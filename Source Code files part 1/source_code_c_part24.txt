Positon &pos);
    SC      ScEnumReset(                   CSnapIns_Positon &pos);

    // ScopeNamespace interface
    SC      ScGetParent(PNODE pNode, PPNODE ppChild);
    SC      ScGetChild(PNODE pNode, PPNODE ppChild);
    SC      ScGetNext(PNODE pNode, PPNODE ppNext);
    SC      ScGetRoot(PPNODE ppRoot);
    SC      ScExpand(PNODE pNode);


    // helpers
private:
    SC      ScGetNode(CMTNode *pMTNode, PPNODE ppOut); // creates a Node interface object for the given MTNode.
    SC      ScGetRootNode(PPNODE ppRootNode);          // Calls above method to get to Root node.

public:
    SC      ScGetNode(PNODE pNode, CMTNode **ppMTNodeOut);

// Operations
public:
    // IScopeTree methods
    STDMETHOD(Initialize)(HWND hwndFrame, IStringTablePrivate* pStringTable);
    STDMETHOD(QueryIterator)(IScopeTreeIter** ppIter);
    STDMETHOD(QueryNodeCallback)(INodeCallback** ppNodeCallback);
    STDMETHOD(CreateNode)(HMTNODE hMTNode, LONG_PTR lViewData, BOOL fRootNode,
                          HNODE* phNode);

    STDMETHOD(CloseView)(int nView);
    STDMETHOD(DeleteView)(int nView);
    STDMETHOD(DestroyNode)(HNODE hNode);
    STDMETHOD(Find)(MTNODEID mID, HMTNODE*  hMTNode);
    STDMETHOD(Find)(MTNODEID mID, CMTNode** ppMTNode);
    STDMETHOD(GetImageList)(PLONG_PTR pImageList);
    STDMETHOD(RunSnapIn)(HWND hwndParent);
    STDMETHOD(GetFileVersion)(IStorage* pstgRoot, int* pnVersion);
    STDMETHOD(GetNodeIDFromBookmark)(HBOOKMARK hbm, MTNODEID* pID, bool& bExactMatchFound);
    STDMETHOD(GetNodeIDFromStream)(IStream *pStm, MTNODEID* pID);
    STDMETHOD(GetNodeFromBookmark)(HBOOKMARK hbm, CConsoleView *pConsoleView, PPNODE ppNode, bool& bExactMatchFound); // get the node from bookmark
    STDMETHOD(GetIDPath)(MTNODEID id, MTNODEID** ppIDs, long* pLength);
    STDMETHOD(IsSynchronousExpansionRequired)();
    STDMETHOD(RequireSynchronousExpansion)(BOOL fRequireSyncExpand);
    STDMETHOD(SetConsoleData)(LPARAM lConsoleData);
    STDMETHOD(GetPathString)(HMTNODE hmtnRoot, HMTNODE hmtnLeaf, LPOLESTR* pPath);
    STDMETHOD(QuerySnapIns)(SnapIns **ppSnapIns);
    STDMETHOD(QueryScopeNamespace)(ScopeNamespace **ppScopeNamespace);
    STDMETHOD(CreateProperties)(Properties** ppProperties);
    STDMETHOD(GetNodeID)(PNODE pNode, MTNODEID *pID);
    STDMETHOD(GetHMTNode)(PNODE pNode, HMTNODE *phMTNode);
    STDMETHOD(GetMMCNode)(HMTNODE hMTNode, PPNODE ppNode);
    STDMETHOD(QueryRootNode)(PPNODE ppNode);
    STDMETHOD(IsSnapinInUse)(REFCLSID refClsidSnapIn, PBOOL pbInUse);

    STDMETHOD(Persist)(HPERSISTOR pPersistor);

    // IPersistStorage methods
    STDMETHOD(HandsOffStorage)(void);
    STDMETHOD(InitNew)(IStorage *pStg);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IStorage *pStg);
    STDMETHOD(Save)(IStorage *pStg, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage *pStg);

    // IPersist method
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // snap-in addition and removal
    SC      ScAddOrRemoveSnapIns(MTNodesList * pmtnDeletedList, NewNodeList * pnnList);
public:
    SC      ScAddSnapin(LPCWSTR szSnapinNameOrCLSID, SnapIn* pParentSnapinNode, Properties* varProperties, SnapIn*& rpSnapIn);


private: // taskpad persistence
    HRESULT LoadTaskpadList(IStorage *pStg);

// Attributes
public:
    CMTNode* GetRoot(void);
    CSPImageCache* GetImageCache(void) { return m_pImageCache; }

    /*
     * convenient, type-safe alternative to IScopeTree::GetImageList
     */
    HIMAGELIST GetImageList () const;

// Operations
    SC   ScInsert(LPSCOPEDATAITEM pSDI, COMPONENTID nID,
                   CMTNode** ppMTNodeNew);
    SC   ScDelete(CMTNode* pmtn, BOOL fDeleteThis, COMPONENTID nID);
    void DeleteNode(CMTNode* pmtn);
    void UpdateAllViews(LONG lHint, LPARAM lParam);
    void Cleanup(void);

    HWND GetMainWindow()
    {
        return (m_pConsoleData->m_hwndMainFrame);
    }

    static IStringTablePrivate* GetStringTable()
    {
        return (m_spStringTable);
    }

    static bool _IsSynchronousExpansionRequired()
    {
        return (m_fRequireSyncExpand);
    }

    static void _RequireSynchronousExpansion(bool fRequireSyncExpand)
    {
        m_fRequireSyncExpand = fRequireSyncExpand;
    }

    static CScopeTree* GetScopeTree()
    {
        return (m_pScopeTree);
    }

    PersistData* GetPersistData() const
    {
        return m_spPersistData;
    }

    SConsoleData* GetConsoleData() const
    {
        return m_pConsoleData;
    }

    CConsoleFrame* GetConsoleFrame() const
    {
        return ((m_pConsoleData != NULL) ? m_pConsoleData->GetConsoleFrame() : NULL);
    }

    CConsoleTaskpadList* GetConsoleTaskpadList() const
    {
        return (m_pConsoleTaskpads);
    }

    CDefaultTaskpadList* GetDefaultTaskpadList() const
    {
        return (m_pDefaultTaskpads);
    }

    SC ScSetHelpCollectionInvalid();

    HRESULT InsertConsoleTaskpad (CConsoleTaskpad *pConsoleTaskpad,
                                  CNode *pNodeTarget, bool bStartTaskWizard);

    SC ScUnadviseMTNode(CMTNode* pMTNode);  // called from ~CMTNode()
    SC ScUnadviseMMCScopeNode(PNODE pNode); // called from ~MMCScopeNode();

// Implementation
private:
    // the one and only CScopeTree for this console
    static CScopeTree*      m_pScopeTree;
    CMTNode*                m_pMTNodeRoot;
    CSPImageCache*          m_pImageCache;
    PersistDataPtr          m_spPersistData;
    CMTNodeList             m_MTNodesToBeReset;
    SConsoleData*           m_pConsoleData;
    CConsoleTaskpadList*    m_pConsoleTaskpads;
    CDefaultTaskpadList*    m_pDefaultTaskpads;
    CMapMTNodeToMMCNode     m_mapMTNodeToMMCNode;

    static bool                     m_fRequireSyncExpand;
    static IStringTablePrivatePtr   m_spStringTable;

    void _DeleteNode(CMTNode* pmtn);
    void _GetPathString(CMTNode* pmtnRoot, CMTNode* pmtnCur, CStr& strPath);
    void DeleteDynamicNodes(CMTNode* pMTNode);
    BOOL ExtensionsHaveChanged(CMTSnapInNode* pMTSINode);
    void HandleExtensionChanges(CMTNode* pMTNode);

// Not implemented
    CScopeTree(const CScopeTree& rhs);
    CScopeTree& operator= (const CScopeTree& rhs);

};  // CScopeTree

#endif // _SCOPTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\siprop.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      siprop.cpp
 *
 *  Contents:  Implementation file for CSnapInPropertiesRoot, et al
 *
 *  History:   04-Nov-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "siprop.h"
#include "variant.h"
#include "mtnode.h"


#ifdef DBG
CTraceTag tagSnapInProps(_T("Snap-in Properties"), _T("Snap-in Properties"));
#endif



/*+=========================================================================*/
/*                                                                          */
/*                         CSnapinPropertyComObject                         */
/*                                                                          */
/*==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CSnapinPropertyComObject
 *
 * This is the COM object that exposes the Property object model interface.
 *--------------------------------------------------------------------------*/

class CSnapinPropertyComObject :
    public CMMCIDispatchImpl<Property>, // the Property interface
    public CTiedComObject<CSnapinProperties>
{
    typedef CSnapinProperties CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CSnapinPropertyComObject)
    END_MMC_COM_MAP()

public:
    // Property interface
    MMC_METHOD1_PARAM (get_Value, VARIANT* /*pvarValue*/, m_key);
    MMC_METHOD1_PARAM (put_Value, VARIANT  /*varValue*/,  m_key);

    STDMETHODIMP get_Name (BSTR* pbstrName)
    {
        DECLARE_SC (sc, _T("CSnapinPropertyComObject::get_Name"));

        /*
         * validate parameters
         */
        sc = ScCheckPointers (pbstrName);
        if (sc)
            return (sc.ToHr());

        /*
         * copy the name
         */
        *pbstrName = SysAllocString (m_key.data());
        if (*pbstrName == NULL)
            return ((sc = E_OUTOFMEMORY).ToHr());

        return (sc.ToHr());
    }

    void SetKey (const CSnapinProperties::CPropertyKey& key)
        { m_key = key; }

private:
    CSnapinProperties::CPropertyKey m_key;
};


/*+=========================================================================*/
/*                                                                          */
/*                     CSnapinProperties implementation                     */
/*                                                                          */
/*==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::FromInterface
 *
 * Returns a pointer to the CSnapinProperties object that implements
 * the given interface, or NULL if the implementing object is not a
 * CSnapinProperties.
 *--------------------------------------------------------------------------*/

CSnapinProperties* CSnapinProperties::FromInterface (IUnknown* pUnk)
{
    CSnapinProperties* pProps;

    pProps = dynamic_cast<CSnapinProperties*>(pUnk);

    return (pProps);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Item
 *
 * Returns an interface to a property identified by bstrName, which must
 * be released by the caller.  If the collection doesn't contain a property
 * with the given name, a new property with the given name (initialized to
 * VT_EMPTY) is added to the collection.
 *
 * Returns:
 *      S_OK            the property was successfully returned
 *      S_FALSE         the property was successfully returned, but didn't
 *                      exist in the collection beforehand, so a new one
 *                      was added
 *      E_INVALIDARG    the property name wasn't valid (i.e. empty) or
 *                      ppProperty was NULL
 *      E_OUTOFMEMORY   not enough memory to perform the operation
 *      E_UNEXPECTED    something dire happened
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::Item (
    BSTR        bstrName,               /* I:name of property to get        */
    PPPROPERTY  ppProperty)             /* O:interface to property          */
{
    DECLARE_SC (sc, _T("CSnapinProperties::Item"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (bstrName, ppProperty);
    if (sc)
        return (sc.ToHr());

    const std::wstring strName = bstrName;
    if (strName.empty())
        return ((sc = E_INVALIDARG).ToHr());

    bool fPropWasAdded = false;

    /*
     * Look up the property.  If it's not there yet, add a new one (maybe).
     */
    if (m_PropMap.find(strName) == m_PropMap.end())
    {
        /*
         * Fail without implicitly adding if we're not attached to a snap-in.
         * This will prevent us from adding properties that weren't
         * registered with AddPropertyName
         */
        if (m_spSnapinProps != NULL)
            return ((sc = ScFromMMC(MMC_E_UnrecognizedProperty)).ToHr());

        /*
         * put an empty property in the map with the given name
         */
        m_PropMap[strName] = CSnapinProperty();
        fPropWasAdded = true;
    }

    /*
     * get a COM object tied to the new property
     */
    sc = ScGetPropertyComObject (strName, *ppProperty);
    if (sc)
        return (sc.ToHr());

    if (*ppProperty == NULL)
        return ((sc = E_UNEXPECTED).ToHr());

    /*
     * if we had to add the property, return S_FALSE so the caller can
     * tell (if he cares)
     */
    if (fPropWasAdded)
        sc = S_FALSE;

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::get_Count
 *
 * Returns the number of properties in the collection in *pCount.
 *
 * Returns:
 *
 *      S_OK            success
 *      E_INVALIDARG    pCount is NULL
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::get_Count (
    PLONG pCount)                   /* O:number of items in the collection  */
{
    DECLARE_SC (sc, _T("CSnapinProperties::get_Count"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (pCount);
    if (sc)
        return (sc.ToHr());

    /*
     * return the number of elements in the property map
     */
    *pCount = m_PropMap.size();

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Remove
 *
 * Removes a property from the collection.
 *
 * Returns:
 *      S_OK            the property was successfully removed
 *      S_FALSE         the property didn't exist in the collection
 *      E_INVALIDARG    the property name wasn't valid (i.e. empty)
 *      E_UNEXPECTED    something dire happened
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::Remove (
    BSTR    bstrName)                   /* I:name of property to remove     */
{
    DECLARE_SC (sc, _T("CSnapinProperties::Remove"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (bstrName);
    if (sc)
        return (sc.ToHr());

    /*
     * find the item to remove
     */
    CPropertyIterator itProp = m_PropMap.find (bstrName);
    if (itProp == m_PropMap.end())
        return ((sc = S_FALSE).ToHr());

    /*
     * see if we can remove it
     */
    if ( itProp->second.IsInitialized() &&
        (itProp->second.GetFlags() & MMC_PROP_REMOVABLE) == 0)
        return ((sc = ScFromMMC(MMC_E_CannotRemoveProperty)).ToHr());

    /*
     * Inform snapin before we remove the property about removal.
     */
    sc = ScNotifyPropertyChange(itProp, itProp->second.GetValue(), MMC_PROPACT_DELETING);
    if (sc)
        return sc.ToHr();

    /*
     * the snap-in approved the change, remove the property
     */
    m_PropMap.erase (itProp);

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinProperties::ScEnumNext
 *
 * PURPOSE: Returns the next Property interface.
 *
 * PARAMETERS:
 *    _Position & key :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CSnapinProperties::ScEnumNext (CPropertyKey &key, PDISPATCH & pDispatch)
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScEnumNext"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    /*
     * get the next element
     */
    CPropertyIterator it = IteratorFromKey (key, false);

    if(it == m_PropMap.end())
        return (sc = S_FALSE); // out of elements.

    /*
     * get the Properties COM object for this property
     */
    PropertyPtr spProperty;
    sc = ScGetPropertyComObject (it->first, *&spProperty);
    if (sc)
        return (sc);

    if (spProperty == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * return the IDispatch for the object and leave a ref on it for the client
     */
    pDispatch = spProperty.Detach();

    // remember the enumeration key for next time
    key = it->first;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScEnumSkip
 *
 * Skips the next celt elements in the properties collection.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScEnumSkip (
    unsigned long   celt,               /* I:number of items to skip        */
    unsigned long&  celtSkipped,        /* O:number of items skipped        */
    CPropertyKey&   key)                /* I/O:enumeration key              */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScEnumSkip"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    /*
     * skip the next celt properties
     */
    CPropertyIterator it = IteratorFromKey (key, false);

    for (celtSkipped = 0;
         (celtSkipped < celt) && (it != m_PropMap.end());
         ++celtSkipped, ++it)
    {
        /*
         * remember the enumeration key for next time
         */
        key = it->first;
    }

    /*
     * if we advanced less than the requested number, return S_FALSE
     */
    if (celtSkipped < celt)
        sc = S_FALSE;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScEnumReset
 *
 * Resets a CPropertyKey so that the next item it will return is the
 * first item in the properties collection.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScEnumReset (
    CPropertyKey&  key)                /* I/O:enumeration key to reset     */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScEnumReset"));

    key.erase();
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::get__NewEnum
 *
 * Creates returns an interface that can be queried for IEnumVARIANT
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::get__NewEnum (IUnknown** ppUnk)
{
    DECLARE_SC (sc, _T("CSnapinProperties::get__NewEnum"));
    Trace (tagSnapInProps, _T("Snap-in Properties"));

    // validate the parameter
    sc = ScCheckPointers (ppUnk);
    if (sc)
        return (sc.ToHr());

    *ppUnk = NULL;

    // typedef the enumerator
    typedef CComObject<CMMCEnumerator<CSnapinProperties, CPropertyKey> > CEnumerator;

    // create an instance of the enumerator
    CEnumerator *pEnum = NULL;
    sc = CEnumerator::CreateInstance (&pEnum);
    if (sc)
        return (sc.ToHr());

    if(!pEnum)
        return ((sc = E_UNEXPECTED).ToHr());

    // create a connection between the enumerator and ourselves
    sc = ScCreateConnection(*pEnum, *this);
    if(sc)
        return (sc.ToHr());

    // initialize the position using the Reset function
    sc = ScEnumReset (pEnum->m_position);
    if(sc)
        return (sc.ToHr());

    // get the IUnknown to return
    sc = pEnum->QueryInterface (IID_IUnknown, (void**) ppUnk);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::IteratorFromKey
 *
 * Returns the iterator in the property map corresponding to the first
 * element following the one designated by key.
 *
 * The caller might be interested in an exact match or the nearest match.
 * The nearest match would be suitable when the key is used in an
 * enumeration.  Let's say that the collection consists of "Alpha", "Bravo",
 * and "Charlie".  The first request for an item will return "Alpha" and
 * the key will hold "Alpha" (see comments for CPropertyKey).  Let's
 * assume that "Alpha" is removed from the collection and then the enumeration
 * continues.  We want to return the one after the last one we got back
 * ("Alpha") which would be "Bravo".  All is well.
 *
 * An exact match would be required when trying to find a CSnapinProperty
 * for a CSnapinPropertyComObject.  The COM object will refer to a specific
 * property, which we want to be sure to find every time.  A close match
 * isn't sufficient.
 *--------------------------------------------------------------------------*/

CSnapinProperties::CPropertyIterator
CSnapinProperties::IteratorFromKey (
    const CPropertyKey& key,            /* I:key to convert                 */
    bool                fExactMatch)    /* I:match key exactly?             */
{
    CPropertyIterator it;

    /*
     * need an exact match?
     */
    if (fExactMatch)
    {
        /*
         * nothing matches an empty key
         */
        if (key.empty())
            it = m_PropMap.end();

        /*
         * the key's not empty, look up the property
         */
        else
            it = m_PropMap.find (key);
    }

    /*
     * nearest match
     */
    else
    {
        /*
         * the beginning of the map is nearest an empty key
         */
        if (key.empty())
            it = m_PropMap.begin();

        /*
         * otherwise, find the nearest one greater than the key
         */
        else
            it = m_PropMap.upper_bound (key);
    }


    return (it);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScInitialize
 *
 * Initializes a CSnapinProperties.  This function will return an error if
 * psip is NULL, or if there's an error copying the initial properties.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScInitialize (
    ISnapinProperties*  psip,           /* I:snap-in's ISnapinProperties iface  */
    Properties*         pInitProps_,    /* I:initial properties for the snap-in */
    CMTSnapInNode*      pMTSnapInNode)  /* I:snap-in these properties belong to */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScInitialize"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (psip);
    if (sc)
        return (sc);

    /*
     * pInitProps_ is optional, but if it was given, it should be the
     * one implemented by CSnapinProperties
     */
    CSnapinProperties* pInitProps = FromInterface (pInitProps_);
    if ((pInitProps_ != NULL) && (pInitProps == NULL))
        return (sc = E_INVALIDARG);

    /*
     * keep the the snap-in and the snap-in's interface
     */
    m_pMTSnapInNode = pMTSnapInNode;
    m_spSnapinProps = psip;

    /*
     * get the names of the properties recognized by the snap-in
     */
    sc = psip->QueryPropertyNames (this);
    if (sc)
        return (sc);

    /*
     * If we're reloading a snap-in's properties from the console file,
     * weed out entries that the snap-in registered last time but didn't
     * register this time.
     */
    if (pInitProps == this)
    {
        CPropertyIterator itProp = m_PropMap.begin();

        while (itProp != m_PropMap.end())
        {
            /*
             * snap-in registered?  keep it
             */
            if (itProp->second.IsRegisteredBySnapin())
                ++itProp;

            /*
             * snap-in didn't register, toss it
             */
            else
                itProp = m_PropMap.erase (itProp);
        }
    }

    /*
     * Otherwise, if we got initial properties, find each property
     * that the snap-in registered in set of initial properties and
     * copy them to the snap-in's collection.
     */
    else if (pInitProps != NULL)
    {
        sc = ScMergeProperties (*pInitProps);
        if (sc)
            return (sc);
    }

    /*
     * initialize the ISnapinProperties interface
     */
    sc = psip->Initialize (this);
    if (sc)
        return (sc);

    /*
     * give the ISnapinProperties its initial property values
     */
    if (!m_PropMap.empty())
    {
        /*
         * Build an array of CSmartProperty objects to pass to
         * ISnapinProperties::PropertiesChanged.  CSmartProperty objects
         * look just like MMC_SNAPIN_PROPERTY structures, but use a
         * CComVariant instead of VARIANT for automatic resource management.
         * See the definition of CSmartProperty.
         */
        CAutoArrayPtr<CSmartProperty> spInitialProps (
                new (std::nothrow) CSmartProperty[m_PropMap.size()]);

        if (spInitialProps == NULL)
            return (sc = E_OUTOFMEMORY);

        CPropertyIterator it = m_PropMap.begin();
        for (int i = 0; it != m_PropMap.end(); ++it, ++i)
        {
            spInitialProps[i].pszPropName = it->first.data();
            spInitialProps[i].varValue    = it->second.GetValue();
            spInitialProps[i].eAction     = MMC_PROPACT_INITIALIZED;
        }

        /*
         * we don't want to trace a failure here, so use a local SC
         */
        SC scLocal = ScNotifyPropertyChange (spInitialProps, m_PropMap.size());
        if (scLocal)
            return (scLocal);
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScSetSnapInNode
 *
 * Attaches this properties collection to a CMTSnapInNode.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScSetSnapInNode (CMTSnapInNode* pMTSnapInNode)
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScSetSnapInNode"));

    m_pMTSnapInNode = pMTSnapInNode;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScMergeProperties
 *
 * Merges the properties from another property collection into this one.
 * Only properties that already exist in the destination collection are
 * copied from the source.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScMergeProperties (const CSnapinProperties& other)
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScMergeProperties"));

    /*
     * for each property in the other collection...
     */
    CConstPropertyIterator itOtherProp;

    for (itOtherProp  = other.m_PropMap.begin();
        (itOtherProp != other.m_PropMap.end()) && !sc.IsError();
         ++itOtherProp)
    {
        /*
         * look for a corresponding property in the our set
         */
        CPropertyIterator itProp = m_PropMap.find (itOtherProp->first);

        /*
         * if it's in our set, copy its value
         */
        if (itProp != m_PropMap.end())
            sc = itProp->second.ScSetValue (itOtherProp->second.GetValue());
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::AddPropertyName
 *
 * This method is called by the snap-in from its implementation of
 * ISnapinProperties::QueryPropertyNames to register the properties it
 * recognizes.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CSnapinProperties::AddPropertyName (
    LPCOLESTR   pszPropName,            /* I:property name                  */
    DWORD       dwFlags)                /* I:flags for this property        */
{
    DECLARE_SC (sc, _T("CSnapinProperties::AddPropertyName"));

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (pszPropName);
    if (sc)
        return (sc.ToHr());

    const std::wstring strName = pszPropName;
    if (strName.empty())
        return ((sc = E_INVALIDARG).ToHr());

    /*
     * make sure no undocumented flags were passed in
     */
    if ((dwFlags & ~CSnapinProperty::PublicFlags) != 0)
        return ((sc = E_INVALIDARG).ToHr());

    /*
     * if the property already exists (from a persisted collection),
     * just update the flags; otherwise add a property with the given
     * name and flags
     */
    CPropertyIterator itProp = m_PropMap.find (strName);

    if (itProp != m_PropMap.end())
        itProp->second.InitializeFlags (dwFlags);
    else
    {
        m_PropMap[strName] = CSnapinProperty(dwFlags);
        m_PropMap[strName].SetRegisteredBySnapin();
    }

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScNotifyPropertyChange
 *
 * Notifies the snap-in that owns this collection of a change to it's
 * properties.  This function delegates the heavy lifting to
 *
 *      ScNotifyPropertyChange (CSmartProperty*, ULONG);
 *
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScNotifyPropertyChange (
    CPropertyIterator   itProp,      /* I:changing property              */
    const VARIANT&      varValue,    /* I:if action is remove then this is current value
                                          else if action is set then this is the proposed value */
    MMC_PROPERTY_ACTION eAction)     /* I:what's happening to the prop?  */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScNotifyPropertyChange"));

    ASSERT(eAction == MMC_PROPACT_CHANGING || eAction == MMC_PROPACT_DELETING);
    /*
     * validate the parameters
     */
    if (itProp == m_PropMap.end())
        return (sc = E_INVALIDARG);

    /*
     * make sure we're allowed to change the property
     */
    if ( itProp->second.IsInitialized() &&
        (itProp->second.GetFlags() & MMC_PROP_MODIFIABLE) == 0)
        return (sc = ScFromMMC (MMC_E_CannotChangeProperty));

    /*
     * if this property change will affect the UI, and the snap-in
     * isn't awake yet, wake him up
     */
    if ((itProp->second.GetFlags() & MMC_PROP_CHANGEAFFECTSUI) &&
        (m_pMTSnapInNode != NULL) &&
        !m_pMTSnapInNode->IsInitialized())
    {
        sc = m_pMTSnapInNode->Init();
        if (sc)
            return (sc);
    }

    /*
     * we don't want to trace failures here, so don't assign to sc
     */
    CSmartProperty SmartProp (itProp->first.data(), varValue, eAction);
    SC scNoTrace = ScNotifyPropertyChange (&SmartProp, 1);
    if (scNoTrace.ToHr() != S_OK)
        return (scNoTrace);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScNotifyPropertyChange
 *
 * Notifies the snap-in that owns this collection of a change to it's
 * properties.
 *
 * The snap-in will return:
 *      S_OK            change was successful
 *      S_FALSE         change was ignored
 *      E_INVALIDARG    a changed property was invalid (e.g. a malformed
 *                      computer name)
 *      E_FAIL          a changed property was valid, but couldn't be used
 *                      (e.g. a valid name for a computer that couldn't be
 *                      located)
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScNotifyPropertyChange (
    CSmartProperty* pProps,             /* I:changing props                 */
    ULONG           cProps)             /* I:how many are there?            */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScNotifyPropertyChange"));

    /*
     * if we're not connected to a snap-in, short out
     */
    if (m_spSnapinProps == NULL)
        return (sc);

    /*
     * validate the parameters
     */
    sc = ScCheckPointers (pProps, E_UNEXPECTED);
    if (sc)
        return (sc);

    if (cProps == 0)
        return (sc = E_UNEXPECTED);

    /*
     * we don't want to trace failures here, so don't assign to sc
     */
    return (m_spSnapinProps->PropertiesChanged (
                            cProps,
                            reinterpret_cast<MMC_SNAPIN_PROPERTY*>(pProps)));
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Scget_Value
 *
 * Returns the value of the property.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::Scget_Value (VARIANT* pvarValue, const CPropertyKey& key)
{
    DECLARE_SC (sc, _T("CSnapinProperties::Scget_Value"));

    /*
     * validate parameters
     */
    pvarValue = ConvertByRefVariantToByValue (pvarValue);
    sc = ScCheckPointers (pvarValue);
    if (sc)
        return (sc);

    /*
     * get the iterator for the requested property
     */
    CPropertyIterator itProp = IteratorFromKey (key, true);
    if (itProp == m_PropMap.end())
        return (sc = E_INVALIDARG);

    /*
     * give it to the caller
     */
    const VARIANT& varValue = itProp->second.GetValue();
    sc = VariantCopy (pvarValue, const_cast<VARIANT*>(&varValue));
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Scput_Value
 *
 * Changes the value of the property.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::Scput_Value (VARIANT varValue, const CPropertyKey& key)
{
    DECLARE_SC (sc, _T("CSnapinProperties::Scput_Value"));

    /*
     * convert possible by-ref VARIANT
     */
    VARIANT* pvarValue = ConvertByRefVariantToByValue (&varValue);
    sc = ScCheckPointers (pvarValue);
    if (sc)
        return (sc);

    /*
     * make sure this is of the type we can persist
     */
    if (!CXMLVariant::IsPersistable(pvarValue))
        return (sc = E_INVALIDARG);

    /*
     * get the iterator for the requested property
     */
    CPropertyIterator itProp = IteratorFromKey (key, true);
    if (itProp == m_PropMap.end())
        return (sc = E_INVALIDARG);

    /*
     * Notify the snap-in of the proposed change.
     */
    sc = ScNotifyPropertyChange (itProp, *pvarValue, MMC_PROPACT_CHANGING);
    if (sc)
        return sc;

    /*
     * the snap-in approved the change, update the property value
     */
    sc = itProp->second.ScSetValue (*pvarValue);
    if (sc)
        return (sc);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::ScGetPropertyComObject
 *
 * Returns a Property interface on a COM object tied to property identified
 * by key.  The returned interface is a tear-off interface.  The collection
 * will not hold a reference to it, but instead will generate a new object
 * for each request for a Property.
 *--------------------------------------------------------------------------*/

SC CSnapinProperties::ScGetPropertyComObject (
    const CPropertyKey& key,            /* I:the key for this property      */
    Property*&          rpProperty)     /* O:the Property interface         */
{
    DECLARE_SC (sc, _T("CSnapinProperties::ScGetPropertyComObject"));

    /*
     * create a CSnapinPropertyComObject if necessary
     */
    CSnapinPropertyComObject* pComObj = NULL;
    typedef CTiedComObjectCreator<CSnapinPropertyComObject> ObjectCreator;
    sc = ObjectCreator::ScCreateAndConnect (*this, pComObj);
    if (sc)
        return (sc);

    if (pComObj == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * tell the object what its key is
     */
    pComObj->SetKey (key);

    /*
     * put a ref on for the caller (note that the collection will *not*
     * hold a reference to the property)
     */
    rpProperty = pComObj;
    rpProperty->AddRef();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::Persist
 *
 * Persists the property collection to/from an XML persistor.
 *--------------------------------------------------------------------------*/

void CSnapinProperties::Persist (CPersistor &persistor)
{
    if (persistor.IsStoring())
    {
        for (CPropertyIterator it = m_PropMap.begin(); it != m_PropMap.end(); ++it)
        {
            if (it->second.GetFlags() & MMC_PROP_PERSIST)
                PersistWorker (persistor, it);
        }
    }
    else
    {
        /*
         * clear out any existing properties
         */
        m_PropMap.clear();

        // let the base class do the job
        // it will call OnNewElement for every element found
        XMLListCollectionBase::Persist(persistor);
    }
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::PersistWorker
 *
 * Persists an individual element of the CPropertyMap to/from an XML
 * persistor.  It exists solely to prevent CSnapinProperties::Persist from
 * calling W2CT (which implicitly calls _alloca) in a loop.
 *--------------------------------------------------------------------------*/

void CSnapinProperties::PersistWorker (CPersistor& persistor, CPropertyIterator it)
{
    USES_CONVERSION;
    persistor.Persist (it->second, W2CT(it->first.data()));
}


/*+-------------------------------------------------------------------------*
 * CSnapinProperties::OnNewElement
 *
 * XMLListCollectionBase::Persist will call this method for every element
 * to be read from the persistor.
 *--------------------------------------------------------------------------*/

void CSnapinProperties::OnNewElement(CPersistor& persistor)
{
    /*
     * read the property name
     */
    std::wstring strName;
    persistor.PersistAttribute (XML_ATTR_SNAPIN_PROP_NAME, strName);

    /*
     * read the property itself
     */
    USES_CONVERSION;
    CSnapinProperty prop;
    persistor.Persist (prop, W2CT(strName.data()));

    /*
     * put the property in the map
     */
    m_PropMap[strName] = prop;
}


/*+=========================================================================*/
/*                                                                          */
/*                      CSnapinProperty implementation                      */
/*                                                                          */
/*==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CSnapinProperty::Persist
 *
 * Persists the property to/from an XML persistor.
 *--------------------------------------------------------------------------*/

void CSnapinProperty::Persist (CPersistor &persistor)
{
    /*
     * persist the value and flags (but not the private ones)
     */
    DWORD dwFlags;

    if (persistor.IsStoring())
        dwFlags = m_dwFlags & ~PrivateFlags;

    persistor.Persist          (m_varValue);
    persistor.PersistAttribute (XML_ATTR_SNAPIN_PROP_FLAGS, dwFlags);

    if (persistor.IsLoading())
        m_dwFlags = dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\siprop.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      siprop.h
 *
 *  Contents:  Interface file for CSnapinProperties, et al
 *
 *  History:   04-Nov-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef SIPROP_H
#define SIPROP_H
#pragma once

#include "refcount.h"
#include "variant.h"

class CSnapinProperties;


/*+-------------------------------------------------------------------------*
 * CMMCPropertyAction
 *
 * This class is intended to be identical to the MMC_SNAPIN_PROPERTY
 * structure that's sent to ISnapinProperties::PropertiesChanged.
 *
 * It exists to give us intelligent initialization and VARIANT handling
 * through CComVariant.  This makes it much easier to build an array of
 * these things and recover from errors.
 *--------------------------------------------------------------------------*/

class CSmartProperty
{
public:
    CSmartProperty() : pszPropName(NULL), eAction(MMC_PROPACT_INITIALIZED)
    {
        /*
         * CSmartProperty must have an identical memory layout to
         * MMC_SNAPIN_PROPERTY.  If any of these asserts fail, that's
         * not the case.
         */
        COMPILETIME_ASSERT (sizeof (CSmartProperty) == sizeof (MMC_SNAPIN_PROPERTY));
        COMPILETIME_ASSERT (sizeof (CComVariant)    == sizeof (VARIANT));
        COMPILETIME_ASSERT (offsetof (CSmartProperty,  pszPropName) == offsetof (MMC_SNAPIN_PROPERTY, pszPropName));
        COMPILETIME_ASSERT (offsetof (CSmartProperty,  varValue)    == offsetof (MMC_SNAPIN_PROPERTY, varValue));
        COMPILETIME_ASSERT (offsetof (CSmartProperty,  eAction)     == offsetof (MMC_SNAPIN_PROPERTY, eAction));
    }

    CSmartProperty (
        LPCOLESTR           pszPropName_,
        const VARIANT&      varValue_,
        MMC_PROPERTY_ACTION eAction_)
        :   pszPropName (pszPropName_),
            varValue    (varValue_),
            eAction     (eAction_)
    {}

public:
    LPCOLESTR           pszPropName;    // name of property
    CComVariant         varValue;       // value of the property
    MMC_PROPERTY_ACTION eAction;        // what happened to this property
};


/*+-------------------------------------------------------------------------*
 * CSnapinProperty
 *
 * Implements a single property in a properties collection.
 *--------------------------------------------------------------------------*/

class CSnapinProperty : public CTiedObject, public CXMLObject
{
public:
    enum
    {
        MMC_PROP_REGISTEREDBYSNAPIN = 0x80000000,

        PrivateFlags = MMC_PROP_REGISTEREDBYSNAPIN,
        PublicFlags  = MMC_PROP_CHANGEAFFECTSUI |
                       MMC_PROP_MODIFIABLE      |
                       MMC_PROP_REMOVABLE       |
                       MMC_PROP_PERSIST,
    };

public:
    CSnapinProperty (DWORD dwFlags = 0) : m_dwFlags (dwFlags), m_fInitialized (dwFlags != 0)
    {
        /*
         * public and private flags shouldn't overlap
         */
        COMPILETIME_ASSERT ((PublicFlags & PrivateFlags) == 0);
    }
    // default destruction, copy construction and assignment are suitable

    const VARIANT& GetValue () const
        { return (m_varValue); }

    SC ScSetValue (const VARIANT& varValue)
    {
        /*
         * use CComVariant::Copy instead of assignment so we'll have access
         * to a return code
         */
        return (m_varValue.Copy (&varValue));
    }

    DWORD GetFlags () const
        { return (m_dwFlags); }

    void InitializeFlags (DWORD dwFlags)
    {
        // only init once
        if (!IsInitialized())
        {
            m_dwFlags      = (dwFlags & PublicFlags) | MMC_PROP_REGISTEREDBYSNAPIN;
            m_fInitialized = true;
        }
    }

    bool IsRegisteredBySnapin () const
        { return (m_dwFlags & MMC_PROP_REGISTEREDBYSNAPIN); }

    bool IsInitialized () const
        { return (m_fInitialized); }

    void SetRegisteredBySnapin()
        { m_dwFlags |= MMC_PROP_REGISTEREDBYSNAPIN; }

    // CXMLObject methods
    DEFINE_XML_TYPE(XML_TAG_SNAPIN_PROPERTY);
    virtual void Persist(CPersistor &persistor);

private:
    CXMLVariant         m_varValue;             // value of the property
    DWORD               m_dwFlags;              // flags for the property
    bool                m_fInitialized;         // initialized yet?
};


/*+-------------------------------------------------------------------------*
 * CSnapinProperties
 *
 * Implementation class for properties collections.  It implements Properties
 * and ISnapinPropertiesCallback, as well as the methods required to support
 * enumeration through CMMCEnumerator.
 *
 * Note that there is not a tied COM object to support Properties; that is
 * implemented here.  This class can, however, be tied to tied COM objects
 * implementing the collection enumerator.
 *--------------------------------------------------------------------------*/

class CSnapinProperties :
    public ISnapinPropertiesCallback,
    public CMMCIDispatchImpl<Properties>, // the Properties interface
    public CTiedObject,
    public XMLListCollectionBase
{
    BEGIN_MMC_COM_MAP(CSnapinProperties)
        COM_INTERFACE_ENTRY(ISnapinPropertiesCallback)
    END_MMC_COM_MAP()

public:
    CSnapinProperties() : m_pMTSnapInNode(NULL) {}

    typedef std::map<std::wstring, CSnapinProperty> CPropertyMap;

    /*
     * When used for enumeration, an key represents the most recent item
     * returned.  When a new enumerator is created, the key will be empty,
     * signifiying that nothing has been returned yet.  After returning Item1,
     * the key will point to Item1, and the next call to return an item will
     * find the next item in the collection after Item1.  This will allow us
     * to correctly enumerate if Item1 is removed from the collection between
     * calls to retrieve Item1 and Item2.
     *
     * When used to identify a property, the key is the name of the property.
     */
    typedef CPropertyMap::key_type CPropertyKey;

private:
    typedef CPropertyMap::iterator          CPropertyIterator;
    typedef CPropertyMap::const_iterator    CConstPropertyIterator;

public:
    ::SC ScInitialize (ISnapinProperties* psip, Properties* pInitialProps, CMTSnapInNode* pMTSnapInNode);
    ::SC ScSetSnapInNode (CMTSnapInNode* pMTSnapInNode);

    static CSnapinProperties* FromInterface (IUnknown* pUnk);

public:
    // ISnapinPropertiesCallback interface
    STDMETHOD(AddPropertyName) (LPCOLESTR pszPropName, DWORD dwFlags);

    // Properties interface
    STDMETHOD(Item)      (BSTR bstrName, PPPROPERTY ppProperty);
    STDMETHOD(get_Count) (PLONG pCount);
    STDMETHOD(Remove)    (BSTR bstrName);
    STDMETHOD(get__NewEnum)  (IUnknown** ppUnk);

    // for support of get__NewEnum and IEnumVARIANT via CMMCNewEnumImpl
    ::SC ScEnumNext  (CPropertyKey &key, PDISPATCH & pDispatch);
    ::SC ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, CPropertyKey &key);
    ::SC ScEnumReset (CPropertyKey &key);

    // Property interface
    ::SC Scget_Value (VARIANT* pvarValue, const CPropertyKey& key);
    ::SC Scput_Value (VARIANT  varValue,  const CPropertyKey& key);

    // CXMLObject methods
    DEFINE_XML_TYPE(XML_TAG_SNAPIN_PROPERTIES);
    virtual void OnNewElement(CPersistor& persistor);
    virtual void Persist (CPersistor &persistor);

private:
    ::SC ScGetPropertyComObject (const CPropertyKey& key, Property*& rpProperty);
    ::SC ScMergeProperties      (const CSnapinProperties& other);
    ::SC ScNotifyPropertyChange (CPropertyIterator itProp, const VARIANT& varNewValue, MMC_PROPERTY_ACTION eAction);
    ::SC ScNotifyPropertyChange (CSmartProperty* pProps, ULONG cProps);

    CPropertyIterator IteratorFromKey (const CPropertyKey& key, bool fExactMatch);
    void PersistWorker (CPersistor &persistor, CPropertyIterator it);

protected:
    CPropertyMap            m_PropMap;
    CMTSnapInNode*          m_pMTSnapInNode;
    ISnapinPropertiesPtr    m_spSnapinProps;
};


#endif /* SIPROP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\snapin.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       SnapIn.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/11/1996   RaviR   Created
//
//____________________________________________________________________________



#include "stdafx.h"

#include "util.h"
#include "NodeMgr.h"
#include "regutil.h"
#include "regkeyex.h"
#include "tstring.h"
#include "about.h"
#include "bitmap.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
 * define our own Win64 symbol to make it easy to include 64-bit only
 * code in the 32-bit build, so we can exercise some code on 32-bit Windows
 * where the debuggers are better
 */
#ifdef _WIN64
#define MMC_WIN64
#endif

#ifdef MMC_WIN64
#include "wow64reg.h"	// for REG_OPTION_OPEN_32BITKEY
#endif

#ifdef DBG
#ifdef MMC_WIN64
CTraceTag  tagSnapinAnalysis64        (_T("64/32-bit interop"), _T("Snap-in analysis"));
CTraceTag  tagVerboseSnapinAnalysis64 (_T("64/32-bit interop"), _T("Snap-in analysis (verbose)"));
#endif	// MMC_WIN64
#endif


/*+-------------------------------------------------------------------------*
 * tstringFromCLSID
 *
 * Returns the text representation of a CLSID in a tstring.
 *--------------------------------------------------------------------------*/

tstring tstringFromCLSID (REFCLSID clsid)
{
    WCHAR wzCLSID[40];
    int nChars = StringFromGUID2 (clsid, wzCLSID, countof(wzCLSID));
    if (nChars == 0)
        return tstring();

    USES_CONVERSION;
    return (W2T (wzCLSID));
}


/*+-------------------------------------------------------------------------*
 * GetModuleVersion
 *
 * Reads the version resource in a module and returns the version string.
 *--------------------------------------------------------------------------*/

DWORD GetModuleVersion (LPCTSTR pszModule, LPTSTR pszBuffer, int cchBuffer)
{
    DECLARE_SC(sc, TEXT("GetModuleVersion"));

    // check parameters    
    sc = ScCheckPointers(pszModule, pszBuffer);
    if(sc)
        return 0;

    // validate the buffer
    BufferCchValidate(pszBuffer, cchBuffer);

    static bool  fAttemptedVersionDllLoad = false;
    static DWORD (APIENTRY* pfnGetFileVersionInfoSize)(LPCTSTR, LPDWORD)          = NULL;
    static BOOL  (APIENTRY* pfnGetFileVersionInfo)(LPCTSTR, DWORD, DWORD, LPVOID) = NULL;
    static BOOL  (APIENTRY* pfnVerQueryValue)(LPBYTE, LPCTSTR, LPVOID*, PUINT)    = NULL;

    if (!fAttemptedVersionDllLoad)
    {
        /*
         * only try once
         */
        fAttemptedVersionDllLoad = true;

        HINSTANCE hinst = LoadLibrary (_T("version.dll"));

        if (hinst != NULL)
        {
#ifdef UNICODE
            (FARPROC&)pfnGetFileVersionInfoSize = GetProcAddress (hinst, "GetFileVersionInfoSizeW");
            (FARPROC&)pfnGetFileVersionInfo     = GetProcAddress (hinst, "GetFileVersionInfoW");
            (FARPROC&)pfnVerQueryValue          = GetProcAddress (hinst, "VerQueryValueW");
#else
            (FARPROC&)pfnGetFileVersionInfoSize = GetProcAddress (hinst, "GetFileVersionInfoSizeA");
            (FARPROC&)pfnGetFileVersionInfo     = GetProcAddress (hinst, "GetFileVersionInfoA");
            (FARPROC&)pfnVerQueryValue          = GetProcAddress (hinst, "VerQueryValueA");
#endif
        }
    }

    *pszBuffer = 0;

    if (pfnGetFileVersionInfoSize != NULL)
    {
        ASSERT (pfnGetFileVersionInfo != NULL);
        ASSERT (pfnVerQueryValue      != NULL);

        ULONG lUnused;
        DWORD cbVerInfo = pfnGetFileVersionInfoSize (pszModule, &lUnused);

        if (cbVerInfo > 0)
        {
            LPBYTE pbVerInfo = new BYTE[cbVerInfo];
            VS_FIXEDFILEINFO* pffi;

            if (pfnGetFileVersionInfo != NULL && pfnVerQueryValue != NULL &&
                pfnGetFileVersionInfo (pszModule, NULL, cbVerInfo, pbVerInfo) &&
                pfnVerQueryValue (pbVerInfo, _T("\\"), (void**) &pffi, (UINT*)&lUnused))
            {
                SC sc = StringCchPrintf (pszBuffer, cchBuffer, _T("%d.%d.%d.%d"),
                          HIWORD (pffi->dwFileVersionMS),
                          LOWORD (pffi->dwFileVersionMS),
                          HIWORD (pffi->dwFileVersionLS),
                          LOWORD (pffi->dwFileVersionLS));
                if(sc)
                    return 0;
            }

            delete[] pbVerInfo;
        }
    }

    return (lstrlen (pszBuffer));
}


/*+-------------------------------------------------------------------------*
 * SafeWriteProfileString
 *
 *
 *--------------------------------------------------------------------------*/

inline void SafeWritePrivateProfileString (
    LPCTSTR pszSection,
    LPCTSTR pszKey,
    LPCTSTR psz,
    LPCTSTR pszFile)
{
    if (!WritePrivateProfileString (pszSection, pszKey, psz, pszFile))
        THROW_ON_FAIL (HRESULT_FROM_WIN32 (GetLastError()));
}


//____________________________________________________________________________
//
//  Member:     CSnapIn::CSnapIn, Constructor
//
//  History:    9/19/1996   RaviR   Created
//____________________________________________________________________________
//

// {E6DFFF74-6FE7-11d0-B509-00C04FD9080A}
const GUID IID_CSnapIn =
{ 0xe6dfff74, 0x6fe7, 0x11d0, { 0xb5, 0x9, 0x0, 0xc0, 0x4f, 0xd9, 0x8, 0xa } };

// {7A85B79C-BDED-11d1-A4FA-00C04FB6DD2C}
static const GUID GUID_EnableAllExtensions =
{ 0x7a85b79c, 0xbded, 0x11d1, { 0xa4, 0xfa, 0x0, 0xc0, 0x4f, 0xb6, 0xdd, 0x2c } };

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapIn);

CSnapIn::CSnapIn()
    :m_pExtSI(NULL), m_dwFlags(SNAPIN_ENABLE_ALL_EXTS), m_ExtPersistor(*this)
{
    TRACE_CONSTRUCTOR(CSnapIn);

#ifdef DBG
    dbg_cRef = 0;
#endif

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapIn);
}


CSnapIn::~CSnapIn()
{
    DECLARE_SC(sc, TEXT("CSnapIn::~CSnapIn"));

    Dbg(DEB_USER1, _T("CSnapIn::~CSnapIn\n"));

    sc = ScDestroyExtensionList();
    if (sc)
    {
    }

#ifdef DBG
    ASSERT(dbg_cRef <= 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapIn);
}


DEBUG_DECLARE_INSTANCE_COUNTER(CExtSI);

CExtSI::CExtSI(CSnapIn* pSnapIn)
    : m_pSnapIn(pSnapIn), m_pNext(NULL), m_dwFlags(0)
{
    ASSERT(pSnapIn != NULL);
    m_pSnapIn->AddRef();

    DEBUG_INCREMENT_INSTANCE_COUNTER(CExtSI);
}

CExtSI::~CExtSI(void)
{
    SAFE_RELEASE(m_pSnapIn);
    delete m_pNext;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CExtSI);
}


CSnapInsCache::CSnapInsCache()
    : m_bIsDirty(FALSE), m_bUpdateHelpColl(false)
{
}

CSnapInsCache::~CSnapInsCache()
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::~CSnapInsCache"));

    // destruction will remove all snapins, but ask them to release extensions first,
    // this will break all circular references (else such snapins objects will be leaked).
    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        // get pointer to the snapin
        CSnapIn* pSnapIn = it->second;
        sc = ScCheckPointers( pSnapIn, E_UNEXPECTED );
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        // ask snapin to destroy extension list
        sc = pSnapIn->ScDestroyExtensionList();
        if (sc)
            sc.TraceAndClear();
    }
}


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScIsDirty
 *
 * PURPOSE: returns dirty status of Snapin Cache
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code [SC(S_OK) - if dirty, SC(S_FALSE) else]
 *
\***************************************************************************/
SC CSnapInsCache::ScIsDirty()
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScIsDirty"));

    TraceDirtyFlag(TEXT("CSnapInsCache"), m_bIsDirty);
    sc = m_bIsDirty ? SC(S_OK) : SC(S_FALSE);

    return sc;
}

void CSnapInsCache::SetDirty(BOOL bIsDirty)
{
    m_bIsDirty = bIsDirty;
}


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::Purge
 *
 * PURPOSE: Cleanup Snapin Cache by usage information
 *          Uses sphisticated algorithm to find out which snapins are not used
 *          see ScMarkExternallyReferencedSnapins() for description
 *          removes snapins which are not referenced externally
 *
 * PARAMETERS:
 *    BOOL bExtensionsOnly
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CSnapInsCache::Purge(BOOL bExtensionsOnly)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::Purge"));

    int iSnapIn;

    // Delete all extensions marked as deleted
    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        CSnapIn* pSnapIn = it->second;
        ASSERT(pSnapIn != NULL);
        if (it->second != NULL)
            it->second->PurgeExtensions();
    }

    if (bExtensionsOnly)
        return;

    // Delete all snapins that have no external references
    sc = ScMarkExternallyReferencedSnapins();
    if (sc)
        return; // error occured - do not remove anything

    // remove not referenced
    for ( it = m_snapins.begin(); it != m_snapins.end(); )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return;

        bool bExternallyReferenced;
        sc = pSnapin->ScTempState_IsExternallyReferenced( bExternallyReferenced );
        if (sc)
            return;

        if ( !bExternallyReferenced )
        {
            // destory extension list - it will break all circular references if such exist
            // (note- extension list is not needed anymore - snapin is not used anyway)
            sc = pSnapin->ScDestroyExtensionList();
            if (sc)
                return;

            // remove snapin from the cache;
            // in combination with the call above this will delete the object.
            it = m_snapins.erase( it );
        }
        else
        {
            ++it; // go to the next snapin
        }
    }
}

/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScMarkExternallyReferencedSnapins
 *
 * PURPOSE: Marks all snapins in cache according to presence of external references
 *          This is done by following algorithm:
 *          1) For each snapin in the cache, all extensions have a temporary reference
 *              count incremented. Thus, at the end of this step, each snapin's temp
 *              ref count is equal to the number of snapins it extends.

            2) Each snapin compares the temp reference count to the total number of 
               references to it, taking into account the fact that the snapin cache
               itself holds a reference to each snapin. If the total references exceed
               the temp references, this indicates that the snapin has one or more 
               external references to it.
 *          Such a snapin is marked as "Externally referenced" as well as all its 
 *          extensions.
 *
 *          At the end of the process each snapin has a boolean flag indicating if
 *          the snapin is externally referenced. This flag is used in subsequential cache cleanup,
 *          or help topic building operation.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScMarkExternallyReferencedSnapins()
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScMarkExternallyReferencedSnapins"));

    // 1. reset the reference calculation data
    for ( map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pSnapin->ScTempState_ResetReferenceCalculationData();
        if (sc)
            return sc;
    }

    // 2. update internal reference counts
    for ( it = m_snapins.begin(); it != m_snapins.end(); ++it )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pSnapin->ScTempState_UpdateInternalReferenceCounts();
        if (sc)
            return sc;
    }

    // now the snapins which have more references than internal ones do clearly
    // have direct external references
    // we can mark them and their extensions as "referenced"

    // 3. mark snapins with external references
    // Note: this step must occur after step 2 completes for ALL snapins.
    for ( it = m_snapins.begin(); it != m_snapins.end(); ++it )
    {
        CSnapIn *pSnapin = it->second;
        sc = ScCheckPointers( pSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pSnapin->ScTempState_MarkIfExternallyReferenced();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScGetSnapIn
 *
 * PURPOSE: either finds the snapin in cache , either creates the new one
 *
 * PARAMETERS:
 *    REFCLSID rclsid       - class id of snapin
 *    CSnapIn** ppSnapIn    - result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScGetSnapIn(REFCLSID rclsid, CSnapIn** ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScGetSnapIn"));

    // first - parameter check
    sc = ScCheckPointers(ppSnapIn);
    if (sc)
        return sc;

    // second - initialization
    *ppSnapIn = NULL;

    //
    //  See if it already exists.
    //
    sc = ScFindSnapIn(rclsid, ppSnapIn);
    if (!sc.IsError())
        return sc;  // jus return OK if we have it

    //
    // Create a new one & cache it
    //
    try
    {
        // Allocate the object
        CComObject<CSnapIn> *pSnapin = NULL;
        sc = CComObject<CSnapIn>::CreateInstance(&pSnapin);
        if (sc)
            return sc;

        // be sure we didn't get the NULL
        sc = ScCheckPointers(pSnapin, E_UNEXPECTED);
        if (sc)
            return sc;

        CSnapInPtr spSnapin = pSnapin;


        // Copy the object impl clsid
        spSnapin->SetSnapInCLSID(rclsid);

        //
        // Cache the object.
        //
        // note - this insertion also AddRef's the pointer
        m_snapins[rclsid] = spSnapin;

        *ppSnapIn = spSnapin.Detach(); // transfer reference to caller
    }
    catch( std::bad_alloc )
    {
        sc = E_OUTOFMEMORY;
    }

    return sc;
}

#ifdef DBG
void CSnapInsCache::DebugDump(void)
{
    TRACE(_T("===========Dump of SnapinsCache ===============\n"));

    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        OLECHAR strGUID[64];

        CSnapIn* pSnapIn = it->second;

        StringFromGUID2(pSnapIn->GetSnapInCLSID(), strGUID, countof(strGUID));
        #ifdef DBG
        TRACE(_T("%s: RefCnt = %d, %s\n"), strGUID, pSnapIn->m_dwRef,
                pSnapIn->HasNameSpaceChanged() ? _T("NameSpace changed") : _T("No change"));
        #endif

        CExtSI* pExt = pSnapIn->GetExtensionSnapIn();
        while (pExt != NULL)
        {
            StringFromGUID2(pExt->GetSnapIn()->GetSnapInCLSID(), strGUID, countof(strGUID));
            #ifdef DBG
            // TODO: go to registry to see the type of extension:
            // these flags are not updated consistently
            TRACE(_T("    %s: %s%s  Extends(%s%s%s%s)\n"), strGUID,
                pExt->IsNew() ? _T("New ") : _T(""),
                pExt->IsMarkedForDeletion()  ? _T("Deleted ")   : _T(""),
                pExt->ExtendsNameSpace()     ? _T("NameSpace ") : _T(""),
                pExt->ExtendsContextMenu()   ? _T("Menu ")      : _T(""),
                pExt->ExtendsToolBar()       ? _T("ToolBar ")   : _T(""),
                pExt->ExtendsPropertySheet() ? _T("Properties") : _T(""),
                pExt->ExtendsView()          ? _T("View")       : _T(""),
                pExt->ExtendsTask()          ? _T("Task")       : _T("")
                );
            #endif

                pExt = pExt->Next();
        }
    }
}

#endif // DBG


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScFindSnapIn
 *
 * PURPOSE: finds the snapin by class id and returns AddRef'ed pointer
 *
 * PARAMETERS:
 *    REFCLSID rclsid       - class id of the snapin
 *    CSnapIn** ppSnapIn    - resulting pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScFindSnapIn(REFCLSID rclsid, CSnapIn** ppSnapIn)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScFindSnapIn"));

    // first - parameter check
    sc = ScCheckPointers(ppSnapIn);
    if (sc)
        return sc;

    // second - initialization
    *ppSnapIn = NULL;

    // and now wee will se if we have one
    map_t::iterator it = m_snapins.find(rclsid);

    if (it == m_snapins.end())
        return E_FAIL; // not assigning to sc, since it's not really an error condition

    // be sure we do not return the NULL
    sc = ScCheckPointers(it->second, E_UNEXPECTED);
    if (sc)
        return sc;

    *ppSnapIn = it->second;
    (*ppSnapIn)->AddRef();

    return sc;
}


#ifdef TEMP_SNAPIN_MGRS_WORK
// Get all extensions.
void CSnapInsCache::GetAllExtensions(CSnapIn* pSI)
{
    if (!pSI)
        return;

    CExtensionsCache extnsCache;
    HRESULT hr = MMCGetExtensionsForSnapIn(pSI->GetSnapInCLSID(), extnsCache);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return;

    CExtensionsCacheIterator it(extnsCache);

    for (; it.IsEnd() == FALSE; it.Advance())
    {
        CSnapInPtr spSITemp;
        hr = GetSnapIn(it.GetKey(), &spSITemp);
        ASSERT(SUCCEEDED(hr));
        pSI->AddExtension(spSITemp);
    }
}
#endif // TEMP_SNAPIN_MGRS_WORK


/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScSave
 *
 * PURPOSE:     saves contents of Snapin Cache to IStream
 *
 * PARAMETERS:
 *    IStream* pStream  - save to this stream
 *    BOOL bClearDirty  - reset dirty flag after save
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScSave(IStream* pStream, BOOL bClearDirty)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScSave"));

    // check the params
    sc = ScCheckPointers(pStream);
    if (sc)
        return sc;

    // iterate ans save all snapins
    for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
    {
        CSnapIn* pSnapIn = it->second;
        ASSERT(pSnapIn != NULL);
        if (pSnapIn != NULL)
        {
            sc = pSnapIn->Save(pStream, bClearDirty);
            if (sc)
                return sc;
        }
    }

    // terminating marker
    ULONG bytesWritten;
    sc = pStream->Write(&GUID_NULL, sizeof(GUID_NULL), &bytesWritten);
    if (sc)
        return sc;

    ASSERT(bytesWritten == sizeof(GUID_NULL));

    if (bClearDirty)
        SetDirty(FALSE);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapInsCache::Persist
 *
 * PURPOSE: Persists the CSnapInsCache to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInsCache::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
        for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
        {
            CSnapIn* pSnapIn = it->second;
            ASSERT(pSnapIn != NULL);
            if (pSnapIn != NULL)
                persistor.Persist(*pSnapIn);
        }
    else
    {
        XMLListCollectionBase::Persist(persistor);
        SetDirty(FALSE);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapInsCache::OnNewElement
 *
 * PURPOSE: called for each saved instance found in XML file.
 *          creates and uploads new snapin entry
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapInsCache::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::OnNewElement"));
    ASSERT(persistor.IsLoading());

    CLSID clsid;
    CPersistor persistorSnapin(persistor, XML_TAG_SNAPIN);
    persistor.PersistAttribute(XML_ATTR_SNAPIN_CLSID, clsid);

    // create and upload snapin
    CSnapInPtr spSnapIn;
    sc = ScGetSnapIn(clsid, &spSnapIn);
    if (sc) // failed to creatre
        sc.Throw();
    if (spSnapIn != NULL)
        spSnapIn->PersistLoad(persistor,this);
    else // OK reported, pointer still NULL
        sc.Throw(E_POINTER);
}

/***************************************************************************\
 *
 * METHOD:  CSnapInsCache::ScLoad
 *
 * PURPOSE:     loads snapin cache from IStream
 *
 * PARAMETERS:
 *    IStream* pStream  - stream to load from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapInsCache::ScLoad(IStream* pStream)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::ScLoad"));

    // parameter check
    sc = ScCheckPointers(pStream);
    if (sc)
        return sc;

    // loop thru saved snapins...
    do
    {
        CLSID clsid;
        ULONG bytesRead;
        sc = pStream->Read(&clsid, sizeof(clsid), &bytesRead);
        if (sc)
            return sc;

        ASSERT(bytesRead == sizeof(clsid));

        // ... until special marker is found
        if (clsid == GUID_NULL)
        {
            SetDirty(FALSE);
            return S_OK;
        }

        // creale new snapin
        CSnapInPtr spSnapIn;
        sc = ScGetSnapIn(clsid, &spSnapIn);
        if (sc)
            return sc;

        // recheck the pointer
        sc = ScCheckPointers(spSnapIn, E_UNEXPECTED);
        if (sc)
            return sc;

        // load the contents of snapin
        sc = spSnapIn->Load(this, pStream);
        if (sc)
            return sc;
    } while (true);
    return E_FAIL; // shouldl never get here.
}


static void WriteSnapInCLSID (
    CSnapIn*    pSnapIn,
    LPCTSTR     pszSection,
    LPCTSTR     pszKeyPrefix,
    LPCTSTR     pszFilename)
{
    tstring strKey = _T("CLSID");

    if (pszKeyPrefix != NULL)
        strKey = pszKeyPrefix + strKey;

    tstring strCLSID = tstringFromCLSID (pSnapIn->GetSnapInCLSID());
    SafeWritePrivateProfileString (pszSection, strKey.data(), strCLSID.data(), pszFilename);
}


static void WriteSnapInName (
    CSnapIn*    pSnapIn,
    LPCTSTR     pszSection,
    LPCTSTR     pszKeyPrefix,
    LPCTSTR     pszFilename)
{
    tstring strKey = _T("Name");

    if (pszKeyPrefix != NULL)
        strKey = pszKeyPrefix + strKey;

	WTL::CString strName;
	SC sc = pSnapIn->ScGetSnapInName (strName);

    if (sc.IsError() || strName.IsEmpty())
        strName = _T("<unknown>");

    SafeWritePrivateProfileString (pszSection, strKey.data(), strName, pszFilename);
}


static void AppendString (tstring& str, LPCTSTR pszToAppend)
{
    if (!str.empty())
        str += _T(", ");

    str += pszToAppend;
}


static void WriteExtensionType (
    DWORD       dwExtensionFlags,
    LPCTSTR     pszSection,
    LPCTSTR     pszKeyPrefix,
    LPCTSTR     pszFilename)
{
    tstring strKey = _T("Type");

    if (pszKeyPrefix != NULL)
        strKey = pszKeyPrefix + strKey;

    struct {
        CExtSI::EXTSI_FLAGS flag;
        LPCTSTR             pszDescription;
    } FlagMap[] = {
        {   CExtSI::EXT_TYPE_REQUIRED,      _T("required")          },
        {   CExtSI::EXT_TYPE_STATIC,        _T("static")            },
        {   CExtSI::EXT_TYPE_DYNAMIC,       _T("dynamic")           },
        {   CExtSI::EXT_TYPE_NAMESPACE,     _T("namespace")         },
        {   CExtSI::EXT_TYPE_CONTEXTMENU,   _T("context menu")      },
        {   CExtSI::EXT_TYPE_TOOLBAR,       _T("toolbar")           },
        {   CExtSI::EXT_TYPE_PROPERTYSHEET, _T("property sheet")    },
        {   CExtSI::EXT_TYPE_TASK,          _T("taskpad")           },
        {   CExtSI::EXT_TYPE_VIEW,          _T("view")              },
    };

    tstring strType;

    for (int i = 0; i < countof (FlagMap); i++)
    {
        if (dwExtensionFlags & FlagMap[i].flag)
            AppendString (strType, FlagMap[i].pszDescription);
    }

    SafeWritePrivateProfileString (pszSection, strKey.data(), strType.data(), pszFilename);
}


HRESULT CSnapInsCache::Dump (LPCTSTR pszDumpFile)
{
    DECLARE_SC(sc, TEXT("CSnapInsCache::Dump"));
    static const TCHAR szStandaloneSection[]  = _T("Standalone Snap-ins");
    static const TCHAR szStandaloneCountKey[] = _T("StandaloneCount");

    int cStandalones = 0;

    try
    {
        /*
         * no stand-alone snap-ins found yet (write it now so it's at the
         * beginning of the section, for human readability)
         */
        SafeWritePrivateProfileString (szStandaloneSection, szStandaloneCountKey, _T("0"), pszDumpFile);

        /*
         * dump each snap-in to the file
         */
        for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
        {
            CSnapIn* pSnapIn = it->second;
            sc = ScCheckPointers(pSnapIn);
            if(sc)
            {
                sc.TraceAndClear();
                continue;
            }

            pSnapIn->Dump (pszDumpFile, this);

            /*
             * if this is a stand-alone, update the "Standalone Snap-ins" section
             */
            if (pSnapIn->IsStandAlone())
            {
                TCHAR szKeyPrefix[20];
                sc = StringCchPrintf(szKeyPrefix, countof(szKeyPrefix), _T("Standalone%d."), ++cStandalones);
                if(sc)
                    return sc.ToHr();

                WriteSnapInCLSID (pSnapIn, szStandaloneSection, szKeyPrefix, pszDumpFile);
                WriteSnapInName  (pSnapIn, szStandaloneSection, szKeyPrefix, pszDumpFile);
            }
        }

        /*
         * if we found stand-alones, update the count
         */
        if (cStandalones > 0)
        {
            TCHAR szStandaloneCount[6];
            _itot (cStandalones, szStandaloneCount, 10);
            SafeWritePrivateProfileString (szStandaloneSection, szStandaloneCountKey,
                                           szStandaloneCount, pszDumpFile);
        }
    }
    catch (_com_error& err)
    {
        sc = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * CSnapInsCache::ScCheckSnapinAvailability
 *
 *
 *--------------------------------------------------------------------------*/

SC CSnapInsCache::ScCheckSnapinAvailability (CAvailableSnapinInfo& asi)
{
	DECLARE_SC (sc, _T("CSnapInsCache::ScCheckSnapinAvailability"));

#ifdef MMC_WIN64
	asi.m_cTotalSnapins = m_snapins.size();
	asi.m_vAvailableSnapins.clear();

	/*
	 * destroy any existing imagelist
	 */
	if (asi.m_himl)
		ImageList_Destroy (asi.m_himl);

	/*
	 * if we're interested in 32-bit snap-ins, make sure the registry APIs
	 * go to the 32-bit registry hive.
	 */
	const REGSAM samDesired = (asi.m_f32Bit) ? KEY_READ | REG_OPTION_OPEN_32BITKEY
											 : KEY_READ;

	CRegKey keyClsid;
	sc = ScFromWin32 (keyClsid.Open (HKEY_CLASSES_ROOT, _T("CLSID"), samDesired));
	if (sc)
		return (sc);

	CStr strUnknownSnapinName;
	VERIFY (strUnknownSnapinName.LoadString (GetStringModule(), IDS_UnknownSnapinName));

	/*
	 * create an imagelist, tracing (but not aborting) on failure
	 */
	const int nImageListFolder = 0;
	WTL::CImageList iml;
	if (!iml.Create (IDB_FOLDER_16, 16 /*cx*/, 4 /*cGrow*/, RGB(255,0,255) /*crMask*/))
		sc.FromLastError().TraceAndClear();

	/*
	 * for each snap-in in the cache...
	 */
	for (map_t::iterator it = m_snapins.begin(); it != m_snapins.end(); ++it)
	{
		/*
		 * ...check to see if there's an HKCR\CLSID\{clsid}\InprocServer32
		 * entry for it.  If there is, we'll assume the snap-in is "available".
		 */
		tstring	strSnapinClsid     = tstringFromCLSID (it->first);
		tstring	strInprocServerKey = strSnapinClsid + _T("\\InprocServer32");

		CRegKey keyInprocServer;
		LONG lResult = keyInprocServer.Open (keyClsid, strInprocServerKey.data(), samDesired);
		bool fSnapinAvailable = (lResult == ERROR_SUCCESS);

		/*
		 * if the snap-in's available, get it's name and put it in the
		 * available snap-ins collection
		 */
		if (fSnapinAvailable)
		{
			CBasicSnapinInfo bsi;
			bsi.m_clsid     = it->first;
			CSnapIn*pSnapin = it->second;

			/*
			 * get the snap-in's name
			 */
			WTL::CString strSnapinName;
			if ((pSnapin != NULL) && !pSnapin->ScGetSnapInName(strSnapinName).IsError())
				bsi.m_strName = strSnapinName;
			else
				bsi.m_strName = strUnknownSnapinName;		// "<unknown>"

			/*
			 * Get the snap-in's image from its about object
			 * (failures here aren't fatal and don't need to be traced).
			 * We'll use a generic folder icon if we can't get an image
			 * from the snap-in's about object.
			 */
			CLSID			clsidAbout;
			CSnapinAbout	snapinAbout;

			if (!iml.IsNull())
			{
				if (!ScGetAboutFromSnapinCLSID(bsi.m_clsid, clsidAbout).IsError() &&
					snapinAbout.GetBasicInformation (clsidAbout))	
				{
					/*
					 * the bitmaps returned by GetSmallImages are owned by
					 * the CSnapinAbout object (don't need to delete here)
					 */
					HBITMAP		hbmSmall;
					HBITMAP		hbmSmallOpen;	// unused here, but required for GetSmallImages
					COLORREF	crMask;
					snapinAbout.GetSmallImages (&hbmSmall, &hbmSmallOpen, &crMask);
	
					/*
					 * ImageList_AddMasked will mess up the background of
					 * its input bitmap, but the input bitmap won't be
					 * reused, so we don't need to make a copy like we
					 * usually do.
					 */
					WTL::CBitmap bmpSmall = CopyBitmap (hbmSmall);

					if (!bmpSmall.IsNull())
						bsi.m_nImageIndex = iml.Add (bmpSmall, crMask);
					else
						bsi.m_nImageIndex = nImageListFolder;
				}
				else
					bsi.m_nImageIndex = nImageListFolder;
			}

			/*
			 * put it in the available snap-ins collection
			 */
			asi.m_vAvailableSnapins.push_back (bsi);
		}

#ifdef DBG
		if (fSnapinAvailable)
			Trace (tagVerboseSnapinAnalysis64,
				   _T("  available: %s (image=%d)"),
				   asi.m_vAvailableSnapins.back().m_strName.data(),
				   asi.m_vAvailableSnapins.back().m_nImageIndex);
		else
			Trace (tagVerboseSnapinAnalysis64, _T("unavailable: %s"), strSnapinClsid.data());
#endif
	}

	Trace (tagSnapinAnalysis64, _T("%d-bit snap-in analysis: %d total, %d available"), asi.m_f32Bit ? 32 : 64, asi.m_cTotalSnapins, asi.m_vAvailableSnapins.size());

	/*
	 * give the imagelist to the CAvailableSnapinInfo
	 */
	asi.m_himl = iml.Detach();
#else
	sc = E_NOTIMPL;
#endif	// !MMC_WIN64

	return (sc);
}


void CSnapIn::MarkExtensionDeleted(CSnapIn* pSnapIn)
{
    ASSERT(pSnapIn != NULL);

    CExtSI* pExt = m_pExtSI;

    while (pExt != NULL)
    {
        if (pExt->GetSnapIn() == pSnapIn)
        {
            pExt->MarkDeleted();
            return;
        }

        pExt = pExt->Next();
    }

    // wasn't in the list !
    ASSERT(FALSE);
}


//
// Delete all extensions marked for deletion
// Also reset any New flags
//
void CSnapIn::PurgeExtensions()
{
    CExtSI* pExt = m_pExtSI;
    CExtSI* pExtPrev = NULL;

    // step through linked list, deleting marked nodes
    while (pExt != NULL)
    {
        if (pExt->IsMarkedForDeletion())
        {
            CExtSI *pExtNext = pExt->Next();

            if (pExtPrev)
                pExtPrev->SetNext(pExtNext);
            else
                m_pExtSI = pExtNext;

            // clear next link so extensions doesn't take the whole chain
            // with it when it is deleted
            pExt->SetNext(NULL);
            delete pExt;

            pExt = pExtNext;
        }
        else
        {
            pExt->SetNew(FALSE);

            pExtPrev = pExt;
            pExt = pExt->Next();
        }
    }
}

CExtSI* CSnapIn::FindExtension(const CLSID& rclsid)
{
    CExtSI* pExt = m_pExtSI;
    while (pExt != NULL && !IsEqualCLSID(rclsid, pExt->GetSnapIn()->GetSnapInCLSID()))
    {
        pExt = pExt->Next();
    }

    return pExt;
}


CExtSI* CSnapIn::AddExtension(CSnapIn* pSI)
{

    CExtSI* pExtSI = new CExtSI(pSI);
    ASSERT(pExtSI != NULL);
	if ( pExtSI == NULL )
		return NULL;

    // insert extension in increasing GUID order
    CExtSI* pExtPrev = NULL;
    CExtSI* pExtTemp = m_pExtSI;

    while (pExtTemp != NULL && pExtTemp->GetCLSID() < pExtSI->GetCLSID())
    {
        pExtPrev = pExtTemp;
        pExtTemp = pExtTemp->Next();
    }

    if (pExtPrev == NULL)
    {
        pExtSI->SetNext(m_pExtSI);
        m_pExtSI = pExtSI;
    }
    else
    {
        pExtSI->SetNext(pExtPrev->Next());
        pExtPrev->SetNext(pExtSI);
    }

    // mark as new
    pExtSI->SetNew();

    return pExtSI;
}

HRESULT CSnapIn::Save(IStream* pStream, BOOL fClearDirty)
{
    ASSERT(pStream != NULL);
    if (pStream == NULL)
        return E_INVALIDARG;

    ULONG bytesWritten;
    HRESULT hr = pStream->Write(&GetSnapInCLSID(), sizeof(CLSID), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(CLSID));
    if (FAILED(hr))
        return hr;

    // If all extensions are enabled, then write special guid & flag and return
    if (AreAllExtensionsEnabled())
    {
        hr = pStream->Write(&GUID_EnableAllExtensions, sizeof(GUID), &bytesWritten);
        ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(GUID));
        if (FAILED(hr))
            return hr;

        int iSnapInEnable = DoesSnapInEnableAll() ? 1 : 0;
        hr = pStream->Write(&iSnapInEnable, sizeof(int), &bytesWritten);
        ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(int));

        return hr;
    }


    if (m_pExtSI)
    {
        hr = m_pExtSI->Save(pStream, fClearDirty);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }

    // NULL guid to terminate extensions list
    hr = pStream->Write(&GUID_NULL, sizeof(GUID_NULL), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(GUID_NULL));
    if (FAILED(hr))
        return hr;

    return S_OK;
}


HKEY CSnapIn::OpenKey (REGSAM samDesired /*=KEY_ALL_ACCESS*/) const
{
    MMC_ATL::CRegKey SnapInKey;
    MMC_ATL::CRegKey AllSnapInsKey;

    if (AllSnapInsKey.Open (HKEY_LOCAL_MACHINE, SNAPINS_KEY, samDesired) == ERROR_SUCCESS)
    {
        OLECHAR szItemKey[40];
        int nChars = StringFromGUID2 (m_clsidSnapIn, szItemKey, countof(szItemKey));
        if (nChars == 0)
            return NULL;

        USES_CONVERSION;
        SnapInKey.Open (AllSnapInsKey, OLE2T(szItemKey), samDesired);
    }

    return (SnapInKey.Detach());
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::Persist
 *
 * PURPOSE: Persists the CSnapIn to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
        persistor.PersistAttribute(XML_ATTR_SNAPIN_CLSID, *const_cast<GUID*>(&GetSnapInCLSID()));

    BOOL bAreAllExtensionsEnabled = AreAllExtensionsEnabled();
    persistor.PersistAttribute(XML_ATTR_SNAPIN_EXTN_ENABLED, CXMLBoolean(bAreAllExtensionsEnabled));
    SetAllExtensionsEnabled(bAreAllExtensionsEnabled);

    if(bAreAllExtensionsEnabled) // if all extensions are enabled, don't save anything else.
        return;

    // save the extension information if it exists
    persistor.Persist(m_ExtPersistor);
}

//+-------------------------------------------------------------------
//
//  Member:      CSnapIn::ScGetSnapInName
//
//  Synopsis:    Return the name of this snapin.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapIn::ScGetSnapInName (WTL::CString& strSnapInName) const
{
    DECLARE_SC(sc, _T("CSnapIn::ScGetSnapInName"));

	sc = ScGetSnapinNameFromRegistry (m_clsidSnapIn, strSnapInName);
	if (sc)
		return (sc);

	return (sc);
}


DWORD CSnapIn::GetSnapInModule(TCHAR* szBuffer, DWORD cchBuffer) const
{
    DECLARE_SC(sc, TEXT("CSnapIn::GetSnapInModule"));

    sc = ScCheckPointers(szBuffer);
    if(sc)
        return 0;

    if(!cchBuffer)
    {
        sc = E_FAIL;
        return 0;
    }

    // validate the buffer
    BufferCbValidate(szBuffer, cchBuffer);

    tstring strKeyName = g_szCLSID;
    strKeyName += _T("\\");
    strKeyName += tstringFromCLSID (m_clsidSnapIn);
    strKeyName += _T("\\");
    strKeyName += _T("InprocServer32");

    *szBuffer = 0;

    MMC_ATL::CRegKey keyServer;
    if (keyServer.Open (HKEY_CLASSES_ROOT, strKeyName.data(), KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {
        TCHAR szModule[MAX_PATH];
        DWORD cchModule = countof(szModule);

        if (keyServer.QueryValue (szModule, NULL, &cchModule) == ERROR_SUCCESS)
            ExpandEnvironmentStrings (szModule, szBuffer, cchBuffer);
    }

    return (lstrlen (szBuffer));
}


HRESULT CSnapIn::Load(CSnapInsCache* pCache, IStream* pStream, CExtSI*& pExtSI)
{
    ASSERT(pStream != NULL);
    if (pStream == NULL)
        return E_INVALIDARG;

    // Clear default enabling of all extensions. The true state will be
    // determined from the persisted data.
    SetAllExtensionsEnabled(FALSE);

    // Read CLSID
    CLSID clsid;
    ULONG bytesRead;
    HRESULT hr = pStream->Read(&clsid, sizeof(clsid), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(clsid));
    if (FAILED(hr))
        return hr;

    if (bytesRead != sizeof(clsid))
        return hr = E_FAIL;

    if (clsid == GUID_NULL)
        return S_OK;

    // If special "Enable all" guid encountered, read flag to see if
    // snapin or user enabled all and return
    if (clsid == GUID_EnableAllExtensions)
    {
        SetAllExtensionsEnabled();

        int iSnapInEnable;
        hr = pStream->Read(&iSnapInEnable, sizeof(int), &bytesRead);
        ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(int));

        if (iSnapInEnable)
            SetSnapInEnablesAll();

        return S_OK;
    }

    // Read extension type flags
    DWORD dwExtTypes;
    hr = pStream->Read(&dwExtTypes, sizeof(DWORD), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(DWORD));
    if (FAILED(hr))
        return hr;

    if (pExtSI != NULL)
    {
        hr = Load(pCache, pStream, pExtSI);
        ASSERT(hr == S_OK);
        return hr == S_OK ? S_OK : E_FAIL;
    }

    CSnapInPtr spSnapIn;
    SC sc = pCache->ScGetSnapIn(clsid, &spSnapIn);
    if (sc)
        return sc.ToHr();

    ASSERT(spSnapIn != NULL);

    pExtSI = new CExtSI(spSnapIn);
    ASSERT(pExtSI != NULL);
	if ( pExtSI == NULL )
		return E_OUTOFMEMORY;

    pExtSI->SetExtensionTypes(dwExtTypes);

    hr = Load(pCache, pStream, pExtSI->Next());
    ASSERT(hr == S_OK);
    return hr == S_OK ? S_OK : E_FAIL;
}


HRESULT CSnapIn::Load(CSnapInsCache* pCache, IStream* pStream)
{
    HRESULT hr = Load(pCache, pStream, m_pExtSI);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    return S_OK;
}


bool CSnapIn::IsStandAlone () const
{
    MMC_ATL::CRegKey StandAloneKey;
    MMC_ATL::CRegKey ItemKey;
    ItemKey.Attach (OpenKey (KEY_READ));

    if (ItemKey.m_hKey != NULL)
        StandAloneKey.Open (ItemKey, g_szStandAlone, KEY_READ);

    return (StandAloneKey.m_hKey != NULL);
}


/*+-------------------------------------------------------------------------*
 * CSnapIn::Dump
 *
 * Dumps the information about this snap-in to a INI-style file.  The
 * format is:
 *
 *      [{clsid}]
 *      Name=<NameString from registry>
 *      Module=<dll name>
 *      Version=<dll version number>
 *      Standalone=<1 if standalone, 0 if extension>
 *      ExtensionCount=<number of extensions>
 *      Extension1={clsid} (extension name)
 *      ...
 *      ExtensionN={clsid} (extension name)
 *--------------------------------------------------------------------------*/

HRESULT CSnapIn::Dump (LPCTSTR pszDumpFile, CSnapInsCache* pCache)
{
    DECLARE_SC(sc, TEXT("CSnapIn::Dump"));
    /*
     * use the CLSID as the section name
     */
    const tstring strSection = tstringFromCLSID (m_clsidSnapIn);

    /*
     * write Name
     */
    WriteSnapInName (this, strSection.data(), NULL, pszDumpFile);

    /*
     * write Module
     */
    TCHAR szModule[MAX_PATH];
    bool fFoundModule = (GetSnapInModule (szModule, countof (szModule)) != 0);

    if (!fFoundModule)
    {
        sc = StringCchCopy (szModule, countof(szModule), _T("<unknown>"));
        if(sc)
            return sc.ToHr();
    }

    SafeWritePrivateProfileString (strSection.data(), _T("Module"), szModule, pszDumpFile);

    /*
     * write Version
     */
    TCHAR szVersion[64];
    if (!fFoundModule || !GetModuleVersion (szModule, szVersion, countof(szVersion)))
    {
        sc = StringCchCopy(szVersion, countof(szVersion), _T("<unknown>"));
        if(sc)
            return sc.ToHr();
    }

    SafeWritePrivateProfileString (strSection.data(), _T("Version"), szVersion, pszDumpFile);

    /*
     * write Standalone
     */
    SafeWritePrivateProfileString (strSection.data(), _T("Standalone"),
                                   IsStandAlone() ? _T("1") : _T("0"),
                                   pszDumpFile);

    /*
     * make sure the extension chain has been built
     */
    if (AreAllExtensionsEnabled())
    {
        /*
         * Calling LoadRequiredExtensions with SNAPIN_SNAPIN_ENABLES_ALL set
         * will result in SNAPIN_ENABLE_ALL_EXTS being cleared, which we don't
         * want (rswaney).
         *
         * This happens because we haven't created the snap-in, so we can't
         * pass an IComponentData from which LoadRequiredExtensions can QI
         * for IRequiredExtensions.  LoadRequiredExtensions uses
         * IRequiredExtensions to determine whether SNAPIN_ENABLE_ALL_EXTS
         * should be cleared or set.  Since there's no IRequiredExtensions,
         * SNAPIN_ENABLE_ALL_EXTS would be cleared.
         */
        SetSnapInEnablesAll (false);

        LoadRequiredExtensions (this, NULL, pCache);
    }

    /*
     * write ExtensionCount
     */
    TCHAR szExtCount[8];
    CExtSI* pExt;
    int cExtensions = 0;

    // count the extensions
    for (pExt = m_pExtSI; pExt != NULL; pExt = pExt->Next())
        cExtensions++;

    _itot (cExtensions, szExtCount, 10);
    SafeWritePrivateProfileString (strSection.data(), _T("ExtensionCount"), szExtCount, pszDumpFile);

    /*
     * build up a cache of the extensions for this snap-in
     */
    CExtensionsCache  ExtCache;
    MMCGetExtensionsForSnapIn (m_clsidSnapIn, ExtCache);

    /*
     * write extensions
     */
    int i;
    for (i = 0, pExt = m_pExtSI; i < cExtensions; i++, pExt = pExt->Next())
    {
        TCHAR szKeyPrefix[20];
        sc = StringCchPrintf (szKeyPrefix, countof(szKeyPrefix), _T("Extension%d."), i+1);
        if(sc)
            return sc.ToHr();

        DWORD dwExtFlags = ExtCache[pExt->GetSnapIn()->m_clsidSnapIn];

        WriteSnapInCLSID   (pExt->GetSnapIn(), strSection.data(), szKeyPrefix, pszDumpFile);
        WriteSnapInName    (pExt->GetSnapIn(), strSection.data(), szKeyPrefix, pszDumpFile);
        WriteExtensionType (dwExtFlags,        strSection.data(), szKeyPrefix, pszDumpFile);
    }

    return (S_OK);
}

HRESULT CExtSI::Save(IStream* pStream, BOOL fClearDirty)
{
    ASSERT(pStream != NULL);
    if (pStream == NULL)
        return E_INVALIDARG;

    // Save extension CLSID
    ULONG bytesWritten;
    HRESULT hr = pStream->Write(&GetCLSID(), sizeof(CLSID), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(CLSID));
    if (FAILED(hr))
        return hr;

    // Save extension types
    DWORD dwExtTypes = m_dwFlags & EXT_TYPES_MASK;
    hr = pStream->Write(&dwExtTypes, sizeof(DWORD), &bytesWritten);
    ASSERT(SUCCEEDED(hr) && bytesWritten == sizeof(DWORD));
    if (FAILED(hr))
        return hr;

    if (m_pNext == NULL)
        return S_OK;

    hr = m_pNext->Save(pStream, fClearDirty);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    return S_OK;
}

void CExtSI::Persist(CPersistor& persistor)
{
    // create an "Extension" object beneath the "Extensions" object.
    CPersistor persistorExtension(persistor, XML_TAG_SNAPIN_EXTENSION);

    persistorExtension.PersistAttribute(XML_ATTR_SNAPIN_CLSID, *const_cast<GUID*>(&GetCLSID()));
}

/*+-------------------------------------------------------------------------*
 *
 * CExtSI::PersistNew
 *
 * PURPOSE: called to create and persist new extension entry
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *    CSnapIn& snapParent   : parent to whom the extension belongs
 *    CSnapInsCache& snapCache : cache to put new (extension) snapin to
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CExtSI::PersistNew(CPersistor &persistor, CSnapIn& snapParent, CSnapInsCache& snapCache)
{
    DECLARE_SC(sc, TEXT("CExtSI::PersistNew"));

    CLSID clsid;
    CPersistor persistorExtension(persistor, XML_TAG_SNAPIN_EXTENSION);
    persistorExtension.PersistAttribute(XML_ATTR_SNAPIN_CLSID, clsid);

    CSnapInPtr spSnapIn;
    sc = snapCache.ScGetSnapIn(clsid, &spSnapIn);
    if (sc)
        sc.Throw();

    // create new extension entry
    CExtSI *pExtSI = snapParent.AddExtension(spSnapIn);
    sc = ScCheckPointers(pExtSI,E_FAIL);
    if (sc)
        sc.Throw();

    // upload new extension entry info
    pExtSI->Persist(persistor);
}

const CLSID& CExtSI::GetCLSID()
{
    ASSERT(m_pSnapIn != NULL);
    return m_pSnapIn ? m_pSnapIn->GetSnapInCLSID() : GUID_NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::PersistLoad
 *
 * PURPOSE: provided instead Persist to maintain reference to cache,
 *          required for registering new extensions during loading
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *    CSnapInsCache* pCache : cache to put new (extension) snapin to
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::PersistLoad(CPersistor& persistor,CSnapInsCache* pCache)
{
    m_ExtPersistor.SetCache(pCache);
    persistor.Persist(*this);
    m_ExtPersistor.SetCache(NULL);
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::CExtPersistor::Persist
 *
 * PURPOSE: persists collection of extensions for snapin
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::CExtPersistor::Persist(CPersistor& persistor)
{
    if (persistor.IsStoring())
    {
        CExtSI* pExt = GetParent().GetExtensionSnapIn();
        while (pExt)
        {
            pExt->Persist(persistor);
            pExt = pExt->Next();
        }
    }
    else
    {
        XMLListCollectionBase::Persist(persistor);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapIn::CExtPersistor::OnNewElement
 *
 * PURPOSE: called for each new entry read from XML doc.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CSnapIn::CExtPersistor::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CSnapIn::CExtPersistor::OnNewElement"));

    sc = (persistor.IsLoading() && m_pCache != NULL) ? S_OK : E_FAIL;
    if (sc)
        sc.Throw();

    CExtSI::PersistNew(persistor, m_Parent, *m_pCache);
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScDestroyExtensionList
 *
 * PURPOSE: destroys the list of extensions. used to do preliminary snapin cleanup
 *          to avoid circular references held by the extension sanpin 
 *          locking the objects in the memory.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScDestroyExtensionList()
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScDestroyExtensionList"));

    // check if we have extensions
    if ( m_pExtSI != NULL )
    {
        // assign to auto variable 
        // ( 'this' may not be valid if the only reference is from extension )
        CExtSI *pExtension = m_pExtSI;

        // update member pointer
        m_pExtSI = NULL;

        delete pExtension;
        // delete the extension (it will delete the next and so on)
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_ResetReferenceCalculationData
 *
 * PURPOSE: resets external reference calculation data 
 *          Used as the first step for external reference calculation process
 *
 * PARAMETERS:
 *    
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_ResetReferenceCalculationData( )
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_ResetReferenceCalculationData"));

    m_dwTempState_InternalRef = 0;
    m_bTempState_HasStrongRef = 0;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_UpdateInternalReferenceCounts
 *
 * PURPOSE: Informs snapin's extensions about the references kept to them
 *          Having this information extension snapin can know if it is 
 *          referenced externally
 *
 * PARAMETERS:
 *    
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_UpdateInternalReferenceCounts( )
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_UpdateInternalReferenceCounts"));

    for ( CExtSI* pExtension = m_pExtSI; pExtension; pExtension = pExtension->Next() )
    {
        CSnapIn *pExtensionSnapin = pExtension->GetSnapIn();
        sc = ScCheckPointers( pExtensionSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        pExtensionSnapin->m_dwTempState_InternalRef++;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_SetHasStrongReference
 *
 * PURPOSE: Marks itself as having external strong references (external to snapin cache)
 *          Marks own extensions as well.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_SetHasStrongReference()
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_SetHasStrongReference"));

    // do nothing if already marked (else we'll have the infinite loop)
    if ( m_bTempState_HasStrongRef )
        return sc;

    m_bTempState_HasStrongRef = true;

    // recurse to all extensions (they inherit the strong reference too)
    for ( CExtSI* pExtension = m_pExtSI; pExtension; pExtension = pExtension->Next() )
    {
        CSnapIn *pExtensionSnapin = pExtension->GetSnapIn();
        sc = ScCheckPointers( pExtensionSnapin, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pExtensionSnapin->ScTempState_SetHasStrongReference();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_MarkIfExternallyReferenced
 *
 * PURPOSE: Used as an intermediate step calculating external references
 *          compares internal references to total references.
 *          If has external references, marks itself as 'Externally referenced'
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_MarkIfExternallyReferenced()
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_MarkIfExternallyReferenced"));

    DWORD dwStrongRef = m_dwRef - m_dwTempState_InternalRef - 1/*chache reference*/;

    if ( dwStrongRef > 0 )
    {
        // now mark itself and the extensions as having strong reference
        sc = ScTempState_SetHasStrongReference();
        if (sc)
            return sc;
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CSnapIn::ScTempState_IsExternallyReferenced
 *
 * PURPOSE:  Returns the cached reference status claculated by preceding 
 *           call to CSnapInsCache::ScMarkExternallyReferencedSnapins.
 *
 * PARAMETERS:
 *    bool& bReferenced [out] - true if snapin has external (to snapin cache) strong references
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CSnapIn::ScTempState_IsExternallyReferenced( bool& bReferenced ) const
{
    DECLARE_SC(sc, TEXT("CSnapIn::ScTempState_IsExternallyReferenced"));

    bReferenced = m_bTempState_HasStrongRef;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\snapin.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       SnapIn.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09/09/1996   RaviR   Created
//
//____________________________________________________________________________


//
//  A sample SnapIn registry entry
//
//  SnapIns
//      {d84a45bb-d390-11cf-b607-00c04fd8d565}
//          = REG_SZ "Logs snap-in"
//          Name = REG_SZ "logvwr.dll, 101"
//          NameString = REG_SZ "Logs"
//          Status = REG_SZ "logvwr.dll, 102"
//          StatusString = REG_SZ "Container enumerating all logs on a machine."
//          ImageOpen = REG_SZ "logvwr.dll, 103"
//          ImageClosed = REG_SZ "logvwr.dll, 104"
//          ResultPane = REG_SZ "{....}" / "Html path" / "url"
//


#ifndef _SNAPIN_H_
#define _SNAPIN_H_

class CExtSI;
class CSnapIn;
class CSnapInsCache;

// forward decl
class CPersistor;

#define BOOLVAL(x) ((x) ? TRUE : FALSE)

//____________________________________________________________________________
//
//  Class:      CSnapIn
//____________________________________________________________________________
//
extern const GUID IID_CSnapIn;

#if _MSC_VER < 1100
class CSnapIn : public IUnknown, public CComObjectRoot
#else
class __declspec(uuid("E6DFFF74-6FE7-11d0-B509-00C04FD9080A")) CSnapIn :
                                      public IUnknown, public CComObjectRoot, public CXMLObject
#endif
{
private:
    enum SNAPIN_FLAGS
    {
        SNAPIN_NAMESPACE_CHANGED  = 0x0001,
        SNAPIN_REQ_EXTS_LOADED    = 0x0002,
        SNAPIN_ENABLE_ALL_EXTS    = 0x0004,
        SNAPIN_SNAPIN_ENABLES_ALL = 0x0008,
    };

public:
    BEGIN_COM_MAP(CSnapIn)
        COM_INTERFACE_ENTRY(CSnapIn)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CSnapIn)

// Attributes
    const CLSID& GetSnapInCLSID() const
    {
        return m_clsidSnapIn;
    }

    void SetSnapInCLSID(const CLSID& id)
    {
        m_clsidSnapIn = id;
    }

    CExtSI* GetExtensionSnapIn() const
    {
        return m_pExtSI;
    }

    BOOL RequiredExtensionsLoaded() const
    {
        return (m_dwFlags & SNAPIN_REQ_EXTS_LOADED) != 0;
    }

    BOOL AreAllExtensionsEnabled() const
    {
        return (m_dwFlags & SNAPIN_ENABLE_ALL_EXTS) != 0;
    }

    BOOL DoesSnapInEnableAll() const
    {
        return (m_dwFlags & SNAPIN_SNAPIN_ENABLES_ALL) != 0;
    }

    void SetAllExtensionsEnabled(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_ENABLE_ALL_EXTS;
        else
          m_dwFlags &= ~SNAPIN_ENABLE_ALL_EXTS;
    }

    void SetRequiredExtensionsLoaded(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_REQ_EXTS_LOADED;
        else
            m_dwFlags &= ~SNAPIN_REQ_EXTS_LOADED;
    }

    void SetSnapInEnablesAll(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_SNAPIN_ENABLES_ALL;
        else
            m_dwFlags &= ~SNAPIN_SNAPIN_ENABLES_ALL;
    }


    BOOL HasNameSpaceChanged() const
    {
        return (m_dwFlags & SNAPIN_NAMESPACE_CHANGED) != 0;
    }

    void SetNameSpaceChanged(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= SNAPIN_NAMESPACE_CHANGED;
        else
            m_dwFlags &= ~SNAPIN_NAMESPACE_CHANGED;
    }

    DWORD GetSnapInModule(TCHAR* szBuffer, DWORD cchBuffer) const;
    bool IsStandAlone() const;
    HRESULT Dump (LPCTSTR pszDumpFile, CSnapInsCache* pCache);

    SC ScGetSnapInName(WTL::CString& strSnapinName) const;

    CExtSI* AddExtension(CSnapIn* pSI);
    CExtSI* FindExtension(const CLSID& id);
    void MarkExtensionDeleted(CSnapIn* pSI);
    void PurgeExtensions();

    // destroys list of extensions. extension list needs to be destroyed 
    // this will break snapin's circular references if such exist.
    // (it happens when snapins extends itself or own extension)
    SC ScDestroyExtensionList();

// Operations
    BOOL ExtendsNameSpace(GUID guidNodeType);

    // Loads/Saves this node and its extensions to the provided stream
    HRESULT Load(CSnapInsCache* pCache, IStream* pStream);
    HRESULT Load(CSnapInsCache* pCache, IStream* pStream, CExtSI*& pExtSI);
    HRESULT Save(IStream* pStream, BOOL bClearDirty);

    virtual void    Persist(CPersistor &persistor);
    void            PersistLoad(CPersistor& persistor,CSnapInsCache* pCache);
    DEFINE_XML_TYPE(XML_TAG_SNAPIN);

public:
#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG

// Implementation
protected:
// Constructor & Destructor
    CSnapIn();

    virtual ~CSnapIn(); // Called only by Release

    HKEY OpenKey (REGSAM samDesired = KEY_ALL_ACCESS) const;

// Following methods/member variables manage/contains temporary state
// used for finding used/unused snapins.
// despite it is not really a property of the snapin and is not valid all the time,
// having the state on the snapin is very convenient for the operation.
// Else it would require temporary storage and frequent lookup for information.

// begin temporary state
public:
    SC ScTempState_ResetReferenceCalculationData( );
    SC ScTempState_UpdateInternalReferenceCounts( );
    SC ScTempState_MarkIfExternallyReferenced( );
    SC ScTempState_IsExternallyReferenced( bool& bReferenced ) const;
private:
    SC ScTempState_SetHasStrongReference( );

    DWORD           m_dwTempState_InternalRef;
    bool            m_bTempState_HasStrongRef;
// end temporary state

private:
    DWORD           m_dwFlags;
    CLSID           m_clsidSnapIn;
    CExtSI*         m_pExtSI;               // Extensions

    //____________________________________________________________________________
    //
    //  Class:      CExtPersistor
    //
    //  Purpose:    implements persisting the collection - snapin extensions
    //____________________________________________________________________________
    //
    class CExtPersistor : public XMLListCollectionBase
    {
    public:
        CExtPersistor(CSnapIn& Parent) : m_Parent(Parent),m_pCache(NULL) {}
        virtual void OnNewElement(CPersistor& persistor);
        virtual void Persist(CPersistor& persistor);
        void SetCache(CSnapInsCache* pCache) { m_pCache = pCache; }
        DEFINE_XML_TYPE(XML_TAG_SNAPIN_EXTENSIONS);
    private:
        CSnapIn& GetParent() { return m_Parent; }
        CSnapIn& m_Parent;
        CSnapInsCache* m_pCache;
    };
    friend class CExtPersistor;

    CExtPersistor    m_ExtPersistor;

// Not implemented.
    CSnapIn(const CSnapIn &rhs);
    CSnapIn& operator=(const CSnapIn &rhs);
}; // class CSnapIn

DEFINE_COM_SMARTPTR(CSnapIn);   // CSnapInPtr

//____________________________________________________________________________
//
//  Class:      CExtSI
//____________________________________________________________________________
//
class CExtSI
{
public:
    enum EXTSI_FLAGS
    {
        EXT_TYPES_MASK         = 0x000FFFFF,
        EXT_TYPE_NAMESPACE     = 0x00000001,
        EXT_TYPE_CONTEXTMENU   = 0x00000002,
        EXT_TYPE_TOOLBAR       = 0x00000004,
        EXT_TYPE_PROPERTYSHEET = 0x00000008,
        EXT_TYPE_TASK          = 0x00000010,
        EXT_TYPE_VIEW          = 0x00000020,
        EXT_TYPE_STATIC        = 0x00010000,
        EXT_TYPE_DYNAMIC       = 0x00020000,
        EXT_TYPE_REQUIRED      = 0x00040000,
        EXT_NEW                = 0x80000000,
        EXT_DELETED            = 0x40000000,

    };

public:
// Constructor & Destructor
    CExtSI(CSnapIn* pSnapIn);
    ~CExtSI(void);

// Attributes
    const CLSID& GetCLSID();

    CExtSI*& Next()
    {
        return m_pNext;
    }

    CSnapIn* GetSnapIn(void) const
    {
        return m_pSnapIn;
    }

    void SetNext(CExtSI* pNext)
    {
        m_pNext = pNext;
    }

    void SetNew(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= EXT_NEW;
        else
            m_dwFlags &= ~EXT_NEW;
    }

    void SetRequired(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= EXT_TYPE_REQUIRED;
        else
            m_dwFlags &= ~EXT_TYPE_REQUIRED;
    }

    void MarkDeleted(BOOL bState = TRUE)
    {
        if (bState)
            m_dwFlags |= EXT_DELETED;
        else
            m_dwFlags &= ~EXT_DELETED;
    }

    BOOL IsNew()
    {
        return BOOLVAL(m_dwFlags & EXT_NEW);
    }

    BOOL IsRequired()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_REQUIRED);
    }

    BOOL IsMarkedForDeletion()
    {
        return BOOLVAL(m_dwFlags & EXT_DELETED);
    }

    BOOL ExtendsNameSpace()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_NAMESPACE);
    }

    BOOL ExtendsContextMenu()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_CONTEXTMENU);
    }

    BOOL ExtendsToolBar()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_TOOLBAR);
    }

    BOOL ExtendsPropertySheet()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_PROPERTYSHEET);
    }

    BOOL ExtendsView()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_VIEW);
    }

    BOOL ExtendsTask()
    {
        return BOOLVAL(m_dwFlags & EXT_TYPE_TASK);
    }

    UINT GetExtensionTypes()
    {
        return (m_dwFlags & EXT_TYPES_MASK);
    }

    void SetExtensionTypes(UINT uiExtTypes)
    {
        ASSERT((uiExtTypes & ~EXT_TYPES_MASK) == 0);
        m_dwFlags = (m_dwFlags & ~EXT_TYPES_MASK) | uiExtTypes;
    }

// Operations
    // Saves this extension, and all of the nexts.
    HRESULT Save(IStream* pStream, BOOL bClearDirty);
    void    Persist(CPersistor &persistor);
    static void PersistNew(CPersistor &persistor, CSnapIn& snapParent, CSnapInsCache& snapCache);

// Implementation
private:
    DWORD       m_dwFlags;
    CSnapIn*    m_pSnapIn;
    CExtSI*     m_pNext;

}; // class CExtSI


//____________________________________________________________________________
//
//  Class:      CSnapInsCache
//____________________________________________________________________________
//
class CSnapInsCache : public XMLListCollectionBase
{
    typedef std::map<CLSID, CSnapInPtr> map_t;

public:
    CSnapInsCache();
    ~CSnapInsCache();

// Operations
    SC ScGetSnapIn(const REFCLSID riid, CSnapIn* * ppSnapIn);
    SC ScFindSnapIn(const REFCLSID riid, CSnapIn** ppSnapIn);
// iteration
    typedef map_t::iterator iterator;
    iterator begin() { return m_snapins.begin(); }
    iterator end()   { return m_snapins.end(); }

// CXMLObject methods
    DEFINE_XML_TYPE(XML_TAG_SNAPIN_CACHE);
    virtual void Persist(CPersistor &persistor);
    virtual void OnNewElement(CPersistor& persistor);

// Load Save the snapins cache
    SC ScSave(IStream* pStream, BOOL bClearDirty);
    SC ScLoad(IStream* pStream);
    SC ScIsDirty() ;
    void SetDirty(BOOL bIsDirty = TRUE);
    void Purge(BOOL bExtensionsOnly = FALSE);

    void SetHelpCollectionDirty (bool bState = true) { m_bUpdateHelpColl = bState;}
    bool IsHelpCollectionDirty  (void)               { return m_bUpdateHelpColl; }

    HRESULT Dump (LPCTSTR pszDumpFile);

	SC ScCheckSnapinAvailability (CAvailableSnapinInfo& asi);

    SC ScMarkExternallyReferencedSnapins();

#ifdef DBG
    void DebugDump();
#endif

private:
// Implementation
    BOOL m_bIsDirty;
    map_t   m_snapins;

    bool m_bUpdateHelpColl    : 1;

#ifdef TEMP_SNAPIN_MGRS_WORK
    void GetAllExtensions(CSnapIn* pSI);
#endif // TEMP_SNAPIN_MGRS_WORK

}; // class CSnapInsCache


#endif // _SNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\snapinpersistence.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       snapinpersistence.h
//
//  Contents:
//
//  Classes: CComponentPersistor, CDPersistor
//
//____________________________________________________________________________

#pragma once

#ifndef SNAPINPERSISTENCE_H_INCLUDED

class CMTSnapInNode;
class CComponentData;

/***************************************************************************\
 *
 * CLASS:  CMTSnapinNodeStreamsAndStorages
 *
 * PURPOSE: Unified base class for CComponentPersistor and CDPersistor
 *          Encapsulated data and functionality for maintaining the collection
 *          of snapin streams and storages.
 *
 * USAGE:   Used as a base for CComponentPersistor and CDPersistor
 *          public methods available for clients of CComponentPersistor,
 *          CDPersistor uses iterfaces internally.
 *
\***************************************************************************/
class CMTSnapinNodeStreamsAndStorages : public XMLListCollectionBase
{
    typedef std::pair<int, CLSID>        key_t;
    typedef std::pair<int, std::wstring> hash_t;

public:

    // CDPersistor uses the same storage (provided by the this class)
    // as CComponent persistor , but it is not related to any view.
    // VIEW_ID_DOCUMENT is the special value for indicating ComponentData entry
    enum { VIEW_ID_DOCUMENT = -1 };

public: // methods not throwing exceptions

    // Initialize the storage for a snapin by copying the contents from
    // provided initialization source.
    SC ScInitIStorage( int idView, LPCWSTR szHash, IStorage *pSource );
    SC ScInitIStream ( int idView, LPCWSTR szHash, IStream  *pSource );

    // Returns the storage for snapin. Creates and caches one if does not have already
    SC ScGetIStorage( int idView, const CLSID& clsid, IStorage **ppStorage );
    SC ScGetIStream ( int idView, const CLSID& clsid, IStream  **ppStream  );

    // Checks if it has a storage for a snapins
    bool HasStream(int idView, const CLSID& clsid);
    bool HasStorage(int idView, const CLSID& clsid);
    
    void RemoveView(int nViewId);

    // returns the pointer to CXML_IStxxxxx object. Creates the object if does not have one
    SC ScGetXmlStorage(int idView, const CLSID& clsid, CXML_IStorage *& pXMLStorage);
    SC ScGetXmlStream (int idView, const CLSID& clsid, CXML_IStream  *& pXMLStream);

protected:
    std::map<key_t, CXML_IStorage>  m_XMLStorage;
    std::map<key_t, CXML_IStream>   m_XMLStream;

public:

    // persistence support for derived classes
    void Persist(CPersistor& persistor, bool bPersistViewId);
    virtual void OnNewElement(CPersistor& persistor);
    // implemented by the derived class
    virtual LPCTSTR GetItemXMLType() = 0;
    
private:

    SC ScFindXmlStorage(int idView, const CLSID& clsid, bool& bFound, CXML_IStorage *& pXMLStorage);
    SC ScFindXmlStream (int idView, const CLSID& clsid, bool& bFound, CXML_IStream  *& pXMLStream);
    
    // looks for snapin's data by the hash value
    // if any is found - moves data to 'known' snapin collection
    SC ScCheckForStreamsAndStoragesByHashValue( int idView, const CLSID& clsid, bool& bFound );

    // maps holding the old data comming from structured storage
    // untill the real data owner (snapin's CLSID) is known
    // We need this coz there is no conversion from hash to clsid
    std::map<hash_t, CXML_IStorage> m_StorageByHash;
    std::map<hash_t, CXML_IStream>  m_StreamByHash;
};


/*+-------------------------------------------------------------------------*
 * class CComponentPersistor
 *
 * PURPOSE: Persists IComponent collection accociated with the snapin
 *          holds IStream & IStorage maps for loading / storing data
 *
 *          Also holds and maintains a collection of all the streams and storages
 *          used by components of the snapin node and all the extensions
 *          extending this node or it's subnodes
 *
 *+-------------------------------------------------------------------------*/
class CComponentPersistor : public CMTSnapinNodeStreamsAndStorages
{
    typedef CMTSnapinNodeStreamsAndStorages BC;

public:
    SC ScReset();
protected:
    virtual void        Persist(CPersistor& persistor);

public:
    DEFINE_XML_TYPE(XML_TAG_ICOMPONENT_LIST);
    static LPCTSTR _GetItemXMLType() { return XML_TAG_ICOMPONENT; }
    virtual LPCTSTR GetItemXMLType()  { return _GetItemXMLType(); }
};

/*+-------------------------------------------------------------------------*
 * class CDPersistor
 *
 * PURPOSE: Persists IComponentData collection accociated with the snapin
 *          holds IStream & IStorage maps for loading / storing data
 *
 *          Also holds and maintains a collection of all the streams and storages
 *          used by component datas of the snapin node and all the extensions
 *          extending this node or it's subnodes
 *
 *+-------------------------------------------------------------------------*/
class CDPersistor : public CMTSnapinNodeStreamsAndStorages
{
    typedef CMTSnapinNodeStreamsAndStorages BC;

public: // interface to data maintained by CMTSnapinNodeStreamsAndStorages

    // CDPersistor uses the same storage (provided by the base class)
    // as CComponent persistor , but it is not related to any view.
    // VIEW_ID_DOCUMENT is the special value for indicating ComponentData entry

    // Initialize the storage for a snapin by copying the contents from
    // provided initialization source.
    SC ScInitIStorage( LPCWSTR szHash, IStorage *pSource )
    {
        return BC::ScInitIStorage( VIEW_ID_DOCUMENT, szHash, pSource );
    }

    SC ScInitIStream ( LPCWSTR szHash, IStream  *pSource )
    {
        return BC::ScInitIStream ( VIEW_ID_DOCUMENT, szHash, pSource );
    }

    // Returns the storage for snapin. Creates and caches one if does not have already
    SC ScGetIStorage( const CLSID& clsid, IStorage **ppStorage )
    {
        return BC::ScGetIStorage( VIEW_ID_DOCUMENT, clsid, ppStorage );
    }

    SC ScGetIStream ( const CLSID& clsid, IStream  **ppStream  )
    {
        return BC::ScGetIStream ( VIEW_ID_DOCUMENT, clsid, ppStream  );
    }

    // Checks if it has a storage for a snapins
    bool HasStream(const CLSID& clsid)
    {
        return BC::HasStream(VIEW_ID_DOCUMENT, clsid);
    }

    bool HasStorage(const CLSID& clsid)
    {
        return BC::HasStorage(VIEW_ID_DOCUMENT, clsid);
    }
    
public:
    SC ScReset();
protected:
    virtual void        Persist(CPersistor& persistor);

public:
    DEFINE_XML_TYPE(XML_TAG_ICOMPONENT_DATA_LIST);
    static  LPCTSTR _GetItemXMLType() { return XML_TAG_ICOMPONENT_DATA; }
    virtual LPCTSTR GetItemXMLType()  { return _GetItemXMLType(); }
};


#endif SNAPINPERSISTENCE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\snapinpersistence.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       snapinpersistence.cpp
//
//  Contents:
//
//  Classes: CComponentPersistor, CDPersistor
//
//____________________________________________________________________________

#include "stdafx.h"
#include "mtnode.h"
#include "regutil.h"

/*+-------------------------------------------------------------------------*
 *
 * struct less_component
 *
 * PURPOSE:  implements viewID and CLSID based comparison for CComponent* pointers
 *           This allows to sort components before pesisting
 *+-------------------------------------------------------------------------*/
struct less_component // define the struct to perform the comparison
{
    typedef std::pair<int, CComponent*> comp_type;

    bool operator ()(const comp_type& arg1, const comp_type& arg2) const
    {
        return  arg1.first != arg2.first ? arg1.first < arg2.first :
                arg1.second->GetCLSID() < arg2.second->GetCLSID();
    }
};

/*+-------------------------------------------------------------------------*
 *
 * struct less_compdata
 *
 * PURPOSE:  implements CLSID based comparison for CComponentData* pointers
 *           This allows to sort component data before pesisting
 *+-------------------------------------------------------------------------*/
struct less_compdata // define the struct to perform the comparison
{
    bool operator ()(const CComponentData* pCD1, const CComponentData* pCD2) const
    {
        return  pCD1->GetCLSID() < pCD2->GetCLSID();
    }
};

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetXmlStorage
 *
 * PURPOSE:  gets CXML_IStorage for snapin. creates & inits one there is none
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    CXML_IStorage *& pXMLStorage  [out] xml storage for the snapin
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetXmlStorage(int idView, const CLSID& clsid, CXML_IStorage *& pXMLStorage)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetXmlStorage"));

    // init out parameter
    pXMLStorage = NULL;

    // try to find it first
    bool bFound = false;
    sc = ScFindXmlStorage(  idView, clsid, bFound, pXMLStorage );
    if (sc)
        return sc;

    if (bFound)
    {
        // recheck
        sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
        if (sc)
            return sc;

        // return the ponter we found
        return sc;
    }

    // insert the new one
    typedef std::map<key_t, CXML_IStorage> col_t;
    col_t::iterator it = m_XMLStorage.insert(col_t::value_type( key_t( idView, clsid ), CXML_IStorage())).first;
    pXMLStorage = &it->second;

    // recheck
    sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScFindXmlStorage
 *
 * PURPOSE: Finds the storage. 
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    bool& bFound                  [out] whether data was found
 *    CXML_IStorage *& pXMLStorage  [out] pointer to found data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::
ScFindXmlStorage(int idView, const CLSID& clsid, bool& bFound, CXML_IStorage *& pXMLStorage)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScFindXmlStorage"));

    // init out parameters
    bFound = false;
    pXMLStorage = NULL;

    typedef std::map<key_t, CXML_IStorage> col_t;
    col_t::iterator it = m_XMLStorage.find( key_t( idView, clsid ) );

    // give a try to find it by the hash value
    if ( it == m_XMLStorage.end() )
    {
        bool bFoundInHash = false;
        sc = ScCheckForStreamsAndStoragesByHashValue( idView, clsid, bFoundInHash );
        if (sc)
            return sc;

        if ( !bFoundInHash ) // if not found - return
            return sc;

        // try again - it may be in the map by now
        it = m_XMLStorage.find( key_t( idView, clsid ) );

        if ( it == m_XMLStorage.end() ) // if still not found - return
            return sc;
    }

    // found!
    bFound = true;
    pXMLStorage = &it->second;

#ifdef DBG // set the snapin name to identify the problems in debug
    tstring strSnapin;
    GetSnapinNameFromCLSID( clsid, strSnapin );
    pXMLStorage->m_dbg_Data.SetTraceInfo(TraceSnapinPersistenceError, true, strSnapin);
#endif // #ifdef DBG

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScFindXmlStream
 *
 * PURPOSE: Finds the stream. 
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    bool& bFound                  [out] whether data was found
 *    CXML_IStream *& pXMLStream    [out] pointer to found data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::
ScFindXmlStream(int idView, const CLSID& clsid, bool& bFound, CXML_IStream *& pXMLStream)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScFindXmlStream"));

    // init out parameters
    bFound = false;
    pXMLStream = NULL;

    typedef std::map<key_t, CXML_IStream> col_t;
    col_t::iterator it = m_XMLStream.find( key_t( idView, clsid ) );

    // give a try to find it by the hash value
    if ( it == m_XMLStream.end() )
    {
        bool bFoundInHash = false;
        sc = ScCheckForStreamsAndStoragesByHashValue( idView, clsid, bFoundInHash );
        if (sc)
            return sc;

        if ( !bFoundInHash ) // if not found - return
            return sc;

        // try again - it may be in the map by now
        it = m_XMLStream.find( key_t( idView, clsid ) );

        if ( it == m_XMLStream.end() ) // if still not found - return
            return sc;
    }

    // found!
    bFound = true;
    pXMLStream = &it->second;

#ifdef DBG // set the snapin name to identify the problems in debug
        tstring strSnapin;
        GetSnapinNameFromCLSID( clsid, strSnapin );
        pXMLStream->m_dbg_Data.SetTraceInfo(TraceSnapinPersistenceError, true, strSnapin);
#endif // #ifdef DBG

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetXmlStream
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *    CXML_IStream *& pXMLStream    [out] xml stream for the snapin
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetXmlStream(int idView, const CLSID& clsid, CXML_IStream *& pXMLStream)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetXmlStream"));

    // init out parameter
    pXMLStream = NULL;

    // try to find it first
    bool bFound = false;
    sc = ScFindXmlStream( idView, clsid, bFound, pXMLStream );
    if (sc)
        return sc;

    if (bFound)
    {
        // recheck
        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            return sc;

        // return the ponter we found
        return sc;
    }

    // insert the new one
    typedef std::map<key_t, CXML_IStream> col_t;
    col_t::iterator it = m_XMLStream.insert(col_t::value_type( key_t( idView, clsid ), CXML_IStream())).first;
    pXMLStream = &it->second;

    // recheck
    sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScInitIStorage
 *
 * PURPOSE: Initializes IStorage from the given source data
 *
 * PARAMETERS:
 *    int idView              [in] view number 
 *    LPCWSTR szHash          [in] hash key (name of storage element) identifying the snapin
 *    IStorage *pSource       [in] source data for initialization
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScInitIStorage( int idView, LPCWSTR szHash, IStorage *pSource )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScInitIStorage"));

    // parameter check;
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // insert the new one
    typedef std::map<hash_t, CXML_IStorage> col_t;
    col_t::iterator it = m_StorageByHash.insert( col_t::value_type(hash_t(idView, szHash), CXML_IStorage())).first;
    CXML_IStorage *pXMLStorage = &it->second;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
    if (sc)
        return sc;

    sc = pXMLStorage->ScInitializeFrom( pSource );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScInitIStream
 *
 * PURPOSE: Initializes IStream from the given source data
 *
 * PARAMETERS:
 *    int idView               [in] view number 
 *    LPCWSTR szHash           [in] hash key (name of storage element) identifying the snapin
 *    IStream *pSource         [in] source data for initialization
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScInitIStream ( int idView, LPCWSTR szHash, IStream *pSource )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScInitIStream"));

    // parameter check;
    sc = ScCheckPointers( pSource );
    if (sc)
        return sc;

    // insert the new one
    typedef std::map<hash_t, CXML_IStream> col_t;
    col_t::iterator it = m_StreamByHash.insert( col_t::value_type(hash_t(idView, szHash), CXML_IStream())).first;
    CXML_IStream *pXMLStream = &it->second;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
    if (sc)
        return sc;

    sc = pXMLStream->ScInitializeFrom( pSource );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetIStorage
 *
 * PURPOSE: returns existing or creates a new IStorage for the component
 *
 * PARAMETERS:
 *    int idView            [in] view number 
 *    const CLSID& clsid    [in] CLSID identifying the snapin
 *    IStorage **ppStorage  [out] - storage for the component
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetIStorage( int idView, const CLSID& clsid, IStorage **ppStorage )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetIStorage"));

    // paramter check
    sc = ScCheckPointers( ppStorage );
    if (sc)
        return sc;

    // init an out parameter
    *ppStorage = NULL;

    CXML_IStorage *pXMLStorage = NULL;
    sc = ScGetXmlStorage( idView, clsid, pXMLStorage );
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the interface
    sc = pXMLStorage->ScGetIStorage(ppStorage);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScGetIStream
 *
 * PURPOSE: returns existing or creates a new IStream for the component
 *
 * PARAMETERS:
 *    int idView            [in] view number 
 *    const CLSID& clsid    [in] CLSID identifying the snapin
 *    IStream  **ppStream   [out] - stream fro the component
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScGetIStream ( int idView, const CLSID& clsid, IStream  **ppStream  )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScGetIStream"));

    // paramter check
    sc = ScCheckPointers( ppStream );
    if (sc)
        return sc;

    // init an out parameter
    *ppStream = NULL;

    CXML_IStream *pXMLStream = NULL;
    sc = ScGetXmlStream( idView, clsid, pXMLStream );
    if (sc)
        return sc;

    // recheck the pointer
    sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the interface
    sc = pXMLStream->ScGetIStream(ppStream);
    if (sc)
        return sc;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::HasStream
 *
 * PURPOSE: Checks if snapins stream is available
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *
 * RETURNS:
 *    bool - true == found
 *
\***************************************************************************/
bool CMTSnapinNodeStreamsAndStorages::HasStream(int idView, const CLSID& clsid)    
{ 
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::HasStream"));

    bool bFound = false;
    CXML_IStream * pUnused = NULL;
    sc = ScFindXmlStream( idView, clsid, bFound, pUnused );
    if (sc)
        return false; // not found if error

    return bFound;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::HasStorage
 *
 * PURPOSE: Checks if snapins storage is available
 *
 * PARAMETERS:
 *    int idView                    [in] view number 
 *    const CLSID& clsid            [in] CLSID identifying the snapin
 *
 * RETURNS:
 *    bool - true == found
 *
\***************************************************************************/
bool CMTSnapinNodeStreamsAndStorages::HasStorage(int idView, const CLSID& clsid)
{ 
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::HasStorage"));

    bool bFound = false;
    CXML_IStorage * pUnused = NULL;
    sc = ScFindXmlStorage( idView, clsid, bFound, pUnused );
    if (sc)
        return false; // not found if error

    return bFound;
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::ScCheckForStreamsAndStoragesByHashValue
 *
 * PURPOSE: Looks up streams and storages by a generated hash value.
 *          if the streams/storages are found, they are moved to the
 *          the list of 'recognized' storages - those identified by the CLSID.
 *          This is a required step to recognize the streams and storages retrieved
 *          from a structured storage based console, where they are identified by the
 *          hash value. It is not possible to map from the hash value to the key 
 *          in unique way, so the collections of data are kept untill the request 
 *          comes and the hash can be mapped by matching with the one generated from 
 *          the key supplied by request.
 *
 * PARAMETERS:
 *    int idView                      [in] view number 
 *    const CLSID& clsid              [in] CLSID identifying the snapin
 *    bool& bFound                    [out] - true if at least one matching hash value was found
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMTSnapinNodeStreamsAndStorages::ScCheckForStreamsAndStoragesByHashValue( int idView, const CLSID& clsid, bool& bFound )
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::ScCheckForStreamsAndStoragesByHashValue"));

    bFound = false;

    wchar_t buff[MAX_PATH];
    sc = CMTNode::ScGetComponentStreamName( buff, countof(buff), clsid );
    if(sc)
        return sc;

    std::wstring strHashValue = buff;

    // process streams
    {
        typedef std::map<hash_t, CXML_IStream> col_t;
        col_t::iterator it = m_StreamByHash.begin();
        while ( it != m_StreamByHash.end() )
        {
            if ( it->first.second == strHashValue )
            {
                bFound = true;
                // put to a 'recognized' list
                int idView = it->first.first;
                m_XMLStream[key_t(idView, clsid)] = it->second;
            
                // for sanity: make sure it is not in the storage map!
                ASSERT( m_StorageByHash.find(it->first) == m_StorageByHash.end() );
                m_StorageByHash.erase( it->first );

                // remove from hash table
                it = m_StreamByHash.erase( it );
            }
            else
                ++ it;
        }

        if ( bFound )
            return sc;
    }

    // process storages
    {
        typedef std::map<hash_t, CXML_IStorage> col_t;
        col_t::iterator it = m_StorageByHash.begin();
        while ( it != m_StorageByHash.end() )
        {
            if ( it->first.second == strHashValue )
            {
                bFound = true;
                // put to a 'recognized' list
                int idView = it->first.first;
                m_XMLStorage[key_t(idView, clsid)] = it->second;
            
                // for sanity: make sure it is not in the stream map!
                ASSERT( m_StreamByHash.find( it->first ) == m_StreamByHash.end() );
                m_StreamByHash.erase( it->first );

                // remove from hash table
                it = m_StorageByHash.erase( it );
            }
            else
                ++it;
        }
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapinNodeStreamsAndStorages::RemoveView
 *
 * PURPOSE:  removes information about one view
 *
 * PARAMETERS:
 *    int idView                      [in] view number 
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTSnapinNodeStreamsAndStorages::RemoveView(int nViewId)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::RemoveView"));

    { // remove streams
        std::map<key_t, CXML_IStream>::iterator  it_stream;
        for (it_stream = m_XMLStream.begin();it_stream != m_XMLStream.end();)
        {
            if (it_stream->first.first == nViewId)
                it_stream = m_XMLStream.erase(it_stream);
            else
                ++it_stream;
        }
    }
    { // remove storages
        std::map<key_t, CXML_IStorage>::iterator it_storage;
        for (it_storage = m_XMLStorage.begin();it_storage != m_XMLStorage.end();)
        {
            if (it_storage->first.first == nViewId)
                it_storage = m_XMLStorage.erase(it_storage);
            else
                ++it_storage;
        }
    }

    { // remove streams by hash
        std::map<hash_t, CXML_IStream>::iterator  it_stream;
        for (it_stream = m_StreamByHash.begin();it_stream != m_StreamByHash.end();)
        {
            if (it_stream->first.first == nViewId)
                it_stream = m_StreamByHash.erase(it_stream);
            else
                ++it_stream;
        }
    }
    { // remove storages by hash
        std::map<hash_t, CXML_IStorage>::iterator it_storage;
        for (it_storage = m_StorageByHash.begin();it_storage != m_StorageByHash.end();)
        {
            if (it_storage->first.first == nViewId)
                it_storage = m_StorageByHash.erase(it_storage);
            else
                ++it_storage;
        }
    }
}

/***************************************************************************\
 *
 * METHOD:  CMTSnapinNodeStreamsAndStorages::Persist
 *
 * PURPOSE: persists stream and storage collections
 *
 * PARAMETERS:
 *    CPersistor& persistor [in] peristor for the operation
 *    bool bPersistViewId   [in] whether to store view identifier
 *                               (ComponentDatas are saved with thi parameter set to false,
 *                                since the view id has no meaning for them)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void CMTSnapinNodeStreamsAndStorages::Persist(CPersistor& persistor, bool bPersistViewId)
{
    DECLARE_SC(sc, TEXT("CMTSnapinNodeStreamsAndStorages::Persist"));

    if (persistor.IsStoring())
    {
        // define iterators for saving
        std::map<key_t, CXML_IStorage>::iterator    itStorages;
        std::map<key_t, CXML_IStream>::iterator     itStreams;
        std::map<hash_t, CXML_IStorage>::iterator   itStoragesByHash;
        std::map<hash_t, CXML_IStream>::iterator    itStreamsByHash;

        // init iterators to point to the start of the collections
        itStorages = m_XMLStorage.begin();
        itStreams = m_XMLStream.begin();
        itStoragesByHash = m_StorageByHash.begin();
        itStreamsByHash = m_StreamByHash.begin();

        // we have 4 collections to save here.
        // while saving them one by one would not change the functionality,
        // console file is more readable when they are sorted by the snapin's clsid.
        // following code does not do any explicit sorting, but persist in the
        // certain order assurring the result is a sorted array of persisted data

        // These 4 iterators represents 4 lines (queues) of sorted items, so
        // in order to get the proper result we just need to merge them correctly.
        // This is done by the following loop which splits the persistence in two steps:
        // 1. Pick the right line (iterator) to persist it's first item.
        // 2. Persist the selected item.
        // There are 4 boolean variables indicating which item to save (only one can be 'true')
        // thus the second part is strigth-forward - test variables and do the persisting.

        // The iterator is picked by the following rules.
        // 1.1 Only lines with items compete.
        // 1.2 If there are items in lines key'ed by guids (in contrast to hash values)
        //     they are processed first, leaving hash values at the end.
        // 1.3 If still there are 2 lines competing - their key's are compared and one
        //     with a smaller key is choosen
        
        while ( 1 )
        {
            // see what collection has data to save
            bool bSaveStorage = ( itStorages != m_XMLStorage.end() );
            bool bSaveStream  = ( itStreams != m_XMLStream.end() );
            bool bSaveStorageByHash = ( itStoragesByHash != m_StorageByHash.end() );
            bool bSaveStreamByHash  = ( itStreamsByHash != m_StreamByHash.end() );

            // exit if nothind to tsave - assume we are done
            if ( !( bSaveStorage || bSaveStream || bSaveStorageByHash || bSaveStreamByHash ))
                break;

            // if both main collections are willing to save - let the smaller key win
            if ( bSaveStorage && bSaveStream )
            {
                bSaveStorage = ( itStorages->first < itStreams->first );
                bSaveStream = !bSaveStorage;
            }

            // if not done with a main collections - dont save by hash
            if ( bSaveStorage || bSaveStream )
                bSaveStorageByHash = bSaveStreamByHash = false;

            // if both hash collections are willing to save - let the smaller key win
            if ( bSaveStorageByHash && bSaveStreamByHash )
            {
                bSaveStorageByHash = ( itStoragesByHash->first < itStreamsByHash->first );
                bSaveStreamByHash = !bSaveStorageByHash;
            }

            // only variable one can be set !
            ASSERT ( 1 == ( (int)bSaveStorage + (int)bSaveStream + (int)bSaveStorageByHash + (int)bSaveStreamByHash) );

            // add the tag for snapin entry
            CPersistor persistorChild(persistor, GetItemXMLType());

            // save one winning entry
            if ( bSaveStorage )
            {
                // persist a key
                CLSID clsid = itStorages->first.second;
                int idView = itStorages->first.first;

                persistorChild.Persist( clsid, XML_NAME_CLSID_SNAPIN );

                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                // persist data
                persistorChild.Persist( itStorages->second );
                
                // advance to the next entry
                ++itStorages;
            }
            else if (bSaveStream)
            {
                // persist a key
                CLSID clsid = itStreams->first.second;
                int idView = itStreams->first.first;

                persistorChild.Persist( clsid, XML_NAME_CLSID_SNAPIN );

                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                // persist data
                persistorChild.Persist( itStreams->second );

                // advance to the next entry
                ++itStreams;
            }
            else if ( bSaveStorageByHash )
            {
                // persist a key
                std::wstring hash = itStoragesByHash->first.second;
                int idView = itStoragesByHash->first.first;
                
                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                CPersistor persistorHash( persistorChild, XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN);
                persistorHash.PersistContents( hash );

                // persist data
                persistorChild.Persist( itStoragesByHash->second );
                
                // advance to the next entry
                ++itStoragesByHash;
            }
            else if (bSaveStreamByHash)
            {
                // persist a key
                std::wstring hash = itStreamsByHash->first.second;
                int idView = itStreamsByHash->first.first;

                if (bPersistViewId)
                    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView);

                CPersistor persistorHash( persistorChild, XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN);
                persistorHash.PersistContents( hash );

                // persist data
                persistorChild.Persist( itStreamsByHash->second );

                // advance to the next entry
                ++itStreamsByHash;
            }
            else
            {
                ASSERT( false ); // should not come here!
                break;
            }
        }

    }
    else
    {
        XMLListCollectionBase::Persist(persistor);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CMTSnapinNodeStreamsAndStorages::OnNewElement
 *
 * PURPOSE:  called for each component data found loading XML doc
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CMTSnapinNodeStreamsAndStorages::OnNewElement(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CDPersistor::OnNewElement"));

    // persistor is 'locked' on particular child element, so that
    // a simple CPersistor constructor can be used to create child's peristor.
    // Creating the child persistor is also necessary to release that 'lock'
    CPersistor persistorChild(persistor, GetItemXMLType());

    CLSID clsid;
    std::wstring hash;
    bool bByHash = false;
    ZeroMemory(&clsid,sizeof(clsid));

    // look how entry is key'ed - by regular key of by a hash value
    if ( persistorChild.HasElement( XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN ) )
    {
        CPersistor persistorHash( persistorChild, XML_TAG_HASH_VALUE, XML_NAME_CLSID_SNAPIN);
        persistorHash.PersistContents( hash );
        bByHash = true;
    }
    else
        persistorChild.Persist(clsid, XML_NAME_CLSID_SNAPIN);

    // persist the view id - default to value used to store component data
    int idView = VIEW_ID_DOCUMENT;
    persistorChild.PersistAttribute(XML_ATTR_ICOMPONENT_VIEW_ID, idView, attr_optional);

    // now we should look what data do we have
    // and persist if recognized
    if (persistorChild.HasElement(CXML_IStream::_GetXMLType(),NULL))
    {
        CXML_IStream *pXMLStream = NULL;

        if (bByHash)
        {
            pXMLStream = &m_StreamByHash[ hash_t(idView, hash) ];
        }
        else
        {
            sc = ScGetXmlStream( idView, clsid, pXMLStream );
            if (sc)
                sc.Throw();
        }

        sc = ScCheckPointers( pXMLStream, E_UNEXPECTED );
        if (sc)
            sc.Throw();

        persistorChild.Persist( *pXMLStream );
    }
    else if (persistorChild.HasElement(CXML_IStorage::_GetXMLType(),NULL))
    {
        CXML_IStorage *pXMLStorage = NULL;

        if (bByHash)
        {
            pXMLStorage = &m_StorageByHash[ hash_t(idView, hash) ];
        }
        else
        {
            sc = ScGetXmlStorage( idView, clsid, pXMLStorage );
            if (sc)
                sc.Throw();
        }

        sc = ScCheckPointers( pXMLStorage, E_UNEXPECTED );
        if (sc)
            sc.Throw();

        persistorChild.Persist( *pXMLStorage );
    }
}


/*+-------------------------------------------------------------------------*
 *+-------------------------------------------------------------------------* 
 *+-------------------------------------------------------------------------* 
 *+-------------------------------------------------------------------------*/


/*+-------------------------------------------------------------------------*
 *
 * CComponentPersistor::Persist
 *
 * PURPOSE:  persists IComponent collection related to snapin ( and its extensions)
 *
 * PARAMETERS:
 *    CPersistor &persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CComponentPersistor::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CComponentPersistor::Persist"));

    // let the base class do the job
    BC::Persist( persistor, true /*bPersistViewId*/ );
}

/***************************************************************************\
 *
 * METHOD:  CComponentPersistor::ScReset
 *
 * PURPOSE: Restores component xml streams/storages into "Just loaded" state
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CComponentPersistor::ScReset()
{
    DECLARE_SC(sc, TEXT("CComponentPersistor::ScReset"));

    // save contents to string 
    std::wstring strContents;
    sc = ScSaveToString(&strContents);
    if (sc)
        return sc;

    // cleanup (anything not saved should go away)
    m_XMLStorage.clear();
    m_XMLStream.clear();

    // load from string
    sc = ScLoadFromString(strContents.c_str());
    if (sc)
        return sc;

    return sc;
}

//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * CDPersistor::Persist
 *
 * PURPOSE:  persists collection of component datas
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CDPersistor::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CDPersistor::Persist"));

    // let the base class do the job
    BC::Persist( persistor, false /*bPersistViewId*/ );
}

/***************************************************************************\
 *
 * METHOD:  CDPersistor::ScReset
 *
 * PURPOSE: Restores component data xml streams/storages into "Just loaded" state
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CDPersistor::ScReset()
{
    DECLARE_SC(sc, TEXT("CDPersistor::ScReset"));

    // save contents to string 
    std::wstring strContents;
    sc = ScSaveToString(&strContents);
    if (sc)
        return sc;

    // cleanup (anything not saved should go away)
    m_XMLStorage.clear();
    m_XMLStream.clear();

    // load from string
    sc = ScLoadFromString(strContents.c_str());
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

#define ASSERT(x)   _ASSERTE(x)

#include <new.h>

#include <crtdbg.h>

#define OEMRESOURCE 1
#include <windows.h>

#include <shellapi.h>
#include <mmctempl.h>

#include <objidl.h>
#include <commctrl.h>
#include <mmcmt.h>

//############################################################################
//############################################################################
//
// MMC headers
//
//############################################################################
#include <mmc.h>
#include <ndmgr.h>
#include <ndmgrpriv.h>

#include <mmcptrs.h>

//############################################################################
//############################################################################
//
// ATL
//
//############################################################################
//############################################################################
// The #define below is to work around an ATL bug causing bug C2872
#define MMC_ATL ::ATL
#define _WTL_NO_AUTOMATIC_NAMESPACE

#include <atlbase.h>

using namespace MMC_ATL;
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module; // Needs to be declared BEFORE atlcom.h

#include <atlcom.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlgdi.h>
#include <atlctl.h>
#include <dlgs.h>
#include <atldlgs.h>


//############################################################################
//############################################################################
//
// STL and  other classes
//
//############################################################################
//############################################################################
#include <algorithm>
#include <exception>
#include <string>
#include <list>
#include <set>
#include <vector>
#include <map>
#include <iterator>

//############################################################################
//############################################################################

// definition to compile code specific to node manager dll
#define _MMC_NODE_MANAGER_ONLY_

//############################################################################
//############################################################################
//
// The safer string handling routines
//
//############################################################################
//############################################################################
// multimon.h (which we don't own) uses a deprecated function in ANSI. That's
// why we #define STRSAFE_NO_DEPRECATE below in ANSI only
#ifndef UNICODE
#define STRSAFE_NO_DEPRECATE
#endif // UNICODE

#include <strsafe.h>

//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "dbg.h"
#include "cstr.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include "tiedobj.h"
#include "comerror.h"
#include "events.h"         // Observer pattern implementation.
#include "strings.h"

// included from NODEMGR (needs some BASE stuff, redefines some as well)
#include "typeinfo.h" // defines IDispatchImpl substitution for node manager

#include "AutoPtr.h"
#include "comobjects.h"
#include "enumerator.h"

//############################################################################
//############################################################################
//
// include common and nodemgr-only strings.
//
//############################################################################
//############################################################################
#include "..\base\basestr.h"
#include "..\base\nodemgrstr.h"

//############################################################################
//############################################################################
//
// Debug support for legacy traces.
//
//############################################################################
//############################################################################
#ifdef DBG

#define TRACE TraceNodeMgrLegacy

#else // DBG

#define TRACE               ;/##/

#endif DBG

//############################################################################
//############################################################################
//
// Other files
//
//############################################################################
//############################################################################
#include "mmcatl.h"
#include "regkeyex.h"
#include "guidhelp.h"
#include "macros.h"
#include "moreutil.h"
#include "amcmsgid.h"
#include "mfccllct.h"
#include "mmcutil.h"
#include "countof.h"
#include "stgio.h"
#include "serial.h"
#include "stlstuff.h"
#include "bookmark.h"
#include "xmlbase.h"
#include "resultview.h"
#include "viewset.h"
#include "memento.h"
#include "objmodelptrs.h"
#include "mmcdata.h"
#include "viewdata.h"
#include "cpputil.h"

class CComponent;
class CMTNode;
typedef CComponent* PCOMPONENT;
typedef std::vector<PCOMPONENT> CComponentArray;
typedef CMTNode* PMTNODE;
typedef std::vector<PMTNODE>    CMTNodePtrArray;


//############################################################################
//############################################################################
//
// Files from the nodemgr subsystem
//
//############################################################################
//############################################################################
#include "mmcres.h"
#include "resource.h"
#include "helparr.h"
#include "classreg.h"
#include "snapin.h"
#include "npd.h"
#include "nmtempl.h"
#include "imageid.h"
#include "amcpriv.h"
#include "containr.h"
#include "ststring.h"
#include "nodepath.h"
#include "mtnode.h"
#include "node.h"
#include "propsht.h"
#include "coldata.h"
#include "toolbar.h"
#include "ctrlbar.h"
#include "verbs.h"
#include "scoptree.h"
#include "nodeinit.h"
#include "wiz97.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=mmcndmgr
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

C_DEFINES=  $(C_DEFINES) -D_NODEMGR_DLL_

USE_NATIVE_EH  = 1
USE_RTTI       = 1
USE_VCCOM      = 1
USE_STL        = 1
USE_STATIC_ATL = 1
ATL_VER        = 30
USE_MSVCRT     = 1
USE_WTL        = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
# The value of SXS_MANIFEST_RESOURCE_ID *must* be 2, to match a hardcoded value
# in WinbasePrivateCreateActCtxForHModule (winbase.inl).
#
SXS_ASSEMBLY_NAME                 = Microsoft.Windows.MMCNDMGR
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT = 1
SXS_MANIFEST                      = mmcndmgr.manifest
SXS_MANIFEST_IN_RESOURCES         = 1
SXS_NO_BINPLACE                   = 1
SXS_MANIFEST_RESOURCE_ID          = 2

C_DEFINES=  $(C_DEFINES) -DISOLATION_AWARE_ENABLED

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	$(SDK_LIB_PATH)\mmc.lib						\
	..\..\core\$(CharWidth)\$(O)\uicore.lib		\
	..\..\base\$(CharWidth)\$(O)\mmcbase.lib	\
	..\..\types\proxy\$(O)\ndmgrproxy.lib

# We need $(SHELL_LIB_PATH)\shlwapip.lib for SHLoadRegUIString
TARGETLIBS = \
	$(SDK_LIB_PATH)\kernel32.lib    \
	$(SDK_LIB_PATH)\user32.lib      \
	$(SDK_LIB_PATH)\oleaut32.lib    \
	$(SDK_LIB_PATH)\ole32.lib       \
	$(SDK_LIB_PATH)\advapi32.lib    \
	$(SDK_LIB_PATH)\uuid.lib        \
	$(SDK_LIB_PATH)\comctl32.lib    \
	$(SDK_LIB_PATH)\gdi32.lib       \
	$(SDK_LIB_PATH)\comdlg32.lib    \
	$(SDK_LIB_PATH)\urlmon.lib      \
	$(SDK_LIB_PATH)\shell32.lib		\
	$(SHELL_LIB_PATH)\shlwapip.lib	\
	$(SDK_LIB_PATH)\rpcrt4.lib      \
	$(WINDOWS_LIB_PATH)\cicsthkl.lib      \

			

# To prevent AV in CPropertyPage::DoModal
LINKER_FLAGS = $(LINKER_FLAGS) /SECTION:.rsrc,rw

DLLDEF=..\mmcndmgr.def

# We need $(SHELL_INC_PATH) for shlwapip.h and uastrfnc.h
# We need $(BASE_INC_PATH)  for wow64reg.h
INCLUDES = \
	..\;					\
	..\..\inc;				\
	..\..\base;             \
	..\..\types\idl\$(O);   \
	$(SHELL_INC_PATH);		\
	$(BASE_INC_PATH);		\
	$(WINDOWS_INC_PATH);


PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

# This target is required so $O\nodemgr.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$O\nodemgr.res: \
	..\res\snpinlst.bmp         		\
	..\res\imagelis.bmp         		\
	..\res\compwiz.bmp          		\
	..\res\setupwiz.bmp         		\
	..\res\ocxwzhd.bmp          		\
	..\res\chkboxes.bmp         		\
	..\res\task_wiz.bmp         		\
	..\res\taskwzhd.bmp         		\
	..\res\h_l.bmp              		\
	..\res\h_m.bmp              		\
	..\res\h_s.bmp              		\
	..\res\hd_l.bmp             		\
	..\res\hd_m.bmp             		\
	..\res\hd_s.bmp             		\
	..\res\t.bmp                		\
	..\res\td.bmp               		\
	..\res\v_l.bmp              		\
	..\res\v_m.bmp              		\
	..\res\v_s.bmp              		\
	..\res\vd_l.bmp             		\
	..\res\vd_m.bmp             		\
	..\res\vd_s.bmp             		\
	..\res\bitmap1.bmp          		\
	..\res\bmp00001.bmp         		\
	..\res\folderop.bmp         		\
	..\res\ocx_16.bmp           		\
	..\res\html16.bmp           		\
	..\res\html_32.bmp          		\
	..\res\bmp00002.bmp         		\
	..\res\folder.ico           		\
	..\res\html.ico             		\
	..\res\ocx.ico              		\
	..\viewext\views.htm        		\
    ..\viewext\ctpcommon.htm            \
    ..\viewext\ctpnoresults.htm         \
    ..\viewext\ctpvert.htm              \
    ..\viewext\ctphoriz.htm             \
    ..\viewext\ctptask.htm              \
	..\res\fldrsnap.rgs         		\
	..\res\ctpsymbols\symbol1.ico		\
	..\res\ctpsymbols\symbol2.ico		\
	..\res\ctpsymbols\symbol3.ico		\
	..\res\ctpsymbols\symbol4.ico		\
	..\res\ctpsymbols\symbol5.ico		\
	..\res\ctpsymbols\symbol6.ico		\
	..\res\ctpsymbols\symbol7.ico		\
	..\res\ctpsymbols\symbol8.ico		\
	..\res\ctpsymbols\symbol9.ico		\
	..\res\ctpsymbols\symbol10.ico		\
	..\res\ctpsymbols\symbol11.ico		\
	..\res\ctpsymbols\symbol12.ico		\
	..\res\ctpsymbols\symbol13.ico		\
	..\res\ctpsymbols\symbol14.ico		\
	..\res\ctpsymbols\symbol15.ico		\
	..\res\ctpsymbols\symbol16.ico		\
	..\res\ctpsymbols\symbol17.ico		\
	..\res\ctpsymbols\symbol18.ico		\
	..\res\ctpsymbols\symbol19.ico		\
	..\res\ctpsymbols\symbol20.ico		\
	..\res\ctpsymbols\symbol21.ico		\
	..\res\ctpsymbols\symbol22.ico		\
	..\res\ctpsymbols\symbol23.ico		\
	..\res\ctpsymbols\symbol24.ico		\
	..\res\ctpsymbols\symbol25.ico		\
	..\res\ctpsymbols\symbol26.ico		\
	..\res\ctpsymbols\symbol27.ico		\
	..\res\ctpsymbols\symbol28.ico		\
	..\res\ctpsymbols\symbol29.ico		\
	..\res\ctpsymbols\symbol30.ico		\
	..\res\ctpsymbols\symbol31.ico		\
	..\res\ctpsymbols\symbol32.ico		\
	..\res\ctpsymbols\symbol33.ico		\
	..\res\ctpsymbols\symbol34.ico		\
	..\res\ctpsymbols\symbol35.ico		\
	..\res\ctpsymbols\symbol36.ico		\
	..\res\ctpsymbols\symbol37.ico		\
	..\res\ctpsymbols\symbol38.ico		\
	..\res\ctpsymbols\symbol39.ico		\
	..\res\ctpsymbols\symbol40.ico		\
	..\res\ctpsymbols\symbol41.ico		\
	..\res\ctpsymbols\symbol42.ico		\
	..\res\ctpsymbols\symbol43.ico		\
	..\res\ctpsymbols\symbol44.ico		\
	..\res\ctpsymbols\symbol45.ico		\
	..\res\ctpsymbols\symbol46.ico		\
	..\res\ctpsymbols\symbol47.ico		\
	..\res\ctpsymbols\symbol48.ico		\
	..\res\ctpsymbols\symbol49.ico		\
	..\res\ctpsymbols\symbol50.ico		\
	..\res\ctpsymbols\symbol51.ico		\
	..\res\ctpsymbols\symbol52.ico		\
	..\res\ctpsymbols\symbol53.ico		\
	..\res\ctpsymbols\symbol54.ico		\
	..\res\ctpsymbols\symbol55.ico		\
	..\res\ctpsymbols\symbol56.ico		\
	..\res\ctpsymbols\symbol57.ico		\
	..\res\ctpsymbols\symbol58.ico		\
	..\res\ctpsymbols\symbol59.ico		\
	..\res\ctpsymbols\symbol60.ico		\
	..\res\ctpsymbols\symbol61.ico		\
	..\res\ctpsymbols\symbol62.ico		\
	..\res\ctpsymbols\symbol63.ico		\
	..\res\ctpsymbols\symbol64.ico		\
	..\res\ctpsymbols\symbol65.ico		\
	..\res\ctpsymbols\symbol66.ico		\
	..\res\ctpsymbols\symbol67.ico		\
	..\res\ctpsymbols\symbol68.ico		\
	..\res\ctpsymbols\symbol69.ico		\
	..\res\ctpsymbols\symbol70.ico		\
	..\res\ctpsymbols\symbol71.ico		\
	..\res\ctpsymbols\symbol72.ico		\
	..\res\ctpsymbols\symbol73.ico		\
	..\res\ctpsymbols\symbol74.ico		\
	..\res\ctpsymbols\symbol75.ico		\
	..\res\ctpsymbols\symbol76.ico		\
	..\res\ctpsymbols\symbol77.ico		\
	..\res\ctpsymbols\symbol78.ico		\
	..\res\ctpsymbols\symbol79.ico		\
	..\res\ctpsymbols\symbol80.ico		\
	..\res\ctpsymbols\symbol81.ico		\
	..\res\ctpsymbols\symbol82.ico		\
	..\res\ctpsymbols\symbol83.ico		\
	..\res\ctpsymbols\symbol84.ico		\
	..\res\ctpsymbols\symbol85.ico		\
	..\res\ctpsymbols\symbol86.ico		\
	..\res\ctpsymbols\symbol87.ico		\
	..\res\ctpsymbols\symbol88.ico		\
	..\res\ctpsymbols\symbol89.ico		\
	..\res\ctpsymbols\symbol90.ico		\
	..\res\ctpsymbols\symbol91.ico		\
	..\res\ctpsymbols\symbol92.ico		\
	..\res\ctpsymbols\symbol93.ico		\
	..\res\ctpsymbols\symbol94.ico		\
	..\res\ctpsymbols\symbol95.ico		\
	..\res\ctpsymbols\symbol96.ico		\
	..\res\ctpsymbols\symbol97.ico		\
	..\res\ctpsymbols\symbol98.ico		\
	..\res\ctpsymbols\symbol99.ico		\
	..\res\ctpsymbols\symbol100.ico		\
	..\res\ctpsymbols\symbol101.ico		\
	..\res\ctpsymbols\symbol102.ico		\
	..\res\ctpsymbols\symbol103.ico		\
	..\res\ctpsymbols\symbol104.ico		\
	..\res\ctpsymbols\symbol105.ico		\
	..\res\ctpsymbols\symbol106.ico		\
	..\res\ctpsymbols\symbol107.ico		\
	..\res\ctpsymbols\symbol108.ico		\
	..\res\ctpsymbols\symbol109.ico		\
	..\res\ctpsymbols\symbol110.ico		\
	..\res\ctpsymbols\symbol111.ico		\
	..\res\ctpsymbols\symbol112.ico		\
	..\res\ctpsymbols\symbol113.ico		\
	..\res\ctpsymbols\symbol114.ico		\
	..\res\ctpsymbols\symbol115.ico		\
	..\res\ctpsymbols\symbol116.ico		\
	..\res\ctpsymbols\symbol117.ico		\
	..\res\ctpsymbols\symbol118.ico		\
	..\res\ctpsymbols\symbol119.ico		\
	..\res\ctpsymbols\symbol120.ico		\
	..\res\ctpsymbols\symbol121.ico		\
	..\res\ctpsymbols\symbol122.ico		\
	..\res\ctpsymbols\symbol123.ico		\
	..\res\ctpsymbols\symbol124.ico		\
	..\res\ctpsymbols\symbol125.ico		\
	..\res\ctpsymbols\symbol126.ico		\
	..\..\types\idl\$(O)\ndmgr.tlb		\

SOURCES = \
	..\nodemgr.rc       		\
	..\about.cpp        		\
	..\addsnpin.cpp     		\
	..\ccomboex.cpp     		\
	..\cmenu.cpp        		\
	..\coldata.cpp      		\
	..\colwidth.cpp     		\
	..\compcat.cpp      		\
	..\copypast.cpp     		\
	..\ctrlbar.cpp      		\
	..\doccnfg.cpp      		\
	..\dummysi.cpp      		\
	..\fldrsnap.cpp     		\
	..\helpdoc.cpp      		\
	..\IconControl.cpp  		\
	..\menubtn.cpp      		\
	..\menuitem.cpp     		\
	..\mmcmt.cpp        		\
	..\mmcprotocol.cpp  		\
	..\moreutil.cpp     		\
	..\msgview.cpp      		\
	..\mtnode.cpp       		\
	..\multisel.cpp     		\
	..\newnode.cpp      		\
	..\nmutil.cpp       		\
	..\node.cpp         		\
	..\node.cpp         		\
	..\nodeinit.cpp     		\
	..\nodemgr.cpp      		\
	..\nodepath.cpp     		\
	..\objfmts.cpp      		\
	..\oncmenu.cpp      		\
	..\plex.cpp         		\
	..\policy.cpp       		\
	..\power.cpp        		\
	..\propsht.cpp      		\
	..\ptrlist.cpp      		\
	..\regkeyex.cpp     		\
	..\regutil.cpp      		\
	..\rsltdata.cpp     		\
	..\scopdata.cpp     		\
	..\scopimag.cpp     		\
	..\scopiter.cpp     		\
	..\scopndcb.cpp     		\
	..\scoptree.cpp     		\
	..\siprop.cpp       		\
	..\snapin.cpp       		\
	..\snapinpersistence.cpp        \
	..\ststring.cpp     		\
	..\task.cpp         		\
	..\taskenum.cpp     		\
	..\tasknode.cpp     		\
	..\tasksym.cpp      		\
	..\tasksymbol.cpp   		\
	..\taskui.cpp       		\
	..\toolbar.cpp      		\
	..\typeinfo.cpp     		\
	..\verbs.cpp        		\
	..\viewdata.cpp     		\
	..\viewext.cpp      		\
	..\viewpers.cpp     		\
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ststring.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ststring.cpp
 *
 *  Contents:  Implementation file for CStringTableString
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"


/*+-------------------------------------------------------------------------*
 * CStringTableString::GetStringTable 
 *
 *
 *--------------------------------------------------------------------------*/

IStringTablePrivate* CStringTableString::GetStringTable () const
{
    return (CScopeTree::GetStringTable());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\ststring.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ststring.h
 *
 *  Contents:  Interface file for CStringTableString
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STSTRING_H
#define STSTRING_H
#pragma once

#include "tstring.h"


/*+-------------------------------------------------------------------------*
 * CStringTableString
 *
 *
 *--------------------------------------------------------------------------*/

class CStringTableString : public CStringTableStringBase
{
    typedef CStringTableStringBase BaseClass;

public:
    CStringTableString () 
        : BaseClass (GetStringTable()) {}

    CStringTableString (const CStringTableString& other)
        : BaseClass (other) {}

    CStringTableString (const tstring& str)
        : BaseClass (GetStringTable(), str) {}
    
    CStringTableString& operator= (const CStringTableString& other)
        { BaseClass::operator= (other); return (*this); }
    
    CStringTableString& operator= (const tstring& str)
        { BaseClass::operator= (str); return (*this); }
    
    CStringTableString& operator= (LPCTSTR psz)
        { BaseClass::operator= (psz); return (*this); }
    
private:
    IStringTablePrivate* GetStringTable() const;

};

#endif /* STSTRING_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\symbinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       symbinfo.h
//
//--------------------------------------------------------------------------

#define CTP_ICON_BASE   30500
#define CTP_STRING_BASE 30000

class CEOTSymbol s_rgEOTSymbol[] =
{
    CEOTSymbol(CTP_ICON_BASE + 1   , 0x0021, CTP_STRING_BASE +   8, CTP_STRING_BASE +   9),
    CEOTSymbol(CTP_ICON_BASE + 2   , 0x0022, CTP_STRING_BASE +  10, CTP_STRING_BASE +  11),
    CEOTSymbol(CTP_ICON_BASE + 3   , 0x0023, CTP_STRING_BASE +  12, CTP_STRING_BASE +  13),
    CEOTSymbol(CTP_ICON_BASE + 4   , 0x0024, CTP_STRING_BASE +  14, CTP_STRING_BASE +  15),
    CEOTSymbol(CTP_ICON_BASE + 5   , 0x0025, CTP_STRING_BASE +  16, CTP_STRING_BASE +  17),
    CEOTSymbol(CTP_ICON_BASE + 6   , 0x0027, CTP_STRING_BASE +  20, CTP_STRING_BASE +  21),
    CEOTSymbol(CTP_ICON_BASE + 7   , 0x0028, CTP_STRING_BASE +  22, CTP_STRING_BASE +  23),
    CEOTSymbol(CTP_ICON_BASE + 8   , 0x0029, CTP_STRING_BASE +  24, CTP_STRING_BASE +  25),
    CEOTSymbol(CTP_ICON_BASE + 9   , 0x002A, CTP_STRING_BASE +  26, CTP_STRING_BASE +  27),
    CEOTSymbol(CTP_ICON_BASE + 10  , 0x002B, CTP_STRING_BASE +  28, CTP_STRING_BASE +  29),
    CEOTSymbol(CTP_ICON_BASE + 11  , 0x002C, CTP_STRING_BASE +  30, CTP_STRING_BASE +  31),
    CEOTSymbol(CTP_ICON_BASE + 12  , 0x002D, CTP_STRING_BASE +  32, CTP_STRING_BASE +  33),
    CEOTSymbol(CTP_ICON_BASE + 13  , 0x002E, CTP_STRING_BASE +  34, CTP_STRING_BASE +  35),
    CEOTSymbol(CTP_ICON_BASE + 14  , 0x002F, CTP_STRING_BASE +  36, CTP_STRING_BASE +  37),
    CEOTSymbol(CTP_ICON_BASE + 15  , 0x0030, CTP_STRING_BASE +  38, CTP_STRING_BASE +  39),
    CEOTSymbol(CTP_ICON_BASE + 16  , 0x0031, CTP_STRING_BASE +  40, CTP_STRING_BASE +  41),
    CEOTSymbol(CTP_ICON_BASE + 17  , 0x0032, CTP_STRING_BASE +  42, CTP_STRING_BASE +  43),
    CEOTSymbol(CTP_ICON_BASE + 18  , 0x0033, CTP_STRING_BASE +  44, CTP_STRING_BASE +  45),
    CEOTSymbol(CTP_ICON_BASE + 19  , 0x0034, CTP_STRING_BASE +  46, CTP_STRING_BASE +  47),
    CEOTSymbol(CTP_ICON_BASE + 20  , 0x0035, CTP_STRING_BASE +  48, CTP_STRING_BASE +  49),
    CEOTSymbol(CTP_ICON_BASE + 21  , 0x0036, CTP_STRING_BASE +  50, CTP_STRING_BASE +  51),
    CEOTSymbol(CTP_ICON_BASE + 22  , 0x0037, CTP_STRING_BASE +  52, CTP_STRING_BASE +  53),
    CEOTSymbol(CTP_ICON_BASE + 23  , 0x0038, CTP_STRING_BASE +  54, CTP_STRING_BASE +  55),
    CEOTSymbol(CTP_ICON_BASE + 24  , 0x0039, CTP_STRING_BASE +  56, CTP_STRING_BASE +  57),
    CEOTSymbol(CTP_ICON_BASE + 25  , 0x003A, CTP_STRING_BASE +  58, CTP_STRING_BASE +  59),
    CEOTSymbol(CTP_ICON_BASE + 26  , 0x003B, CTP_STRING_BASE +  60, CTP_STRING_BASE +  61),
    CEOTSymbol(CTP_ICON_BASE + 27  , 0x003C, CTP_STRING_BASE +  62, CTP_STRING_BASE +  63),
    CEOTSymbol(CTP_ICON_BASE + 28  , 0x003D, CTP_STRING_BASE +  64, CTP_STRING_BASE +  65),
    CEOTSymbol(CTP_ICON_BASE + 29  , 0x003E, CTP_STRING_BASE +  66, CTP_STRING_BASE +  67),
    CEOTSymbol(CTP_ICON_BASE + 30  , 0x003F, CTP_STRING_BASE +  68, CTP_STRING_BASE +  69),
    CEOTSymbol(CTP_ICON_BASE + 31  , 0x0040, CTP_STRING_BASE +  70, CTP_STRING_BASE +  71),
    CEOTSymbol(CTP_ICON_BASE + 32  , 0x0041, CTP_STRING_BASE +  72, CTP_STRING_BASE +  73),
    CEOTSymbol(CTP_ICON_BASE + 33  , 0x0042, CTP_STRING_BASE +  74, CTP_STRING_BASE +  75),
    CEOTSymbol(CTP_ICON_BASE + 34  , 0x0043, CTP_STRING_BASE +  76, CTP_STRING_BASE +  77),
    CEOTSymbol(CTP_ICON_BASE + 35  , 0x0044, CTP_STRING_BASE +  78, CTP_STRING_BASE +  79),
    CEOTSymbol(CTP_ICON_BASE + 36  , 0x0045, CTP_STRING_BASE +  80, CTP_STRING_BASE +  81),
    CEOTSymbol(CTP_ICON_BASE + 37  , 0x0046, CTP_STRING_BASE +  82, CTP_STRING_BASE +  83),
    CEOTSymbol(CTP_ICON_BASE + 38  , 0x0047, CTP_STRING_BASE +  84, CTP_STRING_BASE +  85),
    CEOTSymbol(CTP_ICON_BASE + 39  , 0x0048, CTP_STRING_BASE +  86, CTP_STRING_BASE +  87),
    CEOTSymbol(CTP_ICON_BASE + 40  , 0x0049, CTP_STRING_BASE +  88),
    CEOTSymbol(CTP_ICON_BASE + 41  , 0x004A, CTP_STRING_BASE +  89, CTP_STRING_BASE +  90),
    CEOTSymbol(CTP_ICON_BASE + 42  , 0x004B, CTP_STRING_BASE +  91, CTP_STRING_BASE +  92),
    CEOTSymbol(CTP_ICON_BASE + 43  , 0x004C, CTP_STRING_BASE +  93, CTP_STRING_BASE +  94),
    CEOTSymbol(CTP_ICON_BASE + 44  , 0x004D, CTP_STRING_BASE +  95, CTP_STRING_BASE +  96),
    CEOTSymbol(CTP_ICON_BASE + 45  , 0x004E, CTP_STRING_BASE +  97, CTP_STRING_BASE +  98),
    CEOTSymbol(CTP_ICON_BASE + 46  , 0x004F, CTP_STRING_BASE +  99, CTP_STRING_BASE + 100),
	CEOTSymbol(CTP_ICON_BASE + 47  , 0x0050, CTP_STRING_BASE + 101, CTP_STRING_BASE + 102),
    CEOTSymbol(CTP_ICON_BASE + 48  , 0x0051, CTP_STRING_BASE + 103, CTP_STRING_BASE + 104),
    CEOTSymbol(CTP_ICON_BASE + 49  , 0x0052, CTP_STRING_BASE + 105, CTP_STRING_BASE + 106),
    CEOTSymbol(CTP_ICON_BASE + 50  , 0x0053, CTP_STRING_BASE + 107, CTP_STRING_BASE + 108),
    CEOTSymbol(CTP_ICON_BASE + 51  , 0x0054, CTP_STRING_BASE + 109, CTP_STRING_BASE + 110),
    CEOTSymbol(CTP_ICON_BASE + 52  , 0x0055, CTP_STRING_BASE + 111, CTP_STRING_BASE + 112),
    CEOTSymbol(CTP_ICON_BASE + 53  , 0x0056, CTP_STRING_BASE + 113),
    CEOTSymbol(CTP_ICON_BASE + 54  , 0x0057, CTP_STRING_BASE + 114, CTP_STRING_BASE + 115),
    CEOTSymbol(CTP_ICON_BASE + 55  , 0x0058, CTP_STRING_BASE + 116, CTP_STRING_BASE + 117),
    CEOTSymbol(CTP_ICON_BASE + 56  , 0x0059, CTP_STRING_BASE + 118, CTP_STRING_BASE + 119),
    CEOTSymbol(CTP_ICON_BASE + 57  , 0x005A, CTP_STRING_BASE + 120, CTP_STRING_BASE + 211),
    CEOTSymbol(CTP_ICON_BASE + 58  , 0x005B, CTP_STRING_BASE + 122, CTP_STRING_BASE + 123),
    CEOTSymbol(CTP_ICON_BASE + 59  , 0x005C, CTP_STRING_BASE + 124, CTP_STRING_BASE + 125),
    CEOTSymbol(CTP_ICON_BASE + 60  , 0x005D, CTP_STRING_BASE + 126, CTP_STRING_BASE + 127),
    CEOTSymbol(CTP_ICON_BASE + 61  , 0x0060, CTP_STRING_BASE + 132, CTP_STRING_BASE + 133),
	CEOTSymbol(CTP_ICON_BASE + 62  , 0x0061, CTP_STRING_BASE + 134, CTP_STRING_BASE + 135),
	CEOTSymbol(CTP_ICON_BASE + 63  , 0x0062, CTP_STRING_BASE + 136, CTP_STRING_BASE + 137),
	CEOTSymbol(CTP_ICON_BASE + 64  , 0x0063, CTP_STRING_BASE + 138, CTP_STRING_BASE + 139),
    CEOTSymbol(CTP_ICON_BASE + 65  , 0x0064, CTP_STRING_BASE + 140, CTP_STRING_BASE + 141),
    CEOTSymbol(CTP_ICON_BASE + 66  , 0x0067, CTP_STRING_BASE + 146, CTP_STRING_BASE + 147),
    CEOTSymbol(CTP_ICON_BASE + 67  , 0x0068, CTP_STRING_BASE + 148, CTP_STRING_BASE + 149),
    CEOTSymbol(CTP_ICON_BASE + 68  , 0x0069, CTP_STRING_BASE + 150, CTP_STRING_BASE + 151),
    CEOTSymbol(CTP_ICON_BASE + 69  , 0x006A, CTP_STRING_BASE + 152, CTP_STRING_BASE + 153),
    CEOTSymbol(CTP_ICON_BASE + 70  , 0x006B, CTP_STRING_BASE + 154, CTP_STRING_BASE + 155),
    CEOTSymbol(CTP_ICON_BASE + 71  , 0x006C, CTP_STRING_BASE + 156, CTP_STRING_BASE + 157),
    CEOTSymbol(CTP_ICON_BASE + 72  , 0x0072, CTP_STRING_BASE + 166, CTP_STRING_BASE + 167),
    CEOTSymbol(CTP_ICON_BASE + 73  , 0x0073, CTP_STRING_BASE + 168, CTP_STRING_BASE + 169),
    CEOTSymbol(CTP_ICON_BASE + 74  , 0x0074, CTP_STRING_BASE + 170, CTP_STRING_BASE + 171),
    CEOTSymbol(CTP_ICON_BASE + 75  , 0x0075, CTP_STRING_BASE + 172, CTP_STRING_BASE + 173),
    CEOTSymbol(CTP_ICON_BASE + 76  , 0x0076, CTP_STRING_BASE + 174, CTP_STRING_BASE + 175),
    CEOTSymbol(CTP_ICON_BASE + 77  , 0x0077, CTP_STRING_BASE + 176, CTP_STRING_BASE + 177),
    CEOTSymbol(CTP_ICON_BASE + 78  , 0x0078, CTP_STRING_BASE + 178, CTP_STRING_BASE + 179),
    CEOTSymbol(CTP_ICON_BASE + 79  , 0x0079, CTP_STRING_BASE + 180, CTP_STRING_BASE + 181),
    CEOTSymbol(CTP_ICON_BASE + 80  , 0x007A, CTP_STRING_BASE + 182, CTP_STRING_BASE + 183),
    CEOTSymbol(CTP_ICON_BASE + 81  , 0x007B, CTP_STRING_BASE + 184, CTP_STRING_BASE + 185),
    CEOTSymbol(CTP_ICON_BASE + 82  , 0x007C, CTP_STRING_BASE + 186),
    CEOTSymbol(CTP_ICON_BASE + 83  , 0x007E, CTP_STRING_BASE + 187, CTP_STRING_BASE + 188),
    CEOTSymbol(CTP_ICON_BASE + 84  , 0x007F, CTP_STRING_BASE + 189, CTP_STRING_BASE + 190),
    CEOTSymbol(CTP_ICON_BASE + 85  , 0x0080, CTP_STRING_BASE + 191),
    CEOTSymbol(CTP_ICON_BASE + 86  , 0x0081, CTP_STRING_BASE + 192),
    CEOTSymbol(CTP_ICON_BASE + 87  , 0x201A, CTP_STRING_BASE + 193),
    CEOTSymbol(CTP_ICON_BASE + 88  , 0x0192, CTP_STRING_BASE + 194),
    CEOTSymbol(CTP_ICON_BASE + 89  , 0x201E, CTP_STRING_BASE + 195),
    CEOTSymbol(CTP_ICON_BASE + 90  , 0x2026, CTP_STRING_BASE + 196),
    CEOTSymbol(CTP_ICON_BASE + 91  , 0x2020, CTP_STRING_BASE + 197),
    CEOTSymbol(CTP_ICON_BASE + 92  , 0x2021, CTP_STRING_BASE + 198),
    CEOTSymbol(CTP_ICON_BASE + 93  , 0x02C6, CTP_STRING_BASE + 199, CTP_STRING_BASE + 200),
    CEOTSymbol(CTP_ICON_BASE + 94  , 0x2030, CTP_STRING_BASE + 201, CTP_STRING_BASE + 202),
    CEOTSymbol(CTP_ICON_BASE + 95  , 0x0160, CTP_STRING_BASE + 203, CTP_STRING_BASE + 204),
    CEOTSymbol(CTP_ICON_BASE + 96  , 0x2039, CTP_STRING_BASE + 205, CTP_STRING_BASE + 206),
    CEOTSymbol(CTP_ICON_BASE + 97  , 0x0152, CTP_STRING_BASE + 207, CTP_STRING_BASE + 208),
    CEOTSymbol(CTP_ICON_BASE + 98  , 0x008D, CTP_STRING_BASE + 209, CTP_STRING_BASE + 210),
    CEOTSymbol(CTP_ICON_BASE + 99  , 0x008E, CTP_STRING_BASE + 211, CTP_STRING_BASE + 212),
    CEOTSymbol(CTP_ICON_BASE + 100 , 0x008F, CTP_STRING_BASE + 213, CTP_STRING_BASE + 214),
    CEOTSymbol(CTP_ICON_BASE + 101 , 0x0090, CTP_STRING_BASE + 215, CTP_STRING_BASE + 216),
    CEOTSymbol(CTP_ICON_BASE + 102 , 0x2018, CTP_STRING_BASE + 217, CTP_STRING_BASE + 218),
    CEOTSymbol(CTP_ICON_BASE + 103 , 0x2019, CTP_STRING_BASE + 219, CTP_STRING_BASE + 220),
    CEOTSymbol(CTP_ICON_BASE + 104 , 0x201C, CTP_STRING_BASE + 221, CTP_STRING_BASE + 222),
    CEOTSymbol(CTP_ICON_BASE + 105 , 0x201D, CTP_STRING_BASE + 223, CTP_STRING_BASE + 224),
    CEOTSymbol(CTP_ICON_BASE + 106 , 0x2022, CTP_STRING_BASE + 225, CTP_STRING_BASE + 226),
    CEOTSymbol(CTP_ICON_BASE + 107 , 0x2013, CTP_STRING_BASE + 227, CTP_STRING_BASE + 228),
    CEOTSymbol(CTP_ICON_BASE + 108 , 0x2014, CTP_STRING_BASE + 229, CTP_STRING_BASE + 230),
    CEOTSymbol(CTP_ICON_BASE + 109 , 0x02DC, CTP_STRING_BASE + 231, CTP_STRING_BASE + 232),
    CEOTSymbol(CTP_ICON_BASE + 110 , 0x2122, CTP_STRING_BASE + 233, CTP_STRING_BASE + 234),
    CEOTSymbol(CTP_ICON_BASE + 111 , 0x0161, CTP_STRING_BASE + 235),
    CEOTSymbol(CTP_ICON_BASE + 112 , 0x203A, CTP_STRING_BASE + 236, CTP_STRING_BASE + 237),
    CEOTSymbol(CTP_ICON_BASE + 113 , 0x0153, CTP_STRING_BASE + 238, CTP_STRING_BASE + 239),
    CEOTSymbol(CTP_ICON_BASE + 114 , 0x009D, CTP_STRING_BASE + 240),
    CEOTSymbol(CTP_ICON_BASE + 115 , 0x009E, CTP_STRING_BASE + 241, CTP_STRING_BASE + 242),
    CEOTSymbol(CTP_ICON_BASE + 116 , 0x0178, CTP_STRING_BASE + 243),
    CEOTSymbol(CTP_ICON_BASE + 117 , 0x00A0, CTP_STRING_BASE + 244, CTP_STRING_BASE + 245),
    CEOTSymbol(CTP_ICON_BASE + 118 , 0x00A2, CTP_STRING_BASE + 250, CTP_STRING_BASE + 251),
    CEOTSymbol(CTP_ICON_BASE + 119 , 0x00A3, CTP_STRING_BASE + 252, CTP_STRING_BASE + 253),
    CEOTSymbol(CTP_ICON_BASE + 120 , 0x00A4, CTP_STRING_BASE + 254, CTP_STRING_BASE + 255),
    CEOTSymbol(CTP_ICON_BASE + 121 , 0x00A5, CTP_STRING_BASE + 256, CTP_STRING_BASE + 257),
    CEOTSymbol(CTP_ICON_BASE + 122 , 0x00A6, CTP_STRING_BASE + 258, CTP_STRING_BASE + 259),
    CEOTSymbol(CTP_ICON_BASE + 123 , 0x00A7, CTP_STRING_BASE + 260, CTP_STRING_BASE + 261),
    CEOTSymbol(CTP_ICON_BASE + 124 , 0x00A8, CTP_STRING_BASE + 262, CTP_STRING_BASE + 263),
    CEOTSymbol(CTP_ICON_BASE + 125 , 0x00A9, CTP_STRING_BASE + 264, CTP_STRING_BASE + 265),
    CEOTSymbol(CTP_ICON_BASE + 0   , 0x00AA, CTP_STRING_BASE + 266, CTP_STRING_BASE + 267),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\task.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      task.cpp
 *
 *  Contents:  Implementation file for CConsoleTask
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "regutil.h"
#include "tasks.h"
#include "nodepath.h"
#include "conview.h"

#ifdef DBG
// Traces
CTraceTag tagCTPHTML(TEXT("Console Taskpads"), TEXT("Dump HTML"));
#endif

extern CEOTSymbol s_rgEOTSymbol[];

/*+-------------------------------------------------------------------------*
 *  class CGlobalConsoleTaskList
 *
 * PURPOSE: A global console task list that provides unique IDs for all console tasks
 *          When a task is instantiated, its constructor registers in the global task list,
 *          and obtains a globally unique ID. This ID is unique for the process and should
 *          not be persisted.
 *          The destructor of the task removes it from this list.
 *
 * USAGE:   Call CGlobalConsoleTaskList::GetConsoleTask to obtain a pointer to the  task
 *          that has a specified ID.
 *          Call CConsoleTask::GetUniqueID to get the unique ID for a task.
 *
 *          Thus, CGlobalConsoleTaskList::GetConsoleTask(pConsoleTask->GetUniqueID()) == pConsoleTask
 *          is always true.
 *+-------------------------------------------------------------------------*/
class CGlobalConsoleTaskList
{
private:
    typedef const CConsoleTask *              PCONSOLETASK;
    typedef std::map<PCONSOLETASK, DWORD>     t_taskIDmap;

public:
    static DWORD Advise(  PCONSOLETASK pConsoleTask)
    {
        DWORD dwOut = s_curTaskID++;
        s_map[pConsoleTask] = dwOut;
        return dwOut;
    }

    static void Unadvise(PCONSOLETASK pConsoleTask)
    {
        s_map.erase(pConsoleTask);
    }

    static CConsoleTask * GetConsoleTask(DWORD dwID)
    {
        t_taskIDmap::iterator iter;
        for(iter = s_map.begin(); iter != s_map.end(); iter ++)
        {
            if(iter->second == dwID)
                return const_cast<CConsoleTask *>(iter->first);
        }

        return NULL;
    }

private:
    CGlobalConsoleTaskList() {}// private, so that it cannot be instantiated

    static t_taskIDmap            s_map;
    static DWORD                  s_curTaskID;
};

CGlobalConsoleTaskList::t_taskIDmap            CGlobalConsoleTaskList::s_map;
DWORD                  CGlobalConsoleTaskList::s_curTaskID = 0;

//############################################################################
//############################################################################
//
//  Implementation of class CConsoleTask
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CConsoleTask::CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/
DEBUG_DECLARE_INSTANCE_COUNTER(CConsoleTask);

CConsoleTask::CConsoleTask() :
    m_eConsoleTaskType (eTask_Result),
//  default ctor for m_strName
//  default ctor for m_strDescription
//  default ctor for m_strCommand
//  default ctor for m_strParameters
//  default ctor for m_strDirectory
    m_eWindowState     (eState_Restored),
//  default ctor for m_image
    m_dwFlags          (0),
    m_bmScopeNode      (false),
    m_fDirty           (false),
    m_pctpOwner        (NULL),
    m_dwUniqueID       (CGlobalConsoleTaskList::Advise(this)) // create a unique ID for this task
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsoleTask);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::CConsoleTask(const CConsoleTask& other)
 *
 * PURPOSE: Copy ctor.
 *
 * PARAMETERS: const CConsoleTask& other
 *
 * NOTE: Calls operator=, cant use default copy ctor (see operator= imp.)
 *
/*+-------------------------------------------------------------------------*/
CConsoleTask::CConsoleTask (const CConsoleTask &rhs):
    m_dwUniqueID       (CGlobalConsoleTaskList::Advise(this))
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsoleTask);
    *this = rhs;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::GetConsoleTask
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    DWORD  dwUniqueID :
 *
 * RETURNS:
 *    CConsoleTask *
 *
 *+-------------------------------------------------------------------------*/
CConsoleTask *
CConsoleTask::GetConsoleTask(DWORD dwUniqueID)
{
    return CGlobalConsoleTaskList::GetConsoleTask(dwUniqueID);
}


/*+-------------------------------------------------------------------------*
 *
 * ScReplaceString
 *
 * PURPOSE: Replaces all occurrences of the token by its replacement.
 *
 * PARAMETERS:
 *    CStr &   str :
 *    LPCTSTR  szToken :
 *    LPCTSTR  szReplacement :
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
static SC
ScReplaceString(CStr &str, LPCTSTR szToken, LPCTSTR szReplacement, bool bMustReplace = true)
{
    DECLARE_SC(sc, TEXT("ScReplaceString"));

    CStr strTemp = str;
    str = TEXT("");

    int i = strTemp.Find(szToken);
    if( (-1==i) && bMustReplace)
        return (sc = E_UNEXPECTED);

    while(-1!=i)
    {
        str += strTemp.Left(i);
        str += szReplacement;

        strTemp = strTemp.Mid(i+_tcslen(szToken)); // the remaining string

        i=strTemp.Find(szToken);
    }

    str += strTemp;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScUseJavaScriptStringEntities
 *
 * PURPOSE: Use this to create a valid Javascript string. Replaces " by \" and
 *          \ by \\ in the string parameter.
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
static SC
ScUseJavaScriptStringEntities(CStr &str)
{
    DECLARE_SC(sc, TEXT("ScUseJavaScriptStringEntities"));

    // NOTE: don't change the order of these string replacements

    sc = ScReplaceString(str, TEXT("\\"), TEXT("\\\\"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT("\""), TEXT("\\\""), false);
    if(sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScUseHTMLEntities
 *
 * PURPOSE:  Replaces " by &quot; < by &lt; and > by &gt; and & by &amp; in the string parameter.
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    static SC
 *
 *+-------------------------------------------------------------------------*/
static SC
ScUseHTMLEntities(CStr &str)
{
    DECLARE_SC(sc, TEXT("ScUseHTMLEntities"));

    sc = ScReplaceString(str, TEXT("&"), TEXT("&amp;"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT("\""), TEXT("&quot;"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT("<"), TEXT("&lt;"), false);
    if(sc)
        return sc;

    sc = ScReplaceString(str, TEXT(">"), TEXT("&gt;"), false);
    if(sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::ScGetHTML
 *
 * PURPOSE: returns the HTML representation of the task.
 *
 * PARAMETERS:
 *    LPCTSTR  szFmtHTML :
 *    CStr &   strTaskHTML :
 *    bool     bUseLargeIcons :    Draw in the no-list (large icon) style
 *    bool     bUseTextDescriptions :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTask::ScGetHTML(LPCTSTR szFmtHTML, CStr &strTaskHTML, bool bUseLargeIcons, bool bUseTextDescriptions) const
{
    DECLARE_SC(sc, TEXT("CConsoleTask::ScGetHTML"));
    USES_CONVERSION;

    // the substitution parameters, in order
    CStr    strTableSpacing            = bUseLargeIcons ? TEXT("<BR />") : TEXT("");
    int     iconWidth                  = bUseLargeIcons ? 32: 20;
    int     iconHeight                 = bUseLargeIcons ? 32: 16;
    //      iconWidth and iconHeight repeated
    int     uniqueID                   = GetUniqueID();
    CStr    strSmall                   = bUseLargeIcons ? TEXT("0") : TEXT("1");
    CStr    strHref;
    CStr    strID;
    CStr    strParameter;
    CStr    strOptionalTitleTag;
    CStr    strOptionalTextDescription;
    CStr    strTaskName                = GetName().data();
    CStr    strDescription             = GetDescription().data();
    CStr    strCommand                 = GetCommand().data();

    // use entities for all strings
    sc = ScUseHTMLEntities(strTaskName);
    if(sc)
        return sc;

    sc = ScUseHTMLEntities(strDescription);
    if(sc)
        return sc;

    sc = ScUseJavaScriptStringEntities(strCommand);
    if(sc)
        return sc;

    //------
    if(bUseTextDescriptions)
    {
        strOptionalTextDescription =  TEXT("<BR />");
        strOptionalTextDescription += strDescription;
    }
    else
    {
        strOptionalTitleTag.Format(TEXT("title='%s'"), (LPCTSTR) strDescription);
    }

    switch(GetTaskType())
    {
    case eTask_Scope:
        {
            std::wstring strTemp;

            // get the bookmark of the scope node.
            sc = m_bmScopeNode.ScSaveToString(&strTemp);
            if(sc)
                return sc;

            CStr strScopeNodeBookmark = W2CT(strTemp.data()); // make sure that special characters have been converted
            sc = ScUseJavaScriptStringEntities(strScopeNodeBookmark);
            if(sc)
                return sc;

            strHref.Format(TEXT("external.ExecuteScopeNodeMenuItem(\"%s\", \"%s\");"), (LPCTSTR)strCommand, (LPCTSTR)strScopeNodeBookmark);
        }

        strID=L"ScopeTask";
        break;

    case eTask_Result:
        strHref.Format(TEXT("external.ExecuteSelectionMenuItem(\"%s\");"), (LPCTSTR)strCommand);
        strParameter = strCommand;
        strID        = TEXT("ResultTask");
        break;

    case eTask_CommandLine:
        {
            strParameter = GetParameters().data();
            sc = ScUseJavaScriptStringEntities(strParameter);
            if(sc)
                return sc;

            CStr strDirectory = GetDirectory().data();
            sc = ScUseJavaScriptStringEntities(strDirectory);
            if(sc)
                return sc;

            // get the window state
            CStr strWindowState;

            if(GetWindowState() ==eState_Restored)
                strWindowState = XML_ENUM_WINDOW_STATE_RESTORED;

            else if(GetWindowState() == eState_Minimized)
                strWindowState = XML_ENUM_WINDOW_STATE_MINIMIZED;

            else
                strWindowState = XML_ENUM_WINDOW_STATE_MAXIMIZED;

            strHref.Format(TEXT("external.ExecuteShellCommand(\"%s\", \"%s\", ParseParameters(\"%s\"), \"%s\");"),
                           (LPCTSTR)strCommand, (LPCTSTR)strDirectory, (LPCTSTR)strParameter, (LPCTSTR)strWindowState);
        }
        strID=L"CommandLineTask";

        break;

    case eTask_Target:
        strHref.Format(TEXT("external.ExecuteScopeNodeMenuItem(\"%s\");"), (LPCTSTR)strCommand);
        strParameter = strCommand;
        strID        = L"TargetTask";
        break;

    case eTask_Favorite:
        {
            std::wstring strTemp;
            // save the memento to a string
            sc = const_cast<CMemento *>(&m_memento)->ScSaveToString(&strTemp);
            if(sc)
                return sc;

            CStr strMemento = W2CT(strTemp.data());

            sc = ScUseJavaScriptStringEntities(strMemento);
            if(sc)
                return sc;

            strHref.Format(TEXT("external.ViewMemento(\"%s\");"), (LPCTSTR)strMemento);
        }
        strID=L"FavoriteTask";
        break;

    default:
        break;
    }


    strTaskHTML.Format(szFmtHTML, (LPCTSTR) strTableSpacing, iconWidth, iconHeight, uniqueID, iconWidth, iconHeight,
                       uniqueID, (LPCTSTR) strSmall, uniqueID, uniqueID, (LPCTSTR) strID, (LPCTSTR) strParameter,
                       (LPCTSTR) strOptionalTitleTag, (LPCTSTR)strTaskName, (LPCTSTR) strOptionalTextDescription,
                       uniqueID, uniqueID, uniqueID, (LPCTSTR) strHref);

    Trace(tagCTPHTML, TEXT("%s"), (LPCTSTR)strTaskHTML);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::IsDirty
 *
 * PURPOSE: Determines whether the task needs to be saved.
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool
CConsoleTask::IsDirty() const
{
    TraceDirtyFlag(TEXT("CConsoleTask"), m_fDirty);
    return (m_fDirty);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::operator =
 *
 * PURPOSE: Assignment operator
 *
 * PARAMETERS: const CConsoleTask& rhs
 *
 * RETURNS:
 *      CConsoleTask &
 *
/*+-------------------------------------------------------------------------*/
CConsoleTask &
CConsoleTask::operator =(const CConsoleTask& rhs)
{
    if (this != &rhs)
    {
        m_eConsoleTaskType  = rhs.m_eConsoleTaskType;
        m_strName           = rhs.m_strName;
        m_strDescription    = rhs.m_strDescription;
        m_strCommand        = rhs.m_strCommand;
        m_strParameters     = rhs.m_strParameters;
        m_strDirectory      = rhs.m_strDirectory;
        m_eWindowState      = rhs.m_eWindowState;
        m_dwFlags           = rhs.m_dwFlags;
        m_bmScopeNode       = rhs.m_bmScopeNode;
        m_dwSymbol          = rhs.m_dwSymbol;
        m_smartIconCustomLarge  = rhs.m_smartIconCustomLarge;
        m_smartIconCustomSmall  = rhs.m_smartIconCustomSmall;
        m_memento           = rhs.m_memento;

        m_fDirty            = rhs.m_fDirty;
        m_pctpOwner         = rhs.m_pctpOwner;
        // m_dwUniqueID       = rhs.m_dwUniqueID; DO NOT copy this ID
    }

    return *this;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::operator ==
 *
 * PURPOSE: Equality operator. Checks that the command string is
 *          equal to the given menuitem's Path or Language Independent Path.
 *
 *+-------------------------------------------------------------------------*/
bool
CConsoleTask::operator==(const CMenuItem & menuItem) const
{
    // check that the command string matches either the path or the language independent path.

    if( (m_strCommand == menuItem.GetPath()) ||
        (m_strCommand == menuItem.GetLanguageIndependentPath() )
      )
        return true;

    return false;
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::~CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTask::~CConsoleTask ()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CConsoleTask);

    CGlobalConsoleTaskList::Unadvise(this); // remove this task from the list.
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::HasCustomIcon
 *
 * PURPOSE: Returns whether the task has a custom icon
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool
CConsoleTask::HasCustomIcon()   const
{
    if((HICON)m_smartIconCustomLarge != NULL)
    {
        ASSERT((HICON)m_smartIconCustomSmall != NULL);
        return true;
    }

    return false;
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::Reset
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::ResetUI()
{
    m_bmScopeNode.ResetUI();
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::SetSymbol
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    DWORD  dwSymbol :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::SetSymbol(DWORD dwSymbol)
{
    m_dwSymbol = dwSymbol;
    m_smartIconCustomSmall.Release();
    m_smartIconCustomLarge.Release();
    SetDirty();
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::SetCustomIcon
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CSmartIcon& iconSmall :
 *    CSmartIcon& iconLarge :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::SetCustomIcon(CSmartIcon& iconSmall, CSmartIcon& iconLarge)
{
    m_smartIconCustomSmall = iconSmall;
    m_smartIconCustomLarge = iconLarge;
    SetDirty();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::Enable
 *
 * Sets the enable state for a task.
 *--------------------------------------------------------------------------*/

void CConsoleTask::Enable (bool fEnable)
{
    if (fEnable)
        m_dwFlags &= ~eFlag_Disabled;
    else
        m_dwFlags |= eFlag_Disabled;

    SetDirty ();
}

void
CConsoleTask::Draw (HDC hdc, RECT *lpRect, bool bSmall) const  // Draw into a DC.
{
    if(HasCustomIcon())
    {
        DrawIconEx(hdc, lpRect->left, lpRect->top, bSmall ? m_smartIconCustomSmall : m_smartIconCustomLarge,
               bSmall? 16 : 32, bSmall? 16 : 32, 0, NULL, DI_NORMAL);
        return;
    }

    for(int i = 0; i< NUM_SYMBOLS; i++)
    {
        if(s_rgEOTSymbol[i].GetValue() == m_dwSymbol)
        {
            s_rgEOTSymbol[i].Draw(hdc, lpRect, bSmall);
            return;
        }
    }

	/*
	 * if we get here, we couldn't find the EOT symbol matching m_dwSymbol
	 */
	ASSERT (false);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetName
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetName (const tstring& strName)
{
    if (m_strName != strName)
    {
        m_strName = strName;
        SetDirty ();
    }
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetDescription
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetDescription (const tstring& strDescription)
{
    if (m_strDescription != strDescription)
    {
        m_strDescription = strDescription;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetCommand
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetCommand (const tstring& strCommand)
{
    if (m_strCommand != strCommand)
    {
        m_strCommand = strCommand;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetParameters
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetParameters (const tstring& strParameters)
{
    if (m_strParameters != strParameters)
    {
        m_strParameters = strParameters;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetDirectory
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetDirectory (const tstring& strDirectory)
{
    if (m_strDirectory != strDirectory)
    {
        m_strDirectory = strDirectory;
        SetDirty ();
    }
}


void CConsoleTask::SetMemento(const CMemento &memento)
{
    if( m_memento != memento)
    {
        m_memento = memento;
        SetDirty();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::SetWindowState
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTask::SetWindowState (eWindowState eNewState)
{
    if (m_eWindowState != eNewState)
    {
        m_eWindowState = eNewState;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::RetargetScopeNode
 *
 * PURPOSE: Sets the target scope node for the task. Note: the task must be
 *           of type eTask_Scope.
 *
 * PARAMETERS:
 *      CNode *  pNewNode:
 *
 * RETURNS:
 *      bool
 */
/*+-------------------------------------------------------------------------*/
bool
CConsoleTask::RetargetScopeNode(CNode *pNewNode)
{
    bool fRet = TRUE;

    ASSERT(GetTaskType() == eTask_Scope);

    CMTNode* pMTNewNode = (pNewNode) ? pNewNode->GetMTNode() : NULL;

    m_bmScopeNode.ScRetarget(pMTNewNode, false /*bFastRetrievalOnly*/);

    SetDirty();
    return fRet;
}

/*+-------------------------------------------------------------------------*
 * CConsoleTask::GetScopeNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      IScopeTree *  pScopeTree:
 *
 * RETURNS:
 *      CMTNode *
 *
/*+-------------------------------------------------------------------------*/
CMTNode *
CConsoleTask::GetScopeNode(IScopeTree *pScopeTree) const
{
    DECLARE_SC(sc, TEXT("CConsoleTask::GetScopeNode"));

    CMTNode *pMTNode = NULL;
    bool bExactMatchFound = false; // out value from ScGetMTNode, unused
    sc = m_bmScopeNode.ScGetMTNode(true /*bExactMatchRequired*/, &pMTNode, bExactMatchFound);
    if(sc.IsError())
        return NULL;

    return (pMTNode);
}



/*+-------------------------------------------------------------------------*
 * CConsoleTask::GetScopeNode
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      CViewData *  pViewData:
 *
 * RETURNS:
 *      CNode *
/*+-------------------------------------------------------------------------*/
std::auto_ptr<CNode>
CConsoleTask::GetScopeNode(CViewData *pViewData) const
{
    return m_bmScopeNode.GetNode(pViewData);
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTask::Persist
 *
 * PURPOSE: Persists the console task to the specified persistor.
 *
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTask::Persist(CPersistor &persistor)
{

    persistor.PersistString(XML_ATTR_TASK_NAME,         m_strName);

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedTaskTypes[] =
    {
        { eTask_Scope,            XML_ENUM_TASK_TYPE_SCOPE },
        { eTask_Result,           XML_ENUM_TASK_TYPE_RESULT },
        { eTask_CommandLine,      XML_ENUM_TASK_TYPE_COMMANDLINE },
        { eTask_Target,           XML_ENUM_TASK_TYPE_TARGET },
        { eTask_Favorite,         XML_ENUM_TASK_TYPE_FAVORITE },
    };


    // create wrapper to persist flag values as strings
    CXMLEnumeration taskTypePersistor(m_eConsoleTaskType, mappedTaskTypes, countof(mappedTaskTypes));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASK_TYPE,      taskTypePersistor);

    persistor.PersistString(XML_ATTR_TASK_DESCRIPTION,  m_strDescription);

    {
        /* this section creates
            <ConsoleTask>
                <SYMBOL id = "">
                    <IMAGE name = "LargeIcon" ... />   NOTE: either the id or the images are present.
                    <IMAGE name = "SmallIcon" ... />
                </SYMBOL>
            </ConsoleTask>
         */

        // create a child element for the symbol
        CPersistor persistorSymbol(persistor, XML_TAG_EOT_SYMBOL_INFO);

        if(persistorSymbol.IsLoading())
        {
            m_dwSymbol = (DWORD)-1; // initialize
        }

        if(persistorSymbol.IsLoading() ||
           (persistorSymbol.IsStoring() && !HasCustomIcon() ) )
        {
            // save the "ID" attribute only if there is no icon
            persistorSymbol.PersistAttribute(XML_ATTR_EOT_SYMBOL_DW_SYMBOL,   m_dwSymbol, attr_optional);
        }

        if((persistorSymbol.IsStoring() && HasCustomIcon()) ||
           (persistorSymbol.IsLoading() && (m_dwSymbol == (DWORD) -1)  )
           )
        {
			persistorSymbol.Persist (m_smartIconCustomSmall, XML_NAME_ICON_SMALL);
			persistorSymbol.Persist (m_smartIconCustomLarge, XML_NAME_ICON_LARGE);
        }
    }

    persistor.PersistAttribute(XML_ATTR_TASK_COMMAND,   m_strCommand);

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedTaskFlags[] =
    {
        { eFlag_Disabled, XML_BITFLAG_TASK_DISABLED },
    };

    // create wrapper to persist flag values as strings
    CXMLBitFlags taskFlagPersistor(m_dwFlags, mappedTaskFlags, countof(mappedTaskFlags));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASK_FLAGS, taskFlagPersistor);

    switch (m_eConsoleTaskType)
    {
        case eTask_Scope:
            persistor.Persist(m_bmScopeNode);
            break;

        case eTask_CommandLine:
        {
            CPersistor persistorCmd(persistor, XML_TAG_TASK_CMD_LINE);
            persistorCmd.PersistAttribute(XML_ATTR_TASK_CMD_LINE_DIR, m_strDirectory);

            // define the table to map enumeration values to strings
            static const EnumLiteral windowStates[] =
            {
                { eState_Restored,      XML_ENUM_WINDOW_STATE_RESTORED },
                { eState_Minimized,     XML_ENUM_WINDOW_STATE_MINIMIZED },
                { eState_Maximized,     XML_ENUM_WINDOW_STATE_MAXIMIZED },
            };

            // create wrapper to persist flag values as strings
            CXMLEnumeration windowStatePersistor(m_eWindowState, windowStates, countof(windowStates));
            // persist the wrapper
            persistorCmd.PersistAttribute(XML_ATTR_TASK_CMD_LINE_WIN_ST, windowStatePersistor);

            persistorCmd.PersistAttribute(XML_ATTR_TASK_CMD_LINE_PARAMS, m_strParameters);
            break;
        }

        case eTask_Favorite:
            persistor.Persist(m_memento);
            break;
    }

    // either read or saved - not dirty after the operation
    SetDirty(false);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTask::ReadSerialObject
 *
 *
 *--------------------------------------------------------------------------*/
HRESULT
CConsoleTask::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume unknown version

    if (nVersion == 1)
    {
        try
        {
            // ugly hackery required to extract directly into an enum
            stm >> *((int *) &m_eConsoleTaskType);
            stm >> m_strName;
            stm >> m_strDescription;

            // legacy task symbol info
            {
                // this must be BOOL not bool to occupy the same amount of space as in legacy consoles
                // See Bug #101253
                BOOL bLegacyUseMMCSymbols = TRUE; // a now obsolete field, read for console file compatibility
                tstring strFileLegacy, strFontLegacy;

                stm >> m_dwSymbol;
                stm >> bLegacyUseMMCSymbols;
                stm >> strFileLegacy; // obsolete
                stm >> strFontLegacy; // obsolete
            }

            stm >> m_strCommand;
            stm >> m_dwFlags;

            switch (m_eConsoleTaskType)
            {
                case eTask_Scope:
                    stm >> m_bmScopeNode;
                    break;

                case eTask_CommandLine:
                    stm >> m_strDirectory;
                    // ugly hackery required to extract directly into an enum
                    stm >> *((int *) &m_eWindowState);
                    stm >> m_strParameters;
                    break;

                case eTask_Favorite:
                    hr = m_memento.Read(stm);
                    if(FAILED(hr))
                        return hr;
                    break;
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}



/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::CConsoleTaskpad
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::CConsoleTaskpad (CNode* pTargetNode /*=NULL*/) :
    m_listSize(eSize_Default),   // the default space given to a taskpad.
    m_guidNodeType(GUID_NULL),
    m_guidID(GUID_NULL),
    m_bmTargetNode(),
    m_pMTNodeTarget(NULL),
    m_bNodeSpecific(false),
    m_dwOrientation(TVO_VERTICAL), // the default is a vertical taskpad for consistency with the Extended view.
    m_bReplacesDefaultView(true) // taskpads do not show the normal tab by default.
{
    Retarget (pTargetNode);

    HRESULT hr = CoCreateGuid(&m_guidID);
    ASSERT(SUCCEEDED(hr));

    SetDirty (false);
}

bool
CConsoleTaskpad::IsValid(CNode *pNode) const
{
    ASSERT(pNode != NULL);

    if(!HasTarget())
        return true; // a taskpad without a target is valid for any node. $REVIEW

    if(!pNode)
        return false; // Cannot use a taskpad with a target.

    if(IsNodeSpecific())
    {
        // use this taskpad if it is targetted at the same node. $OPTIMIZE.
        return (*pNode->GetMTNode()->GetBookmark() == m_bmTargetNode);
    }
    else
    {
        GUID guid;
        HRESULT hr = pNode->GetNodeType(&guid);
        if(FAILED(hr))
            return false; // don't use this taskpad.

        return (MatchesNodeType(guid)); // use only if node types match.
    }


}

static CStr g_szTaskpadCommonHTMLTemplate;
static CStr g_szVerticalTaskpadHTMLTemplate;
static CStr g_szHorizontalTaskpadHTMLTemplate;
static CStr g_szNoResultsTaskpadHTMLTemplate;
static CStr g_szTaskHTMLTemplate;
/*+-------------------------------------------------------------------------*
 *
 * ScLoadHTMLTemplate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    HINSTANCE  hinstLibrary :
 *    LPCTSTR    szHTMLTemplateResourceName :
 *    CStr&      str :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScLoadHTMLTemplate(HINSTANCE hinstLibrary, LPCTSTR szHTMLTemplateResourceName, CStr& str)
{
    DECLARE_SC(sc, TEXT("ScLoadHTMLTemplate"));

    sc = ScCheckPointers(hinstLibrary, szHTMLTemplateResourceName);
    if(sc)
        return sc;

    HRSRC hFindRes = ::FindResource(hinstLibrary, szHTMLTemplateResourceName, RT_HTML);
    if(!hFindRes)
        return (sc = E_UNEXPECTED);

    DWORD dwResSize = ::SizeofResource(hinstLibrary, hFindRes);
    if(!dwResSize)
        return (sc = E_UNEXPECTED);

    HGLOBAL hRes = ::LoadResource(hinstLibrary, hFindRes);
    ASSERT(hRes);

    char *pvRes = (char *)::LockResource(hRes);  // no need to Unlock the resource - see the SDK entry for LockResource
    sc = ScCheckPointers(pvRes);
    if(sc)
        return sc;

    std::string strTemp; // initially create an ANSI string
    strTemp.assign(pvRes, dwResSize);
    strTemp+="\0"; // null terminate it

    USES_CONVERSION;
    str = A2CT(strTemp.data());

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScLoadHTMLTemplates
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
ScLoadHTMLTemplates()
{
    DECLARE_SC(sc, TEXT("ScLoadHTMLTemplates"));

    static BOOL bInitialized = false;
    if(bInitialized)
        return sc;

    // load the library into memory.
    TCHAR szBuffer[MAX_PATH];

    DWORD cchSize = countof(szBuffer);
    DWORD dwRet = ::GetModuleFileName(_Module.GetModuleInstance(), szBuffer, cchSize);
    if(0==dwRet)
        return (sc = E_UNEXPECTED);

    // NTRAID#NTBUG9-616478-2002/05/07-ronmart-prefast  warning 53: Call to 'GetModuleFileNameW' may not zero-terminate string
    szBuffer[cchSize - 1] = 0;

    HINSTANCE hinstLibrary = ::LoadLibraryEx(szBuffer, 0, LOAD_LIBRARY_AS_DATAFILE);
    if(!hinstLibrary)
        return (sc = E_UNEXPECTED);

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPCOMMON.HTM"), g_szTaskpadCommonHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPVERT.HTM"), g_szVerticalTaskpadHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPHORIZ.HTM"), g_szHorizontalTaskpadHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPNORESULTS.HTM"), g_szNoResultsTaskpadHTMLTemplate);
    if(sc)
        goto Error;

    sc = ScLoadHTMLTemplate(hinstLibrary, TEXT("CTPTASK.HTM"), g_szTaskHTMLTemplate);
    if(sc)
        goto Error;

    bInitialized = true;

Cleanup:
    FreeLibrary(hinstLibrary);
    return sc;
Error:
    sc = E_UNEXPECTED;
    goto Cleanup;

}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpad::ScGetHTML
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CStr & strTaskpadHTML :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTaskpad::ScGetHTML(CStr &strTaskpadHTML) const
{
    DECLARE_SC(sc, TEXT("CConsoleTaskpad::ScGetHTML"));

    sc = ScLoadHTMLTemplates();
    if(sc)
        return sc;


    CStr strTasksHTML;

    // get the HTML for all the tasks
    for (TaskConstIter it = m_Tasks.begin(); it != m_Tasks.end(); ++it)
    {
        CStr strTemp;
        sc = it->ScGetHTML(g_szTaskHTMLTemplate, strTemp, GetOrientation() & TVO_NO_RESULTS /*bUseLargeIcons*/, GetOrientation() & TVO_DESCRIPTIONS_AS_TEXT);
        if(sc)
            return sc;

        strTasksHTML += strTemp;
    }

    strTaskpadHTML = g_szTaskpadCommonHTMLTemplate;

    // append the orientation-specific portion
    CStr *pstrOrientationSpecificHTML = NULL;

    if(GetOrientation() & TVO_HORIZONTAL)
        pstrOrientationSpecificHTML = &g_szHorizontalTaskpadHTMLTemplate;

    else if (GetOrientation() & TVO_VERTICAL)
        pstrOrientationSpecificHTML = &g_szVerticalTaskpadHTMLTemplate;

    else
        pstrOrientationSpecificHTML = &g_szNoResultsTaskpadHTMLTemplate;

    sc = ScCheckPointers(pstrOrientationSpecificHTML, E_UNEXPECTED);
    if(sc)
        return sc;

    // this replacement must be done first
    sc = ScReplaceString(strTaskpadHTML, TEXT("@@ORIENTATIONSPECIFICHTML@@"), *pstrOrientationSpecificHTML);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@TASKS@@"), strTasksHTML);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@TASKWIDTH@@"), GetOrientation() & TVO_VERTICAL ? TEXT("100%") : TEXT("30%")); // only one task per row for vertical taskpads
    if(sc)
        return sc;

    CStr strName = GetName().data();
    sc = ScUseHTMLEntities(strName);
    if(sc)
        return sc;

    CStr strDescription = GetDescription().data();
    sc = ScUseHTMLEntities(strDescription);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@CONSOLETASKPADNAME@@"), strName);
    if(sc)
        return sc;

    sc = ScReplaceString(strTaskpadHTML, TEXT("@@CONSOLETASKPADDESCRIPTION@@"), strDescription);
    if(sc)
        return sc;

    if (GetOrientation() & TVO_VERTICAL)
    {
        // small, medium and large list sizes correspond to taskpad areas of 262, 212, and 166 pixels respectively
        CStr strLeftPaneWidth;
        if(GetListSize()==eSize_Small)
            strLeftPaneWidth=TEXT("262");
        if(GetListSize()==eSize_Medium)
            strLeftPaneWidth=TEXT("212");
        if(GetListSize()==eSize_Large)
            strLeftPaneWidth=TEXT("166");

        sc = ScReplaceString(strTaskpadHTML, TEXT("@@LEFTPANEWIDTH@@"), strLeftPaneWidth);
        if(sc)
            return sc;
    }
    else if (GetOrientation() & TVO_HORIZONTAL)
    {
        // small, medium and large list sizes correspond to taskpad heights of 200, 150, and 100 pixels respectively
        CStr strBottomPaneHeight;

        if(GetListSize()==eSize_Small)
            strBottomPaneHeight=TEXT("200");
        if(GetListSize()==eSize_Medium)
            strBottomPaneHeight=TEXT("150");
        if(GetListSize()==eSize_Large)
            strBottomPaneHeight=TEXT("100");

        sc = ScReplaceString(strTaskpadHTML, TEXT("@@BOTTOMPANEHEIGHT@@"), strBottomPaneHeight);
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpad::Reset
 *
 * PURPOSE:
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTaskpad::ResetUI()
{
    // reset all the contained tasks.
    for (TaskIter iter = BeginTask(); iter!=EndTask(); ++iter)
    {
        iter->ResetUI();
    }

    // reset the member bookmark
    m_bmTargetNode.ResetUI();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::Retarget
 *
 *
 *--------------------------------------------------------------------------*/

bool CConsoleTaskpad::Retarget (CMTNode* pMTNewNode, bool fReset)
{
    /*
     * if we were given a new node...
     */
    if (pMTNewNode != NULL)
    {
        // Ensure the  MTNode is initialized.
        if (!pMTNewNode->IsInitialized())
        {
            HRESULT hr = pMTNewNode->Init();
            ASSERT(SUCCEEDED(hr));
        }

        /*
         * ...if we've already been targeted to a particular node
         * type, prevent retargeting to a different node type
         */
        if ( (!fReset) && (m_guidNodeType != GUID_NULL))
        {
            GUID guidNewNodeType;
            pMTNewNode->GetNodeType (&guidNewNodeType);

            if (guidNewNodeType != m_guidNodeType)
                return (false);
        }

        /*
         * otherwise, this is the first non-NULL node we've been
         * targeted to; get its node type
         */
        else
            pMTNewNode->GetNodeType (&m_guidNodeType);

        /*
         * If this is a new taskpad, default the taskpad's name
         * to the target node's display name.  The taskpad
         * description and tooltip default to empty.
         */
        if (m_strName.str().empty() || fReset)
        {
            m_strName = pMTNewNode->GetDisplayName();
            ASSERT (m_strDescription.str().empty());
            ASSERT (m_strTooltip.str().empty());
        }
    }

    m_bmTargetNode.ScRetarget(pMTNewNode, false /*bFastRetrievalOnly*/);
    m_pMTNodeTarget = pMTNewNode;

    SetDirty ();
    return (true);
}

bool CConsoleTaskpad::Retarget (CNode* pNewNode)
{
    CMTNode* pMTNewNode = (pNewNode != NULL) ? pNewNode->GetMTNode() : NULL;

    return (Retarget (pMTNewNode));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetName
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetName (const tstring& strName)
{
    SetStringMember (m_strName, strName);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetDescription
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetDescription (const tstring& strDescription)
{
    SetStringMember (m_strDescription, strDescription);
}


void CConsoleTaskpad::SetListSize(const ListSize listSize)
{
    m_listSize = listSize;
    SetDirty();
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetToolTip
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetToolTip (const tstring& strTooltip)
{
    SetStringMember (m_strTooltip, strTooltip);
}


void
CConsoleTaskpad::SetNodeSpecific  (bool bNodeSpecific)
{
    m_bNodeSpecific = bNodeSpecific;
    SetDirty();
}

void
CConsoleTaskpad::SetReplacesDefaultView(bool bReplacesDefaultView)
{
    m_bReplacesDefaultView = bReplacesDefaultView;
    SetDirty();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::SetStringMember
 *
 * Changes the value of a string member variable, and marks the taskpad
 * dirty, if and only if the new value is different than the old value.
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::SetStringMember (
    CStringTableString& strMember,
    const tstring&      strNewValue)
{
    if (strMember != strNewValue)
    {
        strMember = strNewValue;
        SetDirty ();
    }
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::AddTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::AddTask (const CConsoleTask& task)
{
    return (InsertTask (m_Tasks.end(), task));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::InsertTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::InsertTask (
    TaskIter            itTaskBeforeWhichToInsert,
    const CConsoleTask& task)
{
    TaskIter itInserted = m_Tasks.insert (itTaskBeforeWhichToInsert, task);
    SetDirty ();

    return (itInserted);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::EraseTask
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::EraseTask (
    TaskIter itErase)
{
    SetDirty ();
    return (m_Tasks.erase (itErase));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::EraseTasks
 *
 *
 *--------------------------------------------------------------------------*/

CConsoleTaskpad::TaskIter
CConsoleTaskpad::EraseTasks (
    TaskIter itFirst,
    TaskIter itLast)
{
    SetDirty ();
    return (m_Tasks.erase (itFirst, itLast));
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::ClearTasks
 *
 *
 *--------------------------------------------------------------------------*/

void CConsoleTaskpad::ClearTasks ()
{
    SetDirty ();
    m_Tasks.clear ();
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::IsDirty
 *
 * Determines if this taskpad or any of its contained tasks is are dirty.
 *--------------------------------------------------------------------------*/

bool CConsoleTaskpad::IsDirty () const
{
    /*
     * if the taskpad is dirty, short out
     */
    if (m_fDirty)
    {
        TraceDirtyFlag(TEXT("CConsoleTaskpad"), true);
        return (true);
    }

    /*
     * the taskpad is clean, check each task
     */
    for (TaskConstIter it = m_Tasks.begin(); it != m_Tasks.end(); ++it)
    {
        if (it->IsDirty())
        {
            TraceDirtyFlag(TEXT("CConsoleTaskpad"), true);
            return (true);
        }
    }

    TraceDirtyFlag(TEXT("CConsoleTaskpad"), false);
    return (false);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::GetTargetMTNode
 *
 *
 *--------------------------------------------------------------------------*/

CMTNode* CConsoleTaskpad::GetTargetMTNode (IScopeTree* pScopeTree)
{
    DECLARE_SC(sc, TEXT("CConsoleTaskpad::GetTargetMTNode"));

    if(!HasTarget())
        return NULL;

    if(!m_pMTNodeTarget)
    {
        CMTNode *pMTNode = NULL;
        bool bExactMatchFound = false; // out value from ScGetMTNode, unused
        sc = m_bmTargetNode.ScGetMTNode(true /*bExactMatchRequired*/, &pMTNode, bExactMatchFound);
        if(sc.IsError() || !pMTNode)
            return NULL;


        m_pMTNodeTarget = pMTNode;
    }

    return (m_pMTNodeTarget);
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpad::Persist
 *
 * PURPOSE: Persists the console taskpad to the specified persistor.
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CConsoleTaskpad::Persist(CPersistor &persistor)
{
    persistor.PersistString(XML_ATTR_TASKPAD_NAME,              m_strName);
    persistor.PersistString(XML_ATTR_TASKPAD_DESCRIPTION,       m_strDescription);
    persistor.PersistString(XML_ATTR_TASKPAD_TOOLTIP,           m_strTooltip);

    // define the table to map enumeration values to strings
    static const EnumLiteral mappedSize[] =
    {
        { eSize_Large,  XML_ENUM_LIST_SIZE_LARGE },
        { eSize_Medium, XML_ENUM_LIST_SIZE_MEDIUM },
        { eSize_None,   XML_ENUM_LIST_SIZE_NONE },
        { eSize_Small,  XML_ENUM_LIST_SIZE_SMALL },
    };

    // create wrapper to persist flag values as strings
    CXMLEnumeration listSizePersistor(m_listSize, mappedSize, countof(mappedSize));

    // initialize the value suitably
    if(persistor.IsLoading())
        m_listSize = eSize_Default;

    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASKPAD_LIST_SIZE,  listSizePersistor, attr_optional); // optional because this was introduced late

    persistor.PersistAttribute(XML_ATTR_TASKPAD_NODE_SPECIFIC,    CXMLBoolean(m_bNodeSpecific));
    persistor.PersistAttribute(XML_ATTR_REPLACES_DEFAULT_VIEW,    CXMLBoolean(m_bReplacesDefaultView), attr_optional);


    // define the table to map enumeration values to strings
    static const EnumLiteral mappedOrientation[] =
    {
        { TVO_HORIZONTAL,               XML_BITFLAG_TASK_ORIENT_HORIZONTAL },
        { TVO_VERTICAL,                 XML_BITFLAG_TASK_ORIENT_VERTICAL },
        { TVO_NO_RESULTS,               XML_BITFLAG_TASK_ORIENT_NO_RESULTS },
        { TVO_DESCRIPTIONS_AS_TEXT,     XML_BITFLAG_TASK_ORIENT_DESCRIPTIONS_AS_TEXT },
    };

    // create wrapper to persist flag values as strings
    CXMLBitFlags orientationPersistor(m_dwOrientation, mappedOrientation, countof(mappedOrientation));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_TASKPAD_ORIENTATION, orientationPersistor );

    persistor.Persist(m_Tasks);
    persistor.PersistAttribute(XML_ATTR_TASKPAD_NODE_TYPE,        m_guidNodeType);
    persistor.PersistAttribute(XML_ATTR_TASKPAD_ID,               m_guidID);

    persistor.Persist(m_bmTargetNode, XML_NAME_TARGET_NODE);

    // either read or saved - not dirty after the operation
    SetDirty(false);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad::ReadSerialObject
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT
CConsoleTaskpad::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;   // assume unknown version


    if(nVersion==1)
    {
        try
        {
            do  // not a loop
            {
                bool fLegacyHasTarget = true; // an unused field
                UINT visualPercent    = 25;   // replaced by m_listSize

                stm >> m_strName;
                stm >> m_strDescription;
                stm >> m_strTooltip;
                stm >> visualPercent;

                m_listSize = eSize_Medium;
                if(visualPercent==25)
                    m_listSize = eSize_Large;
                else if(visualPercent==75)
                    m_listSize = eSize_Small;

                stm >> m_bNodeSpecific;
                m_bReplacesDefaultView = false; // this was introduced in mmc2.0.
                stm >> m_dwOrientation;

                hr = ::Read(stm, m_Tasks);
                BREAK_ON_FAIL (hr);

                stm >> m_guidNodeType;
                stm >> m_guidID;
                stm >> fLegacyHasTarget;
                stm >> m_bmTargetNode;

                // legacy task symbol info
                {
                    BOOL bLegacyUseMMCSymbols = TRUE; // a now obsolete field, read for console file compatibility
                    tstring strFileLegacy, strFontLegacy;
                    DWORD   dwSymbol = 0;

                    stm >> dwSymbol;
                    stm >> bLegacyUseMMCSymbols;
                    stm >> strFileLegacy; // obsolete
                    stm >> strFontLegacy; // obsolete
                }



                hr = S_OK;      // success!

            } while (false);
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//############################################################################
//############################################################################
//
//  Implementation of class CConsoleTaskpadList
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskpadList::ScGetTaskpadList
 *
 * PURPOSE: Returns the list of all taskpads that are appropriate for the current node.
 *
 * PARAMETERS:
 *    CNode *                       pNode :
 *    CConsoleTaskpadFilteredList & filteredList : [OUT]: The list of taskpads
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTaskpadList::ScGetTaskpadList(CNode *pNode, CConsoleTaskpadFilteredList &filteredList)
{
    DECLARE_SC(sc, TEXT("CConsoleTaskpadList::ScGetTaskpadList"));

    sc = ScCheckPointers(pNode);
    if(sc)
        return sc;

    // 1. add all built- in taskpads

    for(iterator iter = begin(); iter != end(); ++iter)
    {
        CConsoleTaskpad *pConsoleTaskpad = &*iter;
        if(pConsoleTaskpad->IsValid(pNode))
        {
            filteredList.push_back(pConsoleTaskpad);
        }
    }

    return sc;
}

HRESULT
CConsoleTaskpadList::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;       // assume unknown version

    clear();

    if(nVersion == 1)
    {
        try
        {
            DWORD cItems;
            stm >> cItems;

            for(int i=0; i< cItems; i++)
            {
                CConsoleTaskpad taskpad;
                hr = taskpad.Read(stm);
                BREAK_ON_FAIL (hr);
                push_back(taskpad);
            }
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return hr;
}

//############################################################################
//############################################################################
//
//  Implementation of class CDefaultTaskpadList
//
//############################################################################
//############################################################################
HRESULT
CDefaultTaskpadList::ReadSerialObject (IStream &stm, UINT nVersion)
{
    HRESULT hr = S_FALSE;       // assume unknown version

    clear();

    if(nVersion == 1)
    {
        try
        {
            /*
             * TODO: investigate using template operator>> for a map (stgio.h)
             */

            DWORD cItems;
            stm >> cItems;

            for(int i=0; i< cItems; i++)
            {
                GUID guidNodetype, guidTaskpad;
                stm >> guidNodetype;
                stm >> guidTaskpad;
                operator[](guidNodetype) = guidTaskpad;
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\taskenum.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       TaskEnum.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/19/1997   RaviR   Created
//____________________________________________________________________________
//

#include "stdafx.h"
#include "taskenum.h"


CTaskEnumerator::~CTaskEnumerator()
{
    POSITION pos = m_list.GetHeadPosition();
    while (pos)
    {
        STaskEnums& rte = m_list.GetNext(pos);
        rte.pET->Release();
    }

    m_list.RemoveAll();
}

bool 
CTaskEnumerator::AddTaskEnumerator(
    const CLSID& clsid, 
    IEnumTASK* pEnumTASK)
{
    ASSERT(pEnumTASK != NULL);
    if (pEnumTASK == NULL)
        return false;
    
    STaskEnums te; 
    te.clsid = clsid;
    te.pET = pEnumTASK;

    m_list.AddTail(te);
    pEnumTASK->AddRef();

    if (m_posCurr == NULL)
        m_posCurr = m_list.GetHeadPosition();
    
    return true;
}

STDMETHODIMP 
CTaskEnumerator::Next(
    ULONG celt, 
    MMC_TASK *rgelt, 
    ULONG *pceltFetched)
{
    ASSERT(celt == 1);
    if (celt != 1)
        return E_INVALIDARG;
        
    ASSERT(rgelt != NULL);
    if (rgelt == NULL)
        return E_POINTER;
    
    // init
    if (pceltFetched != NULL)
        *pceltFetched = 0;

    if (m_posCurr == NULL)
        return S_FALSE;


    HRESULT hr = S_FALSE;

    while (m_posCurr != NULL)
    {
        STaskEnums& rte = m_list.GetAt(m_posCurr);
        ASSERT(&rte != NULL);

        ULONG celtFetched = 0;
        hr = rte.pET->Next(1, rgelt, &celtFetched);
        ASSERT(SUCCEEDED(hr));
        if (pceltFetched)
            *pceltFetched = celtFetched;

#ifdef DBG
        if (hr == S_FALSE) { ASSERT(celtFetched == 0); }
#endif // DBG

        if (hr == S_OK)
        {
            MMC_ITASK* pTASK = reinterpret_cast<MMC_ITASK*>(rgelt);
            hr = ::StringFromCLSID(rte.clsid, &(pTASK->szClsid));
            ASSERT(SUCCEEDED(hr));
            break;
        }
        else if (FAILED(hr))
        {
            // continue if the snapin failed enum tasks
            hr = S_FALSE;
        }

        m_list.GetNext(m_posCurr);
    }

    return hr;
}

STDMETHODIMP 
CTaskEnumerator::Reset()
{
    POSITION pos = m_list.GetHeadPosition();
    while (pos != NULL && pos != m_posCurr)
    {
        STaskEnums& rte = m_list.GetNext(pos);
        ASSERT(&rte != NULL);
        rte.pET->Reset();
    }

    m_posCurr = m_list.GetHeadPosition();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\task.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      task.h
 *
 *  Contents:  Interface file for CConsoleTask
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TASK_H
#define TASK_H
#pragma once

#include "bookmark.h"
#include "refcount.h"
#include "tstring.h"
#include "menuitem.h"
#include "xmlicon.h"		// for CXMLIcon

// forward declarations
class CConsoleTaskpad;
class CBookmarkEx;
class CStr;

typedef CConsoleTaskpad * PCONSOLETASKPAD;

#include <pshpack8.h>   // for Win64


/*+-------------------------------------------------------------------------*
 * CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/
enum eConsoleTaskType
{
    eTask_None,         // invalid task type
    eTask_Scope,        // task for a scope item
    eTask_Result,       // task for a result item
    eTask_CommandLine,  // task for a command line
    eTask_Target,       // task for menu item on the target node.
    eTask_Favorite      // task for a favorite
};


enum eWindowState
{
    eState_Restored,
    eState_Minimized,
    eState_Maximized,
};



/*+-------------------------------------------------------------------------*
 * CConsoleTask
 *
 *
 *--------------------------------------------------------------------------*/

class CConsoleTask : public CSerialObject, public CXMLObject
{
    enum
    {
        eFlag_Disabled = 0x00000001,
    };

    bool            operator==(const CConsoleTask & consoleTask) const; // private and unimplemented

public:
                    CConsoleTask ();
                    CConsoleTask(const CConsoleTask &rhs);
                    ~CConsoleTask ();

    static CConsoleTask *  GetConsoleTask(DWORD dwUniqueID); // returns the console task that has the specified unique ID.

    SC              ScGetHTML(LPCTSTR szFmtHTML, CStr &strTaskHTML, bool bUseLargeIcons, bool bUseTextDescriptions) const;       // get the HTML representation of the task.


     // need an explicit copy ctor & assignment operator.
    CConsoleTask&   operator= (const CConsoleTask& rhs);

    bool            IsEnabled ()      const    {return ((m_dwFlags & eFlag_Disabled) == 0);}
    void            SetDirty (bool fDirty = true) {m_fDirty = fDirty;}
    bool            IsDirty ()        const;
    bool            HasCustomIcon()   const;

    tstring         GetName ()        const     {return (m_strName.str()); }
    tstring         GetDescription () const     {return (m_strDescription.str()); }
    tstring         GetCommand ()     const     {return (m_strCommand); }
    tstring         GetParameters ()  const     {return (m_strParameters); }
    tstring         GetDirectory ()   const     {return (m_strDirectory); }
    CMemento *      GetMemento()                {return &m_memento;}
    void            Draw (HDC hdc, RECT *lpRect, bool bSmall = false) const ; // Draw into a DC.
    DWORD           GetSymbol()       const     {return m_dwSymbol;}
    const CSmartIcon &    GetSmallCustomIcon() const  {return m_smartIconCustomSmall;}
    const CSmartIcon &    GetLargeCustomIcon() const  {return m_smartIconCustomLarge;}
    DWORD           GetUniqueID()     const     {return m_dwUniqueID;}// returns an ID unique to the task for the current process. Is not persistent.

    void            Enable (bool fEnable);
    void            SetName (const tstring& strName);
    void            SetDescription   (const tstring& strDescription);
    void            SetCommand       (const tstring& strCommand);
    void            SetParameters    (const tstring& strParameters);
    void            SetDirectory     (const tstring &strDirectory);
    void            SetMemento       (const CMemento &memento);
    void            SetSymbol        (DWORD dwSymbol);
    void            SetCustomIcon    (CSmartIcon& iconSmall, CSmartIcon& iconLarge);

    void            ResetUI();                // signal to look for the target node again

    void            SetTaskType(eConsoleTaskType consoleTaskType)
                            {m_eConsoleTaskType = consoleTaskType;}

    void            SetWindowState (eWindowState eState);

    eConsoleTaskType GetTaskType() const            {return m_eConsoleTaskType;}
    eWindowState     GetWindowState() const         {return m_eWindowState;}

    CConsoleTaskpad* GetOwner () const              { return (m_pctpOwner); }

    void             SetOwner (CConsoleTaskpad* pctpOwner);

    bool             operator==(const CMenuItem & menuItem) const;

    // target node methods (scope tasks only)
    bool             RetargetScopeNode(CNode *pNewNode);
    CMTNode *        GetScopeNode(IScopeTree *pScopeTree) const;
    std::auto_ptr<CNode> GetScopeNode(CViewData *pViewData) const;


private:
    /*
     * these are persisted
     */
    eConsoleTaskType        m_eConsoleTaskType;
    CStringTableString      m_strName;
    CStringTableString      m_strDescription;
    DWORD                   m_dwSymbol;         // the index of the built-in icon
    CXMLIcon                m_smartIconCustomLarge; // the large custom icon, if one exists
    CXMLIcon                m_smartIconCustomSmall; // the small custom icon, if one exists

    tstring                 m_strCommand;       // contains: either the menu item, or the command line.
    tstring                 m_strParameters;    // the list of arguments for command line tasks.
    tstring                 m_strDirectory;     // the default directory for command line tasks.
    eWindowState            m_eWindowState;     // min, max, restored

    DWORD                   m_dwFlags;
    mutable CBookmarkEx     m_bmScopeNode;      // for scope tasks only.

    CMemento                m_memento;          // for favorite tasks only.

    /*
     * these are not persisted
     */
    bool                    m_fDirty;
    CConsoleTaskpad*        m_pctpOwner;
    const DWORD             m_dwUniqueID;


    // CXMLObject methods
public:
    DEFINE_XML_TYPE(XML_TAG_TASK);
    virtual void    Persist(CPersistor &persistor);

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);
};


/*+-------------------------------------------------------------------------*
 * CTaskCollection
 *
 *
 * PURPOSE: A list of console tasks. Used by CConsoleTaskpad.
 *
 *+-------------------------------------------------------------------------*/
typedef std::list<CConsoleTask> TaskCollection;
class CTaskCollection : public XMLListCollectionImp<TaskCollection>
{
    DEFINE_XML_TYPE(XML_TAG_TASK_LIST);
};

/*+-------------------------------------------------------------------------*
 * CConsoleTaskpad
 *
 *
 *--------------------------------------------------------------------------*/
const DWORD TVO_HORIZONTAL           = 0x0001;
const DWORD TVO_VERTICAL             = 0x0002;
const DWORD TVO_NO_RESULTS           = 0x0004;
const DWORD TVO_DESCRIPTIONS_AS_TEXT = 0x0008;

/*
 * small list == large task area
 */
enum ListSize
{
    eSize_None   = -1,
    eSize_Small  = 1,
    eSize_Medium,
    eSize_Large,
    eSize_Default= eSize_Medium
};


class CConsoleTaskpad : public CSerialObject, public CXMLObject
{
public:
    CConsoleTaskpad (CNode* pTargetNode = NULL);

    /*
     * member-wise construction and assignment are sufficient
     */
//  CConsoleTaskpad (const CConsoleTaskpad& other);
//  CConsoleTaskpad& operator= (const CConsoleTaskpad& other);

    void                SetDirty (bool fDirty = true) { m_fDirty = fDirty; }
    bool                IsDirty () const;

    bool                HasTarget()       const { return true;}
    const GUID&         GetNodeType ()    const { return (m_guidNodeType); }
    const GUID&         GetID()           const { return (m_guidID);}
    bool                MatchesNodeType(const GUID& guid) const {return (guid == m_guidNodeType);}
    bool                MatchesID      (const GUID& guid) const {return (guid == m_guidID);}

    bool                Retarget (CNode*   pNewNode);
    bool                Retarget (CMTNode* pMTNewNode, bool fReset=false);
    CMTNode*            GetTargetMTNode (IScopeTree* pScopeTree);

    tstring             GetName ()        const { return (m_strName.str()); }
    tstring             GetDescription () const { return (m_strDescription.str()); }
    tstring             GetToolTip ()     const { return (m_strTooltip.str()); }
    ListSize            GetListSize()     const { return m_listSize;}
    bool                IsNodeSpecific()  const { return m_bNodeSpecific;}
    bool                FReplacesDefaultView()  const { return m_bReplacesDefaultView;}
    DWORD               GetOrientation()  const { return m_dwOrientation;}
    bool                IsValid(CNode *pNode) const;      // is this taskpad appropriate for this node?
    CMTNode*            GetRetargetRootNode() const;

    void                SetName          (const tstring& strName);
    void                SetDescription   (const tstring& strDescription);
    void                SetToolTip       (const tstring& strTooltip);
    void                SetListSize      (const ListSize listSize);
    void                SetNodeSpecific  (bool bNodeSpecific);
    void                SetReplacesDefaultView(bool bReplacesDefaultView);
    void                SetOrientation   (DWORD dwOrientation)  {m_dwOrientation = dwOrientation;}
    void                ResetUI();
    CConsoleTaskpad *   PConsoleTaskpad() {return this;} // an easy way to get to the object pointer thru an iterator.

    SC                  ScGetHTML(CStr &strTaskpadHTML) const;       // get the HTML representation of the taskpad.

    /*
     * task list access
     */
    typedef             CTaskCollection::iterator        TaskIter;
    typedef             CTaskCollection::const_iterator  TaskConstIter;

    TaskIter            BeginTask() const  { return (m_Tasks.begin()); }
    TaskIter            EndTask()   const  { return (m_Tasks.end()); }
    UINT                TaskCount() const  { return (static_cast<UINT>(m_Tasks.size())); }
    TaskIter            AddTask    (const CConsoleTask& task);
    TaskIter            InsertTask (TaskIter itTaskBeforeWhichToInsert, const CConsoleTask& task);
    TaskIter            EraseTask  (TaskIter itErase);
    TaskIter            EraseTasks (TaskIter itFirst, TaskIter itLast);
    void                ClearTasks ();

    // CXMLObject methods
public:
    DEFINE_XML_TYPE(XML_TAG_CONSOLE_TASKPAD);
    virtual void        Persist(CPersistor &persistor);

private:
    CBookmarkEx &       GetTargetBookmark()  {return  m_bmTargetNode;}
    void                ResetTargetNodePointer()    {m_pMTNodeTarget = NULL;}
    void                SetStringMember(CStringTableString& strMember, const tstring& strNewValue);

private:
    /*
     * these are persisted
     */
    CStringTableString      m_strName;
    CStringTableString      m_strDescription;
    CStringTableString      m_strTooltip;
    ListSize                m_listSize;         // the area of the the result pane occupied by the embedded view
    bool                    m_bNodeSpecific;    // is this taskpad specific to this node, or can it be used for all nodes of this type?
    DWORD                   m_dwOrientation;
    GUID                    m_guidNodeType;
    GUID                    m_guidID;           // the unique identifier of the taskpad.
    mutable CBookmarkEx     m_bmTargetNode;
    CTaskCollection         m_Tasks;
    bool                    m_bReplacesDefaultView; // does this taskpad replace the default view?

    /*
     * these are not persisted
     */
    bool                    m_fDirty;
    CMTNode *               m_pMTNodeTarget;

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);
};


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpadFilteredList
 *
 *
 * PURPOSE: Provides a list of taskpads appropriate to a given node.
 *
 *+-------------------------------------------------------------------------*/
class CConsoleTaskpadFilteredList : public std::list<PCONSOLETASKPAD>
{
    iterator m_CurrentSelection;    // the currently selected taskpad
};


/*+-------------------------------------------------------------------------*
 * CConsoleTaskpadList
 *
 *
 * PURPOSE: There should be only one object of this kind. This object contains
 *          a flat list of taskpads available. These are not sorted in any
 *          particular order.
 *
 *+-------------------------------------------------------------------------*/
typedef std::list<CConsoleTaskpad> CTaskpadList_base;
class CConsoleTaskpadList : public CSerialObject, public XMLListCollectionImp<CTaskpadList_base>
{
    typedef std::list<CConsoleTaskpad> BC;

public: // find a taskpad for this node, else return NULL
    SC      ScGetTaskpadList(CNode *pNode, CConsoleTaskpadFilteredList &filteredList);

    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);

    // CXMLObject methods
public:
    DEFINE_XML_TYPE(XML_TAG_CONSOLE_TASKPADS);
};

/*+-------------------------------------------------------------------------*
 * CDefaultTaskpadList
 *
 *
 * PURPOSE: stores a map from nodetypes to console taskpad IDs
 *          This maps a nodetype to the default taskpad for that nodetype.
 *
 *+-------------------------------------------------------------------------*/
class CDefaultTaskpadList : public std::map<GUID, GUID>, // 1st = nodetype, 2nd = taskpad ID
    public CSerialObject
{
public:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);
};

#include <poppack.h>


#endif // TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\taskenum.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       taskenum.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/19/1997   RaviR   Created
//____________________________________________________________________________
//

#ifndef TASKENUM_H__
#define TASKENUM_H__

struct STaskEnums
{
    CLSID clsid;
    IEnumTASK* pET;
};


class CTaskEnumerator : public IEnumTASK, 
                        public CComObjectRoot
{
// Constructor & destructor
public:
    CTaskEnumerator() : m_posCurr(NULL)
    {
    }
    ~CTaskEnumerator();
    
// ATL COM map
public:
BEGIN_COM_MAP(CTaskEnumerator)
    COM_INTERFACE_ENTRY(IEnumTASK)
END_COM_MAP()

// IEnumTASK methods
public:
    STDMETHOD(Next)(ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
    STDMETHOD(Reset)();

    STDMETHOD(Skip)(ULONG celt)
    {
        return E_NOTIMPL;
    }
    STDMETHOD(Clone)(IEnumTASK **ppenum)
    {
        return E_NOTIMPL;
    }

// public methods
public:
    bool AddTaskEnumerator(const CLSID& clsid, IEnumTASK* pEnumTASK);

// Implementation
private:
    CList<STaskEnums, STaskEnums&> m_list;
    POSITION m_posCurr;
    
// Ensure that default copy constructor & assignment are not used.
    CTaskEnumerator(const CTaskEnumerator& rhs);
    CTaskEnumerator& operator=(const CTaskEnumerator& rhs);

}; // class CTaskEnumerator


#endif // TASKENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasks.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tasks.h
//
//--------------------------------------------------------------------------

#include "task.h"
#include "tasksym.h"
#include "taskui.h"  
#include "tasknode.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasknode.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       tasknode.h
 *
 *  Contents:   Interface file for console taskpad CMTNode- and CNode-derived
 *              classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TASKNODE_H
#define TASKNODE_H
#pragma once

class CConsoleTaskCallbackImpl;

//____________________________________________________________________________
//
//  Class:      CConsoleTaskCallbackImpl
//
//  PURPOSE:    Implements ITaskCallback.
//____________________________________________________________________________
//
class CConsoleTaskCallbackImpl :
    public ITaskCallback,
    public CComObjectRoot
{
    // typedefs
    typedef CConsoleTaskpad::TaskIter       TaskIter;

DECLARE_NOT_AGGREGATABLE(CConsoleTaskCallbackImpl)

BEGIN_COM_MAP(CConsoleTaskCallbackImpl)
    COM_INTERFACE_ENTRY(ITaskCallback)
END_COM_MAP()

public:

    // must call Initialize after constructing.
    SC ScInitialize(const CLSID& clsid);
    SC ScInitialize(CConsoleTaskpad *pConsoleTaskpad, CScopeTree *pScopeTree, CNode *pNodeTarget);

    // ITaskCallback
	STDMETHOD(IsEditable)();
	STDMETHOD(OnModifyTaskpad)();
	STDMETHOD(OnDeleteTaskpad)();
	STDMETHOD(GetTaskpadID)(GUID *pGuid);

	// constructor/destructor
	CConsoleTaskCallbackImpl();
	HRESULT             OnNewTask();
	void                EnumerateTasks();
	CConsoleTaskpad *   GetConsoleTaskpad() const {return m_pConsoleTaskpad;}

private: // implementation

    void                        CheckInitialized()  const {ASSERT(m_fInitialized);}
    CNode*                      GetTargetNode()     const {CheckInitialized(); return m_pNodeTarget;}
    CScopeTree *                GetScopeTree()      const {return m_pScopeTree;}
    CViewData *                 GetViewData()       const {return m_pViewData;}
	bool						IsTaskpad() const		{ return (m_fTaskpad); }

    // attributes
    CLSID	m_clsid;
	bool	m_fTaskpad;

	/*
	 * these are used for console taskpads only
	 */
    bool                        m_fInitialized;
    CConsoleTaskpad *           m_pConsoleTaskpad;
    CViewData *                 m_pViewData;
    CScopeTree *                m_pScopeTree;
    CNode *                     m_pNodeTarget;
};


#endif /* TASKNODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasknode.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       tasknode.cpp
 *
 *  Contents:   Implementation file for console taskpad CMTNode- and
 *              CNode-derived classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "tasks.h"
#include "util.h"
#include "conview.h"
#include "rsltitem.h"


//############################################################################
//############################################################################
//
//  Implementation of class CConsoleTaskCallbackImpl
//
//############################################################################
//############################################################################



/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::CConsoleTaskCallbackImpl
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CConsoleTaskCallbackImpl::CConsoleTaskCallbackImpl() :
	m_clsid        (GUID_NULL),
	m_fTaskpad     (false),
	m_fInitialized (false),
	m_pViewData    (NULL)
{
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::ScInitialize
 *
 * PURPOSE:  This is the initialization function called for taskpad
 * view extensions.
 *
 * PARAMETERS:
 *    CConsoleTaskpad * pConsoleTaskpad :
 *    CScopeTree *      pScopeTree :
 *    CNode *           pNodeTarget :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
SC
CConsoleTaskCallbackImpl::ScInitialize(
	CConsoleTaskpad*	pConsoleTaskpad,
	CScopeTree*			pScopeTree,
	CNode*				pNodeTarget)
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::ScInitialize"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (pConsoleTaskpad, pScopeTree, pNodeTarget);
	if (sc)
		return (sc);

	sc = ScCheckPointers (pNodeTarget->GetViewData(), E_UNEXPECTED);
	if (sc)
		return (sc);

    m_pConsoleTaskpad = pConsoleTaskpad;
    m_pScopeTree      = pScopeTree;
    m_pNodeTarget     = pNodeTarget;
    m_pViewData       = pNodeTarget->GetViewData();
    m_fInitialized    = true;
	m_fTaskpad        = true;

	return (sc);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::ScInitialize
 *
 * This is the initialization function called for ordinary view extensions.
 *--------------------------------------------------------------------------*/

SC CConsoleTaskCallbackImpl::ScInitialize (const CLSID& clsid)
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::ScInitialize"));

	m_clsid = clsid;
	return (sc);
}

/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::IsEditable
 *
 * Returns S_OK if "Edit" and "Delete" menu items should be displayed
 * on the context menu for the node while this view extension is active.
 *
 * Returns S_FALSE if "Edit" and "Delete" should not be displayed.
 *--------------------------------------------------------------------------*/

STDMETHODIMP CConsoleTaskCallbackImpl::IsEditable()
{
	if (IsTaskpad())
		return (S_OK);

	return (S_FALSE);
}


/*+-------------------------------------------------------------------------*
 * CConsoleTaskCallbackImpl::OnModifyTaskpad
 *
 * PURPOSE:
 *
 * PARAMETERS:    +-
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
STDMETHODIMP
CConsoleTaskCallbackImpl::OnModifyTaskpad()
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::OnModifyTaskpad"));

	/*
	 * this should only be called for taskpad view extensions
	 */
	if (!IsTaskpad())
		return ((sc = E_UNEXPECTED).ToHr());

    CNode *pNodeTarget = GetConsoleTaskpad()->HasTarget() ? GetTargetNode() : NULL;

    bool fCookieValid = false;

    // determine whether the taskpad node is selected. If not, fCookieValid = false.
    LPARAM          lResultItemCookie = -1;
    bool            bScope;
    CNode*          pNode = NULL;
    CConsoleView*   pConsoleView = GetViewData()->GetConsoleView();

    if (pConsoleView != NULL)
    {
        HNODE hNode;
        sc = pConsoleView->ScGetFocusedItem (hNode, lResultItemCookie, bScope);

        if (sc)
            return (sc.ToHr());

        pNode = CNode::FromHandle (hNode);
    }

    if (pNode == NULL)
        fCookieValid = false;

    int iResp = CTaskpadPropertySheet(pNodeTarget, *GetConsoleTaskpad(), FALSE, NULL, fCookieValid,
        GetViewData(), CTaskpadPropertySheet::eReason_PROPERTIES).DoModal();

    if(iResp == IDOK)
    {
        GetViewData()->m_spTaskCallback = NULL;
        GetScopeTree()->UpdateAllViews(VIEW_RESELECT, 0);
    }

    return (sc.ToHr());
}


/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::GetTaskpadID
 *
 * PURPOSE: Returns the GUID ID of the underlying taskpad.
 *
 * PARAMETERS:
 *    GUID * pGuid :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CConsoleTaskCallbackImpl::GetTaskpadID(GUID *pGuid)
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::GetTaskpadID"));

	sc = ScCheckPointers (pGuid);
	if (sc)
		return (sc.ToHr());

	if (IsTaskpad())
	{
		/*
		 * TODO: initialize m_clsid in ScInitialize for taskpads
		 */
		CConsoleTaskpad* pTaskpad = GetConsoleTaskpad();
		sc = ScCheckPointers (pTaskpad, E_UNEXPECTED);
		if (sc)
			return (sc.ToHr());

		*pGuid = pTaskpad->GetID();
	}
	else
	{
		*pGuid = m_clsid;
	}

	return (sc.ToHr());
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::OnDeleteTaskpad
 *
 * PURPOSE: Deletes a taskpad.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CConsoleTaskCallbackImpl::OnDeleteTaskpad()
{
	DECLARE_SC (sc, _T("CConsoleTaskCallbackImpl::OnDeleteTaskpad"));

	/*
	 * this should only be called for taskpad view extensions
	 */
	if (!IsTaskpad())
		return ((sc = E_UNEXPECTED).ToHr());

    CScopeTree* pScopeTree = GetScopeTree();
	sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    CConsoleTaskpadList* pTaskpadList = pScopeTree->GetConsoleTaskpadList();
	sc = ScCheckPointers (pTaskpadList, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    CConsoleTaskpad* pTaskpad = GetConsoleTaskpad();
	sc = ScCheckPointers (pTaskpad, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());


    CConsoleTaskpadList::iterator iter;
    for(iter = pTaskpadList->begin(); iter != pTaskpadList->end(); iter++)
    {
        if(iter->MatchesID(pTaskpad->GetID()))
        {
            pTaskpadList->erase(iter);
            pScopeTree->UpdateAllViews(VIEW_RESELECT, 0);
            return (sc.ToHr());
        }
    }

    return ((sc = E_UNEXPECTED).ToHr()); // not found.
}

/*+-------------------------------------------------------------------------*
 *
 * CConsoleTaskCallbackImpl::OnNewTask
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT : S_OK if tasks were added, S_FALSE if no tasks were added.
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CConsoleTaskCallbackImpl::OnNewTask()
{
    HRESULT hr = S_OK;
    CNode *pNodeTarget = GetConsoleTaskpad()->HasTarget() ? GetTargetNode() : NULL;

    // fake up a taskpad frame.
    CTaskpadFrame taskpadFrame(pNodeTarget, GetConsoleTaskpad(), GetViewData(), false, 0);

    CTaskWizard taskWizard;
    bool fRestartTaskpad = true;
    bool bAddedTasks     = false;

    while(fRestartTaskpad)
    {
        if (taskWizard.Show(GetViewData()->GetMainFrame(), &taskpadFrame,
                            true, &fRestartTaskpad)==S_OK)
        {
            bAddedTasks = true;
            CConsoleTaskpad::TaskIter   itTask;
            CConsoleTaskpad *           pTaskpad = GetConsoleTaskpad();

            itTask = pTaskpad->BeginTask();

            pTaskpad->InsertTask (itTask, taskWizard.ConsoleTask());
        }
        else
            break;
    }

    return bAddedTasks? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasksym.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tasksym.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10/29/1998   DavidPe   Adapted from BackOffice snapin
//____________________________________________________________________________
//

#ifndef __TASKSYM_H__
#define __TASKSYM_H__

#include "tstring.h"
#include "dlgs.h"
#include "task.h"		// for CSmartIcon

extern const int NUM_SYMBOLS; // the total number of symbols available.
class CConsoleTask;

/*+-------------------------------------------------------------------------*
 * class CEOTSymbol
 *
 *
 * PURPOSE: encapsulates information about glyphs that are internal to MMC. These
 *          have description text along with them.
 *+-------------------------------------------------------------------------*/
class CEOTSymbol
{
public:
    CEOTSymbol(WORD iconResource, int value, int ID, int IDSecondary=0)
            {m_iconResource = iconResource; m_value = value; m_ID = ID; m_IDSecondary = IDSecondary;}

    ~CEOTSymbol();
    void Draw (HDC hdc, RECT *lpRect, bool bSmall = false) const ; // Draw into a DC.

public:
    int       GetID()          const {return m_ID;}
    int       GetIDSecondary() const {return m_IDSecondary;}
    int       GetValue() const {return m_value;}
    bool      operator == (const CEOTSymbol &rhs);

    static bool  IsMatch(CStr &str1, CStr &str2);
    static int   FindMatchingSymbol(LPCTSTR szDescription); // finds a symbol matching the given description.

    void         SetIcon(const CSmartIcon & smartIconSmall, const CSmartIcon & smartIconLarge);
    CSmartIcon & GetSmallIcon()  {return m_smartIconSmall;}
    CSmartIcon & GetLargeIcon()  {return m_smartIconLarge;}

private:
    WORD       m_iconResource; // the resource id of the icon
    int        m_value;        // the number of the symbol
    int        m_ID;           // description text resource ID
    int        m_IDSecondary;  // secondary description\

protected:
    mutable CSmartIcon m_smartIconSmall;
    mutable CSmartIcon m_smartIconLarge;
};

/*+-------------------------------------------------------------------------*
 * class CTaskSymbolDlg
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CTaskSymbolDlg :
    public WTL::CPropertyPageImpl<CTaskSymbolDlg>
{
    typedef WTL::CPropertyPageImpl<CTaskSymbolDlg> BC;

public:
    CTaskSymbolDlg(CConsoleTask& rConsoleTask, bool bFindMatchingSymbol= false);

    enum { IDD     = IDD_TASK_PROPS_SYMBOL_PAGE,
           IDD_WIZ = IDD_TASK_WIZARD_SYMBOL_PAGE};

BEGIN_MSG_MAP(CTaskSymbolDlg)
    MESSAGE_HANDLER(WM_INITDIALOG,                    OnInitDialog)
    MESSAGE_HANDLER(WM_CTLCOLORSTATIC,                OnCtlColorStatic)
    CONTEXT_HELP_HANDLER()
    NOTIFY_HANDLER (IDC_GLYPH_LIST,  NM_CUSTOMDRAW,   OnCustomDraw)
    NOTIFY_HANDLER (IDC_GLYPH_LIST,  LVN_ITEMCHANGED, OnSymbolChanged)
    COMMAND_ID_HANDLER(IDB_SELECT_TASK_ICON,          OnSelectTaskIcon)
    COMMAND_HANDLER(IDC_CustomIconRadio, BN_CLICKED,  OnIconSourceChanged)
    COMMAND_HANDLER(IDC_MMCIconsRadio,   BN_CLICKED,  OnIconSourceChanged)
    CHAIN_MSG_MAP(BC)
    REFLECT_NOTIFICATIONS()
END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASK_PROPS_SYMBOL_PAGE);

    //
    // message handlers
    //
    LRESULT OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& handled);
    LRESULT OnCtlColorStatic(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& handled);
    LRESULT OnCustomDraw(int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnSymbolChanged(int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnSelectTaskIcon(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnIconSourceChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    int     OnWizardNext()      {return OnOK() ? 0 : -1;}
    bool    OnApply ()          {return OnOK();}
    BOOL    OnOK();

    // implementation
    void    DrawItem(NMCUSTOMDRAW *pnmcd);

private:
	SC ScEnableControls (int id);

protected:
    CConsoleTask&       m_ConsoleTask;          // get the name to match from here.

    // No need to destroy the CImageList, it is destroyed by the CListViewCtrl
    // as it is not a shared imagelist.
    WTL::CImageList     m_imageList;

    WTL::CListViewCtrl  m_listGlyphs;           // the list control for the glyphs
	WTL::CStatic		m_wndCustomIcon;
	CSmartIcon			m_CustomIconSmall;
	CSmartIcon			m_CustomIconLarge;
    bool                m_bFindMatchingSymbol;  // should we try to guess a symbol?
	bool 				m_bCustomIcon;			// does this task use a custom icon?
};


class CTaskSymbolWizardPage: public CTaskSymbolDlg
{
    typedef CTaskSymbolDlg BC;
public:
    CTaskSymbolWizardPage(CConsoleTask& rConsoleTask): BC(rConsoleTask, true)
    {
        m_psp.pszTemplate = MAKEINTRESOURCE(BC::IDD_WIZ);

        /*
         * Wizard97-style pages have titles, subtitles and header bitmaps
         */
        VERIFY (m_strTitle.   LoadString(GetStringModule(), IDS_TaskWiz_SymbolPageTitle));
        VERIFY (m_strSubtitle.LoadString(GetStringModule(), IDS_TaskWiz_SymbolPageSubtitle));

        m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle    = m_strTitle.data();
        m_psp.pszHeaderSubTitle = m_strSubtitle.data();
    }

    BOOL OnSetActive()
	{
		// add the Finish button.
		WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);
		return TRUE;
	}

private:
    tstring m_strTitle;
    tstring m_strSubtitle;
};
#endif // __TASKSYM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasksym.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tasksym.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "tasks.h"
#include "stgio.h"
#include <commdlg.h>
#include "symbinfo.h"
#include "pickicon.h"
#include "util.h"


const int NUM_SYMBOLS = (sizeof(s_rgEOTSymbol)/sizeof(s_rgEOTSymbol[0]));

static const int s_cxIcon            = 32;	// size of an icon
static const int s_cxSelectionMargin =  4;	// additional border for selection
static const int s_cxIconGutter      = 10;	// gutter space between icons (keep this even)

//############################################################################
//############################################################################
//
//  Implementation of class CEOTSymbol
//
//############################################################################
//############################################################################

CEOTSymbol::~CEOTSymbol()
{
}

bool
CEOTSymbol::operator == (const CEOTSymbol &rhs)
{
    return ( (m_iconResource  == rhs.m_iconResource) &&
             (m_value == rhs.m_value) &&
             (m_ID    == rhs.m_ID) );

}

void
CEOTSymbol::SetIcon(const CSmartIcon & smartIconSmall, const CSmartIcon & smartIconLarge)
{
    m_smartIconSmall = smartIconSmall;
    m_smartIconLarge = smartIconLarge;
}



/*+-------------------------------------------------------------------------*
 *
 * CEOTSymbol::Draw
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    HDC    hdc :
 *    RECT * lpRect :
 *    bool   bSmall :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CEOTSymbol::Draw(HDC hdc, RECT *lpRect, bool bSmall) const
{
    // if the icons already exist, Draw has been called before OR this symbol has a custom icon that as been
    // assigned the icons directly using SetIcon

    if((HICON)m_smartIconSmall == NULL)
    {
        m_smartIconSmall.Attach((HICON)::LoadImage(_Module.GetResourceInstance(),
                                                    MAKEINTRESOURCE(m_iconResource), IMAGE_ICON, 16, 16, 0));
    }

    if((HICON)m_smartIconLarge == NULL)
    {
        m_smartIconLarge.Attach((HICON)::LoadImage(_Module.GetResourceInstance(),
                                                    MAKEINTRESOURCE(m_iconResource), IMAGE_ICON, 32, 32, 0));
    }

	/*
	 * Preserve icon shape when BitBlitting it to a
	 * mirrored DC.
	 */
	DWORD dwLayout=0L;
	if ((dwLayout=GetLayout(hdc)) & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
	}

    DrawIconEx(hdc, lpRect->left, lpRect->top, bSmall ? m_smartIconSmall : m_smartIconLarge,
               bSmall? 16 : 32, bSmall? 16 : 32, 0, NULL, DI_NORMAL);

	/*
	 * Restore the DC to its previous layout state.
	 */
	if (dwLayout & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout);
	}
}


/*+-------------------------------------------------------------------------*
 *
 * CEOTSymbol::IsMatch
 *
 * PURPOSE: Checks to see whether str1 is one of the strings contained in the
 *          comma separated list str2.
 *
 * PARAMETERS:
 *    CStr & str1 :
 *    CStr & str2 :
 *
 * RETURNS:
 *    bool: true if str1 is contained in str2, else false.
 *
 *+-------------------------------------------------------------------------*/
bool
CEOTSymbol::IsMatch(CStr &str1, CStr &str2)
{
    // trim spaces off either end.
    str1.TrimLeft();
    str1.TrimRight();

    CStr strTemp;
    int length;
    while((length = str2.GetLength()) != 0 )
    {
        int index = str2.Find(TEXT(','));
        if(index!=-1)
        {
            strTemp = str2.Left(index); // index is the pos of the ',' so we're OK.
            str2 = str2.Right(length - index -1);
        }
        else
        {
            strTemp = str2;
            str2.Empty();
        }

        strTemp.TrimLeft();
        strTemp.TrimRight();
        // compare str1 and strTemp
        if( str1.CompareNoCase((LPCTSTR)strTemp)==0)
            return true;    // match
    }
    return false;
}

int
CEOTSymbol::FindMatchingSymbol(LPCTSTR szDescription) // finds a symbol matching the given description.
{
    CStr strDescription = szDescription;

    int iSelect = -1;
    for(int i = 0; i<NUM_SYMBOLS; i++)
    {
        CStr strDescTemp;
        int ID = s_rgEOTSymbol[i].GetID();
        strDescTemp.LoadString(_Module.GetResourceInstance(), ID); // get the string.
        if(IsMatch(strDescription, strDescTemp))
        {
            iSelect = i;  // perfect match
            break;
        }

        CStr strDescTemp2;
        int ID2 = s_rgEOTSymbol[i].GetIDSecondary();
        if(ID2)
            strDescTemp2.LoadString(_Module.GetResourceInstance(), ID2); // get the string.
        if(IsMatch(strDescription, strDescTemp2))
        {
            iSelect = i;  // imperfect match, keep trying.
        }
    }

    return iSelect;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskSymbolDialog
//
//############################################################################
//############################################################################

CTaskSymbolDlg::CTaskSymbolDlg(CConsoleTask& rConsoleTask, bool bFindMatchingSymbol)
	:	m_ConsoleTask (rConsoleTask),
		m_bCustomIcon (rConsoleTask.HasCustomIcon())
{
    m_bFindMatchingSymbol = bFindMatchingSymbol;
}


LRESULT CTaskSymbolDlg::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& handled)
{
    m_listGlyphs    = GetDlgItem (IDC_GLYPH_LIST);
	m_wndCustomIcon = GetDlgItem (IDC_CustomIcon);

    m_imageList.Create (16, 28, ILC_COLOR , 20, 10);
	m_listGlyphs.SetImageList((HIMAGELIST) m_imageList, LVSIL_NORMAL);
	
	int cxIconSpacing = s_cxIcon + s_cxIconGutter;
    m_listGlyphs.SetIconSpacing (cxIconSpacing, cxIconSpacing);

    int iSelect = 0;

    // insert all the items
    for(int i=0; i< NUM_SYMBOLS; i++)
    {
        LV_ITEM item;
        ZeroMemory(&item, sizeof(item));
        item.mask    = LVIF_PARAM;
        item.lParam  = i;


        if(s_rgEOTSymbol[i].GetValue()==m_ConsoleTask.GetSymbol())
        {
            iSelect    = i;
        }

        m_listGlyphs.InsertItem(&item);
    }

	/*
	 * check the appropriate radio button
	 */
	int nCheckedButton = (m_bCustomIcon) ? IDC_CustomIconRadio : IDC_MMCIconsRadio;
	CheckRadioButton (IDC_CustomIconRadio, IDC_MMCIconsRadio, nCheckedButton);
	SC scNoTrace = ScEnableControls (nCheckedButton);

	/*
	 * if this task has a custom icon, initialize the preview control
	 */
	if (m_bCustomIcon)
		m_wndCustomIcon.SetIcon (m_ConsoleTask.GetLargeCustomIcon());


    if(m_bFindMatchingSymbol) // a description string was passed in, use it to populate the page.
    {
        tstring strName = m_ConsoleTask.GetName();
        if(strName.length()>0)
            iSelect = CEOTSymbol::FindMatchingSymbol((LPCTSTR)strName.data());
    }


	/*
	 * select the icon for this task
	 */
    LV_ITEM item;
    ZeroMemory(&item, sizeof(item));
    item.iItem     = iSelect;
    item.mask      = LVIF_STATE;
    item.state     = LVIS_FOCUSED | LVIS_SELECTED;
    item.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    m_listGlyphs.SetItem(&item);
    m_listGlyphs.EnsureVisible(iSelect, 0);

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskSymbolDlg::OnCtlColorStatic
 *
 * WM_CTLCOLORSTATIC handler for CTaskSymbolDlg.
 *--------------------------------------------------------------------------*/

LRESULT CTaskSymbolDlg::OnCtlColorStatic(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HBRUSH hbrRet = NULL;

	switch (::GetDlgCtrlID (((HWND) lParam)))
	{
		/*
		 * for the custom icon preview window and its well, if we're using a
		 * custom icon, return a COLOR_WINDOW brush so the static won't paint
		 * the background with COLOR_3DFACE
		 */
		case IDC_CustomIcon:
		case IDC_CustomIconWell:
			if (m_bCustomIcon)
				hbrRet = GetSysColorBrush (COLOR_WINDOW);
			break;
	}

	/*
	 * if we didn't supply a brush, let this message go through to DefWindowProc
	 */
	if (hbrRet == NULL)
		bHandled = false;

	return ((LPARAM) hbrRet);
}


/*+-------------------------------------------------------------------------*
 * CTaskSymbolDlg::OnIconSourceChanged
 *
 * BN_CLICKED handler for CTaskSymbolDlg.
 *--------------------------------------------------------------------------*/

LRESULT CTaskSymbolDlg::OnIconSourceChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	m_bCustomIcon = (wID == IDC_CustomIconRadio);
	SC scNoTrace = ScEnableControls (wID);
	return (0);
}


/*+-------------------------------------------------------------------------*
 * CTaskSymbolDlg::ScEnableControls
 *
 * Enables the controls belonging to a particular radio button on the
 * symbol dialog
 *--------------------------------------------------------------------------*/

SC CTaskSymbolDlg::ScEnableControls (int id)
{
	DECLARE_SC (sc, _T("CTaskSymbolDlg::ScEnableControls"));

	/*
	 * validate input
	 */
	ASSERT ((id == IDC_CustomIconRadio) || (id == IDC_MMCIconsRadio));
	if (!  ((id == IDC_CustomIconRadio) || (id == IDC_MMCIconsRadio)))
		return (sc = E_INVALIDARG);

	/*
	 * controls to be enabled when "Custom Icon" radio button is selected
	 */
	static const int nCustomIconCtlIDs[] = {
		IDC_CustomIcon,
		IDC_CustomIconWell,
		IDB_SELECT_TASK_ICON,
		0	// terminator
	};

	/*
	 * controls to be enabled when "MMC Icons" radio button is selected
	 */
	static const int nMMCIconCtlIDs[] = {
        IDC_GLYPH_LIST,
        IDC_DESCRIPTION,
        IDC_DESCRIPTION2,
        IDC_DESCRIPTIONLabel,
        IDC_DESCRIPTION2Label,
		0	// terminator
	};

	const int* pnEnableIDs  = NULL;
	const int* pnDisableIDs = NULL;

	/*
	 * pick the right sets of controls to enable/disable
	 */
	if (id == IDC_CustomIconRadio)
	{
		pnEnableIDs  = nCustomIconCtlIDs;
		pnDisableIDs = nMMCIconCtlIDs;
	}
	else
	{
		pnEnableIDs  = nMMCIconCtlIDs;
		pnDisableIDs = nCustomIconCtlIDs;
	}

	/*
	 * enable/disable the controls
	 */
	for (int i = 0; pnEnableIDs[i] != 0; i++)
		::EnableWindow (GetDlgItem (pnEnableIDs[i]), true);

	for (int i = 0; pnDisableIDs[i] != 0; i++)
		::EnableWindow (GetDlgItem (pnDisableIDs[i]), false);

	return (sc);
}


LRESULT
CTaskSymbolDlg::OnSymbolChanged(int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMLISTVIEW* pnmlv = (NMLISTVIEW *) pnmh;
    if(! ((pnmlv->uNewState & LVNI_FOCUSED) && (pnmlv->iItem !=-1)) )
        return 0;

    int nItem = pnmlv->iItem;

    CStr strDescription;
    int ID = s_rgEOTSymbol[nItem].GetID();
    strDescription.LoadString(_Module.GetResourceInstance(), ID); // get the string.
    SetDlgItemText(IDC_DESCRIPTION, (LPCTSTR) strDescription);

    CStr strDescription2;
    int ID2 = s_rgEOTSymbol[nItem].GetIDSecondary();
    if(ID2)
        strDescription2.LoadString(_Module.GetResourceInstance(), ID2); // get the string.
    SetDlgItemText(IDC_DESCRIPTION2, (LPCTSTR) strDescription2);

    return 0;
}


LRESULT
CTaskSymbolDlg::OnCustomDraw(int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMCUSTOMDRAW* pnmcd = (NMCUSTOMDRAW *) pnmh;

    switch(pnmcd->dwDrawStage & ~CDDS_SUBITEM)
    {
		case CDDS_PREPAINT:         // the initial notification
			return CDRF_NOTIFYITEMDRAW;    // we want to know about each item's paint.
	
		case CDDS_ITEMPREPAINT:
			DrawItem(pnmcd);
			return CDRF_SKIPDEFAULT;      // we've drawn the whole item ourselves
	
		default:
			return 0;
    }
}

void
CTaskSymbolDlg::DrawItem(NMCUSTOMDRAW *pnmcd)
{
    DECLARE_SC(sc, TEXT("CTaskSymbolDlg::DrawItem"));

    int  nItem = pnmcd->dwItemSpec;
    HDC  &hdc  = pnmcd->hdc;

    LV_ITEM item;
    ZeroMemory(&item, sizeof(item));
    item.iItem = nItem;
    item.mask  = LVIF_STATE;
    item.stateMask = (UINT) -1; //get all the state bits.
    m_listGlyphs.GetItem(&item);


	/*
	 * get the icon rect for the item and offset it downward by the size
	 * of our border margin
	 */
    RECT rectIcon;
    m_listGlyphs.GetItemRect(nItem, &rectIcon, LVIR_ICON);
	OffsetRect (&rectIcon, 0, s_cxSelectionMargin);

	/*
	 * Make a slightly inflated copy the icon rectangle to draw in the
	 * selection color.  We inflate to make the selection stand out a little
	 * more for large icons.
	 */
	RECT rectBackground = rectIcon;
	InflateRect (&rectBackground, s_cxSelectionMargin, s_cxSelectionMargin);

    bool bWindowHasFocus = (GetFocus() == (HWND)m_listGlyphs);
    bool bSelected       = item.state & LVIS_SELECTED;
	bool bDisabled       = !m_listGlyphs.IsWindowEnabled();

    // Create the select rectangle or empty the rectangle.
	int nBackColorIndex = (bDisabled) ? COLOR_3DFACE	:
						  (bSelected) ? COLOR_HIGHLIGHT	:
										COLOR_WINDOW;

	FillRect (hdc, &rectBackground, (HBRUSH) LongToHandle(nBackColorIndex+1));

    // draw the symbol icon
    s_rgEOTSymbol[nItem].Draw(hdc, &rectIcon);

    if(bWindowHasFocus && bSelected)
        ::DrawFocusRect(hdc, &rectBackground);

    //ReleaseDC(hdc);   DONT release the DC!
}

BOOL
CTaskSymbolDlg::OnOK()
{
    int nItem = m_listGlyphs.GetSelectedIndex();

	/*
	 * make sure we've selected an item
	 */
    if (( m_bCustomIcon && (m_CustomIconLarge == NULL)) ||
		(!m_bCustomIcon && (nItem == -1)))
    {
        CStr strError;
        strError.LoadString(GetStringModule(), IDS_SYMBOL_REQUIRED);
        MessageBox(strError, NULL, MB_OK | MB_ICONEXCLAMATION);
        return (false);
    }

	if (m_bCustomIcon)
		m_ConsoleTask.SetCustomIcon(m_CustomIconSmall, m_CustomIconLarge);
	else
		m_ConsoleTask.SetSymbol(s_rgEOTSymbol[nItem].GetValue());

    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CTaskSymbolDlg::OnSelectTaskIcon
 *
 * PURPOSE: Uses the shell-provided icon picker dialog to allow the user to select
 *          a custom icon for the console task.
 *
 * PARAMETERS:
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS:
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTaskSymbolDlg::OnSelectTaskIcon(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    DECLARE_SC(sc, TEXT("CTaskSymbolDlg::OnSelectTaskIcon"));

	static CStr s_strCustomIconFile;
	static int  s_nIconIndex = 0;

    int nIconIndex = s_nIconIndex;
    TCHAR szIconFile[MAX_PATH];

	/*
	 * shouldn't get here unless we think we're using a custom icon
	 */
	ASSERT (m_bCustomIcon);

	/*
	 * reuse the last custom icon source; if it's not available,
	 * default to mmc.exe
	 */
	if (s_strCustomIconFile.IsEmpty())
	{
        UINT   cchCustomIconFile = MAX_PATH;
		LPTSTR pszCustomIconFile = s_strCustomIconFile.GetBuffer (cchCustomIconFile);
		sc = ScCheckPointers (pszCustomIconFile, E_OUTOFMEMORY);
		if (sc)
		{
			MMCErrorBox (sc);
			return (0);
		}

		GetModuleFileName (NULL, pszCustomIconFile, cchCustomIconFile);
		s_strCustomIconFile.ReleaseBuffer();

	}

    sc = StringCchCopy(szIconFile, countof(szIconFile), s_strCustomIconFile);
    if(sc)
    {
        MMCErrorBox (sc);
        return (0);
    }

    if (MMC_PickIconDlg (m_hWnd, szIconFile, countof (szIconFile), &nIconIndex))
    {
        TCHAR szIconFile2[MAX_PATH];
        ExpandEnvironmentStrings(szIconFile, szIconFile2, countof(szIconFile2));

		/*
		 * remember the user's selection for next time
		 */
		s_strCustomIconFile = szIconFile;
		s_nIconIndex        = nIconIndex;

        // need to extract and copy the icon rather than use LoadImage, because LoadImage uses a custom icon
        CSmartIcon smartIconTemp;

        smartIconTemp.Attach(::ExtractIcon (_Module.m_hInst, szIconFile2, nIconIndex));
        m_CustomIconSmall.Attach((HICON) ::CopyImage((HICON)smartIconTemp, IMAGE_ICON, 16, 16, LR_COPYFROMRESOURCE));
        m_CustomIconLarge.Attach((HICON) ::CopyImage((HICON)smartIconTemp, IMAGE_ICON, 32, 32, LR_COPYFROMRESOURCE));

		/*
		 * update the custom icon preview window
		 */
		m_wndCustomIcon.SetIcon (m_CustomIconLarge);
		m_wndCustomIcon.InvalidateRect (NULL);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasksymbol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       tasksymbol.cpp
//
//  History: 17-Jan-2000 Vivekj added
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "TaskSymbol.h"
#include "tasks.h"

//############################################################################
//############################################################################
//
//  Traces
//
//############################################################################
//############################################################################
#ifdef DBG

CTraceTag tagTaskSymbol(TEXT("CTaskSymbol"), TEXT("CTaskSymbol"));

#endif //DBG


//############################################################################
//############################################################################
//
//  Implementation of class CTaskSymbol
//
//############################################################################
//############################################################################

extern CEOTSymbol s_rgEOTSymbol[];


CTaskSymbol::CTaskSymbol()
: m_dwConsoleTaskID(0),
  m_bSmall(0)
{
}



/*+-------------------------------------------------------------------------*
 *
 * CTaskSymbol::OnDraw
 *
 * PURPOSE: Draws out the symbol onto the DC specified in the ATL_DRAWINFO structure.
 *
 * PARAMETERS: 
 *    ATL_DRAWINFO& di :
 *
 * RETURNS: 
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CTaskSymbol::OnDraw(ATL_DRAWINFO& di)
{
    DECLARE_SC(sc, TEXT("CTaskSymbol::OnDraw"));
    RECT * pRect = (RECT *)di.prcBounds;


    sc = ScCheckPointers(pRect);
    if(sc)
        return sc.ToHr();

    CConsoleTask *pConsoleTask = CConsoleTask::GetConsoleTask(m_dwConsoleTaskID); // get the console task from the unique ID
    
    COLORREF colorOld = SetTextColor (di.hdcDraw, ::GetSysColor (COLOR_WINDOWTEXT));

    if(pConsoleTask)
        pConsoleTask->Draw(di.hdcDraw, pRect, m_bSmall);

    SetTextColor(di.hdcDraw, colorOld);


    return sc.ToHr();
}


LRESULT 
CTaskSymbol::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Fire_Click();
    return 0;
}

// from winuser.h, for Windows 2000 and above only.
#define IDC_HAND            MAKEINTRESOURCE(32649)


LRESULT 
CTaskSymbol::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    static HCURSOR s_hCursorHand = ::LoadCursor(NULL, IDC_HAND);

    // if the hand cursor is available, use it.
    if(s_hCursorHand)
        ::SetCursor(s_hCursorHand);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\tasksymbol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       tasksymbol.h
//
//  History: 17-Jan-2000 Vivekj added
//--------------------------------------------------------------------------

#ifndef __TASKSYMBOL_H_
#define __TASKSYMBOL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


/*+-------------------------------------------------------------------------*
 * class CProxyTaskSymbolEvents
 *
 *
 * PURPOSE: Event source implementation generated by ATL.
 *
 *+-------------------------------------------------------------------------*/
template <class T>
class CProxyTaskSymbolEvents : public IConnectionPointImpl<T, &DIID_TaskSymbolEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_Click()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(DISPID_CLICK, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;

    }
};

/*+-------------------------------------------------------------------------*
 * class CTaskSymbol
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class ATL_NO_VTABLE CTaskSymbol :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComControl<CTaskSymbol>,
    public IPersistStreamInitImpl<CTaskSymbol>,
    public IOleControlImpl<CTaskSymbol>,
    public IOleObjectImpl<CTaskSymbol>,
    public IOleInPlaceActiveObjectImpl<CTaskSymbol>,
    public IViewObjectExImpl<CTaskSymbol>,
    public IOleInPlaceObjectWindowlessImpl<CTaskSymbol>,
    public CComCoClass<CTaskSymbol, &CLSID_TaskSymbol>,
    public CProxyTaskSymbolEvents< CTaskSymbol >,
    public IConnectionPointContainerImpl<CTaskSymbol>,
	public IProvideClassInfo2Impl<&CLSID_TaskSymbol, &DIID_TaskSymbolEvents, &LIBID_NODEMGRLib>,
    public IPersistPropertyBagImpl<CTaskSymbol>,
    public IObjectSafetyImpl<CTaskSymbol, INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                                          INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
    typedef IObjectSafetyImpl<CTaskSymbol, INTERFACESAFE_FOR_UNTRUSTED_CALLER |INTERFACESAFE_FOR_UNTRUSTED_DATA> BCSafety;
public:
    CTaskSymbol();

DECLARE_MMC_CONTROL_REGISTRATION (
	g_szMmcndmgrDll,					// implementing DLL
    CLSID_TaskSymbol,               	// CLSID
    _T("TaskSymbol Class"),             // class name
    _T("Control.TaskSymbol.1"),         // ProgID
    _T("Control.TaskSymbol"),           // version-independent ProgID
    LIBID_NODEMGRLib,               	// LIBID
    _T("101"),                          // toolbox bitmap ID
    _T("1.0"))                          // version

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTaskSymbol)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    // Connection point container support
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CTaskSymbol)
    CONNECTION_POINT_ENTRY(DIID_TaskSymbolEvents)
END_CONNECTION_POINT_MAP()


BEGIN_PROP_MAP(CTaskSymbol)
    PROP_DATA_ENTRY("Small",           m_bSmall,          VT_UI4)
    PROP_DATA_ENTRY("ConsoleTaskID", m_dwConsoleTaskID, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CTaskSymbol)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_SETCURSOR,   OnSetCursor)
    CHAIN_MSG_MAP(CComControl<CTaskSymbol>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

public:
    HRESULT OnDraw(ATL_DRAWINFO& di);
	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    typedef std::wstring CString;
    UINT           m_dwConsoleTaskID;
    UINT           m_bSmall;

// Need to override the default IObjectSafetyImpl methods per KB article Q168371
public:
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask,DWORD dwEnabledOptions) {return S_OK;}
};

#endif //__TASKSYMBOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\taskui.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       taskui.cpp
 *
 *  Contents:   Implementation file for console taskpad UI classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "tasks.h"
#include "nodepath.h"
#include "oncmenu.h"
#include "scopndcb.h"
#include "rsltitem.h"
#include "conview.h"
#include "conframe.h"
#include "bitmap.h"
#include "util.h"

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadFrame
//
//############################################################################
//############################################################################
CTaskpadFrame::CTaskpadFrame(CNode *pNodeTarget, CConsoleTaskpad*  pConsoleTaskpad, CViewData *pViewData,
                bool fCookieValid, LPARAM lCookie)
{
    m_pNodeTarget       = pNodeTarget;
    m_pConsoleTaskpad   = pConsoleTaskpad;
    m_pViewData         = pViewData;
    m_fCookieValid      = fCookieValid;
    m_lCookie           = lCookie;

    if(pConsoleTaskpad)
        m_pConsoleTaskpad = pConsoleTaskpad;
    else
        m_pConsoleTaskpad = new CConsoleTaskpad();

    m_fNew = (pConsoleTaskpad == NULL);
    m_bTargetNodeSelected = (pNodeTarget != NULL);
}

CTaskpadFrame::CTaskpadFrame(const CTaskpadFrame &rhs)
{
    m_pNodeTarget         = rhs.m_pNodeTarget;
    m_pConsoleTaskpad     = rhs.m_pConsoleTaskpad;
    m_pViewData           = rhs.m_pViewData;
    m_fCookieValid        = rhs.m_fCookieValid;
    m_fNew                = rhs.m_fNew;
    m_lCookie             = rhs.m_lCookie;
    m_bTargetNodeSelected = rhs.m_bTargetNodeSelected;
}



//############################################################################
//############################################################################
//
//  Implementation of class CWizardPage
//
//############################################################################
//############################################################################
WTL::CFont CWizardPage::m_fontWelcome;

void CWizardPage::OnWelcomeSetActive(HWND hWnd)
{
    WTL::CPropertySheetWindow(::GetParent(hWnd)).SetWizardButtons (PSWIZB_NEXT);
}

void CWizardPage::OnWelcomeKillActive(HWND hWnd)
{
    WTL::CPropertySheetWindow(::GetParent(hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);
}

void CWizardPage::InitFonts(HWND hWnd)
{
    if (m_fontWelcome.m_hFont != NULL)
        return;

    CWindow wnd = hWnd;

	WTL::CClientDC dc (wnd);
	if (dc.m_hDC == NULL)
		return;

    // set the correct font for the title.
    LOGFONT lf;
    WTL::CFont fontDefault = wnd.GetFont();
    fontDefault.GetLogFont(&lf);
    fontDefault.Detach();

    // set the correct font for the welcome line
    CStr strWelcomeFont;
    strWelcomeFont.LoadString(GetStringModule(), IDS_WizardTitleFont);
    CStr strWelcomeFontSize;
    strWelcomeFont.LoadString(GetStringModule(), IDS_WizardTitleFontSize);

    int nPointSize = _ttoi(strWelcomeFont);

    lf.lfWeight = FW_BOLD;
    lf.lfHeight = -MulDiv(nPointSize, dc.GetDeviceCaps(LOGPIXELSY), 72);
    lf.lfWidth  = 0;
    SC sc = StringCchCopy(lf.lfFaceName, countof(lf.lfFaceName), strWelcomeFont);
    if(sc)
        sc.TraceAndClear();

    m_fontWelcome.CreateFontIndirect(&lf);
}

void CWizardPage::OnInitWelcomePage(HWND hDlg)
{
    InitFonts(hDlg);

    CWindow wndTitle = ::GetDlgItem (hDlg, IDC_WELCOME);
    wndTitle.SetFont (m_fontWelcome);
}

void CWizardPage::OnInitFinishPage(HWND hDlg)
{
    InitFonts(hDlg);

    CWindow wndTitle = ::GetDlgItem (hDlg, IDC_COMPLETING);
    wndTitle.SetFont (m_fontWelcome);

    WTL::CPropertySheetWindow(::GetParent(hDlg)).SetWizardButtons (PSWIZB_BACK | PSWIZB_FINISH);
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadPropertySheet
//
//############################################################################
//############################################################################


/* CTaskpadPropertySheet::CTaskpadPropertySheet
 *
 * PURPOSE:     Constructor
 *
 * PARAMETERS:  None
 *
 */
CTaskpadPropertySheet::CTaskpadPropertySheet(CNode *pNodeTarget, CConsoleTaskpad & rConsoleTaskpad, bool fNew,
                LPARAM lparamSelectedNode, bool fLParamValid, CViewData *pViewData, eReason reason):
    BC(),
    CTaskpadFrame(pNodeTarget, &rConsoleTaskpad, pViewData, fLParamValid,
                    lparamSelectedNode),
    m_proppTaskpadGeneral(this),
    m_proppTasks(this, (reason == eReason_NEWTASK)? true : false),
    m_fInsertNode(false),
    m_fNew(fNew),
    m_eReason(reason)
{
    // Add the property pages
    AddPage( m_proppTaskpadGeneral );

    if(!fNew)
        AddPage( m_proppTasks );

    if(Reason()==eReason_NEWTASK)
    {
        ASSERT(!fNew);
        SetActivePage(1); // the tasks page
    }

    /*
     * give the property sheet a title (the string must be a member so
     * it lives until DoModal, where it will actually get used.
     */
    m_strTitle = rConsoleTaskpad.GetName();

    /*
     * HACK:  We should be able to use
     *
     *      SetTitle (m_strTitle.data(), PSH_PROPTITLE);
     *
     * but ATL21 has a bogus assert (it asserts (lpszText == NULL)
     * instead of (lpszText != NULL).
     */
    //  SetTitle (m_strTitle.data(), PSH_PROPTITLE);
    m_psh.pszCaption = m_strTitle.data();
    m_psh.dwFlags   |= PSH_PROPTITLE;

    // hide the Apply button
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadPropertySheet::~CTaskpadPropertySheet
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CTaskpadPropertySheet::~CTaskpadPropertySheet()
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadPropertySheet::DoModal
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      int
/*+-------------------------------------------------------------------------*/
int
CTaskpadPropertySheet::DoModal()
{
    // save the current taskpad in case the user wants to cancel.
    CConsoleTaskpad*pConsoleTaskpad = PConsoleTaskpad();
    CConsoleTaskpad consoleTaskpad = *PConsoleTaskpad();    // make a copy

    CTaskpadFrame::m_pConsoleTaskpad = &consoleTaskpad;     // make modifications on the copy.

    // call the base class method to make changes on the copy.
    int iResp = BC::DoModal();

    if(iResp == IDOK)
    {
        *pConsoleTaskpad = consoleTaskpad;                  // commit changes
        pConsoleTaskpad->SetDirty(true);
    }

    return iResp;
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadWizard
//
//############################################################################
//############################################################################

CTaskpadWizard::CTaskpadWizard(
    CNode*              pNodeTarget,
    CConsoleTaskpad&    rConsoleTaskPad,
    bool                fNew,
    LPARAM              lparamSelectedNode,
    bool                fLParamValid,
    CViewData*          pViewData)
    :
    BC(pNodeTarget, &rConsoleTaskPad, pViewData, fLParamValid, lparamSelectedNode)
{
    BC::SetNew(fNew);
};

HRESULT
CTaskpadWizard::Show(HWND hWndParent, bool *pfStartTaskWizard)
{
    USES_CONVERSION;

    *pfStartTaskWizard = false;

    // save the current taskpad in case the user wants to cancel.
    CConsoleTaskpad*pConsoleTaskpad = PConsoleTaskpad();
    CConsoleTaskpad consoleTaskpad = *PConsoleTaskpad();    // make a copy

    CTaskpadFrame::m_pConsoleTaskpad = &consoleTaskpad;     // make modifications on the copy.

    // create a property sheet
    IFramePrivatePtr spFrame;
    spFrame.CreateInstance(CLSID_NodeInit,
#if _MSC_VER >= 1100
                        NULL,
#endif
                        MMC_CLSCTX_INPROC);


    IPropertySheetProviderPtr pIPSP = spFrame;
    if (pIPSP == NULL)
        return S_FALSE;

    HRESULT hr = pIPSP->CreatePropertySheet (L"Cool :-)", FALSE, NULL, NULL,
                                             MMC_PSO_NEWWIZARDTYPE);

    CHECK_HRESULT(hr);
    RETURN_ON_FAIL(hr);

    // create property pages
    CTaskpadWizardWelcomePage   welcomePage;
    CTaskpadStylePage           stylePage(this);
    CTaskpadNodetypePage        nodetypePage(this);
    CTaskpadNamePage            namePage(this);
    CTaskpadWizardFinishPage    finishPage(pfStartTaskWizard);

    // create the pages we'll add in IExtendPropertySheet::CreatePropertyPages
    CExtendPropSheet* peps;
    hr = CExtendPropSheet::CreateInstance (&peps);
    CHECK_HRESULT(hr);
    RETURN_ON_FAIL(hr);

    /*
     * destroying this object will take care of releasing our ref on peps
     */
    IUnknownPtr spUnk = peps;
    ASSERT (spUnk != NULL);

	peps->SetWatermarkID (IDB_TASKPAD_WIZARD_WELCOME);
    peps->SetHeaderID    (IDB_TASKPAD_WIZARD_HEADER);

    peps->AddPage (welcomePage.Create());
    peps->AddPage (stylePage.Create());
    peps->AddPage (nodetypePage.Create());
    peps->AddPage (namePage.Create());
    peps->AddPage (finishPage.Create());


    hr = pIPSP->AddPrimaryPages(spUnk, FALSE, NULL, FALSE);
    CHECK_HRESULT(hr);

    hr = pIPSP->Show((LONG_PTR)hWndParent, 0);
    CHECK_HRESULT(hr);

    if(hr==S_OK)
    {
        // need to do this explicitly - wizards don't get an OnApply message. Bummer.
        nodetypePage.OnApply();

        *pConsoleTaskpad = consoleTaskpad;                  // commit changes
        pConsoleTaskpad->SetDirty(true);
    }

    return hr;
}



//############################################################################
//############################################################################
//
//  Implementation of class CExtendPropSheetImpl
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CPropertySheetInserter
 *
 * Simple output iterator that will add pages to an MMC property sheet
 * by way of IPropertySheetCallback.
 *--------------------------------------------------------------------------*/

class CPropertySheetInserter : std::iterator<std::output_iterator_tag, void, void>
{
public:
    CPropertySheetInserter (IPropertySheetCallback* pPropSheetCallback) :
        m_spPropSheetCallback (pPropSheetCallback)
    {}

    CPropertySheetInserter& operator=(HANDLE hPage)
    {
        m_spPropSheetCallback->AddPage ((HPROPSHEETPAGE) hPage);
        return (*this);
    }

    CPropertySheetInserter& operator*()
        { return (*this); }
    CPropertySheetInserter& operator++()
        { return (*this); }
    CPropertySheetInserter operator++(int)
        { return (*this); }

protected:
    IPropertySheetCallbackPtr   m_spPropSheetCallback;
};


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::AddPage
 *
 *
 *--------------------------------------------------------------------------*/

void CExtendPropSheetImpl::AddPage (HPROPSHEETPAGE hPage)
{
    m_vPages.push_back ((HANDLE) hPage);
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::SetHeaderID
 *
 *
 *--------------------------------------------------------------------------*/

void CExtendPropSheetImpl::SetHeaderID (int nHeaderID)
{
	m_nHeaderID = nHeaderID;
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::SetWatermarkID
 *
 *
 *--------------------------------------------------------------------------*/

void CExtendPropSheetImpl::SetWatermarkID (int nWatermarkID)
{
	m_nWatermarkID = nWatermarkID;
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::CreatePropertyPages
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CExtendPropSheetImpl::CreatePropertyPages (IPropertySheetCallback* pPSC, LONG_PTR handle, IDataObject* pDO)
{
    std::copy (m_vPages.begin(), m_vPages.end(), CPropertySheetInserter(pPSC));
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::QueryPagesFor
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CExtendPropSheetImpl::QueryPagesFor (IDataObject* pDO)
{
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CExtendPropSheetImpl::GetWatermarks
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CExtendPropSheetImpl::GetWatermarks (IDataObject* pDO, HBITMAP* phbmWatermark, HBITMAP* phbmHeader, HPALETTE* phPal, BOOL* pbStretch)
{
    *phbmWatermark = (m_nWatermarkID)
						? LoadBitmap (_Module.GetResourceInstance(),
									  MAKEINTRESOURCE (m_nWatermarkID))
						: NULL;
	ASSERT ((m_nWatermarkID == 0) || (*phbmWatermark != NULL));

    *phbmHeader    = (m_nHeaderID)
						? LoadBitmap (_Module.GetResourceInstance(),
									  MAKEINTRESOURCE (m_nHeaderID))
						: NULL;
	ASSERT ((m_nHeaderID == 0) || (*phbmHeader != NULL));

    *phPal         = NULL;
    *pbStretch     = false;

    return (S_OK);
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadNamePage
//
//############################################################################
//############################################################################
CTaskpadNamePage::CTaskpadNamePage(CTaskpadFrame * pTaskpadFrame)
    :   CTaskpadFramePtr(pTaskpadFrame)
{
}

BOOL
CTaskpadNamePage::OnSetActive()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);

    m_strName.       Initialize (this, IDC_TASKPAD_TITLE,      -1, PConsoleTaskpad()->GetName().data());
    m_strDescription.Initialize (this, IDC_TASKPAD_DESCRIPTION,-1, PConsoleTaskpad()->GetDescription().data());
    return true;
}


int
CTaskpadNamePage::OnWizardNext()
{
    tstring strName = MMC::GetWindowText (m_strName);

    if (strName.empty())
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), IDS_TASKPAD_NAME_REQUIRED_ERROR);
        MessageBox(strTitle, NULL, MB_OK | MB_ICONEXCLAMATION);
        return -1;
    }

    tstring strDescription = MMC::GetWindowText (m_strDescription);

    CConsoleTaskpad* pTaskpad = PConsoleTaskpad();

    pTaskpad->SetName        (strName);
    pTaskpad->SetDescription (strDescription);

    return 0;
}

int
CTaskpadNamePage::OnWizardBack()
{
    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadWizardWelcomePage
//
//############################################################################
//############################################################################
LRESULT CTaskpadWizardWelcomePage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    return 0;
}

bool
CTaskpadWizardWelcomePage::OnSetActive()
{
    CWizardPage::OnWelcomeSetActive(m_hWnd);
    return true;
}

bool
CTaskpadWizardWelcomePage::OnKillActive()
{
    CWizardPage::OnWelcomeKillActive(m_hWnd);
    return true;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadWizardFinishPage
//
//############################################################################
//############################################################################
LRESULT CTaskpadWizardFinishPage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWizardPage::OnInitFinishPage(m_hWnd); // set up the correct title font
    CheckDlgButton(IDC_START_TASK_WIZARD, BST_CHECKED);
    return 0;
}

BOOL
CTaskpadWizardFinishPage::OnSetActive()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_FINISH);
    return true;
}

BOOL
CTaskpadWizardFinishPage::OnWizardFinish()
{
    *m_pfStartTaskWizard = (IsDlgButtonChecked(IDC_START_TASK_WIZARD)==BST_CHECKED);
    return TRUE;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStyle
//
//############################################################################
//############################################################################
CTaskpadStyle::CTaskpadStyle (
    ListSize    eSize,
    int         idsDescription,
    int         nPreviewBitmapID,
    DWORD       dwOrientation)
:
m_eSize            (eSize),
m_idsDescription   (idsDescription),
m_nPreviewBitmapID (nPreviewBitmapID),
m_dwOrientation    (dwOrientation)
{
}

CTaskpadStyle::CTaskpadStyle (
    ListSize    eSize,
    DWORD       dwOrientation)
:
m_eSize            (eSize),
m_idsDescription   (0),
m_nPreviewBitmapID (0),
m_dwOrientation    (dwOrientation)
{
}

CTaskpadStyle::CTaskpadStyle (const CTaskpadStyle& other)
{
	*this = other;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyle::operator=
 *
 * Custom assignment operator for CTaskpadStyle that does a deep copy of
 * its contained WTL::CBitmap.
 *--------------------------------------------------------------------------*/

CTaskpadStyle& CTaskpadStyle::operator= (const CTaskpadStyle& other)
{
	if (this != &other)
	{
		m_eSize            = other.m_eSize;
		m_idsDescription   = other.m_idsDescription;
		m_nPreviewBitmapID = other.m_nPreviewBitmapID;
		m_dwOrientation    = other.m_dwOrientation;
		m_strDescription   = other.m_strDescription;

		/*
		 * WTL::CBitmap does a shallow copy of the bitmap.  We need to
		 * do a deep copy here so (*this) and (other) don't both
		 * DeleteObject the same bitmap.
		 */
		if (!m_PreviewBitmap.IsNull())
			m_PreviewBitmap.DeleteObject();

		m_PreviewBitmap = CopyBitmap (other.m_PreviewBitmap);
	}

	return (*this);
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStyleBase
//
//############################################################################
//############################################################################




// static variables
CTaskpadStyle
CTaskpadStyleBase::s_rgTaskpadStyle[] =
{
    //             Size                         Description                  Bitmap                     dwOrientation
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzSml,     TVO_HORIZONTAL),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzMed,     TVO_HORIZONTAL),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzLrg,     TVO_HORIZONTAL),
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzSmlD,    TVO_HORIZONTAL | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzMedD,    TVO_HORIZONTAL | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_HORZ_DESCR,      IDB_TPPreview_HorzLrgD,    TVO_HORIZONTAL | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertSml,     TVO_VERTICAL  ),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertMed,     TVO_VERTICAL  ),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertLrg,     TVO_VERTICAL  ),
    CTaskpadStyle (eSize_Small,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertSmlD,    TVO_VERTICAL   | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Medium, IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertMedD,    TVO_VERTICAL   | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_Large,  IDS_TPSTYLE_VERT_DESCR,      IDB_TPPreview_VertLrgD,    TVO_VERTICAL   | TVO_DESCRIPTIONS_AS_TEXT),
    CTaskpadStyle (eSize_None,    IDS_TPSTYLE_NOLIST_DESCR,    IDB_TPPreview_Tasks,       TVO_NO_RESULTS),
    CTaskpadStyle (eSize_None,    IDS_TPSTYLE_NOLIST_DESCR,    IDB_TPPreview_TasksD,      TVO_NO_RESULTS | TVO_DESCRIPTIONS_AS_TEXT),
};

CTaskpadStyleBase::CTaskpadStyleBase(CTaskpadFrame * pTaskpadFrame) :
    CTaskpadFramePtr(pTaskpadFrame)
{
}

LRESULT
CTaskpadStyleBase::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWindow wndDlg = HWnd();

    m_wndPreview = wndDlg.GetDlgItem (IDC_TaskpadPreview);

    /*
     * make sure the taskpad's size is valid (bias to large list)
     */
    ListSize eSize =  PConsoleTaskpad()->GetListSize();

    if ((eSize != eSize_Small) &&
        (eSize != eSize_Medium))
        eSize = eSize_Large;

    ASSERT ((eSize == eSize_Small) ||
            (eSize == eSize_Large) ||
            (eSize == eSize_Medium));


    /*
     * prime the combo box
     */
    m_wndSizeCombo = wndDlg.GetDlgItem (IDC_Style_SizeCombo);

    static const struct {
        ListSize eSize;
        int                     nTextID;
    } ComboData[] = {
        { eSize_Small,   IDS_Small  },
        { eSize_Medium,  IDS_Medium },
        { eSize_Large,   IDS_Large  },
    };

    for (int i = 0; i < countof (ComboData); i++)
    {
        CStr str;
        VERIFY (str.LoadString(GetStringModule(), ComboData[i].nTextID));
        VERIFY (m_wndSizeCombo.InsertString (-1, str) == i);
        m_wndSizeCombo.SetItemData (i, ComboData[i].eSize);

        if (eSize == ComboData[i].eSize)
            m_wndSizeCombo.SetCurSel (i);
    }

    /*
     * make sure something is selected
     */
    ASSERT (m_wndSizeCombo.GetCurSel() != CB_ERR);


    /*
     * prime the radio buttons
     */
    int nID;

    DWORD dwOrientation = PConsoleTaskpad()->GetOrientation();

    nID = (dwOrientation & TVO_VERTICAL)    ? IDC_Style_VerticalList    :
          (dwOrientation & TVO_HORIZONTAL)  ? IDC_Style_HorizontalList  :
                                              IDC_Style_TasksOnly;
    CheckRadioButton (HWnd(), IDC_Style_VerticalList, IDC_Style_TasksOnly, nID);

    nID = (dwOrientation & TVO_DESCRIPTIONS_AS_TEXT) ? IDC_Style_TextDesc  :
                                                       IDC_Style_TooltipDesc;
    CheckRadioButton (HWnd(), IDC_Style_TooltipDesc, IDC_Style_TextDesc, nID);

    ASSERT (s_rgTaskpadStyle[FindStyle (dwOrientation, eSize)] ==
                                        CTaskpadStyle (eSize, dwOrientation));


    // prime the check box
    bool bReplacesDefaultView = PConsoleTaskpad()->FReplacesDefaultView();
    ::SendDlgItemMessage(HWnd(), IDC_Style_HideNormalTab,    BM_SETCHECK, (WPARAM) bReplacesDefaultView  ? BST_CHECKED : BST_UNCHECKED,  0);


    /*
     * update the preview and description
     */
    UpdateControls ();

    return 0;
}

LRESULT
CTaskpadStyleBase::OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    UpdateControls ();
    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::UpdateControls
 *
 *
 *--------------------------------------------------------------------------*/

void CTaskpadStyleBase::UpdateControls ()
{
    DWORD                   dwOrientation;
    ListSize eSize;
    GetSettings (dwOrientation, eSize);

    /*
     * find the style entry that matches the dialog settings
     */
    int nStyle = FindStyle (dwOrientation, eSize);

    /*
     * update the preview bitmap
     */
    m_wndPreview.SetBitmap (s_rgTaskpadStyle[nStyle].GetPreviewBitmap());

    /*
     * update the description text
     */
    SetDlgItemText (HWnd(), IDC_STYLE_DESCRIPTION,
                    s_rgTaskpadStyle[nStyle].GetDescription());

    /*
     * disable the size combo for "Tasks only" taskpads
     */
    m_wndSizeCombo.EnableWindow (!(dwOrientation & TVO_NO_RESULTS));
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::FindStyle
 *
 * Returns the index of the CTaskpadStyle entry matching the given size
 * and orientation.
 *--------------------------------------------------------------------------*/

int CTaskpadStyleBase::FindStyle (DWORD dwOrientation, ListSize eSize)
{
    CTaskpadStyle tps(eSize, dwOrientation);

    for (int i = 0; i < countof (s_rgTaskpadStyle); i++)
    {
        if (s_rgTaskpadStyle[i] == tps)
            break;
    }

    ASSERT (i < countof (s_rgTaskpadStyle));
    return (i);
}


/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::Apply
 *
 *
 *--------------------------------------------------------------------------*/

bool CTaskpadStyleBase::Apply()
{
    DWORD                   dwOrientation;
    ListSize eSize;
    GetSettings (dwOrientation, eSize);

    // set the "replaces default view" flag.
    CWindow wnd = HWnd();
    bool bReplacesDefaultView = wnd.IsDlgButtonChecked (IDC_Style_HideNormalTab);
    PConsoleTaskpad()->SetReplacesDefaultView(bReplacesDefaultView);

    PConsoleTaskpad()->SetOrientation   (dwOrientation);
    PConsoleTaskpad()->SetListSize(eSize);

    return true;
}



/*+-------------------------------------------------------------------------*
 * CTaskpadStyleBase::GetSettings
 *
 * Returns the orientation and size presently selected in the dialog.
 *--------------------------------------------------------------------------*/

void CTaskpadStyleBase::GetSettings (DWORD& dwOrientation, ListSize& eSize)
{
    CWindow wnd = HWnd();

    dwOrientation = wnd.IsDlgButtonChecked (IDC_Style_VerticalList)   ? TVO_VERTICAL :
                    wnd.IsDlgButtonChecked (IDC_Style_HorizontalList) ? TVO_HORIZONTAL :
                                                                        TVO_NO_RESULTS;

    if (wnd.IsDlgButtonChecked (IDC_Style_TextDesc))
        dwOrientation |= TVO_DESCRIPTIONS_AS_TEXT;

    eSize = (ListSize) m_wndSizeCombo.GetItemData (m_wndSizeCombo.GetCurSel ());
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStylePage
//
//############################################################################
//############################################################################
CTaskpadStylePage::CTaskpadStylePage(CTaskpadFrame * pTaskpadFrame) :
    CTaskpadFramePtr(pTaskpadFrame),
    BC2(pTaskpadFrame)
{
}

bool
CTaskpadStylePage::OnSetActive()
{
    UpdateControls();
    return true;
}

bool
CTaskpadStylePage::OnKillActive()
{
    return CTaskpadStyleBase::Apply();
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadStyle
//
//############################################################################
//############################################################################

const CStr&
CTaskpadStyle::GetDescription () const
{
    if (m_strDescription.IsEmpty())
        m_strDescription.LoadString(GetStringModule(), m_idsDescription);

    ASSERT (!m_strDescription.IsEmpty());
    return (m_strDescription);
}


HBITMAP CTaskpadStyle::GetPreviewBitmap() const
{
    if (m_PreviewBitmap == NULL)
        m_PreviewBitmap = LoadSysColorBitmap (_Module.GetResourceInstance(),
                                              m_nPreviewBitmapID);

    ASSERT (m_PreviewBitmap != NULL);
    return (m_PreviewBitmap);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadNodetypeBase
//
//############################################################################
//############################################################################
CTaskpadNodetypeBase::CTaskpadNodetypeBase(CTaskpadFrame *pTaskpadFrame)
: CTaskpadFramePtr(pTaskpadFrame)
{
}

LRESULT
CTaskpadNodetypeBase::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_bApplytoNodetype          = !PConsoleTaskpad()->IsNodeSpecific();
    m_bSetDefaultForNodetype    = true; //$CHANGE

    CDefaultTaskpadList *pDefaultTaskpadList = PTaskpadFrame()->PScopeTree()->GetDefaultTaskpadList();
    ASSERT(pDefaultTaskpadList != NULL);

    CDefaultTaskpadList::iterator iter = pDefaultTaskpadList->find(PConsoleTaskpad()->GetNodeType());
    if(iter != pDefaultTaskpadList->end())
    {
        if(iter->second == PConsoleTaskpad()->GetID())
        {
            m_bSetDefaultForNodetype = true;
        }
    }

    ::SendDlgItemMessage(HWnd(), IDC_UseForSimilarNodes,    BM_SETCHECK, (WPARAM) m_bApplytoNodetype       ? BST_CHECKED : BST_UNCHECKED,  0);
    ::SendDlgItemMessage(HWnd(), IDC_DontUseForSimilarNodes,BM_SETCHECK, (WPARAM) (!m_bApplytoNodetype)    ? BST_CHECKED : BST_UNCHECKED,  0);
    ::SendDlgItemMessage(HWnd(), IDC_SetDefaultForNodetype, BM_SETCHECK, (WPARAM) m_bSetDefaultForNodetype ? BST_CHECKED : BST_UNCHECKED,  0);
    EnableControls();

    return 0;
}

LRESULT
CTaskpadNodetypeBase::OnUseForNodetype(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bApplytoNodetype = true;
    EnableControls();
    return 0;
}

LRESULT
CTaskpadNodetypeBase::OnDontUseForNodetype(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bApplytoNodetype = false;
    EnableControls();
    return 0;
}

LRESULT
CTaskpadNodetypeBase::OnSetAsDefault  (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bSetDefaultForNodetype = !m_bSetDefaultForNodetype;
    EnableControls();
    return 0;
}

void
CTaskpadNodetypeBase::EnableControls()
{
    // enable the set as default button only if the taskpad applies to all nodes of the same type.
    WTL::CButton wndSetAsDefault = ::GetDlgItem(HWnd(), IDC_SetDefaultForNodetype);
    wndSetAsDefault.EnableWindow (m_bApplytoNodetype);

    /*
     * check it if it's disabled
     */
    if (!m_bApplytoNodetype)
        wndSetAsDefault.SetCheck (BST_CHECKED);
}


bool
CTaskpadNodetypeBase::OnApply()
{
    PConsoleTaskpad()->SetNodeSpecific(!m_bApplytoNodetype);
    if(!m_bApplytoNodetype) // retarget the taskpad to this node only.
    {
        CNode *pNode = PTaskpadFrame()->PNodeTarget();
        ASSERT(pNode != NULL);
        PConsoleTaskpad()->Retarget(pNode);
    }

    CDefaultTaskpadList *pDefaultList = PTaskpadFrame()->PScopeTree()->GetDefaultTaskpadList();
    ASSERT(pDefaultList != NULL);

    CDefaultTaskpadList::iterator iter = pDefaultList->find(PConsoleTaskpad()->GetNodeType());

    if(m_bApplytoNodetype && m_bSetDefaultForNodetype)
    {
        (*pDefaultList)[PConsoleTaskpad()->GetNodeType()] = PConsoleTaskpad()->GetID();
    }
    else
    {
        if(iter != pDefaultList->end())
        {
            if(iter->second==PConsoleTaskpad()->GetID())
                pDefaultList->erase(iter);
        }
    }

    return true;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadNodetypePage
//
//############################################################################
//############################################################################
CTaskpadNodetypePage::CTaskpadNodetypePage(CTaskpadFrame *pTaskpadFrame) :
    CTaskpadNodetypeBase(pTaskpadFrame), CTaskpadFramePtr(pTaskpadFrame)
{
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadGeneralPage
//
//############################################################################
//############################################################################

/* CTaskpadGeneralPage::CTaskpadGeneralPage
 *
 * PURPOSE:     Constructor
 *
 * PARAMETERS:  None
 *
 */
CTaskpadGeneralPage::CTaskpadGeneralPage(CTaskpadFrame * pTaskpadFrame):
    BC(),
    CTaskpadFramePtr(pTaskpadFrame),
    BC2(pTaskpadFrame)
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadGeneralPage::OnInitDialog
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      INT      uMsg:
 *      WPARAM   wParam:
 *      LPARAM   lParam:
 *      BOOL&    bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
LRESULT
CTaskpadGeneralPage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_strName.       Initialize (this, IDC_TASKPAD_TITLE,      -1, PConsoleTaskpad()->GetName().data());
    m_strDescription.Initialize (this, IDC_TASKPAD_DESCRIPTION,-1, PConsoleTaskpad()->GetDescription().data());

    return 0;
}





/*+-------------------------------------------------------------------------*
 * CTaskpadGeneralPage::OnOptions
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CTaskpadGeneralPage::OnOptions(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    CTaskpadOptionsDlg dlg (PTaskpadFrame());

    if (dlg.DoModal() == IDOK)
    {
        /*
         * apply the changes to the taskpad
         */
        CConsoleTaskpad* pTaskpad = PConsoleTaskpad();

        //pTaskpad->SetContextFormat  (dlg.m_ctxt);
        UpdateControls();
    }

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskpadGeneralPage::OnApply
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      BOOL
/*+-------------------------------------------------------------------------*/
bool
CTaskpadGeneralPage::OnApply()
{
    tstring strName = MMC::GetWindowText (m_strName);

    if (strName.empty())
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), IDS_TASKPAD_NAME_REQUIRED_ERROR);
        MessageBox(strTitle, NULL, MB_OK | MB_ICONEXCLAMATION);
        return false;
    }

    tstring strDescription = MMC::GetWindowText (m_strDescription);

    CConsoleTaskpad* pTaskpad = PConsoleTaskpad();

    pTaskpad->SetName        (strName);
    pTaskpad->SetDescription (strDescription);

    return BC2::Apply();
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskpadOptionsDlg
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::CTaskpadOptionsDlg
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      TaskpadFrame *    pTaskpadFrame:
 *      CConsoleTask &    rConsoleTask:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CTaskpadOptionsDlg::CTaskpadOptionsDlg (CTaskpadFrame* pTaskpadFrame) :
    CTaskpadFramePtr                   (pTaskpadFrame),
//    BC3                                (pTaskpadFrame),
    BC4                                (pTaskpadFrame)
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::~CTaskpadOptionsDlg
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CTaskpadOptionsDlg::~CTaskpadOptionsDlg()
{
}


/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::OnInitDialog
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      INT      uMsg:
 *      WPARAM   wParam:
 *      LPARAM   lParam:
 *      BOOL&    bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
LRESULT
CTaskpadOptionsDlg::OnInitDialog (HWND hwndFocus, LPARAM lParam, BOOL& bHandled )
{
    CConsoleTaskpad *           pTaskpad   = PConsoleTaskpad();
    EnableControls();
    return (true);
}

/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::EnableControls
 *
 *
 *--------------------------------------------------------------------------*/

void CTaskpadOptionsDlg::EnableControls()
{
    /*
    bool fUseFixedFormat     = IsDlgButtonChecked (IDC_UseFixedFormat);
    bool fUseCustomFormat    = IsDlgButtonChecked (IDC_UseCustomContextFormat);

    /*
     * If neither fixed or custom format, then we're displaying no
     * caption.  If there's no caption, there's no room for a change
     * button, so we'll disable all of the retargetting-related controls
     *
    if (!fUseFixedFormat && !fUseCustomFormat && !m_fSavedWorkingSetting)
    {
        ASSERT (IsDlgButtonChecked (IDC_NoCaption));

        m_fSavedWorkingSetting             = true;
    }
    else if (m_fSavedWorkingSetting)
    {
        m_fSavedWorkingSetting = false;
    }

    //BC3::EnableControls();                                            */
}




/*+-------------------------------------------------------------------------*
 * CTaskpadOptionsDlg::OnApply
 *
 *
 *--------------------------------------------------------------------------*/

bool CTaskpadOptionsDlg::OnApply()
{
    //if(!BC3::OnApply())
      //  return false;

    if(!BC4::OnApply())
        return false;

    return (true);
}

//############################################################################
//############################################################################
//
//  Implementation of class CDialogBase
//
//############################################################################
//############################################################################



/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::CDialogBase
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
CDialogBase<T>::CDialogBase (bool fAutoCenter /* =false */) :
    m_fAutoCenter (fAutoCenter)
{
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::OnInitDialog
 *
 * WM_INITDIALOG handler for CDialogBase.
 *--------------------------------------------------------------------------*/

template<class T>
LRESULT CDialogBase<T>::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fAutoCenter)
        PreventMFCAutoCenter (this);

    return (OnInitDialog ((HWND) wParam, lParam, bHandled));
}

template<class T>
LRESULT CDialogBase<T>::OnInitDialog (HWND hwndFocus, LPARAM lParam, BOOL& bHandled)
{
    /*
     * we didn't change the default focus
     */
    return (true);
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::OnOK
 *
 * IDOK handler for CDialogBase.
 *--------------------------------------------------------------------------*/

template<class T>
LRESULT CDialogBase<T>::OnOK (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (OnApply ())
        EndDialog (IDOK);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::OnCancel
 *
 * IDCANCEL handler for CDialogBase.
 *--------------------------------------------------------------------------*/

template<class T>
LRESULT CDialogBase<T>::OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog (IDCANCEL);
    return (0);
}




/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::EnableDlgItem
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
BOOL CDialogBase<T>::EnableDlgItem (int idControl, bool fEnable)
{
    return (::EnableWindow (GetDlgItem (idControl), fEnable));
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::CheckDlgItem
 *
 *
 *--------------------------------------------------------------------------*/

template<class T>
void CDialogBase<T>::CheckDlgItem (int idControl, int nCheck)
{
    MMC_ATL::CButton btn = GetDlgItem (idControl);
    btn.SetCheck (nCheck);
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::GetDlgItemText
 *
 * Returns the text for a given control in the form of a tstring
 *--------------------------------------------------------------------------*/

template<class T>
tstring CDialogBase<T>::GetDlgItemText (int idControl)
{
    return (MMC::GetWindowText (GetDlgItem (idControl)));
}


/*+-------------------------------------------------------------------------*
 * CDialogBase<T>::SetDlgItemText
 *
 * Sets the text for a given control in the form of a tstring
 *--------------------------------------------------------------------------*/

template<class T>
BOOL CDialogBase<T>::SetDlgItemText (int idControl, tstring str)
{
    return (BaseClass::SetDlgItemText (idControl, str.data()));
}




//############################################################################
//############################################################################
//
//  Implementation of class CTaskPropertiesBase
//
//############################################################################
//############################################################################



/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::CTaskPropertiesBase
 *
 *
 *--------------------------------------------------------------------------*/

CTaskPropertiesBase::CTaskPropertiesBase (
    CTaskpadFrame*  pTaskpadFrame,
    CConsoleTask &  consoleTask,
    bool            fNew)
    :
    CTaskpadFramePtr(pTaskpadFrame),
    m_pTask         (&consoleTask),
    m_fNew          (fNew)
{
}

/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::ScOnVisitContextMenu
 *
 *
 *--------------------------------------------------------------------------*/

// forward declaration of function
void RemoveAccelerators(tstring &str);


SC
CTaskPropertiesBase::ScOnVisitContextMenu(CMenuItem &menuItem)
{
    DECLARE_SC(sc, TEXT("CTaskPropertiesBase::ScOnVisitContextMenu"));

    WTL::CListBox&  wndListBox = GetListBox();
    IntToTaskMap&   map        = GetTaskMap();

    // set up a CConsoleTask object
    CConsoleTask    task;

    tstring strName = menuItem.GetMenuItemName();
    RemoveAccelerators(strName); // friendly looking name.

    task.SetName(       strName);
    task.SetDescription(menuItem.GetMenuItemStatusBarText());
    task.SetCommand(    menuItem.GetLanguageIndependentPath());

    int i = wndListBox.AddString (menuItem.GetPath()); // the "ui-friendly" command path.
    map[i] = task;

    // if this task matches the current task, select it in the listbox
    if (ConsoleTask() == menuItem)
        wndListBox.SetCurSel (i);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::OnCommandListSelChange
 *
 * LBN_SELCHANGE handler for CTaskPropertiesBase
/*+-------------------------------------------------------------------------*/

LRESULT CTaskPropertiesBase::OnCommandListSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int             iSelected = WTL::CListBox(hWndCtl).GetCurSel();
    IntToTaskMap&   TaskMap  =  GetTaskMap();

    CConsoleTask& task = TaskMap[iSelected];
    ConsoleTask().SetName(task.GetName());
    ConsoleTask().SetDescription(task.GetDescription());
    ConsoleTask().SetCommand(task.GetCommand());

    return (0);
}


//############################################################################
//############################################################################
//
//  class CCommandLineArgumentsMenu
//
//############################################################################
//############################################################################

class CCommandLineArgumentsMenu
{
    enum
    {
        TARGETNODE_ITEMS_BASE = 100,
        LISTVIEW_ITEMS_BASE   = 1000
    };
    typedef WTL::CMenu CMenu;
public:
    CCommandLineArgumentsMenu(HWND hWndParent, int nIDButton, HWND hWndListCtrl);
    bool Popup();
    CStr GetResultString()  {return m_strResult;}

private:
    void AddMenuItemsForTargetNode(CMenu &menu);
    void AddMenuItemsForListView(CMenu &menu);
private:
    HWND    m_hWndParent;
    HWND    m_hWndListCtrl;
    int     m_nIDButton;
    CStr    m_strResult;    // the string which was created as a result of the selection
};

CCommandLineArgumentsMenu::CCommandLineArgumentsMenu(HWND hWndParent, int nIDButton, HWND hWndListCtrl) :
    m_hWndParent(hWndParent),
    m_nIDButton(nIDButton),
    m_hWndListCtrl(hWndListCtrl)
{
}

void
CCommandLineArgumentsMenu::AddMenuItemsForTargetNode(CMenu &menu)
{
    bool fSucceeded = menu.CreatePopupMenu();
    ASSERT(fSucceeded);

    CStr strTargetNodeName;
    strTargetNodeName.LoadString(GetStringModule(), IDS_TargetNodeName);
    fSucceeded = menu.AppendMenu(MF_STRING, TARGETNODE_ITEMS_BASE, (LPCTSTR)strTargetNodeName);
    ASSERT(fSucceeded);


    CStr strTargetNodeParentName;
    strTargetNodeParentName.LoadString(GetStringModule(), IDS_TargetNodeParentName);
    fSucceeded = menu.AppendMenu(MF_STRING, TARGETNODE_ITEMS_BASE + 1, (LPCTSTR)strTargetNodeParentName);
    ASSERT(fSucceeded);

    fSucceeded = menu.AppendMenu(MF_SEPARATOR, 0);
    ASSERT(fSucceeded);
}

void
CCommandLineArgumentsMenu::AddMenuItemsForListView(CMenu &menu)
{
    ASSERT(m_hWndListCtrl);

    WTL::CHeaderCtrl  headerCtrl(ListView_GetHeader(m_hWndListCtrl));
    int cItems = headerCtrl.GetItemCount();
    for (int i=0; i<cItems; i++)
    {
        HDITEM hdItem;
        const int cchMaxHeader = 200;

        TCHAR szBuffer[cchMaxHeader];
        ZeroMemory(&hdItem, sizeof(hdItem));

        hdItem.mask         = HDI_TEXT;
        hdItem.pszText      = szBuffer;
        hdItem.cchTextMax   = cchMaxHeader;

        if(headerCtrl.GetItem(i, &hdItem))
        {
            bool fSucceeded = menu.AppendMenu(MF_STRING, LISTVIEW_ITEMS_BASE + i, szBuffer);
            ASSERT(fSucceeded);
        }
    }
}

bool
CCommandLineArgumentsMenu::Popup()
{
    CMenu menu;

    HWND hWndBrowseButton = ::GetDlgItem(m_hWndParent, m_nIDButton);
    RECT rectBrowse;
    ::GetWindowRect(hWndBrowseButton, &rectBrowse);

    int x = rectBrowse.left + 18;
    int y = rectBrowse.top;

    // add all the items
    AddMenuItemsForTargetNode(menu);
    AddMenuItemsForListView(menu);


    int iResp = menu.TrackPopupMenuEx(
        TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTBUTTON,
        x, y, m_hWndParent);

    if(iResp >= TARGETNODE_ITEMS_BASE && iResp <  LISTVIEW_ITEMS_BASE)
    {
        TCHAR szBuffer[10];
        _itot(iResp-TARGETNODE_ITEMS_BASE, szBuffer, 10);
        m_strResult.Format(TEXT("$NAME<%s>"), szBuffer);
    }
    else    // is a list view menu item. The return value is of the form $COL<number>
    {
        TCHAR szBuffer[10];
        _itot(iResp-LISTVIEW_ITEMS_BASE, szBuffer, 10);
        m_strResult.Format(TEXT("$COL<%s>"), szBuffer);
    }

    return (iResp != 0);

}


//############################################################################
//############################################################################
//
//  Implementation of class CTasksListDialog
//
//############################################################################
//############################################################################


/* CTasksListDialog<T>::CTasksListDialog
 *
 * PURPOSE:     Constructor
 *
 * PARAMETERS:  None
 */
template <class T>
CTasksListDialog<T>::CTasksListDialog(CTaskpadFrame* pTaskpadFrame, bool bNewTaskOnInit, bool bDisplayProperties) :
    BC(),
    m_bNewTaskOnInit(bNewTaskOnInit),
    m_pTaskpadFrame(pTaskpadFrame),
    m_bDisplayProperties(bDisplayProperties)
{
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnInitDialog
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      INT      uMsg:
 *      WPARAM   wParam:
 *      LPARAM   lParam:
 *      BOOL&    bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_buttonNewTask.Attach(::GetDlgItem(    m_hWnd, IDC_NEW_TASK_BT));
    m_buttonRemoveTask.Attach(::GetDlgItem( m_hWnd, IDC_REMOVE_TASK));
    m_buttonModifyTask.Attach(::GetDlgItem( m_hWnd, IDC_MODIFY));
    m_buttonMoveUp.Attach(::GetDlgItem(     m_hWnd, IDC_MOVE_UP));
    m_buttonMoveDown.Attach(::GetDlgItem(   m_hWnd, IDC_MOVE_DOWN));
    m_listboxTasks.Attach(::GetDlgItem(     m_hWnd, IDC_LIST_TASKS));
    m_listboxTasks.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    // set up the image list
    WTL::CImageList  imageList; // the destructor will not call a destroy. This is by design - the listbox will do the destroy.
    imageList.Create (16, 16, ILC_COLOR , 4 /*the minimum number of images*/, 10);
    m_listboxTasks.SetImageList((HIMAGELIST) imageList, LVSIL_SMALL);

    // insert the list columns
    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    CStr temp;
    temp.LoadString(GetStringModule(), IDS_COLUMN_TASK);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = 100;
    lvc.iSubItem = 0;

    int iCol = m_listboxTasks.InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    temp.LoadString(GetStringModule(), IDS_COLUMN_TOOLTIP);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = 140;
    lvc.iSubItem = 1;

    iCol = m_listboxTasks.InsertColumn(1, &lvc);
    ASSERT(iCol == 1);

    // insert all the items
    UpdateTaskListbox(PConsoleTaskpad()->BeginTask());

    if(FNewTaskOnInit())    // simulate the "New Task" button being clicked.
    {
        m_buttonNewTask.PostMessage (BM_CLICK);
    }

    return 0;
}

template <class T>
LRESULT
CTasksListDialog<T>::OnCustomDraw(    int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMLVCUSTOMDRAW * pnmlv = (NMLVCUSTOMDRAW *) pnmh;   // the custom draw structure
    NMCUSTOMDRAW   & nmcd = pnmlv->nmcd;
    int              nItem = nmcd.dwItemSpec;
    switch(nmcd.dwDrawStage & ~CDDS_SUBITEM)
    {
    case CDDS_PREPAINT:         // the initial notification
        return CDRF_NOTIFYITEMDRAW;    // we want to know about each item's paint.

    case CDDS_ITEMPREPAINT:
        return DrawItem(&nmcd);

    default:
        return 0;
    }
}

template <class T>
LRESULT
CTasksListDialog<T>::DrawItem(NMCUSTOMDRAW *pnmcd)
{
    NMLVCUSTOMDRAW *  pnmlv = (NMLVCUSTOMDRAW *) pnmcd;
    HDC &hdc        = pnmcd->hdc;
    int  nItem      = pnmcd->dwItemSpec;

    TaskIter  itTask = PConsoleTaskpad()->BeginTask();
    std::advance (itTask, nItem);

    bool bWindowHasFocus = (GetFocus() == (HWND) m_listboxTasks);
    bool bFocused        = pnmcd->uItemState & CDIS_FOCUS;
    bool bHot            = pnmcd->uItemState & CDIS_HOT;
    bool bShowSelAlways  = m_listboxTasks.GetStyle() & LVS_SHOWSELALWAYS;

    /*
     * NOTE:  There's a bug in the list view control that will
     * set CDIS_SELECTED for *all* items (not just selected items)
     * if LVS_SHOWSELALWAYS is specified.  Interrogate the item
     * directly to get the right setting.
     */
//  bool bSelected       = pnmcd->uItemState & CDIS_SELECTED;
    bool bSelected       = m_listboxTasks.GetItemState (nItem, LVIS_SELECTED);

#if DBG
    // bFocused should always be false if the window doesn't have the focus
    if (!bWindowHasFocus)
        ASSERT (!bFocused);
#endif

    RECT rectBounds;
    m_listboxTasks.GetItemRect (nItem, &rectBounds, LVIR_BOUNDS);

    // figure out colors
    int nTextColor, nBackColor;

    if (bSelected && bWindowHasFocus)
    {
        nTextColor = COLOR_HIGHLIGHTTEXT;
        nBackColor = COLOR_HIGHLIGHT;
    }
    else if (bSelected && bShowSelAlways)
    {
        nTextColor = COLOR_BTNTEXT;
        nBackColor = COLOR_BTNFACE;
    }
    else
    {
        nTextColor = COLOR_WINDOWTEXT;
        nBackColor = COLOR_WINDOW;
    }

    // empty (or fill) the region
    FillRect (hdc, &rectBounds, ::GetSysColorBrush (nBackColor));

    // draw the text.
    COLORREF nTextColorOld = SetTextColor (hdc, ::GetSysColor (nTextColor));
    COLORREF nBackColorOld = SetBkColor   (hdc, ::GetSysColor (nBackColor));


    RECT rectIcon;
    m_listboxTasks.GetItemRect(nItem, &rectIcon, LVIR_ICON);

	/*
	 * Preserve icon shape when BitBlitting it to a
	 * mirrored DC.
	 */
	DWORD dwLayout=0L;
	if ((dwLayout=GetLayout(hdc)) & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
	}

    itTask->Draw(hdc, &rectIcon, true /*bSmall*/);

	/*
	 * Restore the DC to its previous layout state.
	 */
	if (dwLayout & LAYOUT_RTL)
	{
		SetLayout(hdc, dwLayout);
	}

    RECT rectLabel;
    UINT uFormat = DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_WORD_ELLIPSIS;
    m_listboxTasks.GetItemRect(nItem,&rectLabel, LVIR_LABEL); // get the label rectangle
    DrawText(hdc, itTask->GetName().data(),-1,&rectLabel, uFormat);

    RECT rectDescr;
    m_listboxTasks.GetSubItemRect(nItem, 1 /*descr column*/, LVIR_LABEL, &rectDescr);
    DrawText(hdc, itTask->GetDescription().data(),-1,&rectDescr, uFormat);

    SetTextColor(hdc, nTextColorOld);
    SetBkColor  (hdc, nBackColorOld);

    if (bFocused)
        ::DrawFocusRect(hdc, &rectBounds);

    return CDRF_SKIPDEFAULT;      // we've drawn the whole item ourselves
}


template <class T>
void
CTasksListDialog<T>::OnTaskProperties()
{
    if(!m_bDisplayProperties)   // don't display any properties if not needed.
        return;

    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)     // defensive
        return;

    TaskIter  itTask =  MapTaskIterators()[iSelected];

    CTaskPropertySheet dlg(NULL, PTaskpadFrame(), *itTask, false);

    if (dlg.DoModal() == IDOK)
    {
        *itTask = dlg.ConsoleTask();
        UpdateTaskListbox (itTask);
    }
}

template <class T>
int
CTasksListDialog<T>::GetCurSel()
{
    int i = (int)PListBoxTasks()->SendMessage(LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_ALL | LVNI_FOCUSED, 0));
    return (i==-1) ? LB_ERR : i;
}

/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnTaskChanged
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnTaskChanged(   int id, LPNMHDR pnmh, BOOL& bHandled )
{
    NMLISTVIEW *pnlv = (LPNMLISTVIEW) pnmh;
    EnableButtons();
    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnNewTask
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnNewTask()
{
    bool        fRestartTaskWizard = true;

    while(fRestartTaskWizard)
    {
         CTaskWizard taskWizard;

         if (taskWizard.Show(m_hWnd, PTaskpadFrame(), true, &fRestartTaskWizard)==S_OK)
        {
            CConsoleTaskpad::TaskIter   itTask;
            CConsoleTaskpad *           pTaskpad = PConsoleTaskpad();

            // get the iterator of the selected task. The new task will be inserted just after this.
            int iSelected = GetCurSel();


            if (iSelected == LB_ERR)
                itTask = pTaskpad->BeginTask();
            else
            {
                /*
                 * InsertTask inserts before the given iterator.  We need to
                 * bump itTask so it gets inserted after the selected task.
                 */
                itTask = MapTaskIterators()[iSelected];
                ASSERT (itTask != pTaskpad->EndTask());
                ++itTask;
            }

            UpdateTaskListbox (pTaskpad->InsertTask (itTask, taskWizard.ConsoleTask()));
        }
        else
            break;
    }

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnRemoveTask
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnRemoveTask( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
        return 0;

    // get the current task
    TaskIter        taskIterator    = MapTaskIterators()[iSelected];
    UpdateTaskListbox(PConsoleTaskpad()->EraseTask(taskIterator));
    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnMoveUp
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnMoveUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
        return 0;

    // get the current task
    TaskIter        itTask    = MapTaskIterators()[iSelected];

    // defensive coding
    if(itTask==PConsoleTaskpad()->BeginTask())
        return 0;

    // point to the previous task
    TaskIter        itPreviousTask = itTask;
    --itPreviousTask;

    // swap the tasks
    std::iter_swap (itTask, itPreviousTask);

    UpdateTaskListbox(itPreviousTask);

    return 0;
}

/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::OnMoveDown
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      ORD     wNotifyCode:
 *      WORD    wID:
 *      HWND    hWndCtl:
 *      BOOL&   bHandled:
 *
 * RETURNS:
 *      LRESULT
/*+-------------------------------------------------------------------------*/
template <class T>
LRESULT
CTasksListDialog<T>::OnMoveDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
        return 0;

    // get the current task
    TaskIter        itTask    = MapTaskIterators()[iSelected];
    ASSERT (itTask != PConsoleTaskpad()->EndTask());

    // point to the next task
    TaskIter        itNextTask = itTask;
    ++itNextTask;

    // defensive coding
    if(itNextTask==PConsoleTaskpad()->EndTask())
        return 0;

    // swap the tasks
    std::iter_swap (itTask, itNextTask);

    UpdateTaskListbox(itNextTask);
    return 0;
}



/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::UpdateTaskListbox
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      TaskIter   itSelectedTask:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
template <class T>
void
CTasksListDialog<T>::UpdateTaskListbox(TaskIter itSelectedTask)
{
    USES_CONVERSION;
    TaskIter itTask;
    int      iSelect = 0;
    int      iInsert = 0;

    // clear the listbox and the iterator map
    PListBoxTasks()->DeleteAllItems();
    MapTaskIterators().clear();

    for (iInsert = 0, itTask  = PConsoleTaskpad()->BeginTask();
         itTask != PConsoleTaskpad()->EndTask();
         ++itTask, ++iInsert)
    {
        LV_ITEM LVItem;
        LVItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        LVItem.iItem = iInsert;
        LVItem.iImage = 0;
        LVItem.iSubItem = 0;
        LVItem.pszText = const_cast<TCHAR *>(itTask->GetName().data());

        int i = PListBoxTasks()->InsertItem(&LVItem);
        ASSERT(i==iInsert);

        // LV_Item for setting tooltim column
        LV_ITEM LVItem2;
        LVItem2.iItem = iInsert;
        LVItem2.mask = LVIF_TEXT;
        LVItem2.iSubItem = 1;
        LVItem2.pszText = const_cast<TCHAR *>(itTask->GetDescription().data());

        BOOL bStat = PListBoxTasks()->SetItem(&LVItem2);
        ASSERT(bStat);


        MapTaskIterators()[i] = itTask;

        if(itTask == itSelectedTask)
            iSelect = i;
    }

    PListBoxTasks()->SetItemState(iSelect, LVIS_FOCUSED| LVIS_SELECTED , LVIS_FOCUSED| LVIS_SELECTED );
    PListBoxTasks()->EnsureVisible(iSelect, false /*fPartialOK*/);
    EnableButtons();
}

/*+-------------------------------------------------------------------------*
 * CTasksListDialog<T>::EnableButtons
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
template <class T>
void
CTasksListDialog<T>::EnableButtons()
{
    bool    bEnableDelete   = true;
    bool    bEnableMoveUp   = true;
    bool    bEnableMoveDown = true;
    bool    bEnableModify   = true;

    int iSelected = GetCurSel();
    if(iSelected == LB_ERR)
    {
        bEnableDelete   = false;
        bEnableMoveUp   = false;
        bEnableMoveDown = false;
        bEnableModify   = false;
    }
    else
    {
        TaskIter taskIterator       = MapTaskIterators()[iSelected];
        TaskIter taskIteratorNext   = taskIterator;
        taskIteratorNext++;

        if(taskIterator==PConsoleTaskpad()->BeginTask())
            bEnableMoveUp = false;
        if(taskIteratorNext==PConsoleTaskpad()->EndTask())
            bEnableMoveDown = false;
    }

    EnableButtonAndCorrectFocus( m_buttonRemoveTask, bEnableDelete );
    EnableButtonAndCorrectFocus( m_buttonModifyTask, bEnableModify );
    EnableButtonAndCorrectFocus( m_buttonMoveUp,     bEnableMoveUp );
    EnableButtonAndCorrectFocus( m_buttonMoveDown,   bEnableMoveDown );
}

/***************************************************************************\
 *
 * METHOD:  CTasksListDialog<T>::EnableButtonAndCorrectFocus
 *
 * PURPOSE: Enables/disables button. Moves focus to OK, if it's on the button
 *          being disabled
 *
 * PARAMETERS:
 *    WTL::CButton& button
 *    BOOL bEnable
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
template <class T>
void CTasksListDialog<T>::EnableButtonAndCorrectFocus( WTL::CButton& button, BOOL bEnable )
{
    // if the focus belongs to the window being disabled,
    // set it to the OK button
    if ( ( !bEnable ) && ( ::GetFocus() == button ) )
    {
        // need to do some funny stuff here. see KB article Q67655 for details

        // Reset the current default push button to a regular button.
        button.SendMessage( BM_SETSTYLE, BS_PUSHBUTTON, (LONG)TRUE );

        // set focus to IDOK
        ::SetFocus( ::GetDlgItem( GetParent(), IDOK ) );
        // inform dialog about the new default button
        ::SendMessage( GetParent(), DM_SETDEFID, IDOK, 0 );
    }

    button.EnableWindow( bEnable );
}

//############################################################################
//############################################################################
//
//  Implementation of class CContextMenuVisitor
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CContextMenuVisitor::ScTraverseContextMenu
 *
 * PURPOSE:  Creates and traverses the context menu tree for the selected item,
 *           whether scope or result.
 *
 * PARAMETERS:
 *      Node *           pNodeTarget:   The scope item whose menu is traversed (or NULL)
 *      CScopeTree *     pCScopeTree:   Points to a CScopeTree
 *      BOOL             fScopeItem:    TRUE if the selected item is a result item, else FALSE.
 *      CNode *          pNodeScope:    The scope item which has the focus.
 *      LPARAM           resultItemParam: The result item whose menu is traversed (or NULL)
 *
 * RETURNS:
 *      SC
/*+-------------------------------------------------------------------------*/
SC
CContextMenuVisitor::ScTraverseContextMenu(CNode *pNodeTarget, CScopeTree *pCScopeTree,
                       BOOL fScopeItem, CNode *pNodeScope, LPARAM resultItemParam, bool bShowSaveList)
{
    DECLARE_SC(sc, TEXT("CContextMenuVisitor::ScTraverseContextMenu"));

    sc = ScCheckPointers(pNodeTarget);
    if(sc)
        return sc;

    // set the context info structure.
    // include flag to force Open verb on scope item menus, so that an open task
    // will always be available and enabled.

    CContextMenuInfo contextInfo;

    contextInfo.Initialize();
    contextInfo.m_dwFlags = CMINFO_USE_TEMP_VERB | CMINFO_SHOW_SCOPEITEM_OPEN;

    // Validate parameters
    if(fScopeItem)
    {
        sc = ScCheckPointers(pNodeScope);
        if(sc)
            return sc;

        // show the view menu items only for the selected scope node
        // NOTE: cannot compare the pNode's directly - they are from different views.
        // must compare the MTNodes.
        if(pNodeTarget->GetMTNode()==pNodeScope->GetMTNode())
            contextInfo.m_dwFlags |= CMINFO_SHOW_VIEW_ITEMS;


        resultItemParam = 0;    // we don't need this
    }
    else
    {
        // Virtual list can have lparam of 0
        // (this condition must have braces as long as the assert is the
        // only conditional statement, to avoid C4390: empty controlled statement)
        if (!(pNodeTarget && pNodeTarget->GetViewData()->IsVirtualList()) &&
            !IS_SPECIAL_LVDATA (resultItemParam))
        {
            ASSERT(resultItemParam);
            CResultItem* pri = CResultItem::FromHandle(resultItemParam);

            if((pri != NULL) && pri->IsScopeItem())    // scope items in the result pane.
            {
                fScopeItem = true;
                pNodeTarget = CNode::FromResultItem (pri);
                resultItemParam = 0;
                contextInfo.m_dwFlags |= CMINFO_SCOPEITEM_IN_RES_PANE;
            }
        }

        pNodeScope = NULL;      // we don't need this.
    }

    CNodeCallback* pNodeCallback   =
        dynamic_cast<CNodeCallback *>(pNodeTarget->GetViewData()->GetNodeCallback());

    contextInfo.m_eContextMenuType      = MMC_CONTEXT_MENU_DEFAULT;
    contextInfo.m_eDataObjectType       = fScopeItem ? CCT_SCOPE: CCT_RESULT;
    contextInfo.m_bBackground           = FALSE;
    contextInfo.m_hSelectedScopeNode    = CNode::ToHandle(pNodeScope);
    contextInfo.m_resultItemParam       = resultItemParam;
    contextInfo.m_bMultiSelect          = (resultItemParam == LVDATA_MULTISELECT);
    contextInfo.m_bScopeAllowed         = fScopeItem;

    if (bShowSaveList)
        contextInfo.m_dwFlags           |= CMINFO_SHOW_SAVE_LIST;

    contextInfo.m_hWnd                  = pNodeTarget->GetViewData()->GetView();
    contextInfo.m_pConsoleView          = pNodeTarget->GetViewData()->GetConsoleView();

    // Create a CContextMenu and initialize it.
    CContextMenu * pContextMenu = NULL;
    ContextMenuPtr spContextMenu;

    sc = CContextMenu::ScCreateInstance(&spContextMenu, &pContextMenu);
    if(sc)
        return sc;

    sc = ScCheckPointers(pContextMenu, spContextMenu.GetInterfacePtr(), E_UNEXPECTED);
    if(sc)
        return sc;

    pContextMenu->ScInitialize(pNodeTarget, pNodeCallback, pCScopeTree, contextInfo);
    if(sc)
        return sc;

    // build and traverse the context menu.
    sc = pContextMenu->ScBuildContextMenu();
    if(sc)
        return sc;

    sc = ScTraverseContextMenu(pContextMenu);
    if(sc)
        return sc;

    // the context menu is freed in the destructor of the smart pointer, so we need to set the pointer to NULL.
    pContextMenu = NULL;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenuVisitor::ScTraverseContextMenu
 *
 * PURPOSE: Iterates thru the context menu.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenuVisitor::ScTraverseContextMenu(CContextMenu *pContextMenu)
{
    DECLARE_SC(sc, TEXT("CContextMenuVisitor::ScTraverseContextMenu"));

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc;

    CMenuItem *pMenuItem = NULL;
    int iIndex = 0;

    do
    {
        sc = pContextMenu->ScGetItem(iIndex++, &pMenuItem);
        if(sc)
            return sc;

        if(!pMenuItem)
            return sc; // all done.

        bool bVisitItem = false;
        sc = ScShouldItemBeVisited(pMenuItem, pContextMenu->PContextInfo(), bVisitItem);
        if(sc)
            return sc;

        if(bVisitItem)
        {
            // Call the vistor on this item.
            SC sc = ScOnVisitContextMenu(*pMenuItem);
            if(sc == SC(S_FALSE)) // S_FALSE is the code to not continue traversal.
            {
                return sc;
            }
        }

    } while(pMenuItem != NULL);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenuVisitor::ScShouldItemBeVisited
 *
 * PURPOSE: Filters items in the traversed tree of menu items to determine whether
 *          the ScOnVisitContextMenu callback should be called.
 *
 * PARAMETERS:
 *    CMenuItem * pMenuItem : The menu item to filter
 *
 *    bool &bVisitItem: [out]: Whether ScOnVisitContextMenu should be called.
 *
 * RETURNS:
 *    bool: true if ScOnVisitContextMenu should be called on this item.
 *
 *+-------------------------------------------------------------------------*/
SC
CContextMenuVisitor::ScShouldItemBeVisited(CMenuItem *pMenuItem, CContextMenuInfo *pContextInfo, /*out*/ bool &bVisitItem)
{
    DECLARE_SC(sc, TEXT("CContextMenuInfo::FVisitItem"));

    sc = ScCheckPointers(pMenuItem, pContextInfo);
    if(sc)
        return sc;

    bVisitItem = false;

    if(pMenuItem->IsSpecialSeparator() || pMenuItem->IsSpecialInsertionPoint()
            || (pMenuItem->GetMenuItemFlags() & MF_SEPARATOR))
    {
        bVisitItem = false;    // don't call ScOnVisitContextMenu for this item
        return sc;
    }
    else if(IsSystemOwnerID(pMenuItem->GetMenuItemOwner()))  // inserted by the MMC
    {
        long nCommandID = pMenuItem->GetCommandID();

        // filter out unneeded verbs
        // also check for scope items in the result pane - these are treated as result items.
        if( (pContextInfo->m_eDataObjectType == CCT_SCOPE)
           && (!(pContextInfo->m_dwFlags & CMINFO_SCOPEITEM_IN_RES_PANE)) )
        {
            // scope menu item
            switch(nCommandID)
            {
            case MID_RENAME:
            case MID_DELETE:
            case MID_COPY:
            case MID_CUT:
            case MID_NEW_TASKPAD_FROM_HERE: // New taskpad from here
                bVisitItem =  false;
                return sc;
                break;
            default:
                bVisitItem = true;
                return sc;
                break;
            }
        }
        else
        {
            if(pContextInfo->m_bMultiSelect)  // result item, multi select
            {
                switch(nCommandID)
                {
                case MID_RENAME:
                case MID_PASTE:
                case MID_REFRESH:
                case MID_OPEN:
                    bVisitItem = false;
                    return sc;
                    break;
                default:
                    bVisitItem = true;
                    return sc;
                    break;
                }
            }
            else                              // result item, single select
            {
                switch(nCommandID)
                {
                case MID_OPEN:
                    bVisitItem = false;
                    return sc;
                    break;
                default:
                    bVisitItem = true;
                    return sc;
                    break;
                }

            }
        }
    }
    else
    {
        bVisitItem = true;
        return sc;
    }
}

//############################################################################
//############################################################################
//
//  Implementation of class CBrowserCookieList
//
//############################################################################
//############################################################################
CBrowserCookieList::~CBrowserCookieList()
{
    iterator iter;

    for (iter = begin(); iter != end(); iter++)
    {
        iter->DeleteNode();
    }
}



//############################################################################
//############################################################################
//
//  Implementation of class CMTBrowserCtrl
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::CMTBrowserCtrl
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      WND           hWnd:
 *      CScopeTree *  pScopeTree:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/

CMTBrowserCtrl::CMTBrowserCtrl() :
    m_pScopeTree(NULL)
{
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::~CMTBrowserCtrl
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
/*+-------------------------------------------------------------------------*/
CMTBrowserCtrl::~CMTBrowserCtrl()
{
    CBrowserCookieList::iterator iter;
    for (iter = PBrowserCookieList()->begin(); iter != PBrowserCookieList()->end(); iter++)
        iter->DeleteNode();
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::Initialize
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/

void
CMTBrowserCtrl::Initialize(const InitData& init)
{
    ASSERT (::IsWindow (init.hwnd));
    ASSERT (init.pScopeTree != NULL);

    SubclassWindow (init.hwnd);
    m_pScopeTree = init.pScopeTree;

    /*
     * Copy the list of nodes to exclude.  This list is likely to be very
     * small.  If we find that it can be large, we may want to sort it
     * so that we can later do a binary search instead of a linear search.
     */
    m_vpmtnExclude = init.vpmtnExclude;
#if OptimizeExcludeList
    std::sort (m_vpmtnExclude.begin(), m_vpmtnExclude.end());
#endif

    /*
     * set the image list of the tree view control
     */
    HIMAGELIST hImageList = m_pScopeTree->GetImageList ();
    SetImageList (hImageList, TVSIL_NORMAL);

    /*
     * if no root was provided, default to the console root
     */
    CMTNode* pmtnRoot = init.pmtnRoot;

    if (pmtnRoot == NULL)
        pmtnRoot = m_pScopeTree->GetRoot();

    ASSERT (pmtnRoot != NULL);

    /*
     * add the root item
     */
    CBrowserCookie browserCookie (pmtnRoot, NULL);
    HTREEITEM htiRoot = InsertItem (browserCookie, TVI_ROOT, TVI_FIRST);

    /*
     * if no selection node was provided, default to the root
     */
    CMTNode* pmtnSelect = init.pmtnSelect;

    if (pmtnSelect == NULL)
        pmtnSelect = pmtnRoot;

    ASSERT (pmtnSelect != NULL);

    /*
     * select the specified node
     */
    SelectNode (pmtnSelect);

    /*
     * insure that the root item is expanded
     */
    Expand (htiRoot, TVE_EXPAND);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::InsertItem
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      MTNode *    pMTNode:
 *      HTREEITEM   hParent:
 *      HTREEITEM   hInsertAfter:
 *
 * RETURNS:
 *      HTREEITEM
/*+-------------------------------------------------------------------------*/
HTREEITEM
CMTBrowserCtrl::InsertItem(
    const CBrowserCookie&   browserCookie,
    HTREEITEM               hParent,
    HTREEITEM               hInsertAfter)
{
    /*
     * don't insert the item if it is in the exclude list
     */
    if (IsMTNodeExcluded (browserCookie.PMTNode()))
        return (NULL);

    UINT nMask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;
    PBrowserCookieList()->push_back(browserCookie);
    CBrowserCookie *pBrowserCookie = & (PBrowserCookieList()->back());
    CMTNode *       pMTNode        = pBrowserCookie->PMTNode();

	tstring strName = pMTNode->GetDisplayName();

    TV_INSERTSTRUCT tvis;
    tvis.hParent                = hParent;
    tvis.hInsertAfter           = hInsertAfter;
    tvis.item.mask              = nMask;
    tvis.item.pszText           = const_cast<LPTSTR>(strName.data());
    tvis.item.iImage            = pMTNode->GetImage();
    tvis.item.iSelectedImage    = pMTNode->GetOpenImage();
    tvis.item.state             = 0;
    tvis.item.stateMask         = 0;
    tvis.item.lParam            = reinterpret_cast<LPARAM>(pBrowserCookie);
    tvis.item.cChildren         = 1;
    return BC::InsertItem(&tvis);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::IsMTNodeExcluded
 *
 * Returns true if the given MTNode is in the exclude list.
 *--------------------------------------------------------------------------*/

bool CMTBrowserCtrl::IsMTNodeExcluded (CMTNode* pmtn) const
{
    CMTNodeCollection::const_iterator itEnd = m_vpmtnExclude.end();

    CMTNodeCollection::const_iterator itFound =
#if OptimizeExcludeList
            std::lower_bound (m_vpmtnExclude.begin(), itEnd, pmtn);
#else
            std::find        (m_vpmtnExclude.begin(), itEnd, pmtn);
#endif

    return (itFound != itEnd);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::OnItemExpanding
 *
 * Reflected TVN_ITEMEXPANDING handler for CMTBrowserCtrl.  The class that
 * uses a CMTBrowserCtrl must have REFLECT_NOTIFICATIONS as the last entry
 * in its message map.
 *--------------------------------------------------------------------------*/

LRESULT CMTBrowserCtrl::OnItemExpanding (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    /*
     * this should only handle messages that originated from itself
     */
    ASSERT (pnmh->hwndFrom == m_hWnd);

    /*
     * insert the children for this node, if we're expanding
     */
    LPNMTREEVIEW pnmtv = (LPNMTREEVIEW) pnmh;

    if (pnmtv->action == TVE_EXPAND)
        ExpandItem (pnmtv->itemNew);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::ExpandItem
 *
 *
 *--------------------------------------------------------------------------*/

#define TVIF_REQUIRED   (TVIF_PARAM | TVIF_HANDLE | TVIF_STATE)

bool CMTBrowserCtrl::ExpandItem (const TV_ITEM& itemExpand)
{
    /*
     * make sure all of the fields we require can be trusted
     */
    ASSERT ((itemExpand.mask & TVIF_REQUIRED) == TVIF_REQUIRED);

    /*
     * if we've already added children, bail
     */
    if (itemExpand.state & TVIS_EXPANDEDONCE)
        return (true);


    CMTNode *pmtnParent = MTNodeFromItem (&itemExpand);
    ASSERT (pmtnParent != NULL);

    /*
     * make sure the master tree node has been expanded
     */
    if (!pmtnParent->WasExpandedAtLeastOnce() && FAILED (pmtnParent->Expand()))
        return (false);

    /*
     * insert tree nodes for all (non-excluded) children of this MTNode
     */
    HTREEITEM   hParent      = itemExpand.hItem;
    bool        bHasChildren = false;

    for (CMTNode* pmtn = pmtnParent->GetChild(); pmtn; pmtn = pmtn->GetNext())
    {
        if (InsertItem (CBrowserCookie(pmtn, NULL), hParent, TVI_LAST))
            bHasChildren = true;
    }

    /*
     * if the parent has no children - set its
     * cChildren to zero to get rid of the "+"
     */
    if (!bHasChildren)
    {
        TV_ITEM item;
        item.mask      = TVIF_HANDLE | TVIF_CHILDREN;
        item.hItem     = hParent;
        item.cChildren = 0;

        SetItem(&item);
    }

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CBrowserCookie::DeleteNode
 *
 *
 *--------------------------------------------------------------------------*/

void CBrowserCookie::DeleteNode()
{
    delete m_pNode;
    m_pMTNode = NULL;
    m_pNode = NULL;
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::FindMTNode
 *
 *
 *--------------------------------------------------------------------------*/

bool CMTBrowserCtrl::SelectNode (CMTNode* pmtnSelect)
{
    HTREEITEM   htiRoot  = GetRootItem();
    CMTNode*    pmtnRoot = MTNodeFromItem (htiRoot);
    CMTNodeCollection vNodes;

    /*
     * walk up the tree to find the root
     */
    while (pmtnSelect != NULL)
    {
        vNodes.push_back (pmtnSelect);

        if (pmtnSelect == pmtnRoot)
            break;

        pmtnSelect = pmtnSelect->Parent();
    }

    /*
     * if we didn't find the root, fail
     */
    if (pmtnSelect == NULL)
        return (false);

    ASSERT (!vNodes.empty());
    ASSERT (vNodes.back() == pmtnRoot);
    HTREEITEM htiSelect = htiRoot;
    HTREEITEM htiWatch;

    /*
     * expand the tree to the node we want to select
     */
    for (int i = vNodes.size()-1; (i > 0) && (htiSelect != NULL); i--)
    {
        if (!Expand (htiSelect, TVE_EXPAND))
            break;

        htiSelect = FindChildItemByMTNode (htiSelect, vNodes[i-1]);
    }

    /*
     * select the node
     */
    SelectItem (htiSelect);
    return (true);
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::GetSelectedMTNode
 *
 * Returns the MTNode corresponding to the selected node in the tree
 *--------------------------------------------------------------------------*/

CMTNode* CMTBrowserCtrl::GetSelectedMTNode () const
{
    CMTBrowserCtrl* pMutableThis = const_cast<CMTBrowserCtrl*>(this);
    return (MTNodeFromItem (pMutableThis->GetSelectedItem ()));
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::CookieFromItem
 *
 *
 *--------------------------------------------------------------------------*/

CBrowserCookie* CMTBrowserCtrl::CookieFromItem (HTREEITEM hti) const
{
    return (CookieFromLParam (GetItemData (hti)));
}

CBrowserCookie* CMTBrowserCtrl::CookieFromItem (const TV_ITEM* ptvi) const
{
    return (CookieFromLParam (ptvi->lParam));
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::CookieFromLParam
 *
 *
 *--------------------------------------------------------------------------*/

CBrowserCookie* CMTBrowserCtrl::CookieFromLParam (LPARAM lParam) const
{
    return (reinterpret_cast<CBrowserCookie *>(lParam));
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::MTNodeFromItem
 *
 *
 *--------------------------------------------------------------------------*/

CMTNode* CMTBrowserCtrl::MTNodeFromItem (HTREEITEM hti) const
{
    return (CookieFromItem(hti)->PMTNode());
}

CMTNode* CMTBrowserCtrl::MTNodeFromItem (const TV_ITEM* ptvi) const
{
    return (CookieFromItem(ptvi)->PMTNode());
}


/*+-------------------------------------------------------------------------*
 * CMTBrowserCtrl::FindChildItemByMTNode
 *
 * Returns the HTREEITEM for the child node of htiParent which refers
 * to pmtnToFind, NULL if no match.
 *--------------------------------------------------------------------------*/

HTREEITEM CMTBrowserCtrl::FindChildItemByMTNode (
    HTREEITEM       htiParent,
    const CMTNode*  pmtnToFind)
{
    HTREEITEM htiChild;

    for (htiChild  = GetChildItem (htiParent);
         htiChild != NULL;
         htiChild  = GetNextSiblingItem (htiChild))
    {
        if (MTNodeFromItem (htiChild) == pmtnToFind)
            break;
    }

    return (htiChild);
}


//############################################################################
//############################################################################
//
//  Implementation of class CMirrorListView
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * HackDuplicate
 *
 * HACK: This is here for theming support.  himlSource comes from the conui
 * list control, which uses comctlv5 imagelists.  A v6 list control cannot
 * use v5 imagelists (images aren't drawn correctly), so we need to create
 * a v6 imagelist for the v6 list control to use.
 *
 * ImageList_Duplicate would do the job for us, but it is not compatible
 * with v5 imagelists.  We'll write to and read from a v5-compatible stream
 * to duplicate it instead.
 *--------------------------------------------------------------------------*/
HIMAGELIST HackDuplicate (HIMAGELIST himlSource)
{
	DECLARE_SC (sc, _T("HackDuplicate"));
	HIMAGELIST himlDuplicate;

	/*
	 * create a temporary stream for conversion
	 */
	IStreamPtr spStream;
	sc = CreateStreamOnHGlobal (NULL /*alloc for me*/, true /*fDeleteOnRelease*/, &spStream);
	if (sc)
		return (NULL);

	/*
	 * write the source imagelist to the stream in a v5-compatible format
	 */
	sc = WriteCompatibleImageList (himlSource, spStream);
	if (sc)
		return (NULL);

	/*
	 * rewind the stream
	 */
	LARGE_INTEGER origin = { 0, 0 };
	sc = spStream->Seek (origin, STREAM_SEEK_SET, NULL);
	if (sc)
		return (NULL);

	/*
	 * reconstitute the imagelist
	 */
	sc = ReadCompatibleImageList (spStream, himlDuplicate);
	if (sc)
		return (NULL);

	return (himlDuplicate);
}

CMirrorListView::CMirrorListView ()
    :   m_fVirtualSource (false)
{
}

void CMirrorListView::AttachSource (HWND hwndList, HWND hwndSourceList)
{
#ifdef DBG
    /*
     * the window we're attaching to should be a list view
     */
    TCHAR szClassName[countof (WC_LISTVIEW)];
    ::GetClassName (hwndSourceList, szClassName, countof (szClassName));
    ASSERT (lstrcmp (szClassName, WC_LISTVIEW) == 0);
#endif

    SubclassWindow (hwndList);

    m_wndSourceList  = hwndSourceList;
    m_fVirtualSource = (m_wndSourceList.GetStyle() & LVS_OWNERDATA) != 0;

    /*
     * Our listview will always be virtual, so we don't have to duplicate
     * the data that may already be in the source listview.  The list view
     * control doesn't allow changing the LVS_OWNERDATA style bit, so we
     * need to make sure that the control we're attaching to already has it
     */
    const DWORD dwForbiddenStyles         = LVS_SHAREIMAGELISTS;
    const DWORD dwRequiredImmutableStyles = LVS_OWNERDATA;
    const DWORD dwRequiredMutableStyles   = 0;
    const DWORD dwRequiredStyles          = dwRequiredImmutableStyles | dwRequiredMutableStyles;

    ASSERT ((dwForbiddenStyles & dwRequiredStyles) == 0);
    ASSERT ((dwRequiredImmutableStyles & dwRequiredMutableStyles) == 0);
    ASSERT ((GetStyle() & dwRequiredImmutableStyles) == dwRequiredImmutableStyles);

    DWORD dwStyle = GetStyle() | dwRequiredStyles & ~dwForbiddenStyles;
    SetWindowLong (GWL_STYLE, dwStyle);

    /*
     * copy the image lists
     */
    SetImageList (HackDuplicate(m_wndSourceList.GetImageList (LVSIL_NORMAL)), LVSIL_NORMAL);
    SetImageList (HackDuplicate(m_wndSourceList.GetImageList (LVSIL_SMALL)),  LVSIL_SMALL);
    SetImageList (HackDuplicate(m_wndSourceList.GetImageList (LVSIL_STATE)),  LVSIL_STATE);

    /*
     * insert the columns
     */
    InsertColumns ();

    /*
     * copy the items (we're virtual, so copying the items only means we
     * copy the item count)
     */
    SetItemCount (m_wndSourceList.GetItemCount());
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::InsertColumns
 *
 *
 *--------------------------------------------------------------------------*/

void CMirrorListView::InsertColumns ()
{
    WTL::CRect rect;
    GetClientRect (rect);
    int cxColumn = rect.Width() - GetSystemMetrics (SM_CXVSCROLL);

    InsertColumn (0, NULL, LVCFMT_LEFT, cxColumn, -1);
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::OnGetDispInfo
 *
 * LVN_GETDISPINFO handler for CMirrorListView.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::OnGetDispInfo (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LV_DISPINFO* plvdi = (LV_DISPINFO *) pnmh;
    return (m_wndSourceList.GetItem (&plvdi->item));
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::ForwardVirtualNotification
 *
 * Generic notification handler for CMirrorListView.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::ForwardVirtualNotification (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    /*
     * if the source list is virtual, forward the notification
     */
    if (m_fVirtualSource)
        return (ForwardNotification (idCtrl, pnmh, bHandled));

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::ForwardNotification
 *
 * Forwards list view notifications to the source list view's parent.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::ForwardNotification (int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return (::SendMessage (m_wndSourceList.GetParent(),
                           WM_NOTIFY, idCtrl, (LPARAM) pnmh));
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::ForwardMessage
 *
 * Forwards list view messages to the source list view.
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::ForwardMessage (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (m_wndSourceList.SendMessage (uMsg, wParam, lParam));
}


/*+-------------------------------------------------------------------------*
 * CMirrorListView::GetSelectedItemData
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CMirrorListView::GetSelectedItemData ()
{
    int nSelectedItem = GetSelectedIndex();

    return ((m_fVirtualSource) ? nSelectedItem : GetItemData (nSelectedItem));
}



//############################################################################
//############################################################################
//
//  Implementation of class CMyComboBox
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 * CMyComboBox::InsertStrings
 *
 *
 *--------------------------------------------------------------------------*/

void CMyComboBox::InsertStrings (const int rgStringIDs[], int cStringIDs)
{
    ASSERT (IsWindow ());
    CStr        str;

    for (int i = 0; i < cStringIDs; ++i)
    {
        /*
         * load the string and stick it in the combo
         */
        VERIFY (str.LoadString (GetStringModule(), rgStringIDs[i]));

        int nIndex = AddString (str);
        ASSERT (nIndex >= 0);

        /*
         * set the string ID as the combo item's data
         */
        SetItemData (nIndex, rgStringIDs[i]);
    }
}


/*+-------------------------------------------------------------------------*
 * CMyComboBox::GetSelectedItemData
 *
 *
 *--------------------------------------------------------------------------*/

LPARAM CMyComboBox::GetSelectedItemData () const
{
    return (GetItemData (GetCurSel ()));
}


/*+-------------------------------------------------------------------------*
 * CMyComboBox::SelectItemByData
 *
 *
 *--------------------------------------------------------------------------*/

void CMyComboBox::SelectItemByData (LPARAM lParam)
{
    int nIndex = FindItemByData(lParam);

    if (nIndex != -1)
        SetCurSel (nIndex);
}


/*+-------------------------------------------------------------------------*
 * CMyComboBox::FindItemByData
 *
 *
 *--------------------------------------------------------------------------*/

int CMyComboBox::FindItemByData (LPARAM lParam) const
{
    int cItems = GetCount ();

    for (int i = 0; i < cItems; i++)
    {
        if (GetItemData (i) == lParam)
            break;
    }

    ASSERT (i <= cItems);
    if (i >= cItems)
        i = -1;

    return (i);
}


//############################################################################
//############################################################################
//
//  Utility functions
//
//############################################################################
//############################################################################

namespace MMC
{

/*+-------------------------------------------------------------------------*
 * GetWindowText
 *
 * Returns the text for a given window in the form of a tstring
 *--------------------------------------------------------------------------*/

tstring GetWindowText (HWND hwnd)
{
    int    cchText = GetWindowTextLength (hwnd) + 1;

    if(0==cchText)
        return TEXT("");

    LPTSTR pszText = NULL;

    try
    {
        pszText = (LPTSTR) _alloca (cchText * sizeof (TCHAR));
    }
    // catch(...) is needed (and safe) here because _alloca does not document the exception class used. 
    // in addition, the only function called in the try block is _alloca, so we're not masking any othercatch(...) 
    // errors  
    catch(...)
    {
        return TEXT("");
    }               

    ::GetWindowText (hwnd, pszText, cchText);

    return (pszText);
}

}; // namespace MMC


/*+-------------------------------------------------------------------------*
 * PreventMFCAutoCenter
 *
 * MFC applications set a CBT hook which will subclass all non-MFC windows
 * with an MFC subclass proc.  That subclass proc will auto-magically center
 * dialogs on their parents.
 *
 * We can prevent this auto-centering, by slightly adjusting the position of
 * the window during WM_INITDIALOG.
 *--------------------------------------------------------------------------*/

void PreventMFCAutoCenter (MMC_ATL::CWindow* pwnd)
{
    RECT rect;

    pwnd->GetWindowRect (&rect);
    OffsetRect (&rect, 0, 1);
    pwnd->MoveWindow (&rect, false);
}


/*+-------------------------------------------------------------------------*
 * LoadSysColorBitmap
 *
 * Loads a bitmap resource and converts gray scale colors to the 3-D colors
 * of the current color scheme.
 *--------------------------------------------------------------------------*/

HBITMAP LoadSysColorBitmap (HINSTANCE hInst, UINT id, bool bMono)
{
    return ((HBITMAP) LoadImage (hInst, MAKEINTRESOURCE(id), IMAGE_BITMAP, 0, 0,
                                 LR_LOADMAP3DCOLORS));
}



//############################################################################
//############################################################################
//
//  Implementation of class CTaskPropertySheet
//
//############################################################################
//############################################################################
CTaskPropertySheet::CTaskPropertySheet(HWND hWndParent, CTaskpadFrame * pTaskpadFrame,
                                       CConsoleTask &consoleTask, bool fNew) :
    m_consoleTask(consoleTask),
    m_namePage(pTaskpadFrame, ConsoleTask(), fNew),
    m_cmdLinePage(pTaskpadFrame, ConsoleTask(), fNew),
    m_taskSymbolDialog(ConsoleTask())
{
    // Add property pages
    AddPage(m_namePage);
    AddPage(m_taskSymbolDialog);
    if(consoleTask.GetTaskType()==eTask_CommandLine)
        AddPage(m_cmdLinePage);

    static CStr strModifyTitle;
    strModifyTitle.LoadString(GetStringModule(),
                               IDS_TaskProps_ModifyTitle);

    // set internal state - not using ATL's SetTitle because of bogus assert.
    m_psh.pszCaption = (LPCTSTR) strModifyTitle;
    m_psh.dwFlags &= ~PSH_PROPTITLE;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizard
//
//############################################################################
//############################################################################
HRESULT
CTaskWizard::Show(HWND hWndParent, CTaskpadFrame * pTaskpadFrame, bool fNew, bool *pfRestartTaskWizard)
{
    USES_CONVERSION;

    *pfRestartTaskWizard = false;

    IFramePrivatePtr spFrame;
    spFrame.CreateInstance(CLSID_NodeInit,
#if _MSC_VER >= 1100
                        NULL,
#endif
                        MMC_CLSCTX_INPROC);


    IPropertySheetProviderPtr pIPSP = spFrame;
    if (pIPSP == NULL)
        return S_FALSE;

    HRESULT hr = pIPSP->CreatePropertySheet (L"Cool :-)", FALSE, NULL, NULL,
                                             MMC_PSO_NEWWIZARDTYPE);

    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    // create property pages
    CTaskWizardWelcomePage  welcomePage (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskWizardTypePage     typePage    (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskCmdLineWizardPage  cmdLinePage (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskWizardFavoritePage favoritePage(pTaskpadFrame, ConsoleTask(), fNew);
    CTaskWizardMenuPage     menuPage    (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskNameWizardPage     namePage    (pTaskpadFrame, ConsoleTask(), fNew);
    CTaskSymbolWizardPage   symbolPage  (ConsoleTask());
    CTaskWizardFinishPage   finishPage  (pTaskpadFrame, ConsoleTask(), pfRestartTaskWizard);


    // create the pages we'll add in IExtendPropertySheet::CreatePropertyPages
    CExtendPropSheet* peps;
    hr = CExtendPropSheet::CreateInstance (&peps);
    CHECK_HRESULT(hr);
    RETURN_ON_FAIL(hr);

    /*
     * destroying this object will take care of releasing our ref on peps
     */
    IUnknownPtr spUnk = peps;
    ASSERT (spUnk != NULL);

	peps->SetWatermarkID (IDB_TASKPAD_WIZARD_WELCOME);
    peps->SetHeaderID    (IDB_TASKPAD_WIZARD_HEADER);

    peps->AddPage (welcomePage.Create());
    peps->AddPage (typePage.Create());
    peps->AddPage (menuPage.Create());
    peps->AddPage (favoritePage.Create());
    peps->AddPage (cmdLinePage.Create());
    peps->AddPage (namePage.Create());
    peps->AddPage (symbolPage.Create());
    peps->AddPage (finishPage.Create());


    hr = pIPSP->AddPrimaryPages(spUnk, FALSE, NULL, FALSE);
    CHECK_HRESULT(hr);

    hr = pIPSP->Show((LONG_PTR)hWndParent, 0);
    CHECK_HRESULT(hr);

    return hr;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardWelcomePage
//
//############################################################################
//############################################################################
LRESULT CTaskWizardWelcomePage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CWizardPage::OnInitWelcomePage(m_hWnd); // set up the correct title font
    return 0;
}

bool
CTaskWizardWelcomePage::OnSetActive()
{
    CWizardPage::OnWelcomeSetActive(m_hWnd);
    return true;
}

bool
CTaskWizardWelcomePage::OnKillActive()
{
    CWizardPage::OnWelcomeKillActive(m_hWnd);
    return true;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardFinishPage
//
//############################################################################
//############################################################################
CTaskWizardFinishPage::CTaskWizardFinishPage(CTaskpadFrame * pTaskpadFrame,
                                             CConsoleTask & consoleTask, bool *pfRestartTaskWizard)
: m_pConsoleTask(&consoleTask),
  m_taskpadFrameTemp(*pTaskpadFrame),
  m_consoleTaskpadTemp(*(pTaskpadFrame->PConsoleTaskpad())),
  BaseClass(&m_taskpadFrameTemp, false, false), CTaskpadFramePtr(pTaskpadFrame)
{
    m_taskpadFrameTemp.SetConsoleTaskpad(&m_consoleTaskpadTemp);
    m_pfRestartTaskWizard = pfRestartTaskWizard;

    /*
     * welcome and finish pages in Wizard97-style wizards don't have headers
     */
    m_psp.dwFlags |= PSP_HIDEHEADER;
}


LRESULT CTaskWizardFinishPage::OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    BaseClass::OnInitDialog(uMsg, wParam, lParam, bHandled); // call the base class -required here.
    CWizardPage::OnInitFinishPage(m_hWnd); // set up the correct title font
    CheckDlgButton(IDB_RESTART_TASK_WIZARD, BST_UNCHECKED);
    return 0;
}

BOOL
CTaskWizardFinishPage::OnSetActive()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_FINISH);

    CConsoleTaskpad* pTaskpad = m_taskpadFrameTemp.PConsoleTaskpad();
    *pTaskpad = *(CTaskpadFramePtr::PTaskpadFrame()->PConsoleTaskpad()); // reset the taskpad

    CConsoleTaskpad::TaskIter   itTask = pTaskpad->EndTask();

    // add the task to the list.
    UpdateTaskListbox (pTaskpad->InsertTask (itTask, ConsoleTask()));

    return TRUE;
}

BOOL
CTaskWizardFinishPage::OnWizardFinish()
{
    *m_pfRestartTaskWizard = (IsDlgButtonChecked(IDB_RESTART_TASK_WIZARD)==BST_CHECKED);
    return TRUE;
}

int
CTaskWizardFinishPage::OnWizardBack()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardTypePage
//
//############################################################################
//############################################################################
CTaskWizardTypePage::CTaskWizardTypePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
:
CTaskpadFramePtr(pTaskpadFrame)
{
    m_pConsoleTask  = &consoleTask;
}

int
CTaskWizardTypePage::OnWizardNext()
{
    int ID = 0;

    // go to the appropriate page.
    switch(ConsoleTask().GetTaskType())
    {
    case eTask_Result:
    case eTask_Scope:
    case eTask_Target:
        ID = IDD_TASK_WIZARD_MENU_PAGE;
        break;
    case eTask_CommandLine:
        ID = IDD_TASK_WIZARD_CMDLINE_PAGE;
        break;
    case eTask_Favorite:
        ID = IDD_TASK_WIZARD_FAVORITE_PAGE;
        break;
    default:
        ASSERT(0 && "Should not come here.");
        break;
    }

    return ID;
}


LRESULT
CTaskWizardTypePage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    int ID = 0;

    switch (ConsoleTask().GetTaskType())
    {
    case eTask_Result:
    case eTask_Target:  // all these types have identical handlers in this page.
    case eTask_Scope:
        ID = IDC_MENU_TASK;
        break;
    case eTask_CommandLine:
        ID = IDC_CMDLINE_TASK;
        break;
    case eTask_Favorite:
        ID = IDC_NAVIGATION_TASK;
        break;
    default:
        ASSERT(0 && "Should not come here.");
        break;
    }

    ::SendDlgItemMessage(m_hWnd, ID, BM_SETCHECK, (WPARAM) true, 0);
    return 0;
}


LRESULT
CTaskWizardTypePage::OnMenuTask  ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( (ConsoleTask().GetTaskType() != eTask_Scope) ||
        (ConsoleTask().GetTaskType() != eTask_Result) ) // if changing task types
    {
        ConsoleTask() = CConsoleTask();             // clear out the task info.
        ConsoleTask().SetTaskType(eTask_Scope);
    }
    return 0;
}

LRESULT
CTaskWizardTypePage::OnCmdLineTask( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if(ConsoleTask().GetTaskType() != eTask_CommandLine) // if changing task types
    {
        ConsoleTask() = CConsoleTask();             // clear out the task info.
        ConsoleTask().SetTaskType(eTask_CommandLine);
    }
    return 0;
}

LRESULT
CTaskWizardTypePage::OnFavoriteTask(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if(ConsoleTask().GetTaskType() != eTask_Favorite) // if changing task types
    {
        ConsoleTask() = CConsoleTask();             // clear out the task info.
        ConsoleTask().SetTaskType(eTask_Favorite);
    }
    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskNamePage
//
//############################################################################
//############################################################################
CTaskNamePage::CTaskNamePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
:
CTaskpadFramePtr(pTaskpadFrame)
{
    m_pConsoleTask  = &consoleTask;

	/*
	 * if this page is for a new task, we'll be running in a wizard (not
	 * a property sheet)
	 */
	m_fRunAsWizard  = fNew;
}

BOOL
CTaskNamePage::SetTaskName(bool fCheckIfOK)
{
    /*
     * get the task name
     */
    CWindow wndTaskName = GetDlgItem (IDC_TaskName);
    tstring strName = MMC::GetWindowText (wndTaskName);

    /*
     * a name is required (usually)
     */
    if (fCheckIfOK && strName.empty())
    {
        CStr strError;
        strError.LoadString(GetStringModule(),
                             IDS_TaskProps_ErrorNoTaskName);

        MessageBox (strError);
        wndTaskName.SetFocus ();
        return (false); // don't allow the change.
    }

    /*
     * get the description
     */
    tstring strDescription = MMC::GetWindowText (GetDlgItem (IDC_TaskDescription));

    /*
     * update the task
     */
    ConsoleTask().SetName        (strName);
    ConsoleTask().SetDescription (strDescription);

    return (true);
}

int
CTaskNamePage::OnWizardNext()
{
    if(!SetTaskName(true))
        return -1;

    return IDD_TASK_WIZARD_SYMBOL_PAGE;
}

int
CTaskNamePage::OnWizardBack()
{
    int ID = 0;

    // go to the appropriate page.
    switch(ConsoleTask().GetTaskType())
    {
    case eTask_Result:
    case eTask_Scope:
    case eTask_Target:
        ID = IDD_TASK_WIZARD_MENU_PAGE;
        break;
    case eTask_CommandLine:
        ID = IDD_TASK_WIZARD_CMDLINE_PAGE;
        break;
    case eTask_Favorite:
        ID = IDD_TASK_WIZARD_FAVORITE_PAGE;
        break;
    default:
        ASSERT(0 && "Should not come here.");
        break;
    }

    return ID;
}


BOOL
CTaskNamePage::OnSetActive()
{
    // Set the correct wizard buttons (only if we're running as a wizard)
	if (m_fRunAsWizard)
		WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK | PSWIZB_NEXT);

    ::SetDlgItemText (m_hWnd, IDC_TaskName,          ConsoleTask().GetName().data());
    ::SetDlgItemText (m_hWnd, IDC_TaskDescription,   ConsoleTask().GetDescription().data());
    return TRUE;
}


BOOL
CTaskNamePage::OnKillActive()
{
    SetTaskName(false); // don't care if it is blank (eg if user pressed "Back" button.)
    return TRUE;
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardMenuPage
//
//############################################################################
//############################################################################
CTaskWizardMenuPage::CTaskWizardMenuPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew) :
    CTaskpadFramePtr(pTaskpadFrame),
    BC2(pTaskpadFrame, consoleTask, fNew)
{
    m_pMirrorTargetNode = NULL;
}


BOOL
CTaskWizardMenuPage::OnSetActive()
{
    return TRUE;
}

BOOL
CTaskWizardMenuPage::OnKillActive()
{
    return TRUE;
}

int
CTaskWizardMenuPage::OnWizardNext()
{
    if(m_wndCommandListbox.GetCurSel() == LB_ERR) // no selection, display error
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), IDS_TASK_MENU_COMMAND_REQUIRED);
        MessageBox(strTitle, NULL, MB_OK | MB_ICONEXCLAMATION);
        return -1;
    }
   return IDD_TASK_WIZARD_NAME_PAGE;
}

CTaskWizardMenuPage::_TaskSource
CTaskWizardMenuPage::s_rgTaskSource[] =
{
    {IDS_TASKSOURCE_RESULT, eTask_Result},
    {IDS_TASKSOURCE_SCOPE,  eTask_Scope},
};

LRESULT
CTaskWizardMenuPage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    //attach HWNDs to CWindows
    m_wndCommandListbox = GetDlgItem (IDC_CommandList);

    CNode* pTargetNode = NULL;

    if(PTaskpadFrame()->PConsoleTaskpad()->HasTarget())
        pTargetNode = PNodeTarget();


    // populate the drop down

    m_wndSourceCombo = GetDlgItem (IDC_TASK_SOURCE_COMBO);

    for (int i = 0; i < countof (s_rgTaskSource); i++)
    {
        CStr str;
        VERIFY (str.LoadString(GetStringModule(), s_rgTaskSource[i].idsName));
        VERIFY (m_wndSourceCombo.InsertString (-1, str) == i);
    }


    /*
     * attach the scope browser to the scope tree
     */
    CMTBrowserCtrl::InitData init;

    init.hwnd       = GetDlgItem (IDC_ScopeTree);
    init.pScopeTree = PScopeTree();
    init.pmtnSelect = (pTargetNode != NULL) ? pTargetNode->GetMTNode() : NULL;

    // remember the task type...
    eConsoleTaskType type = ConsoleTask().GetTaskType();

    m_wndScopeTree.Initialize (init);

    // populate the result menu item list.
    if (pTargetNode /*&& bResultTask*/)
    {
        InitResultView (pTargetNode);
    }

    // reset the task type from above...
    ConsoleTask().SetTaskType(type);

    EnableWindows();
    OnSettingsChanged();
    return 0;
}


void CTaskWizardMenuPage::ShowWindow(HWND hWnd, bool bShowWindow)
{
    if (!::IsWindow(hWnd))
        return;

    ::ShowWindow  (hWnd, bShowWindow ? SW_SHOW : SW_HIDE);
    ::EnableWindow(hWnd, bShowWindow);
}

void
CTaskWizardMenuPage::EnableWindows()
{
    eConsoleTaskType type = ConsoleTask().GetTaskType();
    if(type == eTask_Target)
        type = eTask_Scope;  // for the purposes of the UI these are identical.


    // display the correct task type.
    for(int i = 0; i< countof (s_rgTaskSource); i++)
    {
        if(s_rgTaskSource[i].type == type)
            break;
    }

    ASSERT(i<countof(s_rgTaskSource));

    bool bResultTask = ConsoleTask().GetTaskType() == eTask_Result;

    m_wndSourceCombo.SetCurSel(i);

   /*
    // Enable ResultTask choice only if there are result items
    bool bResultItems = (m_wndResultView.GetItemCount() > 0);
    ASSERT(bResultItems || !bResultTask);
    ::EnableWindow(GetDlgItem(IDC_RESULT_TASK), bResultItems);
    */

    ShowWindow(GetDlgItem(IDC_RESULT_TASK_DESCR),    bResultTask);
    ShowWindow(GetDlgItem(IDC_CONSOLE_TREE_CAPTION), !bResultTask);
    ShowWindow(GetDlgItem(IDC_ScopeTree),            !bResultTask);
    ShowWindow(GetDlgItem(IDC_ResultList),           bResultTask);
}

LRESULT
CTaskWizardMenuPage::OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    OnSettingsChanged();
    return 0;
}

void
CTaskWizardMenuPage::OnSettingsChanged()
{
    eConsoleTaskType type = s_rgTaskSource[m_wndSourceCombo.GetCurSel()].type;

    ConsoleTask().SetTaskType(type);
    EnableWindows();

    if(type == eTask_Scope)
    {
        HTREEITEM hti = m_wndScopeTree.GetSelectedItem();
        m_wndScopeTree.SelectItem(NULL); // remove the selection
        m_wndScopeTree.SelectItem(hti); // reselect it.
    }
    else
    {
        // empty the list box
        m_wndCommandListbox.ResetContent();
        SelectFirstResultItem(false);
        SelectFirstResultItem(true);
    }
}

/*+-------------------------------------------------------------------------*
 * CTaskWizardMenuPage::OnScopeItemChanged
 *
 *
/*+-------------------------------------------------------------------------*/

LRESULT CTaskWizardMenuPage::OnScopeItemChanged(int id, LPNMHDR pnmh, BOOL& bHandled)
{
    // empty the list box
    m_wndCommandListbox.ResetContent();

    LPNMTREEVIEW    pnmtv           = (LPNMTREEVIEW) pnmh;
    CBrowserCookie *pBrowserCookie  = m_wndScopeTree.CookieFromItem (&pnmtv->itemNew);
    if(!pBrowserCookie) // no item selected
        return 0;

    CNode*      pNode   = pBrowserCookie->PNode();
    CMTNode *   pMTNode = pBrowserCookie->PMTNode();

    // validate parameters
    ASSERT(pMTNode);
    ASSERT(PTaskpadFrame()->PViewData());

    if(!pNode)
    {
        pNode = pMTNode->GetNode(PTaskpadFrame()->PViewData());
        if(!pNode)
            return 0;

        pBrowserCookie->SetNode(pNode);
        HRESULT hr = pNode->InitComponents();
        if (FAILED(hr))
            return 0;
    }

    bool bNodeIsTarget = PTaskpadFrame()->PConsoleTaskpad()->HasTarget() &&
                         (PNodeTarget()->GetMTNode() == pNode->GetMTNode());

    // set the correct task type.
    ConsoleTask().SetTaskType(bNodeIsTarget ? eTask_Target : eTask_Scope);
    // retarget the scope node bookmark
    if(!bNodeIsTarget)
        ConsoleTask().RetargetScopeNode(pNode);

    int cResultItemCount = ListView_GetItemCount(m_MirroredView.GetListCtrl());
    SC sc = ScTraverseContextMenu(pNode, PScopeTree(), TRUE, PTaskpadFrame()->PNodeTarget(),
                0, bNodeIsTarget && (cResultItemCount > 0)/*bShowSaveList*/);

    return (0);
}


void CTaskWizardMenuPage::InitResultView (CNode* pRootNode)
{
    /*
     * create the temporary view whose contents we'll mirror
     */
    ASSERT (pRootNode != NULL);
    m_pMirrorTargetNode = m_MirroredView.Create (PScopeTree()->GetConsoleFrame(), pRootNode);
    ASSERT (m_pMirrorTargetNode != NULL);

    /*
     * force the snap-in into a standard list view
     */
    HRESULT hr;
    hr = m_pMirrorTargetNode->InitComponents ();
    hr = m_pMirrorTargetNode->ShowStandardListView ();

    if (FAILED (hr))
    {
        // TODO(jeffro): handle snap-ins that don't support a standard list view
    }

    /*
     * attach the temporary view's list view to our mirror list view
     */
    m_wndResultView.AttachSource (GetDlgItem (IDC_ResultList),
                                  m_MirroredView.GetListCtrl());

    //SelectFirstResultItem();
}

void CTaskWizardMenuPage::SelectFirstResultItem(bool bSelect)
{
    /*
     * Select the first item.  Note that one would think we'd be able to use:
     *
     *      m_wndResultView.SetItemState (0, LVIS_SELECTED, LVIS_SELECTED);
     *
     * to select the item.  We can't though because that overload of
     * SetItemState sends LVM_SETITEM, which fails for virtual listviews.
     *
     * If we instead use:
     *
     *      m_wndResultView.SetItemState (nItem, LV_ITEM* pItem)
     *
     * then LVM_SETITEMSTATE will be sent, which works for virtual listviews.
     */

    int i = m_wndResultView.GetItemCount();
    if(i == 0)
        return;

    LV_ITEM lvi;
    lvi.mask      = LVIF_STATE;
    lvi.iItem     = 0;
    lvi.state     = bSelect ? LVIS_SELECTED : 0;
    lvi.stateMask = LVIS_SELECTED;

    m_wndResultView.SetItemState (0, &lvi);
}


/*+-------------------------------------------------------------------------*
 * CTaskWizardMenuPage::OnResultItemChanged
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT CTaskWizardMenuPage::OnResultItemChanged(int id, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    /*
     * if a new item is being selected, populate the result menu item list
     */
    if ((pnmlv->uNewState & LVIS_SELECTED) && !(pnmlv->uOldState & LVIS_SELECTED))
    {
        ASSERT (m_pMirrorTargetNode != NULL);

        m_wndCommandListbox.ResetContent();

        SC sc = ScTraverseContextMenu (m_pMirrorTargetNode,
                             PScopeTree(), FALSE, NULL,
                             m_wndResultView.GetSelectedItemData ());
    }

    // set the correct task type.
    ConsoleTask().SetTaskType(eTask_Result);
    return (0);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTaskWizardFavoritePage
//
//############################################################################
//############################################################################
CTaskWizardFavoritePage::CTaskWizardFavoritePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
: CTaskpadFramePtr(pTaskpadFrame), m_bItemSelected(false)
{
    m_pConsoleTask  = &consoleTask;
}

CTaskWizardFavoritePage::~CTaskWizardFavoritePage()
{
}

BOOL
CTaskWizardFavoritePage::OnSetActive()
{
    SetItemSelected(m_bItemSelected); // restore the state.

    return true;
}

BOOL
CTaskWizardFavoritePage::OnKillActive()
{
    return true;
}


int
CTaskWizardFavoritePage::OnWizardBack()
{
    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    return IDD_TASK_WIZARD_TYPE_PAGE;
}

int
CTaskWizardFavoritePage::OnWizardNext()
{
    return IDD_TASK_WIZARD_NAME_PAGE;
}

void
CTaskWizardFavoritePage::SetItemSelected(bool bItemSelected)
{
    m_bItemSelected = bItemSelected;

    // Set the correct wizard buttons.
    WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (bItemSelected ? (PSWIZB_BACK | PSWIZB_NEXT)
                                                                              : (PSWIZB_BACK));
}

LRESULT
CTaskWizardFavoritePage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CConsoleView* pConsoleView = PTaskpadFrame()->PViewData()->GetConsoleView();

    if (pConsoleView != NULL)
    {
        HWND hwndCtrl = pConsoleView->CreateFavoriteObserver (m_hWnd, IDC_FavoritesTree);
        ASSERT(hwndCtrl != NULL);

        HWND hWndStatic = GetDlgItem(IDC_FAVORITE_STATIC);
        ASSERT(hWndStatic != NULL);

        RECT rectStatic;
        ::GetWindowRect(hWndStatic, &rectStatic);

        WTL::CPoint pointTopLeft;
        pointTopLeft.y  = rectStatic.top;
        pointTopLeft.x  = rectStatic.left;

        ::ScreenToClient(m_hWnd, &pointTopLeft);

        ::SetWindowPos(hwndCtrl, NULL,
                       pointTopLeft.x, pointTopLeft.y,
                       rectStatic.right  -rectStatic.left,
                       rectStatic.bottom - rectStatic.top,
                       SWP_NOZORDER);
    }

    return 0;
}


LRESULT
CTaskWizardFavoritePage::OnItemChanged (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CMemento *pMemento  = (CMemento *)wParam;
    if(pMemento != NULL)
    {
        ConsoleTask().SetMemento(*pMemento);
    }
    else
    {
        // Set the correct wizard buttons.
        WTL::CPropertySheetWindow(::GetParent(m_hWnd)).SetWizardButtons (PSWIZB_BACK);
    }

    SetItemSelected(pMemento!=NULL);

    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTaskCmdLinePage
//
//############################################################################
//############################################################################
// contents of the "Run:" combo box
const int const CTaskCmdLinePage::s_rgidWindowStates[] =
{
    IDS_TaskProps_Restored,
    IDS_TaskProps_Minimized,
    IDS_TaskProps_Maximized,
};


CTaskCmdLinePage::CTaskCmdLinePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
:    m_hBitmapRightArrow(NULL), CTaskpadFramePtr(pTaskpadFrame)
{
    m_pConsoleTask  = &consoleTask;
}

CTaskCmdLinePage::~CTaskCmdLinePage()
{
    if(m_hBitmapRightArrow)
        ::DeleteObject(m_hBitmapRightArrow);
}

BOOL
CTaskCmdLinePage::OnSetActive()
{
    return TRUE;
}

BOOL
CTaskCmdLinePage::OnKillActive()
{
    switch (m_wndWindowStateCombo.GetSelectedItemData())
    {
        case IDS_TaskProps_Restored:
            ConsoleTask().SetWindowState (eState_Restored);
            break;

        case IDS_TaskProps_Maximized:
            ConsoleTask().SetWindowState (eState_Maximized);
            break;

        case IDS_TaskProps_Minimized:
            ConsoleTask().SetWindowState (eState_Minimized);
            break;
    }

    ConsoleTask().SetCommand   (MMC::GetWindowText (GetDlgItem (IDC_Command)));
    ConsoleTask().SetParameters(MMC::GetWindowText (GetDlgItem (IDC_CommandArgs)));
    ConsoleTask().SetDirectory (MMC::GetWindowText (GetDlgItem (IDC_CommandWorkingDir)));

    return TRUE;
}

int
CTaskCmdLinePage::OnWizardNext()
{

    // make sure we have a command
    tstring strCommand = MMC::GetWindowText (GetDlgItem (IDC_Command));

    if (strCommand.empty())
    {
        CStr strError;
        strError.LoadString(GetStringModule(),
                             IDS_TaskProps_ErrorNoCommand);

        MessageBox (strError);
        ::SetFocus (GetDlgItem (IDC_Command));
        return (-1);
    }
    return IDD_TASK_WIZARD_NAME_PAGE;
}

LRESULT
CTaskCmdLinePage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // Attach HWNDs to CWindows
    m_wndRightArrowButton     = GetDlgItem (IDC_BrowseForArguments);
    m_wndWindowStateCombo     = GetDlgItem (IDC_CommandWindowStateCombo);

    // the menu arrow (OBM_NARROW) is defined by the system.
    m_hBitmapRightArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
    m_wndRightArrowButton.SetBitmap(m_hBitmapRightArrow);

    // populate the combo boxes
    m_wndWindowStateCombo.  InsertStrings (s_rgidWindowStates,     countof (s_rgidWindowStates));


    // select the appropriate items in the combo boxes
    switch (ConsoleTask().GetWindowState())
    {
        case eState_Restored:
            m_wndWindowStateCombo.SelectItemByData(IDS_TaskProps_Restored);
            break;

        case eState_Minimized:
            m_wndWindowStateCombo.SelectItemByData(IDS_TaskProps_Minimized);
            break;

        case eState_Maximized:
            m_wndWindowStateCombo.SelectItemByData(IDS_TaskProps_Maximized);
            break;
    }

    ::SetDlgItemText (m_hWnd, IDC_Command,           ConsoleTask().GetCommand().data());
    ::SetDlgItemText (m_hWnd, IDC_CommandArgs,       ConsoleTask().GetParameters().data());
    ::SetDlgItemText (m_hWnd, IDC_CommandWorkingDir, ConsoleTask().GetDirectory().data());

    return 0;
}

LRESULT
CTaskCmdLinePage::OnBrowseForArguments(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CCommandLineArgumentsMenu commandLineArgumentsMenu(m_hWnd, IDC_BrowseForArguments,
                                    PTaskpadFrame()->PViewData()->GetListCtrl());
    if(commandLineArgumentsMenu.Popup())
    {
        HWND hWndCommandArgs = ::GetDlgItem(m_hWnd, IDC_CommandArgs);

        // replace the selection appropriately.
        ::SendMessage(hWndCommandArgs, EM_REPLACESEL, (WPARAM)(BOOL) true /*fCanUndo*/,
            (LPARAM)(LPCTSTR)commandLineArgumentsMenu.GetResultString());

        ::SetFocus(hWndCommandArgs);
    }

    return 0;
}


/*+-------------------------------------------------------------------------*
 * CTaskCmdLinePage::OnBrowseForCommand
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT
CTaskCmdLinePage::OnBrowseForCommand (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    tstring strCommand = MMC::GetWindowText (GetDlgItem (IDC_Command));

    CStr strFilter;
    strFilter.LoadString(GetStringModule(), IDS_TaskProps_ProgramFilter);

    /*
     * The file dialog expects embedded \0's in the string, but those
     * don't load well.  The string in the resource file has \\ where
     * the \0 should be, so let's make the substitution now.
     */
    for (LPTSTR pch = strFilter.GetBuffer (0); *pch != _T('\0'); pch++)
    {
        if (*pch == _T('\\'))
            *pch = _T('\0');
    }
    // don't call ReleaseBuffer, since the string now contains \0 chars

    WTL::CFileDialog dlg (true, NULL, strCommand.data(),
                          OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
                          strFilter, m_hWnd);

    if (dlg.DoModal() == IDOK)
        SetDlgItemText (IDC_Command, dlg.m_szFileName);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * BrowseForWorkingDirCallback
 *
 * Helper function for CTaskPropertiesBase::OnBrowseForWorkingDir.  It is
 * used to select the current working directory when the "Pick a Directory"
 * dialog is displayed.
 *--------------------------------------------------------------------------*/

int CALLBACK BrowseForWorkingDirCallback (HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    /*
     * once the dialog is initialized, pre-select
     * the current working directory (if there is one)
     */
    if ((msg == BFFM_INITIALIZED) && (lpData != NULL))
        SendMessage (hwnd, BFFM_SETSELECTION, true, lpData);

    return (0);
}


/*+-------------------------------------------------------------------------*
 * CTaskPropertiesBase::OnBrowseForWorkingDir
 *
 *
 *--------------------------------------------------------------------------*/

LRESULT
CTaskCmdLinePage::OnBrowseForWorkingDir (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR szDisplayName[MAX_PATH];
    tstring strCurrentDir = MMC::GetWindowText (GetDlgItem (IDC_CommandWorkingDir));

    BROWSEINFO bi;
    bi.hwndOwner      = m_hWnd;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle      = NULL;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseForWorkingDirCallback;
    bi.lParam         = (strCurrentDir.empty()) ? NULL : (LPARAM) strCurrentDir.data();
    bi.iImage         = 0;

    LPITEMIDLIST pidlWorkingDir = SHBrowseForFolder (&bi);

    if (pidlWorkingDir != NULL)
    {
        /*
         * expand the pidl and put the working directory into the control
         */
        SHGetPathFromIDList (pidlWorkingDir, szDisplayName);
        SetDlgItemText (IDC_CommandWorkingDir, szDisplayName);

        /*
         * free the pidl
         */
        IMallocPtr spMalloc;
        SHGetMalloc (&spMalloc);
        spMalloc->Free (pidlWorkingDir);
    }

    return (0);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTempAMCView
//
//############################################################################
//############################################################################

CNode* CTempAMCView::Create (CConsoleFrame* pFrame, CNode* pRootNode)
{
    ASSERT (pRootNode != NULL);
    return (Create (pFrame, pRootNode->GetMTNode()));
}

CNode* CTempAMCView::Create (CConsoleFrame* pFrame, CMTNode* pRootMTNode)
{
    ASSERT (pRootMTNode != NULL);
    return (Create (pFrame, pRootMTNode->GetID()));
}

CNode* CTempAMCView::Create (CConsoleFrame* pFrame, MTNODEID idRootNode)
{
    HRESULT hr;

    ASSERT (idRootNode != 0);
    ASSERT (pFrame != NULL);
    CConsoleView* pConsoleView = NULL;

    /*
     * clean up an existing view
     */
    Destroy();
    ASSERT (m_pViewData == NULL);

    /*
     * create a new view
     */
    CreateNewViewStruct cnvs;
    cnvs.idRootNode     = idRootNode;
    cnvs.lWindowOptions = MMC_NW_OPTION_NOPERSIST;
    cnvs.fVisible       = false;

    SC sc = pFrame->ScCreateNewView(&cnvs);
    if (sc)
        goto Error;

    m_pViewData = reinterpret_cast<CViewData*>(cnvs.pViewData);

    /*
     * select the new view's root node (can't fail)
     */
    pConsoleView = GetConsoleView();
    ASSERT (pConsoleView != NULL);

    if (pConsoleView != NULL)
        sc = pConsoleView->ScSelectNode (idRootNode);

    if (sc)
        goto Error;

    return (CNode::FromHandle(cnvs.hRootNode));

Cleanup:
    return (NULL);
Error:
    TraceError (_T("CTempAMCView::Create"), sc);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\taskui.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       taskui.h
 *
 *  Contents:   Interface file for console taskpad UI classes.
 *
 *  History:    29-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TASKUI_H
#define TASKUI_H
#pragma once

#include "tstring.h"
#include "dlgs.h"
#include "task.h"
#include "cmenuinfo.h"


/*
 * forward declarations
 */
class CMTNode;
class CTaskpadGeneralPage;
class CTaskpadTasksPage;
class CTaskpadPropertySheet;
class CTaskpadOptionsDlg;
class CContextMenuVisitor;
class CMTBrowserCtrl;
class CConsoleExtendTaskPadImpl;
class CContextMenu;
class CConsoleTask;
class CTaskpadGroupPropertySheet;
class CTaskpadGroupGeneralPage;
class CConsoleView;

// property page classes
class CTaskNamePage;
class CTaskCmdLinePage;
class CTaskSymbolDlg;


#include <pshpack8.h>       // for Win64

// ATL does not allow chaining more than one class or member at a time. This works around that.
#define CHAIN_MSG_MAP_EX(theChainClass) \
    { \
        theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult); \
    }

//############################################################################
//############################################################################
//
//  class CBrowserCookie
//
// a class to store the Node's for each MTNode. Used by CMTBrowserCtrl
//############################################################################
//############################################################################
class CBrowserCookie
{
    CMTNode *           m_pMTNode;
    CNode *             m_pNode;

public:
                        CBrowserCookie();
                        CBrowserCookie(CMTNode *pMTNode, CNode *pNode);
    void                DeleteNode();

    CNode *             PNode() {return m_pNode;}
    CMTNode *           PMTNode() const   {ASSERT(m_pMTNode); return m_pMTNode;}
    void                SetNode(CNode *pNode);
    bool                operator < (const CBrowserCookie &rhs) const {return m_pMTNode < rhs.m_pMTNode;}
};


//############################################################################
//############################################################################
// inlines
//############################################################################
//############################################################################
inline CBrowserCookie::CBrowserCookie()
: m_pMTNode(NULL), m_pNode(NULL)
{}

inline CBrowserCookie::CBrowserCookie(CMTNode *pMTNode, CNode *pNode)
: m_pMTNode(pMTNode), m_pNode(pNode){}

inline void
CBrowserCookie::SetNode(CNode *pNode)
{
    ASSERT(!m_pNode);
    m_pNode = pNode;
}


class CBrowserCookieList : public std::list<CBrowserCookie>
{
public:
    ~CBrowserCookieList();
};

//############################################################################
//############################################################################
//
//  class CMTBrowserCtrl
//
//  PURPOSE: Implements a general purpose scope tree browser that enables a
//           user to browse down the master scope tree and select a node.
//
//  USAGE: Add an object of this class to your dialog, and construct it with
//         the ID of the tree control to use. Chain the object into the
//         message loop. If needed, subclass this class and override any
//         methods appropriately.
//
//############################################################################
//############################################################################

class CMTBrowserCtrl : public CWindowImpl<CMTBrowserCtrl, WTL::CTreeViewCtrlEx>
{
    typedef CWindowImpl<CMTBrowserCtrl, WTL::CTreeViewCtrlEx> BC;

public:
    typedef std::vector<CMTNode*>       CMTNodeCollection;

    struct InitData
    {
        InitData () :
            hwnd(NULL), pScopeTree(NULL), pmtnRoot(NULL), pmtnSelect(NULL)
        {}

        HWND                hwnd;
        CScopeTree*         pScopeTree;
        CMTNode*            pmtnRoot;
        CMTNode*            pmtnSelect;
        CMTNodeCollection   vpmtnExclude;
    };

public:
    // constructor /destructor
    CMTBrowserCtrl();
    ~CMTBrowserCtrl();

    BEGIN_MSG_MAP(CMTBrowserCtrl)
        REFLECTED_NOTIFY_CODE_HANDLER (TVN_ITEMEXPANDING, OnItemExpanding);
        //CHAIN_MSG_MAP(BC)
        DEFAULT_REFLECTION_HANDLER ()
    END_MSG_MAP();

    void        Initialize (const InitData& init);
    HTREEITEM   InsertItem (const CBrowserCookie &browserCookie, HTREEITEM hParent, HTREEITEM hInsertAfter);
    bool        SelectNode (CMTNode* pmtnSelect);

    CMTNode*        GetSelectedMTNode ()                    const;
    CBrowserCookie* CookieFromItem    (HTREEITEM hti)       const;
    CBrowserCookie* CookieFromItem    (const TV_ITEM* ptvi) const;
    CBrowserCookie* CookieFromLParam  (LPARAM lParam)       const;
    CMTNode*        MTNodeFromItem    (HTREEITEM hti)       const;
    CMTNode*        MTNodeFromItem    (const TV_ITEM* ptvi) const;

protected:
    LRESULT OnItemExpanding (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    bool ExpandItem (const TV_ITEM& itemExpand);
    HTREEITEM FindChildItemByMTNode (HTREEITEM htiParent, const CMTNode* pmtnToFind);

private:
    // set this to non-zero to optimize access to m_vpmtnExclude
    enum { OptimizeExcludeList = 0 };

    // implementation
    int                 m_id;       // the ID of the tree control
    int                 ID()                       {return m_id;}

    CMTNodeCollection   m_vpmtnExclude;

    CScopeTree *        m_pScopeTree;
    CScopeTree *        PScopeTree()               {return m_pScopeTree;}
    CBrowserCookieList  m_browserCookieList;
    CBrowserCookieList *PBrowserCookieList()       {return &m_browserCookieList;}

    bool IsMTNodeExcluded (CMTNode* pmtn) const;
};


//############################################################################
//############################################################################
//
//  class CTempAMCView
//
//############################################################################
//############################################################################


class CTempAMCView
{
public:
    CTempAMCView() : m_pViewData(NULL)
    {}

    ~CTempAMCView()
    {
        Destroy();
    }

    CNode* Create (CConsoleFrame* pFrame, CNode* pRootNode);
    CNode* Create (CConsoleFrame* pFrame, CMTNode* pRootMTNode);
    CNode* Create (CConsoleFrame* pFrame, MTNODEID idRootNode);

    bool Destroy ()
    {
        if (m_pViewData == NULL)
            return (false);

        GetChildFrame().SendMessage (WM_CLOSE);
        m_pViewData = NULL;
        return (true);
    }

    CViewData* GetViewData() const
    {
        return (m_pViewData);
    }

    MMC_ATL::CWindow GetChildFrame() const
    {
        return ((m_pViewData != NULL) ? m_pViewData->GetChildFrame() : NULL);
    }

    CConsoleView* GetConsoleView() const
    {
        return ((m_pViewData != NULL) ? m_pViewData->GetConsoleView() : NULL);
    }

    MMC_ATL::CWindow GetListCtrl() const
    {
        return ((m_pViewData != NULL) ? m_pViewData->GetListCtrl() : NULL);
    }


private:
    CViewData*  m_pViewData;

};


//############################################################################
//############################################################################
//
//  class CMirrorListView
//
//  CMirrorListView is a list view control that will mirror the contents of
//  another list view control.
//
//############################################################################
//############################################################################

class CMirrorListView : public CWindowImpl<CMirrorListView, WTL::CListViewCtrl>
{
    typedef CMirrorListView                                     ThisClass;
    typedef CWindowImpl<CMirrorListView, WTL::CListViewCtrl>    BaseClass;

public:
    CMirrorListView();

    void AttachSource (HWND hwndList, HWND hwndSourceList);
    LPARAM GetSelectedItemData ();

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER (LVM_GETITEM, ForwardMessage);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_GETDISPINFO,     OnGetDispInfo);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_ODCACHEHINT,     ForwardVirtualNotification);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_ODFINDITEM,      ForwardVirtualNotification);
        REFLECTED_NOTIFY_CODE_HANDLER (LVN_ODSTATECHANGED,  ForwardVirtualNotification);
        DEFAULT_REFLECTION_HANDLER ()
    END_MSG_MAP();

protected:
    LRESULT ForwardMessage (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnGetDispInfo              (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT ForwardNotification        (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT ForwardVirtualNotification (int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    void InsertColumns ();

private:
    WTL::CListViewCtrl  m_wndSourceList;
    bool                m_fVirtualSource;
};



//############################################################################
//############################################################################
//
//  class MMC:CEdit
//
//############################################################################
//############################################################################

namespace MMC
{

class CEdit : public WTL::CEdit
{
public:
    void Initialize(CWindow *pwndParent, int idEdit, int cchMax = -1, LPCTSTR sz = NULL);
    void Empty(LPCTSTR sz = _T(""))
    {
        SetSel(0, -1);
        ReplaceSel(sz);
    }

};

}; // namespace MMC

//############################################################################
//############################################################################
//
//  class CDialogBase
//
//############################################################################
//############################################################################

template<class T>
class CDialogBase : public CDialogImpl<T>
{
    typedef CDialogBase     ThisClass;
    typedef CDialogImpl<T>  BaseClass;

public:
    CDialogBase (bool fAutoCenter = false);

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,  OnInitDialog)
        COMMAND_ID_HANDLER (IDOK,           OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,       OnCancel)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP()

    virtual LRESULT OnInitDialog (HWND hwndFocus, LPARAM lParam, BOOL& bHandled);
    virtual bool    OnApply () = 0;

public:
    BOOL EnableDlgItem (int idControl, bool fEnable);
    void CheckDlgItem (int idControl, int nCheck);
    tstring GetDlgItemText (int idControl);
    BOOL    SetDlgItemText (int idControl, tstring str);

// Generated message map functions
protected:
    LRESULT OnInitDialog     (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    virtual LRESULT OnOK     (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    virtual LRESULT OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    bool    m_fAutoCenter;
};


//############################################################################
//############################################################################
//
//  class CMyComboBox
//
//############################################################################
//############################################################################

class CMyComboBox : public WTL::CComboBox
{
    typedef WTL::CComboBox BaseClass;

public:
    CMyComboBox (HWND hwnd = NULL) : BaseClass(hwnd)
    {}

    CMyComboBox& operator= (HWND hwnd)
    {
        m_hWnd = hwnd;
        return *this;
    }

    void    InsertStrings (const int rgStringIDs[], int cStringIDs);
    LPARAM  GetSelectedItemData () const;
    void    SelectItemByData (LPARAM lParam);
    int     FindItemByData (LPARAM lParam) const;
};



//############################################################################
//############################################################################
//
//  class CContextMenuVisitor
//
//  PURPOSE: Enables traversal of a tree of context menu items by
//           any class that derives from this one.
//
//############################################################################
//############################################################################
class CContextMenuVisitor
{
    SC                      ScTraverseContextMenu(CContextMenu *pContextMenu);

protected:
    SC                      ScTraverseContextMenu(CNode *pNodeTarget, CScopeTree *pCScopeTree,
                            BOOL fScopeItem, CNode *pNodeScope, LPARAM resultItemParam, bool bShowSaveList = false);
    virtual SC              ScOnVisitContextMenu(CMenuItem &menuItem) = 0;       // defined by derived class.

protected:
    virtual SC              ScShouldItemBeVisited(CMenuItem *pMenuItem, CContextMenuInfo *pContextInfo, /*out*/ bool &bVisitItem);       // should this item be visited?

    virtual ~CContextMenuVisitor() {};
};

//############################################################################
//############################################################################
//
//  class CTaskpadFrame
//
//############################################################################
//############################################################################

class CTaskpadFrame
{
protected:
    CConsoleTaskpad *               m_pConsoleTaskpad;
    bool                            m_fNew;                     // is this a new taskpad?
    CViewData *                     m_pViewData;
    LPARAM                          m_lCookie;
    bool                            m_fCookieValid;
    CNode *                         m_pNodeTarget;
    bool                            m_bTargetNodeSelected;      // has the target node been selected, if there is one

public:
    CScopeTree *                    PScopeTree()            {return dynamic_cast<CScopeTree *>(m_pViewData->GetScopeTree());}
    CNode *                         PNodeTarget()           {return m_pNodeTarget;}
    CConsoleTaskpad     *           PConsoleTaskpad()       {return m_pConsoleTaskpad;}
    bool                            FNew()                  {return m_fNew;}
    void                            SetNew(bool b)          {m_fNew = b;}
    LPARAM                          Cookie()                {return m_lCookie;}
    bool                            FCookieValid()          {return m_fCookieValid;}
    CViewData *                     PViewData()             {return m_pViewData;}
    void                            SetConsoleTaskpad(CConsoleTaskpad *pConsoleTaskpad)
                                                            {m_pConsoleTaskpad = pConsoleTaskpad;}
    bool                            FTargetNodeSelected()   {return m_bTargetNodeSelected;}
    void                            SetTargetNodeSelected(bool b) {m_bTargetNodeSelected = b;}

    CTaskpadFrame(CNode *pNodeTarget, CConsoleTaskpad*  pConsoleTaskpad, CViewData *pViewData,
                    bool fCookieValid, LPARAM lCookie);
    CTaskpadFrame(const CTaskpadFrame &rhs);
};


//############################################################################
//############################################################################
//
//  class CTaskpadStyle
//
//  PURPOSE: Stores details of a taskpad style. Used by CTaskpadGeneralPage
//
//############################################################################
//############################################################################

class CTaskpadStyle
{
private:
	/*
	 * NOTE:  this class has a custom assignment operator.  Be sure to
	 * update it if you add member variables to this class.
	 */
    ListSize                m_eSize;
    DWORD                   m_dwOrientation;
    int                     m_idsDescription;       // eg "Horizontal listpad with tasks underneath."
    int                     m_nPreviewBitmapID;
    mutable CStr            m_strDescription;
    mutable WTL::CBitmap    m_PreviewBitmap;

public:
    CTaskpadStyle (ListSize eSize, int idsDescription, int nPreviewBitmapID, DWORD dwOrientation);
    CTaskpadStyle (ListSize eSize, DWORD dwOrientation);
    CTaskpadStyle (const CTaskpadStyle& other);
    CTaskpadStyle& operator= (const CTaskpadStyle& other);

    bool operator== (const CTaskpadStyle& other) const
    {
        return ((m_dwOrientation == other.m_dwOrientation) &&
                ((m_eSize == other.m_eSize) || (m_eSize == eSize_None)));
    }

    const CStr& GetDescription() const;
    HBITMAP GetPreviewBitmap() const;
};

//############################################################################
//############################################################################
//
//  class CTaskpadFramePtr
//
//  PURPOSE: holds a pointer to the taskpad frame.
//           If multiple base classes inherit from this class, declare this
//           class to be a static base.
//
//############################################################################
//############################################################################
class CTaskpadFramePtr
{
public:
    CTaskpadFramePtr(CTaskpadFrame * pTaskpadFrame): m_pTaskpadFrame(pTaskpadFrame){}
protected:
    // attributes
    CTaskpadFrame *             PTaskpadFrame() const   { return (m_pTaskpadFrame); }
    CConsoleTaskpad *           PConsoleTaskpad()       { return PTaskpadFrame()->PConsoleTaskpad();}
private:
    CTaskpadFrame *             m_pTaskpadFrame;
};

//############################################################################
//############################################################################
//
//  class CTaskpadStyleBase
//
//############################################################################
//############################################################################
class CTaskpadStyleBase:public virtual CTaskpadFramePtr
{
    typedef CTaskpadStyleBase ThisClass;

    static CTaskpadStyle    s_rgTaskpadStyle[];

    WTL::CStatic            m_wndPreview;
    WTL::CComboBox          m_wndSizeCombo;

public:
    CTaskpadStyleBase(CTaskpadFrame * pTaskpadFrame);

protected:
    virtual HWND    HWnd()   =0;

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER(WM_INITDIALOG,                              OnInitDialog)
        COMMAND_HANDLER(IDC_Style_VerticalList,     BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_HorizontalList,   BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_TasksOnly,        BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_TooltipDesc,      BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_TextDesc,         BN_CLICKED,     OnSettingChanged)
        COMMAND_HANDLER(IDC_Style_SizeCombo,        CBN_SELCHANGE,  OnSettingChanged)
    END_MSG_MAP();

    bool    Apply(); // must call this explicitly
    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    void    GetSettings (DWORD& dwOrientation, ListSize& eSize);
    void    UpdateControls ();
    int     FindStyle (DWORD dwOrientation, ListSize eSize);

};


//############################################################################
//############################################################################
//
//  class CTaskpadGeneralPage
//
//############################################################################
//############################################################################
class CTaskpadGeneralPage : public WTL::CPropertyPageImpl<CTaskpadGeneralPage>,
public CTaskpadStyleBase
{
    MMC::CEdit                  m_strName;
    MMC::CEdit                  m_strDescription;
    MMC::CEdit                  m_strTooltip;

public:
    typedef WTL::CPropertyPageImpl<CTaskpadGeneralPage> BC;
    typedef CTaskpadStyleBase BC2;
    enum { IDD = IDD_TASKPAD_GENERAL};

    //constructor/destructor
    CTaskpadGeneralPage(CTaskpadFrame * pTaskpadFrame);

public: // Notification handlers
    bool                        OnApply();

protected:
    BEGIN_MSG_MAP(CTaskpadGeneralPage)
        CHAIN_MSG_MAP_EX(BC2)           // This MUST be the first entry.
        MESSAGE_HANDLER(WM_INITDIALOG,                              OnInitDialog)
        CONTEXT_HELP_HANDLER()
        COMMAND_ID_HANDLER(IDC_Options,                             OnOptions)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASKPAD_GENERAL);

    // for the base classes
    virtual HWND    HWnd()   {return m_hWnd;}

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnOptions       (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

//############################################################################
//############################################################################
//
//  class CTaskpadWizardWelcomePage
//
//############################################################################
//############################################################################
class CTaskpadWizardWelcomePage :
    public CWizard97WelcomeFinishPage<CTaskpadWizardWelcomePage>
{
    typedef CTaskpadWizardWelcomePage                               ThisClass;
    typedef CWizard97WelcomeFinishPage<CTaskpadWizardWelcomePage>   BaseClass;

public:
    // Construction/Destruction
    CTaskpadWizardWelcomePage() {}

public:
    // Dialog data
    enum { IDD = IDD_TASKPAD_WIZARD_WELCOME};

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,    OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool    OnSetActive();
    bool    OnKillActive();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
};

//############################################################################
//############################################################################
//
//  class CTaskpadWizardFinishPage
//
//############################################################################
//############################################################################
class CTaskpadWizardFinishPage :
    public CWizard97WelcomeFinishPage<CTaskpadWizardFinishPage>
{
    typedef CTaskpadWizardFinishPage                                ThisClass;
    typedef CWizard97WelcomeFinishPage<CTaskpadWizardFinishPage>    BaseClass;

public:
    // Construction/Destruction
    CTaskpadWizardFinishPage(bool *pfStartTaskWizard)    {m_pfStartTaskWizard = pfStartTaskWizard;}

public:
    // Dialog data
    enum { IDD = IDD_TASKPAD_WIZARD_FINISH};

    BOOL OnSetActive();
    BOOL OnWizardFinish();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,                  OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
private:
    bool * m_pfStartTaskWizard;
};

//############################################################################
//############################################################################
//
//  class CTaskpadNamePage
//
//############################################################################
//############################################################################
class CTaskpadNamePage :
    public CWizard97InteriorPage<CTaskpadNamePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskpadNamePage                        ThisClass;
    typedef CWizard97InteriorPage<CTaskpadNamePage> BaseClass;

public:
    // Construction/Destruction
    CTaskpadNamePage(CTaskpadFrame * pTaskpadFrame);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASKPAD_WIZARD_NAME_PAGE,
        IDS_Title    = IDS_TaskpadWiz_NamePageTitle,
        IDS_Subtitle = IDS_TaskpadWiz_NamePageSubtitle,
    };

    BOOL OnSetActive();
    int  OnWizardNext();
    int  OnWizardBack();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

private:
    MMC::CEdit                  m_strName;
    MMC::CEdit                  m_strDescription;
};

//############################################################################
//############################################################################
//
//  class CTaskpadStylePage
//
//############################################################################
//############################################################################
class CTaskpadStylePage :
    public CWizard97InteriorPage<CTaskpadStylePage>,
    public CTaskpadStyleBase
{
    typedef CTaskpadStylePage                           ThisClass;
    typedef CWizard97InteriorPage<CTaskpadStylePage>    BaseClass;
    typedef CTaskpadStyleBase                           BC2;


public:
    // Construction/Destruction
    CTaskpadStylePage(CTaskpadFrame * pTaskpadFrame);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASKPAD_WIZARD_STYLE_PAGE,
        IDS_Title    = IDS_TaskpadWiz_StylePageTitle,
        IDS_Subtitle = IDS_TaskpadWiz_StylePageSubtitle,
    };

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass )
        CHAIN_MSG_MAP_EX(BC2)   // This must be the first entry.
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool    OnSetActive();
    bool    OnKillActive();

    // for the base classes
    virtual HWND    HWnd()   {return m_hWnd;}
};

//############################################################################
//############################################################################
//
//  class CTaskpadNodetypeBase
//
//############################################################################
//############################################################################
class CTaskpadNodetypeBase : public virtual CTaskpadFramePtr
{
    typedef  CTaskpadNodetypeBase   ThisClass;
    typedef  CTaskpadFramePtr       BC;

    bool m_bApplytoNodetype;
    bool m_bSetDefaultForNodetype;

protected:
    virtual HWND    HWnd()   =0;

public:
    CTaskpadNodetypeBase(CTaskpadFrame *pTaskpadFrame);


    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER(WM_INITDIALOG,                              OnInitDialog)
        COMMAND_HANDLER (IDC_UseForSimilarNodes,    BN_CLICKED, OnUseForNodetype)
        COMMAND_HANDLER (IDC_DontUseForSimilarNodes,BN_CLICKED, OnDontUseForNodetype)
        COMMAND_HANDLER (IDC_SetDefaultForNodetype, BN_CLICKED, OnSetAsDefault)
    END_MSG_MAP();

    bool    OnApply();
    void    EnableControls();
    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnUseForNodetype    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDontUseForNodetype(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSetAsDefault      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

//############################################################################
//############################################################################
//
//  class CTaskpadNodetypePage
//
//############################################################################
//############################################################################
class CTaskpadNodetypePage :
    public CWizard97InteriorPage<CTaskpadNodetypePage>,
    public CTaskpadNodetypeBase
{
    typedef CTaskpadNodetypePage                        ThisClass;
    typedef CWizard97InteriorPage<CTaskpadNodetypePage> BaseClass;
    typedef CTaskpadNodetypeBase                        BC2;


protected:
    virtual HWND    HWnd()   {return m_hWnd;}

public:
    enum
    {
        IDD          = IDD_TASKPAD_WIZARD_NODETYPE_PAGE,
        IDS_Title    = IDS_TaskpadWiz_NodeTypePageTitle,
        IDS_Subtitle = IDS_TaskpadWiz_NodeTypePageSubtitle,
    };

    CTaskpadNodetypePage(CTaskpadFrame *pTaskpadFrame);

    BEGIN_MSG_MAP( ThisClass )
        CHAIN_MSG_MAP_EX(BC2)   // This must be the first entry.
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool OnApply()      {return BC2::OnApply();}
};


//############################################################################
//############################################################################
//
//  class CTaskpadOptionsDlg
//
//############################################################################
//############################################################################

#include <pshpack8.h>       // for Win64

class CTaskpadOptionsDlg : public CDialogBase<CTaskpadOptionsDlg>,
public CTaskpadNodetypeBase
{
    typedef CTaskpadOptionsDlg              ThisClass;
    typedef CDialogBase<CTaskpadOptionsDlg> BaseClass;
    typedef CTaskpadNodetypeBase            BC4;

public:
    enum { IDD = IDD_TASKPAD_ADVANCED };

    //constructor/destructor
    CTaskpadOptionsDlg(CTaskpadFrame* pTaskpadFrame);
   ~CTaskpadOptionsDlg();

protected:
    BEGIN_MSG_MAP(ThisClass)
        CONTEXT_HELP_HANDLER()

        //CHAIN_MSG_MAP_EX(BC3)           // This MUST be the second entry.
        CHAIN_MSG_MAP   (BC4)           // This MUST be the third entry.
        CHAIN_MSG_MAP   (BaseClass)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASKPAD_ADVANCED);

    virtual HWND    HWnd()     {return m_hWnd;} // for the base classes.
    virtual LRESULT OnInitDialog   (HWND hwndFocus, LPARAM lParam, BOOL& bHandled);
    virtual bool    OnApply        ();
    void            EnableControls();
};

#include <poppack.h>        // for Win64


//############################################################################
//############################################################################
//
//  class CTaskPropertiesBase
//
//############################################################################
//############################################################################

typedef std::map<int, CConsoleTask>           IntToTaskMap;


class CTaskPropertiesBase :
    public CContextMenuVisitor, public virtual CTaskpadFramePtr
{
public:
    CTaskPropertiesBase(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

protected:
    virtual IntToTaskMap &  GetTaskMap()   =0;
    virtual WTL::CListBox&  GetListBox()   =0;

protected:
    LRESULT OnCommandListSelChange  (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    virtual SC      ScOnVisitContextMenu(CMenuItem &menuItem);

    CScopeTree *    PScopeTree()    const       { return (PTaskpadFrame()->PScopeTree()); }
    CNode *         PNodeTarget()   const       { return (PTaskpadFrame()->PNodeTarget()); }
    bool            FCookieValid()  const       { return (PTaskpadFrame()->FCookieValid()); }
    LPARAM          Cookie()        const       { return (PTaskpadFrame()->Cookie()); }
    CConsoleTask &  ConsoleTask()   const       { return *m_pTask;}

private:
    CConsoleTask *          m_pTask;
    const bool              m_fNew;
    IContextMenuCallbackPtr m_spContextMenuCallback;
};

//############################################################################
//############################################################################
//
//  class CTasksListDialog
//
//############################################################################
//############################################################################
template <class T>
class CTasksListDialog : public WTL::CPropertyPageImpl<T> // do NOT inherit from CTaskpadFramePtr.
{
public:
    typedef CTasksListDialog                    ThisClass;
    typedef WTL::CPropertyPageImpl<T>           BC;
private:
    typedef CConsoleTaskpad::TaskIter TaskIter;
    CNode *                 PNodeTarget()           {return PTaskpadFrame()->PNodeTarget();}
    CConsoleTaskpad *       PConsoleTaskpad()       {return PTaskpadFrame()->PConsoleTaskpad();}

    std::map<int, TaskIter> m_mapTaskIterators;
    std::map<int, TaskIter> & MapTaskIterators(){return m_mapTaskIterators;}

    WTL::CButton            m_buttonNewTask;
    WTL::CButton            m_buttonRemoveTask;
    WTL::CButton            m_buttonModifyTask;
    WTL::CButton            m_buttonMoveUp;
    WTL::CButton            m_buttonMoveDown;

    WTL::CListViewCtrl      m_listboxTasks;
    WTL::CListViewCtrl *    PListBoxTasks()         {return &m_listboxTasks;}

    int                     GetCurSel();

    bool                    m_bDisplayProperties;   // should task properties be displayed?

    bool                    m_bNewTaskOnInit;       // display the NewTask dialog on init.
    bool                    FNewTaskOnInit()        {return m_bNewTaskOnInit;}
public:
    //constructor/destructor
    CTasksListDialog(CTaskpadFrame * pTaskpadFrame, bool bNewTaskOnInit, bool bDisplayProperties) ;

protected:
    BEGIN_MSG_MAP(CTasksPage)
        COMMAND_ID_HANDLER(IDC_NEW_TASK_BT, OnNewTask)
        COMMAND_ID_HANDLER(IDC_REMOVE_TASK, OnRemoveTask)
        COMMAND_ID_HANDLER(IDC_MODIFY,      OnTaskProperties)
        COMMAND_ID_HANDLER(IDC_MOVE_UP,     OnMoveUp)
        COMMAND_ID_HANDLER(IDC_MOVE_DOWN,   OnMoveDown)
        NOTIFY_HANDLER    (IDC_LIST_TASKS,  NM_CUSTOMDRAW,   OnCustomDraw)
        NOTIFY_HANDLER    (IDC_LIST_TASKS,  LVN_ITEMCHANGED, OnTaskChanged)
        NOTIFY_HANDLER    (IDC_LIST_TASKS,  NM_DBLCLK,       OnTaskProperties)
        MESSAGE_HANDLER   (WM_INITDIALOG,   OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASKS);

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnNewTask();
    LRESULT OnNewTask(       WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled ) {return OnNewTask();}
    LRESULT OnRemoveTask(    WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveUp(        WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveDown(      WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnTaskProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled ) {OnTaskProperties(); return 0;}
    LRESULT OnTaskProperties(int id, LPNMHDR pnmh, BOOL& bHandled )                     {OnTaskProperties(); return 0;}
    LRESULT OnCustomDraw(    int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnTaskChanged(   int id, LPNMHDR pnmh, BOOL& bHandled );
    void    OnTaskProperties();


    // operations
    LRESULT DrawItem(NMCUSTOMDRAW *pnmcd);
    void    UpdateTaskListbox(TaskIter taskIteratorSelected);
    void    EnableButtons();
    void    EnableButtonAndCorrectFocus( WTL::CButton& button, BOOL bEnable );

private:
    CTaskpadFrame *             PTaskpadFrame()         { return m_pTaskpadFrame;}
    CTaskpadFrame *             m_pTaskpadFrame;
};


//############################################################################
//############################################################################
//
//  class CTasksPage
//
//############################################################################
//############################################################################

class CTasksPage : public CTasksListDialog<CTasksPage>, public virtual CTaskpadFramePtr
{
public:
    typedef CTasksListDialog<CTasksPage> BC;
    enum { IDD = IDD_TASKS};

    //constructor/destructor
    CTasksPage(CTaskpadFrame * pTaskpadFrame, bool bNewTaskOnInit)
    : BC(pTaskpadFrame, bNewTaskOnInit, true), CTaskpadFramePtr(pTaskpadFrame) {}
};


//############################################################################
//############################################################################
//
//  class CTaskWizardWelcomePage
//
//############################################################################
//############################################################################
class CTaskWizardWelcomePage :
    public CWizard97WelcomeFinishPage<CTaskWizardWelcomePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardWelcomePage                              ThisClass;
    typedef CWizard97WelcomeFinishPage<CTaskWizardWelcomePage>  BaseClass;

public:
    // Construction/Destruction
    CTaskWizardWelcomePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew)
        : CTaskpadFramePtr(pTaskpadFrame){}

public:
    // Dialog data
    enum { IDD = IDD_TASK_WIZARD_WELCOME};

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,    OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    bool    OnSetActive();
    bool    OnKillActive();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
};

//############################################################################
//############################################################################
//
//  class CTaskWizardFinishPage
//
//############################################################################
//############################################################################
class CTaskWizardFinishPage :
    public CTasksListDialog<CTaskWizardFinishPage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardFinishPage                      ThisClass;
    typedef CTasksListDialog<CTaskWizardFinishPage>    BaseClass;

public:
    // Construction/Destruction
    CTaskWizardFinishPage(CTaskpadFrame * pTaskpadFrame,
                          CConsoleTask & consoleTask, bool *pfRestartTaskWizard);

public:
    // Dialog data
    enum { IDD = IDD_TASK_WIZARD_FINISH};

    BOOL OnWizardFinish();
    int  OnWizardBack();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,                  OnInitDialog)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();
    BOOL    OnSetActive();
    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
private:
    CTaskpadFrame    m_taskpadFrameTemp;                   // for the list dialog
    CConsoleTaskpad  m_consoleTaskpadTemp;                 //
    bool *        m_pfRestartTaskWizard;
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
};


//############################################################################
//############################################################################
//
//  class CTaskWizardTypePage
//
//############################################################################
//############################################################################
class CTaskWizardTypePage :
    public CWizard97InteriorPage<CTaskWizardTypePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardTypePage                         ThisClass;
    typedef CWizard97InteriorPage<CTaskWizardTypePage>  BaseClass;

public:
    // Construction/Destruction
    CTaskWizardTypePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASK_WIZARD_TYPE_PAGE,
        IDS_Title    = IDS_TaskWiz_TypePageTitle,
        IDS_Subtitle = IDS_TaskWiz_TypePageSubtitle,
    };

    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,       OnInitDialog)
        COMMAND_ID_HANDLER(IDC_MENU_TASK,    OnMenuTask)
        COMMAND_ID_HANDLER(IDC_CMDLINE_TASK, OnCmdLineTask)
        COMMAND_ID_HANDLER(IDC_NAVIGATION_TASK, OnFavoriteTask)
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    LRESULT OnInitDialog ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMenuTask   ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnCmdLineTask( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnFavoriteTask(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
};


//############################################################################
//############################################################################
//
//  class CTaskNamePage
//
//############################################################################
//############################################################################
class CTaskNamePage : public WTL::CPropertyPageImpl<CTaskNamePage>,
public virtual CTaskpadFramePtr
{
    typedef CTaskNamePage                           ThisClass;
    typedef WTL::CPropertyPageImpl<CTaskNamePage>   BaseClass;

public:
    // Construction/Destruction
    CTaskNamePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

public:
    // Dialog data
    enum { IDD     = IDD_TASK_PROPS_NAME_PAGE,
           IDD_WIZ = IDD_TASK_WIZARD_NAME_PAGE };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack();
    int  OnWizardNext();

protected:
    BEGIN_MSG_MAP( ThisClass );
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASK_PROPS_NAME_PAGE);

private:
    // Implementation
    BOOL SetTaskName(bool fCheckIfOK);
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}

	bool m_fRunAsWizard;
};

class CTaskNameWizardPage: public CTaskNamePage
{
    typedef CTaskNamePage BC;
public:
    CTaskNameWizardPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew) :
        CTaskpadFramePtr(pTaskpadFrame),
        BC(pTaskpadFrame, consoleTask, fNew)
    {
        m_psp.pszTemplate = MAKEINTRESOURCE(BC::IDD_WIZ);

        /*
         * Wizard97-style pages have titles, subtitles and header bitmaps
         */
        VERIFY (m_strTitle.   LoadString(GetStringModule(), IDS_TaskWiz_NamePageTitle));
        VERIFY (m_strSubtitle.LoadString(GetStringModule(), IDS_TaskWiz_NamePageSubtitle));

        m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle    = m_strTitle.data();
        m_psp.pszHeaderSubTitle = m_strSubtitle.data();
    }

private:
    tstring m_strTitle;
    tstring m_strSubtitle;
};

//############################################################################
//############################################################################
//
//  class CTaskWizardMenuPage
//
//############################################################################
//############################################################################
class CTaskWizardMenuPage :
    public CWizard97InteriorPage<CTaskWizardMenuPage>,
    public CTaskPropertiesBase
{
    typedef CTaskWizardMenuPage                         ThisClass;
    typedef CWizard97InteriorPage<CTaskWizardMenuPage>  BaseClass;
    typedef CTaskPropertiesBase                         BC2;

public:
    // Construction/Destruction
    CTaskWizardMenuPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);

public:
    // Dialog data
    enum
    {
        IDD          = IDD_TASK_WIZARD_MENU_PAGE,
        IDS_Title    = IDS_TaskWiz_MenuPageTitle,
        IDS_Subtitle = IDS_TaskWiz_MenuPageSubtitle,
    };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack()  {return IDD_TASK_WIZARD_TYPE_PAGE;}
    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_HANDLER    (IDC_CommandList,           LBN_SELCHANGE,   BC2::OnCommandListSelChange)
        NOTIFY_HANDLER     (IDC_ScopeTree,             TVN_SELCHANGED,  OnScopeItemChanged)
        NOTIFY_HANDLER     (IDC_ResultList,            LVN_ITEMCHANGED, OnResultItemChanged)
        COMMAND_HANDLER    (IDC_TASK_SOURCE_COMBO,     CBN_SELCHANGE,   OnSettingChanged)
        CHAIN_MSG_MAP(BaseClass)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP();

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnScopeItemChanged (int id, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnResultItemChanged(int id, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnSettingChanged(  WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    void    EnableWindows();

    virtual IntToTaskMap &  GetTaskMap()   { return m_TaskMap;}
    virtual WTL::CListBox&  GetListBox()   { return m_wndCommandListbox;}
    void    InitResultView (CNode* pRootNode);
    void    ShowWindow(HWND hWnd, bool bShowWindow);
    void    SelectFirstResultItem(bool bSelect = true);
    void    OnSettingsChanged();

private:
    struct _TaskSource
    {
        int              idsName;
        eConsoleTaskType type;
    };


    // attributes
    static _TaskSource              s_rgTaskSource[];
    IntToTaskMap                    m_TaskMap;
    WTL::CListBox                   m_wndCommandListbox;
    CMTBrowserCtrl                  m_wndScopeTree;
    WTL::CComboBox                  m_wndSourceCombo;

    CMirrorListView                 m_wndResultView;
    CTempAMCView                    m_MirroredView;
    CNode*                          m_pMirrorTargetNode;
};

//############################################################################
//############################################################################
//
//  class CTaskWizardFavoritePage
//
//############################################################################
//############################################################################
class CTaskWizardFavoritePage :
    public CWizard97InteriorPage<CTaskWizardFavoritePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskWizardFavoritePage                         ThisClass;
    typedef CWizard97InteriorPage<CTaskWizardFavoritePage>  BaseClass;
    enum { IDC_FavoritesTree = 16384}; // this shouldn't occur on the page.

public:
    // Construction/Destruction
    CTaskWizardFavoritePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);
    ~CTaskWizardFavoritePage();

public:
    // Dialog data
    enum
    {
       IDD          = IDD_TASK_WIZARD_FAVORITE_PAGE,
       IDD_WIZ      = IDD_TASK_WIZARD_FAVORITE_PAGE,
       IDS_Title    = IDS_TaskWiz_FavoritePage_Title,
       IDS_Subtitle = IDS_TaskWiz_FavoritePage_Subtitle,
    };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack();
    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        MESSAGE_HANDLER(WM_INITDIALOG,              OnInitDialog)
        MESSAGE_HANDLER(MMC_MSG_FAVORITE_SELECTION, OnItemChanged)
        CHAIN_MSG_MAP(BaseClass)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP();

    LRESULT OnInitDialog  (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnItemChanged (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSelChanged  (    int id, LPNMHDR pnmh, BOOL& bHandled );
    void    SetItemSelected(bool bItemSelected);

private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}

    bool m_bItemSelected;
};



//############################################################################
//############################################################################
//
//  class CTaskCmdLinePage
//
//############################################################################
//############################################################################
class CTaskCmdLinePage :
    public CWizard97InteriorPage<CTaskCmdLinePage>,
    public virtual CTaskpadFramePtr
{
    typedef CTaskCmdLinePage                        ThisClass;
    typedef CWizard97InteriorPage<CTaskCmdLinePage> BaseClass;

public:
    // Construction/Destruction
    CTaskCmdLinePage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew);
    ~CTaskCmdLinePage();

public:
    // Dialog data
    enum
    {
       IDD          = IDD_TASK_PROPS_CMDLINE_PAGE,
       IDD_WIZ      = IDD_TASK_WIZARD_CMDLINE_PAGE,
       IDS_Title    = IDS_TaskWiz_CmdLinePageTitle,
       IDS_Subtitle = IDS_TaskWiz_CmdLinePageSubtitle,
    };

    BOOL OnSetActive();
    BOOL OnKillActive();
    int  OnWizardBack()  {return IDD_TASK_WIZARD_TYPE_PAGE;}
    int  OnWizardNext();

    // Implementation
protected:
    BEGIN_MSG_MAP( ThisClass );
        COMMAND_ID_HANDLER (IDC_BrowseForCommand,                       OnBrowseForCommand)
        COMMAND_ID_HANDLER (IDC_BrowseForWorkingDir,                    OnBrowseForWorkingDir)
        COMMAND_ID_HANDLER (IDC_BrowseForArguments,                     OnBrowseForArguments)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BaseClass)
    END_MSG_MAP();

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_TASK_PROPS_CMDLINE_PAGE);

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnBrowseForCommand      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnBrowseForWorkingDir   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnBrowseForArguments    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    // attributes
    CConsoleTask  * m_pConsoleTask;
    CConsoleTask  & ConsoleTask()   const       { return *m_pConsoleTask;}
    WTL::CButton    m_wndRightArrowButton;
    HBITMAP         m_hBitmapRightArrow;
    CMyComboBox     m_wndWindowStateCombo;
    static const int const  s_rgidWindowStates[];

};

class CTaskCmdLineWizardPage: public CTaskCmdLinePage
{
    typedef CTaskCmdLinePage BC;
public:
    CTaskCmdLineWizardPage(CTaskpadFrame * pTaskpadFrame, CConsoleTask & consoleTask, bool fNew) :
        CTaskpadFramePtr(pTaskpadFrame),
        CTaskCmdLinePage(pTaskpadFrame, consoleTask, fNew)
    {
        m_psp.pszTemplate = MAKEINTRESOURCE(BC::IDD_WIZ);
    }
};

//############################################################################
//############################################################################
//
//  class CTaskPropertySheet
//
//############################################################################
//############################################################################
class CTaskPropertySheet : public WTL::CPropertySheet
{
public:
    CTaskPropertySheet(HWND hWndParent, CTaskpadFrame * pTaskpadFrame, CConsoleTask &consoleTask, bool fNew);
    CConsoleTask &  ConsoleTask()   {return m_consoleTask;}

private:
    CConsoleTask      m_consoleTask;   // the task that the wizard creates.
    CTaskNamePage     m_namePage;
    CTaskCmdLinePage  m_cmdLinePage;
    CTaskSymbolDlg    m_taskSymbolDialog;
};

//############################################################################
//############################################################################
//
//  class CTaskWizard       // similar to CTaskPropertySheet
//
//############################################################################
//############################################################################
class CTaskWizard
{
public:
    CTaskWizard()   {}

    HRESULT         Show(HWND hWndParent, CTaskpadFrame * pTaskpadFrame,
                          bool fNew, bool *pfRestartTaskWizard);
    CConsoleTask &  ConsoleTask()   {return m_consoleTask;}

private:
    CConsoleTask   m_consoleTask;   // the task that the wizard creates.
};

//############################################################################
//############################################################################
//
//  class CTaskpadPropertySheet
//
//############################################################################
//############################################################################

class CTaskpadPropertySheet : public WTL::CPropertySheet, public CTaskpadFrame
{
    typedef WTL::CPropertySheet BC;
public:
    enum eReason    // the reason for bringing up the sheet
    {
        eReason_PROPERTIES,
        eReason_NEWTASK
    };

private:
    // Attributes:

    CTaskpadGeneralPage             m_proppTaskpadGeneral;
    CTaskpadGeneralPage *           PproppTaskpadGeneral()      {return &m_proppTaskpadGeneral;}
    CTasksPage                      m_proppTasks;
    CTasksPage          *           PproppTasks()               {return &m_proppTasks;}


    bool                            m_fInsertNode;              // TRUE if the taskpad node should be inserted when the sheet is closed.
    bool                            FInsertNode()               {return m_fInsertNode;}

    bool                            m_fNew;                     // is this a new taskpad?
    bool                            FNew()                      {return m_fNew;}

    eReason                         m_eReason;                  // why was the sheet created?
    eReason                         Reason()                    {return m_eReason;}

    tstring                         m_strTitle;

public:
    //constructor/destructor
    CTaskpadPropertySheet(CNode *pNodeTarget, CConsoleTaskpad & rConsoleTaskPad, bool fNew,
                          LPARAM lparamSelectedNode, bool fLParamValid, CViewData *pViewData,
                          eReason reason = eReason_PROPERTIES);
    ~CTaskpadPropertySheet();

    // operations
    int                             DoModal();

};


//############################################################################
//############################################################################
//
//  class CTaskpadWizard       // similar to CTaskpadPropertySheet
//
//############################################################################
//############################################################################
class CTaskpadWizard : public CTaskpadFrame
{
    typedef CTaskpadFrame BC;
public:
    CTaskpadWizard(CNode *pNodeTarget, CConsoleTaskpad & rConsoleTaskPad, bool fNew,
                          LPARAM lparamSelectedNode, bool fLParamValid, CViewData *pViewData);

    HRESULT         Show(HWND hWndParent, bool *pfStartTaskWizard);
};


//############################################################################
//############################################################################
//
//  class CExtendPropSheetImpl
//
//############################################################################
//############################################################################
class CExtendPropSheetImpl :
    public IExtendPropertySheet2,
    public CComObjectRoot
{
public:
    void AddPage (HPROPSHEETPAGE hPage);
    void SetHeaderID (int nHeaderID);
    void SetWatermarkID (int nWatermarkID);

protected:
    BEGIN_COM_MAP(CExtendPropSheetImpl)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    END_COM_MAP()

    // IExtendPropertySheet2
    STDMETHOD(CreatePropertyPages)(IPropertySheetCallback* pPSC, LONG_PTR handle, IDataObject* pDO);
    STDMETHOD(QueryPagesFor)(IDataObject* pDO);
    STDMETHOD(GetWatermarks)(IDataObject* pDO, HBITMAP* phbmWatermark, HBITMAP* phbmHeader, HPALETTE* phPal, BOOL* pbStretch);

private:
    std::vector<HANDLE> m_vPages;
    int					m_nWatermarkID;
    int					m_nHeaderID;
};

typedef CComObject<CExtendPropSheetImpl> CExtendPropSheet;


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////              INLINES                 ///////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

namespace MMC
{
inline void
CEdit::Initialize(CWindow *pwndParent, int idEdit, int cchMax, LPCTSTR sz)
{
    Attach (pwndParent->GetDlgItem( idEdit ));
    ASSERT( m_hWnd != NULL );

    if(sz)
        SetWindowText( sz );

    if(cchMax >=0)
        SetLimitText( 128 );
}

tstring GetWindowText (HWND hwnd);

}; // namespace MMC


void PreventMFCAutoCenter (MMC_ATL::CWindow* pwnd);
HBITMAP LoadSysColorBitmap (HINSTANCE hInst, UINT id, bool bMono = false);

#include <poppack.h>

#endif /* TASKUI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\toolbar.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       toolbar.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//////////////////////////////////////////////////////////////////////////////
// IToolbar implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CToolbar);

CToolbar::CToolbar()
{
    m_pControlbar = NULL;
    m_pToolbarIntf  = NULL;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CToolbar);
}

CToolbar::~CToolbar()
{
    DECLARE_SC(sc, _T("CToolbar::~CToolbar"));

    // Destroy the toolbar UI.
	if (m_pToolbarIntf)
	{
		sc = m_pToolbarIntf->ScDelete(this);
		if (sc)
	        sc.TraceAndClear();

	    m_pToolbarIntf  = NULL;
	}

    // Controlbar has a reference to this object, ask it
    // to stop referencing this object.
    if (m_pControlbar)
    {
        m_pControlbar->DeleteFromToolbarsList(this);
        m_pControlbar = NULL;
    }

    DEBUG_DECREMENT_INSTANCE_COUNTER(CToolbar);
}

//+-------------------------------------------------------------------
//
//  Member:     AddBitmap
//
//  Synopsis:   Add bitmaps for given toolbar.
//
//  Arguments:
//              [nImages] - Number of bitmap images.
//              [hbmp]    - Handle to the bitmap.
//              [cxSize]  - Size of the bitmap.
//              [cySize]  - Size of the bitmap.
//              [crMask]  - color mask.
//
//  Returns:    HRESULT
//
// Note: We support only 16x16 bitmaps for toolbars.
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::AddBitmap(int nImages, HBITMAP hbmp, int cxSize,
                                 int cySize, COLORREF crMask)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::AddBitmap"));

    if (hbmp == NULL || nImages < 1 || cxSize < 1 || cySize < 1)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    // Note: We support only 16x16 bitmaps for toolbars.
    if (cxSize != BUTTON_BITMAP_SIZE || cySize != BUTTON_BITMAP_SIZE)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Bitmap size"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScAddBitmap(this, nImages, hbmp, crMask);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     AddButtons
//
//  Synopsis:   Add buttons for given toolbar.
//
//  Arguments:
//              [nButtons]  - Number of buttons.
//              [lpButtons] - Array of MMCBUTTONS to be added.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::AddButtons(int nButtons, LPMMCBUTTON lpButtons)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::AddButtons"));

    if ( (lpButtons == NULL) || (nButtons < 1) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScAddButtons(this, nButtons, lpButtons);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     InsertButton
//
//  Synopsis:   Add buttons for given toolbar at given index.
//
//  Arguments:
//              [nButtons] - Index at which this button is to be added.
//              [lpButton] - Ptr to MMCBUTTON to be added.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::InsertButton(int nIndex, LPMMCBUTTON lpButton)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::InsertButton"));

    if ( (lpButton == NULL) || (nIndex < 0) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Args"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScInsertButton(this, nIndex, lpButton);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteButton
//
//  Synopsis:   Delete the button at given index.
//
//  Arguments:
//              [nIndex] - Index of the button to be deleted.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::DeleteButton(int nIndex)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::DeleteButton"));

    if (nIndex < 0)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid index"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScDeleteButton(this, nIndex);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     GetTBStateFromMMCButtonState
//
//  Synopsis:   We use MMC_BUTTON_STATE for Set/Get Button States &
//              use TBSTATE for Insert/Add Buttons.
//              This method helps Get/Set ButtonState methods to translate
//              the MMC_BUTTON_STATEs to TBSTATE so that conui deals only
//              with TBSTATE.
//
//  Arguments:  [nState] - MMC_BUTTON_STATE to be transformed.
//
//  Returns:    TBSTATE value.
//
//--------------------------------------------------------------------
BYTE CToolbar::GetTBStateFromMMCButtonState(MMC_BUTTON_STATE nState)
{
    switch (nState)
    {
    case ENABLED:
        return TBSTATE_ENABLED;
        break;

    case CHECKED:
        return TBSTATE_CHECKED;
        break;

    case HIDDEN:
        return TBSTATE_HIDDEN;
        break;

    case INDETERMINATE:
        return TBSTATE_INDETERMINATE;
        break;

    case BUTTONPRESSED:
        return TBSTATE_PRESSED;
        break;

    default:
        ASSERT(FALSE); // Invalid option
        return 0;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     GetButtonState
//
//  Synopsis:   Is the given state of a button set or not.
//
//  Arguments:
//              [idCommand] - Command id of the button.
//              [nState]    - State needed.
//              [pbState]   - Is the above state set or reset.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::GetButtonState(int idCommand, MMC_BUTTON_STATE nState,
                                      BOOL* pbState)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::GetButtonState"));

    if (pbState == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL pointer"), sc);
        return sc.ToHr();
    }

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScGetButtonState(this, idCommand,
                                          GetTBStateFromMMCButtonState(nState),
                                          pbState);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetButtonState
//
//  Synopsis:   Modify  the given state of a button.
//
//  Arguments:
//              [idCommand] - Command id of the button.
//              [nState]    - State to be modified.
//              [bState]    - Set or Reset the state.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CToolbar::SetButtonState(int idCommand, MMC_BUTTON_STATE nState,
                                      BOOL bState)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IToolbar::SetButtonState"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScSetButtonState(this, idCommand,
                                          GetTBStateFromMMCButtonState(nState),
                                          bState);
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:     ScAttach
//
//  Synopsis:   Attach this toolbar to UI.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScAttach()
{
    DECLARE_SC(sc, _T("CToolbar::ScAttach"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScAttach(this);
    if (sc)
        return sc.ToHr();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetach
//
//  Synopsis:   Detach this toolbar from the UI.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScDetach()
{
    DECLARE_SC(sc, _T("CToolbar::ScDetach"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pToolbarIntf->ScDetach(this);
    if (sc)
        return sc.ToHr();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScShow
//
//  Synopsis:   Show/Hide this toolbar.
//
//  Arguments:
//            [bShow] - Show or Hide.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScShow(BOOL bShow)
{
    DECLARE_SC(sc, _T("CToolbar::ScShow"));

    sc = ScCheckPointers(m_pToolbarIntf, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = (bShow ? m_pToolbarIntf->ScAttach(this) : m_pToolbarIntf->ScDetach(this));
    if (sc)
        return sc.ToHr();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifyToolBarClick
//
//  Synopsis:   Notify the snapin about a tool button is click.
//
//  Arguments:  [pNode]             - CNode* that owns result pane.
//              [bScope]            - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [nID]               - Command ID of the tool button clicked.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CToolbar::ScNotifyToolBarClick(HNODE hNode, bool bScope,
                                     LPARAM lResultItemCookie, UINT nID)
{
    DECLARE_SC(sc, _T("CToolbar::ScNotifyToolbarClick"));

    if (NULL == m_pControlbar)
        return (sc = E_UNEXPECTED);

    sc = m_pControlbar->ScNotifySnapinOfToolBtnClick(hNode, bScope, lResultItemCookie, nID);
    if (sc)
        return sc;

    return(sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CToolbar::ScAMCViewToolbarsBeingDestroyed
//
//  Synopsis:    The CAMCViewToolbars object is going away, do not
//               reference that object anymore.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CToolbar::ScAMCViewToolbarsBeingDestroyed ()
{
    DECLARE_SC(sc, _T("CToolbar::ScAMCViewToolbarsBeingDestroyed"));

    m_pToolbarIntf = NULL;

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\toolbar.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       toolbar.h
//
//--------------------------------------------------------------------------

#ifndef _TOOLBAR_H_
#define _TOOLBAR_H_

#include "toolbars.h"

#ifdef DBG
#include "ctrlbar.h"  // Needed for GetSnapinName()
#endif

#define  BUTTON_BITMAP_SIZE 16

//forward prototypes
class CControlbar;
class CMMCToolbarIntf;
class CToolbarNotify;

//+-------------------------------------------------------------------
//
//  class:     CToolbar
//
//  Purpose:   The IToolbar implementation this is owned
//             by the CControlbar and talks to the toolbar UI
//             using the CMMCToolbarIntf interface to manipulate the toolbar.
//             This object lives as long as snapin holds the COM reference.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CToolbar : public IToolbar,
                 public CComObjectRoot,
                 public CToolbarNotify

{
public:
    CToolbar();
    ~CToolbar();

private:
    CToolbar(const CToolbar& toolBar);
    BYTE GetTBStateFromMMCButtonState(MMC_BUTTON_STATE nState);

public:
// ATL COM map
BEGIN_COM_MAP(CToolbar)
    COM_INTERFACE_ENTRY(IToolbar)
END_COM_MAP()


// IToolbar methods
public:
    STDMETHOD(AddBitmap)(int nImages, HBITMAP hbmp, int cxSize, int cySize, COLORREF crMask );
    STDMETHOD(AddButtons)(int nButtons, LPMMCBUTTON lpButtons);
    STDMETHOD(InsertButton)(int nIndex, LPMMCBUTTON lpButton);
    STDMETHOD(DeleteButton)(int nIndex);
    STDMETHOD(GetButtonState)(int idCommand, MMC_BUTTON_STATE nState, BOOL* pState);
    STDMETHOD(SetButtonState)(int idCommand, MMC_BUTTON_STATE nState, BOOL bState);

// Internal methods
public:
    SC ScShow(BOOL bShow);
    SC ScAttach();
    SC ScDetach();

    void SetControlbar(CControlbar* pControlbar)
    {
        m_pControlbar = pControlbar;
    }

    CControlbar*  GetControlbar(void)
    {
        return m_pControlbar;
    }

    CMMCToolbarIntf*   GetMMCToolbarIntf()
    {
        return m_pToolbarIntf;
    }

    void SetMMCToolbarIntf(CMMCToolbarIntf* pToolbarIntf)
    {
        m_pToolbarIntf = pToolbarIntf;
    }

#ifdef DBG     // Debug information.
public:
    LPCTSTR GetSnapinName ()
    {
        if (m_pControlbar)
            return m_pControlbar->GetSnapinName();

        return _T("Unknown");
    }
#endif

public:
    // CToolbarNotify methods.
    virtual SC ScNotifyToolBarClick(HNODE hNode, bool bScope,
                                    LPARAM lParam, UINT nID);
    virtual SC ScAMCViewToolbarsBeingDestroyed();

private:
    CControlbar*     m_pControlbar;
    CMMCToolbarIntf* m_pToolbarIntf;

}; // class CToolbar

#endif  // _TOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\typeinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       typeinfo.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"


/***************************************************************************\
 *
 * METHOD:  COleCacheCleanupManager::GetSingletonObject
 *
 * PURPOSE: returns singe static object 
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    COleCacheCleanupManager& reference to static singleton
 *
\***************************************************************************/
COleCacheCleanupManager& COleCacheCleanupManager::GetSingletonObject()
{
    static COleCacheCleanupManager s_OleCleanupManager;
    return s_OleCleanupManager;
}

/***************************************************************************\
 *
 * METHOD:  COleCacheCleanupManager::ScReleaseCachedOleObjects
 *
 * PURPOSE: static function. forwards the call to the global object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC COleCacheCleanupManager::ScReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("COleCacheCleanupManager::ScReleaseCachedOleObjects"));

    sc = GetSingletonObject().ScFireEvent(COleCacheCleanupObserver::ScOnReleaseCachedOleObjects);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  COleCacheCleanupManager::AddObserver
 *
 * PURPOSE: static function. forwards the call to the global object
 *
 * PARAMETERS:
 *    COleCacheCleanupObserver * pObserver
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
void COleCacheCleanupManager::AddOleObserver(COleCacheCleanupObserver * pObserver)
{
    if (pObserver)
        GetSingletonObject().AddObserver(*pObserver);
}


/***************************************************************************\
 *
 * METHOD:  CMMCTypeInfoHolderWrapper::CMMCTypeInfoHolderWrapper
 *
 * PURPOSE: constructor. registers as observer to COleCacheCleanupManager
 *
 * PARAMETERS:
 *
\***************************************************************************/
CMMCTypeInfoHolderWrapper::CMMCTypeInfoHolderWrapper(CComTypeInfoHolder& rInfoHolder) :
m_rInfoHolder(rInfoHolder)
{
    COleCacheCleanupManager::AddOleObserver(this);
}

/***************************************************************************\
 *
 * METHOD:  CMMCTypeInfoHolderWrapper::ScOnReleaseCachedOleObjects
 *
 * PURPOSE: calls clear on CComTypeInfoHolder ensurin there is no cached 
 *          OLE references left
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCTypeInfoHolderWrapper::ScOnReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("ScOnReleaseCachedOleObjects"));

    DWORD_PTR dw = reinterpret_cast<DWORD_PTR>(&m_rInfoHolder);
    CComTypeInfoHolder::Cleanup(dw);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCComCacheCleanup::ReleaseCachedOleObjects
 *
 * PURPOSE: called fron CONUI side to inform that MMC is going to uninitialize ole
 *          and it's a good time to release all cached com objects
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCComCacheCleanup::ReleaseCachedOleObjects()
{
    DECLARE_SC(sc, TEXT("CMMCComCacheCleanup::ReleaseCachedOleObjects"));

    sc = COleCacheCleanupManager::ScReleaseCachedOleObjects();
    if  (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\verbs.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       verbs.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/9/1997   RaviR   Created
//____________________________________________________________________________
//


#include "stdafx.h"
#include "multisel.h"
#include "tasks.h"
#include "scopndcb.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef DBG
CTraceTag tagVerbs(TEXT("Verbs"), TEXT("Verbs"));
#endif


//############################################################################
//############################################################################
//
//  Implementation of class CConsoleVerbImpl
//
//############################################################################
//############################################################################

BYTE GetTBSTATE(MMC_BUTTON_STATE mmcState)
{
    switch (mmcState)
    {
    case ENABLED:       return TBSTATE_ENABLED;
    case CHECKED:       return TBSTATE_CHECKED;
    case HIDDEN:        return TBSTATE_HIDDEN;
    case INDETERMINATE: return TBSTATE_INDETERMINATE;
    case BUTTONPRESSED: return TBSTATE_PRESSED;
    default:
        ASSERT(0);
        return TBSTATE_ENABLED;
    }
}

EVerb GetEVerb(MMC_CONSOLE_VERB cVerb)
{
    switch (cVerb)
    {
    case MMC_VERB_OPEN:         return evOpen;
    case MMC_VERB_CUT:          return evCut;
    case MMC_VERB_COPY:         return evCopy;
    case MMC_VERB_PASTE:        return evPaste;
    case MMC_VERB_DELETE:       return evDelete;
    case MMC_VERB_PROPERTIES:   return evProperties;
    case MMC_VERB_RENAME:       return evRename;
    case MMC_VERB_REFRESH:      return evRefresh;
    case MMC_VERB_PRINT:        return evPrint;
    default:
        ASSERT(0 && "UNexpected");
        return evOpen;
    }
}

MMC_CONSOLE_VERB GetConsoleVerb(EVerb eVerb)
{
    switch (eVerb)
    {
    case evOpen:         return MMC_VERB_OPEN;
    case evCopy:         return MMC_VERB_COPY;
    case evCut:          return MMC_VERB_CUT;
    case evPaste:        return MMC_VERB_PASTE;
    case evDelete:       return MMC_VERB_DELETE;
    case evProperties:   return MMC_VERB_PROPERTIES;
    case evRename:       return MMC_VERB_RENAME;
    case evRefresh:      return MMC_VERB_REFRESH;
    case evPrint:        return MMC_VERB_PRINT;
    default:
        ASSERT(0 && "UNexpected");
        return MMC_VERB_OPEN;
    }
}


DEBUG_DECLARE_INSTANCE_COUNTER(CConsoleVerbImpl);

CConsoleVerbImpl::CConsoleVerbImpl()
    : m_DefaultVerb(MMC_VERB_OPEN), m_pVerbSet(NULL), m_bCutVerbDisabledBySnapin(false)
{
#ifdef DBG
    DEBUG_INCREMENT_INSTANCE_COUNTER(CConsoleVerbImpl);
    dbg_cRef_CConsoleVerbImpl = 0;
#endif
}


#ifdef DBG
ULONG CConsoleVerbImpl::InternalAddRef()
{
    ++dbg_cRef_CConsoleVerbImpl;
    return CComObjectRoot::InternalAddRef();
}
ULONG CConsoleVerbImpl::InternalRelease()
{
    --dbg_cRef_CConsoleVerbImpl;
    return CComObjectRoot::InternalRelease();
}
#endif // DBG


CConsoleVerbImpl::~CConsoleVerbImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CConsoleVerbImpl);
}


STDMETHODIMP
CConsoleVerbImpl::GetVerbState(
    MMC_CONSOLE_VERB eCmdID,
    MMC_BUTTON_STATE nState,
    BOOL* pbState)
{
    DECLARE_SC(sc, TEXT("CConsoleVerbImpl::GetVerbState"));
    sc = ScCheckPointers(pbState);
    if (sc)
        return sc.ToHr();

    LPCONSOLE_VERB_STATE pCS = GetConsoleVerbState(eCmdID);
    sc = ScCheckPointers(pCS, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    /*
     * Special case for cut verb:
     *
     * Pre MMC2.0 : Snapin never called IConsoleVerb::SetVerbState with cut verb
     * except with (cut, disable) state, to enable cut the Snapin has to enable
     * copy & delete verbs.
     *
     * MMC2.0 : snapin can enable/disable cut verb just like any other verb.
     * Then if hidden hide it.
     *
     * If snapin has enabled or disabled the cut verb then below BLOCK1 is
     * irrelevant, the BLOCK2 will override the value.
     * If snapin did not enable the cut verb but enabled copy & delete then
     * the block BLOCK2. set the cut verb appropriately.
     */

    // BLOCK1. Special case for MMC1.2 cut verb.
    if ( (eCmdID == MMC_VERB_CUT) && (!m_bCutVerbDisabledBySnapin) )
    {
        // Pre MMC2.0
        LPCONSOLE_VERB_STATE pCSDelete = GetConsoleVerbState(MMC_VERB_DELETE);
        LPCONSOLE_VERB_STATE pCSCopy = GetConsoleVerbState(MMC_VERB_COPY);
        sc = ScCheckPointers(pCSDelete, pCSCopy, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (TBSTATE_ENABLED & pCSCopy->GetState() & pCSDelete->GetState())
        {
            // Set Cut verb to be not hidden & enabled.
            pCS->SetState(pCS->GetState() & ~GetTBSTATE(HIDDEN));
            pCS->SetState(pCS->GetState() | GetTBSTATE(ENABLED));
        }
    }

    // BLOCK2. Get the given verbs state.
    *pbState = (pCS->GetState() & GetTBSTATE(nState)) ? TRUE : FALSE;

    return sc.ToHr();
}

STDMETHODIMP
CConsoleVerbImpl::SetVerbState(
    MMC_CONSOLE_VERB eCmdID,
    MMC_BUTTON_STATE nState,
    BOOL bState)
{
    LPCONSOLE_VERB_STATE pCS = GetConsoleVerbState(eCmdID);
    ASSERT(pCS != NULL);
    if (pCS == NULL)
        return E_FAIL;

    // If snapin has enabled/disabled cut verb note it.
    // Used by CConsoleVerbImpl::GetVerbState.
    if ( (MMC_VERB_CUT == eCmdID) && (nState & ENABLED) )
        m_bCutVerbDisabledBySnapin = (bState == FALSE);

    if (bState)
        pCS->SetState(pCS->GetState() | GetTBSTATE(nState));
    else
        pCS->SetState(pCS->GetState() & ~GetTBSTATE(nState));


    if (nState == HIDDEN && bState == TRUE)
    {
        pCS->SetHiddenBySnapin(true);
    }

    /*
     * If we're enabling, make sure the verb is not hidden.
     * We do this for compatibility.  For v1.0, the default state
     * for a verb was disabled and visible when it actually should
     * have been disabled and hidden.  Therefore, v1.0 snap-ins could
     * have written
     *
     *      pConsoleVerb->SetVerbState (verb, ENABLED, TRUE);
     *
     * and had an enabled, visible verb.  Now that we've fixed the
     * default state (bug 150874), we need to make sure v1.0 snap-ins
     * that wrote code like the above will still work as they used to.
     */
    if ((nState == ENABLED) && (bState == TRUE) && (!pCS->IsHiddenBySnapin()))
        pCS->SetState(pCS->GetState() & ~GetTBSTATE(HIDDEN));

    ASSERT(GetVerbSet() != NULL);
    if (GetVerbSet() != NULL)
        GetVerbSet()->Notify(this, eCmdID);

    return S_OK;
}

HRESULT CConsoleVerbImpl::SetDisabledAll(void)
{
    for(int i=0; i< evMax; i++)
        m_rgConsoleVerbStates[i].Disable();

	m_bCutVerbDisabledBySnapin = false;

    return S_OK;
}

STDMETHODIMP CConsoleVerbImpl::SetDefaultVerb(MMC_CONSOLE_VERB eCmdID)
{
    m_DefaultVerb = eCmdID;
    return S_OK;
}

LPCONSOLE_VERB_STATE CConsoleVerbImpl::GetConsoleVerbState(MMC_CONSOLE_VERB eCmdID)
{
    if( (eCmdID < MMC_VERB_FIRST) || (eCmdID > MMC_VERB_LAST) )
        return NULL;
    else
        return &m_rgConsoleVerbStates[eCmdID- MMC_VERB_FIRST];
}


//############################################################################
//############################################################################
//
//  Implementation of class CVerbSet
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CVerbSet);

/*+-------------------------------------------------------------------------*
 *
 * _QueryConsoleVerb
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CNode*         pNode :
 *    LPCONSOLEVERB* ppConsoleVerb :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT _QueryConsoleVerb(CNode* pNode, LPCONSOLEVERB* ppConsoleVerb)
{
    DECLARE_SC(sc, TEXT("::_QueryConsoleVerb"));
    sc = ScCheckPointers(pNode, ppConsoleVerb);
    if (sc)
        return sc.ToHr();

    *ppConsoleVerb = NULL;

    CComponent *pComponent = pNode->GetPrimaryComponent();
    sc = ScCheckPointers(pComponent, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IFramePrivate *pFrame = pComponent->GetIFramePrivate();
    sc = ScCheckPointers(pFrame, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = pFrame->QueryConsoleVerb(ppConsoleVerb);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSetBase::_GetVerbState
 *
 * PURPOSE:  Return the state of given verb. The state is in current
 *           IConsoleVerb ptr. Translate the states from this object
 *           into the SVerbState array.
 *
 * PARAMETERS:
 *    EVerb  ev :
 *
 * RETURNS:
 *    BYTE
 *
 *+-------------------------------------------------------------------------*/
BYTE CVerbSetBase::_GetVerbState(EVerb ev)
{
    if (m_rbVerbState[ev].bAskSnapin != 1)
        return m_rbVerbState[ev].nState;

    if (m_spConsoleVerbCurr == NULL)
        return 0;

    m_rbVerbState[ev].nState = 0; // reset
    MMC_CONSOLE_VERB verb = ::GetConsoleVerb(ev);
    BOOL bReturn = FALSE;

    m_spConsoleVerbCurr->GetVerbState(verb, ENABLED, &bReturn);
    if (bReturn == TRUE)
        m_rbVerbState[ev].nState |= TBSTATE_ENABLED;

    m_spConsoleVerbCurr->GetVerbState(verb, HIDDEN, &bReturn);
    if (bReturn == TRUE)
        m_rbVerbState[ev].nState |= TBSTATE_HIDDEN;

    m_rbVerbState[ev].bAskSnapin = 2;
    return m_rbVerbState[ev].nState;
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSetBase::ScComputeVerbStates
 *
 * PURPOSE:     With given context like scope or result, if result is it background
 *              or ocx or web or multiselection compute the verbstates.
 *
 *              Eventhough snapin can set any verb for its items certain verbs are
 *              not valid in some circumstances. This method takes care of that.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CVerbSetBase::ScComputeVerbStates()
{
    DECLARE_SC(sc, TEXT("CVerbSetBase::ScComputeVerbStates"));

    // reset
    m_spConsoleVerbCurr = NULL;
    for (int i=0; i<evMax; ++i)
    {
        m_rbVerbState[i].nState = TBSTATE_HIDDEN;
        m_rbVerbState[i].bAskSnapin = 0;
    }

    // If the verb context data is invalid, we have already hidden the
    // verbs above so just return .
    if (! m_bVerbContextDataValid)
        return sc;

	sc = ScCheckPointers(m_pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    BOOL   bScopeItemSelected;
    CNode *pSelectedNode = NULL;
    MMC_COOKIE cookie = -1;

    sc = CNodeCallback::ScExtractLVData(m_pNode, m_bScopePaneSelected, m_lResultCookie,
                                        &pSelectedNode, bScopeItemSelected, cookie);
    if (sc)
        return sc.ToHr();

    sc = ScCheckPointers(pSelectedNode, E_UNEXPECTED);
    if (sc)
        return sc;

	// Handle background separately (not same as scope item selected
	// which is the default handling of background).
    if (m_lResultCookie == LVDATA_BACKGROUND)
    {
        // ask snapin for PASTE, PROPERTIES & REFRESH.
        sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
        if (sc)
            return sc;

        _AskSnapin(evPaste);
        _AskSnapin(evProperties);
        _AskSnapin(evRefresh);
        _AskSnapin(evPrint);

        return sc;
    }
	else if (bScopeItemSelected)
    {
        if (pSelectedNode->IsStaticNode())
        {
            if (pSelectedNode->IsConsoleRoot())
            {
                // CONSOLE ROOT is selected

                _EnableVerb(evRename);

                _HideVerb(evOpen);
                _HideVerb(evCut);
                _HideVerb(evCopy);
                _HideVerb(evDelete);
                _HideVerb(evRefresh);
                _HideVerb(evPaste);
                _HideVerb(evPrint);

                return sc;
            }
            else
            {
                _EnableVerb(evOpen);

                // Ask the snapin if paste should be
                // enabled for its root node.
                _AskSnapin(evPaste);

                _HideVerb(evCut);
                _HideVerb(evCopy);
                _HideVerb(evDelete);
            }


            // Static-Snapin node
            // Ask snapin for RENAME, REFRESH & PROPERTIES
            sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
            if (sc)
                return sc;

            _AskSnapin(evOpen);
            _AskSnapin(evRefresh);
            _AskSnapin(evRename);
            _AskSnapin(evPrint);
            _AskSnapin(evProperties);

        }
        else
        {
            // ask snapin for all the verbs.
            sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
            if (sc)
                return sc;

            _AskSnapin(evOpen);
            _AskSnapin(evCut);
            _AskSnapin(evCopy);
            _AskSnapin(evPaste);
            _AskSnapin(evDelete);
            _AskSnapin(evRename);
            _AskSnapin(evRefresh);
            _AskSnapin(evPrint);
            _AskSnapin(evProperties);
        }
    }
    else if (m_lResultCookie == LVDATA_MULTISELECT)
    {
        ASSERT(!bScopeItemSelected);

		if (! m_pMultiSelection)
		{
			CViewData *pViewData = pSelectedNode->GetViewData();
			sc = ScCheckPointers(pViewData, E_UNEXPECTED);
			if (sc)
				return sc;


			m_pMultiSelection = pViewData->GetMultiSelection();
			sc = ScCheckPointers(m_pMultiSelection, E_UNEXPECTED);
			if (sc)
				return sc;
		}

        // if selectedf items are from the primary snapin ask the snapin for all the verbs.

        // Does all the selected items belong to the primary snapin?
        if (m_pMultiSelection->IsSingleSnapinSelection())
        {
            // If so ask the snapin for properties
            sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
            if (sc)
                return sc;

            _AskSnapin(evCut);
            _AskSnapin(evCopy);
            _AskSnapin(evDelete);
            _AskSnapin(evProperties);
            _AskSnapin(evPrint);
        }
        else
        {
            // Multiple snapin items are selected. Even if one item
            // supports cut/copy/delete then enable the verb.
            BOOL bEnable = false;
            sc = m_pMultiSelection->ScIsVerbEnabledInclusively(MMC_VERB_CUT, bEnable);
            if (sc)
                return sc;
            _EnableVerb(evCut, bEnable);

            bEnable = false;
            sc = m_pMultiSelection->ScIsVerbEnabledInclusively(MMC_VERB_COPY, bEnable);
            if (sc)
                return sc;
            _EnableVerb(evCopy, bEnable);

            bEnable = false;
            sc = m_pMultiSelection->ScIsVerbEnabledInclusively(MMC_VERB_DELETE, bEnable);
            if (sc)
                return sc;
            _EnableVerb(evDelete, bEnable);
        }
    } else if ( (m_lResultCookie == LVDATA_CUSTOMOCX) ||
                (m_lResultCookie == LVDATA_CUSTOMWEB) )
    {
        // ask snapin for all the verbs.
        sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
        if (sc)
            return sc;

        _AskSnapin(evOpen);
        _AskSnapin(evCut);
        _AskSnapin(evCopy);
        _AskSnapin(evPaste);
        _AskSnapin(evDelete);
        _AskSnapin(evRename);
        _AskSnapin(evRefresh);
        _AskSnapin(evPrint);
        _AskSnapin(evProperties);

        return sc;
    }
    else
    {
        // ask snapin for all the verbs.
        sc = _QueryConsoleVerb(pSelectedNode, &m_spConsoleVerbCurr);
        if (sc)
            return sc;

        _AskSnapin(evOpen);
        _AskSnapin(evCut);
        _AskSnapin(evCopy);
        _AskSnapin(evPaste);
        _AskSnapin(evDelete);
        _AskSnapin(evRename);
        _AskSnapin(evRefresh);
        _AskSnapin(evPrint);
        _AskSnapin(evProperties);
    }

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSetBase::GetVerbState
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    MMC_CONSOLE_VERB  cVerb :
 *    MMC_BUTTON_STATE  nState :
 *    BOOL*             pbState :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CVerbSetBase::GetVerbState(
    MMC_CONSOLE_VERB cVerb,
    MMC_BUTTON_STATE nState,
    BOOL* pbState)
{
    *pbState = (_GetVerbState(GetEVerb(cVerb)) & GetTBSTATE(nState)) ? TRUE : FALSE;
    return S_OK;
}

STDMETHODIMP
CVerbSetBase::GetDefaultVerb(
    MMC_CONSOLE_VERB* peCmdID)
{
    DECLARE_SC(sc, TEXT("CVerbSetBase::GetDefaultVerb"));
	sc = ScCheckPointers(peCmdID);
	if (sc)
		return sc.ToHr();

    *peCmdID = MMC_VERB_NONE;

    if ( (m_bVerbContextDataValid) && (m_lResultCookie == LVDATA_MULTISELECT) )
        return sc.ToHr();

    if (m_spConsoleVerbCurr == NULL) // Not an error, default verb is requested when the verbset is reset.
        return sc.ToHr();

	sc = m_spConsoleVerbCurr->GetDefaultVerb(peCmdID);
	if (sc)
		return sc.ToHr();

	return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CVerbSet::Notify
 *
 * PURPOSE:   Update the verb state changes to standard toolbar.
 *
 * PARAMETERS:
 *    IConsoleVerb*     pCVIn :
 *    MMC_CONSOLE_VERB  cVerb :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CVerbSet::Notify(
    IConsoleVerb* pCVIn,
    MMC_CONSOLE_VERB cVerb)
{
    /*
     * MMC creates temporary verb to findout verb state for another node or item
     * and mmc also needs verb states for determining drop targets which are not
     * currently selected node. In these cases toolbar should not be changed.
     */
    if (!IsChangesToStdbarEnabled() || m_spConsoleVerbCurr != pCVIn)
        return;

    EVerb ev = GetEVerb(cVerb);
    if (m_rbVerbState[ev].bAskSnapin != 0)
    {
        m_rbVerbState[ev].bAskSnapin = 1;

        CNode *pNode = m_pNode;

        ASSERT(pNode != NULL);
        if (NULL == pNode)
            return;

        CViewData* pViewData = pNode->GetViewData();
        ASSERT(NULL != pViewData);
        if (NULL == pViewData)
            return;

        pViewData->ScUpdateStdbarVerb(cVerb);
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CVerbSet::ScInitialize
//
//  Synopsis:    Given the selection context initialize the verbs by
//               sending MMCN_SELECT or MMCN_DESELECALL to snapin's
//               IComponent::Notify and computing the verbs.
//
//  Arguments:   [pNode]                 - [in] that owns view.
//               [bScope]                - [in] Scope or result item.
//               [bSelect]               - [in] Select or Deselect.
//               [bLVBackgroundSelected] - [in]
//               [lResultCookie]         - [in] If resultpane item then
//                                              this is LVDATA of the item.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CVerbSet::ScInitialize (CNode *pNode, bool bScopePaneSelected,
					       bool bSelect, bool bLVBackgroundSelected,
					       LPARAM lResultCookie)
{
    DECLARE_SC(sc, _T("CVerbSet::ScInitialize"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    if (lResultCookie == LVDATA_MULTISELECT)
        return (sc = E_INVALIDARG);

    if (bLVBackgroundSelected)
	{
		ASSERT(lResultCookie == LVDATA_BACKGROUND);
        bScopePaneSelected = true;
	}

   /*
    * 1. Store the selection context information in the verb-set for resending
    *    MMCN_SELECT after temporary selection notifications.
    */

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    CComponent  *pCC           = NULL;

    // sanity check - if it is a result item then we need to have the valid cookie.
    // but for virtual list - cookie is just an index - it is always valid.
    // see bug #143401 why IsVirtual is needed
	if ( (! bScopePaneSelected) && (!pViewData->IsVirtualList()) &&(lResultCookie == 0))
		return (sc = E_INVALIDARG);

    /*
     * Need to send MMCN_SELECT or MMCN_DESELECTALL notification. Calculate
     * this notification now.
     */
    BOOL bListPadItem = pViewData->HasListPad() && !IS_SPECIAL_LVDATA(lResultCookie);
    MMC_NOTIFY_TYPE eNotify = MMCN_SELECT;

    // On deselect of a virtual listview item, the underlying list-view sends deselect
    // with cookie of -1. So we send MMCN_DESELECT_ALL with NULL dataobject as the
    // index of de-selected item is not known.
    if (bSelect == FALSE && lResultCookie == -1 && pViewData->IsVirtualList() == TRUE )
    {
        eNotify = MMCN_DESELECT_ALL;
		pCC     = pNode->GetPrimaryComponent();
		sc = ScCheckPointers(pCC, E_UNEXPECTED);
		if (sc)
			return sc;
    }
    else if (pViewData->HasOCX() || (pViewData->HasWebBrowser() && !bListPadItem) )
    {
        // Select/Deselect Web or OCX. (except if item is in MMC List control)
        eNotify = bSelect ? MMCN_SELECT : MMCN_DESELECT_ALL;
		pCC     = pNode->GetPrimaryComponent();
		sc = ScCheckPointers(pCC, E_UNEXPECTED);
		if (sc)
			return sc;
    }

    bool bScopeItem = bScopePaneSelected;
    IDataObjectPtr spDataObject   = NULL;
    LPDATAOBJECT lpDataObject = NULL;

    // 2. Get the dataobject & CComponent for given context.
    //    only if event is MMCN_SELECT.
    if (eNotify != MMCN_DESELECT_ALL)
    {
        sc = pNode->ScGetDataObject(bScopePaneSelected, lResultCookie, bScopeItem, &lpDataObject, &pCC);
        if (sc)
		{
			// cannot leave invalid data, cause (especially in deselect case) no cleanup will happen
			// and that will lead to AV on the next right-click
			// see windows bug #489996 (11/09/01)
		    Reset();
            return sc;
		}

        sc = ScCheckPointers(lpDataObject, pCC, E_UNEXPECTED);
        if (sc)
		{
		    Reset();
            return sc;
		}

		if (! IS_SPECIAL_DATAOBJECT(lpDataObject) )
			spDataObject.Attach(lpDataObject, false/*fAddRef*/);
    }

    // Before sending select reset the console verb states.
    sc = pCC->ScResetConsoleVerbStates();
    if (sc)
        return sc;

#ifdef DBG
    Trace(tagVerbs, _T("Sent (MMCN_SELECT %s %s) for permanent verb to snapin with node name %s\n"),
          bScopeItem ? _T("Scope") : _T("Result"),
          bSelect ? _T("Select") : _T("De-select"),
          pNode->GetDisplayName().data());
#endif

    SC scNoTrace = pCC->Notify(lpDataObject, eNotify, MAKELONG((WORD)bScopeItem, (WORD)bSelect), 0);
    if (scNoTrace)
	{
        TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
	}

    Reset();
    m_bScopePaneSelected = bScopePaneSelected;
    m_bVerbContextDataValid = bSelect;
    m_lResultCookie      = lResultCookie;
    m_pNode              = pNode;

    sc = ScComputeVerbStates();
    if (sc)
        return sc;

    // If the item is deselected then the cached context information should be nuked.
    if (! bSelect)
        Reset();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CVerbSetBase::ScInitializeForMultiSelection
//
//  Synopsis:    Initialize the verbset object for multiselection. Unlike
//               single selection in which above CVerbSet::ScInitialize is
//               used, in case of multiselect, the CMultiSelection object
//               knows what is selected in resultpane. It then gets dataobjects
//               for those selections from snapins and sends MMCN_SELECT to those
//               snapins to set verbs.
//
//  Arguments:  [pNode]   - [in] owner of resultpane.
//              [bSelect] - [in] select or deselect.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CVerbSetBase::ScInitializeForMultiSelection (CNode *pNode, bool bSelect)
{
    DECLARE_SC(sc, _T("CVerbSetBase::ScInitializeForMultiSelection"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

   /*
    * Store the selection context information in the verb-set for resending
    * MMCN_SELECT after temporary selection notifications.
    */

    Reset();
    m_bScopePaneSelected = false;
    m_bVerbContextDataValid = bSelect;
    m_lResultCookie      = LVDATA_MULTISELECT;
    m_pNode              = pNode;

    return (sc);
}

/*+-------------------------------------------------------------------------*
 * class CDisableStandardToolbarChanges
 *
 *
 * PURPOSE: A class that disables changes to standard toolbar due to
 *          temp-verb MMCN_SELECTs and enables when destructed (goes out of scope).
 *
 *+-------------------------------------------------------------------------*/
class CDisableStandardToolbarChanges
{
public:
    CDisableStandardToolbarChanges(CVerbSet* pVerbSet) : m_pVerbSet(pVerbSet)
    {
        ASSERT(pVerbSet != NULL);
        if (pVerbSet)
            pVerbSet->DisableChangesToStdbar();
    }
    ~CDisableStandardToolbarChanges()
    {
        ASSERT(m_pVerbSet != NULL);
        if (m_pVerbSet)
            m_pVerbSet->EnableChangesToStdbar();
    }

private:
    CVerbSet *m_pVerbSet;
};

//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScInitialize
//
//  Synopsis:    Initialize the temp verb set,
//
//               Since we are sending MMCN_SELECT notifications to the snapin
//               to calculate temp verbs,
//
//               1. first send de-select to the item for which we sent
//                  (MMCN_SELECT, true) last time.
//                  (If last one is (MMCN_SELECT,false) then skip this and 4th step)
//
//               2. Send (MMCN_SELECT, true) for temp verb calculation.
//               3. Send (MMCN_SELECT, false) for temp verb calculation.
//
//               4. Now send (MMCN_SELECT, true) to select original item (in step 1).
//
//               So we need to compute the dataobject for temp-selected item (from
//               given parameters) and for originally selected item (ask the viewdata).
//
//  Arguments:   [pNode]         - [in] bScope = true, the node that will be temp selected else
//                                      the node that owns the result pane item that is temp selected.
//               [lResultCookie] - [in] If result-item, the LPARAM (can be scope item in result pane).
//               [bScopePaneSel] - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScInitialize (CNode *pNode, LPARAM lResultCookie, bool bScopePaneSel)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScInitialize"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    bool bScopeItem;
    LPDATAOBJECT pDataObject = NULL;
    sc = pNode->ScGetDataObject(bScopePaneSel, lResultCookie, bScopeItem, &pDataObject);
    if (sc)
        return sc;

    sc = ScCheckPointers(pDataObject, E_UNEXPECTED);
    if (sc)
        return sc;

    // take ownership & release it on time!!!
    IDataObjectPtr spDataObject( IS_SPECIAL_DATAOBJECT(pDataObject) ? NULL : pDataObject, false/*fAddRef*/);

    sc = ScInitialize(pDataObject, pNode, bScopePaneSel, lResultCookie);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScInitializePermanentVerbSet
//
//  Synopsis:    Send de-select or select notification to snapin for
//               the permanent verb-set object.
//
//  Arguments:   [pNode]   - [in] owner of the result pane.
//               [bSelect] - [in] true - send select notification to snapin
//                                       informing it to initialize the verbs
//
//                                false - send de-select notification to snapin
//                                        informing it to uninitialize the verbs.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScInitializePermanentVerbSet (CNode *pNode, bool bSelect)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScInitializePermanentVerbSet"));
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers(pViewData, E_UNEXPECTED);
    if (sc)
        return sc;

    // 1. SEND (de)selection to permananet verb set.
    IDataObject*   pOriginalSelDataObject = NULL;
    CComponent    *pCCOriginalSel = NULL;
    bool           bOriginalScopeSel;
    bool           bOriginallySelected;
    LPCTSTR        lpszNodeName = NULL;
    bool           bMultiSelection = false;


    SC scNoTrace = pViewData->ScIsVerbSetContextForMultiSelect(bMultiSelection);
    if (scNoTrace)
		return scNoTrace;

    /*
     * See if verb context is for multiselection.
     * If multiselection we do not send any de-select to be compatible
     * with MMC1.2, just return.
     */
    if (bMultiSelection)
        return sc;

     scNoTrace = pViewData->ScGetVerbSetData(&pOriginalSelDataObject, &pCCOriginalSel,
                                               bOriginalScopeSel, bOriginallySelected
                                               #ifdef DBG
                                               , &lpszNodeName
                                               #endif
                                               );

    if (scNoTrace)
        return sc;

    // Before sending select reset the console verb states.
    sc = pCCOriginalSel->ScResetConsoleVerbStates();
    if (sc)
        return sc;

    // take ownership & release it on time!!!
    IDataObjectPtr spDataObject( IS_SPECIAL_DATAOBJECT(pOriginalSelDataObject) ? NULL : pOriginalSelDataObject, false/*fAddRef*/);

    // If we sent MMCN_SELECT, true then send de-select else nothing.
    if ( (pOriginalSelDataObject != NULL) && (pCCOriginalSel != NULL) && (bOriginallySelected) )
    {
#ifdef DBG
        Trace(tagVerbs, _T("Sent (MMCN_SELECT %s %sselect) for permanent-verb-restore to snapin with node name %s\n"),
                            bOriginalScopeSel ? _T("Scope") : _T("Result"),
                            bSelect ? _T("") : _T("De-"),
                            lpszNodeName);
#endif

        scNoTrace = pCCOriginalSel->Notify(pOriginalSelDataObject, MMCN_SELECT,
                                           MAKELONG(bOriginalScopeSel, bSelect), 0);
        if (scNoTrace)
		{
            TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
		}

		// Verbs were initialized, therefore recompute verbstates.
		if (bSelect)
		{
			// get the verbset
			CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>( pViewData->GetVerbSet() );
			sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
			if (sc)
				return sc;

			/*
			 * The selection context information stored in this object is
			 * invalid upon de-selection of that item.
			 */
			m_bVerbContextDataValid = bSelect;
			sc = pVerbSet->ScComputeVerbStates();
			if (sc)
				return sc;
		}

    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScInitialize
//
//  Synopsis:    Initialize the temp verb set,
//
//               Since we are sending MMCN_SELECT notifications to the snapin
//               to calculate temp verbs,
//
//               1. first send de-select to the item for which we sent
//                  (MMCN_SELECT, true) last time.
//                  (If last one is MMCN_SELECT,false then skip this and 4th step)
//
//               2. Send (MMCN_SELECT, true) for temp verb calculation.
//               3. Send (MMCN_SELECT, false) for temp verb calculation.
//
//               4. Now send (MMCN_SELECT, true) to select original item (in step 1).
//
//               So we need to compute the dataobject for temp-selected item (from
//               given parameters) and for originally selected item (ask the viewdata).
//
//  Arguments:   [lpDataObjectForTempSel]  - [in] dataobject of the temp selected object.
//               [pNodeForTempSel]         - [in] bScope = true, the node that will be temp selected else
//                                                the node that owns the result pane item that is temp selected.
//               [bTempScopePaneSel]       - [in]
//               [lResultCookie]           - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScInitialize (LPDATAOBJECT lpDataObjectForTempSel,
                                    CNode *pNodeForTempSel,
                                    bool   bTempScopePaneSel,
									LPARAM lResultCookie)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScInitialize"));
    sc = ScCheckPointers(lpDataObjectForTempSel, pNodeForTempSel);
    if (sc)
        return sc;

    // get view data
    CViewData *pViewData = pNodeForTempSel->GetViewData();
    sc = ScCheckPointers( pViewData, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the verbset
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>( pViewData->GetVerbSet() );
    sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
    if (sc)
        return sc;

    if (! pNodeForTempSel->IsInitialized())
    {
        sc = pNodeForTempSel->InitComponents();
        if (sc)
            return sc.ToHr();
    }

    CComponent *pCCTempSel = pNodeForTempSel->GetPrimaryComponent();
    sc = ScCheckPointers(pCCTempSel, E_UNEXPECTED);
    if (sc)
        return sc;

    /*
     * We create a temporary verb to get given verb's state. So inform
     * the original verb object that there is a temporary verb
     * so that standard-toolbars are not applied the temporary verb.
     */
    CDisableStandardToolbarChanges standardbarChanges(pVerbSet);

    bool bTempSelected = true; // always compute verb for selection of an item.

    Reset();
    m_bScopePaneSelected  = bTempScopePaneSel;
    m_pNode               = pNodeForTempSel;
	m_lResultCookie       = lResultCookie;

    // sanity check - if it is a result item then we need to have the valid cookie.
    // but for virtual list - cookie is just an index - it is always valid.
    // see bug #143401 why IsVirtual is needed
	if ( (! m_bScopePaneSelected) && (!pViewData->IsVirtualList()) && (m_lResultCookie == 0))
		return (sc = E_INVALIDARG);

    // Ignore the return values from IComponent::Notify

    // 1. SEND de-selection to permananet verb set.
    sc = ScInitializePermanentVerbSet (pNodeForTempSel, /*bSelect*/ false);
    if (sc)
        return sc;

    // 2. SEND selection to temporary verb set.
#ifdef DBG
    Trace(tagVerbs, _T("Sent (MMCN_SELECT %s Select) for tempverbs to snapin with node name %s\n"),
                        m_bScopePaneSelected ? _T("Scope") : _T("Result"),
                        pNodeForTempSel->GetDisplayName().data());
#endif

    // Before sending select reset the console verb states.
    sc = pCCTempSel->ScResetConsoleVerbStates();
    if (sc)
        return sc;

    SC scNoTrace = pCCTempSel->Notify(lpDataObjectForTempSel, MMCN_SELECT, MAKELONG(m_bScopePaneSelected, bTempSelected), 0);
    if (scNoTrace)
	{
        TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
	}

    // 2.a) Compute the verbs.

    /*
     * The selection context information stored in this object is
     * invalid upon de-selection of that item.
     */
    m_bVerbContextDataValid = bTempSelected;

    sc = ScComputeVerbStates();
    if (sc)
        sc.TraceAndClear();

    // 3. SEND de-selection to temporary verb set.
#ifdef DBG
    Trace(tagVerbs, _T("Sent (MMCN_SELECT %s De-select) for tempverbs to snapin with node name %s\n"),
                        m_bScopePaneSelected ? _T("Scope") : _T("Result"),
                        pNodeForTempSel->GetDisplayName().data());
#endif

    // Before sending select reset the console verb states.
    sc = pCCTempSel->ScResetConsoleVerbStates();
    if (sc)
        return sc;

    scNoTrace = pCCTempSel->Notify(lpDataObjectForTempSel, MMCN_SELECT, MAKELONG(m_bScopePaneSelected, !bTempSelected), 0);
    if (scNoTrace)
	{
        TraceSnapinError(TEXT("Snapin has returned error from IComponent::Notify with MMCN_SELECT event"), scNoTrace);
	}

    // 4. SEND select to permanent verb set.
    sc = ScInitializePermanentVerbSet (pNodeForTempSel, /*bSelect*/ true);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::ScComputeVerbStates
//
//  Synopsis:    Since this is temp verb set, we need to get the states
//               of all verbs from CConsoleVerbImpl object immediately after
//               we sent MMCN_SELECT with item seelcted. Otherwise they will
//               be overwritten by subsequent SetVerbState (due to restore MMCN_SELECT
//               notifications).
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CTemporaryVerbSet::ScComputeVerbStates ()
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::ScComputeVerbStates"));

    sc = CVerbSetBase::ScComputeVerbStates();
    if (sc)
        return sc;

    // _GetVerbState gets the state of the verb from CConsoleVerbImpl
    // and fills it in this object's members which will be used later.
    for (int verb=evNone; verb < evMax; ++verb)
        _GetVerbState((EVerb)verb);

    // Get the default verb and store it.
    CVerbSetBase::GetDefaultVerb(&m_DefaultVerb);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CTemporaryVerbSet::GetDefaultVerb
//
//  Synopsis:    Get the default verb for the temp sel.
//
//  Arguments:   [peCmdID] - [out] ptr to default verb.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CTemporaryVerbSet::GetDefaultVerb (MMC_CONSOLE_VERB* peCmdID)
{
    DECLARE_SC(sc, _T("CTemporaryVerbSet::GetDefaultVerb"));
    sc = ScCheckPointers(peCmdID);
    if (sc)
        return sc.ToHr();

    *peCmdID = m_DefaultVerb;

    return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\typeinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       typeinfo.h
//
//--------------------------------------------------------------------------

#pragma once

#if !defined(TYPEINFO_H_INCLUDED)
#define TYPEINFO_H_INCLUDED

#include "classreg.h"

/*-------------------------------------------------------------------------*\
| The classes in this file are to provide extra cleanup functionality.
| Node Manager hosts variety of com objects - some which are solely for MMC;
| some for MMC's Object Model, but also some objects which lifetime is 
| controlled by snapins. If any of the interfaces is hold - Node Manager will
| remain locked in memory until the very end, thus - far beyond the call to
| OleUninitialize. Some objects have ole automation objects cached - 
| particularly IDispatchImpl and IProvidClassInfoImpl implemented by ATL caches
| ITypeInfo interfaces. These caches need to be released before OleUninitialize
| even if Node Manager is locked.
|
| To solve this problem we use derived template: 
| INodeManagerProvideClassInfoImpl, which inherits all functionality from ATL,
| plus registers every class once to COleCacheCleanupManager, which will receive
| the control from CONUI and cleanup the cache.
| To implement described functionality those templates construct static object
| of class CMMCTypeInfoHolderWrapper, giving the reference to static member
| caching ITypeInfo. CMMCTypeInfoHolderWrapper will register itself as observer
| for COleCacheCleanupManager events and will cleanup the cache in response to
| events requesting it.
| [clenup also included into CMMCIDispatchImpl - bas for ObjectModel objects]
\*-------------------------------------------------------------------------*/

/***************************************************************************\
 *
 * CLASS:  COleCacheCleanupObserver
 *
 * PURPOSE: defines observer interface for OLE cleanup events
 *
\***************************************************************************/
class COleCacheCleanupObserver : public CObserverBase
{
public:
    virtual SC ScOnReleaseCachedOleObjects()  = 0;
};

/***************************************************************************\
 *
 * CLASS:  COleCacheCleanupManager
 *
 * PURPOSE: this class is responsible for cleaning up the OLE object cached 
 *          by node manager. It registers all cleanup clients and, when 
 *          received the control from CONUI, will dispatch the events to all 
 *          registered observers
 *
\***************************************************************************/
class COleCacheCleanupManager : public CEventSource<COleCacheCleanupObserver>
{
    static COleCacheCleanupManager& GetSingletonObject();
public:
    static void AddOleObserver(COleCacheCleanupObserver * pObserver);
    static SC   ScReleaseCachedOleObjects();
};

/***************************************************************************\
 *
 * CLASS:  CMMCTypeInfoHolderWrapper
 *
 * PURPOSE: this class wraps type info included into given to constructor
 *          allowing it to be cleared when requested
 *
 * NOTE:    there is not lifetime management involved in this implementation,
 *          user is responsible to make given reference outliving the object
 *          of this class.
 *
\***************************************************************************/
class CMMCTypeInfoHolderWrapper : public COleCacheCleanupObserver
{
    CComTypeInfoHolder&     m_rInfoHolder;
public:
    CMMCTypeInfoHolderWrapper(CComTypeInfoHolder& rInfoHolder);
    virtual SC ScOnReleaseCachedOleObjects();
};

/***************************************************************************\
 *
 * CLASS:  INodeManagerProvideClassInfoImpl
 *
 * PURPOSE: this class is to be used in place of IProvideClassInfo2Impl
 *          for all com object created on NodeManager side.
 *          It ensures ITypeInfo will be released on request from CONUI
 *
\***************************************************************************/

template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE INodeManagerProvideClassInfoImpl : 
public IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>
{
public:
    INodeManagerProvideClassInfoImpl() 
    { 
        static CMMCTypeInfoHolderWrapper wrapper(GetInfoHolder()); 
    }
    // the porpose of this static function is to ensure _tih is a static variable,
    // since static wrapper will hold on its address - it must be always valid 
    static CComTypeInfoHolder& GetInfoHolder() { return _tih; }
};

/***************************************************************************\
 *
 * CLASS:  CMMCComCacheCleanup
 *
 * PURPOSE: implements IComCacheCleanup on cocreatable class to provide access
 *          from CONUI side
 *
\***************************************************************************/

class CMMCComCacheCleanup :
    public CComObjectRoot,
    public IComCacheCleanup,
    public CComCoClass<CMMCComCacheCleanup, &CLSID_ComCacheCleanup>
    {
public:
    BEGIN_COM_MAP(CMMCComCacheCleanup)
        COM_INTERFACE_ENTRY(IComCacheCleanup)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CMMCComCacheCleanup)

    DECLARE_MMC_OBJECT_REGISTRATION (
		g_szMmcndmgrDll,						// implementing DLL
        CLSID_ComCacheCleanup,   				// CLSID
        _T("ComCacheCleanup 1.0 Object"),		// class name
        _T("NODEMGR.ComCacheCleanup.1"),		// ProgID
        _T("NODEMGR.ComCacheCleanup"))		    // version-independent ProgID

public:

    STDMETHOD(ReleaseCachedOleObjects)();
};


#endif // !defined(TYPEINFO_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\verbs.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       verbs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/9/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _VERBS_H_
#define _VERBS_H_


class CNode;
class CVerbSet;

/*+-------------------------------------------------------------------------*
 * class CConsoleVerbState
 *
 *
 * PURPOSE:  Button state for console commands.
 *
 *+-------------------------------------------------------------------------*/
class CConsoleVerbState
{
public:
    CConsoleVerbState() {m_state = m_stateDisabled = TBSTATE_HIDDEN; m_bHiddenBySnapIn = false;}

    void Init(BYTE stateDisabled)   {m_stateDisabled = m_state;}
    void Disable()                  {m_state = m_stateDisabled; m_bHiddenBySnapIn = false;}
    BYTE GetState()                 {return m_state;}
    void SetState(BYTE state)       {m_state = state;}

    void SetHiddenBySnapin(BOOL b)  {m_bHiddenBySnapIn = b;}
    bool IsHiddenBySnapin()         {return m_bHiddenBySnapIn;}

private:
    BYTE                m_state;          // State
    bool                m_bHiddenBySnapIn;
    BYTE                m_stateDisabled; // what "Disabled" means for this verb.
};

typedef CConsoleVerbState *LPCONSOLE_VERB_STATE;

/*+-------------------------------------------------------------------------*
 * class CConsoleVerbImpl
 *
 *
 * PURPOSE: This is the object that the snapins' IConsoleVerb points to.
 *          This object has a pointer to an implementation of CVerbSet.
 *          The CVerbSet object can be switched to allow a temporary
 *          selection, for instance. This allows a view to have its toolbars
 *          to get their verb settings from a different CVerbSet object than
 *          the right click context menu does - just set the CVerbSet
 *          pointer on the CConsoleVerbImpl to the CVerbSet that the
 *          changes should be routed to, and send the snapin an MMCN_SELECT
 *          notification.
 *
 *          What might be confusing at first is that both CConsoleVerbImpl
 *          as well as CVerbSet keep a set of states. 1) The CConsoleVerbImpl
 *          needs to have its own set because the
 *          set of states needs to look consistent to the snapin regardless
 *          of where the CVerbSet pointer is pointing to. 2) At the same time,
 *          the CVerbSet needs its own set of states so that its client
 *          consistently reads this set.
 *+-------------------------------------------------------------------------*/
class CConsoleVerbImpl : public IConsoleVerb, public CComObjectRoot
{

public:
    CConsoleVerbImpl();
    ~CConsoleVerbImpl();

// ATL COM maps
BEGIN_COM_MAP(CConsoleVerbImpl)
    COM_INTERFACE_ENTRY(IConsoleVerb)
END_COM_MAP()

// IConsoleVerb methods
public:
    STDMETHOD(GetVerbState)(MMC_CONSOLE_VERB eCmdID, MMC_BUTTON_STATE nState, BOOL* pbState);
    STDMETHOD(SetVerbState)(MMC_CONSOLE_VERB eCmdID, MMC_BUTTON_STATE nState, BOOL bState);
    STDMETHOD(SetDefaultVerb)(MMC_CONSOLE_VERB eCmdID);
    STDMETHOD(GetDefaultVerb)(MMC_CONSOLE_VERB* peCmdID)
    {
        *peCmdID = m_DefaultVerb;
        return S_OK;
    }

    BYTE    GetVerbState(MMC_CONSOLE_VERB verb);
    HRESULT SetDisabledAll(void);
    void    SetVerbSet(IConsoleVerb* pVerbSet);

private:
    CVerbSet* GetVerbSet()
    {
        ASSERT(m_pVerbSet != NULL);
        return m_pVerbSet;
    }

public:
#ifdef DBG
    int dbg_cRef_CConsoleVerbImpl;
    ULONG InternalAddRef();
    ULONG InternalRelease();
#endif // DBG

// Internal functions
private:
    LPCONSOLE_VERB_STATE GetConsoleVerbState(MMC_CONSOLE_VERB m_eCmdID);

// Implementation
private:
    CVerbSet*           m_pVerbSet;
    MMC_CONSOLE_VERB    m_DefaultVerb;
    CConsoleVerbState   m_rgConsoleVerbStates[evMax];

    bool                m_bCutVerbDisabledBySnapin;
}; // class CConsoleVerbImpl


HRESULT _GetConsoleVerb(CNode* pNode, LPCONSOLEVERB* ppConsoleVerb);


/*+-------------------------------------------------------------------------*
 * class CVerbSetBase
 *
 *
 * PURPOSE: This class retains the state of all the verbs corresponding
 *          to a particular object. See the note in CConsoleVerbImpl above.
 *
 *          This also forms base class for CVerbSet as well as CTemporaryVerbSet
 *          objects.
 *
 *          Do not instantiate this object directly you should create either
 *          CVerbSet or CTemporaryVerbSet object.
 *
 *+-------------------------------------------------------------------------*/
class CVerbSetBase : public IConsoleVerb, public CComObjectRoot
{
public:
    CVerbSetBase();
    ~CVerbSetBase();

// ATL COM maps
BEGIN_COM_MAP(CVerbSetBase)
    COM_INTERFACE_ENTRY(IConsoleVerb)
END_COM_MAP()

// IConsoleVerb methods
public:
    STDMETHOD(GetVerbState)(MMC_CONSOLE_VERB m_eCmdID, MMC_BUTTON_STATE nState, BOOL* pbState);
    STDMETHOD(GetDefaultVerb)(MMC_CONSOLE_VERB* peCmdID);

    STDMETHOD(SetVerbState)(MMC_CONSOLE_VERB m_eCmdID, MMC_BUTTON_STATE nState, BOOL bState)
    {
        ASSERT(0 && "Should never come here!!!");
        return E_FAIL;
    }
    STDMETHOD(SetDefaultVerb)(MMC_CONSOLE_VERB m_eCmdID)
    {
        ASSERT(0 && "Should never come here!!!");
        return E_FAIL;
    }

	SC                  ScInitializeForMultiSelection(CNode *pNode, bool bSelect);
    void                SetMultiSelection(CMultiSelection* pMS);

    SC                  ScComputeVerbStates();

    IConsoleVerb*       GetConsoleVerb(void) const;

// Implementation
protected:
    void                Reset();
    BYTE                _GetVerbState(EVerb ev);

private:
    void                _EnableVerb(EVerb eVerb, bool fEnable);
    void                _EnableVerb(EVerb eVerb);
    void                _HideVerb(EVerb eVerb);
    void                _AskSnapin(EVerb eVerb);

protected:
    CNode*   m_pNode;
    bool     m_bScopePaneSelected;
    LPARAM   m_lResultCookie;
    bool     m_bVerbContextDataValid;

    CMultiSelection*    m_pMultiSelection;

    IConsoleVerbPtr     m_spConsoleVerbCurr;

    struct SVerbState
    {
        BYTE    bAskSnapin; // 0 => don't ask, 1 => ask, 2 => asked and answered.
        BYTE    nState;
    };

    SVerbState m_rbVerbState[evMax];
};

/*+-------------------------------------------------------------------------*
 * class CVerbSet
 *
 *
 * PURPOSE: This object stores verb state information for currently (non-temporarily)
 *          selected item if there is one and is created by CViewData per view.
 *
 *+-------------------------------------------------------------------------*/
class CVerbSet : public CVerbSetBase
{
public:
    CVerbSet() { Reset(); }

	SC       ScInitialize (CNode *pNode, bool bScope, bool bSelect,
		                   bool bLVBackgroundSelected, LPARAM lResultCookie);

    void     Notify(IConsoleVerb* pCVIn, MMC_CONSOLE_VERB m_eCmdID);
    SC       ScGetVerbSetContext(CNode*& pNode, bool& bScope, LPARAM& lResultCookie, bool& bSelected);

    void     DisableChangesToStdbar()   { m_bChangesToStdbarEnabled = false;}
    void     EnableChangesToStdbar()    { m_bChangesToStdbarEnabled = true;}

private:
    bool     IsChangesToStdbarEnabled() { return m_bChangesToStdbarEnabled;}

    void     Reset();

private:

    bool     m_bChangesToStdbarEnabled;
};


/*+-------------------------------------------------------------------------*
 * class CTemporaryVerbSet
 *
 *
 * PURPOSE: This object provides methods to initialize temporary verbset state
 *          infomation. This de-selects any item that is currently selected, then
 *          selects temp item computes verbs, de-selects temp item and selects
 *          original item.
 *
 *          Here selection or de-selection means sending (MMCN_SELECT, true) or
 *          (MMCN_SELECT, false).
 *
 *+-------------------------------------------------------------------------*/
class CTemporaryVerbSet : public CVerbSetBase
{
public:
    STDMETHOD(GetDefaultVerb)(MMC_CONSOLE_VERB* peCmdID);

    SC       ScInitialize(CNode *pNode, LPARAM lResultCookie, bool bScopePaneSel);
    SC       ScInitialize(LPDATAOBJECT lpDataObject, CNode *pNode, bool bScopePaneSel, LPARAM lResultCookie);
    SC       ScComputeVerbStates();

private:
    SC       ScInitializePermanentVerbSet(CNode *pNode, bool bSelect);

private:
    MMC_CONSOLE_VERB    m_DefaultVerb;
};


inline CVerbSetBase::CVerbSetBase()
{
    Reset();
    DEBUG_INCREMENT_INSTANCE_COUNTER(CVerbSetBase);
}

inline CVerbSetBase::~CVerbSetBase()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CVerbSetBase);
}

inline void CVerbSetBase::SetMultiSelection(CMultiSelection* pMS)
{
    m_pMultiSelection = pMS;
}

inline void CVerbSetBase::Reset()
{
    m_bScopePaneSelected = false;
    m_bVerbContextDataValid = false;
    m_lResultCookie      = NULL;
    m_pNode              = NULL;

    m_pMultiSelection    = NULL;
    m_spConsoleVerbCurr  = NULL;
}

inline IConsoleVerb* CVerbSetBase::GetConsoleVerb(void) const
{
    return m_spConsoleVerbCurr;
}


inline void CVerbSetBase::_EnableVerb(EVerb eVerb, bool fEnable)
{
    if (fEnable)
        _EnableVerb(eVerb);
    else
        _HideVerb(eVerb);
}

inline void CVerbSetBase::_EnableVerb(EVerb eVerb)
{
    m_rbVerbState[eVerb].bAskSnapin = 0;
    m_rbVerbState[eVerb].nState = TBSTATE_ENABLED;
}

inline void CVerbSetBase::_HideVerb(EVerb eVerb)
{
    m_rbVerbState[eVerb].bAskSnapin = 0;
    m_rbVerbState[eVerb].nState = TBSTATE_HIDDEN;
}

inline void CVerbSetBase::_AskSnapin(EVerb eVerb)
{
    m_rbVerbState[eVerb].bAskSnapin = 1;
    m_rbVerbState[eVerb].nState = 0;
}

inline void CConsoleVerbImpl::SetVerbSet(IConsoleVerb* pVerbSet)
{
    m_pVerbSet = dynamic_cast<CVerbSet*>(pVerbSet);
    ASSERT(m_pVerbSet != NULL);
}

inline void CVerbSet::Reset()
{
    CVerbSetBase::Reset();

    m_bChangesToStdbarEnabled = true;
}

inline SC CVerbSet::ScGetVerbSetContext(CNode*& pNode,
                                        bool& bScopePaneSel,
                                        LPARAM& lResultCookie,
                                        bool& bDataValid)
{
    pNode         = m_pNode;
    bScopePaneSel = m_bScopePaneSelected;
    lResultCookie = m_lResultCookie;
    bDataValid    = m_bVerbContextDataValid;

    if (! pNode)
        return E_FAIL;

    return S_OK;
}


#endif // _VERBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\viewdata.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ViewData.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/18/1997   RaviR   Created
//____________________________________________________________________________
//

#include "stdafx.h"

#pragma hdrstop


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "menubtn.h"
#include "viewdata.h"
#include "multisel.h"
#include "colwidth.h"
#include "conview.h"        // for CConsoleView
#include "conframe.h"

void CViewData::CreateControlbarsCache()
{
    ASSERT(m_spControlbarsCache == NULL);

    CComObject<CControlbarsCache>* pObj;
    HRESULT hr = CComObject<CControlbarsCache>::CreateInstance(&pObj);
    ASSERT(SUCCEEDED(hr));

    pObj->SetViewData(this);

    if (SUCCEEDED(hr))
        m_spControlbarsCache = pObj;
}

STDMETHODIMP CNodeInitObject::InitViewData(LONG_PTR lViewData)
{
    if (lViewData == NULL)
        return E_INVALIDARG;

    SViewData* pVD = reinterpret_cast<SViewData*>(lViewData);
    ASSERT(pVD != NULL);
    ASSERT(pVD->m_spVerbSet == NULL);

    CViewData* pCVD = reinterpret_cast<CViewData*>(lViewData);
    ASSERT(pCVD != NULL);

    if (pVD->m_spVerbSet == NULL)
    {

        CComObject<CVerbSet>* pVerb;
        HRESULT hr = CComObject<CVerbSet>::CreateInstance(&pVerb);
        if (FAILED(hr))
            return hr;

        ASSERT(pVerb != NULL);

        pVD->m_spVerbSet = pVerb;
        ASSERT(pVD->m_spVerbSet != NULL);
        if (pVD->m_spVerbSet == NULL)
            return E_NOINTERFACE;
    }

    // See if the Column Persistence Object was created,
    // else create one.
    if ( pCVD && (pCVD->IsColumnPersistObjectInitialized() == false) )
    {
        // Create the column persistence object
        CComObject<CColumnPersistInfo>* pColData;

        HRESULT hr = CComObject<CColumnPersistInfo>::CreateInstance (&pColData);
        ASSERT(SUCCEEDED(hr) && pColData != NULL);
        if (FAILED(hr))
        {
            CStr strMsg;
            strMsg.LoadString(GetStringModule(), IDS_ColumnsCouldNotBePersisted);
            ::MessageBox(NULL, strMsg, NULL, MB_OK|MB_SYSTEMMODAL);
        }

        // Save a pointer to Column persistence object in CViewData.
        pCVD->InitializeColumnPersistObject(pColData, pColData);
    }

    return S_OK;
}

STDMETHODIMP CNodeInitObject::CleanupViewData(LONG_PTR lViewData)
{
    SViewData* pVD = reinterpret_cast<SViewData*>(lViewData);
    if (pVD->m_pMultiSelection != NULL)
    {
        pVD->m_pMultiSelection->Release();
        pVD->m_pMultiSelection = NULL;
    }

    return S_OK;
}

// Buttons
//
void CViewData::ShowStdButtons(bool bShow)
{
    DECLARE_SC(sc, _T("CViewData::ShowStdButtons"));

    CStdVerbButtons* pStdToolbar = GetStdVerbButtons();
    if (NULL == pStdToolbar)
    {
        sc = E_UNEXPECTED;
        return;
    }

    sc = pStdToolbar->ScShow(bShow);
}

void CViewData::ShowSnapinButtons(bool bShow)
{
    DECLARE_SC(sc, _T("CViewData::ShowSnapinButtons"));

    IControlbarsCache* pICBC = GetControlbarsCache();
    if (pICBC == NULL)
    {
        sc = E_UNEXPECTED;
        return;
    }

    CControlbarsCache* pCBC = dynamic_cast<CControlbarsCache*>(pICBC);
    if (pCBC == NULL)
    {
        sc = E_UNEXPECTED;
        return;
    }

    sc = pCBC->ScShowToolbars(bShow);
}

bool IsFlagEnabled(DWORD cache, DWORD flag)
{
    return ((cache & flag) == flag) ? true : false;
}

void CViewData::UpdateToolbars(DWORD dwTBNew)
{
    ShowStdButtons(IsFlagEnabled(dwTBNew, STD_BUTTONS));
    ShowSnapinButtons(IsFlagEnabled(dwTBNew, SNAPIN_BUTTONS));

    SetToolbarsDisplayed(dwTBNew);
}

void CViewData::ToggleToolbar(long lMenuID)
{
    DWORD dwTBOld = GetToolbarsDisplayed();
    DWORD dwTBNew = 0;

    DECLARE_SC(sc, _T("CViewData::ToggleToolbar"));

    switch (lMenuID)
    {
    case MID_STD_MENUS:
        {
            dwTBNew = dwTBOld ^ STD_MENUS;
            SetToolbarsDisplayed(dwTBNew);

            CConsoleFrame* pFrame = GetConsoleFrame();
            sc = ScCheckPointers(pFrame, E_UNEXPECTED);
            if (sc)
                return;

            sc = pFrame->ScShowMMCMenus(IsStandardMenusAllowed());
            if (sc)
                return;
        }
        break;

    case MID_STD_BUTTONS:
        dwTBNew = dwTBOld ^ STD_BUTTONS;
        ShowStdButtons(bool(dwTBNew & STD_BUTTONS));
        break;

    case MID_SNAPIN_MENUS:
        {
            dwTBNew = dwTBOld ^ SNAPIN_MENUS;
            SetToolbarsDisplayed(dwTBNew);
            CMenuButtonsMgr* pMenuButtonsMgr = GetMenuButtonsMgr();
            if (NULL != pMenuButtonsMgr)
            {
                sc = pMenuButtonsMgr->ScToggleMenuButton(IsSnapinMenusAllowed());
            }
        }
        break;

    case MID_SNAPIN_BUTTONS:
        dwTBNew = dwTBOld ^ SNAPIN_BUTTONS;
        ShowSnapinButtons(bool(dwTBNew & SNAPIN_BUTTONS));
        break;

    default:
        ASSERT(0 && "Unexpected");
        return;
    }

    SetToolbarsDisplayed(dwTBNew);
}


BOOL CViewData::RetrieveColumnData( const CLSID& refSnapinCLSID,
                                    const SColumnSetID& colID,
                                    CColumnSetData& columnSetData)
{
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
            static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            return pColPersInfo->RetrieveColumnData( refSnapinCLSID, colID,
                                                     GetViewID(), columnSetData);
    }

    return FALSE;
}

BOOL CViewData::SaveColumnData( const CLSID& refSnapinCLSID,
                                const SColumnSetID& colID,
                                CColumnSetData& columnSetData)
{
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
            static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            return pColPersInfo->SaveColumnData( refSnapinCLSID, colID,
                                                 GetViewID(), columnSetData);
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScSaveColumnInfoList
//
//  Synopsis:    Save the CColumnInfoList for given snapin/col-id.
//
//  Arguments:   [refSnapinCLSID] - snapin GUID
//               [colID]          - column-set-id
//               [colInfoList]    - data for columns in a view.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScSaveColumnInfoList(const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                                   const CColumnInfoList& colInfoList)
{
    DECLARE_SC(sc, _T("CViewData::ScSaveColumnInfoList"));
    sc = ScCheckPointers(m_pConsoleData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pConsoleData->m_spPersistStreamColumnData, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnPersistInfo* pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
                                       static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

    sc = ScCheckPointers(pColPersInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnSetData colSetData;

    // Dont care if below succeeds or not, just merge sort & column data.
    pColPersInfo->RetrieveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData);

    colSetData.set_ColumnInfoList(colInfoList);

    sc = pColPersInfo->SaveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScSaveColumnSortData
//
//  Synopsis:    Save the given sort data for persistence into CColumnSetData.
//
//  Arguments:   [refSnapinCLSID] - snapin GUID
//               [colID]          - column-set-id
//               [colSortInfo]    - sort-data.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScSaveColumnSortData(const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                                   const CColumnSortInfo& colSortInfo)
{
    DECLARE_SC(sc, _T("CViewData::ScSaveColumnSortData"));

    sc = ScCheckPointers(m_pConsoleData, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pConsoleData->m_spPersistStreamColumnData, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnPersistInfo* pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
                                       static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

    sc = ScCheckPointers(pColPersInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    CColumnSetData colSetData;

    // Dont care if below succeeds or not, just merge sort & column data.
    pColPersInfo->RetrieveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData);

    CColumnSortList *pColSortList = colSetData.get_ColumnSortList();
    sc = ScCheckPointers(pColSortList, E_UNEXPECTED);
    if (sc)
        return sc;

    pColSortList->clear();
    pColSortList->push_back(colSortInfo);

    sc = pColPersInfo->SaveColumnData(refSnapinCLSID, colID, GetViewID(), colSetData) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    return (sc);
}



VOID CViewData::DeleteColumnData( const CLSID& refSnapinCLSID,
                                  const SColumnSetID& colID)
{
    CColumnPersistInfo* pColPersInfo = NULL;

    if ( (NULL != m_pConsoleData) && (NULL != m_pConsoleData->m_spPersistStreamColumnData) )
    {
        pColPersInfo = dynamic_cast<CColumnPersistInfo*>(
            static_cast<IPersistStream*>(m_pConsoleData->m_spPersistStreamColumnData));

        if (pColPersInfo)
            pColPersInfo->DeleteColumnData( refSnapinCLSID, colID, GetViewID());
    }

    return;
}


/*+-------------------------------------------------------------------------*
 * CViewSettings::GetSelectedNode
 *
 * Returns a pointer to the selected node in the view.
 *--------------------------------------------------------------------------*/

CNode* CViewData::GetSelectedNode () const
{
    CConsoleView* pConsoleView = GetConsoleView();

    if (pConsoleView == NULL)
        return (NULL);

    HNODE hNode = pConsoleView->GetSelectedNode();
    return (CNode::FromHandle(hNode));
}

//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerbs
//
//  Synopsis:    Update all the std-toolbar buttons with
//               current verb state, this is just a wrapper
//               around CStdVerbButtons::ScUpdateStdbarVerbs.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScUpdateStdbarVerbs()
{
    DECLARE_SC (sc, _T("CViewData::ScUpdateStdbarVerbs"));
    CStdVerbButtons* pStdVerbButtons = GetStdVerbButtons();
    if (NULL == pStdVerbButtons)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // Update the std-verb tool-buttons.
    sc = pStdVerbButtons->ScUpdateStdbarVerbs(GetVerbSet());

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update given verb's tool-button, this is just
//               a wrapper around CStdVerbButtons::ScUpdateStdbarVerb.
//
//  Arguments:   [cVerb] - the verb whose button to be updated.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb)
{
    DECLARE_SC (sc, _T("CViewData::ScUpdateStdbarVerb"));
    CStdVerbButtons* pStdVerbButtons = GetStdVerbButtons();
    if (NULL == pStdVerbButtons)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // Update the std-verb tool-buttons.
    sc = pStdVerbButtons->ScUpdateStdbarVerb(cVerb, GetVerbSet());

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      ScUpdateStdbarVerb
//
//  Synopsis:    Update given verb's tool-button, this is just
//               a wrapper around CStdVerbButtons::ScUpdateStdbarVerb.
//
//  Arguments:   [cVerb] - the verb whose button to be updated.
//               [byState] - State of the button to be updated.
//               [bFlag]  - State.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag)
{
    DECLARE_SC (sc, _T("CViewData::ScUpdateStdbarVerb"));
    CStdVerbButtons* pStdVerbButtons = GetStdVerbButtons();
    if (NULL == pStdVerbButtons)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // Update the std-verb tool-buttons.
    sc = pStdVerbButtons->ScUpdateStdbarVerb(cVerb, byState, bFlag);

    return sc;
}



//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScIsVerbSetContextForMultiSelect
//
//  Synopsis:    Get the selection context data stored in verb-set.
//
//  Arguments:   [bMultiSelection] - [out] Is the verb context for multiseleciton?
//
//  Returns:     SC,
//
//--------------------------------------------------------------------
SC CViewData::ScIsVerbSetContextForMultiSelect(bool& bMultiSelection)
{
    DECLARE_SC(sc, _T("CNode::ScIsVerbSetContextForMultiSelect"));
    bMultiSelection = false;

    // 1. Get the verb set.
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(GetVerbSet() );
    sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
    if (sc)
        return sc;

    // 2. Get context information from permanent verb-set.
    CNode *pNode   = NULL;
    LPARAM lCookie = NULL;
    bool   bScopePane;
    bool   bSelected;

    SC scNoTrace = pVerbSet->ScGetVerbSetContext(pNode, bScopePane, lCookie, bSelected);
	if (scNoTrace)
		return sc;  // ignore the error.

    if (LVDATA_MULTISELECT == lCookie)
    {
        bMultiSelection = true;
        return sc;
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CViewData::ScGetVerbSetData
//
//  Synopsis:    Get the selection context data stored in verb-set.
//
//  Arguments:   [ppDataObject] - [out] dataobject of item in the verb-set context.
//                                      This is the item for which last non-temporary MMCN_SELECT
//                                      was sent last time.
//               [ppComponent]  - [out] the above item's component
//               [bScope]       - [out] Is the above item scope or result?
//               [bSelected]    - [out] Is the above item selected or not?
//               [ppszNodeName] - [out] If bScope is true the node name else the name of the node
//                                      that owns result pane. This is for debug purposes only.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewData::ScGetVerbSetData(IDataObject **ppDataObject, CComponent **ppComponent,
                               bool& bScopeItem, bool& bSelected
#ifdef DBG
                        , LPCTSTR *ppszNodeName
#endif
                               )
{
    DECLARE_SC(sc, _T("CNode::ScGetVerbSetData"));
    sc = ScCheckPointers(ppDataObject, ppComponent);
    if (sc)
        return sc;

    *ppDataObject = NULL;
    *ppComponent = NULL;

    // 1. Get the verb set.
    CVerbSet* pVerbSet = dynamic_cast<CVerbSet*>(GetVerbSet() );
    sc = ScCheckPointers( pVerbSet, E_UNEXPECTED );
    if (sc)
        return sc;

    // 2. Get context information from permanent verb-set.
    CNode *pNode   = NULL;
    LPARAM lCookie = NULL;
    bool   bScopePane;

    SC scNoTrace = pVerbSet->ScGetVerbSetContext(pNode, bScopePane, lCookie, bSelected);
	if (scNoTrace)
		return scNoTrace;

    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // 3. Get the dataobject from context information.
    sc = pNode->ScGetDataObject(bScopePane, lCookie, bScopeItem, ppDataObject, ppComponent);
    if (sc)
        return sc;

#ifdef DBG
    if (! ppszNodeName)
        return (sc = E_INVALIDARG);

    *ppszNodeName = pNode->GetDisplayName().data();
#endif

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\viewext.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 2000 - 2000
 *
 *  File:       viewext.h
 *
 *  Contents:   Header file for the built-in view extension snapin that extends
 *              the snapins that ship with windows.
 *
 *  History:    21 March 2000 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


// symbols defined in viewext.cpp
extern const CLSID   CLSID_ViewExtSnapin;
extern       LPCTSTR szClsid_ViewExtSnapin;

// Registration helper.
HRESULT WINAPI RegisterViewExtension (BOOL bRegister, CObjectRegParams& rObjParams, int idSnapinName);

class CViewExtensionSnapin :
    public CComObjectRoot,
    public IExtendView,
    //public ISnapinAbout,
    //public ISnapinHelp,
    public CComCoClass<CViewExtensionSnapin, &CLSID_ViewExtSnapin>
{

public:
    typedef CViewExtensionSnapin ThisClass;

BEGIN_COM_MAP(ThisClass)
    COM_INTERFACE_ENTRY(IExtendView)
    //COM_INTERFACE_ENTRY(ISnapinAbout)
    //COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ThisClass)

    static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
    {                                                   
        CObjectRegParams op (CLSID_ViewExtSnapin, g_szMmcndmgrDll, _T("MMCViewExt 1.0 Object"), _T("NODEMGR.MMCViewExt.1"), _T("NODEMGR.MMCViewExt"));                
                                                        
        return (RegisterViewExtension (bRegister, op, IDS_ViewExtSnapinName));	
    }

public:
    STDMETHODIMP GetViews(LPDATAOBJECT pDataObject, LPVIEWEXTENSIONCALLBACK pViewExtensionCallback);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\viewext.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 2000 - 2000
 *
 *  File:       viewext.cpp
 *
 *  Contents:   Implementation file for the built-in view extension snapin that extends
 *              the snapins that ship with windows.
 *
 *  History:    21 March 2000 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "viewext.h"
#include "util.h"
#include "fldrsnap.h"		// for ScFormatIndirectSnapInName

// {B708457E-DB61-4c55-A92F-0D4B5E9B1224}
const CLSID CLSID_ViewExtSnapin = { 0xb708457e, 0xdb61, 0x4c55, { 0xa9, 0x2f, 0xd, 0x4b, 0x5e, 0x9b, 0x12, 0x24 } };
const GUID  GUID_ExplorerView   = { 0x34723cbb, 0x9676, 0x4770, { 0xa8, 0xdf, 0x60, 0x8, 0x8, 0x53, 0x47, 0x7a } };


#ifdef DBG
    CTraceTag  tagVivekHardCodedViewExtPath(_T("Vivek"), _T("Use view extension d:\\views.htm"));
    CTraceTag  tagDllRegistration (_T("MMC Dll Registration"), _T("View extension registration"));
#endif


/*+-------------------------------------------------------------------------*
 *
 * CViewExtensionSnapin::GetViews
 *
 * PURPOSE: Returns the URL for the extended view.
 *
 * PARAMETERS:
 *    LPDATAOBJECT       pDataObject :
 *    LPVIEWEXTENSIONCALLBACK  pViewExtensionCallback: The callback to add the views into
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CViewExtensionSnapin::GetViews(LPDATAOBJECT pDataObject, LPVIEWEXTENSIONCALLBACK  pViewExtensionCallback)
{
    DECLARE_SC(sc, TEXT("CViewExtensionSnapin::GetView"));

    // check parameters
    sc = ScCheckPointers(pDataObject, pViewExtensionCallback, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    MMC_EXT_VIEW_DATA extViewData = {0};

    USES_CONVERSION;
    TCHAR szBuffer[MAX_PATH * 2];

#ifdef DBG
    if (tagVivekHardCodedViewExtPath.FAny()) // use the hard coded path to make changes easier.
    {
        sc = StringCchCopy(szBuffer, countof(szBuffer), _T("d:\\newnt\\admin\\mmcdev\\nodemgr\\viewext\\views.htm"));
        if(sc)
            return sc.ToHr();
    }
    else
    {
#endif // DBG


    // get the fully qualified path to the dll and append the html page
    sc = StringCchCopy(szBuffer, countof(szBuffer), _T("res://"));
    if(sc)
        return sc.ToHr();

    DWORD dwRet = ::GetModuleFileName (_Module.GetModuleInstance(), szBuffer + _tcslen(szBuffer), countof(szBuffer) - _tcslen(szBuffer));
    if(0==dwRet)
        return (sc.FromLastError().ToHr());


    sc = StringCchCat(szBuffer, countof(szBuffer), _T("/views.htm"));
    if(sc)
        return sc.ToHr();

#ifdef DBG
    }
#endif // DBG

	extViewData.pszURL = T2OLE(szBuffer);

    // set the GUID identifier of the view
    extViewData.viewID = GUID_ExplorerView;

    // set the title for the string.
    CStr strViewTitle;
    strViewTitle.LoadString(GetStringModule(), IDS_ExplorerView); // the name of the view
    extViewData.pszViewTitle = T2COLE(strViewTitle);

    // does not replace the normal view
    extViewData.bReplacesDefaultView = FALSE;

    sc = pViewExtensionCallback->AddView(&extViewData);

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 * szViewExtRegScript
 *
 * Registration script used by RegisterViewExtension.
 *--------------------------------------------------------------------------*/

static const WCHAR szViewExtRegScript[] =
    L"HKLM"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    NoRemove Software"                                                    L"\n"
    L"    {"                                                                    L"\n"
    L"        NoRemove Microsoft"                                               L"\n"
    L"        {"                                                                L"\n"
    L"            NoRemove MMC"                                                 L"\n"
    L"            {"                                                            L"\n"
    L"                NoRemove SnapIns"                                         L"\n"
    L"                {"                                                        L"\n"
    L"                    ForceRemove %VCLSID%"                                 L"\n"
    L"                    {"                                                    L"\n"
    L"                        val NameString = s '%VSnapinName%'"               L"\n"
    L"                        val NameStringIndirect = s '%VSnapinNameIndirect%'" L"\n"
    L"                    }"                                                    L"\n"
    L"                }"                                                        L"\n"
    L"            }"                                                            L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}";


/*+-------------------------------------------------------------------------*
 * RegisterViewExtension
 *
 * Note1: registers mmcndmgr.dll as the module without any path.
 *
 * Note2: Snapin registration does not include nodetypes/about/version...
 *
 *--------------------------------------------------------------------------*/
HRESULT WINAPI RegisterViewExtension (BOOL bRegister, CObjectRegParams& rObjParams, int idSnapinName)
{
    DECLARE_SC (sc, _T("RegisterViewExtension"));

    // First register the com object for this inproc server.
    sc = MMCUpdateRegistry (bRegister, &rObjParams, NULL);
    if (sc)
        return sc.ToHr();

    /*
     * string-ify the CLSID
     */
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID (rObjParams.m_clsid, &spszClsid);
    if (sc)
        return sc.ToHr();

	/*
	 * load the default snap-in name
	 */
	HINSTANCE hInst = GetStringModule();
	CStr strSnapinName;
	strSnapinName.LoadString (hInst, idSnapinName);

	/*
	 * format a MUI-friendly snap-in name
	 */
	CStr strSnapinNameIndirect;
	sc = ScFormatIndirectSnapInName (hInst, idSnapinName, strSnapinNameIndirect);
	if (sc)
		return (sc.ToHr());

    USES_CONVERSION;
#ifdef DBG
    extern CTraceTag tagDllRegistration;
    std::wstring strReplacements;
#endif

#ifdef _ATL_NAMESPACE_BUG_FIXED
    ::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
#else
    MMC_ATL::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
#endif

    _ATL_REGMAP_ENTRY rgExtensionEntries[] =
    {
        {   L"VCLSID",						spszClsid										},
        {   L"VSnapinName",					T2CW (strSnapinName)							},
        {   L"VSnapinNameIndirect",			T2CW (strSnapinNameIndirect)					},
        {   L"VClassName",					rObjParams.m_strClassName.data()				},
        {   L"VProgID",						rObjParams.m_strProgID.data()					},
        {   L"VVersionIndependentProgID",	rObjParams.m_strVersionIndependentProgID.data()	},
    };

    for (int j = 0; j < countof (rgExtensionEntries); j++)
    {
        sc = ro.AddReplacement (rgExtensionEntries[j].szKey, rgExtensionEntries[j].szData);
        if (sc)
            return (sc.ToHr());

        AddReplacementTrace (strReplacements,
                             rgExtensionEntries[j].szKey,
                             rgExtensionEntries[j].szData);
    }

    Trace (tagDllRegistration, _T("Registration script:\n%s"), W2CT(szViewExtRegScript));
    Trace (tagDllRegistration, W2CT(strReplacements.data()));

    /*
     * (un)register!
     */
    sc = (bRegister) ? ro.StringRegister   (szViewExtRegScript)
                     : ro.StringUnregister (szViewExtRegScript);

    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\viewdata.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       viewdata.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/18/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _MMC_VIEWDATA_H_
#define _MMC_VIEWDATA_H_


class CNode;
class CColumnSetData;
class CColumnInfoList;
class CColumnSortInfo;
class CComponent;

// Note: CViewData should have no data of its own!
class CViewData : public SViewData
{
public:
    void ToggleToolbar(long lMenuID);
    void ShowStdButtons(bool b);
    void ShowSnapinButtons(bool b);
    void UpdateToolbars(DWORD dwToolbars);

    SC ScUpdateStdbarVerbs();
    SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb);
    SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag);
    SC ScIsVerbSetContextForMultiSelect(bool& bMultiSelection);
    SC ScGetVerbSetData(IDataObject **ppDataObject, CComponent **ppComponent,
                        bool& bScope, bool& bSelected
#ifdef DBG
                        , LPCTSTR *ppszNodeName
#endif
                        );

// member access methods
public:
    IScopeTree* GetScopeTree() const
    {
        ASSERT(m_pConsoleData != NULL);
        ASSERT(m_pConsoleData->m_spScopeTree != NULL);
        return m_pConsoleData ? m_pConsoleData->m_spScopeTree : NULL;
    }

    INodeCallback * GetNodeCallback() const
    {
        return m_spNodeCallback;
    }

    int GetViewID() const
    {
        return m_nViewID;
    }

    IFramePrivate* GetNodeManager() const
    {
        ASSERT(m_spNodeManager != NULL);
        return m_spNodeManager;
    }

    IResultDataPrivate* GetResultData() const
    {
        ASSERT(m_spResultData != NULL);
        return m_spResultData;
    }

    IImageListPrivate* GetRsltImageList() const
    {
        ASSERT(m_spRsltImageList != NULL);
        return m_spRsltImageList;
    }

    IConsoleVerb* GetVerbSet() const
    {
        ASSERT(m_spVerbSet != NULL);
        return m_spVerbSet;
    }

    HWND GetMainFrame() const
    {
        return m_pConsoleData ? m_pConsoleData->m_hwndMainFrame : NULL;
    }

    CConsoleFrame* GetConsoleFrame() const
    {
        return m_pConsoleData ? m_pConsoleData->GetConsoleFrame() : NULL;
    }

    HWND GetView() const
    {
        return m_hwndView;
    }

    HWND GetListCtrl() const
    {
        return m_hwndListCtrl;
    }

    HWND GetChildFrame() const
    {
        return m_hwndChildFrame;
    }


    // the various view options
    DWORD GetListOptions() const {return m_rvt.GetListOptions();}
    DWORD GetHTMLOptions() const {return m_rvt.GetHTMLOptions();}
    DWORD GetOCXOptions()  const {return m_rvt.GetOCXOptions();}
    DWORD GetMiscOptions() const {return m_rvt.GetMiscOptions();}

    long GetWindowOptions() const
    {
        return m_lWindowOptions;
    }

    IControlbarsCache* GetControlbarsCache()
    {
        if (m_spControlbarsCache == NULL)
            CreateControlbarsCache();

        ASSERT(m_spControlbarsCache != NULL);
        return m_spControlbarsCache;
    }

    CMultiSelection* GetMultiSelection() const
    {
        return m_pMultiSelection;
    }

    void SetMultiSelection(CMultiSelection* pMultiSelection)
    {
        m_pMultiSelection = pMultiSelection;
    }

    bool IsStatusBarVisible(void) const
    {
        return ((m_dwToolbarsDisplayed & STATUS_BAR) != 0);
    }

    bool IsAuthorMode() const
    {
        ASSERT(m_pConsoleData != NULL);
        return ((m_pConsoleData) ? (m_pConsoleData->GetMode() == eMode_Author) : true);
    }

    bool IsUserMode() const
    {
        return (!IsAuthorMode());
    }

    // Needed for "New Window From Here" menu item.
    bool IsUser_SDIMode() const
    {
        return ((m_pConsoleData) ? (m_pConsoleData->GetMode() == eMode_User_SDI) : true);
    }

    bool AllowViewCustomization(void) const
    {
        ASSERT(m_pConsoleData != NULL);

        if (IsUserMode())
            return (!(m_pConsoleData->m_dwFlags & eFlag_PreventViewCustomization));

        return true;
    }

    DWORD GetToolbarsDisplayed(void) const
    {
        return (ToolbarsOf (m_dwToolbarsDisplayed));
    }

    void SetToolbarsDisplayed(DWORD dwToolbars)
    {
        m_dwToolbarsDisplayed = StatusBarOf (m_dwToolbarsDisplayed) |
                                ToolbarsOf (dwToolbars);
    }

    bool IsColumnPersistObjectInitialized()
    {
        if ( (NULL != m_pConsoleData)  &&
             (NULL != m_pConsoleData->m_spPersistStreamColumnData) &&
             (NULL != m_pConsoleData->m_pXMLPersistColumnData) )
            return true;

        return false;
    }

    void InitializeColumnPersistObject(IPersistStream* pPersistStreamColumnData, CXMLObject* pPersistXMLColumnData)
    {
        ASSERT(m_pConsoleData != NULL);

        if ( (NULL != m_pConsoleData ) &&
             (NULL == m_pConsoleData->m_spPersistStreamColumnData) )
        {
            m_pConsoleData->m_spPersistStreamColumnData = pPersistStreamColumnData;
            // NOTE!! the pointer below relies on reference held by m_spPersistStreamColumnData
            m_pConsoleData->m_pXMLPersistColumnData = pPersistXMLColumnData;
            ASSERT(pPersistXMLColumnData != NULL);
        }
    }

    void SetSnapinChangingView()
    {
        m_bSnapinChangingView = TRUE;
    }

    void ResetSnapinChangingView()
    {
        m_bSnapinChangingView = FALSE;
    }

    BOOL IsSnapinChangingView()
    {
        return m_bSnapinChangingView;
    }

public:
    BOOL RetrieveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                             CColumnSetData& columnSetData);

    BOOL SaveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                         CColumnSetData& columnSetData);
    SC ScSaveColumnInfoList(const CLSID& refSnapinCLSID, const SColumnSetID& colID, const CColumnInfoList& colInfoList);
    SC ScSaveColumnSortData(const CLSID& refSnapinCLSID, const SColumnSetID& colID, const CColumnSortInfo& colSortInfo);

    VOID DeleteColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID);

    CNode* GetSelectedNode () const;

private:
    void CreateControlbarsCache();
    void ShowMenuBar();

}; // class CViewData



#endif // _MMC_VIEWDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\viewpers.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      viewpers.cpp
//
//  Contents:  View Persistence data structures.
//
//  History:   04-Apr-99 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "viewpers.h"
#include "macros.h"
#include "comdbg.h"

#define MAX_VIEWITEMS_PERSISTED 50


//------------------------------------------------------------------
// class CViewSettingsPersistor
//------------------------------------------------------------------
CViewSettingsPersistor::CViewSettingsPersistor() :
    m_dwMaxItems(MAX_VIEWITEMS_PERSISTED), m_bDirty(false)
{
	// Now read the registry to see if m_dwMaxItems is specified.
	// Check if the settings key exists.
	CRegKeyEx rSettingsKey;
	if (rSettingsKey.ScOpen (HKEY_LOCAL_MACHINE, SETTINGS_KEY, KEY_READ).IsError())
        return;

	// Read the values for MaxColDataPersisted.
	if (rSettingsKey.IsValuePresent(g_szMaxViewItemsPersisted))
	{
		DWORD  dwType = REG_DWORD;
		DWORD  dwSize = sizeof(DWORD);

		SC sc = rSettingsKey.ScQueryValue (g_szMaxViewItemsPersisted, &dwType,
                                        &m_dwMaxItems, &dwSize);

		if (sc)
			sc.TraceAndClear();
	}
}


//+-------------------------------------------------------------------
//
//  Member:     ScGetViewSettings
//
//  Synopsis:   Given the CViewSettingsID return the CViewSettings object.
//
//  Arguments:  [viewSettingsID] - [in]
//              [viewSettings]   - [out]
//
//  Returns:    SC, S_FALSE if none found.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetViewSettings(const CViewSettingsID& viewSettingsID,
                                             CViewSettings& viewSettings)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScGetViewSettings"));

    // 1. Look in the map if there is persisted data for given id.
    CViewSettingsIDToViewSettingsMap::iterator     itViewSettingsDataMap;
    itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.find(viewSettingsID);
    if (itViewSettingsDataMap == m_mapViewSettingsIDToViewSettings.end())
        return (sc = S_FALSE);

    // Found the data.
    IteratorToViewSettingsList itViewSettings = itViewSettingsDataMap->second;

    // 2. Copy the data.
    viewSettings = *itViewSettings;

    // 3. Move this item to the front of the queue.
    m_listViewSettings.erase(itViewSettings);
    itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(), viewSettings);
    itViewSettingsDataMap->second = itViewSettings;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScSetViewSettings
//
//  Synopsis:   Modify the persisted view information
//              for given view and bookmark (node).
//
//  Arguments:  [nViewID] - Snapin Guid
//              [pBookmark]       - Column Set Identifier.
//              [viewDataSet]        - View ID.
//
//  Returns:    TRUE - Loaded successfully.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetViewSettings(const CViewSettingsID& viewSettingsID,
                                             const CViewSettings& viewSettings,
                                             bool bSetViewDirty)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScSetViewSettings"));

    // 1. Garbage collect if the number of items in the list are 40% more than pre-set limit.
    if (m_listViewSettings.size() >= (m_dwMaxItems * (1 + VIEWSETTINGS_MAXLIMIT)) )
    {
        sc = ScGarbageCollectItems();
        if (sc)
            sc.TraceAndClear();
    }

    // 2. Insert the item into the front of the queue.
    IteratorToViewSettingsList itViewSettings;
    itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(), viewSettings);

    // 3. See if there is data persisted for this id.
    CViewSettingsIDToViewSettingsMap::iterator     itViewSettingsDataMap;
    itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.find(viewSettingsID);

    if (itViewSettingsDataMap == m_mapViewSettingsIDToViewSettings.end()) // not found so insert data.
    {
        m_mapViewSettingsIDToViewSettings.insert(
            CViewSettingsIDToViewSettingsMap::value_type(viewSettingsID, itViewSettings) );
    }
    else
    {
        // found, so replace old settings.
        m_listViewSettings.erase(itViewSettingsDataMap->second);
        itViewSettingsDataMap->second = itViewSettings;
    }

    // dirty flag accumulates.
    m_bDirty = (m_bDirty || bSetViewDirty);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetTaskpadID
//
//  Synopsis:    Given the nodetype & viewid get the taskpad id (this
//               is for taskpads persisted per nodetype).
//
//  Arguments:   [nViewID]      - [in]
//               [guidNodeType] - [in]
//               [guidTaskpad]  - [out]
//
//  Returns:     SC, S_FALSE if none found.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetTaskpadID (int nViewID, const GUID& guidNodeType ,GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetTaskpadID"));

    // 1. Init out param.
    guidTaskpad = GUID_NULL;

    // 2. Construct a CViewSettingsID object with given nodetype & viewid.
    CViewSettingsID viewSettingsID(nViewID, guidNodeType);

    // 3. Get the viewsettings
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);

    // If none exists return
    if (sc != S_OK)
        return sc;

    // 4. CViewSettings exists, see if there is valid taskpad-id stored.
    sc = viewSettings.ScGetTaskpadID(guidTaskpad);

    if (sc) // taskpad-id is not valid.
        return (sc = S_FALSE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetTaskpadID
//
//  Synopsis:    Given the nodetype & viewid set the taskpad id (this
//               is for taskpads persisted per nodetype).
//
//               NOTE: NUKE ANY NODE-SPECIFIC TASKPAD-ID THAT IS STORED.
//
//  Arguments:   [nViewID]      - [in]
//               [guidNodeType] - [in]
//               [bookmark]     - [in]
//               [guidTaskpad]  - [in]
//               [bSetDirty]    - [in] set the console file dirty
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetTaskpadID (int nViewID, const GUID& guidNodeType,
                                           const CBookmark& bookmark, const GUID& guidTaskpad,
                                           bool bSetDirty)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetTaskpadID"));

    // 1. First nuke the the old node specific taskpad-id settings (if any).

    // 1.a) Construct a CViewSettingsID object with given nodetype & viewid.
    CViewSettingsID viewSettingsIDNodeSpecific(nViewID, bookmark);

    // 1.b) Get the viewsettings.
    CViewSettings   viewSettingsNodeSpecific;
    sc = ScGetViewSettings(viewSettingsIDNodeSpecific, viewSettingsNodeSpecific);
    if (sc)
        return sc;

    // data available
    if ( (sc == S_OK) &&
         (viewSettingsNodeSpecific.IsTaskpadIDValid()) )
    {
        // 1.c) Set taskpad id invalid.
        viewSettingsNodeSpecific.SetTaskpadIDValid(false);
        if (sc)
            return sc;

        // 1.d) Save the data.
        sc = ScSetViewSettings(viewSettingsIDNodeSpecific, viewSettingsNodeSpecific, bSetDirty);
    }

    // 2. Now save the taskpad id for nodetype specific.
    // 2.a) Construct a CViewSettingsID object with given nodetype & viewid.
    CViewSettingsID viewSettingsID(nViewID, guidNodeType);

    // 2.b) The CResultViewType & view-mode data are not stored when CViewSettings is stored
    //      per nodetype. So just set the taskpad id.
    CViewSettings   viewSettings;
    sc = viewSettings.ScSetTaskpadID(guidTaskpad);
    if (sc)
        return sc;

    // 2.c) Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, bSetDirty);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetTaskpadID
//
//  Synopsis:    Given the bookmark & viewid get the taskpad id (this
//               is for taskpads persisted per node).
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [guidTaskpad]  - [out]
//
//  Returns:     SC, S_FALSE if none found.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetTaskpadID (int nViewID, const CBookmark& bookmark,GUID& guidTaskpad)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetTaskpadID"));

    // 1. Init out param.
    guidTaskpad = GUID_NULL;

    // 2. Construct a CViewSettingsID object with given bookmark & viewid.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 3. Get the viewsettings
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);

    // If none exists return
    if (sc != S_OK)
        return sc;

    // 4. CViewSettings exists, see if there is valid taskpad-id stored.
    sc = viewSettings.ScGetTaskpadID(guidTaskpad);

    if (sc) // taskpad-id is not valid.
        return (sc = S_FALSE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetTaskpadID
//
//  Synopsis:    Given the bookmark & viewid get the taskpad id (this
//               is for taskpads persisted per nodetype).
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [guidTaskpad]  - [in]
//               [bSetDirty]    - [in] set the console file dirty
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetTaskpadID (int nViewID, const CBookmark& bookmark,
                                           const GUID& guidTaskpad, bool bSetDirty)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetTaskpadID"));

    // 1. Construct a CViewSettingsID object with given bookmark & viewid.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. First get the old settings (if any) and just modify taskpad-id.
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc)
        return sc;

    // 3. If persisted data does not exist dont worry (as CResultViewType and
    //    view mode are invalid), just set taskpad-id.
    sc = viewSettings.ScSetTaskpadID(guidTaskpad);
    if (sc)
        return sc;

    // 4. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, bSetDirty);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetViewMode
//
//  Synopsis:    Given the viewid & bookmark (can identify a node), return
//               the view mode if any persisted.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [ulViewMode]    - [out]
//
//  Returns:     SC, S_FALSE if none.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetViewMode (int nViewID, const CBookmark& bookmark, ULONG&  ulViewMode)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetViewMode"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. see if ViewSettings exist.
    CViewSettings viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc != S_OK)
        return sc;

    sc = viewSettings.ScGetViewMode(ulViewMode);
    if (sc)
        return (sc = S_FALSE);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetViewMode
//
//  Synopsis:    Given view-id & bookmark, set the viewmode in a node
//               specific viewsettings.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [ulViewMode]    - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetViewMode (int nViewID, const CBookmark& bookmark, ULONG ulViewMode)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetViewMode"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. First get the old settings (if any) and just modify viewmode.
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc)
        return sc;

    // 3. If persisted data does not exist dont worry (as CResultViewType and
    //    taskpad-id are invalid), just set viewmode.
    sc = viewSettings.ScSetViewMode(ulViewMode);
    if (sc)
        return sc;

    // 4. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, /*bSetDirty*/ true);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScGetResultViewType
//
//  Synopsis:    Given the viewid & bookmark (can identify a node), return
//               the CResultViewType if persisted.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [rvt]          - [out]
//
//  Returns:     SC, S_FALSE if none.
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGetResultViewType (int nViewID, const CBookmark& bookmark, CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScGetResultViewType"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. see if ViewSettings exist.
    CViewSettings viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc != S_OK)
        return sc;

    sc = viewSettings.ScGetResultViewType(rvt);
    if (sc)
        return (sc = S_FALSE);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetResultViewType
//
//  Synopsis:    Given view-id & bookmark, set the resultviewtype in a node
//               specific viewsettings.
//
//  Arguments:   [nViewID]      - [in]
//               [bookmark]     - [in]
//               [nViewMode]    - [in]
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetResultViewType (int nViewID, const CBookmark& bookmark, const CResultViewType& rvt)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetResultViewType"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. First get the old settings (if any) and just modify resultviewtype.
    CViewSettings   viewSettings;
    sc = ScGetViewSettings(viewSettingsID, viewSettings);
    if (sc)
        return sc;

    // 3. If persisted data does not exist dont worry (as view-mode and
    //    taskpad-id are invalid), just set resultviewtype.
    sc = viewSettings.ScSetResultViewType(rvt);
    if (sc)
        return sc;

    // 4. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, /*bSetDirty*/ true);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CViewSettingsPersistor::ScSetFavoriteViewSettings
//
//  Synopsis:    A favorite is selected and it sets viewsettings
//               before re-selecting the node so that after re-selection
//               the new settings are set for the view. So dont set the
//               console file dirty.
//
//  Arguments:   [nViewID]      -
//               [bookmark]     -
//               [viewSettings] -
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark,
                                                      const CViewSettings& viewSettings)
{
    DECLARE_SC(sc, _T("CViewSettingsPersistor::ScSetFavoriteViewSettings"));

    // 1. Construct the viewsettings-id.
    CViewSettingsID viewSettingsID(nViewID, bookmark);

    // 2. Save the viewsettings into the map.
    sc = ScSetViewSettings(viewSettingsID, viewSettings, /*bSetDirty*/ false);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:     ScDeleteDataOfView
//
//  Synopsis:   Delete the data of given view.
//
//  Arguments:  [nViewID] - View ID.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScDeleteDataOfView( int nViewID)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScDeleteDataOfView"));

    // Find the data for the view.
    CViewSettingsIDToViewSettingsMap::iterator  itViewSettingsDataMap;

    for (itViewSettingsDataMap  = m_mapViewSettingsIDToViewSettings.begin();
         itViewSettingsDataMap != m_mapViewSettingsIDToViewSettings.end();
         ++itViewSettingsDataMap)
    {
        const CViewSettingsID& viewSettingsID = itViewSettingsDataMap->first;
        if (viewSettingsID.get_ViewID() == nViewID)
        {
            // Delete the item;
            IteratorToViewSettingsList itViewSettings = itViewSettingsDataMap->second;
            itViewSettings->SetObjInvalid(TRUE);
        }
    }

    // Delete the invalid items.
    sc = ScDeleteMarkedItems();
    if (sc)
        return sc;

    return sc;
}



//+-------------------------------------------------------------------
//
//  Member:     ScGarbageCollectItems
//
//  Synopsis:   Free least used data.
//
//  Arguments:  None.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScGarbageCollectItems()
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScGarbageCollectItems"));

    INT nItemsToBeRemoved = VIEWSETTINGS_MAXLIMIT * m_dwMaxItems;

    // Go thro' the list and set the nItemsToBeRemoved that was least recently
    // accessed to be invalid.
    INT nIndex = 0;
    IteratorToViewSettingsList itViewSettings;

    // Skip first m_dwMaxItems.
    for (itViewSettings  = m_listViewSettings.begin();
         ( (itViewSettings != m_listViewSettings.end()) && (nIndex <= m_dwMaxItems) );
         ++itViewSettings, nIndex++)
    {
        nIndex++;
    }

    // Mark rest of the items to be garbage.
    while (itViewSettings != m_listViewSettings.end())
    {
        itViewSettings->SetObjInvalid(TRUE);
        ++itViewSettings;
    }

    // Delete the invalid items.
    sc = ScDeleteMarkedItems();
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScDeleteMarkedItems
//
//  Synopsis:   Delete invalidated items. This involves iterating thro
//              the maps to find the invalid items. Then deleting the
//              items. If the map becomes empty then delete the map.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
SC CViewSettingsPersistor::ScDeleteMarkedItems()
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::ScDeleteMarkedItems"));

    CViewSettingsIDToViewSettingsMap::iterator itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.begin();

    // Iterate through the map to see if there are
    // invalidated items.
    while (m_mapViewSettingsIDToViewSettings.end() != itViewSettingsDataMap)
    {
        IteratorToViewSettingsList itViewSettings = itViewSettingsDataMap->second;
        if (itViewSettings->IsObjInvalid())
        {
            // Delete the item ref from the map.
            // Erase returns iterator to next item.
            itViewSettingsDataMap = m_mapViewSettingsIDToViewSettings.erase(itViewSettingsDataMap);

            // Delete the item from the list.
            m_listViewSettings.erase(itViewSettings);
        }
        else
            ++itViewSettingsDataMap;        // Item is valid so get next item.
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   Load the persisted view information.
//
//  Arguments:  [pStream]- IStream from which view data will be loaded.
//
//  Returns:    S_OK - Loaded successfully.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
HRESULT CViewSettingsPersistor::Load (IStream* pStream)
{
    HRESULT hr = E_FAIL;

    // read the column width information.
    try
    {
        do
        {
            // Read the version. If it did not match return
            INT   nVersion                      = 0;
            *pStream >> nVersion;
            if (ViewSettingPersistenceVersion != nVersion)
                return S_FALSE;

            // Read the # of Snapins
            DWORD dwNumItems = 0;
            *pStream >> dwNumItems;

            m_listViewSettings.clear();
            m_mapViewSettingsIDToViewSettings.clear();

            for (int i = 0; i < dwNumItems; i++)
            {
                // Read the ID.
                CViewSettingsID viewSettingsID;
                *pStream >> viewSettingsID;

                // Read the data.
                CViewSettings viewSettings;
                viewSettings.Read(*pStream);

                // Insert the data into the list.
                IteratorToViewSettingsList itViewSettings;
                itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(),
                                                           viewSettings);

                // Insert the data into the map.
                m_mapViewSettingsIDToViewSettings.insert(
                    CViewSettingsIDToViewSettingsMap::value_type(viewSettingsID, itViewSettings) );
            }

            m_listViewSettings.sort();

        } while (FALSE);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }
    catch (...)
    {
        ASSERT (0 && "Unexpected exception");
        throw;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   Persist the view information.
//
//  Arguments:  [pStream]- IStream in which data is persisted.
//
//  Returns:    S_OK - Saved successfully.
//
//  History:    04-26-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
HRESULT CViewSettingsPersistor::Save (IStream* pStream, BOOL bClearDirty)
{
    // absolete method.
    // this method is left here since we use IPersistStream to export
    // persistence to CONUI side and need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:     Persist
//
//  Synopsis:   Persist the view information.
//
//  Arguments:  [CPersistor]- Persistor in/from which data is persisted.
//
//  Returns:    void
//
//  History:    11-08-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CViewSettingsPersistor::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::Persist"));

    if (persistor.IsStoring())
    {
        // Give ranking to each CViewSettings instance.
        IteratorToViewSettingsList itViewSettings;
        DWORD dwRank = 0;
        for (itViewSettings  = m_listViewSettings.begin();
             itViewSettings != m_listViewSettings.end();
             ++itViewSettings)
        {
            dwRank++;
            itViewSettings->SetUsageRank(dwRank);
        }

        CViewSettingsIDToViewSettingsMap::iterator itViewSettingsDataMap;
        for (itViewSettingsDataMap  = m_mapViewSettingsIDToViewSettings.begin();
             itViewSettingsDataMap != m_mapViewSettingsIDToViewSettings.end();
             ++itViewSettingsDataMap)
        {
            // Write the ID.
            persistor.Persist(*const_cast<CViewSettingsID *>(&itViewSettingsDataMap->first));
            // Write the data.
            persistor.Persist(*itViewSettingsDataMap->second);
        }
    }
    else
    {
        // let the base class do the job
        // it will call OnNewElement for every element found
        XMLMapCollectionBase::Persist(persistor);
        // some extra loading actions
        m_listViewSettings.sort();
    }

    // either way we are the same as the file copy
    m_bDirty = false;
}

//+-------------------------------------------------------------------
//
//  Member:     OnNewElement
//
//  Synopsis:   Called for each new data pair read.
//
//  Arguments:  [persistKey]- Persistor from which key is to be loaded
//              [persistVal]- Persistor from which value is to be loaded
//
//  Returns:    void
//
//  History:    11-08-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CViewSettingsPersistor::OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
{
    DECLARE_SC(sc, TEXT("CViewSettingsPersistor::OnNewElement"));

    // Read the ID.
    CViewSettingsID viewSettingsID;
    persistKey.Persist(viewSettingsID);

    // Read the data.
    CViewSettings viewSettings;
    persistVal.Persist(viewSettings);

    // Insert the data into the list.
    IteratorToViewSettingsList itViewSettings;
    itViewSettings = m_listViewSettings.insert(m_listViewSettings.begin(),
                                           viewSettings);

    // Insert the data into the map.
    m_mapViewSettingsIDToViewSettings.insert(
        CViewSettingsIDToViewSettingsMap::value_type(viewSettingsID, itViewSettings) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\viewpers.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       viewpers.h
//
//  Contents:   Classes related to view setting persistence.
//
//  Classes:    CViewSettingsID and CViewSettingPersistor.
//
//  History:    04-Apr-99 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef __VIEWPERS_H__
#define __VIEWPERS_H__
#pragma once
#include "bookmark.h"

#pragma warning(disable: 4503) // Disable long name limit warnings

using namespace std;

class  CViewSettings;
class  CBookmark;

/*************************************************************************
 *
 * How CViewSettingsPersistor is used:
 * There is only one CViewSettingsPersistor object per document.
 *
 * The object stored as static variable inside CNode as CNode needs
 * to access this object frequently.
 *
 * The Document needs to initialize/save the object by loading/savind
 * from/to console file. It calls below ScQueryViewSettingsPersistor.
 *
 * The object is created with first call to ScQueryViewSettingsPersistor.
 * The object is destroyed when DocumentClosed event is received.
 *
 *************************************************************************/


//+-------------------------------------------------------------------
// View Setting Persistence Versioning
// This version info is used for MMC1.2 IPersist* interfaces.
// In MMC2.0, XML maintains versioning using the tags, so this
// constant is not used. Look at CViewPersistInfo members Load/Save
// to see how this version information is used.
static const INT ViewSettingPersistenceVersion = 2;

// We allow the list to grow VIEWSETTINGS_MAXLIMIT times more,
// then we do garbage collection.
#define  VIEWSETTINGS_MAXLIMIT           0.4



//+-------------------------------------------------------------------
//
//  Class:      CViewSettingsID
//
//  Purpose:    To identify the result-view-setting-data. The identifier
//              consists of the triplet [ViewID, NodeTypeGUID, Node-Bookmark]
//
//              We need to persist some result-view-setting-data per node and
//              some per node-type basis.
//
//              The [ViewID + Node-Bookmark] identifies a node. In this case
//              NodeTypeGUID will be GUID_NULL.
//
//              The [ViewID + NodeTypeGUID] identifies a nodetype. In this case
//              Node-Bookmark will be invalid object (see CBookmark for invalid obj).
//
//  History:    06-22-2000   AnandhaG   Created
//
//--------------------------------------------------------------------
class CViewSettingsID : public CXMLObject
{
public:
    friend class  CViewPersistInfo;

    friend IStream& operator>> (IStream& stm, CViewSettingsID& viewSettingsID);

public:
    CViewSettingsID() : m_dwViewID(-1), m_nodeTypeGUID(GUID_NULL)
    {
        // m_bookmark is initialized as not valid by default constructor
    }

    //  Synopsis:    Given the view-id & bookmark (not nodetypeguid) construct
    //               a CViewSettingsID object (with GUID_NULL as nodetypeguid).
    CViewSettingsID(INT nViewID, const CBookmark& bookmark)
    {
        m_dwViewID     = nViewID;
        m_bookmark     = bookmark;
        m_nodeTypeGUID = GUID_NULL;
    }

    //  Synopsis:    Given the view-id & nodetype guid (not bookmark) construct
    //               a CViewSettingsID object (with invalid bookmark).
    CViewSettingsID(INT nViewID, const GUID& guidNodeType)
    {
        m_dwViewID     = nViewID;
        m_nodeTypeGUID = guidNodeType;
        // m_bookmark is initialized as not valid by default constructor
    }
/*
    CViewSettingsID(const CViewSettingsID& viewSettingsID)
    {
        m_dwViewID     = viewSettingsID.m_dwViewID;
        m_bookmark     = viewSettingsID.m_bookmark;
        m_nodeTypeGUID = viewSettingsID.m_nodeTypeGUID;
    }

    CViewSettingsID& operator=(const CViewSettingsID& viewSettingsID)
    {
        if (this != &viewSettingsID)
        {
            m_dwViewID     = viewSettingsID.m_dwViewID;
            m_bookmark     = viewSettingsID.m_bookmark;
            m_nodeTypeGUID = viewSettingsID.m_nodeTypeGUID;
        }

        return (*this);
    }

    bool operator==(const CViewSettingsID& viewSettingsID) const
    {
        return ((m_dwViewID     == viewSettingsID.m_dwViewID) &&
                (m_bookmark     == viewSettingsID.m_bookmark) &&
                (m_nodeTypeGUID == viewSettingsID.m_nodeTypeGUID) );
    }
*/
    /*
     Compare view id first, then guid and then bookmark.
     */
    bool operator<(const CViewSettingsID& viewSettingsID) const
    {
        // First compare view-ids (low cost).
        if (m_dwViewID < viewSettingsID.m_dwViewID)
            return true;

        if (m_dwViewID > viewSettingsID.m_dwViewID)
            return false;

        // The view-ids match so now compare GUIDs.
        if (m_nodeTypeGUID < viewSettingsID.m_nodeTypeGUID)
            return true;

        if (m_nodeTypeGUID > viewSettingsID.m_nodeTypeGUID)
            return false;

        // The view-ids as well as guids match so compare bookmarks.
        if (m_bookmark < viewSettingsID.m_bookmark)
            return true;

        return false;
    }

    DWORD get_ViewID() const { return m_dwViewID;}

    virtual void Persist(CPersistor &persistor)
    {
        persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_ID_VIEW,  m_dwViewID);
        persistor.PersistAttribute(XML_ATTR_NODETYPE_GUID, m_nodeTypeGUID, attr_optional); // optional

		/*
		 * Storing: save book mark only if it is valid.
		 * Loading: See if bookmark is present for this element before reading.
		 */
		if ( ( persistor.IsStoring() && m_bookmark.IsValid() ) || 
			 ( persistor.IsLoading() && persistor.HasElement(m_bookmark.GetXMLType(), NULL) ))
	        persistor.Persist(m_bookmark);

    }
    DEFINE_XML_TYPE(XML_TAG_VIEW_SETTINGS_ID);
protected:
    CBookmark           m_bookmark;
    GUID                m_nodeTypeGUID;
    DWORD               m_dwViewID;
};


//+-------------------------------------------------------------------
//
//  Member:     operator>>
//
//  Synopsis:   Reads CViewSettingsID data from the stream.
//
//  Arguments:  [stm]            - The input stream.
//              [viewSettingsID] - CViewSettingsID object.
//
//                          The format is :
//                              DWORD viewID
//                              CBookmark*
//
//--------------------------------------------------------------------
inline IStream& operator>> (IStream& stm, CViewSettingsID& rvsd)
{
    ASSERT(rvsd.m_nodeTypeGUID == GUID_NULL);

    rvsd.m_nodeTypeGUID = GUID_NULL;
    return (stm >> rvsd.m_dwViewID >> rvsd.m_bookmark);
}


//+-------------------------------------------------------------------
//
//  Data structures used to persist view information:
//
// View information is persisted as follows:
// Internally, the following data structure is used. View information
// is recorded per view.
//                      map
// [View ID, NodeTypeGUID, Bookmark]------> iterator to a list containing CViewSettings.
//
// The list contains CViewSettings to all the views, and  is ordered
// in with most recently used data in the front of the list.
// This is useful for garbage collection.
//
// Persistence: The information is serialized as follows:
//
// 1) Stream version
// 2) Number of viewSettings
// 3) For each viewSettings
//    i)  CViewSettingsID (the identifier).
//    ii) CViewSettings(the data).
//
//--------------------------------------------------------------------

typedef list<CViewSettings>                        CViewSettingsList;
typedef CViewSettingsList::iterator                IteratorToViewSettingsList;

// A one to one map from CViewSettings to pointer to CViewSettings.
typedef map<CViewSettingsID, IteratorToViewSettingsList>   CViewSettingsIDToViewSettingsMap;

//+-------------------------------------------------------------------
//
//  Class:      CViewSettingsPersistor
//
//  Purpose:    This class has persisted settings information for nodes & nodetypes
//              in all views (therefore one per instance of mmc).
//              It knows to load/save the info from streams.
//
//  History:    04-23-1999   AnandhaG   Created
//
//  Data structures used to persist view information:
//      A map from the CViewSettingsID to pointer to CViewSettings class.
//
//--------------------------------------------------------------------
class CViewSettingsPersistor : public IPersistStream,
                               public CComObjectRoot,
                               public XMLMapCollectionBase
{
private:
    CViewSettingsList                 m_listViewSettings;
    CViewSettingsIDToViewSettingsMap  m_mapViewSettingsIDToViewSettings;

    bool                                 m_bDirty;

    // This is the max number of items specified by user???
    // We go 40% more so that we dont do garbage collection often.
    DWORD                                m_dwMaxItems;

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CViewSettingsPersistor)
        COM_INTERFACE_ENTRY (IPersistStream)
    END_COM_MAP ()

    CViewSettingsPersistor();

    SC   ScDeleteDataOfView( int nViewID);

    // IPersistStream methods
    STDMETHOD(IsDirty)(void) { return ( m_bDirty ? S_OK : S_FALSE); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { ASSERT(FALSE); return E_NOTIMPL;}
    STDMETHOD(GetClassID)(LPCLSID lpClsid) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);

    // XML persistence helpers
    virtual void Persist(CPersistor &persistor);
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal);
    DEFINE_XML_TYPE(XML_TAG_VIEW_PERSIST_INFO)

    // Members to access viewsettings data.

    // 1. Taskpad IDs.
    // 1.a) Per NodeTypeGUID
    SC   ScGetTaskpadID(int nViewID, const GUID& guidNodeType ,GUID& guidTaskpad);
    SC   ScSetTaskpadID(int nViewID, const GUID& guidNodeType ,const CBookmark& bookmark,
                        const GUID& guidTaskpad, bool bSetDirty);

    // 1.b) Per node
    SC   ScGetTaskpadID(int nViewID, const CBookmark& bookmark,GUID& guidTaskpad);
    SC   ScSetTaskpadID(int nViewID, const CBookmark& bookmark,const GUID& guidTaskpad, bool bSetDirty);

    // 2. View mode.
    SC   ScGetViewMode (int nViewID, const CBookmark& bookmark, ULONG&  ulViewMode);
    SC   ScSetViewMode (int nViewID, const CBookmark& bookmark, ULONG   ulViewMode);

    // 3. ResultViewTypeInfo.
    SC   ScGetResultViewType   (int nViewID, const CBookmark& bookmark, CResultViewType& rvt);
    SC   ScSetResultViewType   (int nViewID, const CBookmark& bookmark, const CResultViewType& rvt);

    SC   ScSetFavoriteViewSettings (int nViewID, const CBookmark& bookmark, const CViewSettings& viewSettings);

private:
    SC   ScGetViewSettings( const CViewSettingsID& viewSettingsID, CViewSettings& viewSettings);
    SC   ScSetViewSettings( const CViewSettingsID& viewSettingsID, const CViewSettings& viewSettings, bool bSetViewDirty);

    SC   ScGarbageCollectItems();
    SC   ScDeleteMarkedItems();
};

#endif /* __VIEWPERS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\atltask.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       atltask.h
//
//--------------------------------------------------------------------------

#ifndef _ATL_TASKPAD_H_
#define _ATL_TASKPAD_H_

#include "SnapHelp.h"

//
// Derive from this class if you'd like to use the
// IExtendTaskpadImpl implementation in your snap-in.
//
class CTaskpadItem
{
public:
	//
	// Should be overridden by client.
	//
	STDMETHOD( TaskNotify )( IConsole* pConsole, VARIANT* arg, VARIANT* param )
	{
		UNUSED_ALWAYS( arg );
		UNUSED_ALWAYS( param );
		return( E_NOTIMPL );
	}

	//
	// Should be overridden by client.
	//
	STDMETHOD( EnumTasks )( LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK )
	{
		UNUSED_ALWAYS( szTaskGroup );
		UNUSED_ALWAYS( ppEnumTASK );
		return( E_NOTIMPL );
	}

protected:
	//
	// Given a destination and source task list, this copies the
	// strings using CoTaskMemAlloc, and also adds module file path
	// information as appropriate.
	//
	int CoTasksDup( MMC_TASK* pDestTasks, MMC_TASK* pSrcTasks, int nNumTasks )
	{
		USES_CONVERSION;
		_ASSERTE( pDestTasks != NULL );
		_ASSERTE( pSrcTasks != NULL );
		_ASSERTE( nNumTasks > 0 );
		int nCopied = 0;
		TCHAR szImagesPath[ _MAX_PATH * 2 ];
		TCHAR szBuf[ _MAX_PATH * 2 ];

		try
		{
			//
			// Get the path of our module.
			//
			_tcscpy( szImagesPath, _T( "res://" ) );
			if ( GetModuleFileName( _Module.GetModuleInstance(), szImagesPath + _tcslen( szImagesPath ), MAX_PATH ) == 0 )
				throw;

			//
			// Append another seperator.
			//
			_tcscat( szImagesPath, _T( "/" ) );

			//
			// Initialize the destination tasks.
			//
			memset( pDestTasks, 0, sizeof( MMC_TASK ) * nNumTasks );
			
			//
			// Loop through and copy each appropriate task.
			//
			for ( int i = 0; i < nNumTasks; i++ )
			{
				//
				// Copy the display object.
				//
				switch( pSrcTasks[ i ].sDisplayObject.eDisplayType )
				{
				case MMC_TASK_DISPLAY_TYPE_SYMBOL:
					pDestTasks[ i ].sDisplayObject.uSymbol.szFontFamilyName = CoTaskDupString( pSrcTasks[ i ].sDisplayObject.uSymbol.szFontFamilyName );
					pDestTasks[ i ].sDisplayObject.uSymbol.szURLtoEOT = CoTaskDupString( pSrcTasks[ i ].sDisplayObject.uSymbol.szURLtoEOT );
					pDestTasks[ i ].sDisplayObject.uSymbol.szSymbolString = CoTaskDupString( pSrcTasks[ i ].sDisplayObject.uSymbol.szSymbolString );
					break;

				default:
					_tcscpy( szBuf, szImagesPath );
					_tcscat( szBuf, W2T( pSrcTasks[ i ].sDisplayObject.uBitmap.szMouseOverBitmap ) );
					pDestTasks[ i ].sDisplayObject.uBitmap.szMouseOverBitmap = CoTaskDupString( T2W( szBuf ) );
					_tcscpy( szBuf, szImagesPath );
					_tcscat( szBuf, W2T( pSrcTasks[ i ].sDisplayObject.uBitmap.szMouseOffBitmap ) );
					pDestTasks[ i ].sDisplayObject.uBitmap.szMouseOffBitmap = CoTaskDupString( T2W( szBuf ) );
					break;
				}

				//
				// Copy the display type.
				//
				pDestTasks[ i ].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;

				//
				// Copy the help string.
				//
				pDestTasks[ i ].szHelpString = CoTaskDupString( pSrcTasks[ i ].szHelpString );

				//
				// Handle the button text.
				//
				pDestTasks[ i ].szText = CoTaskDupString( pSrcTasks[ i ].szText );

				//
				// Handle the action type.
				//
				pDestTasks[ i ].eActionType = pSrcTasks[ i ].eActionType;

				//
				// Based on the action type, handle the appropriate union member.
				//
				switch( pDestTasks[ i ].eActionType )
				{
				case MMC_ACTION_ID:
					pDestTasks[ i ].nCommandID = pSrcTasks[ i ].nCommandID;
					break;
				case MMC_ACTION_LINK:
					pDestTasks[ i ].szActionURL = CoTaskDupString( pSrcTasks[ i ].szActionURL );
					break;
				case MMC_ACTION_SCRIPT:
					pDestTasks[ i ].szScript = CoTaskDupString( pSrcTasks[ i ].szScript );
					break;
				}

				//
				// Increment our successful copy.
				//
				nCopied++;
			}
		}
		catch(...)
		{
			//
			// Likely thrown by the cotaskdup() allocations.
			//
		}

		return( nCopied );
	}
};

template <class T>        
class ATL_NO_VTABLE IExtendTaskPadImpl : public IExtendTaskPad
{
public:
	STDMETHOD( TaskNotify )( LPDATAOBJECT pdo, VARIANT* arg, VARIANT* param)
	{
		HRESULT hr = E_POINTER;
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;

		//
		// Retrieve the data class from the passed in object.
		//
		hr = pT->m_pComponentData->GetDataClass( pdo, &pItem, &type );
		if (SUCCEEDED(hr))
		{
			CTaskpadItem* pTaskpadItem = dynamic_cast< CTaskpadItem* >( pItem );
			if ( pTaskpadItem )
			{
				//
				// We're guaranteed that the passed in object will be one
				// of ours since we should have derived from it.
				//
				hr = pTaskpadItem->TaskNotify( pT->m_spConsole, arg, param );
			}
		}

		return( hr );
	}

	STDMETHOD( EnumTasks )( IDataObject * pdo, LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK )
	{
		HRESULT hr = E_POINTER;
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;

		//
		// Retrieve the data class from the passed in object.
		//
		hr = pT->m_pComponentData->GetDataClass( pdo, &pItem, &type );
		if (SUCCEEDED(hr))
		{
			CTaskpadItem* pTaskpadItem = dynamic_cast< CTaskpadItem* >( pItem );
			if ( pTaskpadItem )
			{
				//
				// We're guaranteed that the passed in object will be one
				// of ours since we should have derived from it.
				//
				hr = pTaskpadItem->EnumTasks( szTaskGroup, ppEnumTASK );
			}
		}

		return( hr );
	}

	STDMETHOD( GetTitle )( LPOLESTR pszGroup, LPOLESTR * pszTitle )
	{
		UNUSED_ALWAYS( pszGroup );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		T* pT = static_cast<T*>(this);

		try
		{
			//
			// Allocate memory for the title.
			//
			*pszTitle = (LPOLESTR) CoTaskMemAlloc( ( wcslen( pT->m_pszTitle ) + 1 ) * sizeof( OLECHAR ) );
			if ( pszTitle == NULL )
				throw;

			//
			// Copy the title.
			//
			wcscpy( *pszTitle, pT->m_pszTitle );
			hr = S_OK;
		}
		catch( ... )
		{
		}

		return( hr );
	}

	STDMETHOD( GetBackground )( LPOLESTR pszGroup, MMC_TASK_DISPLAY_OBJECT * pTDO )
	{
		UNUSED_ALWAYS( pszGroup );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		T* pT = static_cast<T*>(this);
		TCHAR szModulePath[ _MAX_PATH ];
		OLECHAR szBackgroundPath[ _MAX_PATH ];

		try
		{
			//
			// In the taskpad case, the module path of MMC.EXE should be
			// obtained. Use the template contained therein.
			//
			if ( GetModuleFileName( _Module.GetModuleInstance(), szModulePath, _MAX_PATH ) == 0 )
				throw;

			//
			// Append the necessary decorations for correct access.
			//
			wcscpy( szBackgroundPath, L"res://" );
			wcscat( szBackgroundPath, T2W( szModulePath ) );
			wcscat( szBackgroundPath, L"/" );
			wcscat( szBackgroundPath, pT->m_pszBackgroundPath );

			pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
			pTDO->uBitmap.szMouseOverBitmap = CoTaskDupString( szBackgroundPath );
			if ( pTDO->uBitmap.szMouseOverBitmap == NULL )
				throw;
			pTDO->uBitmap.szMouseOffBitmap = NULL;

			hr = S_OK;
		}
		catch( ... )
		{
		}

		return( hr );
	}

	STDMETHOD( GetDescriptiveText )( LPOLESTR pszGroup, LPOLESTR * pszDescriptiveText )
	{
		UNUSED_ALWAYS( pszGroup );
		UNUSED_ALWAYS( pszDescriptiveText );
		return( E_NOTIMPL );
	}

	STDMETHOD( GetListPadInfo )( LPOLESTR pszGroup, MMC_LISTPAD_INFO * lpListPadInfo )
	{
		UNUSED_ALWAYS( pszGroup );
		UNUSED_ALWAYS( lpListPadInfo );
		return( E_NOTIMPL );
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\nodemgr\wiz97.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File:       wiz97.h
 *
 *  Contents:   Templates and classes for wizard 97 property sheets
 *
 *  History:    02-03-2000 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

//############################################################################
//############################################################################
//
//  class CWizard97WelcomeFinishPage
//
//############################################################################
//############################################################################
template<class T>
class CWizard97WelcomeFinishPage : public WTL::CPropertyPageImpl<T>
{
public:
    CWizard97WelcomeFinishPage()
    {
        /*
         * welcome and finish pages in Wizard97-style wizards don't have headers
         */
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }
};

//############################################################################
//############################################################################
//
//  class CWizard97InteriorPage
//
//############################################################################
//############################################################################
template<class T>
class CWizard97InteriorPage : public WTL::CPropertyPageImpl<T>
{
public:
    CWizard97InteriorPage()
    {
        /*
         * Wizard97-style pages have titles, subtitles and header bitmaps
         */
        VERIFY (m_strTitle.   LoadString(GetStringModule(), T::IDS_Title));
        VERIFY (m_strSubtitle.LoadString(GetStringModule(), T::IDS_Subtitle));

        m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle    = m_strTitle.data();
        m_psp.pszHeaderSubTitle = m_strSubtitle.data();
    }

private:
    tstring m_strTitle;
    tstring m_strSubtitle;
};

//############################################################################
//############################################################################
//
//  class CWizardPage
//
//############################################################################
//############################################################################
class CWizardPage
{
    static WTL::CFont m_fontWelcome;
    static void  InitFonts         (HWND hWnd);
public:
    static void  OnWelcomeSetActive(HWND hWnd);
    static void  OnWelcomeKillActive(HWND hWnd);
    static void  OnInitWelcomePage (HWND hWnd);
    static void  OnInitFinishPage  (HWND hWnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\benefits.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       benefits.h
//
//--------------------------------------------------------------------------

#ifndef __BENEFITS_H_
#define __BENEFITS_H_
#include "resource.h"
#include <atlsnap.h>
#include "snaphelp.h"
#include "atltask.h"
#include "BenSvr.h"
#include "Employee.h"

//
// Property page containing employee information.
//
class CEmployeeNamePage : public CSnapInPropertyPageImpl<CEmployeeNamePage>
{
public :
	CEmployeeNamePage(long lNotifyHandle, bool fStartup, bool bDeleteHandle = false, TCHAR* pTitle = NULL) : 
		CSnapInPropertyPageImpl<CEmployeeNamePage> (pTitle),\
		m_fStartup( fStartup ),
		m_lNotifyHandle(lNotifyHandle),
		m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
	{
		m_pEmployee = NULL;
	}

	~CEmployeeNamePage()
	{
		if (m_bDeleteHandle)
			MMCFreeNotifyHandle(m_lNotifyHandle);
	}

	enum { IDD = IDD_NAME_PAGE };

	BEGIN_MSG_MAP(CEmployeeNamePage)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		COMMAND_CODE_HANDLER( EN_CHANGE, OnChange )
		CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CEmployeeNamePage>)
	END_MSG_MAP()

	HRESULT PropertyChangeNotify(long param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

	//
	// Handler to initialize values in dialog.
	//
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );

	//
	// Calls OnWizardFinish() to handle the storage of employee
	// data.
	//
	BOOL OnApply() { return( OnWizardFinish() ); };

	//
	// Calls OnWizardFinish() to handle the storage of employee
	// data.
	//
	BOOL OnWizardNext() { return( OnWizardFinish() ); };

	//
	// This is overridden to modify the UI depending on whether
	// we're in start-up mode or not.
	//
	BOOL OnSetActive();

	//
	// Overridden to store new values of employee.
	//
	BOOL OnWizardFinish();

	//
	// Called when one of the values has been modified. We need
	// to inform the property page of the change.
	//
	LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		UNUSED_ALWAYS( wNotifyCode );
		UNUSED_ALWAYS( wID );
		UNUSED_ALWAYS( hWndCtl );
		UNUSED_ALWAYS( bHandled );

		SetModified();

		return( TRUE );
	}

public:
	long m_lNotifyHandle;
	bool m_bDeleteHandle;
	CEmployee* m_pEmployee;
	bool m_fStartup;
};

//
// Property page containing employee information.
//
class CEmployeeAddressPage : public CSnapInPropertyPageImpl<CEmployeeAddressPage>
{
public :
	CEmployeeAddressPage(long lNotifyHandle, bool fStartup, bool bDeleteHandle = false, TCHAR* pTitle = NULL) : 
		CSnapInPropertyPageImpl<CEmployeeAddressPage> (pTitle),\
		m_fStartup( fStartup ),
		m_lNotifyHandle(lNotifyHandle),
		m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
	{
		m_pEmployee = NULL;
	}

	~CEmployeeAddressPage()
	{
		if (m_bDeleteHandle)
			MMCFreeNotifyHandle(m_lNotifyHandle);
	}

	enum { IDD = IDD_ADDRESS_PAGE };

	BEGIN_MSG_MAP(CEmployeeAddressPage)
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		COMMAND_CODE_HANDLER( EN_CHANGE, OnChange )
		CHAIN_MSG_MAP(CSnapInPropertyPageImpl<CEmployeeAddressPage>)
	END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT PropertyChangeNotify(long param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

	//
	// Handler to initialize values in dialog.
	//
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );

	//
	// Calls OnWizardFinish() to handle the storage of employee
	// data.
	//
	BOOL OnApply() { return( OnWizardFinish() ); };

	//
	// This is overridden to modify the UI depending on whether
	// we're in start-up mode or not.
	//
	BOOL OnSetActive();

	//
	// Overridden to store new values of employee.
	//
	BOOL OnWizardFinish();

	//
	// Called when one of the values has been modified. We need
	// to inform the property page of the change.
	//
	LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		UNUSED_ALWAYS( wNotifyCode );
		UNUSED_ALWAYS( wID );
		UNUSED_ALWAYS( hWndCtl );
		UNUSED_ALWAYS( bHandled );

		SetModified();

		return( TRUE );
	}

public:
	long m_lNotifyHandle;
	bool m_bDeleteHandle;
	CEmployee* m_pEmployee;
	bool m_fStartup;
};

template< class T >
class CBenefitsData : public CSnapInItemImpl< T >
{
public:
	static const GUID* m_NODETYPE;
	static const TCHAR* m_SZNODETYPE;
	static const TCHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CBenefitsData( CEmployee* pEmployee )
	{
		//
		// Assign the given employee to our internal containment.
		// This employee will be assumed valid for the lifetime of
		// this object since persistence is maintained by our parent
		// node.
		//
		m_pEmployee = pEmployee;

		//
		// Always initialize our display name with the static declared.
		//
		m_bstrDisplayName = m_SZDISPLAY_NAME;

		//
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		//
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = 0; 		// May need modification
		m_scopeDataItem.nOpenImage = 0; 	// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = 0;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;
	}

	~CBenefitsData()
	{
	}

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		if (pScopeDataItem->mask & SDI_STR)
			pScopeDataItem->displayname = m_bstrDisplayName;
		if (pScopeDataItem->mask & SDI_IMAGE)
			pScopeDataItem->nImage = m_scopeDataItem.nImage;
		if (pScopeDataItem->mask & SDI_OPENIMAGE)
			pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
		if (pScopeDataItem->mask & SDI_PARAM)
			pScopeDataItem->lParam = m_scopeDataItem.lParam;
		if (pScopeDataItem->mask & SDI_STATE )
			pScopeDataItem->nState = m_scopeDataItem.nState;

		//
		// SDI_CHILDREN should be overridden by its derived classes.
		//

		return S_OK;
	}

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		if (pResultDataItem->bScopeItem)
		{
			if (pResultDataItem->mask & RDI_STR)
			{
				pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
			}
			if (pResultDataItem->mask & RDI_IMAGE)
			{
				pResultDataItem->nImage = m_scopeDataItem.nImage;
			}
			if (pResultDataItem->mask & RDI_PARAM)
			{
				pResultDataItem->lParam = m_scopeDataItem.lParam;
			}

			return S_OK;
		}

		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_resultDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_resultDataItem.lParam;
		}
		if (pResultDataItem->mask & RDI_INDEX)
		{
			pResultDataItem->nIndex = m_resultDataItem.nIndex;
		}

		return S_OK;
	}

	//
	// Overridden to provide result icons.
	//
	STDMETHOD( OnAddImages )( MMC_NOTIFY_TYPE event,
			long arg,
			long param,
			IConsole* pConsole,
			DATA_OBJECT_TYPES type )
	{
		UNUSED_ALWAYS( event );
		UNUSED_ALWAYS( param );
		UNUSED_ALWAYS( pConsole );
		UNUSED_ALWAYS( type );

		// Add Images
		IImageList* pImageList = (IImageList*) arg;
		HRESULT hr = E_FAIL;

		// Load bitmaps associated with the scope pane
		// and add them to the image list
		// Loads the default bitmaps generated by the wizard
		// Change as required
		HBITMAP hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_BENEFITS_16 ) );
		if (hBitmap16 != NULL)
		{
			HBITMAP hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_BENEFITS_32 ) );
			if (hBitmap32 != NULL)
			{
				hr = pImageList->ImageListSetStrip( (long*)hBitmap16, 
				(long*) hBitmap32, 0, RGB( 0, 128, 128 ) );
				if ( FAILED( hr ) )
					ATLTRACE( _T( "IImageList::ImageListSetStrip failed\n" ) );
			}
		}

		return( hr );
	}

	virtual LPOLESTR GetResultPaneColInfo(int nCol)
	{
		if (nCol == 0)
		{
			T* pT = static_cast<T*>(this);
			return( pT->m_bstrDisplayName );
		}

		// TODO : Return the text for other columns
		return OLESTR("Generic Description");
	}

	//
	// Helper function to extract the appropriate console from
	// a base object type.
	//
	STDMETHOD( GetConsole )( CSnapInObjectRootBase* pObj, IConsole** ppConsole )
	{
		HRESULT hr = E_FAIL;

		if ( pObj->m_nType == 1 )
		{
			//
			// This is the id of the data object.
			//
			*ppConsole = ( (CBenefits*) pObj )->m_spConsole;
			(*ppConsole)->AddRef();
			hr = S_OK;
		}
		else if ( pObj->m_nType == 2 )
		{
			//
			// This is the id of the component object.
			//
			*ppConsole = ( (CBenefitsComponent*) pObj )->m_spConsole;
			(*ppConsole)->AddRef();
			hr = S_OK;
		}

		return( hr );
	}

	//
	// Called to determine if the clipboard data can be obtained and
	// if it has a node type that matches the given GUID.
	//
	STDMETHOD( IsClipboardDataType )( LPDATAOBJECT pDataObject, GUID inGuid )
	{
		HRESULT hr = S_FALSE;

		if ( pDataObject == NULL )
			return( E_POINTER );

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, 
			NULL, 
			DVASPECT_CONTENT,
			-1,
			TYMED_HGLOBAL
		};

		//
		// Allocate memory to received the GUID.
		//
		stgmedium.hGlobal = GlobalAlloc( 0, sizeof( GUID ) );
		if ( stgmedium.hGlobal == NULL )
			return( E_OUTOFMEMORY );

		//
		// Retrieve the GUID of the paste object.
		//
		hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
		if( FAILED( hr ) )
		{
			GlobalFree(stgmedium.hGlobal);
			return( hr );
		}

		//
		// Make a local copy of the GUID.
		//
		GUID guid;
		memcpy( &guid, stgmedium.hGlobal, sizeof( GUID ) );
		GlobalFree( stgmedium.hGlobal );

		//
		// Check to see if the node is of the appropriate type.
		//
		if ( IsEqualGUID( guid, inGuid ) )
			hr = S_OK;
		else
			hr = S_FALSE;

		return( hr );
	}

	//
	// Command handler for "OnImport" functionality. For the current
	// sample, display a simple message box.
	//
	STDMETHOD( OnImport )(bool& bHandled, CSnapInObjectRootBase* pObj)
	{
		UNUSED_ALWAYS( bHandled );
		USES_CONVERSION;
		int nResult;
		CComPtr<IConsole> spConsole;

		//
		// Retrieve the appropriate console.
		//
		GetConsole( pObj, &spConsole );
		spConsole->MessageBox( T2OLE( _T( "Data successfully imported" ) ),
			T2OLE( _T( "Benefits" ) ),
			MB_ICONINFORMATION | MB_OK,
			&nResult );

		return( S_OK );
	};

	//
	// Command handler for "OnExport" functionality. For the current
	// sample, display a simple message box.
	//
	STDMETHOD( OnExport )(bool& bHandled, CSnapInObjectRootBase* pObj)
	{
		UNUSED_ALWAYS( bHandled );
		USES_CONVERSION;
		int nResult;
		CComPtr<IConsole> spConsole;

		//
		// Retrieve the appropriate console.
		//
		GetConsole( pObj, &spConsole );
		spConsole->MessageBox( T2OLE( _T( "Data successfully exported" ) ),
			T2OLE( _T( "Benefits" ) ),
			MB_ICONINFORMATION | MB_OK,
			&nResult );

		return( S_OK );
	};

protected:
	//
	// Container for the employee information.
	//
	CEmployee* m_pEmployee;
};

template< class T >
class CChildrenBenefitsData : public CBenefitsData< T >
{
public:
	//
	// Call the benefits data with no employee. All of our
	// containment nodes are not passed in an employee.
	//
	CChildrenBenefitsData< T >( CEmployee* pEmployee = NULL ) : CBenefitsData< T >( pEmployee )
	{
	};

	//
	// Overridden to automatically clean-up any child nodes.
	//
	virtual ~CChildrenBenefitsData()
	{
		//
		// Free any added nodes.
		//
		for ( int i = 0; i < m_Nodes.GetSize(); i++ )
		{
			CSnapInItem* pNode;
			
			pNode = m_Nodes[ i ];
			_ASSERTE( pNode != NULL );
			delete pNode;
		}
	}

	//
	// Overridden to automatically expand any child nodes.
	//
	STDMETHOD( OnShow )( MMC_NOTIFY_TYPE event,
			long arg,
			long param,
			IConsole* pConsole,
			DATA_OBJECT_TYPES type)
	{
		UNUSED_ALWAYS( event );
		UNUSED_ALWAYS( param );
		UNUSED_ALWAYS( type );
		HRESULT hr = E_NOTIMPL;
		ATLTRACE2(atlTraceSnapin, 0, _T("CChildNodeImpl::OnExpand\n"));

		//
		// Only add the items if we're being selected.
		//
		if ( arg == TRUE )
		{
			CComQIPtr<IResultData,&IID_IResultData> spResultData( pConsole );
			
			//
			// Loop through and add each subnode.
			//
			for ( int i = 0; i < m_Nodes.GetSize(); i++ )
			{
				CSnapInItem* pNode;
				RESULTDATAITEM* pResultData;

				pNode = m_Nodes[ i ];
				_ASSERTE( pNode != NULL );

				//
				// Get the scope pane info for the node and set 
				// relative id.
				//
				pNode->GetResultData( &pResultData );
				_ASSERTE( pResultData != NULL );

				//
				// Add the item to the scope list using the newly
				// populated scope data item.
				//
				hr = spResultData->InsertItem( pResultData );
				_ASSERTE( SUCCEEDED( hr ) );
			}
		}

		return( hr );
	};

	//
	// Overridden to automatically expand any child nodes.
	//
	STDMETHOD( OnExpand )( MMC_NOTIFY_TYPE event,
			long arg,
			long param,
			IConsole* pConsole,
			DATA_OBJECT_TYPES type)
	{
		UNUSED_ALWAYS( event );
		UNUSED_ALWAYS( arg );
		UNUSED_ALWAYS( type );
		ATLTRACE2(atlTraceSnapin, 0, _T("CChildNodeImpl::OnExpand\n"));

		CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> pNameSpace( pConsole );
		HRESULT hr = E_NOTIMPL;
		
		//
		// Loop through and add each subnode.
		//
		for ( int i = 0; i < m_Nodes.GetSize(); i++ )
		{
			CSnapInItem* pNode;
			SCOPEDATAITEM* pScopeData;

			pNode = m_Nodes[ i ];
			_ASSERTE( pNode != NULL );

			//
			// Get the scope pane info for the node and set 
			// relative id.
			//
			pNode->GetScopeData( &pScopeData );
			_ASSERTE( pScopeData != NULL );
			pScopeData->relativeID = param;

			//
			// Add the item to the scope list using the newly
			// populated scope data item.
			//
			hr = pNameSpace->InsertItem( pScopeData );
			_ASSERTE( SUCCEEDED( hr ) );
		}

		return( hr );
	};

	//
	// Used as containment for all child nodes.
	//
	CSimpleArray<CSnapInItem*> m_Nodes;
};

class CBenefits;
class CBenefitsComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CBenefits >,
	public IExtendPropertySheetImpl<CBenefitsComponent>,
	public IExtendContextMenuImpl<CBenefitsComponent>,
	public IExtendControlbarImpl<CBenefitsComponent>,
	public IComponentImpl<CBenefitsComponent>,
	public IExtendTaskPadImpl<CBenefitsComponent>
{
public:
BEGIN_COM_MAP(CBenefitsComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY(IExtendTaskPad)
END_COM_MAP()

public:
	CBenefitsComponent()
	{
		//
		// Taskpad initialization stuff.
		//
		m_pszTitle = L"Benefits Taskpad";
		m_pszBackgroundPath = NULL;
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
	{
		if (lpDataObject != NULL)
			return IComponentImpl<CBenefitsComponent>::Notify(lpDataObject, event, arg, param);
		return E_NOTIMPL;
	}

	//
	// Taskpad related information. Specifies titles, background
	// information, etc.
	//
	LPOLESTR m_pszTitle;
	LPOLESTR m_pszBackgroundPath;
};

class CBenefits : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<1, CBenefits>,
	public IComponentDataImpl<CBenefits, CBenefitsComponent>,
	public IExtendPropertySheetImpl<CBenefits>,
	public IExtendContextMenuImpl<CBenefits>,
	public IPersistStream,
	public CComCoClass<CBenefits, &CLSID_Benefits>,
	public ISnapinHelpImpl<CBenefits>
{
public:
	CBenefits();
	~CBenefits();

BEGIN_COM_MAP(CBenefits)
	COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_BENEFITS)

DECLARE_NOT_AGGREGATABLE(CBenefits)

	//
	// Return the classid of this object.
	//
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		*pClassID = GetObjectCLSID();
		return S_OK;
	}	

	//
	// Call the root node's implementation.
	//
	STDMETHOD(IsDirty)();

	//
	// Call the root node's implementation.
	//
	STDMETHOD(Load)(LPSTREAM pStm);

	//
	// Call the root node's implementation.
	//
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);

	//
	// Call the root node's implementation.
	//
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize );

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

	//
	// This is overridden to handle update notifications from
	// the property pages.
	//
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
};

class ATL_NO_VTABLE CBenefitsAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CBenefitsAbout, &CLSID_BenefitsAbout>
{
public:
	DECLARE_REGISTRY(CBenefitsAbout, _T("BenefitsAbout.1"), _T("BenefitsAbout.1"), IDS_BENEFITS_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CBenefitsAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_BENEFITS_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_BENEFITS_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_BENEFITS_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		UNUSED_ALWAYS( hSmallImage );
		UNUSED_ALWAYS( cMask );

		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;

		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\benefits.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       benefits.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "BenSvr.h"
#include "Benefits.h"
#include "RootNode.h"

CBenefits::CBenefits()
{
	m_pNode = new CRootNode;
	_ASSERTE(m_pNode != NULL);
}

//
// Standard destructor. Simply deletes
// the root node.
//
CBenefits::~CBenefits()
{
	delete m_pNode;
	m_pNode = NULL;
}

HRESULT CBenefits::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CBenefits, CBenefitsComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_BENEFITS_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_BENEFITS_32));
	if (hBitmap32 == NULL)
		return S_OK;

	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
		(long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}

	//
	// This is called to create the unique sub-nodes.
	//
	( (CRootNode*) m_pNode )->InitializeSubNodes();

	return S_OK;
}

//
// This is overridden to handle update notifications from
// the property pages.
//
HRESULT CBenefits::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
	HRESULT hr = E_NOTIMPL;

	if ( lpDataObject != NULL )
	{
		return IComponentDataImpl<CBenefits,CBenefitsComponent>::Notify( lpDataObject, event, arg, param );
	}
	else
	{
		//
		// There are many events which are sent to Notify with
		// the dataobject == NULL. Make sure that the correct one is
		// being dealt with.
		//
		switch( event )
		{
		case MMCN_PROPERTY_CHANGE:
			//
			// Send the notification to our root node for further processing.
			//
			( (CRootNode*) m_pNode )->OnPropertyChange( m_spConsole );

			//
			// Since we've received an update notification, we'll cause the console
			// to be refreshed. This should handle the updates.
			//
			hr = m_spConsole->UpdateAllViews( NULL, NULL, NULL );
			break;
		}
	}

	return( hr );
}

//
// Call the root node's implementation.
//
STDMETHODIMP CBenefits::IsDirty()
{
	return( ( (CRootNode*) m_pNode )->IsDirty() );
}

//
// Call the root node's implementation.
//
STDMETHODIMP CBenefits::Load(LPSTREAM pStm)
{
	return( ( (CRootNode*) m_pNode )->Load( pStm ) );
}

//
// Call the root node's implementation.
//
STDMETHODIMP CBenefits::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	return( ( (CRootNode*) m_pNode )->Save( pStm, fClearDirty ) );
}

//
// Call the root node's implementation.
//
STDMETHODIMP CBenefits::GetSizeMax(ULARGE_INTEGER FAR* pcbSize )
{
	return( ( (CRootNode*) m_pNode )->GetSizeMax( pcbSize ) );
}

//
// This function copies the data from the given employee and populates
// the appropriate controls within the page.
//
LRESULT CEmployeeNamePage::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNUSED_ALWAYS( uiMsg );
	UNUSED_ALWAYS( wParam );
	UNUSED_ALWAYS( lParam );
	UNUSED_ALWAYS( fHandled );
	USES_CONVERSION;
	_ASSERTE( m_pEmployee != NULL );

	SetDlgItemText( IDC_EDIT_LASTNAME, W2T( m_pEmployee->m_szLastName ) );
	SetDlgItemText( IDC_EDIT_FIRSTNAME, W2T( m_pEmployee->m_szFirstName ) );
	SetDlgItemText( IDC_EDIT_SOCIALSECURITY, W2T( m_pEmployee->m_szSocialSecurity ) );
	SetDlgItemText( IDC_EDIT_MOTHERNAME, W2T( m_pEmployee->m_szMotherMaiden ) );

	return( TRUE );
}

//
// Handle the storage of any new values to the employee.
//
BOOL CEmployeeNamePage::OnWizardFinish()
{
	USES_CONVERSION;
	BOOL fValid = TRUE;
	TCHAR szBuf[ 256 ];

	//
	// Get the values from the appropriate edit controls.
	// For demo purposes, always assume success unless the last name
	// and first are bad.
	//
	GetDlgItemText( IDC_EDIT_LASTNAME, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szLastName, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_FIRSTNAME, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szFirstName, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_SOCIALSECURITY, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szSocialSecurity, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_MOTHERNAME, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szMotherMaiden, T2W( szBuf ) );

	//
	// Check for validity of first name and last name.
	//
	if ( wcslen( m_pEmployee->m_szLastName ) == 0 || wcslen( m_pEmployee->m_szFirstName ) == 0 ||
		m_pEmployee->m_szLastName[ 0 ] == ' ' || m_pEmployee->m_szFirstName[ 0 ] == ' ' )
	{
		//
		// Inform the user of the error.
		//
		MessageBox( _T( "Must enter valid first and last name." ) );

		fValid = FALSE;
	}
	else
	{
		//
		// Data is valid. As a result, post a notification to the snap-in
		// that the employee contents have changes. This demonstration does
		// not use any sort of hinting, so NULL can be safely pass in as
		// the nofication's arguement.
		//
		PropertyChangeNotify( NULL );
	}

	return( fValid );
}

//
// This is overridden to modify the UI depending on whether
// we're in start-up mode or not.
//
BOOL CEmployeeNamePage::OnSetActive()
{
	if ( m_fStartup )
	{
		//
		// Must use post message during the setactive message.
		//
		CWindow( GetParent() ).PostMessage( PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT );
	}

	return TRUE;
}

//
// This function copies the data from the given employee and populates
// the appropriate controls within the page.
//
LRESULT CEmployeeAddressPage::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNUSED_ALWAYS( uiMsg );
	UNUSED_ALWAYS( wParam );
	UNUSED_ALWAYS( lParam );
	UNUSED_ALWAYS( fHandled );
	USES_CONVERSION;
	_ASSERTE( m_pEmployee != NULL );

	SetDlgItemText( IDC_EDIT_ADDRESSFIRST, W2T( m_pEmployee->m_szAddress1 ) );
	SetDlgItemText( IDC_EDIT_ADDRESSSECOND, W2T( m_pEmployee->m_szAddress2 ) );
	SetDlgItemText( IDC_EDIT_CITY, W2T( m_pEmployee->m_szCity ) );
	SetDlgItemText( IDC_EDIT_STATE, W2T( m_pEmployee->m_szState ) );
	SetDlgItemText( IDC_EDIT_ZIP, W2T( m_pEmployee->m_szZip ) );
	SetDlgItemText( IDC_EDIT_PHONE, W2T( m_pEmployee->m_szPhone ) );

	return( TRUE );
}

//
// Handle the storage of any new values to the employee.
//
BOOL CEmployeeAddressPage::OnWizardFinish()
{
	USES_CONVERSION;
	BOOL fValid = TRUE;
	TCHAR szBuf[ 256 ];

	//
	// Get the values from the appropriate edit controls.
	// For demo purposes, always assume success unless the last name
	// and first are bad.
	//
	GetDlgItemText( IDC_EDIT_ADDRESSFIRST, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szAddress1, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_ADDRESSSECOND, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szAddress2, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_CITY, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szCity, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_STATE, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szState, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_ZIP, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szZip, T2W( szBuf ) );
	GetDlgItemText( IDC_EDIT_PHONE, szBuf, sizeof( szBuf ) );
	wcscpy( m_pEmployee->m_szPhone, T2W( szBuf ) );

	//
	// Data is valid. As a result, post a notification to the snap-in
	// that the employee contents have changes. This demonstration does
	// not use any sort of hinting, so NULL can be safely pass in as
	// the nofication's arguement.
	//
	PropertyChangeNotify( NULL );

	return( fValid );
}

//
// This is overridden to modify the UI depending on whether
// we're in start-up mode or not.
//
BOOL CEmployeeAddressPage::OnSetActive()
{
	if ( m_fStartup )
	{
		//
		// Must use post message during the setactive message.
		//
		CWindow( GetParent() ).PostMessage( PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH );
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\bennodes.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       bennodes.cpp
//
//--------------------------------------------------------------------------

// BenefitsNodes.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "BenNodes.h"
#include "Dialogs.h"

static const GUID CBuildingNodeGUID_NODETYPE = 
{ 0xec362ef4, 0xd94d, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };
const GUID*  CBuildingNode::m_NODETYPE = &CBuildingNodeGUID_NODETYPE;
const TCHAR* CBuildingNode::m_SZNODETYPE = _T("EC362EF4-D94D-11D1-8474-00104B211BE5");
const TCHAR* CBuildingNode::m_SZDISPLAY_NAME = _T("Building");
const CLSID* CBuildingNode::m_SNAPIN_CLASSID = &CLSID_Benefits;

//
// The following constructor initialiazes its base-class members and
// initializes the building name, location, etc.
//
CBuildingNode::CBuildingNode( CKeyNode* pParentNode, BSTR strName, BSTR bstrLocation ) : CBenefitsData< CBuildingNode >( NULL )
{
	_ASSERTE( pParentNode != NULL );

	m_resultDataItem.nImage = 3;
	m_bstrDisplayName = strName;
	m_bstrLocation = bstrLocation;

	//
	// Save the parent node for deletion purposes.
	//
	m_pParentNode = pParentNode;
}

//
// Copy constructor.
//
CBuildingNode::CBuildingNode( const CBuildingNode &inNode ) : CBenefitsData< CBuildingNode >( NULL )
{
	m_resultDataItem.nImage = inNode.m_resultDataItem.nImage;
	m_bstrDisplayName = inNode.m_bstrDisplayName;
	m_bstrLocation = inNode.m_bstrLocation;
	m_pParentNode = inNode.m_pParentNode;
}

//
// Overridden to provide strings for various columns.
//
LPOLESTR CBuildingNode::GetResultPaneColInfo(int nCol)
{
	CComBSTR szText;

	// The following switch statement dispatches to the
	// appropriate column index and loads the necessary
	// string.
	switch ( nCol )
	{
	case 0:
		szText = m_bstrDisplayName;
		break;
	case 1:
		szText = m_bstrLocation;
		break;
	default:
		ATLTRACE( "An invalid column index was passed to GetResultPaneColInfo()\n" );
	}

	return( szText.Copy() );
}

static const GUID CRetirementNodeGUID_NODETYPE = 
{ 0xec362ef2, 0xd94d, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };
const GUID*  CRetirementNode::m_NODETYPE = &CRetirementNodeGUID_NODETYPE;
const TCHAR* CRetirementNode::m_SZNODETYPE = _T("EC362EF2D94D-11D1-8474-00104B211BE5");
const TCHAR* CRetirementNode::m_SZDISPLAY_NAME = _T("401K Plan");
const CLSID* CRetirementNode::m_SNAPIN_CLASSID = &CLSID_Benefits;

//
// The following constructor initialiazes its base-class members with
// hard-coded values for display purposes. Since these are static nodes,
// hard-coded values can be used for the following values.
//
CRetirementNode::CRetirementNode( CEmployee* pCurEmployee ) : CBenefitsData< CRetirementNode > ( pCurEmployee )
{
	m_scopeDataItem.nOpenImage = m_scopeDataItem.nImage = 0;
	m_scopeDataItem.cChildren = 0;	// Not necessary unless modified.
}

CRetirementNode::~CRetirementNode()
{

}

//
// Specifies that the results should display a web page as its results. In
// addition, the view options should be set so that standard lists, which
// won't be applicable to this node, should not be available to the user.
//
STDMETHODIMP CRetirementNode::GetResultViewType( LPOLESTR* ppViewType, long* pViewOptions )
{
	USES_CONVERSION;

	//
	// For this example to work, the sample control must be installed.
	//
	TCHAR* pszControl = _T( "{FE148827-3093-11D2-8494-00104B211BE5}" );

	// CoTaskMemAlloc(...) must be used since the MMC client frees the space using
	// CoTaskMemFree(...). Include enough space for NULL.
	//
	*ppViewType = (LPOLESTR) CoTaskMemAlloc( ( _tcslen( pszControl ) + 1 ) * sizeof( OLECHAR ) );
	_ASSERTE( *ppViewType != NULL );
	ocscpy( *ppViewType, T2OLE( pszControl ) );

	//
	// Set the view options so that no lists are displayed.
	//
	*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

	return( S_OK );
}

//
// Overridden to provide strings for various columns.
//
LPOLESTR CRetirementNode::GetResultPaneColInfo(int nCol)
{
	CComBSTR szText;

	// The following switch statement dispatches to the
	// appropriate column index and loads the necessary
	// string.
	switch ( nCol )
	{
	case 0:
		szText = m_bstrDisplayName;
		break;
	case 1:
		szText.LoadString( _Module.GetResourceInstance(), IDS_RETIREMENT_DESC );
		break;
	default:
		ATLTRACE( "An invalid column index was passed to GetResultPaneColInfo()\n" );
	}

	return( szText.Copy() );
}

//
// Command handler for "Enroll" functionality.
//
STDMETHODIMP CRetirementNode::OnEnroll( bool& bHandled, CSnapInObjectRootBase* pObj )
{
	UNUSED_ALWAYS( bHandled );
	UNUSED_ALWAYS( pObj );

#ifdef _BENEFITS_DIALOGS
	CRetirementEnrollDialog dlg;

	dlg.SetEmployee( m_pEmployee );
	dlg.DoModal();
#else
	CComPtr<IConsole> spConsole;
	int nResult;

	//
	// Retrieve the appropriate console.
	//
	GetConsole( pObj, &spConsole );
	spConsole->MessageBox( L"Enrolled",
		L"Benefits",
		MB_ICONINFORMATION | MB_OK,
		&nResult );
#endif

	return( S_OK );
}


//
// Command handler for "Update" functionality. Demonstrates calling a
// displayed OCX's method.
//
STDMETHODIMP CRetirementNode::OnUpdate( bool& bHandled, CSnapInObjectRootBase* pObj )
{
	UNUSED_ALWAYS( bHandled );
	UNUSED_ALWAYS( pObj );
	HRESULT hr = E_FAIL;

	if ( m_spControl )
	{
		//
		// This should trigger the OCX to refresh its historical information.
		//
		hr = m_spControl->Refresh();
	}

	return( hr );
}

static const GUID CHealthNodeGUID_NODETYPE = 
{ 0xec362ef1, 0xd94d, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };
const GUID*  CHealthNode::m_NODETYPE = &CHealthNodeGUID_NODETYPE;
const TCHAR* CHealthNode::m_SZNODETYPE = _T("EC362EF1D94D-11D1-8474-00104B211BE5");
const TCHAR* CHealthNode::m_SZDISPLAY_NAME = _T("Health & Dental Plan");
const CLSID* CHealthNode::m_SNAPIN_CLASSID = &CLSID_Benefits;

//
// Hard coded tasks to be associated with the health node.
//
MMC_TASK g_HealthTasks[ 3 ] =
{
	{ MMC_TASK_DISPLAY_TYPE_VANILLA_GIF, L"img\\WebPage.gif", L"img\\WebPage.gif", L"Microsoft", L"General Microsoft resources", MMC_ACTION_LINK, (long) L"http://www.microsoft.com" },
	{ MMC_TASK_DISPLAY_TYPE_VANILLA_GIF, L"img\\WebPage.gif", L"img\\WebPage.gif", L"Microsoft Management Site", L"More MMC oriented resources", MMC_ACTION_LINK, (long) L"http://www.microsoft.com/management" },
	{ MMC_TASK_DISPLAY_TYPE_VANILLA_GIF, L"img\\Query.gif", L"img\\Query.gif", L"Local Query", L"Start query on local database", MMC_ACTION_ID, TASKPAD_LOCALQUERY },
};

//
// The following constructor initialiazes its base-class members with
// hard-coded values for display purposes. Since these are static nodes,
// hard-coded values can be used for the following values.
//
CHealthNode::CHealthNode( CEmployee* pCurEmployee ) : CBenefitsData<CHealthNode> ( pCurEmployee )
{
	m_scopeDataItem.nOpenImage = m_scopeDataItem.nImage = 1;
	m_scopeDataItem.cChildren = 0;	// Not necessary unless modified.

	m_fTaskpad = FALSE;
}

CHealthNode::~CHealthNode()
{

}

//
// Specifies that the results should display a web page as its results. In
// addition, the view options should be set so that standard lists, which
// won't be applicable to this node, should not be available to the user.
//
STDMETHODIMP CHealthNode::GetResultViewType( LPOLESTR* ppViewType, long* pViewOptions )
{
	USES_CONVERSION;
	TCHAR szPath[ _MAX_PATH ];
	TCHAR szModulePath[ _MAX_PATH ];

	//
	// Set the view options to no preferences.
	//
	*pViewOptions = MMC_VIEW_OPTIONS_NONE;

	if ( m_fTaskpad )
	{
		//
		// In the taskpad case, the module path of MMC.EXE should be
		// obtained. Use the template contained therein.
		//
		GetModuleFileName( NULL, szModulePath, _MAX_PATH );

		//
		// Append the necessary decorations for correct access.
		//
		_tcscpy( szPath, _T( "res://" ) );
		_tcscat( szPath, szModulePath );
		_tcscat( szPath, _T( "/default.htm" ) );
	}
	else
	{
		//
		// Use the HTML page that is embedded as a resource of
		// this module for display purposes.
		//
		GetModuleFileName( _Module.GetModuleInstance(), szModulePath, _MAX_PATH );

		//
		// Append the necessary decorations for correct access.
		//
		_tcscpy( szPath, _T( "res://" ) );
		_tcscat( szPath, szModulePath );
		_tcscat( szPath, _T( "/health.htm" ) );
	}

	//
	// CoTaskMemAlloc(...) must be used since the MMC client frees the space using
	// CoTaskMemFree(...). Include enough space for NULL.
	//
	*ppViewType = (LPOLESTR) CoTaskMemAlloc( ( _tcslen( szPath ) + 1 ) * sizeof( OLECHAR ) );
	_ASSERTE( *ppViewType != NULL );
	ocscpy( *ppViewType, T2OLE( szPath ) );

	return( S_OK );
}

//
// Overridden to provide strings for various columns.
//
LPOLESTR CHealthNode::GetResultPaneColInfo(int nCol)
{
	USES_CONVERSION;
	CComBSTR szText;

	// The following switch statement dispatches to the
	// appropriate column index and loads the necessary
	// string.
	switch ( nCol )
	{
	case 0:
		szText = m_bstrDisplayName;
		break;
	case 1:
		szText.LoadString( _Module.GetResourceInstance(), IDS_HEALTH_DESC );
		break;
	default:
		ATLTRACE( "An invalid column index was passed to GetResultPaneColInfo()\n" );
	}

	return( szText.Copy() );
}

//
// Command handler for "Enroll" functionality.
//
STDMETHODIMP CHealthNode::OnEnroll( bool& bHandled, CSnapInObjectRootBase* pObj )
{
	UNUSED_ALWAYS( bHandled );
	UNUSED_ALWAYS( pObj );

#ifdef _BENEFITS_DIALOGS
	CHealthEnrollDialog dlg;

	dlg.SetEmployee( m_pEmployee );
	dlg.DoModal();
#else
	CComPtr<IConsole> spConsole;
	int nResult;

	//
	// Retrieve the appropriate console.
	//
	GetConsole( pObj, &spConsole );
	spConsole->MessageBox( L"Enrolled",
		L"Benefits",
		MB_ICONINFORMATION | MB_OK,
		&nResult );
#endif

	return( S_OK );
}

//
// Restores any state, especially in the case of using a
// taskpad, when the back and forward buttons are used by
// the user for navigation.
//
STDMETHODIMP CHealthNode::OnRestoreView( MMC_RESTORE_VIEW* pRestoreView, BOOL* pfHandled )
{
	_ASSERTE( pRestoreView->dwSize == sizeof( MMC_RESTORE_VIEW ) );
	*pfHandled = TRUE;
	return( S_OK );
}

//
// Called when one of the tasks is clicked.
//
STDMETHODIMP CHealthNode::TaskNotify( IConsole* pConsole, VARIANT* arg, VARIANT* param )
{
	UNUSED_ALWAYS( arg );
	UNUSED_ALWAYS( param );
	HRESULT hr = E_FAIL;

	//
	// Determine if the given notification is for the
	// start query button.
	//
	if ( arg->lVal == TASKPAD_LOCALQUERY )
	{
		CComPtr<IConsole> spConsole = pConsole;
		int nResult;

		//
		// Display a message box to demonstrate the
		// handling of the taskpad notification.
		//
		spConsole->MessageBox( L"Local query started",
			L"Health Taskpad",
			MB_ICONINFORMATION | MB_OK,
			&nResult );

		hr = S_OK;
	}

	return( hr );
}

//
// Returns an enumerator for all of these tasks.
//
STDMETHODIMP CHealthNode::EnumTasks( LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK )
{
	UNUSED_ALWAYS( szTaskGroup );
	MMC_TASK CoTasks[ sizeof( g_HealthTasks ) / sizeof( MMC_TASK ) ];
	typedef CComObject< CComEnum< IEnumTASK, &IID_IEnumTASK, MMC_TASK, _Copy<MMC_TASK> > > enumvar;
	enumvar* p = new enumvar; 

	//
	// Copy the local tasks to our temporary task structures. This
	// performs the CoTaskMemAlloc for the strings, etc. It also
	// maps image type resources to the local module name.
	//
	if ( CoTasksDup( CoTasks, g_HealthTasks, sizeof( g_HealthTasks ) / sizeof( MMC_TASK ) ) )
	{
		p->Init( &CoTasks[ 0 ], &CoTasks[ sizeof( g_HealthTasks ) / sizeof( MMC_TASK ) ], NULL, AtlFlagCopy);
		return( p->QueryInterface( IID_IEnumTASK, (void**) ppEnumTASK ) );
	}

	return( E_FAIL );
}

static const GUID CKeyNodeGUID_NODETYPE = 
{ 0xec362ef3, 0xd94d, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };
const GUID*  CKeyNode::m_NODETYPE = &CKeyNodeGUID_NODETYPE;
const TCHAR* CKeyNode::m_SZNODETYPE = _T("EC362EF3D94D-11D1-8474-00104B211BE5");
const TCHAR* CKeyNode::m_SZDISPLAY_NAME = _T("Card Key Permissions");
const CLSID* CKeyNode::m_SNAPIN_CLASSID = &CLSID_Benefits;

//
// Used for the key node example.
//
extern BUILDINGDATA g_Buildings[ 3 ];

//
// The following constructor initialiazes its base-class members with
// hard-coded values for display purposes. Since these are static nodes,
// hard-coded values can be used for the following values.
//
CKeyNode::CKeyNode( CEmployee* pCurEmployee ) : CChildrenBenefitsData<CKeyNode>( pCurEmployee )
{
	USES_CONVERSION;

	m_scopeDataItem.nOpenImage = m_scopeDataItem.nImage = 2;
	m_scopeDataItem.cChildren = 0;	// Not necessary unless modified.

	//
	// Populate building nodes based on this employees permissions.
	//
	for ( int i = 0; i < sizeof( g_Buildings ) / sizeof( BUILDINGDATA ); i++ )
	{
		//
		// Only add an item if the given employee has access to the
		// building.
		//
		if ( g_Buildings[ i ].dwId & pCurEmployee->m_Access.dwAccess )
		{
			CSnapInItem* pItem;

			pItem = new CBuildingNode( this, W2BSTR( g_Buildings[ i ].pstrName ), W2BSTR( g_Buildings[ i ].pstrLocation ) );
			m_Nodes.Add( pItem );
		}
	}
}

CKeyNode::~CKeyNode()
{

}

//
// Overridden to provide strings for various columns.
//
LPOLESTR CKeyNode::GetResultPaneColInfo(int nCol)
{
	CComBSTR szText;

	// The following switch statement dispatches to the
	// appropriate column index and loads the necessary
	// string.
	switch ( nCol )
	{
	case 0:
		szText = m_bstrDisplayName;
		break;
	case 1:
		szText.LoadString( _Module.GetResourceInstance(), IDS_KEY_DESC );
		break;
	default:
		ATLTRACE( "An invalid column index was passed to GetResultPaneColInfo()\n" );
	}

	return( szText.Copy() );
}

//
// Overridden to add new columns to the results
// display.
//
STDMETHODIMP CKeyNode::OnShowColumn( IHeaderCtrl* pHeader )
{
	USES_CONVERSION;
	HRESULT hr = E_FAIL;
	CComPtr<IHeaderCtrl> spHeader( pHeader );

	// Add two columns: one with the name of the object and one with
	// the description of the node. Use the value of 100 pixels as the size.
	hr = spHeader->InsertColumn( 0, T2OLE( _T( "Building" ) ), LVCFMT_LEFT, 200 );
	_ASSERTE( SUCCEEDED( hr ) );

	// Add the second column. Use the value of 200 pixels as the size.
	hr = spHeader->InsertColumn( 1, T2OLE( _T( "Location" ) ), LVCFMT_LEFT, 350 );
	_ASSERTE( SUCCEEDED( hr ) );

	return( hr );
}

//
// Command handler for "Grant Access" functionality.
//
STDMETHODIMP CKeyNode::OnGrantAccess( bool& bHandled, CSnapInObjectRootBase* pObj )
{
	UNUSED_ALWAYS( bHandled );
	UNUSED_ALWAYS( pObj );

#ifdef _BENEFITS_DIALOGS
	CBuildingAccessDialog dlg;

	dlg.SetEmployee( m_pEmployee );
	dlg.DoModal();
#else
	CComPtr<IConsole> spConsole;
	int nResult;

	//
	// Retrieve the appropriate console.
	//
	GetConsole( pObj, &spConsole );
	spConsole->MessageBox( L"Access granted",
		L"Benefits",
		MB_ICONINFORMATION | MB_OK,
		&nResult );
#endif

	return( S_OK );
}

//
// Called by the console to determine if we can paste the
// specified node.
//
STDMETHODIMP CKeyNode::OnQueryPaste( LPDATAOBJECT pDataObject )
{
	HRESULT hr;

	//
	// Determine if the type of object being pasted is the right
	// type.
	//
	hr = IsClipboardDataType( pDataObject, CBuildingNodeGUID_NODETYPE );
	if ( SUCCEEDED( hr ) )
	{
		CBuildingNode* pItem;
		DATA_OBJECT_TYPES Type;

		//
		// Loop through all of currently contained nodes and
		// determine if we already contain the specified building
		// by comparing building names.
		//
		hr = CSnapInItem::GetDataClass( pDataObject, (CSnapInItem**) &pItem, &Type );
		if ( SUCCEEDED( hr ) )
		{
			for ( int i = 0; i < m_Nodes.GetSize(); i++ )
			{
				CBuildingNode* pTemp;
				CComBSTR bstrTemp;

				//
				// Retrieve the node from our internal list.
				//
				pTemp = dynamic_cast<CBuildingNode*>( m_Nodes[ i ] );
				_ASSERTE( pTemp != NULL );
				
				//
				// If the names are equal, indicate failure
				// and break out.
				//
				if ( wcscmp( pItem->m_bstrDisplayName, pTemp->m_bstrDisplayName ) == 0 )
				{
					hr = S_FALSE;
					break;
				}
			}
		}
	}

	return( hr );
}

//
// Called by MMC when the item should be pasted.
//
STDMETHODIMP CKeyNode::OnPaste( IConsole* pConsole, LPDATAOBJECT pDataObject, LPDATAOBJECT* ppDataObject )
{
	HRESULT hr;

	//
	// Ensure the data is of the correct type.
	//
	hr = IsClipboardDataType( pDataObject, CBuildingNodeGUID_NODETYPE );
	if ( SUCCEEDED( hr ) )
	{
		try
		{
			CBuildingNode* pItem;
			DATA_OBJECT_TYPES Type;

			//
			// Retrieve the passed in item.
			//
			hr = CSnapInItem::GetDataClass( pDataObject, (CSnapInItem**) &pItem, &Type );
			if ( FAILED( hr ) )
				throw;

			//
			// Allocate a new building node. The constructor
			// copies the values from the input node.
			//
			CSnapInItem* pNewNode = new CBuildingNode( *pItem );
			if ( pNewNode == NULL )
				throw;

			//
			// Add the node to the end of our internal array.
			//
			m_Nodes.Add( pNewNode );

			//
			// Reselect ourselves to cause a refresh.
			//
			pConsole->SelectScopeItem( m_scopeDataItem.ID );

			//
			// Put the given data object into the returned dataobject
			// so that MMC may complete its cut tasks.
			//
			*ppDataObject = pDataObject;

			hr = S_OK;
		}
		catch( ... )
		{
			//
			// Assume all failures are total.
			//
			hr = E_FAIL;
		}
	}

	return( hr );
}

//
// Called by one of our children nodes to inform us that
// they should be deleted. This occurs when the user selects
// a delete action on the building. This function should not
// only delete the building, but also handle the refresh of
// the result display.
//
STDMETHODIMP CKeyNode::OnDeleteBuilding( IConsole* pConsole, CBuildingNode* pChildNode )
{
	_ASSERTE( pConsole != NULL );
	_ASSERTE( pChildNode != NULL );
	HRESULT hr = E_FAIL;

	//
	// First, loop through all of our contained members and
	// remove it from the contained list.
	//
	for ( int i = 0; i < m_Nodes.GetSize(); i++ )
	{
		if ( m_Nodes[ i ] == pChildNode )
		{
			//
			// We have found a match. Remove it from the
			// contained list.
			//
			m_Nodes.RemoveAt( i );

			//
			// Reselect ourselves to cause a refresh.
			//
			pConsole->SelectScopeItem( m_scopeDataItem.ID );

			//
			// Since there should only be one match, break out
			// of the find process. Indicate success.
			//
			hr = S_OK;
			break;
		}
	}

	return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\bennodes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       bennodes.h
//
//--------------------------------------------------------------------------

// BenefitsNodes.h
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BENEFITSNODES_H__E0573E77_D325_11D1_846C_00104B211BE5__INCLUDED_)
#define AFX_BENEFITSNODES_H__E0573E77_D325_11D1_846C_00104B211BE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Benefits.h"

//
// Added to support the generated COM dispatch interface.
//
#import "SampCtrl\SampCtrl.ocx"
using namespace SampCtrl;

class CRetirementNode : public CBenefitsData< CRetirementNode >
{
public:
	SNAPINMENUID( IDR_UPDATE_MENU )
	BEGIN_SNAPINCOMMAND_MAP( CRetirementNode, FALSE )
		SNAPINCOMMAND_ENTRY(ID_TASK_ENROLL, OnEnroll)
		SNAPINCOMMAND_ENTRY(ID_TOP_UPDATE, OnUpdate)
	END_SNAPINCOMMAND_MAP()
	BEGIN_SNAPINTOOLBARID_MAP( CRetirementNode )
	END_SNAPINTOOLBARID_MAP()

	CRetirementNode( CEmployee* pCurEmployee );
	virtual ~CRetirementNode();

	//
	// Overridden to display web page as results.
	//
    STDMETHOD( GetResultViewType )( LPOLESTR *ppViewType, long *pViewOptions );

	//
	// Overridden to provide strings for various columns.
	//
	LPOLESTR GetResultPaneColInfo(int nCol);

	//
	// Command handler for "Enroll" functionality.
	//
	STDMETHOD( OnEnroll )(bool& bHandled, CSnapInObjectRootBase* pObj);

	//
	// Command handler for "Update" functionality.
	//
	STDMETHOD( OnUpdate )(bool& bHandled, CSnapInObjectRootBase* pObj);

	//
	// Overridden to cache the OCX pointer.
	//
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		HRESULT hr = E_NOTIMPL;

		switch (event)
		{
		case MMCN_SHOW:
			//
			// Always respond to the show call so that the
			// console knows this has been processed and can
			// properly seat toolbars, etc.
			//
			hr = S_OK;
			break;

		case MMCN_INITOCX:
			//
			// The IUnknown of the OCX is passed in. Do
			// any other initialization of the OCX here.
			//
			m_spControl = (IUnknown*) param;
			hr = S_OK;
			break;

		default:
			//
			// Always default to calling the base class implementation.
			//
			hr = CBenefitsData<CRetirementNode>::Notify( event, 
					arg, 
					param, 
					pComponentData, 
					pComponent, 
					type );
		}

		return hr;
	}

protected:
	//
	// Definition generated by compiler. IDispatch implementation.
	//
	_SampleControlPtr m_spControl;
};

#define TASKPAD_LOCALQUERY 100

class CHealthNode : public CBenefitsData< CHealthNode >,
	public CTaskpadItem
{
public:
	SNAPINMENUID( IDR_ENROLL_MENU )
	BEGIN_SNAPINCOMMAND_MAP( CHealthNode, FALSE )
		SNAPINCOMMAND_ENTRY(ID_TASK_ENROLL, OnEnroll)
		SNAPINCOMMAND_ENTRY(ID_TOP_IMPORT, OnImport)
		SNAPINCOMMAND_ENTRY(ID_TOP_EXPORT, OnExport)
		SNAPINCOMMAND_ENTRY(ID_VIEW_TASKPAD, OnTaskpad)
	END_SNAPINCOMMAND_MAP()
	BEGIN_SNAPINTOOLBARID_MAP( CHealthNode )
		SNAPINTOOLBARID_ENTRY( IDR_ENROLLTOOLBAR )
	END_SNAPINTOOLBARID_MAP()

	CHealthNode( CEmployee* pCurEmployee );
	virtual ~CHealthNode();

	//
	// Overridden to display web page as results.
	//
    STDMETHOD( GetResultViewType )( LPOLESTR *ppViewType, long *pViewOptions );

	//
	// Overridden to provide strings for various columns.
	//
	LPOLESTR GetResultPaneColInfo(int nCol);

	//
	// Command handler for "Enroll" functionality.
	//
	STDMETHOD( OnEnroll )(bool& bHandled, CSnapInObjectRootBase* pObj);

	//
	// Restores any state, especially in the case of using a
	// taskpad, when the back and forward buttons are used by
	// the user for navigation.
	//
	STDMETHOD( OnRestoreView )( MMC_RESTORE_VIEW* pRestoreView, BOOL* pfHandled );

	//
	// Command handler for "OnTaskpad" functionality.
	//
	STDMETHOD( OnTaskpad )(bool& bHandled, CSnapInObjectRootBase* pObj)
	{
		UNUSED_ALWAYS( bHandled );
		CComPtr<IConsole> spConsole;

		//
		// Switch the current view mode to a taskpad view.
		//
		m_fTaskpad = !m_fTaskpad;

		//
		// Reselect the node to cause GetResultViewType() to get
		// called once again.
		//
		if ( pObj->m_nType == 1 )
			spConsole = ((CBenefits*)pObj)->m_spConsole;
		else
			spConsole = ((CBenefitsComponent*)pObj)->m_spConsole;

		spConsole->SelectScopeItem( m_scopeDataItem.ID );

		return( S_OK );
	}

	//
	// Overridden to set the checkmark state of the taskpad menuitem.
	//
	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		UNUSED_ALWAYS( pBuf );

		//
		// Check the menuitem if we are currently in "taskpad"
		// mode.
		//
		if ( id == ID_VIEW_TASKPAD )
			*flags |= m_fTaskpad ? MFS_CHECKED : MFS_UNCHECKED;
	}

	//
	// Overridden to enable the delete verb.
	//
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		HRESULT hr = E_NOTIMPL;

		switch (event)
		{
		case MMCN_SELECT:
			hr = S_OK;
			break;

		case MMCN_RESTORE_VIEW:
			//
			// Called when the history list is used to navigate by
			// the user. Since we have a taskpad display, it's up
			// to us to restore that view, as appropriate.
			//
			hr = OnRestoreView( (MMC_RESTORE_VIEW*) arg, (BOOL*) param );
			break;

		case MMCN_SHOW:
			//
			// Always respond to the show call so that the
			// console knows this has been processed and can
			// properly seat toolbars, etc.
			//
			hr = S_OK;
			break;

		default:
			//
			// Always default to calling the base class implementation.
			//
			hr = CBenefitsData< CHealthNode >::Notify( event, 
					arg, 
					param, 
					pComponentData, 
					pComponent, 
					type );
		}

		return hr;
	}

	//
	// Called when one of the tasks is clicked.
	//
	STDMETHOD( TaskNotify )( IConsole* pConsole, VARIANT* arg, VARIANT* param );

	//
	// Returns an enumerator for all of these tasks.
	//
	STDMETHOD( EnumTasks )( LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK );

protected:
	//
	// Indicates whether we should be displayed in a taskpad view.
	//
	bool m_fTaskpad;
};

class CBuildingNode;
class CKeyNode : public CChildrenBenefitsData< CKeyNode >
{
public:
	SNAPINMENUID( IDR_ACCESS_MENU )
	BEGIN_SNAPINCOMMAND_MAP( CKeyNode, FALSE )
		SNAPINCOMMAND_ENTRY(ID_NEW_BUILDINGACCESS, OnGrantAccess)
	END_SNAPINCOMMAND_MAP()
	BEGIN_SNAPINTOOLBARID_MAP( CKeyNode )
		SNAPINTOOLBARID_ENTRY( IDR_ACCESSTOOLBAR )
	END_SNAPINTOOLBARID_MAP()

	CKeyNode( CEmployee* pCurEmployee );
	virtual ~CKeyNode();

	//
	// Overridden to call the base class implementation.
	//
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE2( atlTraceSnapin, 0, _T( "CNotifyImpl::Notify\n" ) );

		// Add code to handle the different notifications.
		// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
		// In response to MMCN_SHOW you have to enumerate both the scope
		// and result pane items.
		// For MMCN_EXPAND you only need to enumerate the scope items
		// Use IConsoleNameSpace::InsertItem to insert scope pane items
		// Use IResultData::InsertItem to insert result pane item.
		HRESULT hr = E_NOTIMPL;

		_ASSERTE( pComponentData != NULL || pComponent != NULL );

		CComPtr<IConsole> spConsole;
		CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
		if (pComponentData != NULL)
			spConsole = ((CBenefits*)pComponentData)->m_spConsole;
		else
		{
			spConsole = ((CBenefitsComponent*)pComponent)->m_spConsole;
			spHeader = spConsole;
		}

		switch (event)
		{
		case MMCN_SELECT:
			//
			// Call our select handler.
			//
			hr = OnSelect( spConsole );
			break;

		case MMCN_SHOW:
			//
			// Only setup colums if we're displaying the result pane.
			//
			if ( arg == TRUE )
				hr = OnShowColumn( spHeader );
			hr = OnShow( event, arg, param, spConsole, type );
			break;

		case MMCN_EXPAND:
			//
			// We do not expand as normal, since the building nodes are
			// only displayed in the result pane.
			//
			break;

		case MMCN_ADD_IMAGES:
			hr = OnAddImages( event, arg, param, spConsole, type );
			break;

		case MMCN_QUERY_PASTE:
			//
			// Called to determine if the current object can be pasted
			// or not into this context.
			//
			hr = OnQueryPaste( (LPDATAOBJECT) arg );
			break;

		case MMCN_PASTE:
			//
			// Called by MMC when the item should be pasted.
			//
			hr = OnPaste( spConsole, (LPDATAOBJECT) arg, (LPDATAOBJECT*) param );
			break;
		}

		return hr;
	}

	//
	// Ensures that the appropriate verbs are displayed.
	//
	STDMETHOD( OnSelect )( IConsole* pConsole )
	{
		HRESULT hr;
		CComPtr<IConsoleVerb> spConsoleVerb;

		//
		// Enable the delete verb.
		//
		hr = pConsole->QueryConsoleVerb( &spConsoleVerb );
		_ASSERTE( SUCCEEDED( hr ) );

		//
		// Enable the copy and paste verbs.
		//
		hr = spConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
		_ASSERTE( SUCCEEDED( hr ) );

		return( hr );
	}

	//
	// Called by the console to determine if we can paste the
	// specified node.
	//
	STDMETHOD( OnQueryPaste )( LPDATAOBJECT pItem );
	
	//
	// Called by MMC when the item should be pasted.
	//
	STDMETHOD( OnPaste )( IConsole* pConsole, LPDATAOBJECT pItem, LPDATAOBJECT* pItemCut );

	//
	// Overridden to provide strings for various columns.
	//
	LPOLESTR GetResultPaneColInfo(int nCol);

	//
	// Overridden to add new columns to the results
	// display.
	//
	STDMETHOD( OnShowColumn )( IHeaderCtrl* pHeader );

	//
	// Command handler for "Grant Acess" functionality.
	//
	STDMETHOD( OnGrantAccess )( bool& bHandled, CSnapInObjectRootBase* pObj );

	//
	// Called by one of our children nodes to inform us that
	// they should be deleted. This occurs when the user selects
	// a delete action on the building. This function should not
	// only delete the building, but also handle the refresh of
	// the result display.
	//
	STDMETHOD( OnDeleteBuilding )( IConsole* pConsole, CBuildingNode* pChildNode );
};

class CBuildingNode : public CBenefitsData< CBuildingNode >
{
public:
	BEGIN_SNAPINCOMMAND_MAP(CBuildingNode, FALSE)
	END_SNAPINCOMMAND_MAP()

	BEGIN_SNAPINTOOLBARID_MAP(CBuildingNode)
	END_SNAPINTOOLBARID_MAP()

	CBuildingNode( CKeyNode* pParentNode, BSTR bstrName, BSTR bstrLocation );
	CBuildingNode( const CBuildingNode& inNode );

	//
	// Overridden to provide strings for various columns.
	//
	LPOLESTR GetResultPaneColInfo(int nCol);

	//
	// Hold the location of this building.
	//
	BSTR m_bstrLocation;

	//
	// Pointer to our parent node to handle deletion
	// issues.
	//
	CKeyNode* m_pParentNode;

	//
	// Overridden to enable the delete verb.
	//
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		HRESULT hr = E_NOTIMPL;
		CComPtr<IConsole> spConsole;
		CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;

		if (pComponentData != NULL)
			spConsole = ((CBenefits*)pComponentData)->m_spConsole;
		else
		{
			spConsole = ((CBenefitsComponent*)pComponent)->m_spConsole;
			spHeader = spConsole;
		}

		switch (event)
		{
		case MMCN_DELETE:
			//
			// Call our delete handler.
			//
			hr = OnDelete( spConsole );
			break;

		case MMCN_SELECT:
			//
			// Call our select handler.
			//
			hr = OnSelect( spConsole );
			break;

		case MMCN_SHOW:
			//
			// Always respond to the show call so that the
			// console knows this has been processed and can
			// properly seat toolbars, etc.
			//
			hr = S_OK;
			break;

		default:
			//
			// Always default to calling the base class implementation.
			//
			hr = CBenefitsData< CBuildingNode >::Notify( event, 
					arg, 
					param, 
					pComponentData, 
					pComponent, 
					type );
		}

		return hr;
	}

	//
	// Delete handler.
	//
	STDMETHOD( OnDelete )( IConsole* pConsole )
	{
		_ASSERT( m_pParentNode != NULL );
		HRESULT hr;

		//
		// Calls the parent node to tell it to delete
		// ourselves.
		//
		hr = m_pParentNode->OnDeleteBuilding( pConsole, this );

		return( hr );
	}

	//
	// Ensures that the appropriate verbs are displayed.
	//
	STDMETHOD( OnSelect )( IConsole* pConsole )
	{
		HRESULT hr;
		CComPtr<IConsoleVerb> spConsoleVerb;

		//
		// Enable the delete verb.
		//
		hr = pConsole->QueryConsoleVerb( &spConsoleVerb );
		_ASSERTE( SUCCEEDED( hr ) );
		hr = spConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
		_ASSERTE( SUCCEEDED( hr ) );

		//
		// Enable the copy and paste verbs.
		//
		hr = spConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
		_ASSERTE( SUCCEEDED( hr ) );

		return( hr );
	}
};

#endif // !defined(AFX_BENEFTISNODES_H__E0573E77_D325_11D1_846C_00104B211BE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\bensvr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       bensvr.cpp
//
//--------------------------------------------------------------------------

// BenefitsSvr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f BenefitsSvrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "BenSvr.h"

#include "BenSvr_i.c"
#include "Benefits.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Benefits, CBenefits)
//	OBJECT_ENTRY(CLSID_BenefitsAbout, CBenefitsAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_BENEFITSSVRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\dialogs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dialogs.cpp
//
//--------------------------------------------------------------------------

// Dialogs.cpp: implementation of the CDialogs class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "Dialogs.h"
#include "WindowsX.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// {01B4A693-D970-11d1-8474-00104B211BE5}
static const GUID HealthPlan1GUID = 
{ 0x1b4a693, 0xd970, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };

// {01B4A694-D970-11d1-8474-00104B211BE5}
static const GUID HealthPlan2GUID = 
{ 0x1b4a694, 0xd970, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };

// {01B4A693-D970-11d1-8474-00104B211BE5}
static const GUID InvestmentPlan1GUID = 
{ 0x1b4a695, 0xd970, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };

// {01B4A694-D970-11d1-8474-00104B211BE5}
static const GUID InvestmentPlan2GUID = 
{ 0x1b4a696, 0xd970, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };

// {01B4A694-D970-11d1-8474-00104B211BE5}
static const GUID InvestmentPlan3GUID = 
{ 0x1b4a697, 0xd970, 0x11d1, { 0x84, 0x74, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };

//
// Initialize the static plans for health enrollment.
//
HEALTHPLANDATA g_HealthPlans[ 2 ] = 
{
	{ L"Plan 1, PPO", &HealthPlan1GUID },
	{ L"Plan 2, Share Pay", &HealthPlan2GUID },
};

//
// Initialize the static plans for health enrollment.
//
INVESTMENTPLANDATA g_InvestmentPlans[ 3 ] = 
{
	{ L"Mild Growth Fund", &InvestmentPlan1GUID },
	{ L"General Fund", &InvestmentPlan2GUID },
	{ L"Extrememe Growth Fund", &InvestmentPlan3GUID },
};

//
// Initialize the static plans for building information.
//
BUILDINGDATA g_Buildings[ 3 ] =
{
	{ L"Human Resources Building", L"Northwest Campus",  0x00000001 },
	{ L"R. & D. Building", L"Northwest Campus", 0x00000002 },
	{ L"Test Facilities", L"Off-Campus", 0x00000004 },
};

#ifdef _BENEFITS_DIALOGS

//
// Handler to initialize values in dialog. This should map data from the
// employee to the dialog controls. In this case, all these values will be
// persisted by the root node.
//
LRESULT CHealthEnrollDialog::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNUSED_ALWAYS( uiMsg );
	UNUSED_ALWAYS( wParam );
	UNUSED_ALWAYS( lParam );
	UNUSED_ALWAYS( fHandled );
	_ASSERTE( m_pEmployee != NULL );
	USES_CONVERSION;
	int nSel = 0;

	// Add a list of static plan names to the combo.
	CWindow wndCombo = GetDlgItem( IDC_COMBO_BENEFITPLAN );
	for ( int i = 0; i < sizeof( g_HealthPlans ) / sizeof( HEALTHPLANDATA ); i++ )
	{
		int nIndex = ComboBox_AddString( wndCombo, W2CT( g_HealthPlans[ i ].pstrName ) );
		if ( nIndex != CB_ERR )
		{
			//
			// Set the item data of this string.
			//
			ComboBox_SetItemData( wndCombo, nIndex, g_HealthPlans[ i ].pId );

			//
			// Determine if this matche's the employee's current plan so that
			// the current selection can be set.
			//
			if ( m_pEmployee->m_Health.PlanID == *g_HealthPlans[ i ].pId )
				nSel = nIndex;
		}
	}

	//
	// Set the current selection.
	//
	ComboBox_SetCurSel( wndCombo, nSel );

	return( TRUE );
}

//
// Stores the data and attempts to enroll the given user in the specified
// health plan.
//
LRESULT CHealthEnrollDialog::OnOK( WORD /*wNotifyCode*/, WORD /* wID */, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{	
	ENROLLPARAMS EnrollParams;
	GUID* pIdPlan = NULL;

	//
	// Get prior enrollment.
	//
	EnrollParams.fEnrolled = IsDlgButtonChecked( IDC_CHK_PRIORCOVERAGE ) == BST_CHECKED;
	if ( EnrollParams.fEnrolled )
	{
		//
		// Get the prior enrollment information.
		//
		GetDlgItemText( IDC_EDIT_INSURANCECOMPANY, EnrollParams.szInsurerName, sizeof( EnrollParams.szInsurerName ) * sizeof( TCHAR ) );
		GetDlgItemText( IDC_EDIT_POLICYNUMBER, EnrollParams.szPolicyNumber, sizeof( EnrollParams.szInsurerName ) * sizeof( TCHAR ) );
		if ( EnrollParams.szInsurerName[ 0 ] == ' ' || EnrollParams.szPolicyNumber[ 0 ] == ' ' )
		{
			//
			// The dialog text must contain some characters.
			//
			MessageBox( _T( "The insurance company or policy number you entered is invalid." ) );
		}
	}

	//
	// Retrieve the selected enrollment plan.
	//
	CWindow wndCombo = GetDlgItem( IDC_COMBO_BENEFITPLAN );
	int nIndex = ComboBox_GetCurSel( wndCombo );
	if ( nIndex != CB_ERR )
	{
		//
		// Get the associated item data with the combobox entry.
		//
		pIdPlan = (GUID*) ComboBox_GetItemData( wndCombo, nIndex );

		//
		// Actually entroll the employee in the health plan.
		//
		if ( pIdPlan != NULL && Enroll( pIdPlan, &EnrollParams ) )
		{
			//
			// Store the plan to our employee.
			//
			memcpy( &m_pEmployee->m_Health.PlanID, pIdPlan, sizeof( GUID ) );

			//
			// Inform the user that we successfully enrolled the employee.
			//
			MessageBox( _T( "The employee was successfully registered." ) );

			::EndDialog( m_hWnd, IDOK );
		}
		else
		{
			//
			// There was an error. Inform the user.
			//
			MessageBox( _T( "There was an error processing your enrollment info." ) );
		}
	}

	return( TRUE );
}

//
// A stub function that could be used to enroll the employee.
//
BOOL CHealthEnrollDialog::Enroll( GUID* pPlan, PENROLLPARAMS pParams )
{
	UNUSED_ALWAYS( pPlan );
	UNUSED_ALWAYS( pParams );

	// For demo purposes, this function does nothing but return success.
	// This is where one might make a request to a remote database, etc.
	return( TRUE );
}

//
// Sets the initial values of the dialog to the employee's current
// investment options.
//
LRESULT CRetirementEnrollDialog::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNUSED_ALWAYS( uiMsg );
	UNUSED_ALWAYS( wParam );
	UNUSED_ALWAYS( lParam );
	UNUSED_ALWAYS( fHandled );
	_ASSERTE( m_pEmployee != NULL );
	USES_CONVERSION;
	int nSel = 0;

	//
	// Set the edit control containing the benefit amount.
	//
	SetDlgItemInt( IDC_EDIT_CONTRIBUTION, m_pEmployee->m_Retirement.nContributionRate );

	//
	// Cycle through the benefit plans and add them to the combo selection.
	//
	// Add a list of static plan names to the combo.
	CWindow wndCombo = GetDlgItem( IDC_COMBO_INVESTMENTFUNDS );
	for ( int i = 0; i < sizeof( g_InvestmentPlans ) / sizeof( INVESTMENTPLANDATA ); i++ )
	{
		int nIndex = ComboBox_AddString( wndCombo, W2CT( g_InvestmentPlans[ i ].pstrName ) );
		if ( nIndex != CB_ERR )
		{
			//
			// Set the item data of this string.
			//
			ComboBox_SetItemData( wndCombo, nIndex, g_InvestmentPlans[ i ].pId );

			//
			// Determine if this matche's the employee's current plan so that
			// the current selection can be set.
			//
			if ( m_pEmployee->m_Health.PlanID == *g_InvestmentPlans[ i ].pId )
				nSel = nIndex;
		}
	}

	//
	// Set the current selection.
	//
	ComboBox_SetCurSel( wndCombo, nSel );


	return( TRUE );
}

//
// Stores the data and attempts to enroll the given user in the specified
// health plan.
//
LRESULT CRetirementEnrollDialog::OnOK( WORD /*wNotifyCode*/, WORD /* wID */, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{	
	GUID* pIdPlan = NULL;

	//
	// Get the new enrollment amount.
	//
	int nNewRate = GetDlgItemInt( IDC_EDIT_CONTRIBUTION );

	//
	// Retrieve the selected enrollment plan.
	//
	CWindow wndCombo = GetDlgItem( IDC_COMBO_INVESTMENTFUNDS );
	int nIndex = ComboBox_GetCurSel( wndCombo );
	if ( nIndex != CB_ERR )
	{
		//
		// Get the associated item data with the combobox entry.
		//
		pIdPlan = (GUID*) ComboBox_GetItemData( wndCombo, nIndex );

		//
		// Actually entroll the employee in the health plan.
		//
		if ( pIdPlan != NULL && Enroll( pIdPlan, nNewRate ) )
		{
			//
			// Store the plan to our employee.
			//
			memcpy( &m_pEmployee->m_Retirement.PlanID, pIdPlan, sizeof( GUID ) );

			//
			// Inform the user that we successfully enrolled the employee.
			//
			MessageBox( _T( "The employee was successfully registered." ) );

			::EndDialog( m_hWnd, IDOK );
		}
		else
		{
			//
			// There was an error. Inform the user.
			//
			MessageBox( _T( "There was an error processing your enrollment info." ) );
		}
	}

	return( TRUE );
}

//
// A stub function that could be used to enroll the employee.
//
BOOL CRetirementEnrollDialog::Enroll( GUID* pPlan, int nNewRate )
{
	UNUSED_ALWAYS( pPlan );
	UNUSED_ALWAYS( nNewRate );

	// For demo purposes, this function does nothing but return success.
	// This is where one might make a request to a remote database, etc.
	return( TRUE );
}

//
// Sets the initial values of the dialog to the employee's current
// investment options.
//
LRESULT CBuildingAccessDialog::OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled )
{
	UNUSED_ALWAYS( uiMsg );
	UNUSED_ALWAYS( wParam );
	UNUSED_ALWAYS( lParam );
	UNUSED_ALWAYS( fHandled );
	USES_CONVERSION;
	_ASSERTE( m_pEmployee != NULL );

	//
	// Cycle through the benefit plans and add them to the combo selection.
	//
	// Add a list of static plan names to the combo.
	CWindow wndCombo = GetDlgItem( IDC_COMBO_BUILDINGS );
	for ( int i = 0; i < sizeof( g_Buildings ) / sizeof( BUILDINGDATA ); i++ )
	{
		int nIndex = ComboBox_AddString( wndCombo, W2CT( g_Buildings[ i ].pstrName ) );
		if ( nIndex != CB_ERR )
		{
			//
			// Set the item data of this string.
			//
			ComboBox_SetItemData( wndCombo, nIndex, g_Buildings[ i ].dwId );
		}
	}

	//
	// Set the default current selection to the first item.
	//
	ComboBox_SetCurSel( wndCombo, 0 );

	return( TRUE );
}

//
// Stores the data and attempts to enroll the given user in the specified
// health plan.
//
LRESULT CBuildingAccessDialog::OnOK( WORD /*wNotifyCode*/, WORD /* wID */, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{	
	//
	// Retrieve the selected enrollment plan.
	//
	CWindow wndCombo = GetDlgItem( IDC_COMBO_BUILDINGS );
	int nIndex = ComboBox_GetCurSel( wndCombo );
	if ( nIndex != CB_ERR )
	{
		DWORD dwBuildingId;

		//
		// Get the associated item data with the combobox entry.
		//
		dwBuildingId = ComboBox_GetItemData( wndCombo, nIndex );

		//
		// Actually entroll the employee in the health plan.
		//
		if ( GrantAccess( dwBuildingId ) )
		{
			//
			// Store the plan to our employee.
			//
			m_pEmployee->m_Access.dwAccess |= dwBuildingId;

			//
			// Inform the user that we successfully enrolled the employee.
			//
			MessageBox( _T( "The employee was successfully granted access." ) );

			::EndDialog( m_hWnd, IDOK );
		}
		else
		{
			//
			// There was an error. Inform the user.
			//
			MessageBox( _T( "There was an error granting the employee access." ) );
		}
	}

	return( TRUE );
}

//
// A stub function that could be used to enroll the employee.
//
BOOL CBuildingAccessDialog::GrantAccess( DWORD dwBuildingId )
{
	UNUSED_ALWAYS( dwBuildingId );

	// For demo purposes, this function does nothing but return success.
	// This is where one might make a request to a remote database, etc.
	return( TRUE );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\dialogs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dialogs.h
//
//--------------------------------------------------------------------------

// Dialogs.h
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIALOGS_H__AE8F4B53_D4B3_11D1_846F_00104B211BE5__INCLUDED_)
#define AFX_DIALOGS_H__AE8F4B53_D4B3_11D1_846F_00104B211BE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// Includes
//
#include "Employee.h"

//
// Helper structure to define plan names and ids.
//
typedef struct tagHEALTHPLANDATA
{
	WCHAR* pstrName;
	const GUID* pId;
} HEALTHPLANDATA, FAR* PHEALTHPLANDATA;

//
// Helper structure to define plan names and ids.
//
typedef struct tagINVESTMENTPLANDATA
{
	WCHAR* pstrName;
	const GUID* pId;
} INVESTMENTPLANDATA, FAR* PINVESTMENTPLANDATA;

//
// Helper structure to define building names and ids.
//
typedef struct tagBUILDINGDATA
{
	WCHAR* pstrName;
	WCHAR* pstrLocation;
	DWORD dwId;
} BUILDINGDATA, FAR* PBUILDINGDATA;

#ifdef _BENEFITS_DIALOGS

//
// Helper class to contain employee data.
//
template< class T >
class CBenefitsDialog : public CDialogImpl<T>
{
public:
	CBenefitsDialog()
	{
		//
		// Initialize all members.
		//
		m_pEmployee = NULL;
	};

	//
	// Create a message map that handles all of our cancel button
	// implementations.
	//
	BEGIN_MSG_MAP( CBenefitsDialog<T> )
		COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnCloseCmd )
	END_MSG_MAP()

	//
	// Access function to set the employee that the dialog
	// will use.
	//
	void SetEmployee( CEmployee* pEmployee )
	{
		_ASSERTE( pEmployee != NULL );
		m_pEmployee = pEmployee;
	};

	//
	// Dismisses dialogs when the OK or cancel button are pressed.
	//
	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		::EndDialog(m_hWnd, wID);
		return 0;
	};

protected:
	CEmployee* m_pEmployee;
};

//
// Dialog handler for the CHealthNode enroll process.
//
class CHealthEnrollDialog : public CBenefitsDialog<CHealthEnrollDialog>
{
public:
	enum { IDD = IDD_HEALTHENROLL_DIALOG };

	BEGIN_MSG_MAP( CHealthEnrollDialog )
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		COMMAND_HANDLER( IDOK, BN_CLICKED, OnOK )
		CHAIN_MSG_MAP( CBenefitsDialog<CHealthEnrollDialog> )
	END_MSG_MAP()

	//
	// Handler to initialize values in dialog. This should map data from the
	// employee to the dialog controls.
	//
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );

	//
	// Stores the data and attempts to enroll the given user in the specified
	// health plan.
	//
	LRESULT OnOK( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ );

protected:
	//
	// Helper structure for enrollment purposes.
	//
	typedef struct tagENROLLPARAMS
	{
		tagENROLLPARAMS()
		{
			fEnrolled = FALSE;
		}

		BOOL fEnrolled;
		TCHAR szInsurerName[ 256 ];
		TCHAR szPolicyNumber[ 256 ];
	} ENROLLPARAMS, FAR* PENROLLPARAMS;

	//
	// A stub function that could be used to enroll the employee.
	//
	BOOL Enroll( GUID* pPlan, PENROLLPARAMS pParams );
};

//
// Dialog handler for the CRetirementNode enroll process.
//
class CRetirementEnrollDialog : public CBenefitsDialog<CRetirementEnrollDialog>
{
public:
	enum { IDD = IDD_RETIREMENTENROLL_DIALOG };

	BEGIN_MSG_MAP( CRetirementEnrollDialog )
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		COMMAND_HANDLER( IDOK, BN_CLICKED, OnOK )
		CHAIN_MSG_MAP( CBenefitsDialog<CRetirementEnrollDialog> )
	END_MSG_MAP()

	//
	// Handler to initialize values in dialog. 
	//
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );

	//
	// Stores the data and attempts to enroll the given user in the specified
	// investment plan.
	//
	LRESULT OnOK( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ );

protected:
	//
	// A stub function that could be used to enroll the employee.
	//
	BOOL Enroll( GUID* pPlan, int nNewRate );
};

//
// Dialog handler for the CRetirementNode enroll process.
//
class CBuildingAccessDialog : public CBenefitsDialog<CBuildingAccessDialog>
{
public:
	enum { IDD = IDD_BUILDINGACCESS_DIALOG };

	BEGIN_MSG_MAP( CBuildingAccessDialog )
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		COMMAND_HANDLER( IDOK, BN_CLICKED, OnOK )
		CHAIN_MSG_MAP( CBenefitsDialog<CBuildingAccessDialog> )
	END_MSG_MAP()

	//
	// Handler to initialize values in dialog. 
	//
	LRESULT OnInitDialog( UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled );

	//
	// Stores the data and attempts to enroll the given user in the specified
	// investment plan.
	//
	LRESULT OnOK( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ );

protected:
	//
	// A stub function that could be used to enroll the employee.
	//
	BOOL GrantAccess( DWORD dwBuildingId );
};

#endif

#endif // !defined(AFX_DIALOGS_H__AE8F4B53_D4B3_11D1_846F_00104B211BE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\employee.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       employee.h
//
//--------------------------------------------------------------------------

// Employee.h: interface for the CEmployee class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EMPLOYEE_H__374DBB66_D945_11D1_8474_00104B211BE5__INCLUDED_)
#define AFX_EMPLOYEE_H__374DBB66_D945_11D1_8474_00104B211BE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// Structure to help track an employee's health plan.
//
typedef struct tagHEALTHPLAN
{
	GUID PlanID;				// A global ID of the employee's currently enrolled
								// health plan.
} HEALTHPLAN, FAR* PHEALTHPLAN;

//
// Structure to help track an employee's retirement plan.
//
typedef struct tagRETIREMENTPLAN
{
	GUID PlanID;				// An ID of the employee's currently enrolled
								// retirement plan.
	int nContributionRate;		// The employee's contribution rate, in percentage points.
} RETIREMENTPLAN, FAR* PRETIREMENTPLAN;

//
// Structure to help track an employee's card key access.
//
typedef struct tagACCESS
{
	DWORD dwAccess;				// A bitmask indicating which buildings we have access
								// to.
} ACCESS, FAR* PACCESS;

class CEmployee  
{
public:
	//
	// Standard constructor. Initializes data.
	//
	CEmployee()
	{
		//
		// Ensure that everything is zeroed.
		//
		memset( this, 0, sizeof( CEmployee ) );

		//
		// Always grant a newly created employee full access.
		//
		m_Access.dwAccess = 0xFFFF;
	};
	virtual ~CEmployee() {};
	
	//
	// Typical information usually retained about an employee.
	//
	WCHAR m_szFirstName[ 256 ];		// Holds first name.
	WCHAR m_szLastName[ 256 ];		// Holds last name.
	WCHAR m_szSocialSecurity[ 256 ]; // Holds the social security number.
	WCHAR m_szMotherMaiden[ 256 ];	// Holds mother's maiden name for identification.
	WCHAR m_szAddress1[ 256 ];		// Holds first line of address.
	WCHAR m_szAddress2[ 256 ];		// Holds second line of address.
	WCHAR m_szCity[ 256 ];			// Holds city name.
	WCHAR m_szState[ 256 ];			// Hold the state.
	WCHAR m_szZip[ 256 ];			// Hold the zip code.
	WCHAR m_szPhone[ 256 ];			// Holds a phone number.

	// Information used for the sub-nodes.
	HEALTHPLAN m_Health;			// Health information.
	RETIREMENTPLAN m_Retirement;	// Retirement information.
	ACCESS m_Access;				// Card-key access information.
};

#endif // !defined(AFX_EMPLOYEE_H__374DBB66_D945_11D1_8474_00104B211BE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\htmlhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       htmlhelp.h
//
//--------------------------------------------------------------------------

/****************************************************************************
*                                                                           *
* HtmlHelp.h                                                                *
*                                                                           *
* Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC        0x0000
#define HH_HELP_FINDER          0x0000  // WinHelp equivalent
#define HH_DISPLAY_TOC          0x0001  // not currently implemented
#define HH_DISPLAY_INDEX        0x0002  // not currently implemented
#define HH_DISPLAY_SEARCH       0x0003  // not currently implemented
#define HH_SET_WIN_TYPE         0x0004
#define HH_GET_WIN_TYPE         0x0005
#define HH_GET_WIN_HANDLE       0x0006
#define HH_ENUM_INFO_TYPE       0x0007  // Get Info type name, call repeatedly to enumerate, -1 at end
#define HH_SET_INFO_TYPE        0x0008  // Add Info type to filter.
#define HH_SYNC                 0x0009
#define HH_RESERVED1            0x000A
#define HH_RESERVED2            0x000B
#define HH_RESERVED3            0x000C
#define HH_KEYWORD_LOOKUP       0x000D
#define HH_DISPLAY_TEXT_POPUP   0x000E  // display string resource id or text in a popup window
#define HH_HELP_CONTEXT         0x000F  // display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU  0x0010  // text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP      0x0011  // text popup help, same as WinHelp HELP_WM_HELP
#define HH_CLOSE_ALL            0x0012  // close all windows opened directly or indirectly by the caller
#define HH_ALINK_LOOKUP         0x0013  // ALink version of HH_KEYWORD_LOOKUP
#define HH_GET_LAST_ERROR       0x0014  // not currently implemented // See HHERROR.h
#define HH_ENUM_CATEGORY        0x0015	// Get category name, call repeatedly to enumerate, -1 at end
#define HH_ENUM_CATEGORY_IT     0x0016  // Get category info type members, call repeatedly to enumerate, -1 at end
#define HH_RESET_IT_FILTER      0x0017  // Clear the info type filter of all info types.
#define HH_SET_INCLUSIVE_FILTER 0x0018  // set inclusive filtering method for untyped topics to be included in display
#define HH_SET_EXCLUSIVE_FILTER 0x0019  // set exclusive filtering method for untyped topics to be excluded from display
#define HH_SET_GUID             0x001A  // For Microsoft Installer -- dwData is a pointer to the GUID string
#define HH_SET_BACKUP_GUID      0x001B  // For Microsoft Installer -- dwData is a pointer to the GUID string


#define HHWIN_PROP_TAB_AUTOHIDESHOW (1 << 0)    // Automatically hide/show tri-pane window
#define HHWIN_PROP_ONTOP            (1 << 1)    // Top-most window
#define HHWIN_PROP_NOTITLEBAR       (1 << 2)    // no title bar
#define HHWIN_PROP_NODEF_STYLES     (1 << 3)    // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES   (1 << 4)    // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE         (1 << 5)    // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT        (1 << 6)    // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT        (1 << 7)    // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC        (1 << 8)    // automatically ssync contents and index
#define HHWIN_PROP_TRACKING         (1 << 9)    // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH       (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY      (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES    (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE     (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN     (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR       (1 << 15)   // Don't display a toolbar
#define HHWIN_PROP_MENU             (1 << 16)   // Menu
#define HHWIN_PROP_TAB_ADVSEARCH    (1 << 17)   // Advanced FTS UI.
#define HHWIN_PROP_USER_POS         (1 << 18)   // After initial creation, user controls window size/position
#define HHWIN_PROP_TAB_CUSTOM1      (1 << 19)   // Use custom tab #1
#define HHWIN_PROP_TAB_CUSTOM2      (1 << 20)   // Use custom tab #2
#define HHWIN_PROP_TAB_CUSTOM3      (1 << 21)   // Use custom tab #3
#define HHWIN_PROP_TAB_CUSTOM4      (1 << 22)   // Use custom tab #4
#define HHWIN_PROP_TAB_CUSTOM5      (1 << 23)   // Use custom tab #5
#define HHWIN_PROP_TAB_CUSTOM6      (1 << 24)   // Use custom tab #6
#define HHWIN_PROP_TAB_CUSTOM7      (1 << 25)   // Use custom tab #7
#define HHWIN_PROP_TAB_CUSTOM8      (1 << 26)   // Use custom tab #8
#define HHWIN_PROP_TAB_CUSTOM9      (1 << 27)   // Use custom tab #9
#define HHWIN_TB_MARGIN             (1 << 28)   // the window type has a margin

#define HHWIN_PARAM_PROPERTIES      (1 << 1)    // valid fsWinProperties
#define HHWIN_PARAM_STYLES          (1 << 2)    // valid dwStyles
#define HHWIN_PARAM_EXSTYLES        (1 << 3)    // valid dwExStyles
#define HHWIN_PARAM_RECT            (1 << 4)    // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH       (1 << 5)    // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE       (1 << 6)    // valid nShowState
#define HHWIN_PARAM_INFOTYPES       (1 << 7)    // valid apInfoTypes
#define HHWIN_PARAM_TB_FLAGS        (1 << 8)    // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION       (1 << 9)    // valid fNotExpanded
#define HHWIN_PARAM_TABPOS          (1 << 10)   // valid tabpos
#define HHWIN_PARAM_TABORDER        (1 << 11)   // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT   (1 << 12)   // valid cHistory
#define HHWIN_PARAM_CUR_TAB         (1 << 13)   // valid curNavType

#define HHWIN_BUTTON_EXPAND         (1 << 1)    // Expand/contract button
#define HHWIN_BUTTON_BACK           (1 << 2)    // Back button
#define HHWIN_BUTTON_FORWARD        (1 << 3)    // Forward button
#define HHWIN_BUTTON_STOP           (1 << 4)    // Stop button
#define HHWIN_BUTTON_REFRESH        (1 << 5)    // Refresh button
#define HHWIN_BUTTON_HOME           (1 << 6)    // Home button
#define HHWIN_BUTTON_BROWSE_FWD     (1 << 7)    // not implemented
#define HHWIN_BUTTON_BROWSE_BCK     (1 << 8)    // not implemented
#define HHWIN_BUTTON_NOTES          (1 << 9)    // not implemented
#define HHWIN_BUTTON_CONTENTS       (1 << 10)   // not implemented
#define HHWIN_BUTTON_SYNC           (1 << 11)   // Sync button
#define HHWIN_BUTTON_OPTIONS        (1 << 12)   // Options button
#define HHWIN_BUTTON_PRINT          (1 << 13)   // Print button
#define HHWIN_BUTTON_INDEX          (1 << 14)   // not implemented
#define HHWIN_BUTTON_SEARCH         (1 << 15)   // not implemented
#define HHWIN_BUTTON_HISTORY        (1 << 16)   // not implemented
#define HHWIN_BUTTON_FAVORITES      (1 << 17)   // not implemented
#define HHWIN_BUTTON_JUMP1          (1 << 18)
#define HHWIN_BUTTON_JUMP2          (1 << 19)
#define HHWIN_BUTTON_ZOOM           (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT       (1 << 21)
#define HHWIN_BUTTON_TOC_PREV       (1 << 22)

#define HHWIN_DEF_BUTTONS           \
            (HHWIN_BUTTON_EXPAND |  \
             HHWIN_BUTTON_BACK |    \
             HHWIN_BUTTON_OPTIONS | \
             HHWIN_BUTTON_PRINT)

// Button IDs

#define IDTB_EXPAND             200
#define IDTB_CONTRACT           201
#define IDTB_STOP               202
#define IDTB_REFRESH            203
#define IDTB_BACK               204
#define IDTB_HOME               205
#define IDTB_SYNC               206
#define IDTB_PRINT              207
#define IDTB_OPTIONS            208
#define IDTB_FORWARD            209
#define IDTB_NOTES              210 // not implemented
#define IDTB_BROWSE_FWD         211
#define IDTB_BROWSE_BACK        212
#define IDTB_CONTENTS           213 // not implemented
#define IDTB_INDEX              214 // not implemented
#define IDTB_SEARCH             215 // not implemented
#define IDTB_HISTORY            216 // not implemented
#define IDTB_FAVORITES          217 // not implemented
#define IDTB_JUMP1              218
#define IDTB_JUMP2              219
#define IDTB_CUSTOMIZE          221
#define IDTB_ZOOM               222
#define IDTB_TOC_NEXT           223
#define IDTB_TOC_PREV           224

// Notification codes

#define HHN_FIRST       (0U-860U)
#define HHN_LAST        (0U-879U)

#define HHN_NAVCOMPLETE   (HHN_FIRST-0)
#define HHN_TRACK         (HHN_FIRST-1)
#define HHN_WINDOW_CREATE (HHN_FIRST-2)

typedef struct tagHHN_NOTIFY
{
    NMHDR   hdr;
    PCSTR   pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
    int       cbStruct;      // sizeof this structure
    HINSTANCE hinst;         // instance handle for string resource
    UINT      idString;      // string resource id, or text id if pszFile is specified in HtmlHelp call
    LPCTSTR   pszText;       // used if idString is zero
    POINT     pt;            // top center of popup window
    COLORREF  clrForeground; // use -1 for default
    COLORREF  clrBackground; // use -1 for default
    RECT      rcMargins;     // amount of space between edges of window and text, -1 for each member to ignore
    LPCTSTR   pszFont;       // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
    int       cbStruct;     // sizeof this structure
    BOOL      fReserved;    // must be FALSE (really!)
    LPCTSTR   pszKeywords;  // semi-colon separated keywords
    LPCTSTR   pszUrl;       // URL to jump to if no keywords found (may be NULL)
    LPCTSTR   pszMsgText;   // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszMsgTitle;  // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszWindow;    // Window to display URL in
    BOOL      fIndexOnFail; // Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
    HHWIN_NAVTYPE_TOC,
    HHWIN_NAVTYPE_INDEX,
    HHWIN_NAVTYPE_SEARCH,
    HHWIN_NAVTYPE_FAVORITES,
    HHWIN_NAVTYPE_HISTORY,   // not implemented
    HHWIN_NAVTYPE_AUTHOR,
    HHWIN_NAVTYPE_CUSTOM_FIRST = 11
};

enum {
    IT_INCLUSIVE,
    IT_EXCLUSIVE,
    IT_HIDDEN,
};

typedef struct tagHH_ENUM_IT
{
    int       cbStruct;          // size of this structure
    int       iType;             // the type of the information type ie. Inclusive, Exclusive, or Hidden
    LPCSTR    pszCatName;        // Set to the name of the Category to enumerate the info types in a category; else NULL
    LPCSTR    pszITName;         // volitile pointer to the name of the infotype. Allocated by call. Caller responsible for freeing
    LPCSTR    pszITDescription;  // volitile pointer to the description of the infotype.
} HH_ENUM_IT, *PHH_ENUM_IT;

typedef struct tagHH_ENUM_CAT
{
    int       cbStruct;          // size of this structure
    LPCSTR    pszCatName;        // volitile pointer to the category name
    LPCSTR    pszCatDescription; // volitile pointer to the category description
} HH_ENUM_CAT, *PHH_ENUM_CAT;

typedef struct tagHH_SET_INFOTYPE
{
    int       cbStruct;          // the size of this structure
    LPCSTR    pszCatName;        // the name of the category, if any, the InfoType is a member of.
    LPCSTR    pszInfoTypeName;   // the name of the info type to add to the filter
} HH_SET_INFOTYPE, *PHH_SET_INFOTYPE;

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
    HHWIN_NAVTAB_TOP,
    HHWIN_NAVTAB_LEFT,
    HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19  // maximum number of tabs

enum {
    HH_TAB_CONTENTS,
    HH_TAB_INDEX,
    HH_TAB_SEARCH,
    HH_TAB_FAVORITES,
    HH_TAB_HISTORY,
    HH_TAB_AUTHOR,

    HH_TAB_CUSTOM_FIRST = 11,
    HH_TAB_CUSTOM_LAST = HH_MAX_TABS
};

#define HH_MAX_TABS_CUSTOM (HH_TAB_CUSTOM_LAST - HH_TAB_CUSTOM_FIRST + 1)

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
    int cbStruct;            // Sizeof structure in bytes.
    BOOL fUniCodeStrings;    // TRUE if all strings are unicode.
    LPCTSTR pszSearchQuery;  // String containing the search query.
    LONG iProximity;         // Word proximity.
    BOOL fStemmedSearch;     // TRUE for StemmedSearch only.
    BOOL fTitleOnly;         // TRUE for Title search only.
    BOOL fExecute;           // TRUE to initiate the search.
    LPCTSTR pszWindow;       // Window to display in
} HH_FTS_QUERY;

// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
    int     cbStruct;        // IN: size of this structure including all Information Types
    BOOL    fUniCodeStrings; // IN/OUT: TRUE if all strings are in UNICODE
    LPCTSTR pszType;         // IN/OUT: Name of a type of window
    DWORD   fsValidMembers;  // IN: Bit flag of valid members (HHWIN_PARAM_)
    DWORD   fsWinProperties; // IN/OUT: Properties/attributes of the window (HHWIN_)

    LPCTSTR pszCaption;      // IN/OUT: Window title
    DWORD   dwStyles;        // IN/OUT: Window styles
    DWORD   dwExStyles;      // IN/OUT: Extended Window styles
    RECT    rcWindowPos;     // IN: Starting position, OUT: current position
    int     nShowState;      // IN: show state (e.g., SW_SHOW)

    HWND  hwndHelp;          // OUT: window handle
    HWND  hwndCaller;        // OUT: who called this window

    HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

    // The following members are only valid if HHWIN_PROP_TRI_PANE is set

    HWND  hwndToolBar;      // OUT: toolbar window in tri-pane window
    HWND  hwndNavigation;   // OUT: navigation window in tri-pane window
    HWND  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    int   iNavWidth;        // IN/OUT: width of navigation window
    RECT  rcHTML;           // OUT: HTML window coordinates

    LPCTSTR pszToc;         // IN: Location of the table of contents file
    LPCTSTR pszIndex;       // IN: Location of the index file
    LPCTSTR pszFile;        // IN: Default location of the html file
    LPCTSTR pszHome;        // IN/OUT: html file to display when Home button is clicked
    DWORD   fsToolBarFlags; // IN: flags controling the appearance of the toolbar
    BOOL    fNotExpanded;   // IN: TRUE/FALSE to contract or expand, OUT: current state
    int     curNavType;     // IN/OUT: UI to display in the navigational pane
    int     tabpos;         // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    int     idNotify;       // IN: ID to use for WM_NOTIFY messages
    BYTE    tabOrder[HH_MAX_TABS + 1];    // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    int     cHistory;       // IN/OUT: number of history items to keep (default is 30)
    LPCTSTR pszJump1;       // Text for HHWIN_BUTTON_JUMP1
    LPCTSTR pszJump2;       // Text for HHWIN_BUTTON_JUMP2
    LPCTSTR pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
    LPCTSTR pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    RECT    rcMinSize;      // Minimum size for window (ignored in version 1)
    int     cbInfoTypes;    // size of paInfoTypes;
    LPCTSTR pszCustomTabs;  // multiple zero-terminated strings
} HH_WINTYPE, *PHH_WINTYPE;

enum {
    HHACT_TAB_CONTENTS,
    HHACT_TAB_INDEX,
    HHACT_TAB_SEARCH,
    HHACT_TAB_HISTORY,
    HHACT_TAB_FAVORITES,

    HHACT_EXPAND,
    HHACT_CONTRACT,
    HHACT_BACK,
    HHACT_FORWARD,
    HHACT_STOP,
    HHACT_REFRESH,
    HHACT_HOME,
    HHACT_SYNC,
    HHACT_OPTIONS,
    HHACT_PRINT,
    HHACT_HIGHLIGHT,
    HHACT_CUSTOMIZE,
    HHACT_JUMP1,
    HHACT_JUMP2,
    HHACT_ZOOM,
    HHACT_TOC_NEXT,
    HHACT_TOC_PREV,
    HHACT_NOTES,

    HHACT_LAST_ENUM,
};

typedef struct tagHHNTRACK
{
    NMHDR   hdr;
    PCSTR   pszCurUrl;      // Multi-byte, null-terminated string
    int     idAction;       // HHACT_ value
    HH_WINTYPE* phhWinType; // Current window type structure
} HHNTRACK;

HWND
WINAPI
HtmlHelpA(
    HWND hwndCaller,
    LPCSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );

HWND
WINAPI
HtmlHelpW(
    HWND hwndCaller,
    LPCWSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI    (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\rootnode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootnode.h
//
//--------------------------------------------------------------------------

// RootNode.h: interface for the CRootNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ROOTNODE_H__E0573E78_D325_11D1_846C_00104B211BE5__INCLUDED_)
#define AFX_ROOTNODE_H__E0573E78_D325_11D1_846C_00104B211BE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Benefits.h"
#include "Employee.h"

class CRootNode : public CChildrenBenefitsData< CRootNode >
{
public:
	BEGIN_SNAPINTOOLBARID_MAP( CRootNode )
	END_SNAPINTOOLBARID_MAP()

	CRootNode();
	
	//
	// Creates the benefits subnodes for the scope pane.
	//
	BOOL InitializeSubNodes();

	//
	// Overridden to provide employee name for root node.
	//
	STDMETHOD( FillData )( CLIPFORMAT cf, LPSTREAM pStream );

	//
	// Overridden to add new columns to the results
	// display.
	//
	STDMETHOD( OnShowColumn )( IHeaderCtrl* pHeader );

	//
	// Handles creation of our property pages.
	//
    STDMETHOD( CreatePropertyPages )(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type);

	//
	// Determines if pages should be displayed. This has been
	// modified to ensure that we're called by the snap-in manager
	// when it's first inserted.
	//
    STDMETHOD( QueryPagesFor )(DATA_OBJECT_TYPES type)
	{
		if ( type == CCT_SCOPE || type == CCT_RESULT || type == CCT_SNAPIN_MANAGER )
			return S_OK;
		return S_FALSE;
	}

	//
	// Ensures that the appropriate verbs are displayed.
	//
	STDMETHOD( OnSelect )( IConsole* pConsole );

	//
	// Overridden to call the base class implementation.
	//
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        long arg,
        long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		// Add code to handle the different notifications.
		// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
		// For MMCN_EXPAND you only need to enumerate the scope items
		// Use IConsoleNameSpace::InsertItem to insert scope pane items
		// Use IResultData::InsertItem to insert result pane item.
		HRESULT hr = E_NOTIMPL;

		_ASSERTE(pComponentData != NULL || pComponent != NULL);

		CComPtr<IConsole> spConsole;
		CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
		if (pComponentData != NULL)
			spConsole = ((CBenefits*)pComponentData)->m_spConsole;
		else
		{
			spConsole = ((CBenefitsComponent*)pComponent)->m_spConsole;
			spHeader = spConsole;
		}

		switch (event)
		{
		case MMCN_SELECT:
			hr = OnSelect( spConsole );
			break;

		case MMCN_SHOW:
			// Only setup colums if we're displaying the result pane.
			if ( arg == TRUE )
				hr = OnShowColumn( spHeader );
			break;

		case MMCN_EXPAND:
			//
			// Since the insert item is never called, we don't have a valid
			// HSCOPEITEM as you would in sub-nodes. The Expand message is
			// intercepted and stored for use later.
			//
			m_scopeDataItem.ID = param;
			hr = OnExpand( event, arg, param, spConsole, type );
			break;

		case MMCN_ADD_IMAGES:
			hr = OnAddImages( event, arg, param, spConsole, type );
			break;
		}

		return hr;
	}

	//
	// Uses the dirty flag to determine whether or not this node
	// needs to be persisted.
	//
	STDMETHOD(IsDirty)()
	{
		return ( m_fDirty ? S_OK : S_FALSE );
	}

	//
	// Loads the employee information from the stream.
	//
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		DWORD dwRead;

		pStm->Read( &m_Employee, sizeof( m_Employee ), &dwRead );
		_ASSERTE( dwRead == sizeof( m_Employee ) );

		return( S_OK );
	}

	//
	// Stores the employee information to the stream and clears
	// our dirty flag.
	//
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		DWORD dwWritten;

		pStm->Write( &m_Employee, sizeof( m_Employee ), &dwWritten );
		_ASSERTE( dwWritten == sizeof( m_Employee ) );

		//
		// Clear the dirty flag.
		//
		if ( fClearDirty )
			m_fDirty = FALSE;

		return( S_OK );
	}

	//
	// Returns the size of the employee structure.
	//
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize )
	{
		pcbSize->LowPart = sizeof( m_Employee );
		return( S_OK );
	}

	//
	// Received when a property has changed. This function
	// modifies the employee's display text. At a later date,
	// it may post this message to its sub-nodes.
	//
	STDMETHOD( OnPropertyChange )( IConsole* pConsole );

protected:
	//
	// Simply function to create the display name from the
	// employee data.
	//
	int CreateDisplayName( TCHAR* szBuf );

	//
	// Called to set the dirty flag for persistence.
	//
	void SetModified( bool fDirty = true )
	{
		m_fDirty = fDirty;
	}

	//
	// Contains the the employees entire datastore for this
	// sample.
	//
	CEmployee m_Employee;		

	//
	// Flag set to indicate whether the datastore is "dirty".
	//
	bool m_fDirty;
};

#endif // !defined(AFX_ROOTNODE_H__E0573E78_D325_11D1_846C_00104B211BE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\rootnode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootnode.cpp
//
//--------------------------------------------------------------------------

// RootNode.cpp: implementation of the CRootNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "RootNode.h"
#include "BenNodes.h"
#include "Dialogs.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
static const GUID CBenefitsGUID_NODETYPE = 
{ 0xe0573e71, 0xd325, 0x11d1, { 0x84, 0x6c, 0x0, 0x10, 0x4b, 0x21, 0x1b, 0xe5 } };
const GUID*  CRootNode::m_NODETYPE = &CBenefitsGUID_NODETYPE;
const TCHAR* CRootNode::m_SZNODETYPE = _T("E0573E71-D325-11D1-846C-00104B211BE5");
const TCHAR* CRootNode::m_SZDISPLAY_NAME = _T("Benefits");
const CLSID* CRootNode::m_SNAPIN_CLASSID = &CLSID_Benefits;

//
// Pass NULL in as the employee since this contains the valid
// employee. The pointer to the employee is leftover baggage
// from using the CBenefitsData() template.
//
CRootNode::CRootNode() : CChildrenBenefitsData< CRootNode >()
{
	m_scopeDataItem.nOpenImage = 5;
	m_scopeDataItem.nImage = 4;

	//
	// Always clear our dirty flag.
	//
	m_fDirty = false;
}

//
// Creates the benefits subnodes for the scope pane.
//
BOOL CRootNode::InitializeSubNodes()
{
	CSnapInItem* pNode;

	//
	// Allocate sub nodes and add them to our internal list.
	//
	pNode = new CHealthNode( &m_Employee );
	if ( pNode == NULL || m_Nodes.Add( pNode ) == FALSE )
		return( FALSE );

	pNode = new CRetirementNode( &m_Employee );
	if ( pNode == NULL || m_Nodes.Add( pNode ) == FALSE )
		return( FALSE );

	pNode = new CKeyNode( &m_Employee );
	if ( pNode == NULL || m_Nodes.Add( pNode ) == FALSE )
		return( FALSE );

	return( TRUE );
}

//
// Overridden to provide employee name for root node.
//
STDMETHODIMP CRootNode::FillData( CLIPFORMAT cf, LPSTREAM pStream )
{
	HRESULT hr = DV_E_CLIPFORMAT;
	ULONG uWritten;

	//
	// We need to write out our own member since GetDisplayName() does
	// not give us an opportunity override its static implementation by
	// ATL.
	//
	if (cf == m_CCF_NODETYPE)
	{
		hr = pStream->Write( GetNodeType(), sizeof(GUID), &uWritten);
		return hr;
	}

	if (cf == m_CCF_SZNODETYPE)
	{
		hr = pStream->Write( GetSZNodeType(), (lstrlen((LPCTSTR) GetSZNodeType()) + 1 )* sizeof(TCHAR), &uWritten);
		return hr;
	}

	if (cf == m_CCF_DISPLAY_NAME)
	{
		USES_CONVERSION;
		TCHAR szDisplayName[ 256 ];
		LPWSTR pwszName;

		// Create a full display name.
		CreateDisplayName( szDisplayName );
		pwszName = T2W( szDisplayName );
		hr = pStream->Write( pwszName, wcslen( pwszName ) * sizeof( WCHAR ), &uWritten);
		return hr;
	}

	if (cf == m_CCF_SNAPIN_CLASSID)
	{
		hr = pStream->Write( GetSnapInCLSID(), sizeof(GUID), &uWritten);
		return hr;
	}

	return hr;
}

//
// Overridden to add new columns to the results
// display.
//
STDMETHODIMP CRootNode::OnShowColumn( IHeaderCtrl* pHeader )
{
	USES_CONVERSION;
	HRESULT hr = E_FAIL;
	CComPtr<IHeaderCtrl> spHeader( pHeader );

	//
	// Add two columns: one with the name of the object and one with
	// the description of the node. Use the value of 200 pixels as the size.
	//
	hr = spHeader->InsertColumn( 0, T2OLE( _T( "Benefit" ) ), LVCFMT_LEFT, 200 );
	_ASSERTE( SUCCEEDED( hr ) );

	//
	// Add the second column. Use the value of 350 pixels as the size.
	//
	hr = spHeader->InsertColumn( 1, T2OLE( _T( "Description" ) ), LVCFMT_LEFT, 350 );
	_ASSERTE( SUCCEEDED( hr ) );

	return( hr );
}

STDMETHODIMP CRootNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    long handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
	UNUSED_ALWAYS( pUnk );
	HRESULT hr = E_UNEXPECTED; 

	if ( type == CCT_SCOPE || type == CCT_RESULT || type == CCT_SNAPIN_MANAGER )
	{
		bool fStartup;

		//
		// Set the start-up flag based on the type of pages to be
		// created.
		//
		fStartup = type == CCT_SNAPIN_MANAGER ? true : false;

		//
		// Allocate the new page. The second parameter of the constructor
		// indicates whether or not this is the start-up wizard. The dialog
		// handler will update the UI appropriately.
		//
		CEmployeeNamePage* pNamePage = new CEmployeeNamePage( handle, fStartup, false, _T( "Employee Name" ) );
		CEmployeeAddressPage* pAddressPage = new CEmployeeAddressPage( handle, fStartup, false, _T( "Employee Address" ) );

		//
		// Set the page's employee.
		//
		pNamePage->m_pEmployee = &m_Employee;
		pAddressPage->m_pEmployee = &m_Employee;

		lpProvider->AddPage( pNamePage->Create() );
		lpProvider->AddPage( pAddressPage->Create() );

		//
		// The second parameter  to the property page class constructor
		// should be true for only one page.
		//
		hr = S_OK;
	}

	return( hr );
}

//
// Ensures that the appropriate verbs are displayed.
//
STDMETHODIMP CRootNode::OnSelect( IConsole* pConsole )
{
	//
	// Since we display property pages, make sure that the property page
	// verb is enabled.
	//
	CComPtr<IConsoleVerb> spConsoleVerb;
	HRESULT hr = pConsole->QueryConsoleVerb( &spConsoleVerb );

	//
	// Enable the properties verb.
	//
	hr = spConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
	_ASSERTE( SUCCEEDED( hr ) );

	return( hr );
}

//
// Received when a property has changed. This function
// modifies the employee's display text. At a later date,
// it may post this message to its sub-nodes.
//
STDMETHODIMP CRootNode::OnPropertyChange( IConsole* pConsole )
{
	HRESULT hr;
	SCOPEDATAITEM* pScopeData;
	CComQIPtr<IConsoleNameSpace,&IID_IConsoleNameSpace> spNamespace( pConsole );
	TCHAR szNameBuf[ 256 ];

	//
	// For demonstration purposes, always set the modified flag. This
	// could be done more intelligently for real purposes.
	//
	SetModified();

	//
	// Always assume that the name changed. Recreate the display name
	// since this will be called for after SetItem() is called.
	//
	CreateDisplayName( szNameBuf );
	m_bstrDisplayName = szNameBuf;

	//
	// Fill out the scope item structure and set the item.
	// This will cause MMC to call us for the new display
	// text.
	//
	hr = GetScopeData( &pScopeData );

	//
	// Make sure that callback is specified.
	//
	hr = spNamespace->SetItem( pScopeData );

	return( hr );
}

//
// Simply function to create the display name from the
// employee data.
//
int CRootNode::CreateDisplayName( TCHAR* szBuf )
{
	USES_CONVERSION;

	//
	// Create a full display name.
	//
	_tcscpy( szBuf, W2T( m_Employee.m_szLastName ) );
	_tcscat( szBuf, _T( ", " ) );
	_tcscat( szBuf, W2T( m_Employee.m_szFirstName ) );

	return( _tcslen( szBuf ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\snaphelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       snaphelp.h
//
//--------------------------------------------------------------------------

#ifndef _ATLSNAPHELP_H_
#define _ATLSNAPHELP_H_

//
// Include files
//
#include "htmlhelp.h"

//
// Allocates memory for a string, copies the string,
// and returns it to the caller. Throws exceptions.
//
inline LPOLESTR CoTaskDupString( LPOLESTR pszInput )
{
	USES_CONVERSION;
	LPOLESTR pszOut = NULL;

	//
	// We throw an exception if the following allocation fails.
	//
	pszOut = (LPOLESTR) CoTaskMemAlloc( ( wcslen( pszInput ) + 1 ) * sizeof( OLECHAR ) );
	if ( pszOut == NULL )
		throw;

	wcscpy( pszOut, pszInput );

	return( pszOut );
};

template <class T>        
class ATL_NO_VTABLE ISnapinHelpImpl : public ISnapinHelp
{
public:
	//
	// Returns a helpfile name using the ATL module name
	// and appending the appropriate suffix onto the filename.
	//
	STDMETHOD( GetHelpTopic )( LPOLESTR* lpCompiledHelpFile )
	{
		_ASSERT( lpCompiledHelpFile != NULL );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		TCHAR szPath[ _MAX_PATH * 2 ];
		TCHAR szDrive[ _MAX_DRIVE * 2 ], szDir[ _MAX_DIR * 2 ];
		TCHAR szName[ _MAX_FNAME * 2 ], szExt[ _MAX_EXT ];

		try
		{
			//
			// Get the module filename.
			//
			if ( GetModuleFileName( _Module.GetModuleInstance(), szPath, sizeof( szPath ) / sizeof( TCHAR ) ) == NULL )
				throw;

			//
			// Split the given path.
			//
			_tsplitpath( szPath, szDrive, szDir, szName, szExt );
			_tmakepath( szPath, szDrive, szDir, szName, _T( ".chm" ) );

			//
			// Allocate the string and return it.
			*lpCompiledHelpFile = CoTaskDupString( T2W( szPath ) );
			hr = S_OK;
		}
		catch( ... )
		{
		}

		return( hr );
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F9D85C76_DBB8_11D1_8477_00104B211BE5__INCLUDED_)
#define AFX_STDAFX_H__F9D85C76_DBB8_11D1_8477_00104B211BE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//
// Defines used to avoid various build issues.
//
#ifndef UNUSED_ALWAYS
#define UNUSED_ALWAYS( x ) x
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F9D85C76_DBB8_11D1_8477_00104B211BE5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BenSvr.rc
//
#define IDS_PROJNAME                    100
#define IDB_BENEFITS_32                 102
#define IDB_BENEFITS_16                 103
#define IDR_ENROLL_MENU                 103
#define IDR_ACCESS_MENU                 104
#define IDS_BENEFITS_DESC               105
#define IDR_UPDATE_MENU                 105
#define IDS_BENEFITS_PROVIDER           106
#define IDS_BENEFITS_VERSION            107
#define IDR_BENEFITS                    108
#define IDS_RETIREMENT_DESC             110
#define IDS_HEALTH_DESC                 111
#define IDS_KEY_DESC                    112
#define IDR_ENROLLTOOLBAR               201
#define IDC_EDIT_SOCIALSECURITY         201
#define IDD_BUILDINGACCESS_DIALOG       201
#define IDC_EDIT_MOTHERNAME             202
#define IDC_CHK_PRIORCOVERAGE           203
#define IDC_COMBO_BUILDINGS             203
#define IDC_FRAME_PRIORCOVERAGE         204
#define IDC_EDIT_INSURANCECOMPANY       205
#define IDC_EDIT_POLICYNUMBER           206
#define IDD_HEALTHENROLLDIALOG          206
#define IDD_HEALTHENROLL_DIALOG         206
#define IDC_COMBO_BENEFITPLAN           208
#define IDD_RETIREMENTENROLLDIALOG      208
#define IDD_RETIREMENTENROLL_DIALOG     208
#define IDD_BENEFITSPAGE                209
#define IDD_NAME_PAGE                   209
#define IDR_ACCESSTOOLBAR               210
#define IDD_ADDRESS_PAGE                210
#define IDC_SPIN_PERCENTAGE             211
#define IDC_COMBO_INVESTMENTFUNDS       213
#define IDC_EDIT_CONTRIBUTION           214
#define IDC_EDIT_LASTNAME               215
#define IDC_EDIT_FIRSTNAME              216
#define IDC_EDIT_ADDRESSFIRST           217
#define IDC_EDIT_ADDRESSSECOND          218
#define IDC_EDIT_STATE                  219
#define IDC_EDIT_ZIP                    220
#define IDC_EDIT_PHONE                  222
#define IDC_EDIT_CITY                   223
#define ID_TOP_IMPORT                   32768
#define ID_TOP_UPDATE                   32768
#define ID_VIEW_TASKPAD                 32769
#define ID_TASK_ENROLL                  32770
#define ID_TOP_EXPORT                   32775
#define ID_NEW_ENROLL                   32779
#define ID_NEW_BUILDINGACCESS           32785

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        211
#define _APS_NEXT_COMMAND_VALUE         32770
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\dataobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       DataObj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "displ2.h"
#include "DsplMgr2.h"

#define MY_CF_SNAPIN_INTERNAL L"DISPLAY MANAGER SNAPIN"

// global(s)
extern long g_ref_DataObject; // in displ2.cpp
const GUID GUID_RootNode = { /* d59cd090-44d9-11d1-9fd5-00600832db4a */
    0xd59cd090,
    0x44d9,
    0x11d1,
    {0x9f, 0xd5, 0x00, 0x60, 0x08, 0x32, 0xdb, 0x4a}
};
const GUID GUID_WallpaperNode = { /* d59cd091-44d9-11d1-9fd5-00600832db4a */
    0xd59cd091,
    0x44d9,
    0x11d1,
    {0x9f, 0xd5, 0x00, 0x60, 0x08, 0x32, 0xdb, 0x4a}
};
const GUID GUID_PatternNode = { /* d59cd092-44d9-11d1-9fd5-00600832db4a */
    0xd59cd092,
    0x44d9,
    0x11d1,
    {0x9f, 0xd5, 0x00, 0x60, 0x08, 0x32, 0xdb, 0x4a}
};


// statics
UINT CDataObject::s_cfInternal       = 0;
UINT CDataObject::s_cfDisplayName    = 0;
UINT CDataObject::s_cfNodeType       = 0;
UINT CDataObject::s_cfSnapinClsid    = 0;
UINT CDataObject::s_cfSnapinPreloads = 0;

CDataObject::CDataObject(long cookie, DATA_OBJECT_TYPES type)
{
#ifdef DEBUG
   InterlockedIncrement (&g_ref_DataObject);
#endif

   m_ref      = 1;
   m_cookie   = cookie;
   m_type     = type;
   m_bPreload = FALSE;

   USES_CONVERSION;
   s_cfInternal       = RegisterClipboardFormat (W2T(MY_CF_SNAPIN_INTERNAL));
   s_cfDisplayName    = RegisterClipboardFormat (W2T(CCF_DISPLAY_NAME));
   s_cfNodeType       = RegisterClipboardFormat (W2T(CCF_NODETYPE));
   s_cfSnapinClsid    = RegisterClipboardFormat (W2T(CCF_SNAPIN_CLASSID));
   s_cfSnapinPreloads = RegisterClipboardFormat (W2T(CCF_SNAPIN_PRELOADS));
}
CDataObject::~CDataObject ()
{
#ifdef DEBUG
   InterlockedDecrement (&g_ref_DataObject);
#endif
}

HRESULT CDataObject::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
   if (ppvObj == NULL)
      return E_INVALIDARG;

   if ( (riid == IID_IUnknown)    ||
        (riid == IID_IDataObject) ){
      // I know about these two interfaces, only.
      *ppvObj = (void *)this;
   } else {
      *ppvObj = NULL;
      return E_NOINTERFACE;
   }
   AddRef();
   return S_OK;
}
ULONG CDataObject::AddRef ()
{
   return InterlockedIncrement ((LONG *) &m_ref);
}
ULONG CDataObject::Release ()
{
   InterlockedDecrement ((LONG *)&m_ref);
   if (m_ref == 0) {
      delete this;
      return 0;
   }
   return m_ref;
}

HRESULT CDataObject::GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    IStream * pstm = NULL;
    HRESULT hresult = CreateStreamOnHGlobal (pmedium->hGlobal, FALSE, &pstm);
    if (pstm) {
        _ASSERT (hresult == S_OK);

        const CLIPFORMAT cf = pformatetc->cfFormat;

        if (cf == s_cfDisplayName) {
            LPWSTR pszName = L"Display Manager (Version 2)";
            hresult = pstm->Write (pszName, sizeof(WCHAR)*(1+wcslen (pszName)), NULL);
        } else
        if (cf == s_cfInternal) {
            CDataObject * pThis = this;
            hresult = pstm->Write (pThis, sizeof(CDataObject *), NULL);
        } else
        if (cf == s_cfNodeType) {
            const GUID * pguid;
            if (m_cookie == DISPLAY_MANAGER_WALLPAPER)
                pguid = &GUID_WallpaperNode;
            else if (m_cookie == DISPLAY_MANAGER_PATTERN)
                pguid = &GUID_PatternNode;
            else if (m_cookie == DISPLAY_MANAGER_PATTERN_CHILD)
                pguid = &GUID_RootNode;
            else if (m_cookie == 0)
                pguid = &GUID_RootNode;
            else {
                // anything else must be result-side stuff:
                pguid = &GUID_WallpaperNode;
            }
            hresult = pstm->Write ((PVOID)pguid, sizeof(GUID), NULL);
        } else
        if (cf == s_cfSnapinClsid) {
            hresult = pstm->Write (&CLSID_DsplMgr2, sizeof(CLSID_DsplMgr2), NULL);
        } else
        if (cf == s_cfSnapinPreloads) {
            hresult = pstm->Write ((PVOID)&m_bPreload, sizeof(BOOL), NULL);
        } else {
            hresult = DV_E_FORMATETC;
            // Might as well assert, since we should not have any other
            // clipboard formats at this time.
            _ASSERT(hresult == S_OK);
        }
        pstm->Release();
    }
    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\displ2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       displ2.h
//
//--------------------------------------------------------------------------

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Jan 12 12:51:27 1998
 */
/* Compiler settings for displ2.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __displ2_h__
#define __displ2_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __DsplMgr2_FWD_DEFINED__
#define __DsplMgr2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DsplMgr2 DsplMgr2;
#else
typedef struct DsplMgr2 DsplMgr2;
#endif /* __cplusplus */

#endif 	/* __DsplMgr2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mmc.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __DISPL2Lib_LIBRARY_DEFINED__
#define __DISPL2Lib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DISPL2Lib
 * at Mon Jan 12 12:51:27 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_DISPL2Lib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DsplMgr2;

class DECLSPEC_UUID("885B3BAE-43F9-11D1-9FD4-00600832DB4A")
DsplMgr2;
#endif
#endif /* __DISPL2Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\dsplcomp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       DsplComp.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "displ2.h"
#include "DsplMgr2.h"

// local proto
HRESULT ApplyOption (int nCommandID);

extern HINSTANCE g_hinst;  // in displ2.cpp
HSCOPEITEM g_root_scope_item = 0;

CComponent::CComponent()
{
    m_pResultData    = NULL;
    m_pHeaderCtrl    = NULL;
    m_pComponentData = NULL;   // the guy who created me

    m_IsTaskPad      = 0;      // TODO: should get this from the persisted data
    m_pConsole       = NULL;
    m_TaskPadCount   = 0;
    m_toggle         = FALSE;
    m_toggleEntry    = FALSE;
}

CComponent::~CComponent()
{
    _ASSERT (m_pResultData == NULL);
    _ASSERT (m_pHeaderCtrl == NULL);
}

HRESULT CComponent::Initialize (LPCONSOLE lpConsole)
{
    _ASSERT(lpConsole != NULL);
    _ASSERT (m_pResultData == NULL); // should be called only once...
    _ASSERT (m_pHeaderCtrl == NULL); // should be called only once...

    m_pConsole = lpConsole; // hang onto this

    HRESULT hresult = lpConsole->QueryInterface(IID_IResultData, (VOID**)&m_pResultData);
    _ASSERT (m_pResultData != NULL);

    hresult = lpConsole->QueryInterface(IID_IHeaderCtrl, (VOID**)&m_pHeaderCtrl);
    _ASSERT (m_pHeaderCtrl != NULL);

    if (m_pHeaderCtrl)   // Give the console the header control interface pointer
        lpConsole->SetHeader(m_pHeaderCtrl);

#ifdef TODO_ADD_THIS_LATER
    hr = lpConsole->QueryResultImageList(&m_pImageResult);
    _ASSERT(hr == S_OK);

    hr = lpConsole->QueryConsoleVerb(&m_pConsoleVerb);
    _ASSERT(hr == S_OK);

    // Load the bitmaps from the dll for the results pane
    m_hbmp16x16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_RESULT_16x16));
    _ASSERT(m_hbmp16x16);
    m_hbmp32x32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_RESULT_32x32));
    _ASSERT(m_hbmp32x32);
#endif

    return hresult;
}
HRESULT CComponent::Destroy (long cookie)
{
    if (m_pResultData)
    {
        m_pResultData->Release ();
        m_pResultData = NULL;
    }
    if (m_pHeaderCtrl)
    {
        m_pHeaderCtrl->Release ();
        m_pHeaderCtrl = NULL;
    }
    // hmmm... I wonder if I have to release my IConsole pointer?  it doesn't look like it....
    return S_OK;
}
HRESULT CComponent::Notify (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    switch (event)
    {
    case MMCN_SHOW:         return OnShow      (lpDataObject, arg, param);
    case MMCN_ADD_IMAGES:   return OnAddImages (lpDataObject, arg, param);
    case MMCN_DBLCLICK:     return OnDblClick  (lpDataObject, arg, param);
    case MMCN_SELECT:    // return OnSelect    (lpDataObject, arg, param);
        break;
    case MMCN_REFRESH:   // return OnRefresh   (lpDataObject, arg, param);
    case MMCN_VIEW_CHANGE:
    case MMCN_CLICK:
    case MMCN_BTN_CLICK:
    case MMCN_ACTIVATE:
    case MMCN_MINIMIZED:
        break;
    case MMCN_LISTPAD:      return OnListPad     (lpDataObject, arg, param);
    case MMCN_RESTORE_VIEW: return OnRestoreView (lpDataObject, arg, param);
    default:
        return E_UNEXPECTED;
    }
    return S_OK;
}
HRESULT CComponent::GetResultViewType (long cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;

    // only allow taskpad when root is selected
    if (cookie != 0)
        m_IsTaskPad = 0;

    // special case for taskpads only
    if (m_IsTaskPad != 0)
    {
        USES_CONVERSION;

        TCHAR szBuffer[MAX_PATH*2]; // a little extra
        lstrcpy (szBuffer, _T("res://"));
        TCHAR * temp = szBuffer + lstrlen(szBuffer);
        switch (m_IsTaskPad)
        {
        case IDM_CUSTOMPAD:
            // get "res://"-type string for custom taskpad
            ::GetModuleFileName (g_hinst, temp, MAX_PATH);
            lstrcat (szBuffer, _T("/default.htm"));
            break;
        case IDM_TASKPAD:
            // get "res://"-type string for custom taskpad
            ::GetModuleFileName (NULL, temp, MAX_PATH);
            lstrcat (szBuffer, _T("/default.htm"));
            break;
        case IDM_TASKPAD_WALLPAPER_OPTIONS:
            // get "res://"-type string for custom taskpad
            ::GetModuleFileName (NULL, temp, MAX_PATH);
            lstrcat (szBuffer, _T("/default.htm#wallpaper_options"));
            break;

        case IDM_TASKPAD_LISTVIEW:
            // get "res://"-type string for custom taskpad
//         ::GetModuleFileName (g_hinst, temp, MAX_PATH);
//         lstrcat (szBuffer, _T("/listview.htm"));
            ::GetModuleFileName (NULL, temp, MAX_PATH);
            lstrcat (szBuffer, _T("/horizontal.htm"));
            break;

        case IDM_DEFAULT_LISTVIEW:
            // get "res://"-type string for custom taskpad
            ::GetModuleFileName (NULL, temp, MAX_PATH);
            lstrcat (szBuffer, _T("/listpad.htm"));
            break;

        default:
            _ASSERT (0);
            return S_FALSE;
        }

        // return URL
        *ppViewType = CoTaskDupString (T2OLE(szBuffer));
        if (!*ppViewType)
            return E_OUTOFMEMORY;   // or S_FALSE ???
        return S_OK;
    }
    return S_FALSE;   // false for default
}
HRESULT CComponent::QueryDataObject (long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    _ASSERT (ppDataObject != NULL);
    CDataObject *pdo = new CDataObject (cookie, type);
    *ppDataObject = pdo;
    if (!pdo)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CComponent::GetDisplayInfo (RESULTDATAITEM*  prdi)
{
    _ASSERT(prdi != NULL);

    if (prdi)
    {
        // Provide strings for scope tree items
        if (prdi->bScopeItem == TRUE)
        {
            if (prdi->mask & RDI_STR)
            {
                if (prdi->nCol == 0)
                {
                    switch (prdi->lParam)
                    {
                    case DISPLAY_MANAGER_WALLPAPER:
                        if (m_toggle == FALSE)
                            prdi->str = (LPOLESTR)L"Wallpaper";
                        else
                            prdi->str = (LPOLESTR)L"RenamedWallpaper";
                        break;
                    case DISPLAY_MANAGER_PATTERN:
                        prdi->str = (LPOLESTR)L"Pattern";
                        break;
                    case DISPLAY_MANAGER_PATTERN_CHILD:
                        prdi->str = (LPOLESTR)L"Pattern child";
                        break;
                    default:
                        prdi->str = (LPOLESTR)L"Hey! You shouldn't see this!";
                        break;
                    }
                }
                else if (prdi->nCol == 1)
                    prdi->str = (LPOLESTR)L"Display Option";
                else
                    prdi->str = (LPOLESTR)L"Error:Should not see this!";
            }
            if (prdi->mask & RDI_IMAGE)
                prdi->nImage = 0;
        }
        else
        {
            // listpad uses lparam on -1, anything else is wallpaper
            if (prdi->lParam == -1)
            {
                if (prdi->mask & RDI_STR)
                    if (m_toggleEntry == FALSE)
                        prdi->str = (LPOLESTR)L"here's a listpad entry";
                    else
                        prdi->str = (LPOLESTR)L"Changed listpad entry";
                if (prdi->mask & RDI_IMAGE)
                    prdi->nImage = 0;
            }
            else
            {
                lParamWallpaper * lpwp = NULL;
                if (prdi->lParam)
                    lpwp = (lParamWallpaper *)prdi->lParam;

                if (prdi->mask & RDI_STR)
                {
                    if (prdi->nCol == 0)
                    {
                        if (lpwp && (!IsBadReadPtr (lpwp, sizeof (lParamWallpaper))))
                            prdi->str = lpwp->filename;
                        else
                            prdi->str = (LPOLESTR)L"hmm.... error";
                    }
                    else if (prdi->nCol == 1)
                        prdi->str = (LPOLESTR)L"result pane display name col 1";
                    else
                        prdi->str = (LPOLESTR)L"Error:Should not see this!";
                }
                if (prdi->mask & RDI_IMAGE)
                {
                    switch (prdi->lParam)
                    {
                    case DISPLAY_MANAGER_WALLPAPER:
                    case DISPLAY_MANAGER_PATTERN:
                    case DISPLAY_MANAGER_PATTERN_CHILD:
                        prdi->nImage = 0; 
                        break;
                    default:
                        prdi->nImage = 3; 
                        break;
                    }
                }
            }
        }       
    }
    return S_OK;
}
HRESULT CComponent::CompareObjects (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{  return E_NOTIMPL;}

// private functions
HRESULT CComponent::OnShow(LPDATAOBJECT pDataObject, long arg, long param)
{
    USES_CONVERSION;

    CDataObject * pcdo = (CDataObject *)pDataObject;

    if (arg == 0)
    {  // de-selecting:  free up resources, if any
        if (pcdo->GetCookie() == DISPLAY_MANAGER_WALLPAPER)
        {
            // enumerate result data items
            RESULTDATAITEM rdi;
            ZeroMemory(&rdi, sizeof(rdi));
            rdi.mask = RDI_PARAM | RDI_STATE;
            rdi.nIndex = -1;

            while (1)
            {
                if (m_pResultData->GetNextItem (&rdi) != S_OK)
                    break;
                if (rdi.lParam)
                {
                    lParamWallpaper * lpwp = (lParamWallpaper *)rdi.lParam;
                    delete lpwp;
                }
            }
            m_pResultData->DeleteAllRsltItems ();
        }
        return S_OK;
    }

    // init column headers
    _ASSERT (m_pHeaderCtrl != NULL);
    m_pHeaderCtrl->InsertColumn (0, L"Name", 0, 120);

    if (m_pComponentData)
    {
        if (m_pResultData)    // use large icons by default
            m_pResultData->SetViewMode (m_pComponentData->GetViewMode ());
    }

    // add our stuff
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask   = RDI_PARAM | RDI_STR | RDI_IMAGE;
    rdi.nImage = (int)MMC_CALLBACK;
    rdi.str    = MMC_CALLBACK;

    if (pcdo->GetCookie () == DISPLAY_MANAGER_WALLPAPER)
    {
        // enumerate all .bmp files in "c:\winnt.40\" (windows directory)
        TCHAR path[MAX_PATH];
        GetWindowsDirectory (path, MAX_PATH);
        lstrcat (path, _T("\\*.bmp"));

        int i = 0;

        // first do "(none)"
        lParamWallpaper * lpwp = new lParamWallpaper;
        wcscpy (lpwp->filename, L"(none)");
        rdi.lParam = reinterpret_cast<LONG>(lpwp);
        rdi.nImage = i++;

        m_pResultData->InsertItem (&rdi);

        WIN32_FIND_DATA fd;
        ZeroMemory(&fd, sizeof(fd));
        HANDLE hFind = FindFirstFile (path, &fd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                    (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)    ||
                    (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)    )
                    continue;   // files only

                // new a struct to hold info, and cast to lParam.
                lParamWallpaper * lpwp = new lParamWallpaper;
                wcscpy (lpwp->filename, T2OLE(fd.cFileName));

//            rdi.str    = lpwp->filename;
                rdi.lParam = reinterpret_cast<LONG>(lpwp);
                rdi.nImage = i++;

                m_pResultData->InsertItem (&rdi);

            } while (FindNextFile (hFind, &fd) == TRUE);
            FindClose(hFind);
        }
    }
    else
    {
        // DISPLAY_MANAGER_PATTERN
        ;  // hard code a few things.
    }
    return S_OK;
}

#include <windowsx.h>
inline long LongScanBytes (long bits)
{
    bits += 31;
    bits /= 8;
    bits &= ~3;
    return bits;
}
void GetBitmaps (TCHAR * fn, HBITMAP * smallbm, HBITMAP * largebm)
{
    *smallbm = *largebm = (HBITMAP)NULL; // in case of error

    // read bmp file into DIB
    DWORD dwRead;
    HANDLE hf = CreateFile (fn, GENERIC_READ, 
                            FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES) NULL, 
                            OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, 
                            (HANDLE) NULL);
    if (hf != (HANDLE)HFILE_ERROR)
    {
        BITMAPFILEHEADER bmfh;
        ReadFile(hf, &bmfh, sizeof(BITMAPFILEHEADER), &dwRead, (LPOVERLAPPED)NULL); 
        BITMAPINFOHEADER bmih;
        ReadFile(hf, &bmih, sizeof(BITMAPINFOHEADER), &dwRead, (LPOVERLAPPED)NULL); 

        // Allocate memory for the DIB
        DWORD dwSize = sizeof(BITMAPINFOHEADER);
        if (bmih.biBitCount*bmih.biPlanes <= 8)
            dwSize += (sizeof(RGBQUAD))*(1<<(bmih.biBitCount*bmih.biPlanes));
        dwSize += bmih.biHeight*LongScanBytes (bmih.biWidth*(bmih.biBitCount*bmih.biPlanes));

        BITMAPINFOHEADER * lpbmih = (BITMAPINFOHEADER *)GlobalAllocPtr(GHND, dwSize);
        if (lpbmih)
        {
            *lpbmih = bmih;

            RGBQUAD * rgbq = (RGBQUAD *)&lpbmih[1];
            char * bits = (char *)rgbq;
            if (bmih.biBitCount*bmih.biPlanes <= 8)
            {
                ReadFile (hf, rgbq,
                          ((1<<(bmih.biBitCount*bmih.biPlanes))*sizeof(RGBQUAD)), 
                          &dwRead, (LPOVERLAPPED) NULL);
                bits += dwRead;
            }
            SetFilePointer (hf, bmfh.bfOffBits, NULL, FILE_BEGIN);
            ReadFile (hf, bits, dwSize - (bits - (char *)lpbmih),
                      &dwRead, (LPOVERLAPPED) NULL);
            // we should now have a decent DIB

            HWND hwnd   = GetDesktopWindow ();
            HDC hdc     = GetDC (hwnd);
            HDC hcompdc = CreateCompatibleDC (hdc);
//       SetStretchBltMode (hcompdc, COLORONCOLOR);
//       SetStretchBltMode (hcompdc, WHITEONBLACK);
            SetStretchBltMode (hcompdc, HALFTONE);

            HGDIOBJ hold;

//       *smallbm = CreateCompatibleBitmap (hcompdc, 16, 16);
            *smallbm = CreateCompatibleBitmap (hdc,     16, 16);
            if (*smallbm)
            {
                hold = SelectObject (hcompdc, (HGDIOBJ)(*smallbm));
                StretchDIBits (hcompdc, // handle of device context 
                               0, 0, 16, 16,
                               0, 0, 
                               lpbmih->biWidth,
                               lpbmih->biHeight,
                               (CONST VOID *)bits,
                               (CONST BITMAPINFO *)lpbmih,
                               DIB_RGB_COLORS, // usage 
                               SRCCOPY // raster operation code
                              );
                SelectObject (hcompdc, hold);
            }
//       *largebm = CreateCompatibleBitmap (hcompdc, 32, 32);
            *largebm = CreateCompatibleBitmap (hdc,     32, 32);
            if (*largebm)
            {
// testing
/*
              HDC nullDC = GetDC (NULL);
              hold = SelectObject (nullDC, (HGDIOBJ)*largebm);
              StretchDIBits (nullDC, // handle of device context 
                             0, 0, lpbmih->biWidth, lpbmih->biHeight,
                             0, 0, 
                             lpbmih->biWidth,
                             lpbmih->biHeight,
                             (CONST VOID *)bits,
                             (CONST BITMAPINFO *)lpbmih,
                             DIB_RGB_COLORS, // usage 
                             SRCCOPY // raster operation code
                             );
               SelectObject (hdc, hold);
              ReleaseDC (NULL, nullDC);
*/
// testing

                hold = SelectObject (hcompdc, (HGDIOBJ)*largebm);
                StretchDIBits (hcompdc, // handle of device context 
                               0, 0, 32, 32,
                               0, 0, 
                               lpbmih->biWidth,
                               lpbmih->biHeight,
                               (CONST VOID *)bits,
                               (CONST BITMAPINFO *)lpbmih,
                               DIB_RGB_COLORS, // usage 
                               SRCCOPY // raster operation code
                              );
                SelectObject (hcompdc, hold);
            }

            DeleteDC (hcompdc);
            ReleaseDC (hwnd, hdc);
            GlobalFreePtr (lpbmih);
        }
        CloseHandle(hf); 
    }
}
HRESULT CComponent::OnAddImages (LPDATAOBJECT pDataObject, long arg, long param)
{
    IImageList * pImageList = (IImageList *)arg;
    HSCOPEITEM hsi = (HSCOPEITEM)param;

    _ASSERT (pImageList != NULL);

    CDataObject * cdo = (CDataObject *)pDataObject;
    if (cdo->GetCookie () != DISPLAY_MANAGER_WALLPAPER)
    {
        if (cdo->GetCookie () == 0)
        {
            g_root_scope_item = hsi;
            if (cdo->GetType () == CCT_RESULT)
            {
                // add a custom image
                HBITMAP hbmSmall, hbmLarge;
                GetBitmaps (_T("c:\\winnt\\dax.bmp"), &hbmSmall, &hbmLarge);
                pImageList->ImageListSetStrip ((long *)hbmSmall,
                                               (long *)hbmLarge,
                                               3, RGB(1, 0, 254));
                DeleteObject (hbmSmall);
                DeleteObject (hbmLarge);
            }
        }
        return S_OK;   // TODO: for now
    }

    // create HBITMAPs from bmp files
    int i = 0;

    // create some invisible bitmaps
    {
        BYTE bits[] = {
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};

        HBITMAP hbmSmall = CreateBitmap (16, 16, 1, 1, (CONST VOID *)bits);
        HBITMAP hbmLarge = CreateBitmap (32, 32, 1, 1, (CONST VOID *)bits);
        pImageList->ImageListSetStrip ((long *)hbmSmall,
                                       (long *)hbmLarge,
                                       i++, RGB(1, 0, 254));
        DeleteObject (hbmSmall);
        DeleteObject (hbmLarge);
    }

    TCHAR path[MAX_PATH];
    GetWindowsDirectory (path, MAX_PATH);
    TCHAR * pfqfn = path + lstrlen(path) + 1;
    lstrcat (path, _T("\\*.bmp"));

    WIN32_FIND_DATA fd;
    ZeroMemory(&fd, sizeof(fd));
    HANDLE hFind = FindFirstFile (path, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)    ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)    )
                continue;   // files only

            lstrcpy (pfqfn, fd.cFileName);

            HBITMAP hbmSmall, hbmLarge;
            GetBitmaps (path, &hbmSmall, &hbmLarge);
            pImageList->ImageListSetStrip ((long *)hbmSmall,
                                           (long *)hbmLarge,
                                           i++, RGB(1, 0, 254));
            DeleteObject (hbmSmall);
            DeleteObject (hbmLarge);
        }  while (FindNextFile (hFind, &fd) == TRUE);
        FindClose(hFind);
    }
    return S_OK;
}

#ifdef TODO_FIGURE_THIS_OUT
HRESULT CComponent::OnSelect(LPDATAOBJECT pDataObject, long arg, long param)
{
    if (!HIWORD(arg)) // being de-selected
        return S_OK;   // don't care about this
    if (LOWORD(arg))  // in scope pane
        return S_OK;   // don't care about this, either

    CDataObject *cdo = (CDataObject *)pDataObject;
    if (cdo->GetCookie() != DISPLAY_MANAGER_WALLPAPER)
        return S_OK;   // TODO:  do patterns later

    //
    // Bail if we couldn't get the console verb interface, or if the
    // selected item is the root;
    //

    if (!m_pConsoleVerb || pdo->GetCookieType() == COOKIE_IS_ROOT)
    {
        return S_OK;
    }

    //
    // Use selections and set which verbs are allowed
    //

    if (bScope)
    {
        if (pdo->GetCookieType() == COOKIE_IS_STATUS)
        {
            hr = m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
            _ASSERT(hr == S_OK);
        }
    }
    else
    {
        //
        // Selection is in the result pane
        //
    }

    return S_OK;
}
#endif

HRESULT CComponent::OnDblClick(LPDATAOBJECT pDataObject, long arg, long param)
{//see note in CComponent::Command, below !!!

    _ASSERT (pDataObject);
    _ASSERT (m_pResultData);

    // hmmm:  no documentation on arg or param....
    CDataObject *cdo = (CDataObject *)pDataObject;
    lParamWallpaper * lpwp = (lParamWallpaper *)cdo->GetCookie();
    if (lpwp)
        if (!IsBadReadPtr (lpwp, sizeof (lParamWallpaper)))
        {
            USES_CONVERSION;
            SystemParametersInfo (SPI_SETDESKWALLPAPER,
                                  0,
                                  (void *)OLE2T(lpwp->filename),
                                  SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
        }
    return S_OK;
}

HRESULT CComponent::OnListPad (LPDATAOBJECT pDataObject, long arg, long param)
{
    if (arg == TRUE)
    {  // attaching
        IImageList* pImageList = NULL;
        m_pConsole->QueryResultImageList (&pImageList);
        if (pImageList)
        {
            HBITMAP hbmSmall, hbmLarge;
            GetBitmaps (_T("c:\\winnt\\dax.bmp"), &hbmSmall, &hbmLarge);
            pImageList->ImageListSetStrip ((long *)hbmSmall,
                                           (long *)hbmLarge,
                                           0, RGB(1, 0, 254));
            pImageList->Release();
        }

//      m_pResultData->SetViewMode (LVS_ICON);
        m_pResultData->SetViewMode (LVS_REPORT);
        m_pHeaderCtrl->InsertColumn (0, L"Name", 0, 170);

        // populate listview control via IResultData
        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));
        rdi.mask   = RDI_PARAM | RDI_STR | RDI_IMAGE;
        rdi.nImage = (int)MMC_CALLBACK;
        rdi.str    = MMC_CALLBACK;
        rdi.lParam = -1;
        for (int i=0; i<11; i++)
            m_pResultData->InsertItem (&rdi);
    }
    return S_OK;
}
HRESULT CComponent::OnRestoreView (LPDATAOBJECT pDataObject, long arg, long param)
{
    MMC_RESTORE_VIEW* pmrv = (MMC_RESTORE_VIEW*)arg;
    BOOL            * pb   = (BOOL *)param;

    _ASSERT (pmrv);
    _ASSERT (pb);

    // some versioning (not really necessary since this is the new rev.)
    if (pmrv->dwSize < sizeof(MMC_RESTORE_VIEW))
        return E_FAIL;  // version too old

    // maintain my internal state
    if (pmrv->pViewType)
    {

        USES_CONVERSION;

        // there are going to be two cases:
        // 1. custom html pages  (res in my .dll)
        // 2. default html pages (res in mmc.exe)
        // get path to my .dll and compare to pViewType
        TCHAR szPath[MAX_PATH];
        ::GetModuleFileName (g_hinst, szPath, MAX_PATH);

        if (wcsstr (pmrv->pViewType, T2OLE(szPath)))
        {
            // custom html
            if (wcsstr (pmrv->pViewType, L"/default.htm"))
                m_IsTaskPad = IDM_CUSTOMPAD;
            else
                if (wcsstr (pmrv->pViewType, L"/listview.htm"))
                m_IsTaskPad = IDM_TASKPAD_LISTVIEW;
            else
            {
                // this will happen when you can get to a taskpad by clicking
                // on a task, but there is no corresponding view menu option
                // to select.  Therefore do something reasonable.
                // In my case, I can get to "wallpapr.htm" by either custom
                // or default routes (which is probably rather unusual). So,
                // I think I'll just leave the m_IsTaskPad value alone if
                // it's non-NULL, else pick one.
                if (m_IsTaskPad == 0)
                    m_IsTaskPad = IDM_TASKPAD;
            }
        }
        else
        {
            // default html
            if (wcsstr (pmrv->pViewType, L"/default.htm#wallpaper_options"))
                m_IsTaskPad = IDM_TASKPAD_WALLPAPER_OPTIONS;
            else
                if (wcsstr (pmrv->pViewType, L"/default.htm"))
                m_IsTaskPad = IDM_TASKPAD;
            else
                if (wcsstr (pmrv->pViewType, L"/listpad.htm"))
                m_IsTaskPad = IDM_DEFAULT_LISTVIEW;
            else
                if (wcsstr (pmrv->pViewType, L"/horizontal.htm"))
                m_IsTaskPad = IDM_TASKPAD_LISTVIEW;
            else
            {
                _ASSERT (0 && "can't find MMC's resources");
                return E_FAIL;
            }
        }
    }
    else
        m_IsTaskPad = 0;

    *pb = TRUE; // I'm handling the new history notify
    return S_OK;
}

// IExtendContextMenu
HRESULT CComponent::AddMenuItems (LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long *pInsertionAllowed)
{
    CDataObject * cdo = (CDataObject *)pDataObject;

    switch (cdo->GetCookie ())
    {
    case DISPLAY_MANAGER_WALLPAPER:
    case DISPLAY_MANAGER_PATTERN:
        return S_OK;

    case 0:  // root
        // this is when they pull down the view menu
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
        {
            // add my taskpads and delete thingy
            CONTEXTMENUITEM m[] = {
                {L"Custom TaskPad",     L"Custom TaskPad",  IDM_CUSTOMPAD,      CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"Default TaskPad",    L"Default TaskPad", IDM_TASKPAD,        CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"Wallpaper Options TaskPad", L"Wallpaper Options TaskPad", IDM_TASKPAD_WALLPAPER_OPTIONS, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"Horizontal ListView",  L"ListView TaskPad", IDM_TASKPAD_LISTVIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"Default ListPad",   L"Default ListPad",  IDM_DEFAULT_LISTVIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"DeleteRootChildren", L"just testing",    IDM_DELETECHILDREN, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"RenameRoot",         L"just testing",    IDM_RENAMEROOT,     CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"RenameWallPaperNode",L"just testing",    IDM_RENAMEWALL,     CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"ChangeIcon",         L"just testing",    IDM_CHANGEICON,     CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"Pre-Load",           L"just testing",    IDM_PRELOAD,        CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0},
                {L"Test IConsoleVerb",  L"just testing",    IDM_CONSOLEVERB,    CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0}

            };
            if (m_IsTaskPad == IDM_CUSTOMPAD)                 m[0].fFlags = MF_CHECKED;
            if (m_IsTaskPad == IDM_TASKPAD)                   m[1].fFlags = MF_CHECKED;
            if (m_IsTaskPad == IDM_TASKPAD_WALLPAPER_OPTIONS) m[2].fFlags = MF_CHECKED;
            if (m_IsTaskPad == IDM_TASKPAD_LISTVIEW)          m[3].fFlags = MF_CHECKED;
            if (m_IsTaskPad == IDM_DEFAULT_LISTVIEW)          m[4].fFlags = MF_CHECKED;
            if (m_pComponentData->GetPreload() == TRUE)       m[9].fFlags = MF_CHECKED;

            pContextMenuCallback->AddItem (&m[0]);
            pContextMenuCallback->AddItem (&m[1]);
            pContextMenuCallback->AddItem (&m[2]);
            pContextMenuCallback->AddItem (&m[3]);
            pContextMenuCallback->AddItem (&m[4]);
            pContextMenuCallback->AddItem (&m[5]);
            pContextMenuCallback->AddItem (&m[6]);
            pContextMenuCallback->AddItem (&m[7]);
            pContextMenuCallback->AddItem (&m[8]);
            pContextMenuCallback->AddItem (&m[9]);
            return pContextMenuCallback->AddItem (&m[10]);
        }
        return S_OK;
    default:
        break;
    }

    // add to context menu, only if in result pane:
    // this is when they right-click on the result pane.
    if (cdo->GetType() == CCT_RESULT)
    {
        CONTEXTMENUITEM cmi;
        cmi.strName           = L"Center";
        cmi.strStatusBarText  = L"Center Desktop Wallpaper";
        cmi.lCommandID        = IDM_CENTER;
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        cmi.fFlags            = 0;
        cmi.fSpecialFlags     = CCM_SPECIAL_DEFAULT_ITEM;
        pContextMenuCallback->AddItem (&cmi);

        cmi.strName           = L"Tile";
        cmi.strStatusBarText  = L"Tile Desktop Wallpaper";
        cmi.lCommandID        = IDM_TILE;
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        cmi.fFlags            = 0;
        cmi.fSpecialFlags     = 0;   // CCM_SPECIAL_DEFAULT_ITEM;
        pContextMenuCallback->AddItem (&cmi);

        cmi.strName           = L"Stretch";
        cmi.strStatusBarText  = L"Stretch Desktop Wallpaper";
        cmi.lCommandID        = IDM_STRETCH;
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        cmi.fFlags            = 0;
        cmi.fSpecialFlags     = 0;   // CCM_SPECIAL_DEFAULT_ITEM;
        pContextMenuCallback->AddItem (&cmi);
    }
    return S_OK;
}
HRESULT CComponent::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
    m_IsTaskPad = 0;

    CDataObject * cdo = reinterpret_cast<CDataObject *>(pDataObject);

    switch (nCommandID)
    {
    case IDM_TILE:
    case IDM_CENTER:
    case IDM_STRETCH:
        // write registry key:
        {
            HKEY hkey;
            HRESULT r = RegOpenKeyEx (HKEY_CURRENT_USER,
                                      _T("Control Panel\\Desktop"), 
                                      0, KEY_ALL_ACCESS, &hkey);
            if (r == ERROR_SUCCESS)
            {
                // write new value(s)

                DWORD dwType = REG_SZ;
                TCHAR szBuffer[2];

                // first do "TileWallpaper"
                if (nCommandID == IDM_TILE)
                    lstrcpy (szBuffer, _T("1"));
                else
                    lstrcpy (szBuffer, _T("0"));

                DWORD dwCount = sizeof(TCHAR)*(1+lstrlen (szBuffer));
                r = RegSetValueEx (hkey, 
                                   (LPCTSTR)_T("TileWallpaper"),
                                   NULL,
                                   dwType,
                                   (CONST BYTE *)&szBuffer,
                                   dwCount);

                // then do "WallpaperStyle"
                if (nCommandID == IDM_STRETCH)
                    lstrcpy (szBuffer, _T("2"));
                else
                    lstrcpy (szBuffer, _T("0"));
                r = RegSetValueEx (hkey, 
                                   (LPCTSTR)_T("WallpaperStyle"),
                                   NULL,
                                   dwType,
                                   (CONST BYTE *)&szBuffer,
                                   dwCount);

                // close up shop
                RegCloseKey(hkey);
                _ASSERT(r == ERROR_SUCCESS);

                /*
                [HKEY_CURRENT_USER\Control Panel\Desktop]
                "CoolSwitch"="1"
                "CoolSwitchRows"="3"
                "CoolSwitchColumns"="7"
                "CursorBlinkRate"="530"
                "ScreenSaveTimeOut"="900"
                "ScreenSaveActive"="0"
                "ScreenSaverIsSecure"="0"
                "Pattern"="(None)"
                "Wallpaper"="C:\\WINNT\\dax.bmp"
                "TileWallpaper"="0"
                "GridGranularity"="0"
                "IconSpacing"="75"
                "IconTitleWrap"="1"
                "IconTitleFaceName"="MS Sans Serif"
                "IconTitleSize"="9"
                "IconTitleStyle"="0"
                "DragFullWindows"="1"
                "HungAppTimeout"="5000"
                "WaitToKillAppTimeout"="20000"
                "AutoEndTasks"="0"
                "FontSmoothing"="0"
                "MenuShowDelay"="400"
                "DragHeight"="2"
                "DragWidth"="2"
                "WheelScrollLines"="3"
                "WallpaperStyle"="0"
                */
            }
        }
        break;

    case IDM_TASKPAD:
    case IDM_CUSTOMPAD:
    case IDM_TASKPAD_LISTVIEW:
    case IDM_DEFAULT_LISTVIEW:
    case IDM_TASKPAD_WALLPAPER_OPTIONS:
        if (cdo->GetCookie() == 0)
        {
            HSCOPEITEM root = m_pComponentData->GetRoot();
            if (root)
            {
                // we should now be ready for taskpad "view"
                m_IsTaskPad = nCommandID;  // set before selecting node

                // cause new view to be "created"
                m_pConsole->SelectScopeItem (root);
            }
        }
        return S_OK;

    case IDM_DELETECHILDREN:
        if (g_root_scope_item != 0)
            m_pComponentData->myDeleteItem (g_root_scope_item, TRUE);
        return S_OK;

    case IDM_RENAMEROOT:
        if (g_root_scope_item != 0)
            m_pComponentData->myRenameItem (g_root_scope_item, L"Yippee!");
        return S_OK;

    case IDM_RENAMEWALL:
        if (m_toggle)
            m_toggle = FALSE;
        else
            m_toggle = TRUE;
        m_pComponentData->myRenameItem (m_pComponentData->GetWallPaperNode(), NULL);
        return S_OK;

    case IDM_CHANGEICON:
        m_pComponentData->myChangeIcon ();
        return S_OK;

    case IDM_PRELOAD:
        m_pComponentData->myPreLoad();
        return S_OK;

    case IDM_CONSOLEVERB:
        TestConsoleVerb();
        return S_OK;

    default:
        return E_UNEXPECTED;
    }
    return OnDblClick (pDataObject, NULL, NULL); // note what I'm passing!
}

long CComponent::GetViewMode ()
{
    long vm = LVS_ICON;
    if (m_pResultData)
        m_pResultData->GetViewMode (&vm);
    return vm;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendTaskPad interface members
HRESULT CComponent::TaskNotify (IDataObject * pdo, VARIANT * pvarg, VARIANT * pvparam)
{
    if (pvarg->vt == VT_BSTR)
    {
        USES_CONVERSION;

        OLECHAR * path = pvarg->bstrVal;

        // replace any '*' with ' ':  see enumtask.cpp
        // hash mechanism can't handle spaces, and
        // filenames can't have '*'s, so this works out ok.
        OLECHAR * temp;
        while (temp = wcschr (path, '*'))
            *temp = ' ';

        // now go do it!
        SystemParametersInfo (SPI_SETDESKWALLPAPER,
                              0,
                              (void *)OLE2T(path),
                              SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
        return S_OK;
    }
    if (pvarg->vt == VT_I4)
    {
        switch (pvarg->lVal)
        {
        case 1:
            if (m_pComponentData->GetWallPaperNode () != (HSCOPEITEM)0)
            {
                _ASSERT (m_pConsole != NULL);
                m_pConsole->SelectScopeItem (m_pComponentData->GetWallPaperNode());
                return S_OK;
            }
            break;
        case 2:  // Center
            return ApplyOption (IDM_CENTER);
        case 3:  // Tile
            return ApplyOption (IDM_TILE);
        case 4:  // Stretch
            return ApplyOption (IDM_STRETCH);
        case -1:
            if (m_toggleEntry == FALSE)
                m_toggleEntry = TRUE;
            else
                m_toggleEntry = FALSE;

            // empty and repopulate listpad
            m_pResultData->DeleteAllRsltItems();
            m_pHeaderCtrl->DeleteColumn (0);
            OnListPad (NULL, TRUE, 0);
            return S_OK;
        }
    }
    ::MessageBox (NULL, _T("unrecognized task notification"), _T("Display Manager"), MB_OK);
    return S_OK;
}

HRESULT CComponent::GetTitle (LPOLESTR szGroup, LPOLESTR * pszTitle)
{
    *pszTitle = CoTaskDupString (L"Display Manager TaskPad");
    if (!pszTitle)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CComponent::GetDescriptiveText (LPOLESTR szGroup, LPOLESTR * pszTitle)
{
    *pszTitle = CoTaskDupString (L"Bill's Handy-Dandy Display Manager TaskPad Sample");
    if (!pszTitle)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CComponent::GetBackground (LPOLESTR szGroup, MMC_TASK_DISPLAY_OBJECT * pdo)
{
    USES_CONVERSION;

    if(NULL==szGroup)
        return E_FAIL;

    if (szGroup[0] == 0)
    {
        // bitmap case
        pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        MMC_TASK_DISPLAY_BITMAP *pdb = &pdo->uBitmap;
        // fill out bitmap URL
        TCHAR szBuffer[MAX_PATH*2];    // that should be enough
        _tcscpy (szBuffer, _T("res://"));
        ::GetModuleFileName (g_hinst, szBuffer + _tcslen(szBuffer), MAX_PATH);
        _tcscat (szBuffer, _T("/img\\ntbanner.gif"));
        pdb->szMouseOverBitmap = CoTaskDupString (T2OLE(szBuffer));
        if (pdb->szMouseOverBitmap)
            return S_OK;
        return E_OUTOFMEMORY;
    }
    else
    {
        // symbol case
        pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_SYMBOL;
        MMC_TASK_DISPLAY_SYMBOL *pds = &pdo->uSymbol;

        // fill out symbol stuff
        pds->szFontFamilyName = CoTaskDupString (L"Kingston");  // name of font family
        if (pds->szFontFamilyName)
        {
            TCHAR szBuffer[MAX_PATH*2];    // that should be enough
            _tcscpy (szBuffer, _T("res://"));
            ::GetModuleFileName (g_hinst, szBuffer + _tcslen(szBuffer), MAX_PATH);
            _tcscat (szBuffer, _T("/KINGSTON.eot"));
            pds->szURLtoEOT = CoTaskDupString (T2OLE(szBuffer));    // "res://"-type URL to EOT file
            if (pds->szURLtoEOT)
            {
                pds->szSymbolString = CoTaskDupString (T2OLE(_T("A<BR>BCDEFGHIJKLMNOPQRSTUVWXYZ"))); // 1 or more symbol characters
                if (pds->szSymbolString)
                    return S_OK;
                CoTaskFreeString (pds->szURLtoEOT);
            }
            CoTaskFreeString (pds->szFontFamilyName);
        }
        return E_OUTOFMEMORY;
    }
}

HRESULT CComponent::EnumTasks (IDataObject * pdo, LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK)
{
    HRESULT hresult = S_OK;
    CEnumTasks * pet = new CEnumTasks;
    if (!pet)
        hresult = E_OUTOFMEMORY;
    else
    {
        pet->AddRef ();   // make sure release works properly on failure
        hresult = pet->Init (pdo, szTaskGroup);
        if (hresult == S_OK)
            hresult = pet->QueryInterface (IID_IEnumTASK, (void **)ppEnumTASK);
        pet->Release ();
    }
    return hresult;
}

HRESULT CComponent::GetListPadInfo (LPOLESTR szGroup, MMC_LISTPAD_INFO * pListPadInfo)
{
    pListPadInfo->szTitle      = CoTaskDupString (L"Display Manager ListPad Title");
    pListPadInfo->szButtonText = CoTaskDupString (L"Change...");
    pListPadInfo->nCommandID   = -1;
    return S_OK;
}

HRESULT ApplyOption (int nCommandID)
{
    switch (nCommandID)
    {
    case IDM_TILE:
    case IDM_CENTER:
    case IDM_STRETCH:
        // write registry key:
        {
            HKEY hkey;
            HRESULT r = RegOpenKeyEx (HKEY_CURRENT_USER,
                                      _T("Control Panel\\Desktop"), 
                                      0, KEY_ALL_ACCESS, &hkey);
            if (r == ERROR_SUCCESS)
            {
                // write new value(s)

                DWORD dwType = REG_SZ;
                TCHAR szBuffer[2];

                // first do "TileWallpaper"
                if (nCommandID == IDM_TILE)
                    lstrcpy (szBuffer, _T("1"));
                else
                    lstrcpy (szBuffer, _T("0"));

                DWORD dwCount = sizeof(TCHAR)*(1+lstrlen (szBuffer));
                r = RegSetValueEx (hkey, 
                                   (LPCTSTR)_T("TileWallpaper"),
                                   NULL,
                                   dwType,
                                   (CONST BYTE *)&szBuffer,
                                   dwCount);

                // then do "WallpaperStyle"
                if (nCommandID == IDM_STRETCH)
                    lstrcpy (szBuffer, _T("2"));
                else
                    lstrcpy (szBuffer, _T("0"));
                r = RegSetValueEx (hkey, 
                                   (LPCTSTR)_T("WallpaperStyle"),
                                   NULL,
                                   dwType,
                                   (CONST BYTE *)&szBuffer,
                                   dwCount);

                // close up shop
                RegCloseKey(hkey);
                _ASSERT(r == ERROR_SUCCESS);

                /*
                [HKEY_CURRENT_USER\Control Panel\Desktop]
                "CoolSwitch"="1"
                "CoolSwitchRows"="3"
                "CoolSwitchColumns"="7"
                "CursorBlinkRate"="530"
                "ScreenSaveTimeOut"="900"
                "ScreenSaveActive"="0"
                "ScreenSaverIsSecure"="0"
                "Pattern"="(None)"
                "Wallpaper"="C:\\WINNT\\dax.bmp"
                "TileWallpaper"="0"
                "GridGranularity"="0"
                "IconSpacing"="75"
                "IconTitleWrap"="1"
                "IconTitleFaceName"="MS Sans Serif"
                "IconTitleSize"="9"
                "IconTitleStyle"="0"
                "DragFullWindows"="1"
                "HungAppTimeout"="5000"
                "WaitToKillAppTimeout"="20000"
                "AutoEndTasks"="0"
                "FontSmoothing"="0"
                "MenuShowDelay"="400"
                "DragHeight"="2"
                "DragWidth"="2"
                "WheelScrollLines"="3"
                "WallpaperStyle"="0"
                */
            }
            if (r == ERROR_SUCCESS)
                ::MessageBox (NULL, _T("Option set Successfully!"), _T("Display Manager"), MB_OK);
            return r;
        }
    default:
        break;
    }
    return S_FALSE;
}

void CComponent::TestConsoleVerb(void)
{
    IConsoleVerb* pConsoleVerb = NULL;
    m_pConsole->QueryConsoleVerb (&pConsoleVerb);
    _ASSERT (pConsoleVerb != NULL);
    if (pConsoleVerb)
    {
        pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
        pConsoleVerb->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\dsplmgr2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       DsplMgr2.h
//
//--------------------------------------------------------------------------

// DsplMgr2.h : Declaration of the CDsplMgr2

#ifndef __DSPLMGR2_H_
#define __DSPLMGR2_H_

//#include "taskpad.h"
#include "resource.h"      // main symbols

using namespace ATL;

#define DISPLAY_MANAGER_WALLPAPER  1
#define DISPLAY_MANAGER_PATTERN    2
#define DISPLAY_MANAGER_PATTERN_CHILD 3

#define IDM_CENTER                     1
#define IDM_TILE                       2
#define IDM_STRETCH                    3
#define IDM_CUSTOMPAD                  4
#define IDM_TASKPAD                    5
#define IDM_TASKPAD_LISTVIEW           6
#define IDM_DEFAULT_LISTVIEW           7
#define IDM_DELETECHILDREN             8
#define IDM_RENAMEROOT                 9
#define IDM_TASKPAD_WALLPAPER_OPTIONS  10
#define IDM_CHANGEICON                 11
#define IDM_RENAMEWALL                 12
#define IDM_PRELOAD                    13
#define IDM_CONSOLEVERB                14

class CComponent;

struct lParamWallpaper {
   OLECHAR filename[MAX_PATH];
};

LPOLESTR CoTaskDupString (LPOLESTR szString);

/////////////////////////////////////////////////////////////////////////////
// CDsplMgr2
class ATL_NO_VTABLE CDsplMgr2 : 
   public CComObjectRootEx<CComSingleThreadModel>,
   public CComCoClass<CDsplMgr2, &CLSID_DsplMgr2>,
   public IPersistStream,
   public IComponentData
{
public:
	CDsplMgr2();
  ~CDsplMgr2();

DECLARE_REGISTRY_RESOURCEID(IDR_DSPLMGR2)
DECLARE_NOT_AGGREGATABLE(CDsplMgr2)

BEGIN_COM_MAP(CDsplMgr2)
	COM_INTERFACE_ENTRY(IComponentData)
   COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

// IComponentData interface members
public:
   STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
   STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
   STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
   STDMETHOD(Destroy)();
   STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
   STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);      
   STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IPersistStream interface members
   STDMETHOD(GetClassID)(CLSID *pClassID);
   STDMETHOD(IsDirty)();
   STDMETHOD(Load)(IStream *pStream);
   STDMETHOD(Save)(IStream *pStream, BOOL fClearDirty);
   STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

public:
   long GetViewMode () { return m_ViewMode; }
   void SetViewMode (long vm) { m_ViewMode = vm; }
   HSCOPEITEM GetRoot () { return m_rootscopeitem; }
   HSCOPEITEM GetWallPaperNode () { return m_WallPaperNodeID; }
   BOOL       GetPreload () { return m_bPreload; }

	void myDeleteItem (HSCOPEITEM hsi, BOOL fDeleteThis) { m_lpIConsoleNameSpace->DeleteItem (hsi, fDeleteThis); }
	void myRenameItem (HSCOPEITEM hsi, LPOLESTR szName);
   void myChangeIcon (void);
   void myPreLoad (void);

private:
   HRESULT OnExpand (LPDATAOBJECT pDataObject, long arg, long param);

private:
   IConsole          * m_lpIConsole;
   IConsoleNameSpace * m_lpIConsoleNameSpace;
	IImageList        * m_lpIImageList;
   long                m_ViewMode;
   ATL::CComObject<class CComponent> * m_pComponent;
   HSCOPEITEM          m_rootscopeitem;
   HSCOPEITEM          m_patternscopeitem;
   HSCOPEITEM          m_WallPaperNodeID;    // 0 == unexpanded...
   BOOL                m_toggle;
   BOOL                m_bPreload;
};

class CEnumTasks : public IEnumTASK
{
public:
   CEnumTasks();
  ~CEnumTasks();

public:
// IUnknown implementation
   STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
   STDMETHOD_(ULONG, AddRef) ();
   STDMETHOD_(ULONG, Release) ();
private:
   ULONG m_refs;

public:
// IEnumTASKS implementation
   STDMETHOD(Next) (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
   STDMETHOD(Skip) (ULONG celt);
   STDMETHOD(Reset)();
   STDMETHOD(Clone)(IEnumTASK **ppenum);
private:
   ULONG m_index;

public:
   HRESULT Init (IDataObject * pdo, LPOLESTR szTaskGroup);
private:
   void    GetBitmaps (void);
   HRESULT EnumBitmaps (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
   HRESULT EnumOptions (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
private:
   int m_type; // task grouping mechanism
   TCHAR * m_bmps;
};

class CDataObject:
   public IDataObject,
   public CComObjectRoot
{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

private:
   CDataObject() {};
public:
   CDataObject(long cookie, DATA_OBJECT_TYPES type);
   ~CDataObject();

   // 
   // IUnknown overrides
   //
   STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
   STDMETHOD_(ULONG, AddRef) ();
   STDMETHOD_(ULONG, Release) ();
   //
   // IDataObject overrides
   //
   STDMETHOD(GetDataHere) (FORMATETC *pformatetc, STGMEDIUM *pmedium);

// Not Implemented
private:
   STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
   { return E_NOTIMPL; };
   STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
   { return E_NOTIMPL; };
   STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc) 
   { return E_NOTIMPL; };
   STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
   { return E_NOTIMPL; };
   STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
   { return E_NOTIMPL; };
   STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
   { return E_NOTIMPL; };
   STDMETHOD(DUnadvise)(DWORD dwConnection)
   { return E_NOTIMPL; };
   STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
   { return E_NOTIMPL; };

public:  // my methods
   long GetCookie () { return m_cookie; }
   DATA_OBJECT_TYPES GetType () { return m_type; }
   void SetPreload (BOOL b) { m_bPreload = b; }

private:
   ULONG          m_ref;    // object reference counter
   long           m_cookie;
   DATA_OBJECT_TYPES m_type;
   BOOL           m_bPreload;

/*
   ULONG            m_cRefs;    // object refcount
   ULONG            m_ulCookie;  // what this obj refers to
   DATA_OBJECT_TYPES   m_Context;   // context in which this was created
   COOKIETYPE        m_Type;     // how to interpret _ulCookie
   CComponentData    *m_pcd;      // NULL if created by csnapin
*/

public:
   static UINT s_cfInternal;      // Our custom clipboard format
   static UINT s_cfDisplayName;   // Our test for a node
   static UINT s_cfNodeType;
   static UINT s_cfSnapinClsid;
   static UINT s_cfSnapinPreloads;
};

class CComponent:
   public IExtendTaskPad,
	public IComponent,
   public IExtendContextMenu,
   public CComObjectRoot
{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CComponent)

BEGIN_COM_MAP(CComponent)
	COM_INTERFACE_ENTRY(IComponent)
   COM_INTERFACE_ENTRY(IExtendTaskPad)
   COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()


   CComponent();
  ~CComponent();

	//
	// IComponent interface members
	//
   STDMETHOD(Initialize) (LPCONSOLE lpConsole);
   STDMETHOD(Notify) (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
   STDMETHOD(Destroy) (long cookie);
   STDMETHOD(GetResultViewType) (long cookie,  LPOLESTR* ppViewType, long* pViewOptions);
   STDMETHOD(QueryDataObject) (long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
   STDMETHOD(GetDisplayInfo) (RESULTDATAITEM*  pResultDataItem);
   STDMETHOD(CompareObjects) (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu 
   STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, long *pInsertionAllowed);
   STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// IExtendTaskPad interface members
   STDMETHOD(TaskNotify        )(IDataObject * pdo, VARIANT * pvarg, VARIANT * pvparam);
   STDMETHOD(GetTitle          )(LPOLESTR szGroup, LPOLESTR * szTitle);
   STDMETHOD(GetDescriptiveText)(LPOLESTR szGroup, LPOLESTR * szText);
   STDMETHOD(GetBackground     )(LPOLESTR szGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
   STDMETHOD(EnumTasks         )(IDataObject * pdo, BSTR szTaskGroup, IEnumTASK** ppEnumTASK);
   STDMETHOD(GetListPadInfo    )(LPOLESTR szGroup, MMC_LISTPAD_INFO * pListPadInfo);

// public
   void SetComponentData (CDsplMgr2 * pComponentData) { m_pComponentData = pComponentData; }
   long GetViewMode ();

private:
   IResultData    * m_pResultData;
   IHeaderCtrl    * m_pHeaderCtrl;
	CDsplMgr2      * m_pComponentData;  // the guy who created me
   UINT             m_IsTaskPad;       // IDM_CUSTOMPAD or IDM_TASKPAD
   LPCONSOLE        m_pConsole;        // from MMC
   long             m_TaskPadCount;
   BOOL             m_toggle;
   BOOL             m_toggleEntry;     // test "Change..." button

private:
   HRESULT OnShow       (LPDATAOBJECT pDataObject, long arg, long param);
   HRESULT OnAddImages  (LPDATAOBJECT pDataObject, long arg, long param);
   HRESULT OnDblClick   (LPDATAOBJECT pDataObject, long arg, long param);
   HRESULT OnViewChange (LPDATAOBJECT pDataObject, long arg, long param);
   HRESULT OnListPad    (LPDATAOBJECT pDataObject, long arg, long param);
   HRESULT OnRestoreView(LPDATAOBJECT pDataObject, long arg, long param);

   void TestConsoleVerb(void);

};

LPOLESTR CoTaskDupString (LPOLESTR szString);
void CoTaskFreeString (LPOLESTR szString);

#endif //__DSPLMGR2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\dsplmgr2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       DsplMgr2.cpp
//
//--------------------------------------------------------------------------

// DsplMgr2.cpp : Implementation of CDsplMgr2
#include "stdafx.h"
#include "displ2.h"
#include "DsplMgr2.h"

extern HINSTANCE g_hinst;  // in displ2.cpp

/////////////////////////////////////////////////////////////////////////////
// CDsplMgr2

CDsplMgr2::CDsplMgr2()
{
    m_lpIConsole          = NULL;
    m_lpIConsoleNameSpace = NULL;
    m_lpIImageList        = NULL;
    m_ViewMode            = LVS_ICON;   // default (if not persisting)
    m_pComponent          = NULL;
    m_rootscopeitem       = NULL;
    m_WallPaperNodeID     = (HSCOPEITEM)0; // unexpanded
    m_toggle              = FALSE;
    m_bPreload            = FALSE;
}
CDsplMgr2::~CDsplMgr2()
{
    _ASSERT (m_lpIConsole          == NULL);
    _ASSERT (m_lpIConsoleNameSpace == NULL);
    _ASSERT (m_lpIImageList        == NULL);
    if(m_pComponent)
        m_pComponent->Release ();
}
HRESULT CDsplMgr2::Initialize (LPUNKNOWN pUnknown)
{
// testing
// return E_FAIL;
// testing

    if (pUnknown == NULL)
        return E_UNEXPECTED;

    _ASSERT (m_lpIConsole == NULL);
    _ASSERT (m_lpIConsoleNameSpace == NULL);

    // this is my big chance to grab IConsole and IConsoleNameSpace pointers

    HRESULT hresult1 = pUnknown->QueryInterface (IID_IConsole, (void **)&m_lpIConsole);
    _ASSERT(hresult1 == S_OK && m_lpIConsole != NULL);
    
    HRESULT hresult2 = pUnknown->QueryInterface (IID_IConsoleNameSpace, (void **)&m_lpIConsoleNameSpace);
    _ASSERT(hresult2 == S_OK && m_lpIConsoleNameSpace != NULL);

    if (hresult1 || hresult2)
        return E_UNEXPECTED;    // we're dead

    // this is where we can add our images
    HRESULT hresult = m_lpIConsole->QueryScopeImageList(&m_lpIImageList);
    if (m_lpIImageList) {
        _ASSERT(hresult == S_OK);

        // Load the bitmaps from the dll
        HBITMAP hbmSmall = LoadBitmap (g_hinst, MAKEINTRESOURCE(IDB_SCOPE_16X16));
        if (hbmSmall) {
            hresult = m_lpIImageList->ImageListSetStrip (
                                (long*)hbmSmall,
                                (long*)hbmSmall,
                                0,
                                RGB(0,255,0));
            _ASSERT(hresult == S_OK);
            DeleteObject (hbmSmall);
        }
    }
    return hresult;
}
HRESULT CDsplMgr2::CreateComponent (LPCOMPONENT * ppComponent)
{
    //
    // MMC asks us for a pointer to the IComponent interface
    //
    // For those getting up to speed with COM...
    // If we had implemented IUnknown with its methods QueryInterface, AddRef, and Release
    // in our CComponent class...
    // The following line would have worked
    //
    // pNewSnapin = new CComponent(this);
    //
    // In this code we will have ATL take care of IUnknown for us and create an object
    // in the following manner...
    _ASSERT(ppComponent != NULL);
    *ppComponent = NULL;

    HRESULT hresult = CComObject<CComponent>::CreateInstance(&m_pComponent);
    _ASSERT(m_pComponent != NULL);
    if (m_pComponent) {
        // Store IComponentData
        // Can't have a constructor with parameters, so pass it in this way.
        m_pComponent->SetComponentData (this);

        m_pComponent->AddRef();   // bump reference count to 1 (so I can hang onto it)
        hresult = m_pComponent->QueryInterface(IID_IComponent, reinterpret_cast<void**>(ppComponent));
    }
    return hresult;
}
HRESULT CDsplMgr2::Notify (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hresult = S_OK;

    switch (event)
    {
    case MMCN_EXPAND:
        hresult = OnExpand(lpDataObject, arg, param);
        break;

    case MMCN_PRELOAD:
        m_rootscopeitem = (HSCOPEITEM)arg;
        m_bPreload = TRUE;
        myChangeIcon();
        break;

    case MMCN_DELETE:
    case MMCN_RENAME:
    case MMCN_SELECT:
    case MMCN_PROPERTY_CHANGE:
    case MMCN_REMOVE_CHILDREN:
    case MMCN_EXPANDSYNC:
        break;
      
    default:
         ATLTRACE(_T("CComponentData::Notify: unexpected event %x\n"), event);
         _ASSERT(FALSE);
         hresult = E_UNEXPECTED;
         break;
    }
    return hresult;
}
HRESULT CDsplMgr2::Destroy ()
{
    if (m_lpIConsole) {
        m_lpIConsole->Release();
        m_lpIConsole = NULL;
    }
    if (m_lpIConsoleNameSpace) {
        m_lpIConsoleNameSpace->Release();
        m_lpIConsoleNameSpace = NULL;
    }
    if (m_lpIImageList) {
        m_lpIImageList->Release();
        m_lpIImageList = NULL;
    }
    return S_OK;
}
HRESULT CDsplMgr2::QueryDataObject (long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    HRESULT hresult = S_OK;

    CDataObject *pdo = new CDataObject (cookie, type);
    *ppDataObject = pdo;
    if (pdo == NULL)
        hresult = E_OUTOFMEMORY;
#ifdef DO_WE_NEED_THIS
    else {
        //
        // The cookie represents a snapin manager or scope pane item.
        //
        // If the passed-in cookie is NULL, it is our snapins main root node folder
        // We never needed to ask for this to be created. MMC did this for us.
        //
        // Else If the passed-in cookie is non-NULL, then it should be one we
        // created when we added a node to the scope pane. See OnExpand. 
        //

        if (cookie) {
            // cookie is the lparam field that we passed in SCOPEDATAITEM
            // used for the m_pConsoleNameSpace->InsertItem(&sdi);
            ;  // pdoNew->SetCookie(cookie, CCT_SCOPE, COOKIE_IS_STATUS);
        } else {
            // In this case the node is our top node, and was placed there for us.
            ;  // pdoNew->SetCookie(0, type, COOKIE_IS_ROOT);
        }
    }
#endif
    pdo->SetPreload (m_bPreload);
    return hresult;
}
HRESULT CDsplMgr2::GetDisplayInfo (SCOPEDATAITEM* psdi)
{
    _ASSERT (psdi != NULL);

/*
const DWORD SDI_STR         = 0x00002;
const DWORD SDI_IMAGE       = 0x00004;
const DWORD SDI_OPENIMAGE   = 0x00008;
const DWORD SDI_STATE       = 0x00010;
const DWORD SDI_PARAM       = 0x00020;
const DWORD SDI_CHILDREN    = 0x00040;
*/

/*
// The top 4 bit of the mask determines the relative position of this item,
// relative to the SCOPEDATAITEM::relativeID. By default it is the parent.

// For SDI_PARENT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the parent.
// As you can see by the SDI_PARENT value it is a no-op. Since by default
// SCOPEDATAITEM::relativeID is treated as the parents ID.
const DWORD SDI_PARENT      = 0x00000000;

// For SDI_PREVIOUS, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the previous sibling
const DWORD SDI_PREVIOUS    = 0x10000000;

// For SDI_NEXT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the next sibling.
const DWORD SDI_NEXT        = 0x20000000;

// For SDI_PARENT, bit 27 determines whether the item is to be inserted as the
// first child. By default this item will inserted as the last child.
const DWORD SDI_FIRST       = 0x08000000;
*/

/*
typedef struct _SCOPEDATAITEM
{
     DWORD       mask;
     LPOLESTR    displayname;
     int         nImage;
     int         nOpenImage;
     UINT        nState;
     int         cChildren;
     LPARAM      lParam;
     HSCOPEITEM  relativeID;
     HSCOPEITEM  ID;
} SCOPEDATAITEM;

typedef SCOPEDATAITEM* LPSCOPEDATAITEM;

typedef enum _MMC_SCOPE_ITEM_STATE
{
     MMC_SCOPE_ITEM_STATE_NORMAL = 0x0001,        // Not bold. To set or get.
     MMC_SCOPE_ITEM_STATE_BOLD = 0x0002,          // To set or get.
     MMC_SCOPE_ITEM_STATE_EXPANDEDONCE = 0x0003,  // Only to get.
     
} MMC_SCOPE_ITEM_STATE;
*/

    if (psdi) {
        if(psdi->mask & SDI_STR) {
            switch (psdi->lParam) {
            case DISPLAY_MANAGER_WALLPAPER:
                if (m_toggle)
                    psdi->displayname = (LPOLESTR)L"Renamed Wallpaper";
                else
                    psdi->displayname = (LPOLESTR)L"Wallpaper";
                break;
            case DISPLAY_MANAGER_PATTERN:
                psdi->displayname = (LPOLESTR)L"Pattern";
                break;
            case DISPLAY_MANAGER_PATTERN_CHILD:
                psdi->displayname = (LPOLESTR)L"Pattern test child";
                break;
            default:
                psdi->displayname = (LPOLESTR)L"Hey! You shouldn't see this!";
                break;
            }
        }
    }
    return S_OK;
}
HRESULT CDsplMgr2::CompareObjects (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{  return !S_OK; }

HRESULT CDsplMgr2::OnExpand(LPDATAOBJECT pDataObject, long arg, long param)
{
    _ASSERT(m_lpIConsoleNameSpace != NULL); // make sure we QI'ed for the interface
    _ASSERT(pDataObject != NULL);

    if (arg == TRUE) {  // expanding, FALSE => contracting
        CDataObject *pdo = (CDataObject *)pDataObject;  // TODO:  hmm....

        // the code below makes sure that we're dealing only with the root node
        if (pdo->GetCookie () == 0) {    // 0 == root
            // hang onto to root HSCOPEITEM (param) for later
            m_rootscopeitem = (HSCOPEITEM)param;

            // Place our folder(s) into the scope pane
            SCOPEDATAITEM sdi;
            ZeroMemory(&sdi, sizeof(sdi));
            sdi.mask        = SDI_STR       | // displayname is valid
                              SDI_PARAM     | // lParam is valid
                              SDI_IMAGE     | // nImage is valid
                              SDI_OPENIMAGE | // nOpenImage is valid
                              SDI_PARENT;
            sdi.relativeID  = (HSCOPEITEM) param;
            sdi.nImage      = 0;
            sdi.nOpenImage  = 1;
            sdi.displayname = MMC_CALLBACK;

            sdi.lParam      = (LPARAM) DISPLAY_MANAGER_WALLPAPER;
            m_lpIConsoleNameSpace->InsertItem(&sdi);

            m_WallPaperNodeID = sdi.ID;

            sdi.lParam      = (LPARAM) DISPLAY_MANAGER_PATTERN;
            return m_lpIConsoleNameSpace->InsertItem(&sdi);
        }
        if (pdo->GetCookie () == DISPLAY_MANAGER_PATTERN) {
            // add another node, so I can test deleteitem stuff

            // hang onto to root HSCOPEITEM (param) for later
            m_patternscopeitem = (HSCOPEITEM)param;

            // Place our folder into the scope pane
            SCOPEDATAITEM sdi;
            ZeroMemory(&sdi, sizeof(sdi));
            sdi.mask        = SDI_STR       | // displayname is valid
                              SDI_PARAM     | // lParam is valid
                              SDI_IMAGE     | // nImage is valid
                              SDI_OPENIMAGE | // nOpenImage is valid
                              SDI_PARENT;
            sdi.relativeID  = (HSCOPEITEM) param;
            sdi.nImage      = 0;
            sdi.nOpenImage  = 1;
            sdi.displayname = MMC_CALLBACK;

            sdi.lParam      = (LPARAM) DISPLAY_MANAGER_PATTERN_CHILD;
            return m_lpIConsoleNameSpace->InsertItem(&sdi);
        }
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP CDsplMgr2::GetClassID (CLSID *pClassID)
{
    if (pClassID) {
        *pClassID = CLSID_DsplMgr2;
        return S_OK;
    }
    return E_POINTER;
}

HRESULT CDsplMgr2::IsDirty ()
{
    // get current ViewMode and compare against my value
    if (m_pComponent == NULL)
        return S_FALSE;
    long vm = m_pComponent->GetViewMode ();
    if (m_ViewMode == vm)
        return S_FALSE;
    return S_OK;
}

HRESULT CDsplMgr2::Load (IStream *pStream)
{
// testing
// return E_FAIL;
// testing

    _ASSERT (pStream);

    // we have a long specifying ViewMode (LVS_ICON, LVS_REPORT, etc.)
    return pStream->Read (&m_ViewMode, sizeof(long), NULL);
}

HRESULT CDsplMgr2::Save (IStream *pStream, BOOL fClearDirty)
{
    _ASSERT (pStream);

    if (m_pComponent) // get current value
        m_ViewMode = m_pComponent->GetViewMode ();

    // write ViewMode
    HRESULT hr = pStream->Write (&m_ViewMode, sizeof(long), NULL);
    return hr == S_OK ? S_OK : STG_E_CANTSAVE;
}

HRESULT CDsplMgr2::GetSizeMax (ULARGE_INTEGER *pcbSize)
{
    _ASSERT (pcbSize);
    ULISet32 (*pcbSize, sizeof(long));
    return S_OK;
}

// other public stuff
void CDsplMgr2::myRenameItem (HSCOPEITEM hsi, LPOLESTR szName)
{
    if (m_toggle)
        m_toggle = FALSE;
    else
        m_toggle = TRUE;

    SCOPEDATAITEM item;
      ZeroMemory (&item, sizeof(SCOPEDATAITEM));
    item.mask         = SDI_STR;
    item.displayname = MMC_CALLBACK;
    item.ID             = hsi;

    m_lpIConsoleNameSpace->SetItem (&item);
}

void CDsplMgr2::myChangeIcon (void)
{
    _ASSERT (m_lpIImageList != NULL);
    _ASSERT (m_rootscopeitem != NULL);  // shoulda been selected by now.

    HBITMAP hbmSmall = LoadBitmap (g_hinst, MAKEINTRESOURCE(IDB_SCOPE_16X16_CUSTOM));
    if (!hbmSmall)
        return;
    HRESULT hr = m_lpIImageList->ImageListSetStrip (
                        (long*)hbmSmall,
                        (long*)hbmSmall,
                        0,
                        RGB(0,255,0));
    _ASSERT (hr == S_OK);
    DeleteObject (hbmSmall);

    SCOPEDATAITEM item;
      ZeroMemory (&item, sizeof(SCOPEDATAITEM));
    item.mask         = SDI_IMAGE | SDI_OPENIMAGE;
    item.nImage         = 0;   //  (int)MMC_CALLBACK;
    item.nOpenImage     = 1;   //  (int)MMC_CALLBACK;
    item.ID             = m_rootscopeitem;

    m_lpIConsoleNameSpace->SetItem (&item);
}
void CDsplMgr2::myPreLoad (void)
{
    // toggle state
    if (m_bPreload == TRUE)
        m_bPreload = FALSE;
    else
        m_bPreload = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\displ2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       displ2.cpp
//
//--------------------------------------------------------------------------

// displ2.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f displ2ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "displ2.h"

#include "DsplMgr2.h"
#include <atlimpl.cpp>

using namespace ATL;

CComModule _Module;

const CLSID CLSID_DsplMgr2 = {0x885B3BAE,0x43F9,0x11D1,{0x9F,0xD4,0x00,0x60,0x08,0x32,0xDB,0x4A}};

// cut from mmc_i.c (yuck) !!!
const IID IID_IComponentData = {0x955AB28A,0x5218,0x11D0,{0xA9,0x85,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};
const IID IID_IComponent = {0x43136EB2,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IResultDataCompare = {0xE8315A52,0x7A1A,0x11D0,{0xA2,0xD2,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const IID IID_IResultOwnerData = {0x9CB396D8,0xEA83,0x11d0,{0xAE,0xF1,0x00,0xC0,0x4F,0xB6,0xDD,0x2C}};
const IID IID_IConsole = {0x43136EB1,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IHeaderCtrl = {0x43136EB3,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IContextMenuCallback = {0x43136EB7,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IContextMenuProvider = {0x43136EB6,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IExtendContextMenu = {0x4F3B7A4F,0xCFAC,0x11CF,{0xB8,0xE3,0x00,0xC0,0x4F,0xD8,0xD5,0xB0}};
const IID IID_IImageList = {0x43136EB8,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IResultData = {0x31DA5FA0,0xE0EB,0x11cf,{0x9F,0x21,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};
const IID IID_IQuickFilter = {0x9757abb8,0x1b32,0x11d1,{0xa7,0xce,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
const IID IID_IConsoleNameSpace = {0xBEDEB620,0xF24D,0x11cf,{0x8A,0xFC,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};
const IID IID_IPropertySheetCallback = {0x85DE64DD,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};
const IID IID_IPropertySheetProvider = {0x85DE64DE,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};
const IID IID_IExtendPropertySheet = {0x85DE64DC,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};
const IID IID_IControlbar = {0x69FB811E,0x6C1C,0x11D0,{0xA2,0xCB,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const IID IID_IExtendControlbar = {0x49506520,0x6F40,0x11D0,{0xA9,0x8B,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};
const IID IID_IToolbar = {0x43136EB9,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IConsoleVerb = {0xE49F7A60,0x74AF,0x11D0,{0xA2,0x86,0x00,0xC0,0x4F,0xD8,0xFE,0x93}};
const IID IID_ISnapinAbout = {0x1245208C,0xA151,0x11D0,{0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const IID IID_IMenuButton = {0x951ED750,0xD080,0x11d0,{0xB1,0x97,0x00,0x00,0x00,0x00,0x00,0x00}};
const IID IID_ISnapinHelp = {0xA6B15ACE,0xDF59,0x11D0,{0xA7,0xDD,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

const IID IID_IExtendTaskPad = {0x8dee6511,0x554d,0x11d1,{0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a}};
const IID IID_IEnumTASK      = {0x338698b1,0x5a02,0x11d1,{0x9f,0xec,0x00,0x60,0x08,0x32,0xdb,0x4a}};

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DsplMgr2, CDsplMgr2)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

long g_ref_DataObject = 0; // used in DataObj.cpp
HINSTANCE g_hinst = 0;     // used in DsplMgr2.cpp

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
      g_hinst = hInstance;
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\enumtask.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       enumtask.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "displ2.h"
#include "DsplMgr2.h"

extern HINSTANCE g_hinst;  // in displ2.cpp

#define NEW_WAY
LPOLESTR CoTaskDupString (LPOLESTR szString)
{
#ifdef NEW_WAY
    OLECHAR * lpString = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szString)+1));
    if (lpString)
        wcscpy (lpString, szString);
    return lpString;
#else
    return(LPOLESTR)SysAllocString (szString);
#endif
}
void CoTaskFreeString (LPOLESTR szString)
{
#ifdef NEW_WAY
    CoTaskMemFree (szString);
#else
    SysFreeString (szString);
#endif
}

CEnumTasks::CEnumTasks()
{
    m_refs = 0;
    m_index = 0;
    m_type = 0;    // default group/category

    // filenames for wallpaper mode
    m_bmps = NULL;
}
CEnumTasks::~CEnumTasks()
{
    if (m_bmps)
        delete m_bmps;
}

HRESULT CEnumTasks::QueryInterface (REFIID riid, LPVOID FAR* ppv)
{
    if ( (riid == IID_IUnknown)  ||
         (riid == IID_IEnumTASK) )
    {
        *ppv = this;
        ((LPUNKNOWN)(*ppv))->AddRef();
        return NOERROR;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}
ULONG   CEnumTasks::AddRef ()
{
    return ++m_refs;
}
ULONG   CEnumTasks::Release ()
{
    if (--m_refs == 0)
    {
        delete this;
        return 0;
    }
    return m_refs;
}
#define NUMBER_OF_TASKS 4

LPTSTR g_bitmaps[NUMBER_OF_TASKS] = { _T("/img\\ntauto.gif"),
    _T("/img\\mariners.gif"),
    _T("/img\\ntstart.gif"),
    _T("/img\\ntmonitor.gif")};
LPTSTR g_text   [NUMBER_OF_TASKS] = { _T("Set Wallpaper"),
    _T("Wallpaper Node"),
    _T("Wallpaper Options"),
    _T("Alert Script")};
LPTSTR g_help   [NUMBER_OF_TASKS] = { _T("Pick Bitmap Image for Wallpaper"),
    _T("Jump to Wallpaper Node"),
    _T("Select Stretch, Tile, or Center"),
    _T("Script demo")};
LPTSTR g_action [NUMBER_OF_TASKS] = { _T("/wallpapr.htm"),
    _T("1"),
    _T("/default.htm#wallpaper_options"),
    _T("JSCRIPT:alert('my location is: ' + location);")};
//                                    _T("vbscript:MsgBox 'hi' ")};

HRESULT OneOfEach(ULONG index, MMC_TASK *rgelt, ULONG *pceltFetched)
{   // NOTE: not bothering with error checking!!!

    if (index >= 20 /*NUMBER_OF_TASKS*/)
    {
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;   // all done
    }

    USES_CONVERSION;

    // setup path for reuse
    TCHAR szPath[MAX_PATH*2];    // that should be enough
    lstrcpy (szPath, _T("res://"));
    ::GetModuleFileName (g_hinst, szPath + lstrlen(szPath), MAX_PATH);
    TCHAR * szBuffer = szPath + lstrlen(szPath);

    MMC_TASK * task = rgelt;
    MMC_TASK_DISPLAY_OBJECT* pdo = &task->sDisplayObject;
    MMC_TASK_DISPLAY_BITMAP* pdb = &pdo->uBitmap;
    MMC_TASK_DISPLAY_SYMBOL* pds = &pdo->uSymbol;

    switch (index)
    {
    default:
        {
            TCHAR szNumber[10];
            if (index < 200)
                _itot (index, szNumber, 10);
            else
                _itot (index-200, szNumber, 10);
            task->szText       = CoTaskDupString (T2OLE(szNumber));
        }

        task->szHelpString     = CoTaskDupString (T2OLE(g_help[0]));
        task->eActionType      = MMC_ACTION_LINK;
        _tcscpy (szBuffer, _T("/wallpapr.htm"));
        task->szActionURL      = CoTaskDupString (T2OLE(szPath));


        lstrcpy (szPath, _T("res://"));
        ::GetModuleFileName (NULL, szPath + lstrlen(szPath), MAX_PATH);
        szBuffer = szPath + lstrlen(szPath);

        pdo->eDisplayType      = MMC_TASK_DISPLAY_TYPE_SYMBOL;
        if (index < 200)
        {
            pds->szFontFamilyName  = CoTaskDupString (L"Glyph 100");  // name of font family
            _tcscpy (szBuffer, _T("/GLYPH100.eot"));
        }
        else
        {
            pds->szFontFamilyName  = CoTaskDupString (L"Glyph 110");  // name of font family
            _tcscpy (szBuffer, _T("/GLYPH110.eot"));
        }
        pds->szURLtoEOT        = CoTaskDupString (T2OLE(szPath));  // "res://"-type URL to EOT file
        {
            OLECHAR szChar[2] = {0,0};
            szChar[0] = (WORD) (index%20 + 32); // cycle the same 20 symbols starting at 32
            pds->szSymbolString= CoTaskDupString (szChar);  // 1 or more symbol characters
        }
        break;

    case 0:
        pdo->eDisplayType      = MMC_TASK_DISPLAY_TYPE_VANILLA_GIF;
        _tcscpy (szBuffer, _T("/img\\vanilla.gif"));
        pdb->szMouseOffBitmap  = CoTaskDupString (T2OLE(szPath));
        pdb->szMouseOverBitmap = NULL;  // skipping mouse over bitmap
        task->szText           = CoTaskDupString (T2OLE(g_text[index]));
        task->szHelpString     = CoTaskDupString (T2OLE(g_help[index]));
        task->eActionType      = MMC_ACTION_LINK;
        _tcscpy (szBuffer, _T("/wallpapr.htm"));
        task->szActionURL      = CoTaskDupString (T2OLE(szPath));
        break;

    case 1:
        pdo->eDisplayType      = MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF;
        _tcscpy (szBuffer, _T("/img\\chocolate.gif"));
        pdb->szMouseOffBitmap  = CoTaskDupString (T2OLE(szPath));
        pdb->szMouseOverBitmap = NULL;  // skipping mouse off bitmap
        task->szText           = CoTaskDupString (T2OLE(g_text[index]));
        task->szHelpString     = CoTaskDupString (T2OLE(g_help[index]));
        task->eActionType      = MMC_ACTION_ID;
        task->nCommandID       = 1;
        break;

    case 2:
        pdo->eDisplayType      = MMC_TASK_DISPLAY_TYPE_BITMAP;
        _tcscpy (szBuffer, _T("/img\\ntstart.gif"));
        pdb->szMouseOffBitmap  = CoTaskDupString (T2OLE(szPath));
        _tcscpy (szBuffer, _T("/img\\dax.bmp"));
        pdb->szMouseOverBitmap = CoTaskDupString (T2OLE(szPath));
        task->szText           = CoTaskDupString (T2OLE(g_text[index]));
        task->szHelpString     = CoTaskDupString (T2OLE(g_help[index]));
        task->eActionType      = MMC_ACTION_LINK;
        _tcscpy (szBuffer, _T("/default.htm#wallpaper_options"));
        task->szActionURL      = CoTaskDupString (T2OLE(szPath));
        break;

    case 3:
        pdo->eDisplayType      = MMC_TASK_DISPLAY_TYPE_SYMBOL;
        pds->szFontFamilyName  = CoTaskDupString (L"Kingston");  // name of font family
        _tcscpy (szBuffer, _T("/KINGSTON.eot"));
        pds->szURLtoEOT        = CoTaskDupString (T2OLE(szPath));  // "res://"-type URL to EOT file
        pds->szSymbolString    = CoTaskDupString (T2OLE(_T("A"))); // 1 or more symbol characters
        task->szText           = CoTaskDupString (T2OLE(g_text[index]));
        task->szHelpString     = CoTaskDupString (T2OLE(g_help[index]));
        task->eActionType      = MMC_ACTION_SCRIPT;
        task->szScript         = CoTaskDupString (T2OLE(g_action[index]));
        break;
    }
    return S_OK;
}

HRESULT CEnumTasks::Next (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{    // will be called with celt == 1
    // caller alloc's array of MMC_TASKs
    // callee fills MMC_TASK elements (via CoTaskDupString)

    _ASSERT (!IsBadWritePtr (rgelt, celt*sizeof(MMC_TASK)));

    if (m_type == 2)
        return EnumBitmaps (celt, rgelt, pceltFetched);
    if (m_type == 3)
        return EnumOptions (celt, rgelt, pceltFetched);

// new stuff
    return OneOfEach (m_index++, rgelt, pceltFetched);
// new stuff

    if (m_index >= NUMBER_OF_TASKS)
    {
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;   // failure
    }

    USES_CONVERSION;

    // setup path for reuse
    TCHAR szBuffer[MAX_PATH*2];    // that should be enough
    lstrcpy (szBuffer, _T("res://"));
    ::GetModuleFileName (g_hinst, szBuffer + lstrlen(szBuffer), MAX_PATH);
    TCHAR * temp = szBuffer + lstrlen(szBuffer);

    MMC_TASK * task = rgelt;
    MMC_TASK_DISPLAY_OBJECT* pdo = &task->sDisplayObject;
    pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
    MMC_TASK_DISPLAY_BITMAP *pdb = &pdo->uBitmap;

    // fill out bitmap URL
    lstrcpy (temp, g_bitmaps[m_index]);
    pdb->szMouseOffBitmap = CoTaskDupString (T2OLE(szBuffer));
    if (pdb->szMouseOffBitmap)
    {
        lstrcpy (temp, _T("/img\\dax.bmp"));
        pdb->szMouseOverBitmap = CoTaskDupString (T2OLE(szBuffer));
        if (pdb->szMouseOverBitmap)
        {
            // add button text
            task->szText = CoTaskDupString (T2OLE(g_text[m_index]));
            if (task->szText)
            {
                // add help string
                task->szHelpString = CoTaskDupString (T2OLE(g_help[m_index]));
                if (task->szHelpString)
                {

                    // add action URL (link or script)
                    switch (m_index)
                    {
                    default:
                    case 0:
                        task->eActionType = MMC_ACTION_LINK;
                        break;
                    case 1:
                        task->eActionType = MMC_ACTION_ID;
                        break;
                    case 2:
                        task->eActionType = MMC_ACTION_LINK;
                        break;
                    case 3:
                        task->eActionType = MMC_ACTION_SCRIPT;
                        break;
                    }

                    // the stuff below works, because of the nameless union.
                    if (m_index == 1)
                    {
                        task->nCommandID = _ttol (g_action[m_index]);
                        m_index++;

                        // if we get here all is well
                        if (pceltFetched)
                            *pceltFetched = 1;
                        return S_OK;
                    }
                    else
                    {
                        if (m_index == 0)
                        {
                            lstrcpy (temp, g_action[m_index]);
                            task->szActionURL = CoTaskDupString (T2OLE(szBuffer));
                        }
                        else
                            task->szActionURL = CoTaskDupString (T2OLE(g_action[m_index]));
                        if (task->szActionURL)
                        {
                            m_index++;

                            // if we get here all is well
                            if (pceltFetched)
                                *pceltFetched = 1;
                            return S_OK;
                        }
                    }
                    CoTaskFreeString (task->szHelpString);
                }
                CoTaskFreeString (task->szText);
            }
            CoTaskFreeString (pdb->szMouseOverBitmap);
        }
        CoTaskFreeString (pdb->szMouseOffBitmap);
    }

    // if we get here, we have some kinda failure
    if (pceltFetched)
        *pceltFetched = 0;
    return S_FALSE;   // failure
}
HRESULT CEnumTasks::Skip (ULONG celt)
{    // won't be called
    m_index += celt;
    return S_OK;
}
HRESULT CEnumTasks::Reset()
{
    m_index = 0;
    return S_OK;
}
HRESULT CEnumTasks::Clone(IEnumTASK **ppenum)
{    // won't be called

    // clone maintaining state info 
    CEnumTasks * pet = new CEnumTasks();
    if (pet)
    {
        pet->m_index = m_index;
        return pet->QueryInterface (IID_IEnumTASK, (void **)ppenum);   // can't fail
    }
    return E_OUTOFMEMORY;
}

HRESULT CEnumTasks::Init (IDataObject * pdo, LPOLESTR szTaskGroup)
{  // return ok, if we can handle data object and group
    if (!wcscmp (szTaskGroup, L""))
        m_type = 1; // default tasks
    else
        if (!wcscmp (szTaskGroup, L"wallpaper"))
        m_type = 2; // enum wallpaper tasks
    else
        if (!wcscmp (szTaskGroup, L"wallpaper_options"))
        m_type = 3; // enum option-tasks (tile/center/stretch)
//  else
//  if (!wcscmp (szTaskGroup, L"ListPad"))
//      m_type = 4; // default tasks
    return S_OK;
}

HRESULT CEnumTasks::EnumBitmaps (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{   // will be called with celt == 1
    // enum wallpaper tasks

    // may only be called when m_type == 2
    _ASSERT (m_type == 2);

    USES_CONVERSION;

    TCHAR temp2[MAX_PATH*2];

    // setup path for reuse
    TCHAR szBuffer[MAX_PATH*2];    // that should be enough
    lstrcpy (szBuffer, _T("file://"));
    TCHAR * path = szBuffer + lstrlen(szBuffer);
    ::GetWindowsDirectory (path, MAX_PATH);
    lstrcat (path, _T("\\"));
    path = szBuffer + lstrlen(szBuffer);

    // if we haven't already, get all .bmp files in the windows directory
    if (!m_bmps)
        GetBitmaps ();
    if (!m_bmps)
    {
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;   // failure
    }

    TCHAR * temp = m_bmps;
    // skip past names of stuff we've already enum'ed
    for (ULONG j=0; j<m_index; j++)
        temp += lstrlen (temp) + 1;

    if (*temp == 0)
    {
        // all done!
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;   // failure
    }

    MMC_TASK * task = rgelt;
    MMC_TASK_DISPLAY_OBJECT* pdo = &task->sDisplayObject;
    pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
    MMC_TASK_DISPLAY_BITMAP *pdb = &pdo->uBitmap;

    // fill out bitmap URL
    lstrcpy (path, temp);
    if (!lstrcmp (temp, _T("(none)")))
    {
        // special case for none
        lstrcpy (temp2, _T("res://"));
        ::GetModuleFileName (g_hinst, temp2 + lstrlen (temp2), MAX_PATH);
        lstrcat (temp2, _T("/img\\none.gif"));
        pdb->szMouseOffBitmap = CoTaskDupString (T2OLE(temp2));
    }
    else
    {
        lstrcpy (temp2, _T("\""));
        lstrcat (temp2, szBuffer);
        lstrcat (temp2, _T("\""));
        pdb->szMouseOffBitmap = CoTaskDupString (T2OLE(temp2));
    }
    if (pdb->szMouseOffBitmap)
    {
        // am using same bitmap for both!!!
        pdb->szMouseOverBitmap = CoTaskDupString ((LPOLESTR)pdb->szMouseOffBitmap);
        if (pdb->szMouseOverBitmap)
        {
            // add button text
            task->szText = CoTaskDupString (T2OLE(temp));
            if (task->szText)
            {
                // add help string
                OLECHAR help[] = L"Add this Bitmap as Wallpaper";
                task->szHelpString = CoTaskDupString (help);
                if (task->szHelpString)
                {

                    // add action URL (link or script)
                    task->eActionType = MMC_ACTION_LINK;   // always link to scriptlet
                    TCHAR wallpaper[] = _T("#wallpaper");
#ifndef TRY_THIS
                    TCHAR action[]    = _T("/button.htm#");

                    lstrcpy (temp2, _T("res://"));
                    ::GetModuleFileName (g_hinst, temp2 + lstrlen (temp2), MAX_PATH);
                    lstrcat (temp2, action);
#else
                    TCHAR action[]    = _T("button.htm#");
                    lstrcpy (temp2, action);
#endif

                    TCHAR * sztemp = temp2 + lstrlen (temp2);
                    lstrcat (temp2, temp);

                    // replace any spaces with '*' char
                    // script can't handle hashes with ' ' in 'em
                    // and there can't be any filenames with '*' char,
                    // so this works ok.
                    TCHAR * space;
                    while (space = _tcschr (sztemp, ' '))
                        *space = '*';

                    lstrcat (temp2, wallpaper);
                    task->szActionURL = CoTaskDupString (T2OLE(temp2));
                    if (task->szActionURL)
                    {
                        m_index++;

                        // if we get here all is well
                        if (pceltFetched)
                            *pceltFetched = 1;
                        return S_OK;
                    }
                    CoTaskFreeString (task->szHelpString);
                }
                CoTaskFreeString (task->szText);
            }
            CoTaskFreeString (pdb->szMouseOverBitmap);
        }
        CoTaskFreeString (pdb->szMouseOffBitmap);
    }

    // if we get here, we failed above
    if (pceltFetched)
        *pceltFetched = 0;
    return S_FALSE;   // failure
}

void CEnumTasks::GetBitmaps (void)
{
    if (m_bmps)
        return;  // knuckle-head

    TCHAR path[MAX_PATH];
    GetWindowsDirectory (path, MAX_PATH);
    lstrcat (path, _T("\\*.bmp"));

    // count up *.bmp files in windows directory (also add an entry for "(none)" )
    int numBMPs = 0;
    int length  = 0;  // get total length of all filenames

    WIN32_FIND_DATA fd;
    ZeroMemory(&fd, sizeof(fd));
    HANDLE hFind = FindFirstFile (path, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)    ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)    )
                continue;   // files only

            numBMPs++;
            length += lstrlen (fd.cFileName) + 1;

        } while (FindNextFile (hFind, &fd) == TRUE);
        FindClose(hFind);
    }
    numBMPs++;  // one for "(none)"
    length += lstrlen (_T("(none)")) + 1;
    length++;   // add trailing double NULL

    // alloc space to hold filenames (plus extra NULL entry)
    m_bmps = new TCHAR[length];
    if (!m_bmps)
        return;  // fail, but no return mechanism

    // add none first
    TCHAR * temp = m_bmps;
    lstrcpy (temp, _T("(none)"));
    temp += lstrlen (temp) + 1;

    // add all bmp files
    ZeroMemory(&fd, sizeof(fd));
    hFind = FindFirstFile (path, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)    ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)    )
                continue;   // files only

            lstrcpy (temp, fd.cFileName);
            temp += lstrlen (temp) + 1;

        } while (FindNextFile (hFind, &fd) == TRUE);
        FindClose(hFind);
    }
    *temp = 0;  // double null terminator
}


#define NUMBER_OF_O_TASKS 3
LPTSTR g_o_bitmaps[NUMBER_OF_O_TASKS] = {_T("/img\\ntauto.gif"),
    _T("/img\\mariners.gif"),
    _T("/img\\ntstart.gif")};
LPTSTR g_o_text   [NUMBER_OF_O_TASKS] = {_T("Center"),
    _T("Tile"),
    _T("Stretch")};
LPTSTR g_o_help   [NUMBER_OF_O_TASKS] = {_T("Center Wallpaper"),
    _T("Tile Wallpaper"),
    _T("Stretch Wallpaper")};
LPTSTR g_o_action [NUMBER_OF_O_TASKS] = {_T("2"),  // command ids
    _T("3"),
    _T("4")};

HRESULT CEnumTasks::EnumOptions (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{    // will be called with celt == 1
    // enum option tasks

    // may only be called when m_type == 3
    _ASSERT (m_type == 3);
    _ASSERT (celt == 1);

    if (m_index >= NUMBER_OF_O_TASKS)
    {
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;   // failure
    }

    USES_CONVERSION;

    // setup path for reuse
    TCHAR szBuffer[MAX_PATH*2];    // that should be enough
    _tcscpy (szBuffer, _T("res://"));
    ::GetModuleFileName (g_hinst, szBuffer + _tcslen(szBuffer), MAX_PATH);
    TCHAR * path = szBuffer + _tcslen(szBuffer);

    MMC_TASK * task = rgelt;
    MMC_TASK_DISPLAY_OBJECT* pdo = &task->sDisplayObject;
#ifdef BITMAP_CASE
    pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
    MMC_TASK_DISPLAY_BITMAP *pdb = &pdo->uBitmap;

    // fill out bitmap URL
    lstrcpy (path, g_o_bitmaps[m_index]);
    pdb->szMouseOffBitmap = CoTaskDupString (T2OLE(szBuffer));
    if (pdb->szMouseOffBitmap)
    {
        // am using same bitmap for both!!!
        pdb->szMouseOverBitmap = CoTaskDupString (T2OLE(szBuffer));
        if (pdb->szMouseOverBitmap)
        {
#else

    // symbol case
    pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_SYMBOL;
    MMC_TASK_DISPLAY_SYMBOL *pds = &pdo->uSymbol;

    // fill out symbol stuff
    pds->szFontFamilyName = CoTaskDupString (L"Kingston");  // name of font family
    if (pds->szFontFamilyName)
    {
        _tcscpy (path, _T("/KINGSTON.eot"));
        pds->szURLtoEOT = CoTaskDupString (T2OLE(szBuffer));    // "res://"-type URL to EOT file
        if (pds->szURLtoEOT)
        {
            TCHAR szSymbols[2];
            szSymbols[0] = (TCHAR)(m_index + 'A');
            szSymbols[1] = 0;
            pds->szSymbolString   = CoTaskDupString (T2OLE(szSymbols)); // 1 or more symbol characters
            if (pds->szSymbolString)
            {
#endif

                // add button text
                task->szText = CoTaskDupString (T2OLE(g_o_text[m_index]));
                if (task->szText)
                {
                    // add help string
                    task->szHelpString = CoTaskDupString (T2OLE(g_o_help[m_index]));
                    if (task->szHelpString)
                    {
                        // add action
                        task->eActionType = MMC_ACTION_ID;
                        task->nCommandID  = _ttol(g_o_action[m_index]);
                        m_index++;
                        return S_OK;   // all is well
                    }
                    CoTaskFreeString (task->szText);
                }
#ifdef BITMAP_CASE
                CoTaskFreeString (pdb->szMouseOverBitmap);
            }
            CoTaskFreeString (pdb->szMouseOffBitmap);
#else
                CoTaskFreeString (pds->szSymbolString);
            }
            CoTaskFreeString (pds->szURLtoEOT);
        }
        CoTaskFreeString (pds->szFontFamilyName);
#endif
    }

    // we get here on failure
    if (pceltFetched)
        *pceltFetched = 0;
    return S_FALSE;   // failure
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by displ2.rc
//
#define IDS_PROJNAME                    100
#define IDR_DSPLMGR2                    101
#define IDB_SCOPE_16X16                 201
#define IDB_SCOPE_16X16_CUSTOM          202
#define IDH_TASKPAD                    2301

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=displ2
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

C_DEFINES=   -D_DISPL2_DLL_ 

!IF "$(DBX)" == "yes"
C_DEFINES=  $(C_DEFINES) -DDBX
!endif

USE_NATIVE_EH=1
USE_RTTI=1
USE_VCCOM=1
USE_ATL=1

TARGETLIBS= \
            $(SDK_LIB_PATH)\mmc.lib          \
            $(SDK_LIB_PATH)\kernel32.lib     \
            $(SDK_LIB_PATH)\user32.lib       \
            $(SDK_LIB_PATH)\oleaut32.lib     \
            $(SDK_LIB_PATH)\ole32.lib        \
            $(SDK_LIB_PATH)\advapi32.lib     \
            $(SDK_LIB_PATH)\uuid.lib         \
            $(SDK_LIB_PATH)\comctl32.lib     \
            $(SDK_LIB_PATH)\gdi32.lib        \
            $(SDK_LIB_PATH)\comdlg32.lib    


# To prevent AV in CPropertyPage::DoModal
LINKER_FLAGS=\
        /SECTION:.rsrc,rw

DLLDEF=..\displ2.def

INCLUDES=..

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

SOURCES=    \
            ..\displ2.rc    \
            ..\displ2.cpp   \
            ..\dataobj.cpp  \
            ..\enumtask.cpp \
            ..\dsplmgr2.cpp \
            ..\dsplcomp.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\displ2\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__885B3BA4_43F9_11D1_9FD4_00600832DB4A__INCLUDED_)
#define AFX_STDAFX_H__885B3BA4_43F9_11D1_9FD4_00600832DB4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
#include <commctrl.h>

//using namespace ATL;

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern ATL::CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__885B3BA4_43F9_11D1_9FD4_00600832DB4A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\displex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       DisplEx.h
//
//--------------------------------------------------------------------------

// DisplEx.h : Declaration of the CDisplEx

#ifndef __DISPLEX_H_
#define __DISPLEX_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions

/////////////////////////////////////////////////////////////////////////////
// CDisplEx
class ATL_NO_VTABLE CDisplEx : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDisplEx, &CLSID_DisplEx>,

   public IExtendTaskPad
{
public:
   CDisplEx();
  ~CDisplEx();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_DISPLEX)
DECLARE_NOT_AGGREGATABLE(CDisplEx)

BEGIN_COM_MAP(CDisplEx)
   COM_INTERFACE_ENTRY(IExtendTaskPad)
END_COM_MAP()

// IExtendTaskPad interface members
   STDMETHOD(TaskNotify        )(IDataObject * pdo, VARIANT * pvarg, VARIANT * pvparam);
   STDMETHOD(GetTitle          )(LPOLESTR szGroup, LPOLESTR * szTitle);
   STDMETHOD(GetDescriptiveText)(LPOLESTR szGroup, LPOLESTR * szText);
   STDMETHOD(GetBackground     )(LPOLESTR szGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
   STDMETHOD(EnumTasks         )(IDataObject * pdo, BSTR szTaskGroup, IEnumTASK** ppEnumTASK);
   STDMETHOD(GetListPadInfo    )(LPOLESTR szGroup, MMC_LISTPAD_INFO * pListPadInfo);
};

class CEnumTasks : public IEnumTASK
{
public:
   CEnumTasks();
  ~CEnumTasks();

public:
// IUnknown implementation
   STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
   STDMETHOD_(ULONG, AddRef) ();
   STDMETHOD_(ULONG, Release) ();
private:
   ULONG m_refs;

public:
// IEnumTASKS implementation
   STDMETHOD(Next) (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
   STDMETHOD(Skip) (ULONG celt);
   STDMETHOD(Reset)();
   STDMETHOD(Clone)(IEnumTASK **ppenum);
private:
   ULONG m_index;

public:
   HRESULT Init (IDataObject * pdo, LPOLESTR szTaskGroup);
private:
   int m_type; // task grouping mechanism
};

#endif //__DISPLEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\displex.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       DisplEx.cpp
//
//--------------------------------------------------------------------------

// DisplEx.cpp : Implementation of CDisplEx
#include "stdafx.h"
#include "dsplex.h"
#include "DisplEx.h"

// local proto
HRESULT Do (void);

/////////////////////////////////////////////////////////////////////////////
// CDisplEx
CDisplEx::CDisplEx()
{
}
CDisplEx::~CDisplEx()
{
}
//HRESULT CDisplEx::InitializeTaskPad (ITaskPad* pTaskPad)
//{
//    return S_OK;
//}
HRESULT CDisplEx::TaskNotify (IDataObject * pdo, VARIANT * pvarg, VARIANT * pvparam)
{
   if (pvarg->vt == VT_I4)
   if (pvarg->lVal == 1)
      return Do ();

   ::MessageBox (NULL, L"unrecognized task notification", L"Display Manager Extension", MB_OK);
   return S_FALSE;
}
HRESULT CDisplEx::GetTitle (LPOLESTR szGroup, LPOLESTR * szTitle)
{
   return E_NOTIMPL;
}
HRESULT CDisplEx::GetDescriptiveText(LPOLESTR szGroup, LPOLESTR * szText)
{
   return E_NOTIMPL;
}
HRESULT CDisplEx::GetBackground(LPOLESTR szGroup, MMC_TASK_DISPLAY_OBJECT * pTDO)
{
   return E_NOTIMPL;
}
HRESULT CDisplEx::EnumTasks (IDataObject * pdo, LPOLESTR szTaskGroup, IEnumTASK** ppEnumTASK)
{
   CEnumTasks * pet = new CEnumTasks;
   if(pet) {
      pet->Init (pdo, szTaskGroup);
      pet->AddRef ();
      HRESULT hresult = pet->QueryInterface (IID_IEnumTASK, (void **)ppEnumTASK);
      pet->Release ();
      return hresult;
   }
   return E_OUTOFMEMORY;
}
HRESULT CDisplEx::GetListPadInfo (LPOLESTR szGroup, MMC_LISTPAD_INFO * pListPadInfo)
{
    return E_NOTIMPL;
}

HRESULT Do (void)
{
   HRESULT hresult = S_OK;
   if (OpenClipboard (NULL) == 0)
      hresult = S_FALSE;
   else {
      GLOBALHANDLE h = GetClipboardData (CF_DIB);
      if (!h)
         hresult = S_FALSE;
      else {
         BITMAPINFOHEADER * bih = (BITMAPINFOHEADER *)GlobalLock (h);
         if (!bih)
            hresult = E_OUTOFMEMORY;
         else {
            // validate bih
            _ASSERT (bih->biSize == sizeof(BITMAPINFOHEADER));

            // create a file in the windows directory called
            // "DISPLEX.bmp"

            OLECHAR path[MAX_PATH];
            GetWindowsDirectory (path, MAX_PATH);
            lstrcat (path, L"\\DISPLEX.bmp");

            HANDLE hf = CreateFile (path,
                                    GENERIC_WRITE,  // access
                                    0,              // share mode
                                    NULL,           // security attributes
                                    CREATE_ALWAYS,  // creation
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL            // template file
                                   );
            if (hf == (HANDLE)HFILE_ERROR)
               hresult = E_FAIL;
            else {
               // BMP file header (14 bytes):
               // 2 byte:  "BM";
               // long: size of file
               // word: x hot spot
               // word: y hot spot
               // long: offset to bits
               // DIB

               BYTE bm[2];
               bm[0] = 'B';
               bm[1] = 'M';
               DWORD dwWritten;
               WriteFile (hf, (LPCVOID)bm, 2, &dwWritten, NULL);
               DWORD dwTemp = 14 + GlobalSize (h);
               WriteFile (hf, (LPCVOID)&dwTemp, sizeof(DWORD), &dwWritten, NULL);
               dwTemp = 0; // both x, y hot spots in one shot
               WriteFile (hf, (LPCVOID)&dwTemp, sizeof(DWORD), &dwWritten, NULL);
               dwTemp  = 14 + sizeof(BITMAPINFOHEADER);
               dwTemp += bih->biClrUsed*sizeof(RGBQUAD);
               WriteFile (hf, (LPCVOID)&dwTemp, sizeof(DWORD), &dwWritten, NULL);

               // now write dib
               WriteFile (hf, (LPCVOID)bih, GlobalSize (h), &dwTemp, NULL);
               CloseHandle (hf);
               if (GlobalSize(h) != dwTemp)
                  hresult = E_UNEXPECTED;
               else {
                  // now make the BMP the wallpaper
                  SystemParametersInfo (SPI_SETDESKWALLPAPER,
                                        0,
                                        (void *)path,
                                        SPIF_UPDATEINIFILE |
                                        SPIF_SENDWININICHANGE
                                       );
               }
               DeleteFile (path);
            }
            GlobalUnlock (h);
         }
         // don't free handle
      }
      CloseClipboard ();
   }
   if (hresult != S_OK)
      ::MessageBox (NULL, L"Either no Bitmap on Clipboard or\nout of Disk Space", L"Display Manager Extension", MB_OK);
   return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\dsplex.cpp ===
// dsplex.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f dsplexps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "dsplex.h"

#include "dsplex_i.c"
#include <initguid.h>
#include "DisplEx.h"


CComModule _Module;

// cut from mmc_i.c (yuck) !!!
const IID IID_IComponentData = {0x955AB28A,0x5218,0x11D0,{0xA9,0x85,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};
const IID IID_IExtendTaskPad = {0x8dee6511,0x554d,0x11d1,{0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a}};
const IID IID_IEnumTASK      = {0x338698b1,0x5a02,0x11d1,{0x9f,0xec,0x00,0x60,0x08,0x32,0xdb,0x4a}};

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DisplEx, CDisplEx)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

HINSTANCE g_hinst = 0;     // used in enumtask.cpp

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
      g_hinst = hInstance;
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsplex.rc
//
#define IDS_PROJNAME                    100
#define IDR_DISPLEX                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\enumtask.cpp ===
#include "stdafx.h"
#include "dsplex.h"
#include "DisplEx.h"

extern HINSTANCE g_hinst;  // in dsplex.cpp

// local function
LPOLESTR CoTaskDupString (LPOLESTR szString)
{
    OLECHAR * lpString = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(szString)+1));
    if (lpString)
        lstrcpy (lpString, szString);
    return lpString;
}

CEnumTasks::CEnumTasks()
{
    m_refs = 0;
    m_index = 0;
}
CEnumTasks::~CEnumTasks()
{
}

HRESULT CEnumTasks::QueryInterface (REFIID riid, LPVOID FAR* ppv)
{
    if ( (riid == IID_IUnknown)  ||
          (riid == IID_IEnumTASK) ){
        *ppv = this;
        ((LPUNKNOWN)(*ppv))->AddRef();
        return NOERROR;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}
ULONG    CEnumTasks::AddRef ()
{
     return ++m_refs;
}
ULONG    CEnumTasks::Release ()
{
    if (--m_refs == 0) {
        delete this;
        return 0;
    }
    return m_refs;
}

#define NUMBER_OF_TASKS 1

LPOLESTR g_bitmaps[NUMBER_OF_TASKS] = {L"/img\\ntmonitor.gif"};
LPOLESTR g_text   [NUMBER_OF_TASKS] = {L"Wallpaper Extension Task"};
LPOLESTR g_help   [NUMBER_OF_TASKS] = {L"Use Clipboard Image as Wallpaper (but just for testing purposes I'm going to make this a really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really long line\
                                         really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really really long line)"};
long     g_action [NUMBER_OF_TASKS] = {1};

HRESULT CEnumTasks::Next (ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{//will be called with celt == 1

    _ASSERT (celt == 1);
    _ASSERT (!IsBadWritePtr (rgelt, celt*sizeof(MMC_TASK)));

    // wrong type.
    if (m_type != 1) {
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;    // failure
    }

    // setup path for reuse
    OLECHAR szBuffer[MAX_PATH*2];     // that should be enough
    lstrcpy (szBuffer, L"res://");
    ::GetModuleFileName (g_hinst, szBuffer + lstrlen(szBuffer), MAX_PATH);
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

    if (m_index >= NUMBER_OF_TASKS) {
        if (pceltFetched)
            *pceltFetched = 0;
        return S_FALSE;    // failure
    }

    MMC_TASK * task = &rgelt[0];
    MMC_TASK_DISPLAY_OBJECT* pdo = &task->sDisplayObject;
    MMC_TASK_DISPLAY_BITMAP* pdb = &pdo->uBitmap;

    // fill out bitmap URL
    pdo->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
    lstrcpy (temp, g_bitmaps[m_index]);
    pdb->szMouseOverBitmap = CoTaskDupString (szBuffer);
    if (pdb->szMouseOverBitmap) {
        pdb->szMouseOffBitmap = CoTaskDupString (szBuffer);
        if (pdb->szMouseOffBitmap) {
            // add button text
            task->szText = CoTaskDupString (g_text[m_index]);
            if (task->szText) {
            
                // add help string
                task->szHelpString = CoTaskDupString (g_help[m_index]);
                if (task->szHelpString) {
            
                    // add action URL (link or script)
                    task->eActionType = MMC_ACTION_ID;
                    task->nCommandID  = g_action[m_index];
                    m_index++;
                    if (pceltFetched)
                        *pceltFetched = 1;
                    return S_OK;
                }
                CoTaskMemFree (task->szText);
            }
            CoTaskMemFree (pdb->szMouseOffBitmap);
        }
        CoTaskMemFree (pdb->szMouseOverBitmap);
    }

    // if we get here, we didn't "continue" and therefore fail
    if (pceltFetched)
        *pceltFetched = 0;
    return S_FALSE;    // failure
}
HRESULT CEnumTasks::Skip (ULONG celt)
{
    m_index += celt;
    return S_OK;
}
HRESULT CEnumTasks::Reset()
{
    m_index = 0;
    return S_OK;
}
HRESULT CEnumTasks::Clone(IEnumTASK **ppenum)
{//clone maintaining state info
    return E_NOTIMPL;
}

HRESULT CEnumTasks::Init (IDataObject * pdo, LPOLESTR szTaskGroup)
{  // return ok, if we can handle data object and group
    if (!lstrcmp (szTaskGroup, L""))
        m_type = 1; // default tasks
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\dsplex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dsplex.h
//
//--------------------------------------------------------------------------

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Nov 20 11:17:48 1997
 */
/* Compiler settings for dsplex.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dsplex_h__
#define __dsplex_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDisplEx_FWD_DEFINED__
#define __IDisplEx_FWD_DEFINED__
typedef interface IDisplEx IDisplEx;
#endif 	/* __IDisplEx_FWD_DEFINED__ */


#ifndef __DisplEx_FWD_DEFINED__
#define __DisplEx_FWD_DEFINED__

#ifdef __cplusplus
typedef class DisplEx DisplEx;
#else
typedef struct DisplEx DisplEx;
#endif /* __cplusplus */

#endif 	/* __DisplEx_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDisplEx_INTERFACE_DEFINED__
#define __IDisplEx_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDisplEx
 * at Thu Nov 20 11:17:48 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpstring][uuid] */ 



EXTERN_C const IID IID_IDisplEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7D197470-607C-11D1-9FED-00600832DB4A")
    IDisplEx : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDisplExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDisplEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDisplEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDisplEx __RPC_FAR * This);
        
        END_INTERFACE
    } IDisplExVtbl;

    interface IDisplEx
    {
        CONST_VTBL struct IDisplExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDisplEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDisplEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDisplEx_INTERFACE_DEFINED__ */



#ifndef __DSPLEXLib_LIBRARY_DEFINED__
#define __DSPLEXLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DSPLEXLib
 * at Thu Nov 20 11:17:48 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_DSPLEXLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DisplEx;

class DECLSPEC_UUID("7D197471-607C-11D1-9FED-00600832DB4A")
DisplEx;
#endif
#endif /* __DSPLEXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\dsplex\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__DC86AD86_607B_11D1_9FED_00600832DB4A__INCLUDED_)
#define AFX_STDAFX_H__DC86AD86_607B_11D1_9FED_00600832DB4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
using namespace ATL;
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DC86AD86_607B_11D1_9FED_00600832DB4A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\adddir.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       adddir.cpp
//
//--------------------------------------------------------------------------

// AddDir.cpp : implementation file
//

#include "stdafx.h"
#include "AddDir.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddDirDialog dialog


CAddDirDialog::CAddDirDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CAddDirDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddDirDialog)
	//}}AFX_DATA_INIT
}


void CAddDirDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddDirDialog)
	DDX_Text(pDX, IDC_DIRNAME, m_strDirName);
	DDV_MaxChars(pDX, m_strDirName, 255);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddDirDialog, CDialog)
	//{{AFX_MSG_MAP(CAddDirDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddDirDialog message handlers

void CAddDirDialog::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

void CAddDirDialog::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\adddir.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       adddir.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_ADDDIR_H__6E213391_E1DC_11D0_AEEF_00C04FB6DD2C__INCLUDED_)
#define AFX_ADDDIR_H__6E213391_E1DC_11D0_AEEF_00C04FB6DD2C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddDir.h : header file
//

#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CAddDirDialog dialog

class CAddDirDialog : public CDialog
{
// Construction
public:
	CAddDirDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddDirDialog)
	enum { IDD = IDD_ADDDIR };
	CString	m_strDirName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddDirDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddDirDialog)
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDDIR_H__6E213391_E1DC_11D0_AEEF_00C04FB6DD2C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\addfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       addfile.cpp
//
//--------------------------------------------------------------------------

// AddFile.cpp : implementation file
//

#include "stdafx.h"
#include "AddFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddFileDialog dialog


CAddFileDialog::CAddFileDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CAddFileDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddFileDialog)
	m_strFileName = _T("");
	//}}AFX_DATA_INIT
}


void CAddFileDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddFileDialog)
	DDX_Text(pDX, IDC_FILENAME, m_strFileName);
	DDV_MaxChars(pDX, m_strFileName, 255);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddFileDialog, CDialog)
	//{{AFX_MSG_MAP(CAddFileDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddFileDialog message handlers

void CAddFileDialog::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

void CAddFileDialog::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\inc\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);

    void Trace(LPWSTR pszfmt, ...);
    void Trace(LPSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPWSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, LPWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

private:
    unsigned long   m_InfoLevel; // must be the first data member
    LPTSTR          m_InfoLevelString;

};  // class CDbg


#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined
#define DEB_USER8           0x00800000      // User defined
#define DEB_USER9           0x01000000      // User defined
#define DEB_USER10          0x02000000      // User defined
#define DEB_USER11          0x04000000      // User defined
#define DEB_USER12          0x08000000      // User defined
#define DEB_USER13          0x10000000      // User defined
#define DEB_USER14          0x20000000      // User defined
#define DEB_USER15          0x40000000      // User defined

#define DEB_NOCOMPNAME      0x80000000      // suppress component name

#define DEB_FORCE           0x7fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\inc\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#define DEB_RESOURCE    DEB_USER10      // Constructor/Destructor
#define DEB_METHOD      DEB_USER11
#define DEB_FUNCTION    DEB_USER12

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    
    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_DESTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this);

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n"));

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __DummyDbg(ULONG, LPCWSTR, ...) { }
    inline void __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __DummyTrace(LPCWSTR, ...) { }
    inline void __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   e

    #define ASSERT(e)
    #define VERIFY(e)   e

#endif // DBG==1


#if DBG==1 && defined(_NODEMGR_DLL_)

    // Debug instance counter
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "MMC: Memory Leak!!!", MB_OK);
}

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    

#endif 





#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }


#ifdef DBX
#define DbxAssert(x)    ASSERT(x)
#define DbxMsg(sz)      ::MessageBox(NULL, sz, _T("MMC"), MB_OK|MB_APPLMODAL)
#else 
#define DbxAssert(x)
#define DbxMsg(sz)
#endif 

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\addfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       addfile.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_ADDFILE_H__6E213392_E1DC_11D0_AEEF_00C04FB6DD2C__INCLUDED_)
#define AFX_ADDFILE_H__6E213392_E1DC_11D0_AEEF_00C04FB6DD2C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddFile.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAddFileDialog dialog

class CAddFileDialog : public CDialog
{
// Construction
public:
	CAddFileDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddFileDialog)
	enum { IDD = IDD_ADDFILE };
	CString	m_strFileName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddFileDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddFileDialog)
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDFILE_H__6E213392_E1DC_11D0_AEEF_00C04FB6DD2C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\assert.cpp ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------


#define new DEBUG_NEW


#include <stdafx.h>
#include "admindbg.h"

//
//  Globals
//

ULONG AdminInfoLevel = DEF_INFOLEVEL;
ULONG AdminInfoMask = 0xffffffff;
ULONG AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL fCritSecInit = FALSE;
static CRITICAL_SECTION s_csMessageBuf;
static TCHAR g_szMessageBuf[500];        // this is the message buffer

//
//  Forward declration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  InitializeDebugging(void);
void  smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
int   w4dprintf(LPTSTR format, ...);
int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4smprintf(LPTSTR  format, va_list arglist)
{
    int ret;

    EnterCriticalSection(&s_csMessageBuf);
    ret = wvsprintf(g_szMessageBuf, format, arglist);
    OutputDebugString(g_szMessageBuf);
    LeaveCriticalSection(&s_csMessageBuf);
    return ret;
}


//+------------------------------------------------------------
// Function:    SetAdminInfoLevel(ULONG ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
//
// Returns:     Old info level
//
//-------------------------------------------------------------

ULONG SetAdminInfoLevel(ULONG ulNewLevel)
{
    ULONG ul;

    ul = AdminInfoLevel;
    AdminInfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetAdminInfoMask(ULONG ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
//
// Returns:     Old info mask
//
//-------------------------------------------------------------

ULONG SetAdminInfoMask(ULONG ulNewMask)
{
    ULONG ul;

    ul = AdminInfoMask;
    AdminInfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetAdminAssertLevel(ULONG ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
//
// Returns:     Old assert level
//
//-------------------------------------------------------------

ULONG SetAdminAssertLevel(ULONG ulNewLevel)
{
    ULONG ul;

    ul = AdminAssertLevel;
    AdminAssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

void smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | AdminInfoLevel) & AdminInfoMask))
    {
        EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((AdminInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
            }
            w4smprintf(ppszfmt, pargs);
        }

        //if (AdminInfoLevel & DEB_STDOUT)
        //{
        //    if (! (ulCompMask & DEB_NOCOMPNAME))
        //    {
        //        printf("%x.%03x> %s: ", pid, tid, pszComp);
        //    }
        //    vprintf(ppszfmt, pargs);
        //}

        LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
#define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    if (!fCritSecInit) InitializeDebugging();

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADMINDEBUGKEY, 0,
                                            KEY_ALL_ACCESS, &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                                                    KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                   REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;

            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                        (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}

void InitializeDebugging(void)
{
    if (fCritSecInit) return;
    InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    fCritSecInit = TRUE;
}



// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':')
                            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return (LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static CHAR szModuleName[128];
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    wsprintf(szAssertCaption, _T("%hs: Assertion Failed"), pProcess);


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    wsprintf(szDetails, _T(" Assertion:\t %s\n\n")       \
                        _T(" File:   \t\t %hs\n")        \
                        _T(" Line:   \t\t %d\n\n")       \
                        _T(" Module:   \t %hs\n")        \
                        _T(" Thread ID:\t %d.%d\n"),
                        szMsg, szFile, iLine, pszModuleName, pid, tid);


    int id = MessageBox(NULL,
                    szDetails,
                    szAssertCaption,
                    MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
            szMessage, pszFileName, iLine, tid);
    }

    if (AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (AdminAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________

CDbg::CDbg(LPTSTR  str)
    :
    m_InfoLevelString(str),
    m_InfoLevel(DEF_INFOLEVEL)
{
    CheckInit(m_InfoLevelString, &m_InfoLevel);
}

void CDbg::Trace(LPSTR pszfmt, ...)
{
#ifdef UNICODE
    int convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::Trace(LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    int convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                                                      err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    ptcMsg = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcMsg[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\compdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       compdata.cpp
//
//--------------------------------------------------------------------------

// CompData.cpp : Implementation of CComponentData
#include "stdafx.h"
#include "CompData.h"
#include "Compont.h"
#include "dataobj.h"
#include "cookie.h"
#include "AddFile.h"
#include "AddDir.h"


extern int cookie_id = 0;
extern int iDbg = 0;

/////////////////////////////////////////////////////////////////////////////
// CComponentData


CComponentData::CComponentData() : m_pCookieRoot(NULL)
{
    m_strRootDir = _T("C:\\testbed");
}

CComponentData::~CComponentData()
{
    ASSERT(m_spConsole == NULL);
    ASSERT(m_spScope == NULL);
}

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    if (pUnknown == NULL)
        return E_POINTER;

    ASSERT(m_spConsole == NULL);
    m_spConsole = pUnknown;
    ASSERT(m_spConsole != NULL);

    m_spScope = m_spConsole;
    ASSERT(m_spScope != NULL);

    if (m_pCookieRoot == NULL)
    {
        m_pCookieRoot = new CCookie(FOLDER_COOKIE);
        m_pCookieRoot->SetName((LPWSTR)(LPCWSTR)m_strRootDir);
    }

    ASSERT(m_pCookieRoot != NULL);

    return S_OK;
}

STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);
    if (ppComponent == NULL)
        return E_POINTER;

    CComObject<CComponent>* pObject;
    HRESULT hr = CComObject<CComponent>::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return E_FAIL;

    // Store IComponentData
    pObject->SetComponentData(this);

    return pObject->QueryInterface(IID_IComponent,
                                   reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject,
                                    MMC_NOTIFY_TYPE event, long arg, long param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spScope != NULL);
    HRESULT hr = S_OK;

    if (event == MMCN_PROPERTY_CHANGE)
    {
        ASSERT(0 && _T("MMCN_PROPERTY_CHANGE not handled."));
        //hr = OnProperties(param);
    }
    else
    {
        switch(event)
        {
        case MMCN_DELETE:
            _OnDelete(lpDataObject);
            break;

        case MMCN_REMOVE_CHILDREN:
            _OnRemoveChildren(arg);
            break;

        case MMCN_RENAME:
            ::AfxMessageBox(_T("CD::MMCN_RENAME"));
            //hr = OnRename(cookie, arg, param);
            break;

        case MMCN_EXPAND:
            hr = _OnExpand(lpDataObject, arg, param);
            break;

        case MMCN_BTN_CLICK:
            ::AfxMessageBox(_T("CD::MMCN_BTN_CLICK"));
            break;

        default:
            break;
        }

    }

    return hr;
}

STDMETHODIMP CComponentData::Destroy()
{
    m_spConsole.Release();
    ASSERT(m_spConsole == NULL);
    m_spScope.Release();
    ASSERT(m_spScope == NULL);

    m_pCookieRoot->Release();

    return S_OK;
}

STDMETHODIMP CComponentData::QueryDataObject(long cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    if (m_pCookieRoot == 0)
    {
        m_pCookieRoot = new CCookie(FOLDER_COOKIE);
        m_pCookieRoot->SetName((LPWSTR)(LPCWSTR)m_strRootDir);
    }

    CCookie* pCC = cookie ? reinterpret_cast<CCookie*>(cookie) : m_pCookieRoot;

    CComObject<CDataObject>* pObject;
    HRESULT hr = CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return E_FAIL;

    pObject->Init(TRUE, this);
    pObject->AddCookie(pCC);

    return pObject->QueryInterface(IID_IDataObject,
                                   reinterpret_cast<void**>(ppDataObject));
}

STDMETHODIMP CComponentData::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CCookie* pCookie = reinterpret_cast<CCookie*>(pScopeDataItem->lParam);

    ASSERT(pScopeDataItem->mask & SDI_STR);
    pScopeDataItem->displayname = pCookie->GetName();

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA,
                                            LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    return S_OK;
}

void CComponentData::_FreeFolderCookies(HSCOPEITEM hSI)
{
    ASSERT(m_spScope != NULL);

    HSCOPEITEM hSITemp;
    LONG lCookie;

    do
    {
        HRESULT hr = m_spScope->GetChildItem(hSI, &hSITemp, &lCookie);
        if (FAILED(hr))
            break;

        _FreeFolderCookies(hSITemp);
        reinterpret_cast<CCookie*>(lCookie)->Release();

    } while (1);
}

CCookie* CComponentData::_GetCookie(HSCOPEITEM hSI)
{
    SCOPEDATAITEM sdi;
    ZeroMemory(&sdi, sizeof(sdi));

    sdi.mask = SDI_PARAM;
    sdi.ID = hSI;

    HRESULT hr = m_spScope->GetItem(&sdi);
    ASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
        return NULL;

    CCookie* pCookie = reinterpret_cast<CCookie*>(sdi.lParam);
    if (pCookie == NULL)
    {
        pCookie = m_pCookieRoot;
        ASSERT(m_pCookieRoot != NULL);
        sdi.lParam = reinterpret_cast<long>(m_pCookieRoot);

        hr = m_spScope->SetItem(&sdi);
        ASSERT(SUCCEEDED(hr));
    }

    return pCookie;
}

HRESULT CComponentData::_OnExpand(LPDATAOBJECT lpDataObject, LONG arg, LONG param)
{
    if (arg == 0)
    {
        ASSERT(0);
        _FreeFolderCookies((HSCOPEITEM)param);
    }
    else
    {
        IEnumCookiesPtr spEnum = lpDataObject;
        ASSERT(spEnum != NULL);
        if (spEnum == NULL)
            return E_FAIL;

        CCookie* pCookie = NULL;
        spEnum->Reset();
        HRESULT hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookie), NULL);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        ASSERT(pCookie != NULL);
        if (pCookie == NULL)
            return E_FAIL;

        if (m_pCookieRoot == pCookie)
            m_pCookieRoot->SetID((HSCOPEITEM)param);

        ASSERT(pCookie->GetID() == param);

        if (pCookie->IsExpanded() == FALSE)
        {
            _EnumerateFolders(pCookie);
            pCookie->SetExpanded(TRUE);
        }
    }

    return S_OK;
}

void CComponentData::GetFullPath(LPCWSTR pszFolderName, HSCOPEITEM hScopeItem,
                                 CString& strDir)
{
    strDir = _T(""); // init

    HSCOPEITEM hSI = hScopeItem;
    LONG lCookie;
    HRESULT hr = S_OK;

    CList<LONG, LONG> listOfCookies;

    while (hSI)
    {
        HSCOPEITEM hSITemp = 0;
        hr = m_spScope->GetParentItem(hSI, &hSITemp, &lCookie);
        if (FAILED(hr))
            break;

        if (lCookie == 0)
            lCookie = reinterpret_cast<LONG>(m_pCookieRoot);

        listOfCookies.AddHead(lCookie);

        hSI = hSITemp;
    }

    POSITION pos = listOfCookies.GetHeadPosition();
    while (pos)
    {
        CCookie* pCookie = reinterpret_cast<CCookie*>(listOfCookies.GetNext(pos));
        strDir += pCookie->GetName();
        strDir += _T('\\');
    }

    strDir += pszFolderName;
}


HRESULT CComponentData::_EnumerateFolders(CCookie* pCookie)
{
    HRESULT hr = S_OK;

    CString strDir;
    GetFullPath(pCookie->GetName(), (HSCOPEITEM)pCookie->GetID(), strDir);
    strDir += _T("\\*");

    WIN32_FIND_DATA fd;
    ZeroMemory(&fd, sizeof(fd));
    HANDLE hFind = FindFirstFile(strDir, &fd);

    SCOPEDATAITEM sdi;
    ZeroMemory(&sdi, sizeof(sdi));

    sdi.mask = SDI_PARAM | SDI_STR;
    sdi.displayname = MMC_CALLBACK;
    sdi.relativeID = (HSCOPEITEM)pCookie->GetID();
    sdi.nImage = FOLDER_ICON;
    sdi.nOpenImage = OPEN_FOLDER_ICON;

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) ||
                (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
            {
                continue;
            }

            if (fd.cFileName[0] == _T('.'))
            {
                if (fd.cFileName[1] == _T('\0'))
                    continue;

                if ((fd.cFileName[1] == _T('.')) && (fd.cFileName[2] == _T('\0')))
                    continue;
            }

            CCookie* pCookie = new CCookie(FOLDER_COOKIE);
            pCookie->SetName(fd.cFileName);

            sdi.lParam = reinterpret_cast<LONG>(pCookie);
            hr = m_spScope->InsertItem(&sdi);
            ASSERT(SUCCEEDED(hr));

            ASSERT(sdi.ID != 0);
            pCookie->SetID(sdi.ID);

        } while (FindNextFile(hFind, &fd) == TRUE);

        FindClose(hFind);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// IExtendContextMenu methods

enum {
    IDM_ADDFILE,
    IDM_ADDDIR
};

static CONTEXTMENUITEM menuItems[] =
{
    {
        L"File...", L"Create a new file",
        IDM_ADDFILE, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, 0
    },
    {
        L"Directory...", L"Create a new directory",
        IDM_ADDDIR, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, 0
    },
    { NULL, NULL, 0, 0, 0 }
};


STDMETHODIMP CComponentData::AddMenuItems(
                LPDATAOBJECT pDataObject,
                LPCONTEXTMENUCALLBACK pContextMenuCallback,
                long *pInsertionAllowed)
{
    HRESULT hr = S_OK;

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
    {

        IEnumCookiesPtr spEnumCookies = pDataObject;
        if (spEnumCookies == NULL)
            return E_FAIL;

        CCookie* pCookie = NULL;
        spEnumCookies->Reset();
        HRESULT hr = spEnumCookies->Next(1, (long*)&pCookie, NULL);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        ASSERT(pCookie->IsFolder() == TRUE);

        // Can only add item to folder
        if (pCookie->IsFolder() == FOLDER_COOKIE)
        {
            for (LPCONTEXTMENUITEM m = menuItems; m->strName; m++)
            {
                hr = pContextMenuCallback->AddItem(m);

                if (FAILED(hr))
                    break;
            }
        }
    }

    return hr;
}

int _lstrcmpin(LPWSTR psz1, LPWSTR psz2, UINT cch)
{
    ASSERT(lstrlen(psz1) >= (int)cch);
    ASSERT(lstrlen(psz2) >= (int)cch);

    WCHAR tc1 = psz1[cch];
    WCHAR tc2 = psz2[cch];

    psz1[cch] = _T('\0');
    psz2[cch] = _T('\0');

    int iRet = lstrcmpi(psz1, psz2);

    psz1[cch] = tc1;
    psz2[cch] = tc2;

    return iRet;
}

LPWSTR _GetNextDir(LPWSTR pszPath, LPWSTR pszDir)
{
    *pszDir = _T('\0'); // init

    // Strip leading back slashes
    while (*pszPath == _T('\\')) ++pszPath;

    if (*pszPath == _T('\0'))
        return NULL;

    while ((*pszPath != _T('\0')) && (*pszPath != _T('\\')))
        *pszDir++ = *pszPath++;

    *pszDir = _T('\0');

    return pszPath;
}

CCookie* CComponentData::_FindCookie(LPWSTR pszName)
{
    UINT cchRootDir = lstrlen(GetRootDir());
    UINT cch = lstrlen(pszName);

    ASSERT(cch >= cchRootDir);
    ASSERT(_lstrcmpin(pszName, (LPWSTR)GetRootDir(), cchRootDir) == 0);

    if (cch == cchRootDir)
        return m_pCookieRoot;

    ASSERT(m_pCookieRoot->GetID() != 0);

    LPWSTR pszRest = pszName + cchRootDir;
    WCHAR szDir[260];


    HSCOPEITEM hScopeItem = m_pCookieRoot->GetID();
    CCookie* pCookie = NULL;
    HRESULT hr = S_OK;

    for (pszRest = _GetNextDir(pszRest, szDir);
         pszRest != NULL;
         pszRest = _GetNextDir(pszRest, szDir))
    {
        hr = m_spScope->GetChildItem(hScopeItem, &hScopeItem,
                                     reinterpret_cast<long*>(&pCookie));
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            break;

        while (*pCookie != szDir)
        {
            hr = m_spScope->GetNextItem(hScopeItem, &hScopeItem,
                                        reinterpret_cast<long*>(&pCookie));
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
                break;
        }

        if (FAILED(hr))
            break;
    }

    if (FAILED(hr))
        pCookie = NULL;

    return pCookie;
}

STDMETHODIMP CComponentData::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    ASSERT(pDataObject != NULL);

    IEnumCookiesPtr spEnum = pDataObject;
    ASSERT(spEnum != NULL);
    if (spEnum == NULL)
        return E_FAIL;

    CCookie* pCookie = NULL;
    spEnum->Reset();
    HRESULT hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookie), NULL);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    ASSERT(pCookie != NULL);
    if (pCookie == NULL)
        return E_FAIL;

    CString strPath; // = pCookie->GetName();
    GetFullPath(pCookie->GetName(), (HSCOPEITEM)pCookie->GetID(), strPath);
    strPath += _T("\\");

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (nCommandID)
    {
    case IDM_ADDFILE:
    {
        CAddFileDialog FileDlg;

        if (FileDlg.DoModal() == IDOK && !FileDlg.m_strFileName.IsEmpty())
        {
            strPath += FileDlg.m_strFileName;

            HANDLE hFile = CreateFile(strPath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
            ASSERT(hFile != INVALID_HANDLE_VALUE);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                SUpadteInfo* pUI = new SUpadteInfo;
                pUI->m_hSIParent = pCookie->GetID();
                pUI->m_bCreated = TRUE;
                LPWSTR psz = NewDupString((LPCWSTR)FileDlg.m_strFileName);
                pUI->m_files.Add(psz);

                m_spConsole->UpdateAllViews(GetDummyDataObject(), (long)pUI, 0L);
                delete [] psz;
            }
        }

        break;
    }
    case IDM_ADDDIR:
    {
        CAddDirDialog DirDlg;

        if (DirDlg.DoModal() == IDOK && !DirDlg.m_strDirName.IsEmpty())
        {
            strPath += DirDlg.m_strDirName;
            if (CreateDirectory(strPath, NULL))
            {
                CCookie* pNewCookie = new CCookie(FOLDER_COOKIE);
                pNewCookie->SetName((LPWSTR)(LPCWSTR)DirDlg.m_strDirName);

                // If the parent folder has been expanded
                // then add scope item for new folder
                if (pCookie->IsExpanded() == TRUE)
                {
                    SCOPEDATAITEM sdi;
                    ZeroMemory(&sdi, sizeof(sdi));
#if 1
                    HSCOPEITEM idNext = 0;
                    LONG lParam;
                    hr = m_spScope->GetChildItem(pCookie->GetID(), &idNext, &lParam);
                    ASSERT(SUCCEEDED(hr));

                    if (idNext)
                    {
                        sdi.mask = SDI_PARAM | SDI_STR | SDI_NEXT;
                        sdi.relativeID = idNext;
                    }
                    else
                    {
                        sdi.mask = SDI_PARAM | SDI_STR;
                        sdi.relativeID = pCookie->GetID();
                    }
#else
                    sdi.mask = SDI_PARAM | SDI_STR;
                    sdi.relativeID = pCookie->GetID();
#endif
                    sdi.displayname = MMC_CALLBACK;
                    sdi.nImage = FOLDER_ICON;
                    sdi.nOpenImage = OPEN_FOLDER_ICON;
                    sdi.lParam = reinterpret_cast<LONG>(pNewCookie);
                    hr = m_spScope->InsertItem(&sdi);
                    ASSERT(SUCCEEDED(hr));

                    pNewCookie->SetID(sdi.ID);

                    //m_spConsole->SelectScopeItem(sdi.ID);
                }
            }

        }

        break;
    }
    default:
        ASSERT(FALSE);
    }


    return S_OK;
}


void CComponentData::_OnDelete(LPDATAOBJECT lpDataObject)
{
    IEnumCookiesPtr spEnum = lpDataObject;
    ASSERT(spEnum != NULL);
    if (spEnum == NULL)
        return;

    CCookie* pCookie = NULL;
    spEnum->Reset();
    HRESULT hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookie), NULL);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return;

    ASSERT(pCookie != NULL);
    if (pCookie == NULL)
        return;

#if DBG==1
    CCookie* pCookieNext = NULL;
    hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookieNext), NULL);
    ASSERT(hr == S_FALSE);
#endif

    CString str;
    GetFullPath(pCookie->GetName(), (HSCOPEITEM)pCookie->GetID(), str);

    OnDelete((LPCTSTR)str, pCookie->GetID());
}

void CComponentData::OnDelete(LPCTSTR pszDir, long id)
{
    Dbg(DEB_USER14, _T("Deleting <%s> \n"), pszDir);

    ASSERT(m_spScope != NULL);
    if (::RemoveDirectory(pszDir) != 0)
    {
        m_spScope->DeleteItem(id, TRUE);
    }
    else if (GetLastError() == ERROR_DIR_NOT_EMPTY)
    {
        TCHAR buf[500];
        wsprintf(buf, _T("%s directory is not empty"), pszDir);
        ::AfxMessageBox(buf);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }
}

void CComponentData::_OnRemoveChildren(HSCOPEITEM hSI)
{
    CCookie* pCookie;
    HRESULT hr = m_spScope->GetChildItem(hSI, &hSI,
                                         reinterpret_cast<long*>(&pCookie));
    if (FAILED(hr))
        return;

    if (pCookie)
        pCookie->Release();

    _OnRemoveChildren(hSI);

    while (hSI)
    {
        hr = m_spScope->GetNextItem(hSI, &hSI,
                                    reinterpret_cast<long*>(&pCookie));
        if (FAILED(hr))
            break;

        _OnRemoveChildren(hSI);

        if (pCookie)
            pCookie->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\compdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       compdata.h
//
//--------------------------------------------------------------------------

// CompData.h : Declaration of the CComponentData

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include "resource.h"       // main symbols

class CCookie;

/////////////////////////////////////////////////////////////////////////////
// CComponentData
class ATL_NO_VTABLE CComponentData : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CComponentData, &CLSID_ComponentData>,
    public IComponentData,
    public IExtendContextMenu
{
public:
    CComponentData();
    ~CComponentData();

DECLARE_REGISTRY_RESOURCEID(IDR_COMPDATA)
DECLARE_NOT_AGGREGATABLE(CComponentData)

BEGIN_COM_MAP(CComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()

// IComponentData interface members
public:
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);       
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, 
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    LPCTSTR GetRootDir()
    {
        return m_strRootDir;
    }

    void GetFullPath(LPCTSTR pszFolderName, HSCOPEITEM hScopeItem, CString& strDir);
    void OnDelete(LPCTSTR pszDir, long id);

private:
    IConsolePtr                 m_spConsole;
    IConsoleNameSpacePtr        m_spScope;
    CString                     m_strRootDir;
    CCookie*                    m_pCookieRoot; 

    void _FreeFolderCookies(HSCOPEITEM hSI);
    void _OnDelete(LPDATAOBJECT lpDataObject);
    void _OnRemoveChildren(HSCOPEITEM hSI);
    HRESULT _EnumerateFolders(CCookie* pCookie);
    HRESULT _OnExpand(LPDATAOBJECT lpDataObject, LONG arg, LONG param);
    CCookie* _FindCookie(LPTSTR pszName);
    CCookie* _GetCookie(HSCOPEITEM hSI);
};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\compont.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       compont.h
//
//--------------------------------------------------------------------------

// Compont.h : Declaration of the CComponent

#ifndef __COMPONT_H_
#define __COMPONT_H_

#include "resource.h"       // main symbols

class CComponentData;

/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponent : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IComponent
{
public:
    CComponent() : m_pComponentData(NULL), m_pCookieCurFolder(NULL), 
                   m_hSICurFolder(NULL)
    {
    }

    ~CComponent()
    {
        ASSERT(m_spConsole == NULL);    
        ASSERT(m_spScope == NULL);      
        ASSERT(m_spConsoleVerb == NULL);
        ASSERT(m_spResult == NULL);     
        ASSERT(m_spHeader == NULL);     
        ASSERT(m_spImageResult == NULL);

        m_pComponentData = NULL; // No need to delete this.
    }

DECLARE_REGISTRY_RESOURCEID(IDR_COMPONT)
DECLARE_NOT_AGGREGATABLE(CComponent)

BEGIN_COM_MAP(CComponent)
    COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHOD(Destroy)(long cookie);
    STDMETHOD(GetResultViewType)(long cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    void SetComponentData(CComponentData* pCCD)
    {
        m_pComponentData = pCCD;
    }

private:
    CComponentData*         m_pComponentData;

    IConsolePtr             m_spConsole;
    IConsoleNameSpacePtr    m_spScope;
    IConsoleVerbPtr         m_spConsoleVerb;
    IResultDataPtr          m_spResult;
    IHeaderCtrlPtr          m_spHeader;
    IImageListPtr           m_spImageResult;

	CCookie*                m_pCookieCurFolder;
    HSCOPEITEM              m_hSICurFolder;

    void _InitializeHeaders();
    void _FreeFileCookies(HSCOPEITEM hSI);
	void _OnDelete(LPDATAOBJECT lpDataObject);
    void _HandleStandardVerbs(WORD bScope, WORD bSelect, LPDATAOBJECT lpDataObject);
    HRESULT _EnumerateFiles(CCookie* pCookie);
    HRESULT _OnAddImages(IImageList* pIL);
    HRESULT _OnShow(LPDATAOBJECT lpDataObject, LONG arg, LONG param);
    HRESULT _OnUpdateView(SUpadteInfo* pUI);
    HRESULT _OnQueryPaste(LPDATAOBJECT lpDataObject, LPDATAOBJECT lpDataObjectSrc);
    HRESULT _OnPaste(LPDATAOBJECT lpDataObject, LPDATAOBJECT lpDataObjectSrc, long param);
    HRESULT _OnMultiSelPaste(IEnumCookies* pEnumDest, IEnumCookies* pEnumSrc, 
                             LPDATAOBJECT* ppDO);
    HRESULT _PasteHdrop(CCookie* pCookieDest, LPDATAOBJECT lpDataObject, 
                        LPDATAOBJECT lpDataObjectSrc);

};  // class CComponent


#endif //__COMPONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\compont.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       compont.cpp
//
//--------------------------------------------------------------------------

// Compont.cpp : Implementation of CComponent
#include "stdafx.h"
#include "CompData.h"
#include "Compont.h"
#include "dataobj.h"
#include "cookie.h"
#include "resource.h"


enum
{
    COLUMN_NAME = 0,
    COLUMN_SIZE = 1,
    COLUMN_TYPE = 2,
    COLUMN_MODIFIED = 3,
    COLUMN_ATTRIBUTES = 4,
};


LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) && pPath[1] && (pPath[1] != TEXT('\\')))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}

/////////////////////////////////////////////////////////////////////////////
// CComponent

STDMETHODIMP CComponent::Initialize(LPCONSOLE lpConsole)
{
    m_spConsole = lpConsole;
    ASSERT(m_spConsole != NULL);

    m_spScope = lpConsole;
    ASSERT(m_spScope != NULL);

    m_spResult = lpConsole;
    ASSERT(m_spResult != NULL);

    m_spImageResult = lpConsole;
    ASSERT(m_spImageResult != NULL);

    m_spHeader = lpConsole;
    ASSERT(m_spHeader != NULL);

    HRESULT hr = lpConsole->QueryConsoleVerb(&m_spConsoleVerb);
    ASSERT(SUCCEEDED(hr));
    ASSERT(m_spConsoleVerb != NULL);

    return S_OK;
}

STDMETHODIMP CComponent::Notify(LPDATAOBJECT lpDataObject, 
                                MMC_NOTIFY_TYPE event, long arg, long param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

//  if (event == MMCN_PROPERTY_CHANGE)
//  {
//      hr = OnPropertyChange(lpDataObject);
//  }
//  else 
   if (event == MMCN_VIEW_CHANGE)
    {
        hr = _OnUpdateView(reinterpret_cast<SUpadteInfo*>(arg));
    }
    else
    {
        switch(event)
        {
        case MMCN_ACTIVATE:
            break;

        case MMCN_CLICK:
            ::AfxMessageBox(_T("CSnapin::MMCN_CLICK"));
            break;

        case MMCN_DBLCLICK:
            ::AfxMessageBox(_T("CSnapin::MMCN_DBLCLICK"));
            //hr = OnResultItemClkOrDblClk(pInternal->m_type, cookie, 
            //                             (event == MMCN_DBLCLICK));
            break;

        case MMCN_ADD_IMAGES:
            _OnAddImages(reinterpret_cast<IImageList*>(arg));
            break;

        case MMCN_SHOW:
            hr = _OnShow(lpDataObject, arg, param);
            break;

        case MMCN_SELECT:
            _HandleStandardVerbs(LOWORD(arg), HIWORD(arg), lpDataObject);            
            break;

        case MMCN_BTN_CLICK:
            AfxMessageBox(_T("CSnapin::MMCN_BTN_CLICK"));
            break;

        case MMCN_CUTORMOVE:
            _OnDelete(reinterpret_cast<IDataObject*>(arg));
            break;

      case MMCN_DELETE:
         _OnDelete(lpDataObject);
         break;

        case MMCN_QUERY_PASTE:
            hr = _OnQueryPaste(lpDataObject, reinterpret_cast<IDataObject*>(arg));
            Dbg(DEB_ERROR, _T("--------------> _OnQueryPaste returned = %d\n"), hr);
            break;

        case MMCN_PASTE:
            hr = _OnPaste(lpDataObject, reinterpret_cast<IDataObject*>(arg), param);
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }
    }

    return hr;
}


HRESULT CComponent::_OnQueryPaste(LPDATAOBJECT lpDataObject, 
                                  LPDATAOBJECT lpDataObjectSrc)
{
    IEnumCookiesPtr spEnumDest = lpDataObject;
    ASSERT(spEnumDest != NULL);
    if (spEnumDest == NULL)
    {
        Dbg(DEB_ERROR, _T("             Dest is NOT a FSSNAPIN dataobject. \n"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    IEnumCookiesPtr spEnumSrc = lpDataObjectSrc;
    if (spEnumSrc == NULL)
    {
        Dbg(DEB_ERROR, _T("             Sources is NOT a FSSNAPIN dataobject. \n"));
        
        FORMATETC fmt;
        ZeroMemory(&fmt, sizeof(fmt));
        fmt.dwAspect = DVASPECT_CONTENT;
        fmt.cfFormat = CF_HDROP;
        fmt.tymed = TYMED_HGLOBAL;
        hr = lpDataObjectSrc->QueryGetData(&fmt);
        return hr;
    }
    
    if (spEnumSrc->IsMultiSelect() == S_OK)
    {
        if (spEnumSrc->HasFiles() == S_OK) 
            return S_OK;
    }
    else
    {
        CCookie* pCookieSrc = NULL;
        spEnumSrc->Reset();
        hr = spEnumSrc->Next(1, reinterpret_cast<long*>(&pCookieSrc), NULL);
        ASSERT(SUCCEEDED(hr));
        if (hr != S_OK)
        {
            Dbg(DEB_ERROR, _T("             FSSNAPIN dataobject has NO data. \n"));
            return hr;
        }
        ASSERT(pCookieSrc != NULL);
        if (!pCookieSrc)
            return E_UNEXPECTED;
    
        if (pCookieSrc->IsFile() == TRUE)
            return S_OK;
    }

    return S_FALSE;
}

HRESULT 
CComponent::_PasteHdrop(
    CCookie* pCookieDest, 
    LPDATAOBJECT lpDataObject, 
    LPDATAOBJECT lpDataObjectSrc)
{
    FORMATETC fmt;
    ZeroMemory(&fmt, sizeof(fmt));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.cfFormat = CF_HDROP;
    fmt.tymed = TYMED_HGLOBAL;

    STGMEDIUM stgm;
    ZeroMemory(&stgm, sizeof(stgm));
    //stgm.tymed = TYMED_HGLOBAL;
    HRESULT hr = lpDataObjectSrc->GetData(&fmt, &stgm);
    if (FAILED(hr))
        return hr;

    CString strDest;
    m_pComponentData->GetFullPath(pCookieDest->GetName(), 
                                  (HSCOPEITEM)pCookieDest->GetID(), strDest);
    strDest += _T('\\');
    TCHAR szFileTo[MAX_PATH+1];
    UINT cchDest = strDest.GetLength();


    HDROP hdrop = (HDROP)stgm.hGlobal;
    UINT cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);
    TCHAR szFileFrom[MAX_PATH+1];
    UINT cchFileFrom = ARRAYLEN(szFileFrom);


    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_PARAM | RDI_STR | RDI_IMAGE;
    rdi.nImage = (int)MMC_CALLBACK;
    rdi.str = MMC_CALLBACK;

    for (UINT i = 0; i < cFiles; i++)
    {
        DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);
    
        LPTSTR pszName = PathFindFileName(szFileFrom);
        szFileTo[cchDest] = _T('\0');
        lstrcpy(szFileTo, pszName);

        if (::CopyFile(szFileFrom, szFileTo, FALSE) != 0)
        {
            DWORD dw = GetFileAttributes(szFileTo);
            BYTE bType = (dw & FILE_ATTRIBUTE_DIRECTORY) ? 
                            FOLDER_COOKIE : FILE_COOKIE;

            CCookie* pCookie = new CCookie(bType); 
            pCookie->SetName(pszName);

            rdi.lParam = reinterpret_cast<LONG>(pCookie);
            hr = m_spResult->InsertItem(&rdi);
            ASSERT(SUCCEEDED(hr));

            pCookie->SetID(rdi.itemID);
        }
        else 
        {
            ASSERT(0);
            DBG_OUT_LASTERROR;
        }
    }

    return S_OK;
}

HRESULT CComponent::_OnPaste(LPDATAOBJECT lpDataObject, 
                             LPDATAOBJECT lpDataObjectSrc, long param)
{
    IEnumCookiesPtr spEnumDest = lpDataObject;
    ASSERT(spEnumDest != NULL);
    if (spEnumDest == NULL)
        return E_INVALIDARG;

    CCookie* pCookieDest = NULL;
    spEnumDest->Reset();
    HRESULT hr = spEnumDest->Next(1, reinterpret_cast<long*>(&pCookieDest), NULL);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    ASSERT(pCookieDest != NULL);
    if (!pCookieDest)
        return E_UNEXPECTED;
    

    IEnumCookiesPtr spEnumSrc = lpDataObjectSrc;
    ASSERT(spEnumSrc != NULL);
    if (spEnumSrc == NULL)
    {
        // must be CF_HDROP
        _PasteHdrop(pCookieDest, lpDataObject, lpDataObjectSrc);
    }

    if (spEnumSrc->IsMultiSelect() == S_OK)
    {
        hr = _OnMultiSelPaste(spEnumDest, spEnumSrc, 
                         reinterpret_cast<LPDATAOBJECT*>(param));
        return hr;
    }
    
    ASSERT(pCookieDest->IsFolder() == TRUE);
    if (pCookieDest->IsFolder() != TRUE)
        return E_UNEXPECTED;
    

    CCookie* pCookieSrc = NULL;
    spEnumSrc->Reset();
    hr = spEnumSrc->Next(1, reinterpret_cast<long*>(&pCookieSrc), NULL);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    ASSERT(pCookieSrc != NULL);
    if (!pCookieSrc)
        return E_UNEXPECTED;

    CCookie* pCookieSrcParent = NULL;
    ASSERT(pCookieSrc->IsFile() == TRUE);
    if (pCookieSrc->IsFile() != TRUE)
    {
        return E_UNEXPECTED;
    }
    else 
    {
        hr = spEnumSrc->GetParent(reinterpret_cast<long*>(&pCookieSrcParent));
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }

    CString strSrc;
    m_pComponentData->GetFullPath(pCookieSrcParent->GetName(), 
                                  (HSCOPEITEM)pCookieSrcParent->GetID(), strSrc);
    strSrc += _T('\\');
    strSrc += pCookieSrc->GetName();


    CString strDest;
    m_pComponentData->GetFullPath(pCookieDest->GetName(), 
                                  (HSCOPEITEM)pCookieDest->GetID(), strDest);
    strDest += _T('\\');
    strDest += pCookieSrc->GetName();

    if (::CopyFile(strSrc, strDest, FALSE) != 0)
    {
        if (param)
            *((LPDATAOBJECT*)param) = lpDataObjectSrc;
    }
    else 
    {
        ASSERT(0);
        DBG_OUT_LASTERROR;
    }

    return S_OK;
}


HRESULT 
CComponent::_OnMultiSelPaste(
    IEnumCookies* pEnumDest, 
    IEnumCookies* pEnumSrc, 
    LPDATAOBJECT* ppDO)
{
    CCookie* pCookieDest = NULL;
    pEnumDest->Reset();
    HRESULT hr = pEnumDest->Next(1, reinterpret_cast<long*>(&pCookieDest), NULL);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;
    ASSERT(pCookieDest != NULL);
    if (!pCookieDest)
        return E_UNEXPECTED;
    ASSERT(pCookieDest->IsFolder() == TRUE);
    if (pCookieDest->IsFolder() != TRUE)
        return E_UNEXPECTED;


    CCookie* pCookieSrcParent = NULL;
    hr = pEnumSrc->GetParent(reinterpret_cast<long*>(&pCookieSrcParent));
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CString str;

    m_pComponentData->GetFullPath(pCookieSrcParent->GetName(), 
                                  (HSCOPEITEM)pCookieSrcParent->GetID(), str);
    str += _T('\\');
    UINT cchSrc = str.GetLength();
    TCHAR bufSrc[1024];
    lstrcpy(bufSrc, str);


    m_pComponentData->GetFullPath(pCookieDest->GetName(), 
                                  (HSCOPEITEM)pCookieDest->GetID(), str);
    str += _T('\\');
    UINT cchDest = str.GetLength();
    TCHAR bufDest[1024];
    lstrcpy(bufDest, str);


    pEnumSrc->Reset();
    CArray<CCookie*, CCookie*> rgCookiesCopied;

    do
    {
        CCookie* pCookieSrc = NULL;
        hr = pEnumSrc->Next(1, reinterpret_cast<long*>(&pCookieSrc), NULL);
        ASSERT(SUCCEEDED(hr));
        if (hr != S_OK)
            break;
        ASSERT(pCookieSrc != NULL);
        if (!pCookieSrc || pCookieSrc->GetType() == FOLDER_COOKIE)
            continue;
        
        bufSrc[cchSrc] = _T('\0');
        lstrcat(bufSrc, pCookieSrc->GetName());
    
        bufDest[cchDest] = _T('\0');
        lstrcat(bufDest, pCookieSrc->GetName());
    
        if (::CopyFile(bufSrc, bufDest, FALSE) != 0)
        {
            if (ppDO)
                rgCookiesCopied.Add(pCookieSrc);
        }
        else 
        {
            ASSERT(0);
            DBG_OUT_LASTERROR;
        }

    } while (1);

    if (ppDO == NULL)
        return S_OK;

    *ppDO = NULL;
    if (rgCookiesCopied.GetSize() == 0)
        return S_FALSE;


    CComObject<CDataObject>* pObject;
    hr = CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr)) 
        return hr;

    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return E_OUTOFMEMORY;

    pObject->SetParentFolder(pCookieSrcParent);
    pObject->SetHasFiles();
    for (int i=0; i < rgCookiesCopied.GetSize(); ++i)
    {
        pObject->AddCookie(rgCookiesCopied[i]);
    }

    hr = pObject->QueryInterface(IID_IDataObject,
                                 reinterpret_cast<void**>(ppDO));
    return hr;
}

void CComponent::_HandleStandardVerbs(WORD bScope, WORD bSelect, 
                                      LPDATAOBJECT lpDataObject)
{
    ASSERT(m_spConsoleVerb != NULL);

    if (!bSelect)
    {
        m_spConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
        m_spConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
        m_spConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);

        m_spConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);

        m_spConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, FALSE);
        m_spConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);

        return;
    }

    m_spConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
    m_spConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

    if (bScope)
    {
        ASSERT(bSelect);
        
        m_spConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, FALSE);
        m_spConsoleVerb->SetVerbState(MMC_VERB_OPEN, ENABLED, TRUE);

        m_spConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, FALSE);
        m_spConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);

        m_spConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else 
    {
        ASSERT(bSelect);

        bool bItemIsFolder = ::IsFolder(lpDataObject);
            
        if (bItemIsFolder)
        {
            m_spConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, FALSE);
            m_spConsoleVerb->SetVerbState(MMC_VERB_OPEN, ENABLED, TRUE);
    
            m_spConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, FALSE);
            m_spConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);
    
            m_spConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
        }
        else 
        {
            IEnumCookiesPtr spEnumDest = lpDataObject;
            ASSERT(spEnumDest != NULL);
            
            if (spEnumDest->IsMultiSelect() == S_OK)
            {
                if (spEnumDest->HasFiles() == S_OK)
                {
                    m_spConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
                    m_spConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);
                }
            }
            else 
            {
                m_spConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
                m_spConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);
            }

            m_spConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);
        }
    }
}

STDMETHODIMP CComponent::Destroy(long cookie)
{
    if (m_hSICurFolder)
    {
        m_pCookieCurFolder = NULL;
        m_hSICurFolder = NULL;
    }

    m_spConsole.Release();
    m_spScope.Release();
    m_spResult.Release();
    m_spImageResult.Release();
    m_spHeader.Release();
    m_spConsoleVerb.Release();
    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(long cookie,  LPOLESTR* ppViewType,
                                           long* pViewOptions)
{
    if (!pViewOptions)
        return E_POINTER;
    
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    return S_FALSE;
}

STDMETHODIMP CComponent::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, 
                                         LPDATAOBJECT* ppDataObject)
{
   ASSERT(cookie != 0);
   if (cookie == 0)
      return E_INVALIDARG;

    CComObject<CDataObject>* pObject;
    HRESULT hr = CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr)) 
        return hr;

    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return E_FAIL;

    pObject->Init(FALSE, m_pComponentData);
    ASSERT(m_pCookieCurFolder != NULL);
    pObject->SetParentFolder(m_pCookieCurFolder);


    if (IS_SPECIAL_COOKIE(cookie))
    {
        if (cookie == MMC_MULTI_SELECT_COOKIE)
        {
            RESULTDATAITEM rdi;
            ZeroMemory(&rdi, sizeof(rdi));
            rdi.mask = RDI_STATE;
            rdi.nIndex = -1;
            rdi.nState = LVIS_SELECTED;
            bool bFiles = false;
            bool bFolders = false;
            
            do
            {
                rdi.lParam = 0;
                ASSERT(rdi.mask == RDI_STATE);
                ASSERT(rdi.nState == LVIS_SELECTED);
                hr = m_spResult->GetNextItem(&rdi);
                if (hr != S_OK)
                    break;
                
                CCookie* pCookie = reinterpret_cast<CCookie*>(rdi.lParam);

                try
                {
                    if (pCookie->GetType() == FOLDER_COOKIE)
                        bFolders = true;
                    if (pCookie->GetType() == FILE_COOKIE)
                        bFiles = true;
                }
                catch (...)
                {
                    hr = E_INVALIDARG;
                }

                ASSERT(SUCCEEDED(hr));
                if (SUCCEEDED(hr))
                    pObject->AddCookie(pCookie);

            } while (1);

            if (bFolders)
                pObject->SetHasFolders();

            if (bFiles)
                pObject->SetHasFiles();
        }
    }
    else 
    {
      CCookie* pCookie = reinterpret_cast<CCookie*>(cookie);
      ASSERT(pCookie->GetType() == FILE_COOKIE);
      if (pCookie->GetType() != FILE_COOKIE)
         return E_INVALIDARG;
    
        pObject->AddCookie(pCookie);
    }

    return pObject->QueryInterface(IID_IDataObject,
                                   reinterpret_cast<void**>(ppDataObject));
}

STDMETHODIMP CComponent::GetDisplayInfo(RESULTDATAITEM*  pResult)
{
    static TCHAR* s_szSize = _T("200");
    
    ASSERT(pResult != NULL);
 
    if (pResult)
    {
        CCookie* pCookie = reinterpret_cast<CCookie*>(pResult->lParam);
    
        if (pResult->mask & RDI_STR)
        {
            switch (pResult->nCol)
            {
            case COLUMN_NAME:
                pResult->str = pCookie->GetName();
                break;

            case COLUMN_SIZE:
                pResult->str = (LPOLESTR)s_szSize;
                break;

            case COLUMN_TYPE:
                pResult->str = pCookie->IsFile() ? _T("File") : _T("Folder");
                break;

            case COLUMN_MODIFIED:
                pResult->str = _T("NYI");
                break;

            case COLUMN_ATTRIBUTES:
                pResult->str = _T("NYI");
                break;
            }

            ASSERT(pResult->str != NULL);
        }

        if (pResult->mask & RDI_IMAGE)
            pResult->nImage = pCookie->IsFile() ? FILE_ICON : FOLDER_ICON;
    }

    return S_OK;
}

STDMETHODIMP CComponent::CompareObjects(LPDATAOBJECT lpDataObjectA, 
                                        LPDATAOBJECT lpDataObjectB)
{
    return S_OK;
}


HRESULT CComponent::_OnUpdateView(SUpadteInfo* pUI)
{
    ASSERT(pUI != NULL);
    if (pUI == NULL)
        return E_POINTER;
    
    ASSERT(pUI->m_files[0] != NULL);
    if (pUI->m_files[0] == NULL)
        return E_INVALIDARG;
    
    // Process only if it is currently selected.
    if (m_pCookieCurFolder->GetID() != (long)pUI->m_hSIParent)
        return S_FALSE;

    if (pUI->m_bCreated == TRUE)
    {
        // Add a result item for the file
        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));

        rdi.mask = RDI_PARAM | RDI_STR | RDI_IMAGE;
        rdi.nImage = (int)MMC_CALLBACK;
        rdi.str = MMC_CALLBACK;
        CCookie* pNewCookie = new CCookie(FILE_COOKIE); 
        pNewCookie->SetName(pUI->m_files[0]);

        rdi.lParam = reinterpret_cast<LONG>(pNewCookie);

        HRESULT hr = m_spResult->InsertItem(&rdi);
        ASSERT(SUCCEEDED(hr));

        pNewCookie->SetID(rdi.itemID);
    }
    else 
    {
        ASSERT(0 && "Not yet tested");

        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));

        rdi.mask = RDI_PARAM;
        rdi.nIndex = -1;
        rdi.nState = LVNI_ALL;
    
        while (1)
        {
            HRESULT hr = m_spResult->GetNextItem(&rdi);
            if (hr != S_OK)
                break;
    
            CCookie* pCookie = reinterpret_cast<CCookie*>(rdi.lParam);
            ASSERT(pUI->m_files[0] != NULL);
            if (lstrcmp(pCookie->GetName(), pUI->m_files[0]) == 0)
            {
                HRESULT hr = m_spResult->DeleteItem(rdi.itemID, 0);
                ASSERT(SUCCEEDED(hr));
                pCookie->Release();
            }
        }
    }

    return S_OK;
}

HRESULT CComponent::_OnAddImages(IImageList* pIL)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(pIL != NULL);
    ASSERT(m_spImageResult != NULL);

    CBitmap bmp16x16;
    CBitmap bmp32x32;

    // Load the bitmaps from the dll
    VERIFY(bmp16x16.LoadBitmap(IDB_16x16) != 0);
    VERIFY(bmp32x32.LoadBitmap(IDB_32x32) != 0);

    // Set the images
    m_spImageResult->ImageListSetStrip(reinterpret_cast<long*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<long*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255, 0, 255));

    if (pIL != m_spImageResult)
    {
        pIL->ImageListSetStrip(reinterpret_cast<long*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<long*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255, 0, 255));
    }


    return S_OK;
}

HRESULT CComponent::_OnShow(LPDATAOBJECT lpDataObject, LONG arg, LONG param)
{
    if (arg == 0)
    {
        ASSERT(m_hSICurFolder == (HSCOPEITEM)param);
        _FreeFileCookies(m_hSICurFolder);
        m_pCookieCurFolder = NULL;
        m_hSICurFolder = NULL;

        m_spResult->SetDescBarText(_T(" "));
    }
    else 
    {
        ASSERT(m_hSICurFolder == 0);

        _InitializeHeaders();

        // GetCookie (F)
        //

        IEnumCookiesPtr spEnum = lpDataObject;
        ASSERT(spEnum != NULL);
        if (spEnum == NULL)
            return E_INVALIDARG;

        CCookie* pCookie = NULL;
        spEnum->Reset();
        HRESULT hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookie), NULL);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;

        ASSERT(pCookie != NULL);
        if (pCookie == NULL)
            return E_FAIL;

        ASSERT(pCookie->IsFolder() == TRUE);
        if (pCookie->IsFolder() == FALSE)
            return E_FAIL;

        m_hSICurFolder = (HSCOPEITEM)param;
        m_pCookieCurFolder = pCookie;
        if (m_pCookieCurFolder->GetID() == 0)
            m_pCookieCurFolder->SetID(param); //m_hScopeItemCurr = (HSCOPEITEM)param;
        
        ASSERT(m_pCookieCurFolder->GetID() == param);

        _EnumerateFiles(pCookie);

        m_spResult->SetDescBarText(pCookie->GetName());
    }

    return S_OK;
}

void CComponent::_InitializeHeaders()
{
    ASSERT(m_spHeader != NULL);

    // Put the correct headers depending on the cookie
    // Note - cookie ignored for this sample
    m_spHeader->InsertColumn(0, _T("Name"), LVCFMT_LEFT, 120);     
    m_spHeader->InsertColumn(1, _T("Size"), LVCFMT_RIGHT, 30);     
    m_spHeader->InsertColumn(2, _T("Type"), LVCFMT_LEFT, 50);     
    m_spHeader->InsertColumn(3, _T("Modified"), LVCFMT_LEFT, 100); 
    m_spHeader->InsertColumn(4, _T("Attributes"), LVCFMT_RIGHT, 40);
}

HRESULT CComponent::_EnumerateFiles(CCookie* pCookie)
{
   ASSERT(pCookie != NULL);
   if (pCookie == NULL)
      return E_UNEXPECTED;

    ASSERT(m_pComponentData != NULL);
    if (m_pComponentData == NULL)
        return E_UNEXPECTED;
    
    CString strDir;
    m_pComponentData->GetFullPath(pCookie->GetName(), (HSCOPEITEM)pCookie->GetID(), strDir);

    strDir += _T("\\*");

    WIN32_FIND_DATA fd;
    ZeroMemory(&fd, sizeof(fd));
    HANDLE hFind = FindFirstFile(strDir, &fd);

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));

    rdi.mask = RDI_PARAM | RDI_STR | RDI_IMAGE;
    rdi.nImage = (int)MMC_CALLBACK;
    rdi.str = MMC_CALLBACK;

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do 
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                continue;
            }
            
            CCookie* pCookie = new CCookie(FILE_COOKIE); 
            pCookie->SetName(fd.cFileName);

            rdi.lParam = reinterpret_cast<LONG>(pCookie);
            HRESULT hr = m_spResult->InsertItem(&rdi);
            ASSERT(SUCCEEDED(hr));

            pCookie->SetID(rdi.itemID);
    
        } while (FindNextFile(hFind, &fd) == TRUE);

        FindClose(hFind);
    }

    return S_OK;
}


void CComponent::_FreeFileCookies(HSCOPEITEM hSI)
{
    ASSERT(m_spResult != NULL);

    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    HRESULT hr S_OK;

    rdi.mask = RDI_PARAM | RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = LVNI_ALL;

    while (1)
    {
        hr = m_spResult->GetNextItem(&rdi);
        if (hr != S_OK)
            break;

        CCookie* pCookie = reinterpret_cast<CCookie*>(rdi.lParam);
        if (pCookie->IsFile() == TRUE)
            pCookie->Release();
    }
}

void CComponent::_OnDelete(LPDATAOBJECT lpDataObject)
{
    IEnumCookiesPtr spEnum = lpDataObject;
    ASSERT(spEnum != NULL);
    if (spEnum == NULL)
        return;

    CCookie* pCookieParent = NULL;
    HRESULT hr = spEnum->GetParent(reinterpret_cast<long*>(&pCookieParent));
    if (FAILED(hr))
        return;
    ASSERT(pCookieParent != NULL);
    if (!pCookieParent)
        return;
    ASSERT(pCookieParent->GetType() == FOLDER_COOKIE);
    if (pCookieParent->GetType() != FOLDER_COOKIE)
        return;
    
   CString str;
   m_pComponentData->GetFullPath(pCookieParent->GetName(), 
                              (HSCOPEITEM)pCookieParent->GetID(), str);
   str += _T('\\');
    UINT cchParent = str.GetLength();
    TCHAR buf[1024];
    lstrcpy(buf, str);

    CCookie* pCookie = NULL;
    spEnum->Reset();

    do
    {
        hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookie), NULL);
        ASSERT(SUCCEEDED(hr));
        if (hr != S_OK)
            break;
    
        ASSERT(pCookie != NULL);
        if (pCookie != NULL)
        {
            buf[cchParent] = _T('\0');
            lstrcat(buf, pCookie->GetName());
        
            if (pCookie->GetType() == FOLDER_COOKIE)
            {
                m_pComponentData->OnDelete((LPCTSTR)buf, pCookie->GetID());
            }
            else 
            {
                Dbg(DEB_USER14, _T("Deleting <%s> \n"), buf);
            
                ASSERT(m_spResult != NULL);
                if (::DeleteFile((LPCTSTR)buf) != 0)
                    m_spResult->DeleteItem(pCookie->GetID(), 0);
            }
            pCookie->Release();
        }

    } while (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\cookie.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cookie.h
//
//--------------------------------------------------------------------------


#ifndef COOKIE_H___
#define COOKIE_H___

#define FOLDER_COOKIE       1
#define FILE_COOKIE         2


extern long g_cookieCount;
extern int cookie_id;
extern int iDbg;

class CCookie
{
    int m_cookie_id;
public:
    CCookie(BYTE type)
        : m_cRef(1), m_cookieType(type), m_bExpanded(FALSE), 
          m_lID(0), m_pszName(NULL), m_cookie_id(++cookie_id)
    {
        ++g_cookieCount;
    }

    void Release()
    {
        ASSERT(m_cRef > 0);
        --m_cRef;
        if (m_cRef == 0)
            delete this;
    }

    void AddRef()
    {
        ASSERT(m_cRef > 0);
        ++m_cRef;
    }
    
    LPWSTR SetName(LPWSTR pszName)
    {
        ASSERT(pszName != NULL);
        if (m_pszName)
            delete [] m_pszName;

        m_pszName = NewDupString(pszName);

        Dbg(DEB_USER1, _T("\t**** %3d> SetName cookie %d = %s\n"), ++iDbg, m_cookie_id, m_pszName);

        return m_pszName;
    }
    
    LPWSTR GetName()
    {
        ASSERT(m_pszName != NULL);
        return m_pszName;
    }

    BOOL IsFolder()
    {
        return ((m_cookieType & FOLDER_COOKIE) == FOLDER_COOKIE);
    }

    BOOL IsFile()
    {
        return ((m_cookieType & FILE_COOKIE) == FILE_COOKIE);
    }
    
    BYTE GetType()
    {
        return (BYTE)m_cookieType;
    }
    
    BOOL IsExpanded()
    {
        return m_bExpanded;
    }

    void SetExpanded(BYTE b)
    {
        m_bExpanded = b;
    }

    void SetID(long lID)
    {
        m_lID = lID;
    }

    long GetID()
    {
        return m_lID;
    }

    BOOL operator== (CCookie& rhs)
    {
        if (m_cookieType == rhs.m_cookieType)
            if (m_lID == rhs.m_lID)
                if (lstrcmp(m_pszName, rhs.m_pszName) == 0)
                    return TRUE;

        return FALSE;
    }

    BOOL operator== (LPWSTR pszName)
    {
        return (lstrcmp(m_pszName, pszName) == 0);
    }

    BOOL operator!= (LPWSTR pszName)
    {
        return (lstrcmp(m_pszName, pszName) != 0);
    }

private:
    BYTE        m_cookieType;
    BYTE        m_bExpanded;
    WORD        m_cRef;
    long        m_lID;    
    LPWSTR      m_pszName;

    ~CCookie()
    {
        Dbg(DEB_USER1, _T("\t**** %3d> Deleting cookie %d = %s\n"), ++iDbg, m_cookie_id, m_pszName);
        delete [] m_pszName;
        --g_cookieCount;
    }


}; // class CCookie


#endif // COOKIE_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\dataobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dataobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"
#include "dataobj.h"
#include "objfmts.h"
#include "compdata.h"

const GUID cNodeTypeFolder = {0x8394a514,0xe0f8,0x11d0,{0xa7,0xc3,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
const TCHAR* cszNodeTypeFolder = _T("{8394a514-e0f8-11d0-a7c3-00c04fd8d565}");

const GUID cNodeTypeFile   = {0x8394a515,0xe0f8,0x11d0,{0xa7,0xc3,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
const TCHAR* cszNodeTypeFile = _T("{8394a515-e0f8-11d0-a7c3-00c04fd8d565}");


CDataObject::CDataObject() : m_bForScopePane(0), m_iCurr(0),
                             m_pCookieParent(NULL)
{
}

CDataObject::~CDataObject()
{
    if (m_pCookieParent)
        m_pCookieParent->Release();

    for (int i=0; i < m_rgCookies.GetSize(); ++i)
    {
        m_rgCookies[i]->Release();
    }
}

void CDataObject::AddCookie(CCookie* pCookie)
{
    m_rgCookies.Add(pCookie);
    pCookie->AddRef();
}

void CDataObject::SetParentFolder(CCookie* pCookie)
{
    m_pCookieParent = pCookie;
    pCookie->AddRef();
}

// Clipboard formats that are required by the console
const CLIPFORMAT  g_cfNodeType            = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
const CLIPFORMAT  g_cfNodeTypeString      = (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);
const CLIPFORMAT  g_cfDisplayName         = (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
const CLIPFORMAT  g_cfCoClass             = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
const CLIPFORMAT  g_cfMultiSelObjTypes    = (CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
const CLIPFORMAT  g_cfPreferredDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetcIn->cfFormat;
    lpMedium->tymed = TYMED_HGLOBAL;

    if (cf == g_cfNodeType)
    {
        lpMedium->hGlobal = ::GlobalAlloc(GPTR, sizeof(GUID));
        hr = _CreateNodeTypeData(lpMedium);
    }
    else if (cf == g_cfCoClass)
    {
        lpMedium->hGlobal = ::GlobalAlloc(GPTR, sizeof(CLSID));
        hr = _CreateCoClassID(lpMedium);
    }
    else if (cf == g_cfNodeTypeString)
    {
        lpMedium->hGlobal = ::GlobalAlloc(GPTR, sizeof(WCHAR)*50);
        hr = _CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == g_cfDisplayName)
    {
        lpMedium->hGlobal = ::GlobalAlloc(GPTR, sizeof(WCHAR)*MAX_PATH);
        hr = _CreateDisplayName(lpMedium);
    }
    else if (cf == g_cfMultiSelObjTypes)
    {
        hr = _CreaateMultiSelObjTypes(lpMedium);
    }
    else if (cf == CF_HDROP)
    {
        hr = _CreateHDrop(lpMedium);
    }
    else if (cf == g_cfPreferredDropEffect)
    {
        DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
        if (!pdw)
            return E_OUTOFMEMORY;

        //*pdw = m_fCut ? DROPEFFECT_MOVE : DROPEFFECT_COPY;
        *pdw = DROPEFFECT_COPY;
        lpMedium->hGlobal = (HGLOBAL)pdw;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == g_cfNodeType)
    {
        hr = _CreateNodeTypeData(lpMedium);
    }
    else if (cf == g_cfCoClass)
    {
        hr = _CreateCoClassID(lpMedium);
    }
    else if(cf == g_cfNodeTypeString)
    {
        hr = _CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == g_cfDisplayName)
    {
        hr = _CreateDisplayName(lpMedium);
    }

    return hr;
}


STDMETHODIMP
CDataObject::EnumFormatEtc(
    DWORD dwDirection,
    LPENUMFORMATETC* ppEnumFormatEtc)
{
    if (dwDirection == DATADIR_SET)
        return E_FAIL;

    FORMATETC fmte[] = {
        {g_cfNodeType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {g_cfCoClass, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {g_cfNodeTypeString, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {g_cfDisplayName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {g_cfMultiSelObjTypes, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {g_cfPreferredDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    return ::GetObjFormats(ARRAYLEN(fmte), fmte, (void**)ppEnumFormatEtc);
}

STDMETHODIMP
CDataObject::QueryGetData(
    LPFORMATETC pfmt)
{
    //
    //  Check the aspects we support.
    //

    if (!(DVASPECT_CONTENT & pfmt->dwAspect))
        return DATA_E_FORMATETC;

    if (pfmt->cfFormat == g_cfNodeType)
        return S_OK;

    if (pfmt->cfFormat == g_cfCoClass)
        return S_OK;

    if (pfmt->cfFormat == g_cfNodeTypeString)
        return S_OK;

    if (pfmt->cfFormat == g_cfDisplayName)
        return S_OK;

    if (pfmt->cfFormat == g_cfMultiSelObjTypes)
        return S_OK;

    if (pfmt->cfFormat == CF_HDROP)
        return S_OK;

    if (pfmt->cfFormat == g_cfPreferredDropEffect)
        return S_OK;

    return S_FALSE;
}


HRESULT
CDataObject::_CreateHDrop(
    LPSTGMEDIUM lpMedium)
{
    HDROP hMem = 0;
    LPDROPFILES lpDrop = NULL;
    DWORD dwSize = 0;

    //
    //  Walk the list and find out how much space we need.
    //

    HRESULT hr = S_OK;
    ASSERT(m_pComponentData != NULL);
    ASSERT(m_rgCookies.GetSize() > 0);

    CCookie* pCookieParent = m_pCookieParent;
    if (pCookieParent == NULL)
    {
        ASSERT(m_bForScopePane);
        pCookieParent = m_rgCookies[0];
    }

    ASSERT(pCookieParent != NULL);
    if (!pCookieParent)
        return E_UNEXPECTED;

    CString strParent;
    m_pComponentData->GetFullPath(pCookieParent->GetName(),
                                  (HSCOPEITEM)pCookieParent->GetID(), strParent);
    strParent += _T('\\');
    UINT cchParent = strParent.GetLength();
    UINT cb = (cchParent + 1) * sizeof(TCHAR); // 1 for null char
    cb *= m_rgCookies.GetSize();

    for (int i=0; i < m_rgCookies.GetSize(); ++i)
    {
        cb += lstrlen(m_rgCookies[i]->GetName()) * sizeof(TCHAR);
    }

    cb += sizeof(DROPFILES);
    cb += sizeof(TCHAR); // for double terminating the end.
    cb += 50; // buffer for error!!!!!!

    //
    //  If it's bigger than the struct can hold, then bail.
    //  TODO: Return an error?
    //

    if (cb > 0x0000ffff)
        return E_FAIL;

    lpMedium->hGlobal = ::GlobalAlloc(GPTR, cb);
    if (!lpMedium->hGlobal)
        return E_OUTOFMEMORY;

    lpDrop = (LPDROPFILES)::GlobalLock(lpMedium->hGlobal);
    lpDrop->pFiles = (DWORD)(sizeof(DROPFILES));
    lpDrop->pt.x   = 0;
    lpDrop->pt.y   = 0;
    lpDrop->fNC    = FALSE;
#ifdef UNICODE
    lpDrop->fWide  = TRUE;
#else
    lpDrop->fWide  = FALSE;
#endif

    //
    //  Fill in the path names.
    //

    LPBYTE pbTemp = (LPBYTE) ((LPBYTE) lpDrop + lpDrop->pFiles);
    TCHAR* pch = (TCHAR*)pbTemp;

    for (i=0; i < m_rgCookies.GetSize(); ++i)
    {
        lstrcpy(pch, strParent);
        pch += cchParent;
        lstrcpy(pch, m_rgCookies[i]->GetName());
        pch += lstrlen(m_rgCookies[i]->GetName()) + 1;
    }

    *pch = _T('\0');

    return S_OK;
}

HRESULT CDataObject::_Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::_CreaateMultiSelObjTypes(LPSTGMEDIUM lpMedium)
{
    UINT cGuids = 0;
    if (m_bHasFiles)
        ++cGuids;

    if (m_bHasFolders)
        ++cGuids;

    UINT size = sizeof(SMMCObjectTypes) + (cGuids-1) * sizeof(GUID);
    lpMedium->hGlobal = ::GlobalAlloc(GPTR, size);
    if (!lpMedium->hGlobal)
        return E_OUTOFMEMORY;

    SMMCObjectTypes* pdata = reinterpret_cast<SMMCObjectTypes*>(lpMedium->hGlobal);
    pdata->count = cGuids;
    int i=0;
    if (m_bHasFiles)
        pdata->guid[i++] = cNodeTypeFile;

    if (m_bHasFolders)
        pdata->guid[i++] = cNodeTypeFolder;

    return S_OK;
}

HRESULT CDataObject::_CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    if (m_rgCookies.GetSize() > 1)
        return E_FAIL;

    // Create the node type object in GUID format
    const GUID* pNodeType = &cNodeTypeFolder;

    if (m_bForScopePane == FALSE)
    {
        ASSERT(m_rgCookies.GetSize() > 0);
        if (m_rgCookies[0]->IsFile() == TRUE)
            pNodeType = &cNodeTypeFile;
    }

    return _Create(reinterpret_cast<const void*>(pNodeType), sizeof(GUID),
                  lpMedium);
}

HRESULT CDataObject::_CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    if (m_rgCookies.GetSize() > 1)
        return E_FAIL;

    // Create the node type object in GUID string format
    const TCHAR* cszNodeType = cszNodeTypeFolder;

    if (m_bForScopePane == FALSE)
    {
        ASSERT(m_rgCookies.GetSize() > 0);
        if (m_rgCookies[0]->IsFile() == TRUE)
            cszNodeType = cszNodeTypeFolder;
    }

    return _Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(TCHAR)), lpMedium);
}

HRESULT CDataObject::_CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    if (m_rgCookies.GetSize() > 1)
        return E_FAIL;

    // This is the display named used in the scope pane and snap-in manager
    CString strName;

    if (m_bForScopePane == TRUE)
    {
        strName = _T("Explore <");
        strName += m_rgCookies[0]->GetName();
        strName += _T(">");
    }
    else if (m_rgCookies.GetSize() == 1)
    {
        strName = m_rgCookies[0]->GetName();
    }
    else
    {
        return E_FAIL;
    }

    return _Create(strName, ((strName.GetLength()+1) * sizeof(TCHAR)), lpMedium);
}

HRESULT CDataObject::_CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return _Create(reinterpret_cast<const void*>(&CLSID_ComponentData), sizeof(CLSID), lpMedium);
}


STDMETHODIMP CDataObject::Next(ULONG celt, long* rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;

    if ((rgelt == NULL) ||
        ((celt > 1) && (pceltFetched == NULL)))
    {
        hr = E_INVALIDARG;
        CHECK_HRESULT(hr);
        return hr;
    }

    ULONG celtTemp = m_rgCookies.GetSize() - m_iCurr;
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    if (pceltFetched)
        *pceltFetched = celtTemp;

    if (celtTemp == 0)
        return S_FALSE;

    for (ULONG i=0; i < celtTemp; ++i)
    {
        rgelt[i] = reinterpret_cast<long>(m_rgCookies[m_iCurr++]);
    }

    return (celtTemp < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CDataObject::Skip(ULONG celt)
{
    ULONG celtTemp = m_rgCookies.GetSize() - m_iCurr;
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    m_iCurr += celtTemp;

    return (celtTemp < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CDataObject::Reset(void)
{
    m_iCurr = 0;
    return S_OK;
}


STDMETHODIMP CDataObject::Clone(IEnumCookies** ppenum)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


IDataObject* GetDummyDataObject()
{
    CComObject<CDummyDataObject>* pObject;
    HRESULT hr = CComObject<CDummyDataObject>::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return NULL;

    ASSERT(pObject != NULL);
    if (pObject == NULL)
        return NULL;

    IDataObject* pDataObject = NULL;
    pObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(&pDataObject));
    return pDataObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\objfmts.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       objfmts.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/12/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef _OBJFMTS_H_
#define _OBJFMTS_H_


HRESULT GetObjFormats(UINT cfmt, FORMATETC *afmt, LPVOID *ppvObj);
HRESULT GetObjFormatsEx(IEnumFORMATETC* pEnum1, IEnumFORMATETC* pEnum2,
                        IEnumFORMATETC** ppEnumOut);


//____________________________________________________________________________
//
//  Class:      CObjFormats
//
//  Purpose:    Impements IEnumFORMATETC for objects.
//____________________________________________________________________________


class CObjFormats : public IEnumFORMATETC,
                    public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CObjFormats)
BEGIN_COM_MAP(CObjFormats)
    COM_INTERFACE_ENTRY(IEnumFORMATETC)
END_COM_MAP()

public:
    CObjFormats() : m_iFmt(0), m_cFmt(0), m_aFmt(NULL) 
    {
    }

    ~CObjFormats() { if (m_aFmt) delete [] m_aFmt; }

    void Init(UINT cfmt, FORMATETC * afmt)
    {
        m_cFmt = cfmt; 
        m_aFmt = afmt;
    }

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    UINT            m_iFmt;
    UINT            m_cFmt;
    FORMATETC     * m_aFmt;

}; // class CObjFormats


//____________________________________________________________________________
//
//  Class:      CObjFormatsEx
//
//  Purpose:    Impements IEnumFORMATETC for objects.
//____________________________________________________________________________


class CObjFormatsEx : public IEnumFORMATETC,
                      public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CObjFormatsEx)
BEGIN_COM_MAP(CObjFormatsEx)
    COM_INTERFACE_ENTRY(IEnumFORMATETC)
END_COM_MAP()

public:
    CObjFormatsEx() : m_iCur(0)
    {
    }

    ~CObjFormatsEx() 
    { 
    }

    bool Init(IEnumFORMATETC* pEnum1, IEnumFORMATETC* pEnum2)
    {
        ASSERT(pEnum1 && pEnum2);
        if (!pEnum1 || !pEnum2)
            return false;
        
        m_rgspEnums[0] = pEnum1;
        m_rgspEnums[1] = pEnum2;
        return true;
    }

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    UINT                m_iCur;
    IEnumFORMATETCPtr   m_rgspEnums[2];

}; // class CObjFormatsEx


#endif // _OBJFMTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\dataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dataobj.h
//
//--------------------------------------------------------------------------


#ifndef __DATAOBJ_H___
#define __DATAOBJ_H___

class CComponentData;
class CCookie;


class CDataObject : public IDataObject, 
                    public IEnumCookies, 
                    public CComObjectRoot 
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IEnumCookies)
END_COM_MAP()

// Construction/Destruction
    CDataObject();
    ~CDataObject();

// Initialization
    void Init(BOOL bForScopePane, CComponentData* pCD)
    {
        ASSERT(pCD != NULL);

        m_bForScopePane = bForScopePane;
        m_pComponentData = pCD;
    }

    void AddCookie(CCookie* pCookie);
    void SetParentFolder(CCookie* pCookie);
    void SetHasFolders()
    {
        m_bHasFolders = true;
    }
    void SetHasFiles()
    {
        m_bHasFiles = true;
    }

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

// Not Implemented
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut) { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease) { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,LPADVISESINK pAdvSink, LPDWORD pdwConnection) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection) { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise) { return E_NOTIMPL; };

// IEnumCookies
    STDMETHOD(Next)(ULONG celt, long* rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(IEnumCookies **ppenum);
    STDMETHOD(GetParent)(long* plCookie)
    {
        if (!plCookie)
            return E_POINTER;
        
        *plCookie = reinterpret_cast<long>(m_pCookieParent);
        return S_OK;
    }
    STDMETHOD(HasFiles)(void)
    {
        return m_bHasFiles ? S_OK : S_FALSE;
    }
    STDMETHOD(HasFolders)(void)
    {
        return m_bHasFolders ? S_OK : S_FALSE;
    }
    STDMETHOD(IsMultiSelect)(void)
    {
        return (m_rgCookies.GetSize() > 1) ? S_OK : S_FALSE;
    }


private:
    
    BOOL                m_bForScopePane;
    CCookiePtrArray     m_rgCookies;        
    CCookie*            m_pCookieParent;    // used for leaf items
    CComponentData*     m_pComponentData;

    // data member used by IEnumCookies
    ULONG               m_iCurr;

    // Data used for multi-seln
    bool m_bHasFiles;
    bool m_bHasFolders;

    HRESULT _CreaateMultiSelObjTypes(LPSTGMEDIUM lpMedium);
    HRESULT _CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT _CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT _CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT _CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT _CreateHDrop(LPSTGMEDIUM lpMedium);
    HRESULT _Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

IDataObject* GetDummyDataObject();

class CDummyDataObject : public IDataObject, 
                         public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummyDataObject)
BEGIN_COM_MAP(CDummyDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDummyDataObject() {}
    ~CDummyDataObject() {}

// Standard IDataObject methods
public:
// Not Implemented
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium) { return E_NOTIMPL; };
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium) { return E_NOTIMPL; };
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc) { return E_NOTIMPL; };
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc) { return E_NOTIMPL; };
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut) { return E_NOTIMPL; };
                    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease) { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,LPADVISESINK pAdvSink, LPDWORD pdwConnection) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection) { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise) { return E_NOTIMPL; };
};


#endif // __DATAOBJ_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(FSSnapIn)
    #define DBG_COMP    FSSnapInInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\fssptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       fssptrs.h
//
//--------------------------------------------------------------------------

#ifndef FSSPTRS_H
#define FSSPTRS_H

#include "comdef.h"

#define DEFINE_SMARTPTR(intf) _COM_SMARTPTR_TYPEDEF(intf, __uuidof(intf));


DEFINE_SMARTPTR(IComponent);
DEFINE_SMARTPTR(IComponentData);
DEFINE_SMARTPTR(IConsole);
DEFINE_SMARTPTR(IConsoleNameSpace);
DEFINE_SMARTPTR(IConsoleVerb);
DEFINE_SMARTPTR(IContextMenuProvider);
DEFINE_SMARTPTR(IControlbar);
DEFINE_SMARTPTR(IEnumCookies);
DEFINE_SMARTPTR(IExtendContextMenu);
DEFINE_SMARTPTR(IExtendControlbar);
DEFINE_SMARTPTR(IExtendPropertySheet);
DEFINE_SMARTPTR(IHeaderCtrl);
DEFINE_SMARTPTR(IImageList);
DEFINE_SMARTPTR(IPropertySheetCallback);
DEFINE_SMARTPTR(IPropertySheetProvider);
DEFINE_SMARTPTR(IResultData);
DEFINE_SMARTPTR(ISnapinAbout);

#endif // FSSPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\fssnapin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       fssnapin.cpp
//
//--------------------------------------------------------------------------

// fssnapin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f fssnapinps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "CompData.h"
#include "Compont.h"


DECLARE_INFOLEVEL(FSSnapIn);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ComponentData, CComponentData)
END_OBJECT_MAP()

class CFssnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CFssnapinApp theApp;
extern long g_cookieCount = 0;

BOOL CFssnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CFssnapinApp::ExitInstance()
{
	_Module.Term();
    Dbg(DEB_USER1, _T("Number of cookies leaked = %d\n"), g_cookieCount);
    ASSERT(g_cookieCount == 0);
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fssnapin.rc
//
#define IDS_PROJNAME                    100
#define IDR_COMPDATA                    102
#define IDR_COMPONT                     103
#define IDD_ADDDIR                      201
#define IDC_FILENAME                    202
#define IDD_ADDFILE                     202
#define IDC_DIRNAME                     203
#define IDB_16x16                       501
#define IDB_32x32                       502

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\objfmts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objfmts.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "objfmts.h"



//____________________________________________________________________________
//
//  Members:     IEnumFORMATETC methods
//____________________________________________________________________________

STDMETHODIMP
CObjFormats::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    UINT    cfetch = 0;
    HRESULT hr = S_FALSE; // assume less numbers

    if (m_iFmt < m_cFmt)
    {
        cfetch = m_cFmt - m_iFmt;

        if (cfetch >= celt)
        {
            cfetch = celt;
            hr = S_OK;
        }

        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC));
        m_iFmt += cfetch;
    }

    if (pceltFethed)
    {
        *pceltFethed = cfetch;
    }

    return hr;
}


STDMETHODIMP
CObjFormats::Skip(
    ULONG celt)
{
    m_iFmt += celt;

    if (m_iFmt > m_cFmt)
    {
        m_iFmt = m_cFmt;
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP
CObjFormats::Reset()
{
    m_iFmt = 0;
    return S_OK;
}

STDMETHODIMP
CObjFormats::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Function:     Function to obtain the IEnumFORMATETC interface.
//____________________________________________________________________________

HRESULT
GetObjFormats(
    UINT        cfmt,
    FORMATETC * afmt,
    LPVOID    * ppvObj)
{
    ASSERT(ppvObj != NULL);
    ASSERT(afmt != NULL);

    FORMATETC * pFmt = new FORMATETC[cfmt];

    if (pFmt == NULL)
        return E_OUTOFMEMORY;

    CopyMemory(pFmt, afmt, cfmt * sizeof(FORMATETC));

    CComObject<CObjFormats>* pObjFormats;
    CComObject<CObjFormats>::CreateInstance(&pObjFormats);

    if (pObjFormats == NULL)
    {
        delete [] pFmt;
        return E_OUTOFMEMORY;
    }
    
    pObjFormats->Init(cfmt, pFmt);

    return pObjFormats->QueryInterface(IID_IEnumFORMATETC, 
                                       reinterpret_cast<void**>(ppvObj));
}



//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////
//////////....................................................//////////////



//____________________________________________________________________________
//
//  Members:     CObjFormatsEx::IEnumFORMATETC methods
//____________________________________________________________________________

STDMETHODIMP
CObjFormatsEx::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    if (m_iCur == 1)
        return m_rgspEnums[1]->Next(celt, rgelt, pceltFethed);

    HRESULT hr = m_rgspEnums[0]->Next(celt, rgelt, pceltFethed);
    if (hr == S_OK)
        return S_OK;

    ULONG celt2 = celt - *pceltFethed;
    ULONG celtFethed2 = 0;
    
    m_iCur = 1;
    hr = m_rgspEnums[1]->Next(celt2, &rgelt[*pceltFethed], &celtFethed2);
    *pceltFethed += celtFethed2;
    return hr;
}


STDMETHODIMP
CObjFormatsEx::Skip(
    ULONG celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CObjFormatsEx::Reset()
{
    m_iCur = 0;
    m_rgspEnums[0]->Reset();
    m_rgspEnums[1]->Reset();
    return S_OK;
}

STDMETHODIMP
CObjFormatsEx::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}



HRESULT 
GetObjFormatsEx(
    IEnumFORMATETC* pEnum1, 
    IEnumFORMATETC* pEnum2,
    IEnumFORMATETC** ppEnumOut)
{
    ASSERT(pEnum1 != NULL);
    ASSERT(pEnum2 != NULL);
    ASSERT(ppEnumOut != NULL);
    if (!pEnum1 || !pEnum2 || !ppEnumOut)
        return E_INVALIDARG;


    CComObject<CObjFormatsEx>* pObj;
    CComObject<CObjFormatsEx>::CreateInstance(&pObj);

    if (pObj == NULL)
        return E_OUTOFMEMORY;
    
    pObj->Init(pEnum1, pEnum2);

    return pObj->QueryInterface(IID_IEnumFORMATETC, 
                                reinterpret_cast<void**>(ppEnumOut));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__17605694_DEB9_11D0_A7B3_00C04FD8D565__INCLUDED_)
#define AFX_STDAFX_H__17605694_DEB9_11D0_A7B3_00C04FD8D565__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>


#include "dbg.h"

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
using namespace ATL;
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__17605694_DEB9_11D0_A7B3_00C04FD8D565__INCLUDED)


#include <mmc.h>
#include "fss.h"
#include "fssptrs.h"
#include "templ.h"
#include "afxtempl.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\util.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       util.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "cookie.h"


CCookie* GetCookie(IDataObject* pDataObject)
{
    CCookie* pCookie = NULL;
    IEnumCookiesPtr spEnum = pDataObject;
    spEnum->Reset();
    HRESULT hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookie), NULL);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return NULL;

    CCookie* pCookieNext = NULL;
    hr = spEnum->Next(1, reinterpret_cast<long*>(&pCookieNext), NULL);
    if (hr == S_OK)
        // for multi-selectNo cookie

    ASSERT(pCookie != NULL);
    return pCookie;
}

bool IsFolder(IDataObject* pDataObject)
{
    CCookie* pCookie = GetCookie(pDataObject);
    if (pCookie && pCookie->IsFolder())
        return true;

    return false;
}
                                 

bool IsFile(IDataObject* pDataObject)
{
    CCookie* pCookie = GetCookie(pDataObject);
    if (pCookie && pCookie->IsFile())
        return true;

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\types\idl\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

TARGET_H = $(BASEDIR)\public\sdk\inc\fss.h

$(TARGET_H): $(PASS0_HEADERDIR)\fss.h
    copy $(PASS0_HEADERDIR)\fss.h $(TARGET_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------


#ifndef UTIL_H____
#define UTIL_H____

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))

class CComponentData;
class CComponent;
class CCookie;

typedef CArray<CCookie*, CCookie*> CCookiePtrArray;

#define FOLDER_ICON         0
#define OPEN_FOLDER_ICON    1
#define FILE_ICON           2

struct SUpadteInfo
{
    HSCOPEITEM              m_hSIParent;
    BOOL                    m_bCreated;
    CArray<LPTSTR, LPTSTR>  m_files;

}; // SUpadteInfo


inline LPTSTR NewDupString(LPCTSTR lpszIn)
{
    if (!lpszIn)
        return NULL;
    
    register ULONG len = lstrlen(lpszIn) + 1;
    TCHAR* lpszOut = new TCHAR[len];

    if (lpszOut != NULL)
        CopyMemory(lpszOut, lpszIn, len * sizeof(TCHAR));

    return lpszOut;
}


CCookie* GetCookie(IDataObject* pDataObject);
bool IsValidDataObject(IDataObject* pDataObject);
bool IsFolder(IDataObject* pDataObject);
bool IsFile(IDataObject* pDataObject);

#endif // UTIL_H____
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\about.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include <stdafx.h>


#include "Service.h"  
#include "CSnapin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CSnapinAboutImpl::CSnapinAboutImpl()
{
}


CSnapinAboutImpl::~CSnapinAboutImpl()
{
}


HRESULT CSnapinAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

	USES_CONVERSION;

    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_DESCRIPTION, lpDescription);
}


STDMETHODIMP CSnapinAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper(IDS_VERSION, lpVersion);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CSnapinAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\fssnapin\src\templ.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       templ.h
//
//--------------------------------------------------------------------------


template <typename CSome>
class CSafeReleasePtr
{
public:
    CSafeReleasePtr(void) : m_pSome(NULL) 
    {
    }

    CSafeReleasePtr(CSome* pSome) : m_pSome(pSome) 
    {
        if (pSome)
            pSome->AddRef();
    }

    ~CSafeReleasePtr()
    {
    }

public: void Attach(CSome* pSome) throw()
    // Saves/sets the m_pSome without AddRef()ing.  This call
    // will release any previously aquired m_pSome.
    {
    _Release();
    m_pSome = pSome;
    }

public: void Attach(CSome* pSome, bool bAddRef) throw()
    // Saves/sets the m_pSome only AddRef()ing if bAddRef is TRUE.
    // This call will release any previously aquired m_pSome.
    {
    _Release();
    m_pSome = pSome;
    if (bAddRef)
        {
        ASSERT(pSome);
        if (pSome)
            pSome->AddRef();
        }
    }

public: CSome* Detach() throw()
    // Simply NULL the m_pSome pointer so that it isn't Released()'ed.
    {
    CSome* const old=m_pSome;
    m_pSome = NULL;
    return old;
    }


public: operator CSome*() const throw()
    // Return the m_pSome.  This value may be NULL
    {
    return m_pSome;
    }

public: CSome& operator*() const throw()
    // Allows an instance of this class to act as though it were the
    // actual m_pSome.  Also provides minimal assertion verification.
    {
    ASSERT(m_pSome);
    return *m_pSome;
    }

public: CSome** operator&() throw()
    // Returns the address of the m_pSome pointer contained in this
    // class.  This is useful when using the COM/OLE interfaces to create
    // this m_pSome.
    {
    _Release();
    m_pSome = NULL;
    return &m_pSome;
    }

public: CSome* operator->() const throw()
    // Allows this class to be used as the m_pSome itself.
    // Also provides simple assertion verification.
    {
    ASSERT(m_pSome);
    return m_pSome;
    }

public: BOOL IsNull() const throw()
    // Returns TRUE if the m_pSome is NULL.
    {
    return !m_pSome;
    }

private:
    CSome*  m_pSome;

    void _Release()
    {
        if (m_pSome)
            m_pSome->Release();
    }

}; // class CSafeReleasePtr



template <typename CSome>
class CHolder
{
public:
    CHolder(CSome* pSome) : m_pSome(pSome), m_cRef(1) {}
    ~CHolder() {}

    CSome* GetObject()
    {
        return m_pSome;
    }

    void AddRef()
    {
        ++m_cRef;
    }

    void Release()
    {
        --m_cRef;
        if (m_cRef == 0)
        {
            ASSERT(m_pSome == NULL);
            delete this;
        }
    }

private:
    friend class CSome;

    void SetObject(CSome* pSome)
    {
        m_pSome = pSome;
    }

    CSome*  m_pSome;
    ULONG   m_cRef;

    // Not defined
    CHolder();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
#include "Service.h"
#include "CSnapin.h"
#include "DataObj.h"
#include "afxdlgs.h"
#include "resource.h"
#include "genpage.h"  // Step 3

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// All data is static for the sample
FOLDER_DATA FolderData[NUM_FOLDERS] =
{
    {L"User Data", L"1111", L"Info about users", USER},
    {L"Company Data", L"2222", L"Info about Companies", COMPANY},
    {L"Virtual Data", L"3333", L"Info about virtual items", VIRTUAL},
    {L"", L"", L"",STATIC}
};

FOLDER_DATA ExtFolderData[NUM_FOLDERS] =
{
    {L"1:", L"1111", L"Info about users", EXT_USER},
    {L"2:", L"2222", L"Info about Companies", EXT_COMPANY},
    {L"3:", L"3333", L"Infor about virtual items", EXT_VIRTUAL},
    {L"", L"", L"",STATIC}
};

static MMCBUTTON SnapinButtons[] =
{
 { 0, 1, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Folder", L"New Folder" },
 { 1, 2, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Inbox",  L"Mail Inbox"},
 { 2, 3, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Outbox", L"Mail Outbox" },
 { 3, 4, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Send",   L"Send Message" },
 { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP,    L" ",      L"" },
 { 4, 5, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Trash",  L"Trash" },
 { 5, 6, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Open",   L"Open Folder"},
 { 6, 7, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"News",   L"Today's News" },
 { 7, 8, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"INews",  L"Internet News" },

};

static MMCBUTTON SnapinButtons2[] =
{
 { 0, 10, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Compose",   L"Compose Message" },
 { 1, 20, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Print",     L"Print Message" },
 { 2, 30, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Find",      L"Find Message" },
 { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP,    L" ",         L"" },
 { 3, 40, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Inbox",     L"Inbox" },
 { 4, 50, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Smile",     L"Smile :-)" },
 { 5, 60, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Reply",     L"Reply" },
 { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP   , L" ",         L"" },
 { 6, 70, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Reply All", L"Reply All" },

};

enum
{
    // Identifiers for each of the commands/views to be inserted into the context menu.
    IDM_COMMAND1,
    IDM_COMMAND2,
    IDM_DEFAULT_MESSAGE_VIEW,
    IDM_SAMPLE_OCX_VIEW,
    IDM_SAMPLE_WEB_VIEW
};

static int n_count = 0;

#define ODS OutputDebugString

#ifdef DBX
  void DbxPrint(LPTSTR pszFmt, ...)
  {
      va_list va;
      va_start (va, pszFmt);
      TCHAR buf[250];
      wsprintf(buf, pszFmt, va);
      OutputDebugString(buf);
      va_end(va);
  }
  //#define DBX_PRINT     DbxPrint
  inline void __DummyTrace(LPTSTR, ...) { }
  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace
#else
  inline void __DummyTrace(LPTSTR, ...) { }
  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace
#endif

//
// The sample snap-in only has 1 property type and it's the workstation name
//

//
// Extracts the coclass guid format from the data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int ucf)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    CLIPFORMAT cf = (CLIPFORMAT)ucf;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { cf, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    int len = (cf == CDataObject::m_cfWorkstation) ?
        ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE);

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

    // Get the workstation name from the data object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;

    } while (FALSE);

    return p;
}

template<class T>
void ReleaseExtracted (T* t)
{
    GlobalFree (reinterpret_cast<HGLOBAL>(t));
}

BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    FORMATETC fmt = {s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}

BOOL IsMyMultiSelectDataObject(IDataObject* pIDataObject)
{
    if (pIDataObject == NULL)
        return FALSE;

    CDataObject* pCDataObject = dynamic_cast<CDataObject*>(pIDataObject);
    if (pCDataObject == NULL)
        return FALSE;

    return pCDataObject->IsMultiSelDobj();
}

// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    return Extract<CLSID>(lpDataObject, CDataObject::m_cfCoClass);
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    return Extract<GUID>(lpDataObject, CDataObject::m_cfNodeType);
}

wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject)
{
    return Extract<wchar_t>(lpDataObject, CDataObject::m_cfWorkstation);
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    return Extract<INTERNAL>(lpDataObject, CDataObject::m_cfInternal);
}

void ReleaseClassID (CLSID* pclsid)
{
    ReleaseExtracted<CLSID>(pclsid);
}

void ReleaseNodeType (GUID* pguid)
{
    ReleaseExtracted<GUID>(pguid);
}

void ReleaseWorkstation (wchar_t* p)
{
    ReleaseExtracted<wchar_t>(p);
}

void ReleaseInternalFormat (INTERNAL* pInternal)
{
    ReleaseExtracted<INTERNAL>(pInternal);
}


HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    ASSERT(pImpl != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

#ifdef _DEBUG
    pObject->SetComponentData(pImpl);
#endif

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

DWORD GetItemType(MMC_COOKIE cookie)
{
    // folder = CFoder* is cookie
    // result = RESULT_DATA* is the cookie

    return (*reinterpret_cast<DWORD*>(cookie));
}

/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CSnapin::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    ASSERT(lpDataObject);
    GUID* nodeType = ExtractNodeType(lpDataObject);

    // Is this my main node (static folder node type)
    if (::IsEqualGUID(*nodeType, cNodeTypeStatic) == TRUE)
        bResult = TRUE;

    // Free resources
    ::GlobalFree(reinterpret_cast<HANDLE>(nodeType));

    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation


// guid for custom view
static WCHAR* szCalendarGUID = L"{8E27C92B-1264-101C-8A2F-040224009C02}";
static WCHAR* szMicrosoftURL = L"www.microsoft.com";

STDMETHODIMP CSnapin::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // if list view
    if (m_CustomViewID == VIEW_DEFAULT_LV)
    {
        m_bVirtualView = FALSE;

       // if static folder not selected
        if (cookie != NULL)
        {
            // See if virtual data folder is selected
            CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
            ASSERT(pFolder->itemType == SCOPE_ITEM);
            FOLDER_TYPES ftype = pFolder->GetType();

            m_bVirtualView = (ftype == VIRTUAL || ftype == EXT_VIRTUAL);

            if (m_bVirtualView)
                *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
        }

        return S_FALSE;
    }

    WCHAR szMessageViewGUID[40];
    WCHAR* pszView;

    switch (m_CustomViewID)
    {
        case VIEW_CALENDAR_OCX:
            pszView = szCalendarGUID;
            break;

        case VIEW_MICROSOFT_URL:
            pszView = szMicrosoftURL;
            break;

        case VIEW_DEFAULT_MESSAGE_VIEW:
            StringFromGUID2 (CLSID_MessageView, szMessageViewGUID, ARRAYLEN(szMessageViewGUID));
            pszView = szMessageViewGUID;
            break;

        default:
            ASSERT (false && "CSnapin::GetResultViewType:  Unknown view ID");
            return (S_FALSE);
            break;
    }

    UINT uiByteLen = (wcslen(pszView) + 1) * sizeof(WCHAR);
    LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

    USES_CONVERSION;

    if (psz != NULL)
    {
       wcscpy(psz, pszView);
       *ppViewType = psz;
       return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    DBX_PRINT(_T(" ----------  CSnapin::Initialize<0x08x>\n"), this);
    ASSERT(lpConsole != NULL);
    m_bInitializedC = true;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (IS_SPECIAL_DATAOBJECT(lpDataObject))
    {
        if (event == MMCN_BTN_CLICK)
        {
            if (m_CustomViewID != VIEW_DEFAULT_LV)
            {
                switch (param)
                {
                case MMC_VERB_REFRESH:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_REFRESH"));
                    _OnRefresh(lpDataObject);
                    break;

                case MMC_VERB_PROPERTIES:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_PROPERTIES"));
                    break;

                default:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::param unknown"));
                    break;
                }
            }
        }
        else
        {
            switch (event)
            {
            case MMCN_REFRESH:
                ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMCN_REFRESH"));
                _OnRefresh(lpDataObject);
                break;
            }
        }

        return S_OK;
    }

    HRESULT hr = S_OK;
    MMC_COOKIE cookie;

    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(lpDataObject);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else if (event == MMCN_DESELECT_ALL)
    {
        DBX_PRINT(_T("CSnapin::Notify -> MMCN_DESELECT_ALL \n"));
    }
    else if (event == MMCN_COLUMN_CLICK)
    {
        DBX_PRINT(_T("CSnapin::Notify -> MMCN_COLUMN_CLICK \n"));
    }
    else if (event == MMCN_SNAPINHELP)
    {
        AfxMessageBox(_T("CSnapin::Notify ->MMCN_SNAPINHELP"));
    }
    else
    {
        INTERNAL* pInternal = NULL;

        if (IsMMCMultiSelectDataObject(lpDataObject) == FALSE)
        {
            pInternal = ExtractInternalFormat(lpDataObject);

            if (pInternal == NULL)
            {
                ASSERT(FALSE);
                return S_OK;
            }

            if (pInternal)
                cookie = pInternal->m_cookie;
        }

        switch(event)
        {
        case MMCN_ACTIVATE:
            break;

        case MMCN_CLICK:
            hr = OnResultItemClk(pInternal->m_type, cookie);
            break;

        case MMCN_DBLCLICK:
            if (pInternal->m_type == CCT_RESULT)
                Command(IDM_COMMAND1, lpDataObject);
            else
                hr = S_FALSE;

            break;

        case MMCN_ADD_IMAGES:
            OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow(cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_INITOCX:
//          ::MessageBox(NULL, _T("MMCN_INITOCX"), _T("TRACE"), MB_OK);
            ASSERT(param != 0);
            break;

        case MMCN_DESELECT_ALL:
        case MMCN_SELECT:
            HandleStandardVerbs((event == MMCN_DESELECT_ALL),
                                arg, lpDataObject);
            break;

        case MMCN_PASTE:
            AfxMessageBox(_T("CSnapin::MMCN_PASTE"));
            break;

        case MMCN_DELETE:
            AfxMessageBox(_T("CSnapin::MMCN_DELETE"));
            break;

        case MMCN_CONTEXTHELP:
            hr = OnContextHelp(lpDataObject);
            break;

        case MMCN_REFRESH:
            AfxMessageBox(_T("CSnapin::MMCN_REFRESH"));
            _OnRefresh(lpDataObject);
            break;

        case MMCN_PRINT:
            AfxMessageBox(_T("CSnapin::MMCN_PRINT"));
            break;

        case MMCN_RENAME:
//          ODS(_T("\n\n\t\tCSnapin::MMCN_RENAME\n\n"));
            break;

        case MMCN_RESTORE_VIEW:
            {   // user selected Back or Forward buttons:
                // we get the same info back that we gave
                // MMC during the GetResultViewType call.
                MMC_RESTORE_VIEW* pmrv = (MMC_RESTORE_VIEW*)arg;
                BOOL            * b    = (BOOL*)param;

                *b = TRUE;  // we're handling it

                // first, setup m_bVirtualMode
                m_bVirtualView = FALSE;
                CFolder* pFolder = reinterpret_cast<CFolder*>(pmrv->cookie);
                if (pFolder != NULL)
                    if (pFolder->GetType() == VIRTUAL)
                        m_bVirtualView = TRUE;

                WCHAR szMessageViewGUID[40];
                StringFromGUID2 (CLSID_MessageView, szMessageViewGUID, ARRAYLEN(szMessageViewGUID));

                // also, maintain m_CustomViewID
                if (pmrv->pViewType == NULL)
                    m_CustomViewID = VIEW_DEFAULT_LV;
                else if (!wcscmp (pmrv->pViewType, szCalendarGUID))
                    m_CustomViewID = VIEW_CALENDAR_OCX;
                else if (!wcscmp (pmrv->pViewType, szMicrosoftURL))
                    m_CustomViewID = VIEW_MICROSOFT_URL;
                else if (!wcscmp (pmrv->pViewType, szMessageViewGUID))
                    m_CustomViewID = VIEW_DEFAULT_MESSAGE_VIEW;
                else
                    // doesn't look like one of mine, but it is:
                    // if the URL leads to another URL.  This is
                    // sent to you can still maintain your checks
                    // in the view menu.
                    m_CustomViewID = VIEW_MICROSOFT_URL;
                    // also, you could be re-directed via script or asp.
                    // also, you may have neglected
            }
            break;

        // Note - Future expansion of notify types possible
        default:
            hr = E_UNEXPECTED;
            break;
        }

        if (pInternal != NULL)
        {
            ::GlobalFree(reinterpret_cast<HANDLE>(pInternal));
        }
    }

    if (m_pResult)
        m_pResult->SetDescBarText(L"hello world");

    return hr;
}

void CSnapin::_OnRefresh(LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
        return;

    USES_CONVERSION;

    if (pInternal->m_type == CCT_SCOPE)
    {
        CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);

        if (pData->IsPrimaryImpl())
        {
            CFolder* pFolder = pData->FindObject(pInternal->m_cookie);

            ::AfxMessageBox(pInternal->m_cookie ? OLE2T(pFolder->m_pszName) : _T("Files"));
            pData->DeleteAndReinsertAll();
        }
    }
    else
    {
        RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);
        ::AfxMessageBox(OLE2T(pData->szName));
    }
}

HRESULT CSnapin::OnContextHelp(LPDATAOBJECT pdtobj)
{
    TCHAR name[128];
    GetItemName(pdtobj, name);

    TCHAR buf[200];
    wsprintf(buf, _T("Context help requested for item: %s"), name);
    ::MessageBox(NULL, buf, _T("TRACE"), MB_OK);

    return S_OK;
}


STDMETHODIMP CSnapin::Destroy(MMC_COOKIE cookie)
{
    DBX_PRINT(_T(" ----------  CSnapin::Destroy<0x08x>\n"), this);
    ASSERT(m_bInitializedC);
    m_bDestroyedC = true;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

        SAFE_RELEASE(m_pConsoleVerb);
    }

    return S_OK;
}

typedef CArray<GUID, const GUID&> CGUIDArray;

void GuidArray_Add(CGUIDArray& rgGuids, const GUID& guid)
{
    for (int i=rgGuids.GetUpperBound(); i >= 0; --i)
    {
        if (rgGuids[i] == guid)
            break;
    }

    if (i < 0)
        rgGuids.Add(guid);
}

HRESULT CSnapin::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

    CGUIDArray rgGuids;

    if (m_bVirtualView == TRUE)
    {
        GuidArray_Add(rgGuids, cNodeTypeCompany);
    }
    else
    {
        // Determine the items selected
        ASSERT(m_pResult != NULL);
        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));
        rdi.mask = RDI_STATE;
        rdi.nIndex = -1;
        rdi.nState = TVIS_SELECTED;

        while (m_pResult->GetNextItem(&rdi) == S_OK)
        {
            FOLDER_TYPES fType;
            DWORD* pdw = reinterpret_cast<DWORD*>(rdi.lParam);


            if (*pdw == SCOPE_ITEM)
            {
                CFolder* pFolder = reinterpret_cast<CFolder*>(rdi.lParam);
                fType = pFolder->m_type;
            }
            else
            {
                ASSERT(*pdw == RESULT_ITEM);
                RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(rdi.lParam);
                fType = pData->parentType;
            }

            const GUID* pguid;
            switch (fType)
            {
            case STATIC:
                pguid = &cNodeTypeStatic;
                break;

            case COMPANY:
                pguid = &cNodeTypeCompany;
                break;

            case USER:
                pguid = &cNodeTypeUser;
                break;

            case EXT_COMPANY:
                pguid = &cNodeTypeExtCompany;
                break;

            case EXT_USER:
                pguid = &cNodeTypeExtUser;
                break;

            case VIRTUAL:
            case EXT_VIRTUAL:
                pguid = &cNodeTypeVirtual;
                break;

            default:
                return E_FAIL;
            }

            GuidArray_Add(rgGuids, *pguid);
        }
    }

    CComObject<CDataObject>* pObject;
    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);
    pObject->SetMultiSelDobj();

    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);

#ifdef _DEBUG
    pObject->SetComponentData(pImpl);
#endif

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());
    UINT cb = rgGuids.GetSize() * sizeof(GUID);
    GUID* pGuid = new GUID[rgGuids.GetSize()];
    CopyMemory(pGuid, rgGuids.GetData(), cb);
    pObject->SetMultiSelData((BYTE*)pGuid, cb);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
    return S_OK;
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    if (cookie == MMC_MULTI_SELECT_COOKIE)
        return QueryMultiSelectDataObject(cookie, type, ppDataObject);

    ASSERT(type == CCT_RESULT);

#ifdef _DEBUG
    if (cookie != MMC_MULTI_SELECT_COOKIE &&
        m_bVirtualView == FALSE)
    {
        DWORD dwItemType = GetItemType(cookie);
        ASSERT(dwItemType == RESULT_ITEM);
    }
#endif

    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pImpl != NULL);
    return _QueryDataObject(cookie, type, pImpl, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
: m_bIsDirty(TRUE), m_bInitializedC(false), m_bDestroyedC(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    SAFE_RELEASE(m_pToolbar1);
    SAFE_RELEASE(m_pToolbar2);

    SAFE_RELEASE(m_pMenuButton1);

    SAFE_RELEASE(m_pControlbar);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    ASSERT(m_pToolbar1 == NULL);
    ASSERT(m_pToolbar2 == NULL);


    delete m_pbmpToolbar1;
    delete m_pbmpToolbar2;

    ASSERT(!m_bInitializedC || m_bDestroyedC);

    Construct();
}

void CSnapin::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;
    m_pToolbar1 = NULL;
    m_pToolbar2 = NULL;
    m_pControlbar = NULL;

    m_pMenuButton1 = NULL;

    m_pbmpToolbar1 = NULL;
    m_pbmpToolbar2 = NULL;

    m_pConsoleVerb = NULL;

    m_CustomViewID = VIEW_DEFAULT_LV;
//  m_CustomViewID = VIEW_MICROSOFT_URL;
//  m_CustomViewID = VIEW_CALENDAR_OCX;
//  m_CustomViewID = VIEW_DEFAULT_MESSAGE_VIEW;

    m_bVirtualView = FALSE;
    m_dwVirtualSortOptions = 0;
}

void CSnapin::LoadResources()
{
    // Load strings from resources
    m_column1.LoadString(IDS_NAME);
    m_column2.LoadString(IDS_SIZE);
    m_column3.LoadString(IDS_TYPE);
}

HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);

    USES_CONVERSION;

    // Put the correct headers depending on the cookie
    // Note - cookie ignored for this sample
    m_pHeader->InsertColumn(0, T2COLE(m_column1), LVCFMT_LEFT, 180);     // Name
    m_pHeader->InsertColumn(1, T2COLE(m_column2), LVCFMT_RIGHT, 90);     // Size
    m_pHeader->InsertColumn(2, T2COLE(m_column3), LVCFMT_LEFT, 160);     // Type

    return hr;
}

HRESULT CSnapin::InitializeBitmaps(MMC_COOKIE cookie)
{
    ASSERT(m_pImageResult != NULL);

    ::CBitmap bmp16x16;
    ::CBitmap bmp32x32;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    m_pImageResult->ImageListSetStrip(
                    reinterpret_cast<PLONG_PTR>(static_cast<HBITMAP>(bmp16x16)),
                    reinterpret_cast<PLONG_PTR>(static_cast<HBITMAP>(bmp32x32)),
                    0, RGB(255, 0, 255));

    return S_OK;
}

WCHAR* StringFromFolderType(FOLDER_TYPES type)
{
    static WCHAR* s_szStatic    = L"Static";
    static WCHAR* s_szCompany   = L"Company";
    static WCHAR* s_szUser      = L"User";
    static WCHAR* s_szVirtual   = L"Virtual";
    static WCHAR* s_szUnknown   = L"Unknown";

    switch (type)
    {
    case STATIC:    return s_szStatic;
    case COMPANY:   return s_szCompany;
    case USER:      return s_szUser;
    case VIRTUAL:   return s_szVirtual;
    default:        return s_szUnknown;
    }
}

STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    static WCHAR* s_szSize = L"200";

    ASSERT(pResult != NULL);

    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = pFolder->m_pszName;
                else if (pResult->nCol == 1)
                    pResult->str = (LPOLESTR)s_szSize;
                else
                    pResult->str = (LPOLESTR)StringFromFolderType(pFolder->m_type);

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

			if (pResult->mask & RDI_IMAGE)
			{
				switch(pFolder->GetType())
				{
					case USER:
					case EXT_USER:
						pResult->nImage = USER_IMAGE;
						break;

					case COMPANY:
					case EXT_COMPANY:
						pResult->nImage = COMPANY_IMAGE;
						break;

					case VIRTUAL:
						pResult->nImage = VIRTUAL_IMAGE;
						break;
				}
			}
        }
        else
        {
            RESULT_DATA* pData;

            // if virtual, derive result item from index
            // else lParam is the item pointer
            if (m_bVirtualView)
                pData = GetVirtualResultItem(pResult->nIndex);
            else
                pData= reinterpret_cast<RESULT_DATA*>(pResult->lParam);

            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = (LPOLESTR)pData->szName;
                else if(pResult->nCol == 1)
                    pResult->str = (LPOLESTR)pData->szSize;
                else
                    pResult->str = (LPOLESTR)pData->szType;

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            // MMC can request image and indent for virtual data
            if (pResult->mask & RDI_IMAGE)
                pResult->nImage = 4;
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation


// Array of menu item commands to be inserted into the contest menu.
// Note - the first item is the menu text, // CCM_SPECIAL_DEFAULT_ITEM
// the second item is the status string
static CONTEXTMENUITEM menuItems[] =
{
    {
        L"Command 1", L"Sample extension menu added by snapin (Command 1)",
        IDM_COMMAND1, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
    },
    {
        L"Command 2", L"Sample extension menu added by snapin (Command 2)",
        IDM_COMMAND2, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
    },
    { NULL, NULL, 0, 0, 0 }
};

// Array of view items to be inserted into the context menu.
static CONTEXTMENUITEM viewItems[] =
{
    {
        L"Message View", L"Default message view",
        IDM_DEFAULT_MESSAGE_VIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
    },
    {
        L"Calendar", L"Sample OCX custom view",
        IDM_SAMPLE_OCX_VIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
    },
    {
        szMicrosoftURL, L"Sample WEB custom view",
        IDM_SAMPLE_WEB_VIEW, CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, 0
    },
    { NULL, NULL, 0, 0, 0 },
};

// guid for custom view
static GUID CLSID_SmGraphControl =
        {0xC4D2D8E0L,0xD1DD,0x11CE,0x94,0x0F,0x00,0x80,0x29,0x00,0x43,0x47};

STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    long *pInsertionAllowed)
{
#if 1 //testing

    ASSERT(pDataObject != NULL);
    if (pDataObject && IsMMCMultiSelectDataObject(pDataObject))
    {
        static CLIPFORMAT s_cf = 0;
        if (s_cf == 0)
        {
            USES_CONVERSION;
            s_cf = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_MULTI_SELECT_SNAPINS));
        }

        FORMATETC fmt = {s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        STGMEDIUM stgm = { TYMED_HGLOBAL, NULL };
        HRESULT hr = pDataObject->GetData(&fmt, &stgm);
        SMMCDataObjects* pData = (SMMCDataObjects*)stgm.hGlobal;
        int count = pData->count;
        IDataObject* pDO = NULL;
        hr = pData->lpDataObject[0]->QueryInterface(IID_IDataObject, (void**)&pDO);
        pDO->Release();
    }

#endif

    viewItems[0].fFlags = (m_CustomViewID == VIEW_DEFAULT_MESSAGE_VIEW) ? MF_CHECKED : 0;
    viewItems[1].fFlags = (m_CustomViewID == VIEW_CALENDAR_OCX)         ? MF_CHECKED : 0;
    viewItems[2].fFlags = (m_CustomViewID == VIEW_MICROSOFT_URL)        ? MF_CHECKED : 0;

    CComponentDataImpl* pCCD = dynamic_cast<CComponentDataImpl*>(m_pComponentData);

    HRESULT hr = pCCD->AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);

#if 0
    /*
     * add do-nothing commands on odd numbered items in the virtual list view
     */
    if (SUCCEEDED (hr) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) && m_bVirtualView)
    {
        INTERNAL* pInternal = pDataObject ? ExtractInternalFormat(pDataObject) : NULL;

        if (pInternal && (pInternal->m_cookie % 2))
        {
            CONTEXTMENUITEM cmi;

            cmi.strName           = L"Another command (odd, virtual-only)";
            cmi.strStatusBarText  = NULL;
            cmi.lCommandID        = 0xDDDD;
            cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            cmi.fFlags            = 0;
            cmi.fSpecialFlags     = 0;

            pContextMenuCallback->AddItem (&cmi);
            ReleaseInternalFormat (pInternal);
        }
    }
#endif

    return (hr);
}


STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
        return E_FAIL;

    if (pInternal->m_type == CCT_SCOPE)
    {
        // Handle view specific commands here
        switch (nCommandID)
        {
        case IDM_SAMPLE_WEB_VIEW:
        case IDM_SAMPLE_OCX_VIEW:
        case IDM_DEFAULT_MESSAGE_VIEW:
            m_CustomViewID =
                    (nCommandID == IDM_SAMPLE_OCX_VIEW) ? VIEW_CALENDAR_OCX :
                    (nCommandID == IDM_SAMPLE_WEB_VIEW) ? VIEW_MICROSOFT_URL :
                                                          VIEW_DEFAULT_MESSAGE_VIEW;

            // Ask console to reslelect the node to force a new view
            if (pInternal->m_cookie == 0)
            {
                CComponentDataImpl* pCCDI =
                    dynamic_cast<CComponentDataImpl*>(m_pComponentData);

                ASSERT(pCCDI != NULL);

                m_pConsole->SelectScopeItem(pCCDI->m_pStaticRoot);
            }
            else
            {
                CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
                m_pConsole->SelectScopeItem(pFolder->m_pScopeItem->ID);
            }
            break;

        case MMCC_STANDARD_VIEW_SELECT:
            m_CustomViewID = VIEW_DEFAULT_LV;
            break;

        default:
            // Pass non-view specific commands to ComponentData
            return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(nCommandID, pDataObject);
        }
    }
    else if (pInternal->m_type == CCT_RESULT)
    {

        // Handle each of the commands.
        switch (nCommandID)
        {
        case IDM_COMMAND1:
        case IDM_COMMAND2:
        {
            m_pResult->ModifyViewStyle(MMC_SINGLESEL, (MMC_RESULT_VIEW_STYLE)0);

            RESULTDATAITEM rdi;
            ZeroMemory(&rdi, sizeof(rdi));

            rdi.mask = RDI_STATE;
            rdi.nState = LVIS_SELECTED;
            rdi.nIndex = -1;
            m_pResult->GetNextItem(&rdi);

            int iSel = rdi.nIndex;
            int nImage = rdi.nImage;
            HRESULTITEM hri = 0;

            RESULT_DATA* pData;

            // if virtual view, derive result item from the index
            if (m_bVirtualView)
            {
                pData = GetVirtualResultItem(iSel);
            }
            // else get the cookie (which is result item ptr)
            else
            {
                ZeroMemory(&rdi, sizeof(rdi));
                rdi.mask = RDI_PARAM | RDI_IMAGE;
                rdi.nIndex = iSel;
                HRESULT hr = m_pResult->GetItem(&rdi);
                nImage = rdi.nImage;
                ASSERT(SUCCEEDED(hr));
                ASSERT(rdi.lParam != 0);

                m_pResult->FindItemByLParam (rdi.lParam, &hri);

                pData = reinterpret_cast<RESULT_DATA*>(rdi.lParam);
            }

#if 0
            static int nIconIndex = 12;
            nIconIndex = (nIconIndex == 12) ? 13 : 12;

            HICON hIcon = ExtractIcon (AfxGetInstanceHandle(),
                                       _T("%SystemRoot%\\system32\\shell32.dll"),
                                       nIconIndex);

            IImageList* pil;
            m_pConsole->QueryResultImageList(&pil);

            _asm int 3;
            pil->ImageListSetIcon((LONG_PTR*) hIcon, nImage);
            pil->ImageListSetIcon((LONG_PTR*) hIcon, ILSI_SMALL_ICON (nImage));
            pil->ImageListSetIcon((LONG_PTR*) hIcon, ILSI_LARGE_ICON (nImage));

            pil->Release();

            m_pResult->UpdateItem (hri);

#else
            CString strBuf = (nCommandID == IDM_COMMAND1) ?
                _T("\t Command 1 executed.\n\n") : _T("\t Command 2 executed.\n\n");

            strBuf += pData->szName;
            strBuf += _T(" is the currently selected item.");

            AfxMessageBox(strBuf);

            // change image in list
            if (!m_bVirtualView)
            {
                ZeroMemory(&rdi, sizeof(rdi));
                rdi.mask = RDI_IMAGE;
                rdi.nIndex = iSel;
                rdi.nImage = 3;
                HRESULT hr = m_pResult->SetItem(&rdi);
                ASSERT(SUCCEEDED(hr));
            }
#endif
        }
        break;

        default:
            ASSERT(FALSE); // Unknown command!
            break;
        }
    }
    else
    {
        ASSERT(0);
    }

    ::GlobalFree(reinterpret_cast<HANDLE>(pInternal));

    return S_OK;
}

STDMETHODIMP CSnapin::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return E_NOTIMPL;
}

STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    DBX_PRINT(_T(" ----------  CSnapin::Load<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    ASSERT(pStm);
    // Read the string
    char psz[10];
    ULONG nBytesRead;
    HRESULT hr = pStm->Read(psz, 10, &nBytesRead);

    // Verify that the read succeeded
    ASSERT(SUCCEEDED(hr) && nBytesRead == 10);

    // check to see if the string is the correct string
    ASSERT(strcmp("987654321", psz) == 0);

    ClearDirty();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL fClearDirty)
{
    DBX_PRINT(_T(" ----------  CSnapin::Save<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    HRESULT hr = pStm->Write("987654321", 10, &nBytesWritten);

    // Verify that the write operation succeeded
    ASSERT(SUCCEEDED(hr) && nBytesWritten == 10);
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
    : m_bIsDirty(TRUE), m_pScope(NULL), m_pConsole(NULL),
      m_bInitializedCD(false), m_bDestroyedCD(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

#ifdef _DEBUG
    m_cDataObjects = 0;
#endif
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);

    ASSERT(!m_bInitializedCD || m_bDestroyedCD);

    // Some snap-in is hanging on to data objects.
    // If they access, it will crash!!!
    ASSERT(m_cDataObjects <= 1);
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Initialize<0x08x>\n"), this);
    m_bInitializedCD = true;

    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));

    // add the images for the scope tree
    ::CBitmap bmp16x16;
    LPIMAGELIST lpScopeImage;

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);

    // Set the images
    lpScopeImage->ImageListSetStrip(
                        reinterpret_cast<PLONG_PTR>(static_cast<HBITMAP>(bmp16x16)),
                        reinterpret_cast<PLONG_PTR>(static_cast<HBITMAP>(bmp16x16)),
                        0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState());

    ASSERT(m_pScope != NULL);
    HRESULT hr;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnProperties(param);
    }
    else
    {

        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            return S_OK;
        }

        MMC_COOKIE cookie = pInternal->m_cookie;
        ::GlobalFree(reinterpret_cast<HANDLE>(pInternal));

        switch(event)
        {
        case MMCN_PASTE:
            AfxMessageBox(_T("CSnapin::MMCN_PASTE"));
            break;

        case MMCN_DELETE:
            AfxMessageBox(_T("CD::MMCN_DELETE"));
            //hr = OnDelete(cookie);
            break;

        case MMCN_REMOVE_CHILDREN:
            hr = OnRemoveChildren(arg);
            break;

        case MMCN_RENAME:
            hr = OnRename(cookie, arg, param);
            break;

        case MMCN_EXPAND:
            hr = OnExpand(lpDataObject, arg, param);
            break;

        default:
            break;
        }

    }

    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Destroy<0x08x>\n"), this);
    ASSERT(m_bInitializedCD);
    m_bDestroyedCD = true;

    // Delete enumerated scope items
    DeleteList();

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
#ifdef _DEBUG
    if (cookie == 0)
    {
        ASSERT(type != CCT_RESULT);
    }
    else
    {
        ASSERT(type == CCT_SCOPE);

        DWORD dwItemType = GetItemType(cookie);
        ASSERT(dwItemType == SCOPE_ITEM);
    }
#endif

    return _QueryDataObject(cookie, type, this, ppDataObject);
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return E_NOTIMPL;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Load<0x08x>\n"), this);

    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Read the string
    char psz[10];
    ULONG nBytesRead;
    HRESULT hr = pStm->Read(psz, 10, &nBytesRead);

    // Verify that the read succeeded
    ASSERT(SUCCEEDED(hr) && nBytesRead == 10);

    // check to see if the string is the correct string
    ASSERT(strcmp("123456789", psz) == 0);

    ClearDirty();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Save<0x08x>\n"), this);

    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Write the string
    ULONG nBytesWritten;
    HRESULT hr = pStm->Write("123456789", 10, &nBytesWritten);

    // Verify that the write operation succeeded
    ASSERT(SUCCEEDED(hr) && nBytesWritten == 10);
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnDelete(MMC_COOKIE cookie)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRemoveChildren(LPARAM arg)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
        return S_OK;

    LPOLESTR pszNewName = reinterpret_cast<LPOLESTR>(param);
    if (pszNewName == NULL)
        return E_INVALIDARG;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_INVALIDARG;

    pFolder->SetName(pszNewName);

    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);
        EnumerateScopePane(lpDataObject, param);
    }

    return S_OK;
}

HRESULT CComponentDataImpl::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnProperties(LPARAM param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);
    CFolder* pFolder = new CFolder();

    // Create a new folder object
    pFolder->Create( reinterpret_cast<LPOLESTR>(param), 0, 0, STATIC, FALSE);

    // The static folder in the last item in the list
    POSITION pos = m_scopeItemList.GetTailPosition();
    if (pos == 0)
    {
      //  CreateFolderList();
        pos = m_scopeItemList.GetTailPosition();
    }

    ASSERT(pos);

    // Add it to the internal list
    if (pos)
    {
        CFolder* pItem = m_scopeItemList.GetAt(pos);
        m_scopeItemList.InsertBefore(pos, pFolder);

        pFolder->m_pScopeItem->relativeID = pItem->m_pScopeItem->relativeID;

        // Set the folder as the cookie
        pFolder->m_pScopeItem->mask |= SDI_PARAM;
        pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
        pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
        m_pScope->InsertItem(pFolder->m_pScopeItem);
    }

    ::GlobalFree(reinterpret_cast<void*>(param));

    return S_OK;
}


void CComponentDataImpl::CreateFolderList(LPDATAOBJECT lpDataObject)
{
    CFolder* pFolder;

    ASSERT(lpDataObject != NULL);

    wchar_t* pWkStation = ExtractWorkstation(lpDataObject);
    ASSERT(pWkStation != NULL);

    CLSID* pCoClassID = ExtractClassID(lpDataObject);
    ASSERT(pCoClassID != NULL);

    // Determine which folder set to use based on context information
    FOLDER_DATA* pFolderSet = FolderData;
    BOOL bExtend = FALSE;

    if (!IsEqualCLSID(*pCoClassID, GetCoClassID()))
    {
        pFolderSet = ExtFolderData;
        bExtend = TRUE;
//      TRACE(_T("Using Extension Data\n"));
    }

    ASSERT(m_scopeItemList.GetCount() == 0);
    wchar_t buf[100];

    for (int i=0; i < NUM_FOLDERS; i++)
    {
        pFolder = new CFolder();
        buf[0] = NULL;

        USES_CONVERSION;

        wcscpy(buf, pFolderSet[i].szName);

        // Add context info to the folder name
        if (bExtend)
            wcscat(buf, pWkStation);

        int nImage = 0;
        switch(pFolderSet[i].type)
        {
        case USER:
		case EXT_USER:
            nImage = USER_IMAGE;
            break;

        case COMPANY:
		case EXT_COMPANY:
            nImage = COMPANY_IMAGE;
            break;

		case VIRTUAL:
			nImage = VIRTUAL_IMAGE;
			break;
        }

        // Create the folder objects with static data
        pFolder->Create(buf, nImage/*FOLDER_IMAGE_IDX*/, OPEN_FOLDER_IMAGE_IDX,
            pFolderSet[i].type, FALSE);

        m_scopeItemList.AddTail(pFolder);
    }

    // mark cookie for last item
    pFolder->SetCookie(NULL);

    // Free memory from data object extraction
    ::GlobalFree(reinterpret_cast<HGLOBAL>(pWkStation));
    ::GlobalFree(reinterpret_cast<HGLOBAL>(pCoClassID));
}

void CComponentDataImpl::EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent)
{
    int i;

    ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface
    ASSERT(lpDataObject != NULL);

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

    if (pInternal == NULL)
        return ;

    MMC_COOKIE cookie = pInternal->m_cookie;

#ifndef RECURSIVE_NODE_EXPANSION
    // Only the static node has enumerated children
    if (cookie != NULL)
        return ;
#endif

    ::GlobalFree(reinterpret_cast<HANDLE>(pInternal));

    // Initialize folder list if empty
    if (m_scopeItemList.GetCount() == 0)
        CreateFolderList(lpDataObject);

    // Enumerate the scope pane
    // return the folder object that represents the cookie
    // Note - for large list, use dictionary
    CFolder* pStatic = FindObject(cookie);

#ifndef RECURSIVE_NODE_EXPANSION
    ASSERT(!pStatic->IsEnumerated());
    // Note - Each cookie in the scope pane represents a folder.
    // A released product may have more then one level of children.
    // This sample assumes the parent node is one level deep.
#endif

    ASSERT(pParent != NULL);

    // Cache the HSCOPEITEM of the static root.
    if (cookie == NULL)
        m_pStaticRoot = pParent;

    POSITION pos = m_scopeItemList.GetHeadPosition();
    CFolder* pFolder;

    for (i=0; (i < (NUM_FOLDERS - 1)) && (pos != NULL); i++)
    {
        pFolder = m_scopeItemList.GetNext(pos);
        ASSERT(pFolder);

        // Set the parent
        pFolder->m_pScopeItem->relativeID = pParent;

        // Set the folder as the cookie
        pFolder->m_pScopeItem->mask |= SDI_PARAM;
        pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
        pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
        m_pScope->InsertItem(pFolder->m_pScopeItem);

        // Note - On return, the ID member of 'm_pScopeItem'
        // contains the handle to the newly inserted item!
        ASSERT(pFolder->m_pScopeItem->ID != NULL);
    }

    // Last folder added is the static folder
    pStatic->Set(TRUE);     // folder has been enumerated
    pStatic->m_pScopeItem->relativeID = pParent;
}

void CComponentDataImpl::DeleteAndReinsertAll()
{
    ASSERT(m_pScope != NULL); // make sure we QI'ed for the interface

    ASSERT (m_scopeItemList.GetCount() > 0);

    //m_pStaticRoot
    HRESULT hr = m_pScope->DeleteItem(m_pStaticRoot, FALSE);
    ASSERT(SUCCEEDED(hr));

    POSITION pos = m_scopeItemList.GetHeadPosition();
    CFolder* pFolder;

    for (UINT i=0; (i < (NUM_FOLDERS - 1)) && (pos != NULL); i++)
    {
        pFolder = m_scopeItemList.GetNext(pos);
        ASSERT(pFolder);

        // clear old ID
        pFolder->m_pScopeItem->ID = NULL;

        // Set the parent
        pFolder->m_pScopeItem->relativeID = m_pStaticRoot;

        // Set the folder as the cookie
        pFolder->m_pScopeItem->mask |= SDI_PARAM;
        pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
        pFolder->SetCookie(reinterpret_cast<MMC_COOKIE>(pFolder));
        m_pScope->InsertItem(pFolder->m_pScopeItem);

        // Note - On return, the ID member of 'm_pScopeItem'
        // contains the handle to the newly inserted item!
        ASSERT(pFolder->m_pScopeItem->ID != NULL);
    }
}

void CComponentDataImpl::DeleteList()
{
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while (pos)
        delete m_scopeItemList.GetNext(pos);
}

CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie)
{
    POSITION pos = m_scopeItemList.GetHeadPosition();
    CFolder* pFolder = NULL;

    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);

        if (*pFolder == cookie)
            return pFolder;
    }

    return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

    ASSERT(pScopeDataItem->mask & SDI_STR);
    pScopeDataItem->displayname = pFolder ? pFolder->m_pszName : L"Snapin Data";

    //ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectA);

   if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

    ::GlobalFree(reinterpret_cast<HANDLE>(pA));
    ::GlobalFree(reinterpret_cast<HANDLE>(pB));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet2 Implementation

HRESULT CComponentDataImpl::DoInsertWizard(LPPROPERTYSHEETCALLBACK lpProvider)
{
    CStartUpWizard* pWizard = new CStartUpWizard;
    CStartupWizard1* pWizard1 = new CStartupWizard1;

    MMCPropPageCallback(&pWizard->m_psp97);
    MMCPropPageCallback(&pWizard1->m_psp97);

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pWizard->m_psp97);

    if (hPage == NULL)
        return E_UNEXPECTED;

    lpProvider->AddPage(hPage);

    hPage = CreatePropertySheetPage(&pWizard1->m_psp97);

    if (hPage == NULL)
        return E_UNEXPECTED;

    lpProvider->AddPage(hPage);

    return S_OK;
}

STDMETHODIMP
CComponentDataImpl::GetWatermarks(
    LPDATAOBJECT lpIDataObject,
    HBITMAP* lphWatermark,
    HBITMAP* lphHeader,
    HPALETTE* lphPalette,
    BOOL* pbStretch)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    *lphHeader = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_BANNER));
    *lphWatermark = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_WATERMARK));
    *pbStretch = TRUE; // force the watermark bitmap to stretch

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);


    // Look at the data object and see if the snap-in manager is asking for pages
    INTERNAL* pInternal= ExtractInternalFormat(lpIDataObject);

    if (pInternal != NULL)
    {
        DATA_OBJECT_TYPES type = pInternal->m_type;
        FREE_DATA(pInternal);

        if (type == CCT_SNAPIN_MANAGER)
        {
            HRESULT hr = DoInsertWizard(lpProvider);
            return hr;
        }
    }

    CLSID* pCoClassID = ExtractClassID(lpIDataObject);

    if(pCoClassID == NULL)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    CPropertyPage* pBasePage;

    // Determine which
    // Note: Should check the node type, but the sample only has 1
    if (IsEqualCLSID(*pCoClassID, GetCoClassID()))
    {
        // Create the primary property page
        CGeneralPage* pPage = new CGeneralPage();
        pPage->m_hConsoleHandle = handle;
        pBasePage = pPage;
    }
    else
    {

        // Create the extension property page
        CExtensionPage* pPage = new CExtensionPage();
        pBasePage = pPage;

        wchar_t* pWkStation = ExtractWorkstation(lpIDataObject);

        if (pWkStation == NULL)
        {
            ASSERT(FALSE);
            return E_FAIL;
        }

        // Save the workstation name
        pPage->m_szText = pWkStation;
        FREE_DATA(pWkStation);

    }

    FREE_DATA(pCoClassID);

    // Object gets deleted when the page is destroyed
    ASSERT(lpProvider != NULL);

    HRESULT hr = MMCPropPageCallback(&pBasePage->m_psp);

    if (SUCCEEDED(hr))
    {

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);

        if (hPage == NULL)
            return E_UNEXPECTED;

        lpProvider->AddPage(hPage);
    }

    return hr;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Get the node type and see if it's one of mine

    // if (nodetype == one of mine)
    //      do this
    // else
    //      see which node type it is and answer the question

    return S_OK;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

    if (pInternal->m_cookie == NULL &&
        (pInternal->m_type == CCT_SCOPE || pInternal->m_type == CCT_RESULT))
        bResult = TRUE;

    FREE_DATA(pInternal);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    long *pInsertionAllowed)
{
    HRESULT hr = S_OK;

    // Note - snap-ins need to look at the data object and determine
    // in what context, menu items need to be added. They must also
    // observe the insertion allowed flags to see what items can be
    // added.

    if (IsMMCMultiSelectDataObject(pDataObject) == TRUE)
        return S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    BOOL bCmd1IsDefault = (pInternal->m_type == CCT_RESULT);

    if (bCmd1IsDefault)
        menuItems[0].fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;
    else
        menuItems[0].fSpecialFlags = 0;

    // Loop through and add each of the menu items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        for (LPCONTEXTMENUITEM m = menuItems; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);

            if (FAILED(hr))
                break;
        }
    }

    // Loop through and add each of the view items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        for (LPCONTEXTMENUITEM m = viewItems; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);

            if (FAILED(hr))
                break;
        }
    }

    return hr;
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

#ifdef DOBJ_NOCONSOLE
    if (pDataObject == DOBJ_NOCONSOLE)
    {
        TCHAR szMsg[256];

        wsprintf (szMsg, _T("CComponentDataImpl::Command invoked from outside the context of MMC (nCommandID = %d)."), nCommandID);
        AfxMessageBox (szMsg);
        return (S_OK);
    }
#endif // DOBJ_NOCONSOLE

    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.

    // Handle each of the commands.
    switch (nCommandID)
    {
    case IDM_COMMAND1:
    {
        ASSERT(m_pConsole);
        m_pConsole->MessageBox(L"Snapin Menu Comand Selected",
                                    menuItems[nCommandID].strName, MB_OK, NULL);
        if (1)
        {
            IConsole2* pc2 = NULL;
            m_pConsole->QueryInterface(IID_IConsole2, (void**)&pc2);
            ASSERT(pc2 != NULL);
            pc2->IsTaskpadViewPreferred();
            pc2->Release();
            break;
        }

        INTERNAL* pi = ExtractInternalFormat(pDataObject);
        ASSERT(pi);
        ASSERT(pi->m_type != CCT_RESULT);
        CFolder* pFolder = reinterpret_cast<CFolder*>(pi->m_cookie);
        if (pFolder)
        {
            m_pConsole->SelectScopeItem(pFolder->m_pScopeItem->ID);
        }
        else
        {
            SCOPEDATAITEM si;
            ZeroMemory(&si, sizeof(si));
            si.ID = m_pStaticRoot;
            si.mask = SDI_STR;
            si.displayname = MMC_TEXTCALLBACK; // _T("Sample snapin's static folder");
            m_pScope->SetItem(&si);
        }
        break;
    }
    case IDM_COMMAND2:
        ASSERT(m_pConsole);
        m_pConsole->MessageBox(L"Snapin Menu Comand Selected",
                                    menuItems[nCommandID].strName, MB_OK, NULL);
        break;

    default:
        ASSERT(FALSE); // Unknown command!
        break;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{
//  TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar);

    // Please don't delete this. Required to make sure we pick up the bitmap
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (pControlbar != NULL)
    {

        // Hold on to the controlbar interface.
        if (m_pControlbar)
        {
            m_pControlbar->Release();
        }

        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr=S_FALSE;

        if (!m_pMenuButton1)
        {
            hr = m_pControlbar->Create(MENUBUTTON, this,
                                reinterpret_cast<LPUNKNOWN*>(&m_pMenuButton1));
            ASSERT(SUCCEEDED(hr));
        }

        if (m_pMenuButton1)
        {
            // Unlike toolbar buttons, menu buttons need to be added every time.
            hr = m_pMenuButton1->AddButton(FOLDEREX_MENU, L"FolderEx", L"Extended Folder Menu");
            ASSERT(SUCCEEDED(hr));
            hr = m_pMenuButton1->AddButton(FILEEX_MENU, L"FileEx", L"Extended File Menu");
            ASSERT(SUCCEEDED(hr));
        }


        // Create the Toolbar 1
        if (!m_pToolbar1)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pToolbar1));
            ASSERT(SUCCEEDED(hr));


            // Add the bitmap
            m_pbmpToolbar1 = new ::CBitmap;
            m_pbmpToolbar1->LoadBitmap(IDB_TOOLBAR1);
            hr = m_pToolbar1->AddBitmap(11, *m_pbmpToolbar1, 16, 16, RGB(255, 0, 255));
            ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            hr = m_pToolbar1->AddButtons(ARRAYLEN(SnapinButtons), SnapinButtons);
            ASSERT(SUCCEEDED(hr));

        }


        // TOOLBAR 2

            // Create the Toolbar 2
        if (!m_pToolbar2)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pToolbar2));
            ASSERT(SUCCEEDED(hr));

            // Add the bitmap
            m_pbmpToolbar2 = new ::CBitmap;
            m_pbmpToolbar2->LoadBitmap(IDB_TOOLBAR2);
            hr = m_pToolbar2->AddBitmap(36, *m_pbmpToolbar2, 16, 16, RGB(192,192,192));
            ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            hr = m_pToolbar2->AddButtons(ARRAYLEN(SnapinButtons2), SnapinButtons2);
            ASSERT(SUCCEEDED(hr));

        }


    }
    else
    {
        SAFE_RELEASE(m_pControlbar);
    }


    return S_OK;
}


void CSnapin::OnButtonClick(LPDATAOBJECT pdtobj, LONG_PTR idBtn)
{
    TCHAR name[128];
    GetItemName(pdtobj, name);

    TCHAR buf[200];
    wsprintf(buf, _T("Toolbar button<%d> was clicked. \nThe currently selected result item is <%s>"), idBtn, name);
    ::MessageBox(NULL, buf, _T("TRACE"), MB_OK);
}


STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr=S_FALSE;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (event)
    {
    case MMCN_BTN_CLICK:
        //TCHAR szMessage[MAX_PATH];
        //wsprintf(szMessage, _T("CommandID %ld"),param);
        //AfxMessageBox(szMessage);
        OnButtonClick(reinterpret_cast<LPDATAOBJECT>(arg), param);
        break;

    case MMCN_DESELECT_ALL:
    case MMCN_SELECT:
        HandleExtToolbars((event == MMCN_DESELECT_ALL), arg, param);
        break;

    case MMCN_MENU_BTNCLICK:
        HandleExtMenus(arg, param);
        break;

    default:
        break;
    }


    return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}


// This compare is used to sort the item's in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assum sort is ascending when comparing.


STDMETHODIMP CSnapin::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;
    ASSERT(nCol >=0 && nCol< 3);

    *pnResult = 0;

    USES_CONVERSION;

    LPTSTR szStringA;
    LPTSTR szStringB;

    RESULT_DATA* pDataA = reinterpret_cast<RESULT_DATA*>(cookieA);
    RESULT_DATA* pDataB = reinterpret_cast<RESULT_DATA*>(cookieB);


    ASSERT(pDataA != NULL && pDataB != NULL);

    if (nCol == 0)
    {
        szStringA = OLE2T(pDataA->szName);
        szStringB = OLE2T(pDataB->szName);
    }
    else if(nCol == 1)
    {
        szStringA = OLE2T(pDataA->szSize);
        szStringB = OLE2T(pDataB->szSize);
    }
    else
    {
        szStringA = OLE2T(pDataA->szType);
        szStringB = OLE2T(pDataB->szType)   ;
    }

    ASSERT(szStringA != NULL);
    ASSERT(szStringB != NULL);

    *pnResult = _tcscmp(szStringA, szStringB);


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// IResultOwnerData implementation
//
STDMETHODIMP CSnapin::FindItem (LPRESULTFINDINFO pFindInfo, int* pnFoundIndex)
{
    // find next item that matches the string (exact or partial)
    // if matched found, set FoundIndex and return S_OK

    // For the sample all items are named by their index number
    // so we don't do a real string search. Also, to simplify the code
    // the routine assumes a partial match search with wrap, which is what
    // keyboard navigation calls use.
    ASSERT((pFindInfo->dwOptions & (RFI_PARTIAL | RFI_WRAP)) == (RFI_PARTIAL | RFI_WRAP));

    USES_CONVERSION;

    TCHAR* lpszFind = OLE2T(pFindInfo->psz);

//  TRACE(_T("CSnapin::FindItem(\"%s\")"), lpszFind);

    // convert search string to number
    int nMatchVal = 0;
    TCHAR* pch = lpszFind;
    while (*pch >= _T('0') && *pch <= _T('9') && nMatchVal < NUM_VIRTUAL_ITEMS)
        nMatchVal = nMatchVal * 10 + (*pch++ - _T('0'));

    // if string has a non-decimal char or is too large, it won't match anything
    if (*pch != 0 || nMatchVal >= NUM_VIRTUAL_ITEMS)
        return S_FALSE;

    // if ascending sequence
    if (!(m_dwVirtualSortOptions & RSI_DESCENDING))
    {
        int nStartVal = pFindInfo->nStart;

        // if match is less than start (but not zero), locate first value above start that matches
        // otherwise the match number itself it the answer
        if (nMatchVal < nStartVal && nMatchVal != 0)
        {
             // find scale factor to reach value >= start value
            int nScale = 1;
            while (nMatchVal * nScale < nStartVal)
                nScale *= 10;

            // check special case of start value beginning with the match digits
            int nTestVal = (nStartVal * 10 - nMatchVal * nScale) < nScale ? nStartVal : nMatchVal * nScale;

            // if not too big it's the match, else the match value is the match
            if (nTestVal < NUM_VIRTUAL_ITEMS)
                nMatchVal = nTestVal;
        }
    }
    else  // descending sequence
    {
        // convert start index to start value
        int nStartVal = (NUM_VIRTUAL_ITEMS - 1) - pFindInfo->nStart;

        if (nMatchVal != 0)
        {
            // if match number > start, we will have to wrap to find a match
            // so use max index as our target
            int nTargetVal = (nMatchVal > nStartVal) ? NUM_VIRTUAL_ITEMS - 1 : nStartVal;

            // find scale factor that gets closest without going over target
            int nScale = 1;
            while (nMatchVal * nScale * 10 < nTargetVal)
                nScale *= 10;

            // check special case of target value beginning with the match digits
            nMatchVal = (nTargetVal - nMatchVal * nScale) < nScale ? nTargetVal : (nMatchVal + 1) * nScale - 1;
        }

        // convert match value back to an item index
        nMatchVal = (NUM_VIRTUAL_ITEMS - 1) - nMatchVal;
    }

    *pnFoundIndex = nMatchVal;

    return S_OK;

}


STDMETHODIMP CSnapin::CacheHint (int nStartIndex, int nEndIndex)
{
    // If advantageous, use this hint to pre-fetch the result item info that
    // is about to be requested.
//  TRACE(_T("CSnapin::CacheHint(%d,%d)\n"), nStartIndex, nEndIndex);

    return S_OK;

}

STDMETHODIMP CSnapin::SortItems (int nColumn, DWORD dwSortOptions, LPARAM lUserParam)
{
    // sort request for user owned result items
    // if item order changed return S_OK, else S_FALSE

    // Sample only sorts on the first column (item name)

    if ((nColumn == 0) && (m_dwVirtualSortOptions != dwSortOptions))
    {
        m_dwVirtualSortOptions = dwSortOptions;
        return S_OK;
    }

    return S_FALSE;

}


void CSnapin::HandleStandardVerbs(bool bDeselectAll, LPARAM arg,
                                  LPDATAOBJECT lpDataObject)
{
    WORD bScope = LOWORD(arg);
    WORD bSelect = HIWORD(arg);

#if 0
    // trace
    {
        TCHAR buf[250];
        static UINT s_count1 = 0;
        wsprintf(buf, _T("<%4d> %s - %s\n"), ++s_count1, bScope ? _T("Scope") : _T("Result"),
                                     bSelect ? _T("selected") : _T("de-selected"));
        OutputDebugString(buf);
    }
#endif

    if (!bScope)
    {
        if (m_CustomViewID == VIEW_MICROSOFT_URL)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

            return;
        }
        else if (m_CustomViewID == VIEW_CALENDAR_OCX)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

            return;
        }
    }

    if (!bDeselectAll && lpDataObject == NULL)
        return;

    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.

#if 0
    TCHAR buf[40];
    wsprintf(buf, _T("      %4d - CSnapin::OnSelect<%d, %d>\n"), ++n_count, bScope, bSelect);
    ODS(buf);
#else
    DBX_PRINT(_T("      %4d - CSnapin::OnSelect<%d, %d>\n"), ++n_count, bScope, bSelect);
#endif


    if (!bDeselectAll && IsMyMultiSelectDataObject(lpDataObject) == TRUE)
    {
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

        m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);

        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

        return;
    }

    INTERNAL* pInternal = lpDataObject ? ExtractInternalFormat(lpDataObject) : NULL;

    if (bSelect && (pInternal != NULL) && (pInternal->m_type == CCT_SCOPE))
    {
        IConsole2* pConsole2;
        m_pConsole->QueryInterface (IID_IConsole2, (void**)&pConsole2);

        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

        if (pFolder != NULL)
        {
            switch (pFolder->GetType())
            {
                case USER:
                    pConsole2->SetStatusText (L"User node selected||third pane");
                    break;

                case COMPANY:
                    pConsole2->SetStatusText (L"Company node selected|%25|third pane");
                    break;

                case VIRTUAL:
                    pConsole2->SetStatusText (L"  Virtual node selected  |  %50  |  third pane  ");
                    break;
            }
        }
        else
            pConsole2->SetStatusText (L"Static root node selected||third pane");

        pConsole2->Release ();
    }

    if (bDeselectAll || !bSelect)
    {
        if (bScope)
        {
            m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
        }
        else
        {
            // Result pane background
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, TRUE);

            if (pInternal && pInternal->m_cookie == 0)
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
            }

            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
        }

        return;
    }


    if (m_pConsoleVerb && pInternal)
    {
        if (pInternal->m_type == CCT_SCOPE)
        {
            // Standard funcitonality support by scope items
            m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, ENABLED, TRUE);

            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

            // Enable properties for static node only.
            if (pInternal->m_cookie == 0)
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                //m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            }
            else
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, TRUE);

                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            }

            // Standard funcitonality NOT support by scope items
            m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);

            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

            m_pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, FALSE);
            //m_pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);
        }
        else
        {
            // Standard funcitonality support by result items
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);

            // Standard funcitonality NOT support by result items
        }

        m_pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

        // Standard funcitonality NOT support by all items
        //m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
        //m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    }
}

void EnableToolbar(LPTOOLBAR pToolbar, MMCBUTTON rgSnapinButtons[], int nRgSize,
                   BOOL bEnable)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
            pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,
                                     bEnable);
    }
}


void EnableMenuBtns(LPMENUBUTTON pMenuBtn, MMCBUTTON rgSnapinButtons[], int nRgSize,
                   BOOL bEnable)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
            pMenuBtn->SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,
                                     bEnable);
    }
}

void CSnapin::HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param)
{
    INTERNAL* pInternal = NULL;
    HRESULT hr;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

#if 0
#if 1
{
    if (param)
    {
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
        pInternal = ExtractInternalFormat(pDataObject);
    }

    TCHAR buf[200];
    wsprintf(buf, _T("      %4d - CExtendControlbar::OnSelect<%d, %d> = %d\n"),
             ++n_count, bScope, bSelect, pInternal ? pInternal->m_cookie : 0);
    ODS(buf);
}
#else
    DBX_PRINT(_T("      %4d - CExtendControlbar::OnSelect<%d, %d>\n"), ++n_count, bScope, bSelect);
#endif
#endif

    if (bDeselectAll || bSelect == FALSE)
    {
        ASSERT(m_pToolbar1);
        EnableToolbar(m_pToolbar1, SnapinButtons,
                      ARRAYLEN(SnapinButtons), FALSE);

        ASSERT(m_pToolbar2);
        EnableToolbar(m_pToolbar2, SnapinButtons2,
                      ARRAYLEN(SnapinButtons2), FALSE);

        ASSERT(m_pMenuButton1 != NULL);
        m_pMenuButton1->SetButtonState(FOLDEREX_MENU, ENABLED, FALSE);
        m_pMenuButton1->SetButtonState(FILEEX_MENU, ENABLED, FALSE);

        return;
    }

    ASSERT(bSelect == TRUE);
    bool bFileExBtn = false;
    if (bScope == TRUE)
    {
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        pInternal = ExtractInternalFormat(pDataObject);
        if (pInternal == NULL)
            return;

        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

        if (pInternal->m_cookie == 0)
        {
            if (IsPrimaryImpl() == TRUE)
            {
                // Attach the toolbars to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
                ASSERT(SUCCEEDED(hr));

                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
                ASSERT(SUCCEEDED(hr));
            }
        }
        else if ((IsPrimaryImpl() == TRUE && pFolder->GetType() == COMPANY) ||
                 (IsPrimaryImpl() == FALSE && pFolder->GetType() == EXT_COMPANY))
        {
            // Detach the toolbar2 from the window
            hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar2);
            ASSERT(SUCCEEDED(hr));

            // Attach the toolbar1 to the window
            hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
            ASSERT(SUCCEEDED(hr));
        }
        else if ((IsPrimaryImpl() == TRUE && pFolder->GetType() == USER) ||
                 (IsPrimaryImpl() == FALSE && pFolder->GetType() == EXT_USER))
        {
            // Detach the toolbar1 from the window
            hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar1);
            ASSERT(SUCCEEDED(hr));

            // Attach the toolbar2 to the window
            hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            // Detach the toolbars from the window
            hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar1);
            ASSERT(SUCCEEDED(hr));

            hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar2);
            ASSERT(SUCCEEDED(hr));
        }

        FREE_DATA(pInternal);

        EnableToolbar(m_pToolbar1, SnapinButtons,
                      ARRAYLEN(SnapinButtons), FALSE);

        EnableToolbar(m_pToolbar2, SnapinButtons2,
                      ARRAYLEN(SnapinButtons2), FALSE);
    }
    else // result item selected.
    {
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        if (pDataObject != NULL)
            pInternal = ExtractInternalFormat(pDataObject);

        if (pInternal == NULL)
            return;

        if (pInternal->m_type == CCT_RESULT)
        {
            bFileExBtn = true;

            ASSERT(m_pToolbar1);
            EnableToolbar(m_pToolbar1, SnapinButtons,
                          ARRAYLEN(SnapinButtons), TRUE);

            m_pToolbar1->SetButtonState(1, ENABLED,       FALSE);
            m_pToolbar1->SetButtonState(2, CHECKED,       TRUE);
            m_pToolbar1->SetButtonState(3, HIDDEN,        TRUE);
            m_pToolbar1->SetButtonState(4, INDETERMINATE, TRUE);
            m_pToolbar1->SetButtonState(5, BUTTONPRESSED, TRUE);

            // Above is the correct way
            ASSERT(m_pToolbar2);
            m_pToolbar2->SetButtonState(20, CHECKED,       TRUE);
            m_pToolbar2->SetButtonState(30, HIDDEN,        TRUE);
            m_pToolbar2->SetButtonState(40, INDETERMINATE, TRUE);
            m_pToolbar2->SetButtonState(50, BUTTONPRESSED, TRUE);

            EnableToolbar(m_pToolbar2, SnapinButtons2,
                          ARRAYLEN(SnapinButtons2), TRUE);
        }
        else // sub folder slected
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

            ASSERT(m_pControlbar);

            if (pInternal->m_cookie == 0)
            {
                if (IsPrimaryImpl() == TRUE)
                {
                    // Attach the toolbars to the window
                    hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
                    ASSERT(SUCCEEDED(hr));

                    hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
                    ASSERT(SUCCEEDED(hr));
                }
            }
            else if ((IsPrimaryImpl() == TRUE && pFolder->GetType() == COMPANY) ||
                     (IsPrimaryImpl() == FALSE && pFolder->GetType() == EXT_COMPANY))
            {
                // Detach the toolbar2 from the window
                hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar2);
                ASSERT(SUCCEEDED(hr));

                // Attach the toolbar1 to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
            else if ((IsPrimaryImpl() == TRUE && pFolder->GetType() == USER) ||
                     (IsPrimaryImpl() == FALSE && pFolder->GetType() == EXT_USER))
            {
                // Detach the toolbar1 from the window
                hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar1);
                ASSERT(SUCCEEDED(hr));

                // Attach the toolbar2 to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                // Detach the toolbars from the window
                hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar1);
                ASSERT(SUCCEEDED(hr));

                hr = m_pControlbar->Detach((LPUNKNOWN)m_pToolbar2);
                ASSERT(SUCCEEDED(hr));
            }

            ASSERT(m_pToolbar1);
            EnableToolbar(m_pToolbar1, SnapinButtons,
                          ARRAYLEN(SnapinButtons), TRUE);

            m_pToolbar1->SetButtonState(1, ENABLED,       FALSE);
            m_pToolbar1->SetButtonState(2, CHECKED,       TRUE);
            m_pToolbar1->SetButtonState(3, ENABLED,       TRUE);
            m_pToolbar1->SetButtonState(4, INDETERMINATE, TRUE);
            m_pToolbar1->SetButtonState(5, BUTTONPRESSED, TRUE);


            ASSERT(m_pToolbar2);
            EnableToolbar(m_pToolbar2, SnapinButtons2,
                          ARRAYLEN(SnapinButtons2), TRUE);

            // Above is the correct way
            m_pToolbar2->SetButtonState(20, CHECKED,       FALSE);
            m_pToolbar2->SetButtonState(30, ENABLED,       TRUE);
            m_pToolbar2->SetButtonState(40, INDETERMINATE, FALSE);
            m_pToolbar2->SetButtonState(50, BUTTONPRESSED, TRUE);
        }
    }

    if (m_pMenuButton1)
    {
        // Always make sure the menuButton is attached
        m_pControlbar->Attach(MENUBUTTON, m_pMenuButton1);

        if (bFileExBtn)
        {
            m_pMenuButton1->SetButtonState(FILEEX_MENU, HIDDEN, FALSE);
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, HIDDEN, TRUE);
            m_pMenuButton1->SetButtonState(FILEEX_MENU, ENABLED, TRUE);
        }
        else
        {
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, HIDDEN, FALSE);
            m_pMenuButton1->SetButtonState(FILEEX_MENU, HIDDEN, TRUE);
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, ENABLED, TRUE);
        }
    }
}


void CSnapin::HandleExtMenus(LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LPDATAOBJECT* ppDataObject = reinterpret_cast<LPDATAOBJECT*>(arg);
    LPMENUBUTTONDATA pMenuData = reinterpret_cast<LPMENUBUTTONDATA>(param);

    if (ppDataObject == NULL || pMenuData == NULL)
    {
        ASSERT(FALSE);
        return;
    }


    ::CMenu menu;
    ::CMenu* pMenu = NULL;

    switch (pMenuData->idCommand)
    {
    case FOLDEREX_MENU:
        menu.LoadMenu(FOLDEREX_MENU);
        pMenu = menu.GetSubMenu(0);
        break;

    case FILEEX_MENU:
        menu.LoadMenu(FILEEX_MENU);
        pMenu = menu.GetSubMenu(0);
        break;

    default:
        ASSERT(FALSE);
    }

    if (pMenu == NULL)
        return;

    pMenu->TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY, pMenuData->x, pMenuData->y, AfxGetMainWnd());

}


void CSnapin::GetItemName(LPDATAOBJECT pdtobj, LPTSTR pszName)
{
    ASSERT(pszName != NULL);
    pszName[0] = 0;

    INTERNAL* pInternal = ExtractInternalFormat(pdtobj);
    ASSERT(pInternal != NULL);
    if (pInternal == NULL)
        return;

    OLECHAR *pszTemp;

    USES_CONVERSION;

    if (pInternal->m_type == CCT_RESULT)
    {
        RESULT_DATA* pData;
        // if virtual, derive result item from index
        // else cookie is the item pointer
        if (m_bVirtualView)
            pData = GetVirtualResultItem(pInternal->m_cookie);
        else
            pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);

        ASSERT(pData != NULL);
        pszTemp = pData->szName;
    }
    else
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
        if (pFolder == 0)
            pszTemp = L"Static folder";
        else
            pszTemp = pFolder->m_pszName;
    }

    lstrcpy(pszName, OLE2T(pszTemp));
}


/* end of file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin


#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

class CFolder;

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX      = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
const USER_IMAGE            = 2;
const COMPANY_IMAGE         = 3;
const VIRTUAL_IMAGE         = 4;

/////////////////////////////////////////////////////////////////////////////
// Snapin

//
// helper methods extracting data from data object
//
INTERNAL *   ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *    ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *       ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *      ExtractClassID(LPDATAOBJECT lpDataObject);

class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet2,
    public IExtendContextMenu,
    public IPersistStream,
    public CComObjectRoot
{
BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    ~CComponentDataImpl();

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet2 interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        LONG_PTR handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT lpIDataObject, HBITMAP* lphWatermark,
                     HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* pbStretch);


// IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;

public:
// Other public methods
    void DeleteAndReinsertAll();

// Notify handler declarations
private:
    HRESULT OnDelete(MMC_COOKIE cookie);
    HRESULT OnRemoveChildren(LPARAM arg);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    CFolder* FindObject(MMC_COOKIE cookie);
    void CreateFolderList(LPDATAOBJECT lpDataObject);            // scope item cookie helper
    void DeleteList();
    void EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    HRESULT DoInsertWizard(LPPROPERTYSHEETCALLBACK lpProvider);

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;     // My interface pointer to the console
    HSCOPEITEM              m_pStaticRoot;
    BOOL                    m_bIsDirty;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(MMC_COOKIE cookie);

private:
    CList<CFolder*, CFolder*> m_scopeItemList;

#ifdef _DEBUG
    friend class CDataObject;
    int     m_cDataObjects;

#endif
};


class CComponentDataPrimaryImpl : public CComponentDataImpl,
    public CComCoClass<CComponentDataPrimaryImpl, &CLSID_Snapin>
{
public:
    DECLARE_REGISTRY(CSnapin, _T("Snapin.Snapin.1"), _T("Snapin.Snapin"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_Snapin; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }
};

class CComponentDataExtensionImpl : public CComponentDataImpl,
    public CComCoClass<CComponentDataExtensionImpl, &CLSID_Extension>
{
public:
    DECLARE_REGISTRY(CSnapin, _T("Extension.Extension.1"), _T("Extension.Extension"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID(){ return CLSID_Extension; }
    virtual const BOOL IsPrimaryImpl() { return FALSE; }
};


enum CUSTOM_VIEW_ID
{
    VIEW_DEFAULT_LV = 0,
    VIEW_CALENDAR_OCX = 1,
    VIEW_MICROSOFT_URL = 2,
    VIEW_DEFAULT_MESSAGE_VIEW = 3,
};

class CSnapin :
    public IComponent,
    public IExtendContextMenu,   // Step 3
    public IExtendControlbar,
    public IResultDataCompare,
    public IResultOwnerData,
    public IPersistStream,
    public CComObjectRoot
{
public:
    CSnapin();
    ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)   // Step 3
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
    COM_INTERFACE_ENTRY(IResultOwnerData)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IResultOwnerData
    STDMETHOD(FindItem)(LPRESULTFINDINFO pFindInfo, int* pnFoundIndex);
    STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex);
    STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // Only for debug purpose
    bool m_bInitializedC;
    bool m_bLoadedC;
    bool m_bDestroyedC;

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);
    void GetItemName(LPDATAOBJECT lpDataObject, LPTSTR pszName);
    BOOL IsPrimaryImpl()
    {
        CComponentDataImpl* pData =
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->IsPrimaryImpl();

        return FALSE;
    }

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClk(DATA_OBJECT_TYPES type, MMC_COOKIE cookie);
    HRESULT OnContextHelp(LPDATAOBJECT lpDataObject);
    void OnButtonClick(LPDATAOBJECT pdtobj, LONG_PTR idBtn);

    HRESULT QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                   LPDATAOBJECT* ppDataObject);

// IExtendContextMenu
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// End step 3

// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    void Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent);
    void EnumerateResultPane(MMC_COOKIE cookie);

    void PopulateMessageView (MMC_COOKIE cookie);

// Result pane helpers
    void AddResultItems(RESULT_DATA* pData, int nCount, int imageIndex);
    void AddUser();
    void AddCompany();
    void AddExtUser();
    void AddExtCompany();
    void AddVirtual();
    RESULT_DATA* GetVirtualResultItem(int iIndex);

    HRESULT InitializeBitmaps(MMC_COOKIE cookie);

// UI Helpers
    void HandleStandardVerbs(bool bDeselectAll, LPARAM arg, LPDATAOBJECT lpDataObject);
    void HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param);
    void HandleExtMenus(LPARAM arg, LPARAM param);
    void _OnRefresh(LPDATAOBJECT pDataObject);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list
    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LPMENUBUTTON        m_pMenuButton1; // Menu Button for view

    ::CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
    ::CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar


// Header titles for each nodetype(s)
protected:
    CString m_column1;      // Name
    CString m_column2;      // Size
    CString m_column3;      // Type

private:
    BOOL            m_bIsDirty;
    CUSTOM_VIEW_ID  m_CustomViewID;
    BOOL            m_bVirtualView;
    DWORD           m_dwVirtualSortOptions;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}


class CSnapinAboutImpl :
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CSnapinAboutImpl, &CLSID_About>
{
public:
    CSnapinAboutImpl();
    ~CSnapinAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.About.1"), _T("Snapin.About"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CSnapinAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage,
                                    HBITMAP* hSmallImageOpen,
                                    HBITMAP* hLargeImage,
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};


#define FREE_DATA(pData) \
    ASSERT(pData != NULL); \
    do { if (pData != NULL) \
        GlobalFree(pData); } \
    while(0);


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "stdafx.h"
#include "Service.h" 
#include "CSnapin.h"
#include "DataObj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = 0;
unsigned int CDataObject::m_cfNodeTypeString = 0;  
unsigned int CDataObject::m_cfDisplayName    = 0; 
unsigned int CDataObject::m_cfCoClass        = 0; 
unsigned int CDataObject::m_cfNodeID         = 0;

unsigned int CDataObject::m_cfInternal       = 0; 
unsigned int CDataObject::m_cfMultiSel       = 0;



    
// Extension information
// The only additional clipboard format supported is to get the workstation name.
unsigned int CDataObject::m_cfWorkstation    = 0;

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

CDataObject::CDataObject()
{
    USES_CONVERSION;

    m_cfNodeType       = RegisterClipboardFormat(W2T(CCF_NODETYPE));
    m_cfNodeTypeString = RegisterClipboardFormat(W2T(CCF_SZNODETYPE));  
    m_cfDisplayName    = RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME)); 
    m_cfCoClass        = RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID)); 
    m_cfMultiSel       = RegisterClipboardFormat(W2T(CCF_OBJECT_TYPES_IN_MULTI_SELECT));
    m_cfNodeID         = RegisterClipboardFormat(W2T(CCF_NODEID));

#ifdef UNICODE
    m_cfInternal       = RegisterClipboardFormat(W2T((LPTSTR)SNAPIN_INTERNAL)); 
    m_cfWorkstation    = RegisterClipboardFormat(W2T((LPTSTR)SNAPIN_WORKSTATION));
#else
    m_cfInternal       = RegisterClipboardFormat(W2T(SNAPIN_INTERNAL)); 
    m_cfWorkstation    = RegisterClipboardFormat(W2T(SNAPIN_WORKSTATION));
#endif //UNICODE


    #ifdef _DEBUG
        m_ComponentData = NULL;
        dbg_refCount = 0;
    #endif

    m_pbMultiSelData = 0;
    m_cbMultiSelData = 0;
    m_bMultiSelDobj = FALSE;
}


STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfMultiSel)
    {
        ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
            return E_FAIL;
        
        //return CreateMultiSelData(lpMedium);

        ASSERT(m_pbMultiSelData != 0);
        ASSERT(m_cbMultiSelData != 0);

        lpMedium->tymed = TYMED_HGLOBAL; 
        lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, 
                                          (m_cbMultiSelData + sizeof(DWORD)));
        if (lpMedium->hGlobal == NULL)
            return STG_E_MEDIUMFULL;

        BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
        *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID); 
        pb += sizeof(DWORD);
        CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

        ::GlobalUnlock(lpMedium->hGlobal);

        hr = S_OK;
    }
#ifdef RECURSIVE_NODE_EXPANSION
    else if (cf == m_cfNodeID)
    {
        // Create the node type object in GUID format
        BYTE    byData[256] = {0};
        SNodeID* pData = reinterpret_cast<SNodeID*>(byData);
        LPCTSTR pszText;
    
        if (m_internal.m_cookie == NULL)
        {
            return (E_FAIL);
        }
        else if (m_internal.m_type == CCT_SCOPE)
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
            ASSERT(pFolder != NULL);
            if (pFolder == NULL)
                return E_UNEXPECTED;
            
            switch (pFolder->GetType())
            {
                // save the user node as a custom node ID   
                case USER:
                    pszText = _T("___Custom ID for User Data node___");
                    break;

                // save the company node as a string
                case COMPANY:
                    return (E_FAIL);
                    break;
            
                // truncate anything below a virtual node
                case VIRTUAL:
                    pszText = _T("");
                    break;
            
                case EXT_USER:
                case EXT_COMPANY:
                case EXT_VIRTUAL:
                default:
                    return (E_FAIL);
                    break;
            }
        }
        else if (m_internal.m_type == CCT_RESULT)
        {
            return (E_FAIL);
        }
    
        _tcscpy ((LPTSTR) pData->id, pszText);
        pData->cBytes = _tcslen ((LPTSTR) pData->id) * sizeof (TCHAR);
        int cb = pData->cBytes + sizeof (pData->cBytes);

        lpMedium->tymed = TYMED_HGLOBAL; 
        lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);

        if (lpMedium->hGlobal == NULL)
            return STG_E_MEDIUMFULL;

        BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
        CopyMemory(pb, pData, cb);

        ::GlobalUnlock(lpMedium->hGlobal);

        hr = S_OK;
    }
#endif  /* RECURSIVE_NODE_EXPANSION */

    return hr;
}

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfWorkstation)
    {
        hr = CreateWorkstationName(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}


HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium)
{
    ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        
    ASSERT(m_pbMultiSelData != 0);
    ASSERT(m_cbMultiSelData != 0);

    return Create(reinterpret_cast<const void*>(m_pbMultiSelData), 
                  m_cbMultiSelData, lpMedium);
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pcObjectType = NULL;

    if (m_internal.m_cookie == NULL)
    {
        pcObjectType = &cNodeTypeStatic;
    }
    else if (m_internal.m_type == CCT_SCOPE)
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
        ASSERT(pFolder != NULL);
        if (pFolder == NULL)
            return E_UNEXPECTED;
        
        switch (pFolder->GetType())
        {
        case COMPANY:
            pcObjectType = &cNodeTypeCompany;
            break;
    
        case USER:
            pcObjectType = &cNodeTypeUser;
            break;
    
        case EXT_COMPANY:
            pcObjectType = &cNodeTypeExtCompany;
            break;
    
        case EXT_USER:
            pcObjectType = &cNodeTypeExtUser;
            break;
    
        case VIRTUAL:
        case EXT_VIRTUAL:
            pcObjectType = &cNodeTypeExtUser;
            break;
    
        default:
            pcObjectType = &cNodeTypeDynamic;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        // RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(m_internal.m_cookie);
        
        pcObjectType = &cObjectTypeResultItem;
    }

    return Create(reinterpret_cast<const void*>(pcObjectType), sizeof(GUID), 
                  lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    const WCHAR* cszObjectType = NULL;

    if (m_internal.m_cookie == NULL)
    {
        cszObjectType = cszNodeTypeStatic;
    }
    else if (m_internal.m_type == CCT_SCOPE)
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);
        ASSERT(pFolder != NULL);
        if (pFolder == NULL)
            return E_UNEXPECTED;

        switch (pFolder->GetType())
        {
        case COMPANY:
            cszObjectType = cszNodeTypeCompany;
            break;
    
        case USER:
            cszObjectType = cszNodeTypeUser;
            break;
    
        case EXT_COMPANY:
            cszObjectType = cszNodeTypeExtCompany;
            break;
    
        case EXT_USER:
            cszObjectType = cszNodeTypeExtUser;
            break;
    
        default:
            cszObjectType = cszNodeTypeDynamic;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        // RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(m_internal.m_cookie);
        
        cszObjectType = cszObjectTypeResultItem;
    }
    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    USES_CONVERSION;

#ifdef UNICODE
    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium);
#else
    return Create(T2W(szDispName), ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium);
#endif
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateWorkstationName(LPSTGMEDIUM lpMedium)
{
    TCHAR pzName[MAX_COMPUTERNAME_LENGTH+1] = {0};
    DWORD len = MAX_COMPUTERNAME_LENGTH+1;

    if (GetComputerName(pzName, &len) == FALSE)
        return E_FAIL;

    // Add 1 for the NULL and calculate the bytes for the stream
//#ifdef UNICODE
    USES_CONVERSION;
    return Create(T2W(pzName), ((len+1)* sizeof(WCHAR)), lpMedium);
//#else
//    return Create(pzName, ((len+1)* sizeof(WCHAR)), lpMedium);
//#endif

}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject();
    ~CDataObject()
    {
    #ifdef _DEBUG
        m_ComponentData = NULL;
    #endif

        delete [] m_pbMultiSelData;
    };

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    static unsigned int    m_cfMultiSel;        // Required by the console
    static unsigned int    m_cfNodeID;          // Published information

    static unsigned int    m_cfInternal;        // Step 3
    static unsigned int    m_cfWorkstation;     // Published information

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
#ifdef _DEBUG
        ASSERT(m_ComponentData != NULL);
        ++(m_ComponentData->m_cDataObjects);
        if (m_bMultiSelDobj == TRUE)
            AddRefMultiSelDobj();
#endif
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
#ifdef _DEBUG
        ASSERT(m_ComponentData != NULL);
        --(m_ComponentData->m_cDataObjects);
        if (m_bMultiSelDobj == TRUE)
            ReleaseMultiSelDobj();
#endif
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    // This is used only as a diagnostic in debug builds to track if
    // anyone is hanging on to any data objects that's have been handed out
    // Snapin's should view context data objects as ephemeral.
#ifdef _DEBUG
public:
    void SetComponentData(CComponentDataImpl* pCCD)
    {
        ASSERT(m_ComponentData == NULL && pCCD != NULL); m_ComponentData = pCCD;
    } ;
private:
    CComponentDataImpl* m_ComponentData;
#endif

public:
    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid) { m_internal.m_clsid = clsid; }

    void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
    {
        m_pbMultiSelData = pbMultiSelData;
        m_cbMultiSelData = cbMultiSelData;
    }

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

    BOOL IsMultiSelDobj()
    {
        return m_bMultiSelDobj;
    }

#ifdef _DEBUG
    UINT dbg_refCount;


    void AddRefMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        ++dbg_refCount;
    }

    void ReleaseMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        --dbg_refCount;
        //if (dbg_refCount == 0)
        //    ::MessageBox(NULL, _T("Final release on multi-sel-dobj"), _T("Sample snapin"), MB_OK);
    }
#endif

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3
    HRESULT CreateWorkstationName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateMultiSelData(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;    // Step 3

    BYTE* m_pbMultiSelData;
    UINT m_cbMultiSelData;
    BOOL m_bMultiSelDobj;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "Service.h" 
#include "CSnapin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Primary Data
RESULT_DATA StaticRootData[NUM_NAMES] =
{
    {RESULT_ITEM, USER, L"Bill", L"990", L"CEO"},
    {RESULT_ITEM, USER, L"Jill", L"991", L"Director"},
    {RESULT_ITEM, USER, L"Hill", L"992", L"President"},
    {RESULT_ITEM, USER, L"Will", L"993", L"Chairman"},
};

RESULT_DATA UserData[NUM_NAMES] =
{
    {RESULT_ITEM, USER, L"Joe", L"100", L"Employee"},
    {RESULT_ITEM, USER, L"Harry", L"101", L"Manager"},
    {RESULT_ITEM, USER, L"Jane", L"102", L"Vice President"},
    {RESULT_ITEM, USER, L"Sue", L"103", L"Developer"},
};

RESULT_DATA CompanyData[NUM_COMPANY] = 
{
    {RESULT_ITEM, COMPANY, L"Taxes", L"43", L"IRS Documents"},
    {RESULT_ITEM, COMPANY, L"Medical", L"345", L"HMO"},
    {RESULT_ITEM, COMPANY, L"Dental", L"121", L"Plus Plan"},
    {RESULT_ITEM, COMPANY, L"Insurance", L"2332", L"Dollars are Us"},
    {RESULT_ITEM, COMPANY, L"401K", L"1000", L"Up to you"},
    {RESULT_ITEM, COMPANY, L"Legal", L"78", L"Yes"}
};

// Extension data
RESULT_DATA UserDataExt[NUM_NAMES] =
{
    {RESULT_ITEM, EXT_USER, L"Charles", L"200", L"Employee"},
    {RESULT_ITEM, EXT_USER, L"Jill", L"201", L"Manager"},
    {RESULT_ITEM, EXT_USER, L"John", L"202", L"Vice President"},
    {RESULT_ITEM, EXT_USER, L"Tami", L"203", L"Developer"},
};

RESULT_DATA CompanyDataExt[NUM_COMPANY] = 
{
    {RESULT_ITEM, EXT_COMPANY, L"Payroll", L"99", L"Corporate Payroll"},
    {RESULT_ITEM, EXT_COMPANY, L"Health", L"568", L"HMO"},
    {RESULT_ITEM, EXT_COMPANY, L"Health Club", L"834", L"Plus Plan"},
    {RESULT_ITEM, EXT_COMPANY, L"Insurance", L"1101", L"Dollars are Us"},
    {RESULT_ITEM, EXT_COMPANY, L"401K", L"1543", L"Up to you"},
    {RESULT_ITEM, EXT_COMPANY, L"Legal", L"27", L"Yes"}
};

// We use a single structure for all virtual items, so 
// the name field points to this buffer that is changed 
// on the fly.
WCHAR VirtualItemName[MAX_ITEM_NAME];

RESULT_DATA VirtualData[1] =
{ 
    {RESULT_ITEM, VIRTUAL, VirtualItemName, L"100", L"Virtual"}
};


/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT CSnapin::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CSnapin::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    // if cookie is from a different snapin
    // if (IsMyCookie(cookie) == FALSE)
    if (arg)
    {
        // add the images for the scope tree only
        ::CBitmap bmp16x16;
        ::CBitmap bmp32x32;
        LPIMAGELIST lpImageList = reinterpret_cast<LPIMAGELIST>(arg);
    
        // Load the bitmaps from the dll
        bmp16x16.LoadBitmap(IDB_16x16);
        bmp32x32.LoadBitmap(IDB_32x32);
    
        // Set the images
        lpImageList->ImageListSetStrip(
                        reinterpret_cast<PLONG_PTR>(static_cast<HBITMAP>(bmp16x16)),
                        reinterpret_cast<PLONG_PTR>(static_cast<HBITMAP>(bmp32x32)),
                        0, RGB(255, 0, 255));
    }
    else 
    {
        InitializeBitmaps(cookie);
    }
    return S_OK;
}

HRESULT CSnapin::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        // if list view on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            // Show the headers for this nodetype
            InitializeHeaders(cookie);
            Enumerate(cookie, param);
        }

        else if (m_CustomViewID == VIEW_DEFAULT_MESSAGE_VIEW)
        {
            PopulateMessageView (cookie);
        }

        // BUBBUG - Demonstration to should how you can attach
        // and a toolbar when a particular nodes gets focus.
        // warning this needs to be here as the toolbars are
        // currently hidden when the previous node looses focus.
        // This should be update to show the user how to hide
        // and show toolbars. (Detach and Attach).

        //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
        //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
    }
    else
    {

        // BUGBUG - Demonstration this to show how to hide toolbars that
        // could be particular to a single node.
        // currently this is used to hide the toolbars the console 
        // does not do any toolbar clean up.

        //m_pControlbar->Detach(m_pToolbar1);
        //m_pControlbar->Detach(m_pToolbar2);
        // Free data associated with the result pane items, because
        // your node is no longer being displayed.
        // Note: The console will remove the items from the result pane
    }

    return S_OK;
}

HRESULT CSnapin::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CSnapin::OnResultItemClk(DATA_OBJECT_TYPES type, MMC_COOKIE cookie)
{
    RESULT_DATA* pResult;

    if (m_bVirtualView == TRUE)
    {
        pResult = GetVirtualResultItem(cookie);
    }
    else if (cookie != 0)
    {
        DWORD* pdw = reinterpret_cast<DWORD*>(cookie);
        if (*pdw == RESULT_ITEM)
        {
            pResult = reinterpret_cast<RESULT_DATA*>(cookie);
        }
    }

    return S_OK;
}

HRESULT CSnapin::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CSnapin::OnPropertyChange(LPDATAOBJECT lpDataObject)
{

    return S_OK;
}

HRESULT CSnapin::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CSnapin::Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    EnumerateResultPane(cookie);
}

void CSnapin::EnumerateResultPane(MMC_COOKIE cookie)
{
    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);

    // Our static folders must be displayed in the result pane
    // by use because the console doesn't do it.
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    FOLDER_TYPES type = pFolder ? pFolder->GetType() : STATIC;

    switch(type)
    {
    case STATIC:
        AddResultItems(&StaticRootData[0], NUM_NAMES, 4);
        break;

    case COMPANY:
        AddCompany();
        break;

    case USER:
        AddUser();
        break;

    case EXT_USER:
        AddExtUser();
        break;

    case EXT_COMPANY:
        AddExtCompany();
        break;

    case VIRTUAL:
    case EXT_VIRTUAL:
        AddVirtual();
        break;

    default:
        break;
    }
}

void CSnapin::PopulateMessageView(MMC_COOKIE cookie)
{
    ASSERT(m_pComponentData != NULL);
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    FOLDER_TYPES type = pFolder ? pFolder->GetType() : STATIC;

    IUnknown* pResultUnk;
    HRESULT hr = m_pConsole->QueryResultView (&pResultUnk);
    ASSERT (SUCCEEDED (hr) && "IConsole::QueryResultView failed");

    IMessageView* pMessageView;
    hr = pResultUnk->QueryInterface (IID_IMessageView, (void**) &pMessageView);
    ASSERT (SUCCEEDED (hr) && "Couldn't query IMessageView interface from the result pane.");

    switch(type)
    {
        case STATIC:
            pMessageView->SetTitleText (L"This is the Files node.  It uses the error icon.");
            pMessageView->SetBodyText  (L"REDMOND, WashMicrosoft Corp. today will release a third test version of its Windows 2000 operating system to its plants, a major hurdle in delivering the long-delayed program to the market."
                                        L"\n\nThe third \"beta\" version of the program is expected to be the final test version before the product is completed. Shortly after the test code reaches Microsoft's manufacturing plants, the company is expected to begin the process of distributing as many as 650,000 copies, the widest reach yet of any test version of Windows. Many of those users will be paying for the privilege; Microsoft intends to charge $59.95 for copies of the Windows 2000 beta sold via its World Wide Web site.");
            pMessageView->SetIcon      (Icon_Error);
            break;
    
        case COMPANY:
            pMessageView->SetTitleText (L"This is the Company node.  It uses the information icon and has a really, really long title that should span several lines.  In fact, it could span more than several lines, it could span dozens or even hundreds of lines.");
            pMessageView->SetBodyText  (L"This is the (short) body text for the company node");
            pMessageView->SetIcon      (Icon_Information);
            break;
    
        case USER:
            pMessageView->SetTitleText (L"This is the User node.  Is uses the warning icon and has no body text.");
            pMessageView->SetBodyText  (NULL);
            pMessageView->SetIcon      (Icon_Warning);
            break;
    
        case VIRTUAL:
        case EXT_VIRTUAL:
            pMessageView->SetTitleText (L"This is the Virtual node.  It has no icon.");
            pMessageView->SetBodyText  (L"REDMOND, WashMicrosoft Corp. today will release a third test version of its Windows 2000 operating system to its plants, a major hurdle in delivering the long-delayed program to the market."
                                        L"\n\nThe third \"beta\" version of the program is expected to be the final test version before the product is completed. Shortly after the test code reaches Microsoft's manufacturing plants, the company is expected to begin the process of distributing as many as 650,000 copies, the widest reach yet of any test version of Windows. Many of those users will be paying for the privilege; Microsoft intends to charge $59.95 for copies of the Windows 2000 beta sold via its World Wide Web site.");
            pMessageView->SetIcon      (Icon_None);
            break;
    
        default:
            AfxMessageBox (_T("CSnapin::PopulateMessageView:  default node type, clearing message view"));
            pMessageView->Clear ();
            break;
    }

    pMessageView->Release();
    pResultUnk->Release();
}

void CSnapin::AddResultItems(RESULT_DATA* pData, int nCount, int imageIndex)
{
    ASSERT(m_pResult);

    RESULTDATAITEM resultItem;
    memset(&resultItem, 0, sizeof(RESULTDATAITEM));

    for (int i=0; i < nCount; i++)
    {
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.str = MMC_TEXTCALLBACK;
        resultItem.nImage = imageIndex;
        resultItem.lParam = reinterpret_cast<LPARAM>(pData + i);
        m_pResult->InsertItem(&resultItem);
    }

    m_pResult->Sort(0,0,-1);

}

void CSnapin::AddUser()
{
    AddResultItems(&UserData[0], NUM_NAMES, 4);
}

void CSnapin::AddCompany()
{
    AddResultItems(&CompanyData[0], NUM_COMPANY, 3);
}

void CSnapin::AddExtUser()
{
    AddResultItems(&UserDataExt[0], NUM_NAMES, 4);
}

void CSnapin::AddExtCompany()
{
    AddResultItems(&CompanyDataExt[0], NUM_COMPANY, 3);
}

void CSnapin::AddVirtual()
{
    // for virtual data, just set the item count
    m_pResult->SetItemCount(NUM_VIRTUAL_ITEMS, MMCLV_UPDATE_NOINVALIDATEALL);
}


RESULT_DATA* CSnapin::GetVirtualResultItem(int iIndex)
{
    // reverse order for descending sort
    if (m_dwVirtualSortOptions & RSI_DESCENDING)
        iIndex = (NUM_VIRTUAL_ITEMS - 1) - iIndex;

    // Create a name from the index
    swprintf(VirtualItemName, L"%d", iIndex);

    // return pointer to the virtual result item
    return &VirtualData[0];
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\genpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       genpage.cpp
//
//--------------------------------------------------------------------------

// genpage.cpp : implementation file
//

#include "stdafx.h"
#include "Service.h" 
#include "csnapin.h"
#include "resource.h"
#include "afxdlgs.h"
#include "genpage.h"
#include "dataobj.h"
#include "prsht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CGeneralPage property page

IMPLEMENT_DYNCREATE(CGeneralPage, CPropertyPage)

CGeneralPage::CGeneralPage() : CPropertyPage(CGeneralPage::IDD)
{

    //{{AFX_DATA_INIT(CGeneralPage)
    m_szName = _T("");
    //}}AFX_DATA_INIT

    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;

}

CGeneralPage::~CGeneralPage()
{
}

void CGeneralPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGeneralPage)
    DDX_Control(pDX, IDC_NEW_FOLDER, m_EditCtrl);
    DDX_Text(pDX, IDC_NEW_FOLDER, m_szName);
    DDV_MaxChars(pDX, m_szName, 64);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGeneralPage, CPropertyPage)
    //{{AFX_MSG_MAP(CGeneralPage)
    ON_WM_DESTROY()
    ON_EN_CHANGE(IDC_NEW_FOLDER, OnEditChange)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage message handlers



void CGeneralPage::OnDestroy() 
{
    // Note - This needs to be called only once.  
    // If called more than once, it will gracefully return an error.
    MMCFreeNotifyHandle(m_hConsoleHandle);

    CPropertyPage::OnDestroy();

    // Delete the CGeneralPage object
    delete this;
}


void CGeneralPage::OnEditChange() 
{
    // Page is dirty, mark it.
    SetModified();  
    m_bUpdate = TRUE;
}


BOOL CGeneralPage::OnApply() 
{
    if (m_bUpdate == TRUE)
    {

        USES_CONVERSION;
        // Simple string cookie, could be anything!
        LPWSTR lpString = 
            reinterpret_cast<LPWSTR>(
          ::GlobalAlloc(GMEM_SHARE, 
                        (sizeof(wchar_t) * 
                        (m_szName.GetLength() + 1))
                        ));

        wcscpy(lpString, T2COLE(m_szName));

        // Send a property change notify to the console
        MMCPropertyChangeNotify(m_hConsoleHandle, reinterpret_cast<LPARAM>(lpString));
        m_bUpdate = FALSE;
    }
    
    return CPropertyPage::OnApply();
}
/////////////////////////////////////////////////////////////////////////////
// CExtensionPage property page

IMPLEMENT_DYNCREATE(CExtensionPage, CPropertyPage)

CExtensionPage::CExtensionPage() : CPropertyPage(CExtensionPage::IDD)
{
    //{{AFX_DATA_INIT(CExtensionPage)
    m_szText = _T("");
    //}}AFX_DATA_INIT
}

CExtensionPage::~CExtensionPage()
{
}

void CExtensionPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CExtensionPage)
    DDX_Control(pDX, IDC_EXT_TEXT, m_hTextCtrl);
    DDX_Text(pDX, IDC_EXT_TEXT, m_szText);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExtensionPage, CPropertyPage)
    //{{AFX_MSG_MAP(CExtensionPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExtensionPage message handlers

BOOL CExtensionPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    
    m_hTextCtrl.SetWindowText(m_szText);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CStartUpWizard property page


// NOTICE: need to override this because CPropertyPage::AssertValid() 
// would otherwise assert
IMPLEMENT_DYNCREATE(CBaseWizard, CPropertyPage)

CBaseWizard::CBaseWizard(UINT id) : CPropertyPage(id)
{
    // NOTICE: need to do this because MFC was compiled with NT 4.0
    // headers that had a different size
    ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE)); 

    memcpy(&m_psp97, &m_psp, m_psp.dwSize);
    m_psp97.dwSize = sizeof(PROPSHEETPAGE);
}

void CBaseWizard::OnDestroy() 
{
    CPropertyPage::OnDestroy();
    delete this;    
}

BEGIN_MESSAGE_MAP(CBaseWizard, CPropertyPage)
    //{{AFX_MSG_MAP(CStartupWizard1)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNCREATE(CStartUpWizard, CBaseWizard)

CStartUpWizard::CStartUpWizard() : CBaseWizard(CStartUpWizard::IDD)
{
    //{{AFX_DATA_INIT(CStartUpWizard)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_psp97.dwFlags |= PSP_HIDEHEADER;
}

CStartUpWizard::~CStartUpWizard()
{
}

void CStartUpWizard::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStartUpWizard)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStartUpWizard, CBaseWizard)
    //{{AFX_MSG_MAP(CStartUpWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStartUpWizard message handlers

BOOL CStartUpWizard::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CStartUpWizard::OnSetActive() 
{
    // TODO: Add your specialized code here and/or call the base class

    // TODO: Add your specialized code here and/or call the base class
    HWND hwnd = GetParent()->m_hWnd;
    ::SendMessage(hwnd, PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
    
    return CPropertyPage::OnSetActive();
}
/////////////////////////////////////////////////////////////////////////////
// CStartupWizard1 property page

IMPLEMENT_DYNCREATE(CStartupWizard1, CBaseWizard)

CStartupWizard1::CStartupWizard1() : CBaseWizard(CStartupWizard1::IDD)
{
    //{{AFX_DATA_INIT(CStartupWizard1)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    m_psp97.pszHeaderTitle = _T("This is the title line");
    m_psp97.pszHeaderSubTitle = _T("This is the sub-title line");
}

CStartupWizard1::~CStartupWizard1()
{
}

void CStartupWizard1::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStartupWizard1)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStartupWizard1, CBaseWizard)
    //{{AFX_MSG_MAP(CStartupWizard1)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStartupWizard1 message handlers

BOOL CStartupWizard1::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    
    // TODO: Add extra initialization here
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CStartupWizard1::OnSetActive() 
{
    // TODO: Add your specialized code here and/or call the base class
    HWND hwnd = GetParent()->m_hWnd;
    ::SendMessage(hwnd, PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH | PSWIZB_BACK);
    
    return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\service.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "Service.h"
#include "CSnapin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void CFolder::Create(LPWSTR szName, int nImage, int nOpenImage,
                                FOLDER_TYPES type, BOOL bHasChildren)
{
    ASSERT(m_pScopeItem == NULL); // Calling create twice on this item?

    // Two-stage construction
    m_pScopeItem = new SCOPEDATAITEM;
    memset(m_pScopeItem, 0, sizeof(SCOPEDATAITEM));

    // Set folder type
    m_type = type;

    // Add node name
    if (szName != NULL)
    {
        m_pScopeItem->mask = SDI_STR;
        m_pScopeItem->displayname = (unsigned short*)(-1);

        UINT uiByteLen = (wcslen(szName) + 1) * sizeof(OLECHAR);
        LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);

        if (psz != NULL)
        {
            wcscpy(psz, szName);
            m_pszName = psz;
        }
    }

    // Add close image
    if (nImage != 0)
    {
        m_pScopeItem->mask |= SDI_IMAGE;
        m_pScopeItem->nImage = nImage;
    }

    // Add open image
    if (nOpenImage != 0)
    {
        m_pScopeItem->mask |= SDI_OPENIMAGE;
        m_pScopeItem->nOpenImage = nOpenImage;
    }

    // Add button to node if the folder has children
    m_pScopeItem->mask |= SDI_CHILDREN;
    m_pScopeItem->cChildren = (bHasChildren == TRUE) ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\genpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       genpage.h
//
//--------------------------------------------------------------------------

// genpage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage dialog

class CGeneralPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CGeneralPage)

// Construction
public:
    CGeneralPage();
    ~CGeneralPage();
    BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);

// Dialog Data
    //{{AFX_DATA(CGeneralPage)
    enum { IDD = IDD_GENERAL };
    ::CEdit m_EditCtrl;
    CString m_szName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CGeneralPage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CGeneralPage)
    afx_msg void OnDestroy();
    afx_msg void OnEditChange();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    LONG_PTR m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
};
/////////////////////////////////////////////////////////////////////////////
// CExtensionPage dialog

class CExtensionPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CExtensionPage)

// Construction
public:
    CExtensionPage();
    ~CExtensionPage();

// Dialog Data
    //{{AFX_DATA(CExtensionPage)
    enum { IDD = IDD_EXTENSION_PAGE };
    ::CStatic   m_hTextCtrl;
    CString m_szText;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CExtensionPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CExtensionPage)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CStartUpWizard dialog

class CBaseWizard : public CPropertyPage
{
    DECLARE_DYNCREATE(CBaseWizard)
public:
    CBaseWizard(UINT id);
    CBaseWizard() {};

// Implementation
public:
    PROPSHEETPAGE m_psp97;

protected:
    // Generated message map functions
    //{{AFX_MSG(CStartUpWizard)
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

class CStartUpWizard : public CBaseWizard
{
    DECLARE_DYNCREATE(CStartUpWizard)

// Construction
public:
    CStartUpWizard();
    ~CStartUpWizard();

// Dialog Data
    //{{AFX_DATA(CStartUpWizard)
    enum { IDD = IDD_INSERT_WIZARD };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CStartUpWizard)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CStartUpWizard)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////////
// CStartupWizard1 dialog

class CStartupWizard1 : public CBaseWizard
{
    DECLARE_DYNCREATE(CStartupWizard1)

// Construction
public:
    CStartupWizard1();
    ~CStartupWizard1();

// Dialog Data
    //{{AFX_DATA(CStartupWizard1)
    enum { IDD = IDD_INSERT_WIZARD };
    // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CStartupWizard1)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CStartupWizard1)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\service.h ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _SERVICE_H
#define _SERVICE_H

// Forward declarations
class CSnapin;

#define SCOPE_ITEM      111
#define RESULT_ITEM     222

// Internal structure used for cookies
struct FOLDER_DATA
{
    wchar_t*    szName;
    wchar_t*    szSize;
    wchar_t*    szType;

    FOLDER_TYPES    type;
};

struct RESULT_DATA
{
    DWORD       itemType; // used for debug purpose only
    FOLDER_TYPES parentType;

    wchar_t*    szName;
    wchar_t*    szSize;
    wchar_t*    szType;
};


class CFolder
{
    DWORD       itemType;   // Used for debug purpose only. This should be the first
                            // member. The class should not have any virtual fuctions.

    friend class CSnapin;
    friend class CComponentDataImpl;

public:
    // UNINITIALIZED is an invalid memory address and is a good cookie initializer
    CFolder()
    {
        itemType = SCOPE_ITEM;  // used for debug purpose only

        m_cookie = UNINITIALIZED;
        m_enumed = FALSE;
        m_pScopeItem = NULL;
        m_type = NONE;
        m_pszName = NULL;
    };

    ~CFolder() { delete m_pScopeItem; CoTaskMemFree(m_pszName); };

// Interface
public:
    BOOL IsEnumerated() { return  m_enumed; };
    void Set(BOOL state) { m_enumed = state; };
    void SetCookie(MMC_COOKIE cookie) { m_cookie = cookie; }
    FOLDER_TYPES GetType() { ASSERT(m_type != NONE); return m_type; };
    BOOL operator == (const CFolder& rhs) const { return rhs.m_cookie == m_cookie; };
    BOOL operator == (MMC_COOKIE cookie) const { return cookie == m_cookie; };
    void SetName(LPWSTR pszIn)
    {
        UINT len = wcslen(pszIn) + 1;
        LPWSTR psz = (LPWSTR)CoTaskMemAlloc(len * sizeof(WCHAR));
        if (psz != NULL)
        {
            wcscpy(psz, pszIn);
            CoTaskMemFree(m_pszName);
            m_pszName = psz;
        }
    }

    HSCOPEITEM GetItemID()
    {
        return m_pScopeItem->ID;
    }

// Implementation
private:
    void Create(LPWSTR szName, int nImage, int nOpenImage,
        FOLDER_TYPES type, BOOL bHasChildren = FALSE);

// Attributes
private:
    LPSCOPEDATAITEM m_pScopeItem;
    MMC_COOKIE          m_cookie;
    BOOL            m_enumed;
    FOLDER_TYPES    m_type;
    LPOLESTR        m_pszName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\snapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Snapinps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Service.h" 
#include "CSnapin.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Snapin, CComponentDataPrimaryImpl)
	OBJECT_ENTRY(CLSID_Extension, CComponentDataExtensionImpl)
	OBJECT_ENTRY(CLSID_About, CSnapinAboutImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CSnapinApp theApp;

BOOL CSnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
	_Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
    DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_NODENAME                    5
#define IDS_STRING6                     6
#define IDS_DESCRIPTION                 6
#define IDS_VERSION                     7
#define IDS_COMPANY                     8
#define IDD_GENERAL                     107
#define IDD_EXTENSION_PAGE              108
#define IDD_INSERT_WIZARD               109
#define IDC_NEW_FOLDER                  201
#define IDB_16x16                       202
#define IDC_EXT_STATIC                  202
#define IDB_32x32                       203
#define IDC_EXT_TEXT                    203
#define IDI_FOLDER                      205
#define IDB_TOOLBAR1                    207
#define IDB_TOOLBAR2                    208
#define IDI_APPICON                     209
#define IDB_SMALLBMP                    210
#define IDB_LARGE                       211
#define IDR_MENU1                       212
#define FILEEX_MENU                     213
#define FOLDEREX_MENU                   214
#define IDB_WATERMARK                   216
#define IDB_BANNER                      218
#define ID_TEST2_ITEM1                  32770
#define ID_TEST2_ITEM2                  32771
#define ID_TEST2_ITEM3                  32773
#define ID_TEST2_ITEM4_ITEMA            32774
#define ID_TEST2_ITEM4_ITEMB            32775
#define ID_TEST2_ITEM4_ITEMC            32776
#define ID_TEST2_ITEM5                  32777
#define ID_TEST2_COLOR1                 32779
#define ID_TEST2_COLOR2                 32780
#define ID_TEST2_COLOR3                 32781
#define ID_MENUITEM32782                32782
#define ID_MENUITEM32783                32783
#define ID_MENUITEM32784                32784
#define ID_MENUITEM32785                32785
#define ID_MENUITEM32786                32786

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         204
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\snapin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       snapin.h
//
//--------------------------------------------------------------------------

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Oct 03 17:06:29 1996
 */
/* Compiler settings for Snapin.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Snapin_h__
#define __Snapin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IComponent : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponent_INTERFACE_DEFINED__ */



#ifndef __SNAPINLib_LIBRARY_DEFINED__
#define __SNAPINLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SNAPINLib
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SNAPINLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Snapin;

class Snapin;
#endif
#endif /* __SNAPINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF


MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=snapin
TARGETPATH=obj
TARGETTYPE=DYNLINK

WIN32_WINNT_VERSION=0x0500
WIN32_IE_VERSION=0x0400
SUBSYSTEM_VERSION=5.00

USE_ATL=1
USE_MFC=1


DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

TARGETLIBS= \
            $(SDK_LIB_PATH)\mmc.lib            \
            $(SDK_LIB_PATH)\kernel32.lib       \
            $(SDK_LIB_PATH)\user32.lib         \
            $(SDK_LIB_PATH)\oleaut32.lib       \
            $(SDK_LIB_PATH)\ole32.lib          \
            $(SDK_LIB_PATH)\advapi32.lib       \
            $(SDK_LIB_PATH)\uuid.lib           \
            $(SDK_LIB_PATH)\comctl32.lib       \
            $(SDK_LIB_PATH)\comdlg32.lib       \
            $(SDK_LIB_PATH)\netapi32.lib       \
            $(SDK_LIB_PATH)\gdi32.lib          \
            $(SDK_LIB_PATH)\shell32.lib       


DLLDEF=     ..\snapin.def

!IF "$(DBX)" == "yes"
C_DEFINES=  $(C_DEFINES) -DDBX
!endif

!IF defined(DBG)
C_DEFINES = $(C_DEFINES) -D_DEBUG
!ENDIF

INCLUDES=   ..\; \
            ..\..\..\..\inc;

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp

SOURCES=    \
            ..\about.cpp \
            ..\CSnapin.cpp \
            ..\Dataobj.cpp \
            ..\events.cpp \
            ..\genpage.cpp \
            ..\service.cpp \
            ..\snapin.cpp \
            ..\snapin.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"

const CLSID CLSID_Snapin =    {0x18731372,0x1D79,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const CLSID CLSID_Extension = {0x27E5EC4E,0x9F2D,0x11D0,{0xA7,0xD6,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const CLSID CLSID_About =     {0xF0A1B9BE,0xA172,0x11D0,{0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
const GUID cNodeTypeStatic = {0x44092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const wchar_t*  cszNodeTypeStatic = L"{44092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Company Data NodeType GUID in numeric & string formats.
const GUID cNodeTypeCompany = {0x55092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const wchar_t*  cszNodeTypeCompany = L"{55092d22-1d7e-11d0-a29b-00c04fd909dd}";

// User Data NodeType GUID in numeric & string formats.
const GUID cNodeTypeUser = {0x66092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
const wchar_t*  cszNodeTypeUser = L"{66092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Extension Company Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeExtCompany = {0xe5092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
extern const wchar_t*  cszNodeTypeExtCompany = L"{e5092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Extension User Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeExtUser = {0xe6092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};
extern const wchar_t*  cszNodeTypeExtUser = L"{e6092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Virtual Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeVirtual = {0xad003e5a,0x483,0x11d1,{0xae,0xf7,0x0,0xc0,0x4f,0xb6,0xdd,0x2c}};
extern const wchar_t*  cszNodeTypeVirtual = L"{AD003E5A-0483-11d1-AEF7-00C04FB6DD2C}";

// Dynamicaly created objects.
extern const GUID cNodeTypeDynamic = {0x0ac69b7a,0xafce,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
extern const wchar_t*  cszNodeTypeDynamic = L"{0ac69b7a-afce-11d0-a79b-00c04fd8d565}";


//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem = {0x00c86e52,0xaf90,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
extern const wchar_t*  cszObjectTypeResultItem = L"{00c86e52-af90-11d0-a79b-00c04fd8d565}";




//
//
//////////////////////////////////////////////////////////////////////////////




// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"SNAPIN_INTERNAL"; // Step 3

// Published formats
const wchar_t* SNAPIN_WORKSTATION = L"SNAPIN_WORKSTATION"; // Extension
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright 1995 - 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

// define this symbol to insert another level of User,Company,Virtual
// nodes whenever one of the nodes is expanded
// #define RECURSIVE_NODE_EXPANSION


#include <afxwin.h>
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include "afxtempl.h"

//#include <shellapi.h>

#include <atlbase.h>
using namespace ATL;

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


//#include "afxtempl.h"   


#pragma comment(lib, "mmc")
#include <mmc.h>




const long UNINITIALIZED = -1;

// Constants used in samples
const int NUM_FOLDERS = 4;
const int NUM_NAMES = 4;
const int NUM_COMPANY = 6;
const int NUM_VIRTUAL_ITEMS = 100000;
const int MAX_ITEM_NAME = 64;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
    COMPANY = 0x8001,
    USER = 0x8002,
    VIRTUAL = 0x8003,
    EXT_COMPANY = 0x8004,
    EXT_USER = 0x8005,
    EXT_VIRTUAL = 0x8006,
    NONE = 0xFFFF
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
        TRACE(_T("Release called on NULL interface ptr\n")); 
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const CLSID CLSID_Extension; // In-Proc server GUID
extern const CLSID CLSID_About; 

///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeStatic;
extern const wchar_t*  cszNodeTypeStatic;

// Company Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeCompany;
extern const wchar_t*  cszNodeTypeCompany;

// User Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeUser;
extern const wchar_t*  cszNodeTypeUser;

// Extension Company Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeExtCompany;
extern const wchar_t*  cszNodeTypeExtCompany;

// Extension User Data NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeExtUser;
extern const wchar_t*  cszNodeTypeExtUser;

// Extension Virtual NodeType GUID in numeric & string formats.
extern const GUID cNodeTypeVirtual;
extern const wchar_t*  cszNodeTypeVirtual;

// Dynamicaly created objects.
extern const GUID cNodeTypeDynamic;
extern const wchar_t*  cszNodeTypeDynamic;


//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem;
extern const wchar_t*  cszObjectTypeResultItem;

//
//
//////////////////////////////////////////////////////////////////////////////



// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

// Published context information for extensions to extend
extern const wchar_t* SNAPIN_WORKSTATION;

struct INTERNAL 
{
    INTERNAL() 
    {
        m_type = CCT_UNINITIALIZED; 
        m_cookie = -1;
        ZeroMemory(&m_clsid, sizeof(CLSID));
    };

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;         // What context is the data object.
    MMC_COOKIE              m_cookie;       // What object the cookie represents
    CString             m_string;       // 
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs) 
    { 
        if (&rhs == this)
            return *this;

        // Deep copy the information
        m_type = rhs.m_type; 
        m_cookie = rhs.m_cookie; 
        m_string = rhs.m_string;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    } 

    BOOL operator==(const INTERNAL& rhs) 
    {
        return rhs.m_string == m_string;
    }
};

// Debug instance counter
#ifdef _DEBUG
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "SAMPLE: Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize( 
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;
    
    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.
    
    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();
    
    return hr;
}

STDMETHODIMP CComponent::Notify( 
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
	MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    return S_FALSE;
}

STDMETHODIMP CComponent::Destroy( 
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }
    
    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject( 
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType( 
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;
    
    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( 
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects( 
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    // Get pointer to name space interface
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    // Get pointer to console interface
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
        MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    return S_FALSE;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
            LPCTSTR pszT = base->GetDisplayName();
            MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
    
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
{ 
    
}

CDelegationBase::~CDelegationBase() 
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {22612902-79B5-11d2-9508-00C04FB92EC2}
DEFINE_GUID(CLSID_CComponentData, 
            0x22612902, 0x79b5, 0x11d2, 0x95, 0x8, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2);

// {22612904-79B5-11d2-9508-00C04FB92EC2}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x22612904, 0x79b5, 0x11d2, 0x95, 0x8, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_LGBMP                       112
#define IDB_SMBMP                       113
#define IDB_SMOPEN                      114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        115
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
}

CStaticNode::~CStaticNode()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\about\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    IControlbar*    m_ipControlBar;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_ipDisplayHelp = NULL;
    m_ipControlBar  = NULL;
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->AddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->Select(m_ipConsole, (BOOL) LOWORD(arg), (BOOL) HIWORD(arg));
        break;

    case MMCN_SHOW:
        hr = base->Show(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_INITOCX:
        hr = base->InitOCX(reinterpret_cast<IUnknown *>(param));
        break;

    case MMCN_CONTEXTHELP:
        hr = base->ShowContextHelp(m_ipConsole, m_ipDisplayHelp, m_pComponentData->m_HelpFile);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, ISnapinHelp
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;

    WCHAR            m_HelpFile[MAX_PATH];
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        ///////////////////////////////
        // Interface ISnapinHelp
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;

    TCHAR tmpHelpFile[MAX_PATH];

    GetWindowsDirectory(tmpHelpFile, sizeof(tmpHelpFile));
    _tcscat(tmpHelpFile, _T("\\HELP\\"));
    LoadString(g_hinst, IDS_HELPFILE, &tmpHelpFile[_tcslen(tmpHelpFile)], MAX_PATH - _tcslen(tmpHelpFile));

	MAKE_WIDEPTR_FROMTSTR(wszHelpFile, tmpHelpFile);
	wcscpy(m_HelpFile, wszHelpFile);
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_ISnapinHelp))
        *ppv = static_cast<ISnapinHelp*>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
	MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->Expand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;

    case MMCN_INITOCX:
        hr = base->InitOCX(reinterpret_cast<IUnknown *>(param));
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic(
                                     /* [out] */ LPOLESTR *lpCompiledHelpFile)
{
    *lpCompiledHelpFile = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(m_HelpFile) + 1) * sizeof(WCHAR)));
    
    wcscpy(*lpCompiledHelpFile, m_HelpFile);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"
#include "Comp.h"
#include "CompData.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: m_pComponentData(NULL), bExpanded(FALSE) 
{ 
    m_pBMapSm = NULL;
    m_pBMapLg = NULL;
    
    LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::AddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponent;
class CComponentData;

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    virtual HRESULT AddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT Expand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT Select(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT Show(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT ShowContextHelp(IConsole *pConsole, IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile) { return S_FALSE; }
    
    virtual HRESULT InitOCX(IUnknown *pUnknown) { return S_FALSE; }
    
public:
    void SetComponentData(CComponentData *pComponentData) { m_pComponentData = pComponentData; }
    
    HBITMAP m_pBMapSm;
    HBITMAP m_pBMapLg;
    
protected:
    void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
public:
    CComponentData *m_pComponentData;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include <mmc.h>
#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle(CComponentData *pComponentData = NULL)
    { m_pComponentData = pComponentData; }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {FA7306A6-8B0D-11d2-8A0B-000021473128}
DEFINE_GUID(CLSID_CComponentData, 
            0xfa7306a6, 0x8b0d, 0x11d2, 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);

// {FA7306A8-8B0D-11d2-8A0B-000021473128}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xfa7306a8, 0x8b0d, 0x11d2, 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include <mmc.h>
#include "DeleBase.h"

class CPerson : public CDelegationBase {
public:
    CPerson(int id, CComponentData *pComponentData = NULL);
    
    virtual ~CPerson();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
    virtual HRESULT ShowContextHelp(IConsole *pConsole, IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile);
    
    void Initialize(_TCHAR *szName, LONG lSpeed, LONG lHeight, LONG lWeight, BOOL fAnimating);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    IUnknown *m_pUnknown;
    _TCHAR *szName; 
    LONG lSpeed; 
    LONG lHeight; 
    LONG lWeight;
    BOOL fAnimating;
    
    int m_id;
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle(CComponentData *pComponentData = NULL);
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT Expand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
   
    enum { NUMBER_OF_CHILDREN = 4 };
    CPerson *children[NUMBER_OF_CHILDREN];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

#include <initguid.h>
// for vb component
//#include "vb\mmcsample.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CPerson::thisGuid = { 0xd41ef043, 0x8bc5, 0x11d2, { 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;

    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CPerson(n, pComponentData);
        children[n]->Initialize(_T("Fred"), 6, 2, 115, n % 2 == 0 ? TRUE : FALSE);
    }
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CPeoplePoweredVehicle::Expand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = children[n]->GetBitmapIndex();
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

//==============================================================
//
// CPeopleVehicle::CPerson implementation
//
//
CPerson::CPerson(int id, CComponentData *pComponentData)
: m_id(id)
{
    m_pComponentData = pComponentData;

    m_pUnknown = NULL;
    szName     = NULL;
    lSpeed     = 0;
    lHeight    = 0;
    lWeight    = 0;
    fAnimating = FALSE;
}

CPerson::~CPerson()
{
    if (szName)
        delete [] szName;

    if (m_pUnknown)
        m_pUnknown->Release();
}

void CPerson::Initialize(_TCHAR *szName, LONG lSpeed, LONG lHeight, LONG lWeight, BOOL fAnimating)
{
    if (szName) {
        this->szName = new _TCHAR[_tcslen(szName) + 20];
        _tcscpy(this->szName, szName);
        _tcscat(this->szName, _T(" "));

        if (m_id % 2)
            _tcscat(this->szName, _T("(new control)"));
        else
            _tcscat(this->szName, _T("(share control)"));
    }

    this->lSpeed = lSpeed;
    this->lHeight = lHeight;
    this->lWeight = lWeight;
    this->fAnimating = fAnimating;

    return;
}

const _TCHAR *CPerson::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _tcscpy(buf, szName ? szName : _T(""));
        break;

    case 1:
        _stprintf(buf, _T("%ld m/s"), lSpeed);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lWeight);
        break;
    }
    return buf;
}

HRESULT CPerson::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    // for vb component
    // LPOLESTR lpOleStr;
    // HRESULT hr = StringFromCLSID(CLSID_VBComponent, &lpOleStr);
    // *ppViewType = lpOleStr;

    // for atl component
    LPOLESTR lpOleStr = L"{9A12FB62-C754-11D2-952C-00C04FB92EC2}";
    *ppViewType = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(lpOleStr) + 1) * sizeof(WCHAR)));
    wcscpy(*ppViewType, lpOleStr);

    if (m_id % 2) {
        // create new control
        *pViewOptions = MMC_VIEW_OPTIONS_CREATENEW;
    } else {
        // share control
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    }

    return S_OK;
}

HRESULT CPerson::ShowContextHelp(IConsole *pConsole, IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile)
{
    HRESULT hr = S_OK;

    IUnknown *pUnk = NULL;
    if (SUCCEEDED(hr = pConsole->QueryResultView(&pUnk))) {
        IDispatch *pDispatch = NULL;

        if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IDispatch, (void **)&pDispatch))) {
            DISPID dispID;
            DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
            EXCEPINFO exInfo;
            OLECHAR *pszName = L"DoHelp";
            UINT uErr;

            hr = pDispatch->GetIDsOfNames(IID_NULL, &pszName, 1, LOCALE_SYSTEM_DEFAULT, &dispID);

            if (SUCCEEDED(hr)) {
                hr = pDispatch->Invoke(
                    dispID,
                    IID_NULL,
                    LOCALE_USER_DEFAULT,
                    DISPATCH_METHOD,
                    &dispparamsNoArgs, NULL, &exInfo, &uErr);
            }

            pDispatch->Release();
        }

        pUnk->Release();
    }

    _ASSERT(SUCCEEDED(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      116
#define IDB_SMBMP                       117
#define IDB_LGBMP                       118
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_COMMAND_COMMAND1             40016
#define ID_COMMAND_COMMAND2             40017
#define ID_COMMAND_COMMAND3             40018
#define ID_COMMAND_COMMAND4             40020
#define ID_BUTTONSTART                  40021
#define ID_BUTTONPAUSE                  40022
#define ID_BUTTONSTOP                   40023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        119
#define _APS_NEXT_COMMAND_VALUE         40024
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include <mmc.h>
#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle(CComponentData *pComponentData = NULL)
    { m_pComponentData = pComponentData;  }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Space.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;

    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(pComponentData);
        children[n]->Initialize(_T("Vehicle"), 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::Show(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CSpaceVehicle::CRocket implementation
//
//
CRocket::CRocket(CComponentData *pComponentData)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    m_pComponentData = pComponentData;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

void CRocket::Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload)
{
    if (szName) {
        this->szName = new _TCHAR[_tcslen(szName) + 1];
        _tcscpy(this->szName, szName);
    }

    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _tcscpy(buf, szName ? szName : _T(""));
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include <mmc.h>
#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(CComponentData *pComponentData = NULL);
    
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
    void Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle(CComponentData *pComponentData = NULL);
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
    virtual HRESULT Show(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
   
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _STATICNODE_H
#define _STATICNODE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode(CComponentData *pComponentData = NULL);
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
    virtual HRESULT Expand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _STATICNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;
    
    children[0] = new CPeoplePoweredVehicle(pComponentData);
    children[1] = new CLandBasedVehicle(pComponentData);
    children[2] = new CSkyBasedVehicle(pComponentData);
    children[3] = new CSpaceVehicle(pComponentData);
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::Expand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\atlcontrol.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Nov 19 19:31:26 1999
 */
/* Compiler settings for D:\nt\private\admin\bosrc\sources\activex\atl\ATLControl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ATLControl_h__
#define __ATLControl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMMCControl_FWD_DEFINED__
#define __IMMCControl_FWD_DEFINED__
typedef interface IMMCControl IMMCControl;
#endif 	/* __IMMCControl_FWD_DEFINED__ */


#ifndef __MMCControl_FWD_DEFINED__
#define __MMCControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class MMCControl MMCControl;
#else
typedef struct MMCControl MMCControl;
#endif /* __cplusplus */

#endif 	/* __MMCControl_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMMCControl_INTERFACE_DEFINED__
#define __IMMCControl_INTERFACE_DEFINED__

/* interface IMMCControl */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMMCControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("831DF6C8-C754-11D2-952C-00C04FB92EC2")
    IMMCControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartAnimation( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopAnimation( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoHelp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMMCControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMMCControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMMCControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMMCControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMMCControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMMCControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMMCControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMMCControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAnimation )( 
            IMMCControl __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopAnimation )( 
            IMMCControl __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoHelp )( 
            IMMCControl __RPC_FAR * This);
        
        END_INTERFACE
    } IMMCControlVtbl;

    interface IMMCControl
    {
        CONST_VTBL struct IMMCControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMCControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMMCControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMMCControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMMCControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMMCControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMMCControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMMCControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMMCControl_StartAnimation(This)	\
    (This)->lpVtbl -> StartAnimation(This)

#define IMMCControl_StopAnimation(This)	\
    (This)->lpVtbl -> StopAnimation(This)

#define IMMCControl_DoHelp(This)	\
    (This)->lpVtbl -> DoHelp(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMMCControl_StartAnimation_Proxy( 
    IMMCControl __RPC_FAR * This);


void __RPC_STUB IMMCControl_StartAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMMCControl_StopAnimation_Proxy( 
    IMMCControl __RPC_FAR * This);


void __RPC_STUB IMMCControl_StopAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMMCControl_DoHelp_Proxy( 
    IMMCControl __RPC_FAR * This);


void __RPC_STUB IMMCControl_DoHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMMCControl_INTERFACE_DEFINED__ */



#ifndef __ATLCONTROLLib_LIBRARY_DEFINED__
#define __ATLCONTROLLib_LIBRARY_DEFINED__

/* library ATLCONTROLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ATLCONTROLLib;

EXTERN_C const CLSID CLSID_MMCControl;

#ifdef __cplusplus

class DECLSPEC_UUID("9A12FB62-C754-11D2-952C-00C04FB92EC2")
MMCControl;
#endif
#endif /* __ATLCONTROLLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\atlcontrol.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// ATLControl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ATLControlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ATLControl.h"

#include "ATLControl_i.c"
#include "MMCControl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MMCControl, CMMCControl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ATLCONTROLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\mmccontrol.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// MMCControl.cpp : Implementation of CMMCControl

#include "stdafx.h"
#include "ATLControl.h"
#include "MMCControl.h"

/////////////////////////////////////////////////////////////////////////////
// CMMCControl


STDMETHODIMP CMMCControl::StartAnimation()
{
    m_bAnimating = TRUE;
    
    SetDlgItemText(IDC_ANIMATIONSTATE, _TEXT("Animation Running"));
    SetDlgItemText(IDC_ANIMATE, _TEXT("Stop"));

    OutputDebugString(_TEXT("CMMCControl_StartAnimation\n"));

	return S_OK;
}

STDMETHODIMP CMMCControl::StopAnimation()
{
    m_bAnimating = FALSE;
    
    SetDlgItemText(IDC_ANIMATIONSTATE, _TEXT("Animation Stopped"));
    SetDlgItemText(IDC_ANIMATE, _TEXT("Start"));

    OutputDebugString(_TEXT("CMMCControl_StopAnimation\n"));

	return S_OK;
}

STDMETHODIMP CMMCControl::DoHelp()
{
    MessageBox(_TEXT("DoHelp called"), _TEXT("Sample Animation control"), MB_OK);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ATLControl.rc
//
#define IDS_PROJNAME                    100
#define IDB_MMCCONTROL                  101
#define IDR_MMCCONTROL                  102
#define IDD_MMCCONTROL                  103
#define IDC_ANIMATE                     201
#define IDC_ANIMATIONSTATE              202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\mmccontrol.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// MMCControl.h : Declaration of the CMMCControl

#ifndef __MMCCONTROL_H_
#define __MMCCONTROL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


/////////////////////////////////////////////////////////////////////////////
// CMMCControl
class ATL_NO_VTABLE CMMCControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMMCControl, &IID_IMMCControl, &LIBID_ATLCONTROLLib>,
	public CComCompositeControl<CMMCControl>,
	public IPersistStreamInitImpl<CMMCControl>,
	public IOleControlImpl<CMMCControl>,
	public IOleObjectImpl<CMMCControl>,
	public IOleInPlaceActiveObjectImpl<CMMCControl>,
	public IViewObjectExImpl<CMMCControl>,
	public IOleInPlaceObjectWindowlessImpl<CMMCControl>,
	public ISupportErrorInfo,
	public CComCoClass<CMMCControl, &CLSID_MMCControl>
{
public:
	CMMCControl()
	{
        OutputDebugString(_TEXT("CMMCControl constructor\n"));

        m_bWindowOnly = TRUE;
        m_bAnimating = FALSE;
		CalcExtent(m_sizeExtent);
	}

	~CMMCControl()
    {
        OutputDebugString(_TEXT("CMMCControl destructor\n"));
    }

DECLARE_REGISTRY_RESOURCEID(IDR_MMCCONTROL)
DECLARE_NOT_AGGREGATABLE(CMMCControl)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMMCControl)
	COM_INTERFACE_ENTRY(IMMCControl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CMMCControl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CMMCControl)
	CHAIN_MSG_MAP(CComCompositeControl<CMMCControl>)
	COMMAND_HANDLER(IDC_ANIMATE, BN_CLICKED, OnClickedAnimate)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CMMCControl)
	//Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		if (dispid == DISPID_AMBIENT_BACKCOLOR)
		{
			SetBackgroundColorFromAmbient();
			FireViewChange();
		}
		return IOleControlImpl<CMMCControl>::OnAmbientPropertyChange(dispid);
	}



// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_IMMCControl,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
            if (::InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	}

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// IMMCControl
public:
	STDMETHOD(DoHelp)();
	STDMETHOD(StopAnimation)();
	STDMETHOD(StartAnimation)();

	enum { IDD = IDD_MMCCONTROL };
	LRESULT OnClickedAnimate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        m_bAnimating = !m_bAnimating;
    
        if (m_bAnimating)
            StartAnimation();
        else
            StopAnimation();

		return 0;
	}

private:
    BOOL m_bAnimating;
    UINT m_timerId;
};

#endif //__MMCCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\stdafx.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\atl\stdafx.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__758048CD_C754_11D2_952C_00C04FB92EC2__INCLUDED_)
#define AFX_STDAFX_H__758048CD_C754_11D2_952C_00C04FB92EC2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__758048CD_C754_11D2_952C_00C04FB92EC2__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\activex\vb\mmcsample.h ===
interface _VBComponent;

DEFINE_GUID(IID__VBComponent,0xC224F73FL,0x8D72,0x11D2,0x8A,0x0B,0x00,0x00,0x21,0x47,0x31,0x28);
DECLARE_INTERFACE_(_VBComponent, IDispatch)
{
    STDMETHOD(StartAnimation)(THIS) PURE;
    STDMETHOD(StopAnimation)(THIS) PURE;
};

DEFINE_GUID(CLSID_VBComponent,0xCD3A5DAAL,0x8CA5,0x11D2,0x8A,0x0B,0x00,0x00,0x21,0x47,0x31,0x28);
class CWrapVBComponent : public _VBComponent
{
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj){ return m_pInternal->QueryInterface(riid, ppvObj); }
    STDMETHOD_(unsigned long, AddRef)(THIS){ return m_pInternal->AddRef(); }
    STDMETHOD_(unsigned long, Release)(THIS){ return m_pInternal->Release(); }
    STDMETHOD(GetTypeInfoCount)(THIS_ unsigned int FAR* pctinfo){ return m_pInternal->GetTypeInfoCount(pctinfo); }
    STDMETHOD(GetTypeInfo)(THIS_ unsigned int itinfo, unsigned long lcid, ITypeInfo FAR* FAR* pptinfo){ return m_pInternal->GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, unsigned short FAR* FAR* rgszNames, unsigned int cNames, unsigned long lcid, long FAR* rgdispid){ return m_pInternal->GetIDsOfNames(riid, 
        rgszNames, cNames, lcid, rgdispid); }
    STDMETHOD(Invoke)(THIS_ long dispidMember, REFIID riid, unsigned long lcid, unsigned short wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO 
        FAR* pexcepinfo, unsigned int FAR* puArgErr){ return m_pInternal->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }
    STDMETHOD(StartAnimation)(THIS){ return m_pInternal->StartAnimation(); }
    STDMETHOD(StopAnimation)(THIS){ return m_pInternal->StopAnimation(); }
    CWrapVBComponent()
    {
      m_pInternal = NULL;
      IUnknown FAR* pUnk;
      if SUCCEEDED(m_hrLaunch = CoCreateInstance(CLSID_VBComponent, NULL, CLSCTX_SERVER, 
                                               IID_IUnknown, (void FAR* FAR*) &pUnk)) {
        m_hrLaunch = pUnk->QueryInterface(IID__VBComponent, (void FAR* FAR*) &m_pInternal);  
        pUnk->Release();
      }
    }
    CWrapVBComponent(IUnknown *pUnk)
    {
      m_pInternal = NULL;
      m_hrLaunch = pUnk->QueryInterface(IID__VBComponent, (void FAR* FAR*) &m_pInternal);  
    }
    virtual ~CWrapVBComponent(){if (m_pInternal) m_pInternal->Release();}
    HRESULT LaunchError(){return m_hrLaunch;}
private:
    _VBComponent FAR* m_pInternal;
    HRESULT m_hrLaunch;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\compsvrext.cpp ===
// CompSvrExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CompSvrExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "CompSvrExt.h"
EXTERN_C const CLSID CLSID_PropPageExt;

#include "CompSvrExt_i.c"
#include "PropPageExt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PropPageExt, CPropPageExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init( ObjectMap, hInstance );
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\compsvrext.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Feb 17 10:56:23 2000
 */
/* Compiler settings for D:\nt\private\admin\bosrc\sources\atl_samp\comexp\CompSvrExt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __CompSvrExt_h__
#define __CompSvrExt_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPropPageExt_FWD_DEFINED__
#define __IPropPageExt_FWD_DEFINED__
typedef interface IPropPageExt IPropPageExt;
#endif 	/* __IPropPageExt_FWD_DEFINED__ */


#ifndef __PropPageExt_FWD_DEFINED__
#define __PropPageExt_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropPageExt PropPageExt;
#else
typedef struct PropPageExt PropPageExt;
#endif /* __cplusplus */

#endif 	/* __PropPageExt_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IPropPageExt_INTERFACE_DEFINED__
#define __IPropPageExt_INTERFACE_DEFINED__

/* interface IPropPageExt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropPageExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83E05E3D-CF47-4146-BE16-5E876584119D")
    IPropPageExt : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPropPageExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropPageExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropPageExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropPageExt __RPC_FAR * This);
        
        END_INTERFACE
    } IPropPageExtVtbl;

    interface IPropPageExt
    {
        CONST_VTBL struct IPropPageExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropPageExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropPageExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropPageExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropPageExt_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\globals.cpp ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#include "stdafx.h"
#include "globals.h"

//
// Global functions for extracting information from a primary's  data object
//

HRESULT ExtractData( 
                                       IDataObject* piDataObject,
                                      CLIPFORMAT   cfClipFormat,
                                      BYTE*        pbData,
                                      DWORD        cbData 
                                     )
{
    if ( piDataObject == NULL )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    
    FORMATETC formatetc =
    {
        cfClipFormat, 
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    STGMEDIUM stgmedium = 
    {
        TYMED_HGLOBAL,
        NULL
    };
    

    do // false loop
    {
        stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
        if ( NULL == stgmedium.hGlobal )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = (BYTE*)::GlobalLock(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }

        ::memcpy( pbData, pbNewData, cbData );
		::GlobalUnlock( stgmedium.hGlobal);

    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree( stgmedium.hGlobal );
    }

    return hr;
} // ExtractData()


HRESULT ExtractString(
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    WCHAR*       pstr,
    DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, 
                        (PBYTE)pstr, cchMaxLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\proppageext.cpp ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#include "stdafx.h"

#include "CompSvrExt.h"
EXTERN_C const CLSID CLSID_PropPageExt;

#include "PropPageExt.h"
#include "globals.h"
#include "resource.h"


//
// Interface IExtendPropertySheet
//

HRESULT CPropPageExt::CreatePropertyPages( 
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject
    )
{
	HRESULT hr = S_FALSE;

    //
	// Extract data from the data object passed to us from the currently
    // selected item in the Component Services snap-in
    //

	// Component Services snap-in clip format

	CLIPFORMAT cfComponentCLSID = (CLIPFORMAT)RegisterClipboardFormat(
        L"CCF_COM_OBJECTKEY" );

    if ( cfComponentCLSID == 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

	CLIPFORMAT cfWorkstation = (CLIPFORMAT)RegisterClipboardFormat(
        L"CCF_COM_WORKSTATION");

    if ( cfWorkstation == 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
	
    //
	// Retrieve current computer name
    //

	hr = ExtractString( lpIDataObject,
                        cfWorkstation,
                        m_szWorkstation, 
                        (MAX_COMPUTERNAME_LENGTH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }
	
	if ( *m_szWorkstation == L'\0' )
    {
        WCHAR pszMyComputer[ 128 ];

        if ( LoadString( _Module.GetModuleInstance(),
                         IDS_MYCOMPUTER,
                         pszMyComputer, 127 ) == 0 )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

		wcscpy( m_szWorkstation, pszMyComputer );
    }

    //
	// Retrieve current object key
	// For node types in which an object key is not appropriate, the
    // GetDataHere() method from the data object will return L""
    //

	WCHAR pszGuid[ COMNS_MAX_GUID ];

    hr = ExtractString( lpIDataObject,
                        cfComponentCLSID,
                        pszGuid,
                        COMNS_MAX_GUID * sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = CLSIDFromString( pszGuid, &m_clsidNodeType );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Create a property sheet page object from a dialog box.
    //
    // We store a pointer to our class in the psp.lParam, so we
    // can access our class members from within the dialog procedure.

 	PROPSHEETPAGE psp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = _Module.GetModuleInstance();
    psp.pszTemplate = MAKEINTRESOURCE( IDD_EXTENSIONPAGEGEN );
    psp.pfnDlgProc  = ExtensionPageDlgProc;
    psp.lParam = reinterpret_cast<LPARAM>( this );
    psp.pszTitle = MAKEINTRESOURCE(IDS_PROPPAGE_TITLE);
    
    HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&psp);
    if ( hPage == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = lpProvider->AddPage(hPage);
    if ( FAILED(hr) )
    {
        return hr;
    }

    return hr;
}

HRESULT CPropPageExt::QueryPagesFor( 
    /* [in] */ LPDATAOBJECT lpDataObject
    )
{
    return S_OK;
}

BOOL CALLBACK CPropPageExt::ExtensionPageDlgProc(
    HWND hDlg, 
    UINT uMessage, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    static CPropPageExt *pThis = NULL;
    LPOLESTR pszCLSID = NULL;
    
    switch (uMessage)
    {     		
    case WM_INITDIALOG:
        pThis = reinterpret_cast<CPropPageExt *>(
            reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam );

        //
        // Display the computer name
        //

        SetWindowText( GetDlgItem( hDlg, IDC_EDITMACHINENAME),
                       pThis->m_szWorkstation );

        //
        // Display the component CLSID
        //

        if ( ::StringFromCLSID( pThis->m_clsidNodeType, &pszCLSID) == S_OK )
        {
            SetWindowText( GetDlgItem( hDlg,IDC_EDITCOMPCLSID ), pszCLSID );

            CoTaskMemFree( pszCLSID );
        }

        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return TRUE;
            
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
		break;
    } 
 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CompSvrExt.rc
//
#define IDS_PROJNAME                    100
#define IDR_PROPPAGEEXT                 101
#define IDS_PROPPAGE_TITLE              101
#define IDS_MYCOMPUTER                  102
#define IDD_EXTENSIONPAGEGEN            107
#define IDC_MACHINENAME                 201
#define IDC_EDITMACHINENAME             202
#define IDC_COMPCLSID                   205
#define IDC_EDITCOMPCLSID               206

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\proppageext.h ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#ifndef PROPPAGEEXT_H
#define PROPPAGEEXT_H

#include "PropPageExt.h"
#include "resource.h"

class ATL_NO_VTABLE CPropPageExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropPageExt, &CLSID_PropPageExt>,
	public IPropPageExt,
	public IExtendPropertySheet
{
    BEGIN_COM_MAP(CPropPageExt)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
    END_COM_MAP()

public:

	CPropPageExt()
	{
	}

	DECLARE_REGISTRY_RESOURCEID(IDR_PROPPAGEEXT)

	DECLARE_NOT_AGGREGATABLE(CPropPageExt)

	DECLARE_PROTECT_FINAL_CONSTRUCT()


    //
    // Interface IExtendPropertySheet
    //

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);

private:

	static BOOL CALLBACK ExtensionPageDlgProc( HWND hDlg, 
                                               UINT uMessage, 
                                               WPARAM wParam, 
                                               LPARAM lParam);

	CLSID m_clsidNodeType; // CLSID of currently selected node 
	WCHAR m_szWorkstation[MAX_COMPUTERNAME_LENGTH+1];	//Current computer name

};

#endif //PROPPAGEEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\globals.h ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#ifndef MMC_GLOBALS_H
#define MMC_GLOBALS_H

#define COMNS_MAX_GUID 40
#define COMNS_MAX_OBJECTLEN 1024

//Helper functions for extracting data from data objects 

HRESULT ExtractString( IDataObject *piDataObject, 
                       CLIPFORMAT cfClipFormat, 
                       WCHAR *pstr,
                       DWORD cchMaxLength );

HRESULT ExtractData( IDataObject* piDataObject,
                     CLIPFORMAT cfClipFormat, 
                     BYTE* pbData,
                     DWORD cbData );

#endif // MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\compsvrext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0E3EB299_8611_4DFE_AA8C_73508EC72654__INCLUDED_)
#define AFX_STDAFX_H__0E3EB299_8611_4DFE_AA8C_73508EC72654__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <tchar.h>
#include <mmc.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0E3EB299_8611_4DFE_AA8C_73508EC72654__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\cmenuext.cpp ===
// CMenuExt.cpp : Implementation of CCMenuExt
#include "stdafx.h"
#include "DSAdminExt.h"
#include "CMenuExt.h"

/////////////////////////////////////////////////////////////////////////////
// CCMenuExt

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CCMenuExt::AddMenuItems( 
                                            /* [in] */ LPDATAOBJECT piDataObject,
                                            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                            /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
	HRESULT hr = S_FALSE;
    
	if (NULL == piDataObject)
        return hr;

    CONTEXTMENUITEM menuItemsTask[] =
    {
        {
            L"DSAdmin Extension Sample Menu Item", L"Inserted by DSAdminExt.dll sample snap-in",
                1, CCM_INSERTIONPOINTID_3RDPARTY_TASK  , 0, 0
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        for (CONTEXTMENUITEM *m = menuItemsTask; m->strName; m++)
        {
            hr = piCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
 
    return hr;
    
}

HRESULT CCMenuExt::Command( 
                                       /* [in] */ long lCommandID,
                                       /* [in] */ LPDATAOBJECT piDataObject)
{
    _TCHAR pszName[255];
    HRESULT hr = ExtractString(piDataObject, s_cfDisplayName, pszName, sizeof(pszName));
	LPOLESTR lpDest = NULL;

	AllocOleStr(&lpDest, pszName);
    
    if (SUCCEEDED(hr)) {
        switch (lCommandID)
        {
        case 1:
            ::MessageBox(NULL, lpDest, _T("Message from DSAdminExt.dll"), MB_OK|MB_ICONEXCLAMATION);
            break;
        }
    }
    else
		::MessageBox(NULL, _T("Multiple objects selected"), _T("DSAdminExt.dll Sample"), MB_OK|MB_ICONEXCLAMATION);

	// Free memory.
	CoTaskMemFree(lpDest) ;
 
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\cmenuext.h ===
// CMenuExt.h : Declaration of the CCMenuExt

#ifndef __CMENUEXT_H_
#define __CMENUEXT_H_

#include <mmc.h>
#include "DSAdminExt.h"
#include "DeleBase.h"
#include <tchar.h>
#include <crtdbg.h>
//#include "globals.h"		// main symbols
#include "resource.h"
//#include "LocalRes.h"

/////////////////////////////////////////////////////////////////////////////
// CCMenuExt
class ATL_NO_VTABLE CCMenuExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCMenuExt, &CLSID_CMenuExt>,
	public ICMenuExt,
	public IExtendContextMenu
{

BEGIN_COM_MAP(CCMenuExt)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()

public:
	CCMenuExt()
	{
	}
	DECLARE_REGISTRY_RESOURCEID(IDR_CMENUEXT)
	DECLARE_NOT_AGGREGATABLE(CCMenuExt)
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	///////////////////////////////
	// Interface IExtendContextMenu
	///////////////////////////////
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);
};

#endif //__CMENUEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\delebase.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#include "stdafx.h"

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x66f340f8, 0x3733, 0x49b4, {0x8e, 0x48, 0x10, 0x20, 0xe4, 0xdd, 0x86, 0x60} };
/*
HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;
*/
//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{
/*	if (NULL == m_pBMapSm || NULL == m_pBMapLg)
		LoadBitmaps(); */
}

CDelegationBase::~CDelegationBase() 
{
}
/*
// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
/*    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
*/
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\dsadminext.cpp ===
// DSAdminExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DSAdminExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "globals.h"
#include <initguid.h>
#include "DSAdminExt.h"

#include "DSAdminExt_i.c"
#include "CMenuExt.h"
#include "PropPageExt.h"

CComModule _Module;

// our globals
HINSTANCE g_hinst;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CMenuExt, CCMenuExt)
OBJECT_ENTRY(CLSID_PropPageExt, CPropPageExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		g_hinst = hInstance;

        _Module.Init(ObjectMap, hInstance, &LIBID_DSADMINEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
// This sample modifies the ATL object wizard generated code to include
// the registration of the snap-in as a context menu extension


STDAPI DllRegisterServer(void)
{
	HRESULT hr;

    _TCHAR szSnapInName[256];
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName)/sizeof(szSnapInName[0]));

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);

    // place the registry information for the context menu extension
    if SUCCEEDED(hr)
        hr = RegisterSnapinAsExtension(szSnapInName);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;
#include "stdafx.h"
#include "DataObj.h"
#include "DeleBase.h"
#include "CMenuExt.h"
#include "globals.h"
//#include "DSAdminExt.h"
#include <stdio.h>
/*
//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

//Our snap-in's CLSID
#define _T_CCF_INTERNAL_SNAPIN _T("{6707A300-264F-4BA3-9537-70E304EED9BA}")


// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);

// Custom clipboard format only used within the snap-in
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);

*/
CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
	USES_CONVERSION;
    
	const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
		LPOLESTR wszName = NULL;

		const _TCHAR *pszName = base->GetDisplayName();
		wszName = (LPOLESTR)T2COLE(pszName);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
 
      // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlenW(szGuid);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, ulSizeofName, NULL);
            CoTaskMemFree(szGuid);
		}
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CMenuExt;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\delebase.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
//#include "resource.h"
//#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;

    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }

public:
    // virtual functions go here (for MMCN_*)
//    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
//    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
//    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID) { return S_FALSE; }
    
public:
/*    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

	_TCHAR m_szMachineName[255]; //Current machine name. CClassExtSnap also caches this value.

	_TCHAR* GetMachineName() { return m_szMachineName; }
*/    
protected:

    BOOL bExpanded;
/*	
	static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS)); }  
*/
private:
    // {66F340F8-3733-49b4-8E48-1020E4DD8660}
    static const GUID thisGuid;

};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\dsadminext.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Feb 09 15:33:22 2000
 */
/* Compiler settings for D:\nt\private\admin\bosrc\sources\atl_samp\DSAdminExt\DSAdminExt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __DSAdminExt_h__
#define __DSAdminExt_h__

/* Forward Declarations */ 

#ifndef __ICMenuExt_FWD_DEFINED__
#define __ICMenuExt_FWD_DEFINED__
typedef interface ICMenuExt ICMenuExt;
#endif 	/* __ICMenuExt_FWD_DEFINED__ */


#ifndef __IPropPageExt_FWD_DEFINED__
#define __IPropPageExt_FWD_DEFINED__
typedef interface IPropPageExt IPropPageExt;
#endif 	/* __IPropPageExt_FWD_DEFINED__ */


#ifndef __CMenuExt_FWD_DEFINED__
#define __CMenuExt_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMenuExt CMenuExt;
#else
typedef struct CMenuExt CMenuExt;
#endif /* __cplusplus */

#endif 	/* __CMenuExt_FWD_DEFINED__ */


#ifndef __PropPageExt_FWD_DEFINED__
#define __PropPageExt_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropPageExt PropPageExt;
#else
typedef struct PropPageExt PropPageExt;
#endif /* __cplusplus */

#endif 	/* __PropPageExt_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICMenuExt_INTERFACE_DEFINED__
#define __ICMenuExt_INTERFACE_DEFINED__

/* interface ICMenuExt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICMenuExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52ADFAA1-B9EE-40D4-9185-0C97A999854B")
    ICMenuExt : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICMenuExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICMenuExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICMenuExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICMenuExt __RPC_FAR * This);
        
        END_INTERFACE
    } ICMenuExtVtbl;

    interface ICMenuExt
    {
        CONST_VTBL struct ICMenuExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICMenuExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICMenuExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICMenuExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICMenuExt_INTERFACE_DEFINED__ */


#ifndef __IPropPageExt_INTERFACE_DEFINED__
#define __IPropPageExt_INTERFACE_DEFINED__

/* interface IPropPageExt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropPageExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61955412-FE5C-4334-8E92-4E462AB21BB8")
    IPropPageExt : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPropPageExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropPageExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropPageExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropPageExt __RPC_FAR * This);
        
        END_INTERFACE
    } IPropPageExtVtbl;

    interface IPropPageExt
    {
        CONST_VTBL struct IPropPageExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropPageExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropPageExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropPageExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropPageExt_INTERFACE_DEFINED__ */



#ifndef __DSADMINEXTLib_LIBRARY_DEFINED__
#define __DSADMINEXTLib_LIBRARY_DEFINED__

/* library DSADMINEXTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DSADMINEXTLib;

EXTERN_C const CLSID CLSID_CMenuExt;

#ifdef __cplusplus

class DECLSPEC_UUID("6707A300-264F-4BA3-9537-70E304EED9BA")
CMenuExt;
#endif

EXTERN_C const CLSID CLSID_PropPageExt;

#ifdef __cplusplus

class DECLSPEC_UUID("5D883BEE-BA12-4F61-811D-6337982E131D")
PropPageExt;
#endif
#endif /* __DSADMINEXTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

extern HINSTANCE g_hinst;

HRESULT	AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer);
HRESULT RegisterSnapinAsExtension(_TCHAR* szNameString);


//Clipboard formats
extern UINT s_cfSZNodeType;
extern UINT s_cfDisplayName;
extern UINT s_cfNodeType;
extern UINT s_cfSnapinClsid;
extern UINT s_cfInternal;

//Required for extracting data from DSAdmin snap-in's data object
extern UINT cfDsObjectNames;


//Helper functions for extracting data from data objects 
HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
HRESULT ExtractString( IDataObject *piDataObject, CLIPFORMAT cfClipFormat, _TCHAR *pstr, DWORD cchMaxLength);
HRESULT ExtractData( IDataObject* piDataObject, CLIPFORMAT cfClipFormat, BYTE* pbData, DWORD cbData );


// uncomment the following #define to enable message cracking
//#define MMC_CRACK_MESSAGES
/*
void MMCN_Crack(BOOL bComponentData, 
				IDataObject *pDataObject, 
				IComponentData *pCompData,
				IComponent *pComp,
				MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param);
*/



#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\globals.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.

//==============================================================;

#include "stdafx.h"
#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//
// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

//Our snap-in's CLSID
#define _T_CCF_INTERNAL_SNAPIN _T("{6707A300-264F-4BA3-9537-70E304EED9BA}")

//Needed for extended Active Directory Users and Computers snap-in
#define CFSTR_DSOBJECTNAMES TEXT("DsObjectNames")

// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons.
extern UINT s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
extern UINT s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
extern UINT s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
extern UINT s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);

// Custom clipboard format only used within the snap-in
UINT s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);

//AD Users and Computers snap-in clip format
extern UINT cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);



// this uses the ATL String Conversion Macros 
// for handling any necessary string conversion. Note that
// the snap-in (callee) allocates the necessary memory,
// and MMC (the caller) does the cleanup, as required by COM.
HRESULT AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	USES_CONVERSION;
 
	*lpDest = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(szBuffer) + 1) * 
									sizeof(WCHAR)));
	if (*lpDest == 0)
		return E_OUTOFMEMORY;
    
	LPOLESTR ptemp = T2OLE(szBuffer);
	
	wcscpy(*lpDest, ptemp);

    return S_OK;
}

///////////////////////////////
// Global functions for extracting
// information from a primary's 
// data object
///////////////////////////////

HRESULT ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             _TCHAR       *pstr,
                                             DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    return ExtractData( piDataObject, s_cfSnapinClsid, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\proppageext.h ===
// PropPageExt.h : Declaration of the CPropPageExt

#ifndef __PROPPAGEEXT_H_
#define __PROPPAGEEXT_H_

#include <mmc.h>
#include "DSAdminExt.h"
#include "DeleBase.h"
#include <tchar.h>
#include <crtdbg.h>
#include "resource.h"

class ATL_NO_VTABLE CPropPageExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropPageExt, &CLSID_PropPageExt>,
	public IPropPageExt,
	public IExtendPropertySheet
{
BEGIN_COM_MAP(CPropPageExt)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

public:
	CPropPageExt() : m_ppHandle(NULL), m_ObjPath(NULL), m_hPropPageWnd(NULL), 
					 m_hDlgModeless(NULL)
	{
	}

	DECLARE_REGISTRY_RESOURCEID(IDR_PROPPAGEEXT)
	DECLARE_NOT_AGGREGATABLE(CPropPageExt)
	DECLARE_PROTECT_FINAL_CONSTRUCT()


    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
    /* [in] */ LPDATAOBJECT lpDataObject);

private:
    LONG_PTR m_ppHandle;
    PWSTR m_ObjPath;
	HWND m_hPropPageWnd;
	HWND m_hDlgModeless;

	static BOOL CALLBACK DSExtensionPageDlgProc(HWND hDlg, 
                             UINT uMessage, 
                             WPARAM wParam, 
                             LPARAM lParam);
    
	static BOOL CALLBACK AdvDialogProc(HWND hDlg, 
                             UINT uMessage, 
                             WPARAM wParam, 
                             LPARAM lParam);
};

#endif //__PROPPAGEEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DSAdminExt.rc
//
#define IDS_PROJNAME                    100
#define IDR_CMENUEXT                    101
#define IDS_SNAPINNAME                  101
#define IDS_PROPPAGE_TITLE              102
#define IDR_PROPPAGEEXT                 103
#define IDD_USER_PAGE_EXT               107
#define IDD_DSExtensionPage             108
#define IDD_DSExtensionPageGen          109
#define IDI_PSI_ROCKET                  201
#define IDC_EMPID                       202
#define IDC_EMAIL                       203
#define IDC_OFFICE                      204
#define IDC_TELNUMBER                   205
#define IDC_NAME						206
#define IDC_GUID                        207
#define IDC_CLASS                       208
#define IDC_PARENT                      209
#define IDC_SCHEMA                      210
#define IDC_ADSPATH                     211
#define IDD_DIALOG1                     212
#define WM_MODELESSDLGCLOSED			213
#define IDC_EDIT_PICTURE_PATH           1000
#define IDC_PICTURE_DISPLAY             1001
#define IDC_BUTTON_CHANGE_PICTURE       1002
#define IDC_EDIT_EMPLOYEE_ID            1003
#define IDC_BUTTON_CLEAR_PICTURE        1004
#define IDC_BUTTONADV                   1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        214
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\proppageext.cpp ===
// PropPageExt.cpp : Implementation of CPropPageExt
#include "stdafx.h"
#include "DSAdminExt.h"
#include "PropPageExt.h"
#include "globals.h"
#include <crtdbg.h>
#include "Iads.h"
#include "adsprop.h"
#include "Adshlp.h"
#include "resource.h"
#include "winable.h"

typedef struct
{
    DWORD   dwFlags;                    // item flags
    DWORD   dwProviderFlags;            // flags for item provider
    DWORD   offsetName;                 // offset to ADS path of the object
    DWORD   offsetClass;                // offset to object class name / == 0 not known
} DSOBJECT, * LPDSOBJECT;


typedef struct
{
    CLSID    clsidNamespace;            // namespace identifier (indicates which namespace selection from)
    UINT     cItems;                    // number of objects
    DSOBJECT aObjects[1];               // array of objects
} DSOBJECTNAMES, * LPDSOBJECTNAMES;

#define BYTE_OFFSET(base, offset) (((LPBYTE)base)+offset)

/////////////////////////////////////////////////////////////////////////////
// CPropPageExt


///////////////////////////////
// Interface IExtendPropertySheet
///////////////////////////////
HRESULT CPropPageExt::CreatePropertyPages( 
                                                 /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                 /* [in] */ LONG_PTR handle,
                                                 /* [in] */ LPDATAOBJECT lpIDataObject)
{

	HRESULT hr = S_FALSE;

    LPDSOBJECTNAMES pDsObjectNames;
    PWSTR pwzObjName;
    PWSTR pwzClass;
 

	// Unpack the data pointer and create the property page.
	// Register clipboard format

	FORMATETC fmte = { cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	STGMEDIUM objMedium = {TYMED_NULL};;

	hr = lpIDataObject->GetData(&fmte, &objMedium);

    if (SUCCEEDED(hr))
    {
        pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal; 
 
        if (pDsObjectNames->cItems < 1)
        {
            hr = E_FAIL;
        }
        pwzObjName = (PWSTR)BYTE_OFFSET(pDsObjectNames,
                                       pDsObjectNames->aObjects[0].offsetName);
        pwzClass = (PWSTR)BYTE_OFFSET(pDsObjectNames,
                                       pDsObjectNames->aObjects[0].offsetClass);
        // Save the ADsPath of object
        m_ObjPath = new WCHAR [wcslen(pwzObjName )+1];
        wcscpy(m_ObjPath,pwzObjName);
    }
 
    // Now release the objMedium:
    // If punkForRelease is NULL, the receiver of 
    // the medium is responsible for releasing it; otherwise, 
    // punkForRelease points to the IUnknown on the appropriate 
    // object so its Release method can be called. 
 
    ReleaseStgMedium(&objMedium);
 
 	PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

	hr = S_OK;

    //
    // Create a property sheet page object from a dialog box.
    //
    // We store a pointer to our class in the psp.lParam, so we
    // can access our class members from within the DSExtensionPageDlgProc.
    //
    // If the page needs more instance data, you can append
    // arbitrary size of data at the end of this structure,
    // and pass it to the CreatePropSheetPage. In such a case,
    // the size of entire data structure (including page specific
    // data) must be stored in the dwSize field.   Note that in
    // general you should NOT need to do this, as you can simply
    // store a pointer to data in the lParam member.
    
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DSExtensionPageGen);
    psp.pfnDlgProc  = DSExtensionPageDlgProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PROPPAGE_TITLE);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    hr = lpProvider->AddPage(hPage);
    return hr;
}

HRESULT CPropPageExt::QueryPagesFor( 
                                           /* [in] */ LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

BOOL CALLBACK CPropPageExt::DSExtensionPageDlgProc(HWND hDlg, 
                             UINT uMessage, 
                             WPARAM wParam, 
                             LPARAM lParam)
{


    static CPropPageExt *pThis = NULL;
	
	static bool b_IsDirty = FALSE;
    
    switch (uMessage)
    {     		

		////////////////////////////////////////////////////////////////////////////////
		//WM_INITDIALOG handler
		////////////////////////////////////////////////////////////////////////////////
        case WM_INITDIALOG:
            {
				pThis = reinterpret_cast<CPropPageExt *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

				//Set to value of m_hPropPageWnd to the HWND of the our property page dialog
				pThis->m_hPropPageWnd = hDlg;

                HRESULT hr; 

				IDirectoryObject* pDirObject = NULL;
                hr = ADsGetObject(  pThis->m_ObjPath, IID_IDirectoryObject,(void **)&pDirObject);

                if (SUCCEEDED(hr))
                {
					//Retrieve some general info about the current user object.
					//We use our IDirectoryObject pointer here.

					ADS_ATTR_INFO   *pAttrInfo=NULL;
					ADS_ATTR_INFO   *pAttrInfo1=NULL;

					DWORD   dwReturn, dwReturn1;
					LPWSTR   pAttrNames[]={L"employeeID", L"mail", L"physicalDeliveryOfficeName", L"telephoneNumber"};
					LPWSTR   pAttrNames1[]={L"allowedAttributesEffective"};
					
					DWORD   dwNumAttr=sizeof(pAttrNames)/sizeof(LPWSTR);
					DWORD   dwNumAttr1=sizeof(pAttrNames1)/sizeof(LPWSTR);
					
					/////////////////////////////////////////
					// First get the allowedAttributesEffective 
					// attribute value. We use it to determine
					// whether we have the proper permissions
					// to modify the attributes of the current
					// object. If we have the needed
					// permissions, we enable the edit fields.
					// (They're disabled by default.)
					///////////////////////////////////////////

                    bool b_allowEmployeeChange  = FALSE;
                    bool b_allowMailChange      = FALSE;
                    bool b_allowOfficeChange    = FALSE;
                    bool b_allowTelNumberChange = FALSE;

					hr = pDirObject->GetObjectAttributes( pAttrNames1, 
														  dwNumAttr1, 
														  &pAttrInfo1, 
														  &dwReturn1 );
                    if ( SUCCEEDED(hr) )
                    {
                        //The call can succeed with no attributes returned if you lack privilege,
                        //so check that all attributes are returned.
                        if (dwReturn1 && pAttrInfo1 && pAttrInfo1->pszAttrName &&
                            _wcsicmp(pAttrInfo1->pszAttrName,L"allowedAttributesEffective")== 0)
                        {
                            if (ADSTYPE_INVALID != pAttrInfo1->dwADsType)
                            {
	                            //Permissions are per-attribute, so you need to check 
                                //if the attribute name is in the array of names returned 
                                //by the read of allowedAttributesEffective.

                                //The attributes we are interested in modifying are:
                                //employeeID, mail, physicalDeliveryOfficeName, telephoneNumber
	                            for (DWORD i = 0; i < pAttrInfo1->dwNumValues; i++)
	                            {
		                            if (_tcscmp(L"employeeID", pAttrInfo1->pADsValues[i].CaseIgnoreString) == 0)
			                            b_allowEmployeeChange = TRUE;
		                            else if (_tcscmp(L"mail", pAttrInfo1->pADsValues[i].CaseIgnoreString) == 0)
			                            b_allowMailChange = TRUE;
		                            else if (_tcscmp(L"physicalDeliveryOfficeName", pAttrInfo1->pADsValues[i].CaseIgnoreString) == 0)
			                            b_allowOfficeChange = TRUE;
		                            else if (_tcscmp(L"telephoneNumber", pAttrInfo1->pADsValues[i].CaseIgnoreString) == 0)
			                            b_allowTelNumberChange = TRUE;
	                            }
                            }
                        }
                    }

					//For loop for setting default value of text controls
					//This makes use of the fact that the ID values of the
					//text controls are sequential. We use the value of 
					//b_allowChanges to determine whether we enable editing or not
					for (int i = IDC_EMPID; i <= IDC_TELNUMBER; i++)
					{
						SetWindowText(GetDlgItem(hDlg,i),L"<not set>");
						if (IDC_EMPID == i && b_allowEmployeeChange)
							EnableWindow(GetDlgItem(hDlg, i), TRUE);

						else if (IDC_EMAIL == i && b_allowMailChange)
							EnableWindow(GetDlgItem(hDlg, i), TRUE);

						else if (IDC_OFFICE == i && b_allowOfficeChange)
							EnableWindow(GetDlgItem(hDlg, i), TRUE);

						else if (IDC_TELNUMBER == i && b_allowTelNumberChange)
							EnableWindow(GetDlgItem(hDlg, i), TRUE);
					}

					/////////////////////////////////////////////////////////////
					// Use FreeADsMem for all memory obtained from the ADSI call. 
					/////////////////////////////////////////////////////////////
					if (pAttrInfo1)
						FreeADsMem( pAttrInfo1 );

					
					/////////////////////////////////////////
					// Now get attribute values requested
					// Note: The order is not necessarily the 
					// same as requested using pAttrNames.
					///////////////////////////////////////////
					hr = pDirObject->GetObjectAttributes( pAttrNames, 
														  dwNumAttr, 
														  &pAttrInfo, 
														  &dwReturn );

					if ( SUCCEEDED(hr) )
					{
					   //Fill values of text controls with information taken from
					   //object attributes
					   for(DWORD idx=0; idx < dwReturn;idx++, pAttrInfo++ )
					   {
						   if (_wcsicmp(pAttrInfo->pszAttrName,L"employeeID") == 0 &&
							   pAttrInfo->pADsValues->CaseIgnoreString != '\0')
						   {
								SetWindowText(GetDlgItem(hDlg,IDC_EMPID),pAttrInfo->pADsValues->CaseIgnoreString);
						   }
						   else if (_wcsicmp(pAttrInfo->pszAttrName,L"mail") == 0 &&
							        pAttrInfo->pADsValues->CaseIgnoreString != '\0')
						   {
								SetWindowText(GetDlgItem(hDlg,IDC_EMAIL),pAttrInfo->pADsValues->CaseIgnoreString);
						   }
						   else if (_wcsicmp(pAttrInfo->pszAttrName,L"physicalDeliveryOfficeName") == 0 &&
							        pAttrInfo->pADsValues->CaseIgnoreString != '\0')
						   {
								SetWindowText(GetDlgItem(hDlg,IDC_OFFICE),pAttrInfo->pADsValues->CaseIgnoreString);
						   }
						   else if (_wcsicmp(pAttrInfo->pszAttrName,L"telephoneNumber") == 0 &&
							        pAttrInfo->pADsValues->CaseIgnoreString != '\0')
						   {
								SetWindowText(GetDlgItem(hDlg,IDC_TELNUMBER),pAttrInfo->pADsValues->CaseIgnoreString);
						   }
					   }
					}

					//Release our IDirectoryObject interface
 					pDirObject->Release();

					/////////////////////////////////////////////////////////////
					// Use FreeADsMem for all memory obtained from the ADSI call. 
					/////////////////////////////////////////////////////////////

					if (pAttrInfo)
						//First subtract pointer increments in the above for loop to our original pAttrInfo
						pAttrInfo = pAttrInfo-(dwReturn);

						FreeADsMem(pAttrInfo);

					return TRUE;
                }
            } //WM_INITDIALOG

		break;
		////////////////////////////////////////////////////////////////////////////////
		
		////////////////////////////////////////////////////////////////////////////////
		//WM_NOTIFY handler
		////////////////////////////////////////////////////////////////////////////////
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
                //We use this notification to enable the Advanced button on the general page
				case PSN_SETACTIVE:
					if (!pThis->m_hDlgModeless)
						EnableWindow(GetDlgItem(hDlg, IDC_BUTTONADV), TRUE);
					return TRUE;
                break;

				/////////////////////////////////////////////////////////////////
				//PSN_APPLY handler
				/////////////////////////////////////////////////////////////////
                case PSN_APPLY:
				{
					 if(b_IsDirty)
					 {
						 IDirectoryObject* pDirObject = NULL;
						 HRESULT hr = ADsGetObject(pThis->m_ObjPath, IID_IDirectoryObject,(void **)&pDirObject);
                    
						 _ASSERT(SUCCEEDED(hr));

						 //Apply changes user made here
						 WCHAR empID[128];
						 WCHAR email[128];
						 WCHAR office[128];
						 WCHAR telnumber[128];

						 DWORD dwReturn;
						 ADSVALUE snEmpID, snEmail, snOffice, snTelnumber;
						 ADS_ATTR_INFO attrInfo[] = {	{L"employeeID",ADS_ATTR_UPDATE,ADSTYPE_CASE_IGNORE_STRING,&snEmpID,1},
														{L"mail",ADS_ATTR_UPDATE,ADSTYPE_CASE_IGNORE_STRING,&snEmail,1}, 
														{L"physicalDeliveryOfficeName",ADS_ATTR_UPDATE,ADSTYPE_CASE_IGNORE_STRING,&snOffice,1}, 
														{L"telephoneNumber",ADS_ATTR_UPDATE,ADSTYPE_CASE_IGNORE_STRING,&snTelnumber,1},														
													};
						DWORD dwAttrs = 0;
						dwAttrs = sizeof(attrInfo)/sizeof(ADS_ATTR_INFO); 

						GetWindowText(GetDlgItem(hDlg, IDC_EMPID), empID, sizeof(empID));
						GetWindowText(GetDlgItem(hDlg, IDC_EMAIL), email, sizeof(email));
						GetWindowText(GetDlgItem(hDlg, IDC_OFFICE), office, sizeof(office));
						GetWindowText(GetDlgItem(hDlg, IDC_TELNUMBER), telnumber, sizeof(telnumber));

						snEmpID.dwType=ADSTYPE_CASE_IGNORE_STRING;
						snEmpID.CaseIgnoreString = empID;

						snEmail.dwType=ADSTYPE_CASE_IGNORE_STRING;
						snEmail.CaseIgnoreString = email;

						snOffice.dwType=ADSTYPE_CASE_IGNORE_STRING;
						snOffice.CaseIgnoreString = office;

						snTelnumber.dwType=ADSTYPE_CASE_IGNORE_STRING;
						snTelnumber.CaseIgnoreString = telnumber;

						hr = pDirObject->SetObjectAttributes(attrInfo, dwAttrs, &dwReturn);
						if (SUCCEEDED(hr))
							MessageBox(hDlg,
									   L"Changes accepted", 
									   L"Changes to Object Attributes",
									   MB_OK | MB_ICONEXCLAMATION);
						else	
							MessageBox(hDlg, 
									   L"Some or all changes were rejected\nby the directory service.", 
									   L"Changes to Object Attributes",
									   MB_OK | MB_ICONWARNING);

						//Release our IDirectoryObject interface
 						pDirObject->Release();

						b_IsDirty = FALSE;
					 }
					 //No user changes. Property sheet will go down, so
					 //first check if our property page's child dialog is open
					 else if (pThis->m_hDlgModeless)
						PostMessage(pThis->m_hDlgModeless, WM_CLOSE, wParam, lParam);
 
					 return TRUE;

                break; //PSN_APPLY
				}
				/////////////////////////////////////////////////////////////////

				/////////////////////////////////////////////////////////////////
				//PSN_QUERYCANCEL handler
				/////////////////////////////////////////////////////////////////
				case PSN_QUERYCANCEL:
					if (pThis->m_hDlgModeless)
						//The property page's child window is still open, so
						//we need to close it first.
						PostMessage(pThis->m_hDlgModeless, WM_CLOSE, wParam, lParam);				

					return TRUE;
				break; //PSN_QUERYCANCEL
				/////////////////////////////////////////////////////////////////

                default:
					return FALSE;
                break;

            } //end switch (((NMHDR FAR *)lParam)->code)

        break; //WM_NOTIFY
		////////////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////////////
		//WM_COMMAND handler
		////////////////////////////////////////////////////////////////////////////////
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{	
				/////////////////////////////////////////////////////////////////
				//IDC_EMPID, IDC_EMPID, IDC_OFFICE, IDC_TELNUMBER handler
				/////////////////////////////////////////////////////////////////
				case IDC_EMPID:
				case IDC_EMAIL:
				case IDC_OFFICE:
				case IDC_TELNUMBER:	

				if (EN_CHANGE == HIWORD(wParam) &&
					SendMessage(GetDlgItem(hDlg, LOWORD(wParam)),EM_GETMODIFY,0,0))
				{	
					//Activate Apply button
					SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
					
					//Set b_IsDirty to TRUE, indicating that user changes have occurred
					//Used in handling PSN_APPLY
					b_IsDirty = TRUE;
				}
				
				return TRUE;
				break;
				/////////////////////////////////////////////////////////////////

				/////////////////////////////////////////////////////////////////
				//IDC_BUTTONADV handler
				/////////////////////////////////////////////////////////////////
				case IDC_BUTTONADV:
				{
					//Disable Advanced button so that more than one child dialog
					//can't be available at a given time
					EnableWindow(GetDlgItem(hDlg, IDC_BUTTONADV), FALSE);
											
					//Create a secondary dialog							
					pThis->m_hDlgModeless = CreateDialogParam(g_hinst, MAKEINTRESOURCE(IDD_DSExtensionPage), 
								   hDlg, AdvDialogProc, reinterpret_cast<LPARAM>(pThis));

					return TRUE;
				}
				break; //IDC_BUTTONADV
				/////////////////////////////////////////////////////////////////

			} // end switch

        break;  //WM_COMMAND
		////////////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////////////
		//WM_MODELESSDLGCLOSED handler (custom window message)
		////////////////////////////////////////////////////////////////////////////////
		case WM_MODELESSDLGCLOSED:
			//Enable Advanced button again
			EnableWindow(GetDlgItem(hDlg, IDC_BUTTONADV), TRUE);
			return TRUE;
		break;	
		////////////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////////////
		//WM_DESTROY handler
		////////////////////////////////////////////////////////////////////////////////
        case WM_DESTROY:
			pThis->m_hPropPageWnd = NULL;
            RemoveProp(hDlg, L"ID");
			return TRUE;
        break;		
		////////////////////////////////////////////////////////////////////////////////

		default:
            return FALSE;
		break;
    } // 
 
    return TRUE;
} 

BOOL CALLBACK CPropPageExt::AdvDialogProc(HWND hDlg, 
                             UINT uMessage, 
                             WPARAM wParam, 
                             LPARAM lParam)
{
	static CPropPageExt *pThis = NULL;
	
	switch (uMessage)
	{
	////////////////////////////////////////////////////////////////////////////////
	//WM_INITDIALOG handler
	////////////////////////////////////////////////////////////////////////////////
	case WM_INITDIALOG:
	{   
		BSTR bsResult;

		pThis = reinterpret_cast<CPropPageExt *>(lParam);

        HRESULT hr; 
        IADs* pIADs = NULL;

        hr = ADsGetObject(  pThis->m_ObjPath, IID_IADs,(void **)&pIADs);		
        if (SUCCEEDED(hr))
        {

            // Retrieves the GUID for this object- The guid uniquely identifies 
            // this directory object. The Guid is globally unique
            // Also the guid is rename/move safe. The ADsPath below returns the 
            // CURRENT location of the object- The guid remains constant regardless of 
            // name or location of the directory object
            pIADs->get_GUID(&bsResult); 
            SetWindowText(GetDlgItem(hDlg,IDC_GUID),bsResult);
            SysFreeString(bsResult);

            // Retrieves the RDN
            pIADs->get_Name(&bsResult); 
            SetWindowText(GetDlgItem(hDlg,IDC_NAME),bsResult);
            SysFreeString(bsResult);

            // Retrieves the value in the class attribute, that is, group
            pIADs->get_Class(&bsResult); 
            SetWindowText(GetDlgItem(hDlg,IDC_CLASS),bsResult);
            SysFreeString(bsResult);

            // Retrieves the full literal LDAP path for this object.
            // This may be used to re-bind to this object- though for persistent
            // storage (and to be 'move\rename' safe) it is suggested that the 
            // guid be used instead of the ADsPath
            pIADs->get_ADsPath(&bsResult); 
            SetWindowText(GetDlgItem(hDlg,IDC_ADSPATH),bsResult);
            SysFreeString(bsResult);

            // Retrieves the LDAP path for the parent\container for this object
            pIADs->get_Parent(&bsResult); 
            SetWindowText(GetDlgItem(hDlg,IDC_PARENT),bsResult);
            SysFreeString(bsResult);

            // Retrieves the LDAP path for the Schema definition of the object returned from 
            /// the IADs::get_Schema() member
            pIADs->get_Schema(&bsResult); 
            SetWindowText(GetDlgItem(hDlg,IDC_SCHEMA),bsResult);
            SysFreeString(bsResult);

			pIADs->Release();
            pIADs = NULL;
        }
        
		return TRUE;
    }   
	
	break;
	////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////////
	//WM_COMMAND handler
	////////////////////////////////////////////////////////////////////////////////
	case WM_COMMAND:
		switch (LOWORD (wParam))
		{
			case IDOK :
				PostMessage(hDlg, WM_CLOSE, wParam, lParam);
				return TRUE;
			break;
		}
	break;
	////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////////
	//WM_CLOSE handler
	////////////////////////////////////////////////////////////////////////////////
	case WM_CLOSE:
		DestroyWindow (hDlg);
		SendMessage(pThis->m_hPropPageWnd, WM_MODELESSDLGCLOSED, (WPARAM)hDlg, 0);
		pThis->m_hDlgModeless = NULL;
		return TRUE;
	break;

	}//end 	switch (uMessage)
	////////////////////////////////////////////////////////////////////////////////

	return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\registry.cpp ===
#include "stdafx.h"
#include <wchar.h>
#include <activeds.h>

#include "DSAdminExt.h"
 
 
#define MMC_REG_NODETYPES L"software\\microsoft\\mmc\\nodetypes"
#define MMC_REG_SNAPINS L"software\\microsoft\\mmc\\snapins"
#define MMC_REG_SNAPINS L"software\\microsoft\\mmc\\snapins"
 
//MMC Extension subkeys
 
#define MMC_REG_EXTENSIONS L"Extensions"
#define MMC_REG_NAMESPACE L"NameSpace"
#define MMC_REG_CONTEXTMENU L"ContextMenu"
#define MMC_REG_TOOLBAR L"ToolBar"
#define MMC_REG_PROPERTYSHEET L"PropertySheet"
#define MMC_REG_TASKPAD L"Task"
 
//DSADMIN key
#define MMC_DSADMIN_CLSID L"{E355E538-1C2E-11D0-8C37-00C04FD8FE93}"
 
HRESULT GetCOMGUIDStr(LPOLESTR *ppAttributeName,IDirectoryObject *pDO, LPOLESTR *ppGUIDString);
 
HRESULT  RegisterNodeType( LPOLESTR pszSchemaIDGUID );
 
HRESULT  AddExtensionToNodeType(LPOLESTR pszSchemaIDGUID,
                    LPOLESTR pszExtensionType,
                    LPOLESTR pszExtensionSnapinCLSID,
                    LPOLESTR pszRegValue
                    );

//WCHAR * GetDirectoryObjectAttrib(IDirectoryObject *pDirObject,LPWSTR pAttrName);
 
HRESULT RegisterSnapinAsExtension(_TCHAR* szNameString) // NameString
{
	LPOLESTR szPath = new OLECHAR[MAX_PATH];
	HRESULT hr = S_OK;
	IADs *pObject = NULL;
	VARIANT var;
	IDirectoryObject *pDO = NULL;
	LPOLESTR pAttributeName = L"schemaIDGUID";
	LPOLESTR pGUIDString = NULL;

	//Convert CLSIDs of our "extension objects" to strings
	LPOLESTR wszCMenuExtCLSID = NULL;
	LPOLESTR wszPropPageExtCLSID = NULL;

	hr = StringFromCLSID(CLSID_CMenuExt, &wszCMenuExtCLSID);
	hr = StringFromCLSID(CLSID_PropPageExt, &wszPropPageExtCLSID);
	
	wcscpy(szPath, L"LDAP://");
	CoInitialize(NULL);
	//Get rootDSE and the schema container's DN.
	//Bind to current user's domain using current user's security context.
	hr = ADsOpenObject(L"LDAP://rootDSE",
				NULL,
				NULL,
				ADS_SECURE_AUTHENTICATION, //Use Secure Authentication
				IID_IADs,
				(void**)&pObject);
 
	if (SUCCEEDED(hr))
	{
		hr = pObject->Get(L"schemaNamingContext",&var);
		if (SUCCEEDED(hr))
		{
			wcscat(szPath, L"cn=user,");
			wcscat(szPath,var.bstrVal);
			hr = ADsOpenObject(szPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION, //Use Secure Authentication
					IID_IDirectoryObject,
					(void**)&pDO);
			if (SUCCEEDED(hr))
			{
				hr = GetCOMGUIDStr(&pAttributeName,
							pDO,
							&pGUIDString);
			if (SUCCEEDED(hr))
			{
				wprintf(L"schemaIDGUID: %s\n", pGUIDString);
				hr = RegisterNodeType( pGUIDString);
				wprintf(L"hr %x\n", hr);
				//do twice, once for each extension CLSID

				hr = AddExtensionToNodeType(pGUIDString,
							MMC_REG_CONTEXTMENU,
							wszCMenuExtCLSID, //our context menu extension object's CLSID
							szNameString 
							);
				hr = AddExtensionToNodeType(pGUIDString,
							MMC_REG_PROPERTYSHEET,
							wszPropPageExtCLSID, //our prop page extension object's CLSID
							szNameString
							);
				}
			}
		}
	}
	if (pDO)
		pDO->Release();
 
	VariantClear(&var);

	// Free memory.
	CoTaskMemFree(wszCMenuExtCLSID);
 	CoTaskMemFree(wszPropPageExtCLSID);

	// Uninitialize COM
	CoUninitialize();
	return 0;
}
  
HRESULT GetCOMGUIDStr(LPOLESTR *ppAttributeName,IDirectoryObject *pDO, LPOLESTR *ppGUIDString)
{
    HRESULT hr = S_OK;
    PADS_ATTR_INFO  pAttributeEntries;
    VARIANT varX;
    DWORD dwAttributesReturned = 0;
    hr = pDO->GetObjectAttributes(  ppAttributeName, //objectGUID
                                  1, //Only objectGUID
                                  &pAttributeEntries, // Returned attributes
                                  &dwAttributesReturned //Number of attributes returned
                                );
    if (SUCCEEDED(hr) && dwAttributesReturned>0)
    {
        //Make sure that we got the right type--GUID is ADSTYPE_OCTET_STRING
        if (pAttributeEntries->dwADsType == ADSTYPE_OCTET_STRING)
        {
            LPGUID pObjectGUID = (GUID*)(pAttributeEntries->pADsValues[0].OctetString.lpValue);
            //OLE str to fit a GUID
            LPOLESTR szDSGUID = new WCHAR [39];
            //Convert GUID to string.
            ::StringFromGUID2(*pObjectGUID, szDSGUID, 39); 
			*ppGUIDString = (OLECHAR *)CoTaskMemAlloc (sizeof(OLECHAR)*(wcslen(szDSGUID)+1));
			
			if (*ppGUIDString)
			   wcscpy(*ppGUIDString, szDSGUID);
			else
            hr=E_FAIL;
		}

	    else
		    hr = E_FAIL;
    
		//Free the memory for the attributes.
    FreeADsMem(pAttributeEntries);
    VariantClear(&varX);
    }
    return hr;
}
 
 
 
HRESULT  RegisterNodeType(LPOLESTR pszSchemaIDGUID)  
{ 
    LONG     lResult; 
    HKEY     hKey; 
    HKEY     hSubKey, hNewKey; 
    DWORD    dwDisposition; 
    LPOLESTR szRegSubKey = new OLECHAR[MAX_PATH];
 
        // first, open the HKEY_LOCAL_MACHINE 
        lResult  = RegConnectRegistry( NULL, HKEY_LOCAL_MACHINE, &hKey ); 
        if ( ERROR_SUCCESS == lResult )
    {
        //go to the MMC_REG_NODETYPES subkey 
            lResult  = RegOpenKey( hKey, MMC_REG_NODETYPES, &hSubKey ); 
            if ( ERROR_SUCCESS == lResult ) 
        {
            // Create a key for the node type of the class represented by pszSchemaIDGUID
            lResult  = RegCreateKeyEx( hSubKey,                // handle of an open key 
                        pszSchemaIDGUID,       // address of subkey name 
                        0L ,                    // reserved 
                        NULL, 
                        REG_OPTION_NON_VOLATILE,// special options flag 
                        KEY_ALL_ACCESS, 
                        NULL, 
                        &hNewKey, 
                        &dwDisposition );
            RegCloseKey( hSubKey ); 
        if ( ERROR_SUCCESS == lResult ) 
        {
            hSubKey = hNewKey; 
                // Create an extensions key 
            lResult  = RegCreateKeyEx( hSubKey,                 
                    MMC_REG_EXTENSIONS,                
                                0L ,                     
                                NULL, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hNewKey, 
                                &dwDisposition );
            //go to the MMC_REG_SNAPINS subkey 
            RegCloseKey( hSubKey ); 
            //Build the subkey path to the NodeTypes key of dsadmin
            wcscpy(szRegSubKey, MMC_REG_SNAPINS); //Snapins key
            wcscat(szRegSubKey, L"\\");
            wcscat(szRegSubKey, MMC_DSADMIN_CLSID); //CLSID for DSADMIN
            wcscat(szRegSubKey, L"\\NodeTypes");
            lResult  = RegOpenKey( hKey, szRegSubKey, &hSubKey ); 
            if ( ERROR_SUCCESS == lResult ) 
            {
                // Create a key for the node type of the class represented by pszSchemaIDGUID
                lResult  = RegCreateKeyEx( hSubKey,                // handle of an open key 
                                pszSchemaIDGUID,       // address of subkey name 
                                0L ,                    // reserved 
                                NULL, 
                                REG_OPTION_NON_VOLATILE,// special options flag 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &hNewKey, 
                                &dwDisposition );
                    RegCloseKey( hSubKey );
                }
 
            }
        }
    }
    RegCloseKey( hSubKey ); 
    RegCloseKey( hNewKey );
    RegCloseKey( hKey );
        return lResult; 
} 
 
HRESULT  AddExtensionToNodeType(LPOLESTR pszSchemaIDGUID,
                        LPOLESTR pszExtensionType,
                        LPOLESTR pszExtensionSnapinCLSID,
                        LPOLESTR pszRegValue
                        ) 
{
        LONG     lResult; 
        HKEY     hKey; 
        HKEY     hSubKey, hNewKey; 
        DWORD    dwDisposition;
    LPOLESTR szRegSubKey = new OLECHAR[MAX_PATH];
    HRESULT hr = S_OK;
 
        // first, open the HKEY_LOCAL_MACHINE 
        lResult  = RegConnectRegistry( NULL, HKEY_LOCAL_MACHINE, &hKey ); 
        if ( ERROR_SUCCESS == lResult )
    {
        //Build the subkey path to the NodeType specified by pszSchemaIDGUID
    wcscpy(szRegSubKey, MMC_REG_NODETYPES);
    wcscat(szRegSubKey, L"\\");
    wcscat(szRegSubKey, pszSchemaIDGUID);
    //go to the subkey 
        lResult  = RegOpenKey( hKey, szRegSubKey, &hSubKey ); 
        if ( ERROR_SUCCESS != lResult ) 
    {
        // Create the key for the nodetype if it doesn't already exist.
        hr = RegisterNodeType(pszSchemaIDGUID);
            if ( ERROR_SUCCESS != lResult ) 
            return E_FAIL;
            lResult  = RegOpenKey( hKey, szRegSubKey, &hSubKey ); 
    }
    // Create an extensions key if one doesn't already exist
    lResult  = RegCreateKeyEx( hSubKey,
                    MMC_REG_EXTENSIONS,
                               0L ,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hNewKey,
                               &dwDisposition );
    RegCloseKey( hSubKey ); 
    if ( ERROR_SUCCESS == lResult ) 
    {
        hSubKey = hNewKey; 
        // Create an extension type subkey if one doesn't already exist
        lResult  = RegCreateKeyEx( hSubKey,
                    pszExtensionType,
                           0L ,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hNewKey,
                           &dwDisposition );
        RegCloseKey( hSubKey );
        if ( ERROR_SUCCESS == lResult )
            {
            hSubKey = hNewKey;
            // Add your snap-in to the 
            //extension type key if it hasn't been already.
            lResult  = RegSetValueEx( hSubKey,
                pszExtensionSnapinCLSID,
                           0L ,
                           REG_SZ,
                           (const BYTE*)pszRegValue,
                           (wcslen(pszRegValue)+1)*sizeof(OLECHAR)
                    );
            }
 
        }
 }
    RegCloseKey( hSubKey );
    RegCloseKey( hNewKey );
    RegCloseKey( hKey );
    return lResult; 
} 

//GetDirectoryObjectAttrib() isn't used in this sample 
////////////////////////////////////////////////////////////////////////////////////////////////////
/*  
    GetDirectoryObjectAttrib()    - Returns the value of the attribute named in pAttrName
                                    from the IDirectoryObject passed
    Parameters
    
        IDirectoryObject *pDirObject    - Object from which to retrieve an attribute value
        LPWSTR pAttrName                - Name of attribute to retrieve
////////////////////////////////////////////////////////////////////////////////////////////////////

WCHAR * GetDirectoryObjectAttrib(IDirectoryObject *pDirObject,LPWSTR pAttrName)
{
    HRESULT   hr;
    ADS_ATTR_INFO   *pAttrInfo=NULL;
    DWORD   dwReturn;
    static WCHAR pwReturn[1024];
 
    pwReturn[0] = 0l;
 
    hr = pDirObject->GetObjectAttributes( &pAttrName, 
                                            1, 
                                            &pAttrInfo, 
                                            &dwReturn ); 
    if ( SUCCEEDED(hr) )
    {
        for(DWORD idx=0; idx < dwReturn;idx++, pAttrInfo++ )   
        {
            if ( _wcsicmp(pAttrInfo->pszAttrName,pAttrName) == 0 )       
            {
                wcscpy(pwReturn,pAttrInfo->pADsValues->CaseIgnoreString);
                break;
            }
        }
        FreeADsMem( pAttrInfo );
    }
    return pwReturn;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\dsadminext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D4E0AA86_DFF2_4B9E_B4C1_12969CDB9240__INCLUDED_)
#define AFX_STDAFX_H__D4E0AA86_DFF2_4B9E_B4C1_12969CDB9240__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D4E0AA86_DFF2_4B9E_B4C1_12969CDB9240__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\cabout.h ===
// CAbout.h : Declaration of the CCAbout

#ifndef __CABOUT_H_
#define __CABOUT_H_

#include "resource.h"       // main symbols
#include "Cabout.h"

#include <tchar.h>
#include <mmc.h>

/////////////////////////////////////////////////////////////////////////////
// CCAbout
class ATL_NO_VTABLE CCAbout : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCAbout, &CLSID_CAbout>,
	public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;

public:
    CCAbout();
    ~CCAbout();

DECLARE_REGISTRY_RESOURCEID(IDR_CABOUT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
};

#endif //__CABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\comp.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;
#include "stdafx.h"
#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CCompData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
}

CComponent::~CComponent()
{
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( 
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
	LPOLESTR pszW = NULL;
	HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give
    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
 
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);			
			AllocOleStr(&pszW, (LPTSTR)pszT);
            pResultDataItem->str = pszW;

        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\cabout.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

// CCAbout.cpp : Implementation of CCAbout

#include "stdafx.h"
#include "EvtVwr.h"
#include "CAbout.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CCAbout::CCAbout()
: m_cref(0)
{
        
    m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CCAbout::~CCAbout()
{
    if (m_hSmallImage != NULL)
        DeleteObject(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        DeleteObject(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        DeleteObject(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        DeleteObject(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CCAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
	return AllocOleStr(lpDescription,
			_T("Sample Z3: ATL-based Event Viewer Sample"));
}


STDMETHODIMP CCAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1999 Microsoft Corporation"));
}


STDMETHODIMP CCAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));
}


STDMETHODIMP CCAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CCAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CCompData *m_pComponentData;
    
    public:
        CComponent(CCompData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\compdata.h ===
// CompData.h : Declaration of the CCompData

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include "resource.h"       // main symbols
#include <mmc.h>

#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

#include "EvtVwr.h"

/////////////////////////////////////////////////////////////////////////////
// CCompData
class ATL_NO_VTABLE CCompData : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCompData, &CLSID_CompData>,
	public IComponentData,
	public IExtendPropertySheet2, //for configuration wizard
	public IExtendContextMenu,
	public IPersistStream
{
friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE2	m_ipConsoleNameSpace2;
    
    CStaticNode     *m_pStaticNode;

public:
	CCompData();
	~CCompData();

DECLARE_REGISTRY_RESOURCEID(IDR_COMPDATA)
DECLARE_NOT_AGGREGATABLE(CCompData)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCompData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet2)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

public:

    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);

    //////////////////////////////////
    // Interface IExtendPropertySheet2
    //////////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
    /* [in] */ LPDATAOBJECT lpDataObject);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
    /* [in] */ LPDATAOBJECT lpIDataObject,
    /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
    /* [out] */ HBITMAP __RPC_FAR *lphHeader,
    /* [out] */ HPALETTE __RPC_FAR *lphPalette,
    /* [out] */ BOOL __RPC_FAR *bStretch);

    ///////////////////////////////
    // Interface IExtendContextMenu
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);

    ///////////////////////////////
    // Interface IPersistStream
    ///////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE GetClassID( 
    /* [out] */ CLSID __RPC_FAR *pClassID);
    
    virtual HRESULT STDMETHODCALLTYPE IsDirty( void);

	virtual HRESULT STDMETHODCALLTYPE Load( 
    /* [unique][in] */ IStream __RPC_FAR *pStm);
    
    virtual HRESULT STDMETHODCALLTYPE Save( 
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ BOOL fClearDirty);
    
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
    /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);

private:
	HRESULT OnPreLoad(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);

    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//==============================================================;

// CCompData.cpp : Implementation of CCCompData
#include "stdafx.h"
#include "EvtVwr.h"
#include "CompData.h"
#include "Comp.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

HBITMAP CCompData::m_pBMapSm = NULL;
HBITMAP CCompData::m_pBMapLg = NULL;

CCompData::CCompData()
: m_cref(0), m_ipConsoleNameSpace2(NULL), m_ipConsole(NULL)
{        
	m_pStaticNode = new CStaticNode();
}

CCompData::~CCompData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }
    
}



///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CCompData::Initialize( 
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT hr = S_OK;
    
    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (void **)&m_ipConsoleNameSpace2);
    _ASSERT( S_OK == hr );
    
    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );
 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
	{	
		m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
	}

    IImageList *pImageList;
    hr = m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );
   
	//ImageListSetStrip can return a failure code. If it does, that's ok.
	hr = pImageList->ImageListSetStrip(	(long *)m_pBMapSm, // pointer to a handle
		(long *)m_pBMapLg, // pointer to a handle
		0, // index of the first image in the strip
		RGB(0, 128, 128)  // color of the icon mask
		);

    pImageList->Release();
    
    return S_OK;
}

HRESULT CCompData::CreateComponent( 
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) 
{
    *ppComponent = NULL;
    
    CComponent *pComponent = new CComponent(this);
    
    if (NULL == pComponent)
        return E_OUTOFMEMORY;
    
    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);

	return S_FALSE;
}

HRESULT CCompData::Notify( 
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();
    
    switch (event)
    {
    case MMCN_PRELOAD:
		//The arg value passed into Notify holds the HSCOPEITEM of
		//the static node. Cache it for future use.
		m_pStaticNode->SetHandle((HANDLE)arg);
		
		//The static node's display name includes the name of the 
		//currently targetted machine. MMC stores a static node's 
		//display name in the .msc file. When loading a snap-in
		//from a .msc file, MMC uses the stored display name again
		//The only way for the snap-in to change the display name 
		//is to support the CCF_SNAPINS_PRELOADS clipboard format
		//and to handle MMCN_PRELOAD.
		OnPreLoad(lpDataObject, arg, param);
		
		break;

	case MMCN_EXPAND: 
        hr = base->OnExpand(m_ipConsoleNameSpace2, m_ipConsole, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;
    
	case MMCN_REMOVE_CHILDREN:
	    hr = base->OnRemoveChildren();
        break;
	}

    return hr;
}


HRESULT CCompData::OnPreLoad(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)

{

	HRESULT hr = S_FALSE;
	USES_CONVERSION;
	SCOPEDATAITEM sdi;

	LPOLESTR wszName = NULL;

	const _TCHAR *pszName = m_pStaticNode->GetDisplayName();	

	wszName = (LPOLESTR)T2COLE(pszName);

	ZeroMemory (&sdi, sizeof(SCOPEDATAITEM));
	sdi.mask = SDI_STR;
	sdi.displayname	= wszName;
	sdi.ID			= arg;

	hr = m_ipConsoleNameSpace2->SetItem(&sdi);
	
	if (S_OK != hr)
		return E_FAIL;

	return hr;

}


HRESULT CCompData::Destroy( void)
{
	//Release handles to bitmaps created in CCompData::Initialize

	if (m_pBMapSm != NULL)
		DeleteObject(m_pBMapSm);

	if (m_pBMapLg != NULL)
		DeleteObject(m_pBMapLg);
	
	
	// Free interfaces
    if (m_ipConsoleNameSpace2) {
        m_ipConsoleNameSpace2->Release();
        m_ipConsoleNameSpace2 = NULL;
    }
    
    if (m_ipConsole) {
        m_ipConsole->Release(); 
        m_ipConsole = NULL;
    }
    


    return S_OK;
}

HRESULT CCompData::QueryDataObject( 
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject) 
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

HRESULT CCompData::GetDisplayInfo( 
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{	
	LPOLESTR pszW = NULL;
	HRESULT hr = S_FALSE;
    
    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {

			LPCTSTR pszT = base->GetDisplayName();		
			AllocOleStr(&pszW, (LPTSTR)pszT);
            pScopeDataItem->displayname = pszW;

        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }
    
    return hr;
}

HRESULT CCompData::CompareObjects( 
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CCompData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    return m_pStaticNode->CreatePropertyPages(lpProvider, handle);
}

HRESULT CCompData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    return m_pStaticNode->HasPropertySheets();
}

HRESULT CCompData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    return m_pStaticNode->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CCompData::AddMenuItems(
                                     /* [in] */ LPDATAOBJECT piDataObject,
                                     /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                     /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnAddMenuItems(piCallback, pInsertionAllowed);
}

HRESULT CCompData::Command(
                                /* [in] */ long lCommandID,
                                /* [in] */ LPDATAOBJECT piDataObject)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnMenuCommand(m_ipConsole, m_ipConsoleNameSpace2, lCommandID, piDataObject);
}


///////////////////////////////
// Interface IPersistStream
///////////////////////////////
HRESULT CCompData::GetClassID(
                                   /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = m_pStaticNode->getNodeType();

    return S_OK;
}

HRESULT CCompData::IsDirty( void)
{
    return m_pStaticNode->isDirty() == true ? S_OK : S_FALSE;
}

HRESULT CCompData::Load(
                             /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();

    return pStm->Read(snapInData, dataSize, NULL);
}

HRESULT CCompData::Save(
                             /* [unique][in] */ IStream __RPC_FAR *pStm,
                             /* [in] */ BOOL fClearDirty)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();

    if (fClearDirty)
        m_pStaticNode->clearDirty();

    return pStm->Write(snapInData, dataSize, NULL);
}

HRESULT CCompData::GetSizeMax(
                                   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return m_pStaticNode->getDataSize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "stdafx.h"

#include "DataObj.h"
#include "DeleBase.h"
#include "EvtVwr.h"

// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

#define _T_CCF_MACHINE_NAME _T("MMC_SNAPIN_MACHINE_NAME")
#define _T_CCF_EV_VIEWS _T("CF_EV_VIEWS")

#define _T_CCF_SNAPIN_PRELOADS _T("CCF_SNAPIN_PRELOADS")

// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);

//Clipboard formats required by Event Viewer extension
UINT CDataObject::s_cfMachineName   = RegisterClipboardFormat(_T_CCF_MACHINE_NAME );
UINT CDataObject::s_cfEventViews	= RegisterClipboardFormat(_T_CCF_EV_VIEWS);

//CCF_SNAPIN_PRELOADS clipboard format. We need to support this to receive
//the MMCN_PRELOAD notification.
UINT CDataObject::s_cfPreload		=  RegisterClipboardFormat(_T_CCF_SNAPIN_PRELOADS);

CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
	USES_CONVERSION;

    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
		LPOLESTR wszName = NULL;

		const _TCHAR *pszName = base->GetDisplayName();
		wszName = (LPOLESTR)T2COLE(pszName);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
 
      // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlenW(szGuid);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, ulSizeofName, NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CompData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    } else if(cf == s_cfMachineName) {
	  // Event Viewer will ask for this to determine which machine to 
      // to retrieve the log from.
		LPOLESTR wszMachineName = NULL;

		const _TCHAR *pszMachineName = base->GetMachineName();
		wszMachineName = (LPOLESTR)T2COLE(pszMachineName);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszMachineName);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszMachineName, ulSizeofName, NULL);
	} else if (cf == s_cfPreload) {
		BOOL bPreload = TRUE;
		hr = pStream->Write( (PVOID)&bPreload, sizeof(BOOL), NULL );
	}

    pStream->Release();
    
    return hr;
}

STDMETHODIMP CDataObject::GetData
( 
  LPFORMATETC pFormatEtc,    //[in]  Pointer to the FORMATETC structure 
  LPSTGMEDIUM pStgMedium     //[out] Pointer to the STGMEDIUM structure  
)
{
  const   CLIPFORMAT cf = pFormatEtc->cfFormat;
 
  _ASSERT( NULL != pFormatEtc );
  _ASSERT( NULL != pStgMedium );

  HRESULT hr = S_FALSE;

  if( pFormatEtc->cfFormat == s_cfEventViews )
  {
    hr = RetrieveEventViews( pStgMedium );
  }

  return hr;	

} //end GetData()

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
   
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()

//---------------------------------------------------------------------------
// This function fills out the STGMEDIUM in reponse to call to GetDataHere()
// with CF_EV_VIEWS as the clipformat.  We display a custom view of the 
// System log in this sample.
// The macros and other defines are in DataObject.h
//
HRESULT CDataObject::RetrieveEventViews
(
  LPSTGMEDIUM pStgMedium     //[in] Where we will store CF_EV_VIEWS
)
{
 
  USES_CONVERSION;

  HRESULT hr = S_OK;
                                       
  WCHAR      szFileName[_MAX_PATH];  // Build the path to the log

  CDelegationBase *base = GetBaseNodeObject();

  LPOLESTR szServerName = NULL;

  const _TCHAR *pszMachineName = base->GetMachineName();
  szServerName = (LPOLESTR)T2COLE(pszMachineName);

//  wcscpy( szFileName, L"\\\\" );
//  wcscat( szFileName, szServerName );  
  wcscpy( szFileName, szServerName );  
  wcscat( szFileName, L"\\Admin$\\System32\\Config\\SysEvent.Evt" );

  LPWSTR  szSourceName  = L"System";         // Log to access
  LPWSTR  szDisplayName = L"System Events";    // Title of our view

                                             // Allocate some memory
  HGLOBAL hMem = ::GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT, 1024 );
  if( NULL == hMem )
    return STG_E_MEDIUMFULL;               
                                             // Get a pointer to our data
  BYTE* pPos = reinterpret_cast<BYTE*>(::GlobalLock(hMem));
  LONG  nLen = 0;

  // Add the CF_EV_VIEWS header info
  ADD_BOOL( TRUE, pPos );                    // fOnlyTheseViews
  ADD_USHORT( 1, pPos );                     // cViews - Just one view

  ///////////////////////////////////////////////////////////////////////////
  // This information is repeated for each view we want to display

  // Add a filtered System Log
  ADD_ULONG( ELT_SYSTEM, pPos );           // EVENTLOGTYPE 
  ADD_USHORT( VIEWINFO_CUSTOM, pPos );     // fViewFlags   
  ADD_STRING( szServerName, nLen, pPos );  // wszServerName  - Null for local machine
  ADD_STRING( szSourceName, nLen, pPos );  // wszSourceName  - "SYSTEM" for SystemLog
  ADD_STRING( szFileName,   nLen, pPos );  // wszFileName    - UNC or local path to log
  ADD_STRING( szDisplayName,nLen, pPos );  // wszDisplayName - Name of the custom view 

  // EV_SCOPE_FILTER data
  ADD_ULONG( EV_ALL_ERRORS, pPos );        // fRecType
  ADD_USHORT( 0, pPos );                   // usCategory
  ADD_BOOL( FALSE, pPos );                 // fEventID
  ADD_ULONG( 0, pPos );                    // ulEventID
  ADD_STRING( L"", nLen, pPos );           // szSource-"NetLogon","TCPMon" etc
  ADD_STRING( L"", nLen, pPos );           // szUser
  ADD_STRING( L"", nLen, pPos );           // szComputer
  ADD_ULONG( 0, pPos );                    // ulFrom
  ADD_ULONG( 0, pPos );                    // ulTo

  ::GlobalUnlock( hMem );                  // Unlock and set the rest of the 
  pStgMedium->hGlobal        = hMem;       // StgMedium variables 
  pStgMedium->tymed          = TYMED_HGLOBAL;
	 pStgMedium->pUnkForRelease = NULL;

  ATLTRACE(_T("CDataObject::RetrieveEventVeiws-> Returned S_OK \n") );
  return hr;

} //end RetrieveEventVeiws()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

#define ADD_TYPE(Data, Type, pPos)    *((Type*)pPos) = (Type)(Data); \
 	                                    pPos += sizeof(Type)

#define ADD_BOOL(bo, pPos)            ADD_TYPE(bo, BOOL,   pPos)
#define ADD_USHORT(us, pPos)          ADD_TYPE(us, USHORT, pPos)
#define ADD_ULONG(ul, pPos)           ADD_TYPE(ul, ULONG,  pPos)
#define ADD_STRING(str, strLength, pPos)                                         \
 	                             strLength = wcslen((LPWSTR)(str)) + 1;            \
 	                             ADD_USHORT(strLength, pPos);                      \
 	                             wcsncpy((LPWSTR)pPos, (LPWSTR)(str), strLength);  \
 	                             pPos += (strLength * sizeof(WCHAR))


#define ELT_SYSTEM            101
#define ELT_SECURITY          102
#define ELT_APPLICATION       103
#define ELT_CUSTOM            104

#define VIEWINFO_BACKUP       0x0001
#define VIEWINFO_FILTERED     0x0002
#define VIEWINFO_LOW_SPEED    0x0004
#define VIEWINFO_USER_CREATED 0x0008
#define VIEWINFO_ALLOW_DELETE 0x0100
#define VIEWINFO_DISABLED     0x0200
#define VIEWINFO_READ_ONLY    0x0400
#define VIEWINFO_DONT_PERSIST 0x0800

#define VIEWINFO_CUSTOM       ( VIEWINFO_FILTERED | VIEWINFO_DONT_PERSIST  | \
                            VIEWINFO_ALLOW_DELETE | VIEWINFO_USER_CREATED)

#define EV_ALL_ERRORS  (EVENTLOG_ERROR_TYPE       | EVENTLOG_WARNING_TYPE  | \
                        EVENTLOG_INFORMATION_TYPE | EVENTLOG_AUDIT_SUCCESS | \
                        EVENTLOG_AUDIT_FAILURE) 



class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    
	// The rest are not implemented
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
// Private support methods
  private:
//    HRESULT  RetrieveNodeTypeGuid( IStream* pStream );
//    HRESULT  RetrieveSnapInClassID( IStream* pStream );
//    HRESULT  RetrieveDisplayString( IStream* pStream );
//    HRESULT  RetrieveGuidString( IStream* pStream );
//    HRESULT  RetrieveThisPointer( IStream* pStream );
//    HRESULT  RetrieveMachineName( IStream* pStream );
    HRESULT  RetrieveEventViews( LPSTGMEDIUM pStgMedium );

public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;

	// clipboard formats required by Event Viewer extension
	static UINT s_cfMachineName; //machine name that Event Viewer points to
	static UINT s_cfEventViews;  // Data needed by Event Viewer
    
	//Add support for the CCF_SNAPIN_PRELOADS clipboard format
	static UINT s_cfPreload;
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;
#include "stdafx.h"
#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE), m_handle(NULL) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\evtvwr.cpp ===
// EvtVwr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f EvtVwrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "EvtVwr.h"

#include "EvtVwr_i.c"
#include "CompData.h"
#include "CAbout.h"

// our globals
HINSTANCE g_hinst;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CompData, CCompData)
OBJECT_ENTRY(CLSID_CAbout, CCAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {

		g_hinst = hInstance;

        _Module.Init(ObjectMap, hInstance, &LIBID_EVTVWRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"


class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const _TCHAR *GetMachineName() {_ASSERT(FALSE); return NULL;}
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    virtual const HANDLE GetHandle() { return m_handle; }
    virtual SetHandle(HANDLE handle) { m_handle = handle; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace2 *pConsoleNameSpace2, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
	virtual HRESULT OnRemoveChildren() { return S_FALSE; }
	
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }

    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, IConsoleNameSpace2 *pConsoleNameSpace2, long lCommandID, IDataObject *piDataObject) { return S_FALSE; }

    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    HANDLE m_handle;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\evtvwr.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Fri Jan 21 20:15:53 2000
 */
/* Compiler settings for D:\nt\private\admin\bosrc\sources\atl_samp\EvtVwr\EvtVwr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __EvtVwr_h__
#define __EvtVwr_h__

/* Forward Declarations */ 

#ifndef __ICompData_FWD_DEFINED__
#define __ICompData_FWD_DEFINED__
typedef interface ICompData ICompData;
#endif 	/* __ICompData_FWD_DEFINED__ */


#ifndef __ICAbout_FWD_DEFINED__
#define __ICAbout_FWD_DEFINED__
typedef interface ICAbout ICAbout;
#endif 	/* __ICAbout_FWD_DEFINED__ */


#ifndef __CompData_FWD_DEFINED__
#define __CompData_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompData CompData;
#else
typedef struct CompData CompData;
#endif /* __cplusplus */

#endif 	/* __CompData_FWD_DEFINED__ */


#ifndef __CAbout_FWD_DEFINED__
#define __CAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class CAbout CAbout;
#else
typedef struct CAbout CAbout;
#endif /* __cplusplus */

#endif 	/* __CAbout_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICompData_INTERFACE_DEFINED__
#define __ICompData_INTERFACE_DEFINED__

/* interface ICompData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICompData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DCBBC99-77D1-456D-BA21-89456CC5F3B7")
    ICompData : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICompDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICompData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICompData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICompData __RPC_FAR * This);
        
        END_INTERFACE
    } ICompDataVtbl;

    interface ICompData
    {
        CONST_VTBL struct ICompDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICompData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICompData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICompData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICompData_INTERFACE_DEFINED__ */


#ifndef __ICAbout_INTERFACE_DEFINED__
#define __ICAbout_INTERFACE_DEFINED__

/* interface ICAbout */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EA1621DC-3A2F-4B73-8899-6080E0CD439C")
    ICAbout : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICAbout __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICAbout __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICAbout __RPC_FAR * This);
        
        END_INTERFACE
    } ICAboutVtbl;

    interface ICAbout
    {
        CONST_VTBL struct ICAboutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICAbout_INTERFACE_DEFINED__ */



#ifndef __EVTVWRLib_LIBRARY_DEFINED__
#define __EVTVWRLib_LIBRARY_DEFINED__

/* library EVTVWRLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_EVTVWRLib;

EXTERN_C const CLSID CLSID_CompData;

#ifdef __cplusplus

class DECLSPEC_UUID("D26F5CC6-58E0-46A2-8939-C2D051E3E343")
CompData;
#endif

EXTERN_C const CLSID CLSID_CAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("37C40DB4-6539-40DF-8022-8EB106883236")
CAbout;
#endif
#endif /* __EVTVWRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_LOGSERVICEICON     0
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\globals.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.

//==============================================================;

#include "stdafx.h"
#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

// this uses the ATL String Conversion Macros 
// for handling any necessary string conversion. Note that
// the snap-in (callee) allocates the necessary memory,
// and MMC (the caller) does the cleanup, as required by COM.
HRESULT AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	USES_CONVERSION;
 
	*lpDest = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(szBuffer) + 1) * 
									sizeof(WCHAR)));
	if (*lpDest == 0)
		return E_OUTOFMEMORY;
    
	LPOLESTR ptemp = T2OLE(szBuffer);
	
	wcscpy(*lpDest, ptemp);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

extern HINSTANCE g_hinst;

HRESULT	AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer);

// uncomment the following #define to enable message cracking
#define MMC_CRACK_MESSAGES
void MMCN_Crack(BOOL bComponentData, 
				IDataObject *pDataObject, 
				IComponentData *pCompData,
				IComponent *pComp,
				MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param);




#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\logsrvc.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//==============================================================;

#include "stdafx.h"
#include "logsrvc.h"
#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"

const GUID CLogService::thisGuid = { 0x72248fa5, 0x1fa1, 0x4742, { 0xa4, 0xb2, 0x10, 0x9a, 0xf2, 0x5, 0x1d, 0x6c } };

//==============================================================
//
// CLogService implementation
//
//

const _TCHAR *CLogService::GetDisplayName(int nCol)
{ 
/*    _TCHAR buf[128];
    
    wsprintf(buf, _T("Bicycle"));
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;

*/


    
	static _TCHAR szDisplayName[256] = {0};
    LoadString(g_hinst, IDS_LOGSERVICENODE, szDisplayName, sizeof(szDisplayName)/sizeof(szDisplayName[0]));
/*    
    _tcscat(szDisplayName, _T(" ("));
    _tcscat(szDisplayName, snapInData.m_host);
    _tcscat(szDisplayName, _T(")"));
   
*/  
	return szDisplayName; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\logsrvc.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _LOGSVRC_H
#define _LOGSVRC_H

#include "DeleBase.h"
#include "statnode.h"

//---------------------------------------------------------------------------
//  This node class doesn't do much.  It just provides a node for use to
//  to attach the Event Viewer extension to.
//
class CLogService : public CDelegationBase {
public:
    CLogService(CStaticNode* parent) : pParent(parent) { }
    
    virtual ~CLogService() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LOGSERVICEICON; }
    virtual const _TCHAR *GetMachineName() { return pParent->getHost(); }  
 
private:
	// {72248FA5-1FA1-4742-A4B2-109AF2051D6C}
    static const GUID thisGuid;

	CStaticNode* pParent;
};


#endif // _LOGSVRC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EvtVwr.rc
//
#define IDS_HELPFILE                    1
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_SNAPINDESC                  8
#define IDS_ABOUTNAME                   9
#define IDS_PROJNAME                    100
#define IDS_CHOOSER_INVALID_COMPUTERNAME 101
#define IDS_SELECT_COMPUTER             102
#define IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR 103
#define IDS_COMPUTER_BROWSER_CAPTION    104
#define IDR_COMPDATA                    105
#define IDS_COMPUTER_NEW_BROWSER_CAPTION 105
#define IDR_CABOUT                      106
#define IDS_LOGSERVICENODE              106
#define IDI_ICON1                       108
#define IDB_WATERMARK                   111
#define IDB_HEADER                      112
#define IDB_SMOPEN                      113
#define IDB_SMBMP                       114
#define IDB_LGBMP                       115
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_NODES_16x16                 208
#define IDB_NODES_32x32                 209
#define IDD_CHOOSER_CHOOSE_NEW_MACHINE  213
#define IDD_CHOOSER_CHOOSE_MACHINE      10016
#define IDC_CHOOSER_STATIC              10017
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 10018
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 10019
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 10020
#define IDC_CHOOSER_EDIT_MACHINE_NAME   10021
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 10022
#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME 10023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        214
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "stdafx.h"
#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__24B86198_F26C_4A74_BF39_1E6D3EDBD028__INCLUDED_)
#define AFX_STDAFX_H__24B86198_F26C_4A74_BF39_1E6D3EDBD028__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__24B86198_F26C_4A74_BF39_1E6D3EDBD028__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\statnode.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0); 
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    virtual const _TCHAR *GetMachineName() { return getHost(); }   
	
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace2 *pConsoleNameSpace2, IConsole *pConsole, HSCOPEITEM parent);
	virtual HRESULT OnRemoveChildren(); 
	virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);

    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, IConsoleNameSpace2 *pConsoleNameSpace2, long lCommandID, IDataObject *piDataObject);


private:
    enum { IDM_SELECT_COMPUTER = 4 };

    enum { NUMBER_OF_CHILDREN = 1 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {39874FE4-258D-46f2-B442-0EA0DA2CBEF8}
    static const GUID thisGuid;
    
    struct privateData {
        _TCHAR m_host[MAX_PATH];
        BOOL m_fIsRadioLocalMachine;
        BOOL m_fAllowOverrideMachineNameOut;
        bool m_isDirty;
        
        privateData() : m_isDirty(false) {
            ZeroMemory(m_host, sizeof(m_host));
            m_fIsRadioLocalMachine = TRUE;
            m_fAllowOverrideMachineNameOut = FALSE;
        }
    } snapInData;
    
    static BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

	static int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

	static GetLocalComputerName( _TCHAR *szComputerName);
    
	HRESULT ReinsertChildNodes(IConsole *pConsole, IConsoleNameSpace2 *pConsoleNameSpace2);

public:
    LONG getDataSize() { return sizeof(privateData); }
    void *getData() { return &snapInData; }
    bool isDirty() { return snapInData.m_isDirty; }
    void clearDirty() { snapInData.m_isDirty = false; };
    
    _TCHAR *getHost() { return snapInData.m_host; }
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\evtvwr\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;
#include "stdafx.h"
#include <Shlwapi.h>
#include <Shlobj.H>

#include "StatNode.h"
#include "logsrvc.h"

const GUID CStaticNode::thisGuid = { 0x39874fe4, 0x258d, 0x46f2, { 0xb4, 0x42, 0xe, 0xa0, 0xda, 0x2c, 0xbe, 0xf8 } };


//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
  children[0] = new CLogService(this);
}

CStaticNode::~CStaticNode()
{
	//Note that CStaticNode's children are already deleted when the snap-in
	//receives the MMCN_REMOVE_CHILDREN notification.
}


const _TCHAR *CStaticNode::GetDisplayName(int nCol)
{ 
    static _TCHAR szDisplayName[256] = {0};
    LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
    
    _tcscat(szDisplayName, _T(" ("));
    _tcscat(szDisplayName, snapInData.m_host);
    _tcscat(szDisplayName, _T(")"));
    
    return szDisplayName; 
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace2 *pConsoleNameSpace2, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
   
	//The HSCOPEITEM passed into OnExpand is the handle of our static node, so cache it
	//if it doesn't already exist.
    if (GetHandle() == NULL) {
        SetHandle((HANDLE)parent);
    }  

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_TEXTCALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0; // no child scope items, so remove "+" sign
            
            HRESULT hr = pConsoleNameSpace2->InsertItem( &sdi );
            
            children[n]->SetHandle((HANDLE)sdi.ID);
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
	//Set bExpanded flag to TRUE
	bExpanded = TRUE;
    return S_OK;
}


HRESULT CStaticNode::OnRemoveChildren()
{
	HRESULT hr = S_OK;

	for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
		if (children[n]) {
		delete children[n];
	}
	
	return hr;
}


HRESULT CStaticNode::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CHOOSER_CHOOSE_MACHINE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(&snapInData);
    psp.pszTitle = MAKEINTRESOURCE(IDS_SELECT_COMPUTER);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    return lpProvider->AddPage(hPage);
}

HRESULT CStaticNode::HasPropertySheets()
{
    return S_OK;
}

HRESULT CStaticNode::GetWatermarks(HBITMAP *lphWatermark,
                                   HBITMAP *lphHeader,
                                   HPALETTE *lphPalette,
                                   BOOL *bStretch)
{
    *lphHeader = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_HEADER), IMAGE_BITMAP, 0, 0, 0);
    *lphWatermark = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_WATERMARK), IMAGE_BITMAP, 0, 0, 0);
    *bStretch = FALSE;
    
    return S_OK;
}

BOOL CALLBACK CStaticNode::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static privateData *pData = NULL;
    static HWND m_hwndCheckboxOverride;
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        pData = reinterpret_cast<privateData *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
        
        SendDlgItemMessage(hwndDlg, IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, pData->m_fIsRadioLocalMachine, 0L);
        SendDlgItemMessage(hwndDlg, IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !pData->m_fIsRadioLocalMachine, 0L);
        
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), !pData->m_fIsRadioLocalMachine);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), !pData->m_fIsRadioLocalMachine);
        
        m_hwndCheckboxOverride = ::GetDlgItem(hwndDlg, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME);
        
        // fill in the supplied machine name (could be us, need to check here first)
        if (*pData->m_host != '\0') 
        {
            ::SetWindowText(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), pData->m_host);
            ::SendMessage(GetDlgItem(hwndDlg, IDC_CHOOSER_RADIO_SPECIFIC_MACHINE), BM_CLICK, 0, 0);
        }
        
        
        return TRUE;
        
    case WM_COMMAND:
        switch (wParam) 
        {
        case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
            pData->m_fIsRadioLocalMachine = TRUE;
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), FALSE);
            break;
            
        case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
            pData->m_fIsRadioLocalMachine = FALSE;
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), TRUE);
            break;
            
        case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
            {
                // Fall back to IE-style browser
                BROWSEINFO bi;
                LPITEMIDLIST lpItemIdList;
                LPMALLOC lpMalloc;
                
                if (SUCCEEDED(SHGetSpecialFolderLocation(hwndDlg, CSIDL_NETWORK, &lpItemIdList)))
                {
                    _TCHAR szBrowserCaption[MAX_PATH];
                    LoadString(g_hinst, IDS_COMPUTER_BROWSER_CAPTION, szBrowserCaption, sizeof(szBrowserCaption));
                    
                    bi.hwndOwner = hwndDlg; 
                    bi.pidlRoot = lpItemIdList; 
                    bi.pszDisplayName = pData->m_host; 
                    bi.lpszTitle = szBrowserCaption; 
                    bi.ulFlags = BIF_BROWSEFORCOMPUTER | BIF_EDITBOX | BIF_VALIDATE; 
					bi.lpfn = BrowseCallbackProc; 
                    bi.lParam = NULL; 
                    bi.iImage = NULL; 
                    
                    if (SHBrowseForFolder(&bi) != NULL) 
                    {
                        if (*pData->m_host != '\0') 
                        {
                            ::SetWindowText(GetDlgItem(hwndDlg, 
                                IDC_CHOOSER_EDIT_MACHINE_NAME), pData->m_host);
                        }
                    }
                    
                    if (SUCCEEDED(SHGetMalloc(&lpMalloc))) 
                    {
                        lpMalloc->Free(lpItemIdList);
                        lpMalloc->Release();
                    }
                }
            }
            break;
            
        case IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME:
            break;
        }
        break;
        
        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
            case PSN_SETACTIVE: 
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_FINISH);
                break;
                
            case PSN_WIZFINISH: 
                if (pData->m_fIsRadioLocalMachine) {
					// Return string with local computer name to the caller
					GetLocalComputerName(pData->m_host);

                } else {
                    // Get the machine name from the edit window
                    GetWindowText(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), 
                        pData->m_host, sizeof(pData->m_host));

					//if the user didn't enter anything, we need to
					//get the local computer name first. Since
					//GetLocalComputerName takes care of putting everything
					//into uppercase, we can break from this case
					if (*pData->m_host == '\0')
					{
						GetLocalComputerName(pData->m_host);
						break;
					}

					//Put machine name in uppercase
					static _TCHAR sztemp[MAX_PATH];
					int n =0;
					while (pData->m_host[n] != '\0')
					{
						sztemp[n] = toupper(pData->m_host[n]);
						n++;
					}
					sztemp[n] = '\0';
					_tcscpy(pData->m_host, sztemp);
                }
                
                // Save the override flag if the caller asked for it
                pData->m_fAllowOverrideMachineNameOut = 
                    SendMessage(m_hwndCheckboxOverride, BM_GETCHECK, 0, 0) == BST_CHECKED ? TRUE : FALSE;
                
                break;
            }
            
            break;
    }
    
    return FALSE;
}

HRESULT CStaticNode::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            L"Select Computer", L"Select new computer to manage",
            IDM_SELECT_COMPUTER, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        { NULL, NULL, 0, 0, 0 }
    };

    // Loop through and add each of the menu items, we
    // want to add to new menu, so see if it is allowed.
    if (*pInsertionsAllowed)
    {
        for (LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);

            if (FAILED(hr))
                break;
        }
    }

    return hr;
}

HRESULT CStaticNode::OnMenuCommand(IConsole *pConsole, IConsoleNameSpace2 *pConsoleNameSpace2, long lCommandID, IDataObject *pDataObject)
{

	HRESULT hr = S_FALSE;

	USES_CONVERSION;

	switch (lCommandID)
    {
    case IDM_SELECT_COMPUTER:

        // Fall back to IE-style browser
        BROWSEINFO bi;
        LPITEMIDLIST lpItemIdList;
        LPMALLOC lpMalloc;

		HWND  hWnd;
		hr = pConsole->GetMainWindow(&hWnd);

		if (SUCCEEDED(hr))
		{
 
			if (SUCCEEDED(SHGetSpecialFolderLocation(hWnd, CSIDL_NETWORK, &lpItemIdList)))
			{
				_TCHAR szBrowserCaption[MAX_PATH];
				_TCHAR szUserSelection[MAX_PATH];

				LoadString(g_hinst, IDS_COMPUTER_NEW_BROWSER_CAPTION, szBrowserCaption, sizeof(szBrowserCaption));
            
				
				//Add machine name to browser caption
				_tcscat(szBrowserCaption, _T("\nCurrent computer is "));
 				_tcscat(szBrowserCaption, snapInData.m_host);

				bi.hwndOwner = hWnd; 
				bi.pidlRoot = lpItemIdList; 
				bi.pszDisplayName = szUserSelection; 
				bi.lpszTitle = szBrowserCaption; 
				bi.ulFlags = BIF_BROWSEFORCOMPUTER | BIF_EDITBOX | BIF_VALIDATE; 
				bi.lpfn = BrowseCallbackProc; 
				bi.lParam = NULL; 
				bi.iImage = NULL; 
            
				if (SHBrowseForFolder(&bi) != NULL) 
				{
					//Check to see if user chose a new machine. If yes,
					//we'll need to remove the Log Service Node and then
					//reinsert it. As a result, Event Viewer will reinsert
					//its node under the Log Service Node and request the
					//MMC_SPAPIN_MACHINE_NAME clipboard format from us.
					if ( (_tcscmp(szUserSelection, getHost())) ) 
					{
						//Store the new machine name
						static privateData *pData = NULL;
						pData = &snapInData;
						if (*szUserSelection == 0) //Retrieve local computer name first
							GetLocalComputerName(szUserSelection);

						_tcscpy(pData->m_host, szUserSelection);

						//Put machine name in uppercase
						static _TCHAR sztemp[MAX_PATH];
						int n =0;
						while (pData->m_host[n] != '\0')
						{
							sztemp[n] = toupper(pData->m_host[n]);
							n++;
						}
						sztemp[n] = '\0';
						_tcscpy(pData->m_host, sztemp);

						//Now reinsert the Log Service Node
						hr = ReinsertChildNodes(pConsole, pConsoleNameSpace2);
					}


				}
            
				if (SUCCEEDED(SHGetMalloc(&lpMalloc))) 
				{
					lpMalloc->Free(lpItemIdList);
					lpMalloc->Release();
				}
			}
		}
    }

    return hr;
}


int CALLBACK CStaticNode::BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{

   switch (uMsg)
    {
    case BFFM_VALIDATEFAILED:
        

		::MessageBox(hwnd, _T("The selected computer isn't on the network. Try again."), _T("Invalid drive specification"),
					 MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    
		return 1; //Don't dismiss the Browse dialog

   }

   return 0;

}


HRESULT CStaticNode::ReinsertChildNodes(IConsole *pConsole, IConsoleNameSpace2 *pConsoleNameSpace2)
{
	HRESULT hr = S_FALSE;
	USES_CONVERSION;

	//First we change the display name of the static node
	SCOPEDATAITEM sdi;

	LPOLESTR wszName = NULL;
	const _TCHAR *pszName = GetDisplayName();	
	wszName = (LPOLESTR)T2COLE(pszName);

	HSCOPEITEM hStaticNode = (HSCOPEITEM)GetHandle();

	ZeroMemory (&sdi, sizeof(SCOPEDATAITEM));
	sdi.mask = SDI_STR;
	sdi.displayname	= wszName;
	sdi.ID			= hStaticNode;

	hr = pConsoleNameSpace2->SetItem(&sdi);
	
	if (S_OK != hr)
		return E_FAIL;

	//check to see if the static node has already been expanded. If it hasn't,
	//there's nothing else we need to do.
	
	if (bExpanded)
	{
		//Delete children of static node
		for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
		{
			if (children[n])
			{
				hr =  pConsoleNameSpace2->DeleteItem((HSCOPEITEM)(children[n]->GetHandle()), TRUE);
				_ASSERT(SUCCEEDED(hr));	
			}		
		}

		//Reinsert the children of the static node. This will
		//result in the Event Viewer snap-in reinserting its own node under ours.
		//First set bExpanded flag to FALSE so that the code that inserts
		//the children is executed.
		bExpanded = FALSE;
		OnExpand(pConsoleNameSpace2, pConsole, hStaticNode);

		if (S_OK != hr)
			return E_FAIL;
	}

	return hr;
}

CStaticNode::GetLocalComputerName( _TCHAR *szComputerName)
{

	static _TCHAR szbuf[MAX_PATH];
	static _TCHAR szbuflower[MAX_PATH];

	DWORD dw = sizeof(szbuf);
					
	::GetComputerName(&szbuf[0], &dw);

	int n =0;

	//Put each character of machine name in uppercase
	while (szbuf[n] != '\0')
	{
		szbuflower[n] = toupper(szbuf[n]);
		n++;
	}
	szbuflower[n] = '\0';


	_tcscpy( szComputerName, _T("\\\\") );
	_tcscat( szComputerName, &szbuflower[0] ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

// About.cpp : Implementation of CAbout

#include "stdafx.h"
#include "ExtSnap.h"
#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CAbout::CAbout()
: m_cref(0)
{
        
    m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CAbout::~CAbout()
{
    if (m_hSmallImage != NULL)
        DeleteObject(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        DeleteObject(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        DeleteObject(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        DeleteObject(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
	return AllocOleStr(lpDescription,
			_T("ATL-based Namespace Extension Sample \
			Snap-in for the Computer Management snap-in."));
}


STDMETHODIMP CAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));
}


STDMETHODIMP CAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));
}


STDMETHODIMP CAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\classextsnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#include "stdafx.h"

#include "ExtSnap.h"
#include "ClassExtSnap.h"
#include "Comp.h"
#include "DataObj.h"
#include "globals.h"
#include "resource.h"
#include "node1.h"

/////////////////////////////////////////////////////////////////////////////
// CClassExtSnap


//Here are the definitions for the clipboard formats that the
//CClassExtSnap needs to be aware of for extending Computer Management

#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")
#define _T_MMC_SNAPIN_MACHINE_NAME _T("MMC_SNAPIN_MACHINE_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")

UINT CClassExtSnap::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CClassExtSnap::s_cfMachineName = RegisterClipboardFormat (_T_MMC_SNAPIN_MACHINE_NAME);
UINT CClassExtSnap::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);

const GUID CClassExtSnap::structuuidNodetypeServerApps = { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };


HBITMAP CClassExtSnap::m_pBMapSm = NULL;
HBITMAP CClassExtSnap::m_pBMapLg = NULL;												

CClassExtSnap::CClassExtSnap()
: m_cref(0), bExpanded(FALSE), m_ipConsoleNameSpace2(NULL), m_ipConsole2(NULL)
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps();    
}

CClassExtSnap::~CClassExtSnap()
{
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CClassExtSnap::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (void **)&m_ipConsoleNameSpace2);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole2, (void **)&m_ipConsole2);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole2->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );
    
    hr = pImageList->ImageListSetStrip(	(long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
    _ASSERT( S_OK == hr );
    
    pImageList->Release();
    _ASSERT( S_OK == hr );

    return hr;
}

HRESULT CClassExtSnap::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CClassExtSnap::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
	MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

	HRESULT hr = S_FALSE;
   
	if (NULL == lpDataObject)
        return hr;

	switch (event)
	{
		case MMCN_EXPAND:
		{
           _TCHAR szMachineName[MAX_PATH]; //Current machine name.
                                           //Your child scope items should cache this
    
			GUID myGuid;
			// extract GUID of the the currently selected node type from the data object
			hr = ExtractObjectTypeGUID(lpDataObject, &myGuid);
			_ASSERT( S_OK == hr );    
			
			// compare node type GUIDs of currently selected node and the node type 
			// we want to extend. If they are are equal, currently selected node
			// is the type we want to extend, so we add our items underneath it
			if (IsEqualGUID(myGuid, getPrimaryNodeType()))
			{
			    //Get the current targeted machine's name using the MMC_SNAPIN_MACHINE_NAME 
				//clipboard format.
				//Note that each time the user retargets Computer Management, MMC will 
				//send the MMCN_EXPAND notification to the SAME IComponentData instance.
				//Therefore, szMachineName always hold the current machine name.
				hr = ExtractString(lpDataObject, s_cfMachineName, szMachineName, (MAX_PATH+1)*sizeof(WCHAR) );
				hr = CreateChildNode(m_ipConsoleNameSpace2, m_ipConsole2, (HSCOPEITEM)param, szMachineName);
			}

			else
			// currently selected node is one of ours instead
			{
				CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();					
				hr = base->OnExpand(m_ipConsoleNameSpace2, m_ipConsole2, (HSCOPEITEM)param);
			}

			break;
		}
		case MMCN_REMOVE_CHILDREN:
			
			for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
				if (children[n]) {
				delete children[n];
                children[n] = NULL;
			}
			
			hr = S_OK;
			break;
	}	
	
    return hr;
}

HRESULT CClassExtSnap::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace2) {
        m_ipConsoleNameSpace2->Release();
        m_ipConsoleNameSpace2 = NULL;
    }

    if (m_ipConsole2) {
        m_ipConsole2->Release();
        m_ipConsole2 = NULL;
    }

    return S_OK;
}

HRESULT CClassExtSnap::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

	//cookie always != 0 for namespace extensions)
    //if (cookie == 0) //static node
    //    pObj = new CDataObject((MMC_COOKIE)this, type);
    //else
		pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CClassExtSnap::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
	LPOLESTR pszW = NULL;
	HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {

            LPCTSTR pszT = base->GetDisplayName();    
			AllocOleStr(&pszW, (LPTSTR)pszT);		
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT CClassExtSnap::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}


///////////////////////////////
// CClassExtSnap::CreateChildNode
///////////////////////////////

HRESULT CClassExtSnap::CreateChildNode(IConsoleNameSpace *pConsoleNameSpace, 
                                IConsole *pConsole, HSCOPEITEM parent, _TCHAR *pszMachineName)
{	
	_ASSERT(NULL != pszMachineName);
       
    if (!bExpanded) {

       //first create the CNode1 objects, one for each inserted item
        for (int i = 0; i < NUMBER_OF_CHILDREN; i++) {
            children[i] = new CNode1(i + 1, pszMachineName);
        }  	

	    //now fill an SCOPEDATAITEM for each item and then insert it
	    SCOPEDATAITEM sdi;

        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR   |   // Displayname is valid
                SDI_PARAM	     |   // lParam is valid
                SDI_IMAGE        |   // nImage is valid
                SDI_OPENIMAGE    |   // nOpenImage is valid
                SDI_PARENT       |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

HRESULT CClassExtSnap::ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT CClassExtSnap::ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             _TCHAR       *pstr,
                                             DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT CClassExtSnap::ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT CClassExtSnap::ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

// CAbout.h : Declaration of the CAbout

#ifndef __ABOUT_H_
#define __ABOUT_H_

#include "resource.h"       // main symbols
#include "about.h"

#include <tchar.h>
#include <mmc.h>

/////////////////////////////////////////////////////////////////////////////
// CAbout
class ATL_NO_VTABLE CAbout : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAbout, &CLSID_About>,
	public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;

public:
    CAbout();
    ~CAbout();

DECLARE_REGISTRY_RESOURCEID(IDR_ABOUT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);        
};

#endif //__ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#include "stdafx.h"

#include "Comp.h"
#include "DataObj.h"
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "ClassExtSnap.h"

CComponent::CComponent(CClassExtSnap *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_ipDisplayHelp(NULL)
{
}

CComponent::~CComponent()
{
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

	//cookie always != 0 for namespace extensions)
    //if (cookie == 0) //static node
    //    pObj = new CDataObject((MMC_COOKIE)m_pComponentData, type);
    //else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
	LPOLESTR pszW = NULL;
	HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
            
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
			AllocOleStr(&pszW, (LPTSTR)pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\classextsnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

// ClassExtSnap.h : Declaration of the CClassExtSnap

#ifndef __CLASSEXTSNAP_H_
#define __CLASSEXTSNAP_H_


#include <mmc.h>
#include "ExtSnap.h"
#include "DeleBase.h"
#include <tchar.h>
#include <crtdbg.h>
#include "globals.h"		// main symbols
#include "resource.h"
#include "LocalRes.h"

/////////////////////////////////////////////////////////////////////////////
// CClassExtSnap
class ATL_NO_VTABLE CClassExtSnap : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CClassExtSnap, &CLSID_ClassExtSnap>,
	public IClassExtSnap, IComponentData//, IExtendContextMenu
{

friend class CComponent;

private:
    ULONG                m_cref;
    LPCONSOLE2           m_ipConsole2;
    LPCONSOLENAMESPACE2  m_ipConsoleNameSpace2;
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
    HRESULT ExtractString( IDataObject *piDataObject, CLIPFORMAT cfClipFormat, _TCHAR *pstr, DWORD cchMaxLength);
    HRESULT ExtractData( IDataObject* piDataObject, CLIPFORMAT cfClipFormat, BYTE* pbData, DWORD cbData );
       
    enum { NUMBER_OF_CHILDREN = 1 };
    CDelegationBase *children[1]; 

	// Clipboard formats needed for extending Computer Management
	static UINT s_cfMachineName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;

    // {476e6449-aaff-11d0-b944-00c04fd8d5b0}
    static const GUID structuuidNodetypeServerApps;

public:
	CClassExtSnap();
	~CClassExtSnap();

	const GUID & getPrimaryNodeType() { return structuuidNodetypeServerApps; }
    HRESULT CreateChildNode(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent, _TCHAR *pszMachineName);	

    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    


DECLARE_REGISTRY_RESOURCEID(IDR_CLASSEXTSNAP)
DECLARE_NOT_AGGREGATABLE(CClassExtSnap)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CClassExtSnap)
	COM_INTERFACE_ENTRY(IComponentData)
END_COM_MAP()

public:

    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
        /* [in] */ LPUNKNOWN pUnknown);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent(
    /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
    /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);

protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;

};

#endif //__CLASSEXTSNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;

	//The following clipboard formats are needed for allowing System Service Management 
	//Extension to extend Node1's context menu
	static UINT s_cfServiceName;
	static UINT s_cfServiceDisplayName;
	static UINT s_cfSnapinMachineName;
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>
#include "ClassExtSnap.h"

class CComponent : public IComponent
{
private:
    ULONG			m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    
    class CClassExtSnap *m_pComponentData;
    
    public:
        CComponent(CClassExtSnap *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;
#include "stdafx.h"
#include "DataObj.h"
#include "DeleBase.h"
#include "ExtSnap.h"
#include <stdio.h>

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

//Additional #defines needed for allowing our snap-in to be extended by
//System Service Management Extension

#define _T_FILEMGMT_SNAPIN_SERVICE_NAME _T("FILEMGMT_SNAPIN_SERVICE_NAME")
#define _T_FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME _T("FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME")
#define _T_CCF_SNAPIN_MACHINE_NAME _T("MMC_SNAPIN_MACHINE_NAME")


// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);

// Custom clipboard format only used within the snap-in
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);

//Additional formats needed for allowing our snap-in to be extended by
//System Service Management Extension
UINT CDataObject::s_cfServiceName = RegisterClipboardFormat(_T_FILEMGMT_SNAPIN_SERVICE_NAME);
UINT CDataObject::s_cfServiceDisplayName = RegisterClipboardFormat(_T_FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME);
UINT CDataObject::s_cfSnapinMachineName = RegisterClipboardFormat (_T_CCF_SNAPIN_MACHINE_NAME);



CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
	USES_CONVERSION;
    
	const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
		LPOLESTR wszName = NULL;

		const _TCHAR *pszName = base->GetDisplayName();
		wszName = (LPOLESTR)T2COLE(pszName);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
 
      // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlenW(szGuid);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, ulSizeofName, NULL);
            CoTaskMemFree(szGuid);
		}
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_ClassExtSnap;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
	
	} else if (cf == s_cfSnapinMachineName) {
		LPOLESTR wszName = NULL;

		const _TCHAR *pszName = base->GetMachineName();
		wszName = (LPOLESTR)T2COLE(pszName);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
	} else if (cf == s_cfServiceName) {
		LPOLESTR wszName = NULL;
		static _TCHAR buf[MAX_PATH];
    
	    _stprintf(buf, _T("Alerter")); //NOTE: Should be replaced with the real display name obtained from
 		                               //the Service Control Manager (SCM)

		wszName = (LPOLESTR)T2COLE(buf);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(buf);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
	} else if (cf == s_cfServiceDisplayName) {
		LPOLESTR wszName = NULL;
		static _TCHAR buf[MAX_PATH];
    
		_stprintf(buf, _T("Alerter"));
		wszName = (LPOLESTR)T2COLE(buf);

        // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(buf);
        ulSizeofName++;  // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\globals.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.

//==============================================================;

#include "stdafx.h"
#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

// this uses the ATL String Conversion Macros 
// for handling any necessary string conversion. Note that
// the snap-in (callee) allocates the necessary memory,
// and MMC (the caller) does the cleanup, as required by COM.
HRESULT AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	USES_CONVERSION;
 
	*lpDest = static_cast<LPOLESTR>(CoTaskMemAlloc((_tcslen(szBuffer) + 1) * 
									sizeof(WCHAR)));
	if (*lpDest == 0)
		return E_OUTOFMEMORY;
    
	LPOLESTR ptemp = T2OLE(szBuffer);
	
	wcscpy(*lpDest, ptemp);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\delebase.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#include "stdafx.h"

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0xc0f26ade, 0x500, 0x4c6c, {0xba, 0x7, 0x6d, 0xba, 0x25, 0x46, 0x55, 0x22} };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{
	if (NULL == m_pBMapSm || NULL == m_pBMapLg)
		LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\extsnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

// ExtSnap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ExtSnapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ExtSnap.h"

#include "ExtSnap_i.c"
#include "About.h"
#include "ClassExtSnap.h"

// our globals
HINSTANCE g_hinst;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_About, CAbout)
OBJECT_ENTRY(CLSID_ClassExtSnap, CClassExtSnap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hInstance;

		_Module.Init(ObjectMap, hInstance, &LIBID_EXTSNAPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\extsnap.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Dec 21 18:02:40 1999
 */
/* Compiler settings for D:\nt\mmc_atl\ExtSnap\ExtSnap.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ExtSnap_h__
#define __ExtSnap_h__

/* Forward Declarations */ 

#ifndef __IAbout_FWD_DEFINED__
#define __IAbout_FWD_DEFINED__
typedef interface IAbout IAbout;
#endif 	/* __IAbout_FWD_DEFINED__ */


#ifndef __IClassExtSnap_FWD_DEFINED__
#define __IClassExtSnap_FWD_DEFINED__
typedef interface IClassExtSnap IClassExtSnap;
#endif 	/* __IClassExtSnap_FWD_DEFINED__ */


#ifndef __About_FWD_DEFINED__
#define __About_FWD_DEFINED__

#ifdef __cplusplus
typedef class About About;
#else
typedef struct About About;
#endif /* __cplusplus */

#endif 	/* __About_FWD_DEFINED__ */


#ifndef __ClassExtSnap_FWD_DEFINED__
#define __ClassExtSnap_FWD_DEFINED__

#ifdef __cplusplus
typedef class ClassExtSnap ClassExtSnap;
#else
typedef struct ClassExtSnap ClassExtSnap;
#endif /* __cplusplus */

#endif 	/* __ClassExtSnap_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IAbout_INTERFACE_DEFINED__
#define __IAbout_INTERFACE_DEFINED__

/* interface IAbout */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3AC3AD56-7391-48A4-8837-60BCC3FB8D28")
    IAbout : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAbout __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAbout __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAbout __RPC_FAR * This);
        
        END_INTERFACE
    } IAboutVtbl;

    interface IAbout
    {
        CONST_VTBL struct IAboutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAbout_INTERFACE_DEFINED__ */


#ifndef __IClassExtSnap_INTERFACE_DEFINED__
#define __IClassExtSnap_INTERFACE_DEFINED__

/* interface IClassExtSnap */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IClassExtSnap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D44A9455-D873-48A9-A2A0-E55A8065B7EB")
    IClassExtSnap : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IClassExtSnapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClassExtSnap __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClassExtSnap __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClassExtSnap __RPC_FAR * This);
        
        END_INTERFACE
    } IClassExtSnapVtbl;

    interface IClassExtSnap
    {
        CONST_VTBL struct IClassExtSnapVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassExtSnap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassExtSnap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassExtSnap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IClassExtSnap_INTERFACE_DEFINED__ */



#ifndef __EXTSNAPLib_LIBRARY_DEFINED__
#define __EXTSNAPLib_LIBRARY_DEFINED__

/* library EXTSNAPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_EXTSNAPLib;

EXTERN_C const CLSID CLSID_About;

#ifdef __cplusplus

class DECLSPEC_UUID("4E7F429A-9A8A-4FA5-BBA0-10EB183898D1")
About;
#endif

EXTERN_C const CLSID CLSID_ClassExtSnap;

#ifdef __cplusplus

class DECLSPEC_UUID("3F40BB91-D7E4-4A37-9DE7-4D837B30F998")
ClassExtSnap;
#endif
#endif /* __EXTSNAPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

extern HINSTANCE g_hinst;

HRESULT	AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer);

// uncomment the following #define to enable message cracking
#define MMC_CRACK_MESSAGES
void MMCN_Crack(BOOL bComponentData, 
				IDataObject *pDataObject, 
				IComponentData *pCompData,
				IComponent *pComp,
				MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param);




#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\delebase.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;

    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

	_TCHAR m_szMachineName[MAX_PATH]; //Current machine name.

	_TCHAR* GetMachineName() { return m_szMachineName; }
    
protected:

    BOOL bExpanded;
	
	static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS)); }  

private:
    // {C0F26ADE-0500-4c6c-BA07-6DBA25465522}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\node1.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#include "stdafx.h"

#include <stdio.h>
#include "node1.h"


const GUID CNode1::thisGuid = { 0x28d4f536, 0xbdb5, 0x4bc5, {0xba, 0x88, 0x53, 0x75, 0xa4, 0x99, 0x68, 0x50} };

//==============================================================
//
// CNode1 implementation
//
//

CNode1::CNode1(int i,  const _TCHAR *pszName) : id(i)
{
	_tcscpy(m_szMachineName, pszName);
}

const _TCHAR *CNode1::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("MMC SDK Sample"));
    
    return buf;
}

HRESULT CNode1::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
	HRESULT hr;
	IUnknown *pUnk = NULL;
	IMessageView *pMessageView = NULL;

	hr = pConsole->QueryResultView(&pUnk);

	if (SUCCEEDED(hr)) {
		hr = pUnk->QueryInterface(IID_IMessageView, (void **)&pMessageView);

		if (SUCCEEDED(hr)) {
			pMessageView->SetIcon(Icon_Information);
			pMessageView->SetTitleText(L"ATL-based extension snap-in sample");
			pMessageView->SetBodyText(L"This sample allows you to start and stop the \n"
				L"Alerter service (if installed) on a local or remote machine.\n"
				L"\nTo modify the status of the service, use the context menu \n"
				L"of the 'MMC SDK Sample' node inserted by this sample.\n" 
				L"\nTo see the actual status of the service, go to the \n"
				L"Services and Applications->Services node.");

			pMessageView->Release();
		}

		pUnk->Release();
	}

	return S_FALSE;
}

HRESULT CNode1::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    // message view control
	LPOLESTR lpOleStr = NULL;
	HRESULT hr = StringFromCLSID(CLSID_MessageView, &lpOleStr);
    *ppViewType = lpOleStr;

	// don't just list view menu items
	*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS; 

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#include "stdafx.h"

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\node1.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//==============================================================;

#ifndef _NODE1_H
#define _NODE1_H

#include "DeleBase.h"

class CNode1 : public CDelegationBase {
public:
    CNode1(int i, const _TCHAR *pszName);
    virtual ~CNode1() {}
    
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
private:	

	// {28D4F536-BDB5-4bc5-BA88-5375A4996850}
    static const GUID thisGuid;
    int id;
};

#endif // _NODE1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ExtSnap.rc
//
#define IDS_HELPFILE                    1
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PROJNAME                    100
#define IDR_ABOUT                       102
#define IDR_CLASSEXTSNAP                103
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__726F2572_3B40_4CF8_886E_4939DD1E620E__INCLUDED_)
#define AFX_STDAFX_H__726F2572_3B40_4CF8_886E_4939DD1E620E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__726F2572_3B40_4CF8_886E_4939DD1E620E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\globals.cpp ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#include "stdafx.h"
#include "globals.h"

HRESULT ExtractData( 
                                       IDataObject* piDataObject,
                                      CLIPFORMAT   cfClipFormat,
                                      BYTE*        pbData,
                                      DWORD        cbData 
                                     )
{
    if ( piDataObject == NULL )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    
    FORMATETC formatetc =
    {
        cfClipFormat, 
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    STGMEDIUM stgmedium = 
    {
        TYMED_HGLOBAL,
        NULL
    };
    

    do // false loop
    {
        stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
        if ( NULL == stgmedium.hGlobal )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = (BYTE*)::GlobalLock(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }

        ::memcpy( pbData, pbNewData, cbData );
		::GlobalUnlock( stgmedium.hGlobal);

    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree( stgmedium.hGlobal );
    }

    return hr;
} // ExtractData()


HRESULT ExtractString(
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    WCHAR*       pstr,
    DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, 
                        (PBYTE)pstr, cchMaxLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\iissnapinext.cpp ===
// IISSnapinExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f IISSnapinExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "IISSnapinExt.h"

#include "IISSnapinExt_i.c"
#include "PropPageExt.h"
#include "MenuExt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PropPageExt, CPropPageExt)
OBJECT_ENTRY(CLSID_MenuExt, CMenuExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_IISSNAPINEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\globals.h ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#ifndef MMC_GLOBALS_H
#define MMC_GLOBALS_H

//
//Helper functions for extracting data from data objects 
//
HRESULT ExtractString( IDataObject *piDataObject, 
                       CLIPFORMAT cfClipFormat, 
                       WCHAR *pstr,
                       DWORD cchMaxLength );

HRESULT ExtractData( IDataObject* piDataObject,
                     CLIPFORMAT cfClipFormat, 
                     BYTE* pbData,
                     DWORD cbData );

#endif // MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\iissnapinext.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Tue Apr 04 16:49:24 2000
 */
/* Compiler settings for D:\nt\private\admin\bosrc\sources\atl_samp\IISSnapinExt\IISSnapinExt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __IISSnapinExt_h__
#define __IISSnapinExt_h__

/* Forward Declarations */ 

#ifndef __IPropPageExt_FWD_DEFINED__
#define __IPropPageExt_FWD_DEFINED__
typedef interface IPropPageExt IPropPageExt;
#endif 	/* __IPropPageExt_FWD_DEFINED__ */


#ifndef __IMenuExt_FWD_DEFINED__
#define __IMenuExt_FWD_DEFINED__
typedef interface IMenuExt IMenuExt;
#endif 	/* __IMenuExt_FWD_DEFINED__ */


#ifndef __PropPageExt_FWD_DEFINED__
#define __PropPageExt_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropPageExt PropPageExt;
#else
typedef struct PropPageExt PropPageExt;
#endif /* __cplusplus */

#endif 	/* __PropPageExt_FWD_DEFINED__ */


#ifndef __MenuExt_FWD_DEFINED__
#define __MenuExt_FWD_DEFINED__

#ifdef __cplusplus
typedef class MenuExt MenuExt;
#else
typedef struct MenuExt MenuExt;
#endif /* __cplusplus */

#endif 	/* __MenuExt_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IPropPageExt_INTERFACE_DEFINED__
#define __IPropPageExt_INTERFACE_DEFINED__

/* interface IPropPageExt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropPageExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1E514B4-AD1D-4F68-B8BD-F4205DBC6708")
    IPropPageExt : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IPropPageExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropPageExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropPageExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropPageExt __RPC_FAR * This);
        
        END_INTERFACE
    } IPropPageExtVtbl;

    interface IPropPageExt
    {
        CONST_VTBL struct IPropPageExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropPageExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropPageExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropPageExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropPageExt_INTERFACE_DEFINED__ */


#ifndef __IMenuExt_INTERFACE_DEFINED__
#define __IMenuExt_INTERFACE_DEFINED__

/* interface IMenuExt */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMenuExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BA9FCDE1-5F70-4F7B-AA5A-7B77753888C0")
    IMenuExt : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMenuExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMenuExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMenuExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMenuExt __RPC_FAR * This);
        
        END_INTERFACE
    } IMenuExtVtbl;

    interface IMenuExt
    {
        CONST_VTBL struct IMenuExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMenuExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMenuExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuExt_INTERFACE_DEFINED__ */



#ifndef __IISSNAPINEXTLib_LIBRARY_DEFINED__
#define __IISSNAPINEXTLib_LIBRARY_DEFINED__

/* library IISSNAPINEXTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_IISSNAPINEXTLib;

EXTERN_C const CLSID CLSID_PropPageExt;

#ifdef __cplusplus

class DECLSPEC_UUID("9727974C-8212-4C1C-AB7A-6F75109CCD2E")
PropPageExt;
#endif

EXTERN_C const CLSID CLSID_MenuExt;

#ifdef __cplusplus

class DECLSPEC_UUID("31F7EC8B-1472-4B3F-9539-6AAB9CDA283D")
MenuExt;
#endif
#endif /* __IISSNAPINEXTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\menuext.cpp ===
// MenuExt.cpp : Implementation of CIISSnapinExtApp and DLL registration.

#include "stdafx.h"
#include "IISSnapinExt.h"

EXTERN_C const CLSID CLSID_MenuExt;

#include "MenuExt.h"
#include "globals.h"


///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CMenuExt::AddMenuItems( 
								/* [in] */ LPDATAOBJECT piDataObject,
								/* [in] */ LPCONTEXTMENUCALLBACK piCallback,
								/* [out][in] */ long *pInsertionAllowed)
{
	HRESULT hr = S_FALSE;
    
	if (NULL == piDataObject)
        return hr;

    CONTEXTMENUITEM menuItemsTask[] =
    {
        {
            L"IIS Snap-in Extension Sample Menu Item", L"Inserted by IISSnapinExt.dll sample snap-in",
                1, CCM_INSERTIONPOINTID_3RDPARTY_TASK  , 0, 0
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        for (CONTEXTMENUITEM *m = menuItemsTask; m->strName; m++)
        {
            hr = piCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
 
    return hr;
    
}

HRESULT CMenuExt::Command( 
                           /* [in] */ long lCommandID,
                           /* [in] */ LPDATAOBJECT piDataObject)
{
	HRESULT hr = S_FALSE;
    
	if (NULL == piDataObject)
        return hr;
    
    switch (lCommandID)
    {
    case 1:
        ::MessageBox(NULL, _T("IIS snap-in context menu extension sample"), _T("Message from IISSnapinExt.dll"), MB_OK|MB_ICONEXCLAMATION);
        break;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\proppageext.cpp ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#include "stdafx.h"

#include "IISSnapinExt.h"
EXTERN_C const CLSID CLSID_PropPageExt;

#include "PropPageExt.h"
#include "globals.h"
#include "resource.h"
//
//Register clipboard formats needed for extending IIS
//
CLIPFORMAT CPropPageExt::cfSnapinMachineName = (CLIPFORMAT)RegisterClipboardFormat(
    L"ISM_SNAPIN_MACHINE_NAME" );

CLIPFORMAT CPropPageExt::cfSnapinService = (CLIPFORMAT)RegisterClipboardFormat(
    L"ISM_SNAPIN_SERVICE" );

CLIPFORMAT CPropPageExt::cfSnapinInstance = (CLIPFORMAT)RegisterClipboardFormat(
    L"ISM_SNAPIN_INSTANCE" );

CLIPFORMAT CPropPageExt::cfSnapinParentPath = (CLIPFORMAT)RegisterClipboardFormat(
    L"ISM_SNAPIN_PARENT_PATH" );

CLIPFORMAT CPropPageExt::cfSnapinNode = (CLIPFORMAT)RegisterClipboardFormat(
    L"ISM_SNAPIN_NODE" );

CLIPFORMAT CPropPageExt::cfSnapinMetaPath = (CLIPFORMAT)RegisterClipboardFormat(
    L"ISM_SNAPIN_META_PATH" );


//
// Interface IExtendPropertySheet
//

HRESULT CPropPageExt::CreatePropertyPages( 
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject
    )
{
    HRESULT hr = S_OK;

    //
    // Extract data from the data object passed to us from the currently
    // selected item in the IIS snap-in
    //
    hr = ExtractDataFromIIS(lpIDataObject);


    //
    // Create a property sheet page object from a dialog box.
    //
    // We store a pointer to our class in the psp.lParam, so we
    // can access our class members from within the dialog procedure.
    //

    PROPSHEETPAGE psp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = _Module.GetModuleInstance();
    psp.pszTemplate = MAKEINTRESOURCE( IDD_EXTENSIONPAGEGEN );
    psp.pfnDlgProc  = ExtensionPageDlgProc;
    psp.lParam = reinterpret_cast<LPARAM>( this );
    psp.pszTitle = MAKEINTRESOURCE(IDS_PROPPAGE_TITLE);
    
    HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&psp);
    if ( hPage == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = lpProvider->AddPage(hPage);
    if ( FAILED(hr) )
    {
        return hr;
    }

    return hr;

}

HRESULT CPropPageExt::QueryPagesFor( 
    /* [in] */ LPDATAOBJECT lpDataObject
    )
{
    return S_OK;
}

BOOL CALLBACK CPropPageExt::ExtensionPageDlgProc(
    HWND hDlg, 
    UINT uMessage, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    static CPropPageExt *pThis = NULL;
    LPOLESTR pszCLSID = NULL;
    
    switch (uMessage)
    {             
    case WM_INITDIALOG:
        pThis = reinterpret_cast<CPropPageExt *>(
            reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam );

        //
        // Display values retrieved from using the IIS-supported
        // clipboard formats.
        //

        SetWindowText( GetDlgItem( hDlg, IDC_EDITMACHINENAME),
                       pThis->m_szMachineName );

        SetWindowText( GetDlgItem( hDlg,  IDC_EDITSERVICE),
                       pThis->m_szService );
        
        SetWindowText( GetDlgItem( hDlg, IDC_EDITINSTANCE),
                       pThis-> m_szInstance );
               
        SetWindowText( GetDlgItem( hDlg, IDC_EDITPARENTPATH),
                       pThis-> m_szParentPath );
        
        SetWindowText( GetDlgItem( hDlg, IDC_EDITNODE),
                       pThis-> m_szNode );

        SetWindowText( GetDlgItem( hDlg, IDC_EDITMETAPATH),
                       pThis-> m_szMetaPath );


        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return TRUE;
            
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
        break;
    } 
 
    return TRUE;
} 

HRESULT CPropPageExt::ExtractDataFromIIS(IDataObject* lpIDataObject)
{
    //
    // Retrieve Snapin machine name
    //

    HRESULT hr = S_OK;

    WCHAR buf[MAX_PATH+1];

    hr = ExtractString( lpIDataObject,
                        cfSnapinMachineName,
                        buf, 
                        (DNS_MAX_NAME_LENGTH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }

    wcscpy( m_szMachineName, buf );

    //
    // Retrieve Snapin service
    //    

    hr = ExtractString( lpIDataObject,
                        cfSnapinService,
                        buf, 
                        (MAX_PATH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    wcscpy( m_szService, buf );

    //
    // Retrieve Snapin instance
    //    

    hr = ExtractString( lpIDataObject,
                        cfSnapinInstance,
                        buf, 
                        (MAX_PATH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }

    wcscpy( m_szInstance, buf );

    //
    // Retrieve Snapin parent path
    //    

    hr = ExtractString( lpIDataObject,
                        cfSnapinParentPath,
                        buf, 
                        (MAX_PATH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }

    wcscpy( m_szParentPath, buf );

    //
    // Retrieve Snapin node
    //    

    hr = ExtractString( lpIDataObject,
                        cfSnapinNode,
                        buf, 
                        (MAX_PATH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }

    wcscpy( m_szNode, buf );

    //
    // Retrieve Snapin meta path
    //    

    hr = ExtractString( lpIDataObject,
                        cfSnapinMetaPath,
                        buf, 
                        (MAX_PATH + 1)*sizeof(WCHAR) );
    if ( FAILED(hr) )
    {
        return hr;
    }

    wcscpy( m_szMetaPath, buf );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\menuext.h ===
// MenuExt.h: Definition of the CMenuExt class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MENUEXT_H__CB3F876D_9584_49A1_9914_3B7667C45C62__INCLUDED_)
#define AFX_MENUEXT_H__CB3F876D_9584_49A1_9914_3B7667C45C62__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <mmc.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMenuExt
class ATL_NO_VTABLE CMenuExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMenuExt, &CLSID_MenuExt>,
	public IMenuExt, 
	public IExtendContextMenu
{
public:
	CMenuExt()
	{
	}

	DECLARE_REGISTRY_RESOURCEID(IDR_MENUEXT)
	DECLARE_NOT_AGGREGATABLE(CMenuExt)

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMenuExt)
		COM_INTERFACE_ENTRY(IExtendContextMenu)
	END_COM_MAP()

public:
	///////////////////////////////
	// Interface IExtendContextMenu
	///////////////////////////////
	virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);
};

#endif // !defined(AFX_MENUEXT_H__CB3F876D_9584_49A1_9914_3B7667C45C62__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\proppageext.h ===
//=============================================================================
//
//  This source code is only intended as a supplement to existing Microsoft 
//  documentation. 
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//=============================================================================

#ifndef PROPPAGEEXT_H
#define PROPPAGEEXT_H

#include "resource.h"
#include "mmc.h"
#include "windns.h"

class ATL_NO_VTABLE CPropPageExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropPageExt, &CLSID_PropPageExt>,
	public IPropPageExt,
	public IExtendPropertySheet
{
    BEGIN_COM_MAP(CPropPageExt)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
    END_COM_MAP()

public:

	CPropPageExt() {}

	DECLARE_REGISTRY_RESOURCEID(IDR_PROPPAGEEXT)

	DECLARE_NOT_AGGREGATABLE(CPropPageExt)

	DECLARE_PROTECT_FINAL_CONSTRUCT()


    //
    // Interface IExtendPropertySheet
    //

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);

private:

	static BOOL CALLBACK ExtensionPageDlgProc( HWND hDlg, 
                                               UINT uMessage, 
                                               WPARAM wParam, 
                                               LPARAM lParam);

	HRESULT ExtractDataFromIIS(IDataObject* lpIDataObject);


	WCHAR m_szMachineName[DNS_MAX_NAME_LENGTH +1];	//Snapin machine name
	WCHAR m_szService[MAX_PATH+1];		//Snapin service
	WCHAR m_szInstance[MAX_PATH+1];		//Snapin instance
	WCHAR m_szParentPath[MAX_PATH+1];	//Snapin parent path
	WCHAR m_szNode[MAX_PATH+1];			//Snapin node
	WCHAR m_szMetaPath[MAX_PATH+1];		//Snapin meta path

	//Clipboard formats needed for extending IIS Snap-in
	static CLIPFORMAT cfSnapinMachineName;
	static CLIPFORMAT cfSnapinService;
	static CLIPFORMAT cfSnapinInstance;
	static CLIPFORMAT cfSnapinParentPath;
	static CLIPFORMAT cfSnapinNode;
	static CLIPFORMAT cfSnapinMetaPath;


};

#endif //PROPPAGEEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IISSnapinExt.rc
//
#define IDS_PROJNAME                    100
#define IDR_PROPPAGEEXT                 101
#define IDS_MYCOMPUTER                  101
#define IDS_PROPPAGE_TITLE              102
#define IDR_MENUEXT                     103
#define IDD_EXTENSIONPAGEGEN            107
#define IDC_EDITMACHINENAME             201
#define IDC_MACHINENAME                 202
#define IDC_SERVICE                     203
#define IDC_EDITSERVICE                 204
#define IDC_INSTANCE                    205
#define IDC_EDITINSTANCE                206
#define IDC_PARENTPATH                  207
#define IDC_EDITPARENTPATH              208
#define IDC_NODE                        209
#define IDC_EDITNODE                    210
#define IDC_METAPATH                    211
#define IDC_EDITMETAPATH                212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\iissnapinext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__442EBC6F_B6DC_4446_B84C_CFC2CC0B4D35__INCLUDED_)
#define AFX_STDAFX_H__442EBC6F_B6DC_4446_B84C_CFC2CC0B4D35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__442EBC6F_B6DC_4446_B84C_CFC2CC0B4D35__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendContextMenu
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            ///////////////////////////////
            // Interface IExtendContextMenu
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_ipDisplayHelp(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
        *ppv = static_cast<IExtendContextMenu *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_CONTEXTHELP:
        hr = base->OnShowContextHelp(m_ipDisplayHelp, m_pComponentData->m_HelpFile);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
            LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
            MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponent::AddMenuItems(
                                 /* [in] */ LPDATAOBJECT piDataObject,
                                 /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                 /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnAddMenuItems(piCallback, pInsertionAllowed);
}

HRESULT CComponent::Command(
                            /* [in] */ long lCommandID,
                            /* [in] */ LPDATAOBJECT piDataObject)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnMenuCommand(m_ipConsole, lCommandID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

    m_pStaticNode = new CStaticNode;

    TCHAR tmpHelpFile[MAX_PATH];

    GetWindowsDirectory(tmpHelpFile, sizeof(tmpHelpFile));
    _tcscat(tmpHelpFile, _T("\\HELP\\"));
    LoadString(g_hinst, IDS_HELPFILE, &tmpHelpFile[_tcslen(tmpHelpFile)], MAX_PATH - _tcslen(tmpHelpFile));

    MAKE_WIDEPTR_FROMTSTR(wszHelpFile, tmpHelpFile);
    wcscpy(m_HelpFile, wszHelpFile);
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
        *ppv = static_cast<IExtendContextMenu *>(this);
    else if (IsEqualIID(riid, IID_ISnapinHelp))
        *ppv = static_cast<ISnapinHelp*>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();


    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
            LPCTSTR pszT = base->GetDisplayName();
            MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic(
                                     /* [out] */ LPOLESTR *lpCompiledHelpFile)
{
    *lpCompiledHelpFile = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(m_HelpFile) + 1) * sizeof(WCHAR)));

    wcscpy(*lpCompiledHelpFile, m_HelpFile);

    return S_OK;
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponentData::AddMenuItems(
                                     /* [in] */ LPDATAOBJECT piDataObject,
                                     /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                     /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnAddMenuItems(piCallback, pInsertionAllowed);
}

HRESULT CComponentData::Command(
                                /* [in] */ long lCommandID,
                                /* [in] */ LPDATAOBJECT piDataObject)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnMenuCommand(m_ipConsole, lCommandID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
IExtendContextMenu,
ISnapinHelp
{
    friend class CComponent;

private:
    ULONG                               m_cref;
    LPCONSOLE                   m_ipConsole;
    LPCONSOLENAMESPACE  m_ipConsoleNameSpace;

    CStaticNode     *m_pStaticNode;

    WCHAR            m_HelpFile[MAX_PATH];

public:
    CComponentData();
    ~CComponentData();

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize(
        /* [in] */ LPUNKNOWN pUnknown);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent(
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify(
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject(
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo(
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects(
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface ISnapinHelp
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic(
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);

        ///////////////////////////////
        // Interface IExtendContextMenu
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile) { return S_FALSE; }
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {B5982EC8-8971-11d2-8A09-000021473128}
DEFINE_GUID(CLSID_CComponentData, 
            0xb5982ec8, 0x8971, 0x11d2, 0x8a, 0x9, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);

// {B5982ECA-8971-11d2-8A09-000021473128}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xb5982eca, 0x8971, 0x11d2, 0x8a, 0x9, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
HRESULT CLandBasedVehicle::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            L"Land based", L"Add a new land based vehicle",
                IDM_NEW_LAND, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        for (LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
}

HRESULT CLandBasedVehicle::OnMenuCommand(IConsole *pConsole, long lCommandID)
{
    switch (lCommandID)
    {
    case IDM_NEW_LAND:
        pConsole->MessageBox(L"This sample does not create a new item\nSee Complete sample for a demonstration", L"Menu Command", MB_OK|MB_ICONINFORMATION, NULL);
        break;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID);
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\people.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle() 
{ 
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle() 
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Bicycle #%d"), id);
    
    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Skateboard #%d"), id);
    
    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Ice Skate #%d"), id);
    
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_SMOPEN                      124
#define IDB_SMBMP                       125
#define IDB_LGBMP                       126
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTON40016                  40016
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTON40022                  40022
#define ID_BUTTON40023                  40023
#define ID_BUTTON40024                  40024
#define ID_BUTTON40025                  40025
#define ID_BUTTON40026                  40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
HRESULT CSkyBasedVehicle::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            L"Sky based", L"Add a new sky based vehicle",
                IDM_NEW_SKY, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        for (LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
}

HRESULT CSkyBasedVehicle::OnMenuCommand(IConsole *pConsole, long lCommandID)
{
    switch (lCommandID)
    {
    case IDM_NEW_SKY:
        pConsole->MessageBox(L"This sample does not create a new item\nSee Complete sample for a demonstration", L"Menu Command", MB_OK|MB_ICONINFORMATION, NULL);
        break;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\space.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Space.h"
#include "Comp.h"
#include <stdio.h>

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket();
        children[n]->Initialize(_T("Vehicle"), 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

HRESULT CSpaceVehicle::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            L"Space based", L"Add a new space based vehicle",
                IDM_NEW_SPACE, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        for (LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
}

HRESULT CSpaceVehicle::OnMenuCommand(IConsole *pConsole, long lCommandID)
{
    switch (lCommandID)
    {
    case IDM_NEW_SPACE:
        pConsole->MessageBox(L"This sample does not create a new item\nSee Complete sample for a demonstration", L"Menu Command", MB_OK|MB_ICONINFORMATION, NULL);
        break;
    }
    
    return S_OK;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket() 
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{ 
}

CRocket::~CRocket() 
{
    if (szName)
        delete [] szName;
}

void CRocket::Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload)
{
    if (szName) {
        this->szName = new _TCHAR[_tcslen(szName) + 1];
        _tcscpy(this->szName, szName);
    }
    
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

const _TCHAR *CRocket::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    switch (nCol) {
    case 0:
        _tcscpy(buf, szName ? szName : _T(""));
        break;
        
    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;
        
    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;
        
    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;
        
    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") : 
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;
        
    }
    
    return buf;
}

HRESULT CRocket::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsTask[] =
    {
        {
            L"Start vehicle", L"Start the space vehicle",
                IDM_START_SPACE, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        {
            L"Pause vehicle", L"Pause the space vehicle",
                IDM_PAUSE_SPACE, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        {
            L"Stop vehicle", L"Stop the space vehicle",
                IDM_STOP_SPACE, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, 0
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        for (LPCONTEXTMENUITEM m = menuItemsTask; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
}

HRESULT CRocket::OnMenuCommand(IConsole *pConsole, long lCommandID)
{
    _TCHAR szVehicle[128];
    
    switch (lCommandID) {
    case IDM_START_SPACE:
        iStatus = RUNNING;
        break;
        
    case IDM_PAUSE_SPACE:
        iStatus = PAUSED;
        break;
        
    case IDM_STOP_SPACE:
        iStatus = STOPPED;
        break;
    }
    
    _stprintf(szVehicle, _T("%s has been %s"), szName, 
        (long)iStatus == RUNNING ? _T("started") : 
    (long)iStatus == PAUSED ? _T("paused") :
    (long)iStatus == STOPPED ? _T("stopped") : _T("!!!unknown command!!!"));
    
    MAKE_WIDEPTR_FROMTSTR(ptrname, szVehicle);
    int ret = 0;
    pConsole->MessageBox(ptrname,
        L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID);
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };


//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
        
        bExpanded = TRUE;
    }
    
    return S_OK;
}

HRESULT CStaticNode::OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile)
{ 
    WCHAR topicName[MAX_PATH];
    
    wcscpy(topicName, helpFile);
    
    // we should read this from a resource file
    wcscat(topicName, L"::/default.htm");
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(topicName) + 1) * sizeof(WCHAR)));
    
    wcscpy(pszTopic, topicName);
    
    return m_ipDisplayHelp->ShowTopic(pszTopic);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"
#include "CompData.h"

class CRocket : public CDelegationBase {
public:
    CRocket();
    
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID);
    
    void Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
    enum { IDM_START_SPACE = 100, IDM_PAUSE_SPACE, IDM_STOP_SPACE };
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, long lCommandID);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenu\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\cmenuext.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _CContextMenuExtension_H_
#define _CContextMenuExtension_H_

#include <tchar.h>
#include <mmc.h>

class CContextMenuExtension : public IExtendContextMenu
{
    
private:
    ULONG				m_cref;
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
    HRESULT ExtractString( IDataObject *piDataObject,
        CLIPFORMAT   cfClipFormat,
        WCHAR        *pstr,
        DWORD        cchMaxLength);
    HRESULT ExtractData( IDataObject* piDataObject,
        CLIPFORMAT   cfClipFormat,
        BYTE*        pbData,
        DWORD        cbData );
    
    // clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    
public:
    CContextMenuExtension();
    ~CContextMenuExtension();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendContextMenu
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);
};

#endif _CContextMenuExtension_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\cmenuext.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "CMenuExt.h"
#include "globals.h"
#include "resource.h"
#include <crtdbg.h>

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons. We don't need any others at this time.
UINT CContextMenuExtension::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CContextMenuExtension::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CContextMenuExtension::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);

CContextMenuExtension::CContextMenuExtension() : m_cref(0)
{
    OBJECT_CREATED
}

CContextMenuExtension::~CContextMenuExtension()
{
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CContextMenuExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendContextMenu *>(this);
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
        *ppv = static_cast<IExtendContextMenu *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CContextMenuExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CContextMenuExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

HRESULT CContextMenuExtension::ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT CContextMenuExtension::ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             WCHAR        *pstr,
                                             DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT CContextMenuExtension::ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT CContextMenuExtension::ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CContextMenuExtension::AddMenuItems( 
                                            /* [in] */ LPDATAOBJECT piDataObject,
                                            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                            /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsTask[] =
    {
        {
            L"People Extension", L"Do an extension thing",
                1, CCM_INSERTIONPOINTID_3RDPARTY_TASK  , 0, 0
        },
        { NULL, NULL, 0, 0, 0 }
    };
    
    // Loop through and add each of the menu items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
    {
        for (CONTEXTMENUITEM *m = menuItemsTask; m->strName; m++)
        {
            hr = piCallback->AddItem(m);
            
            if (FAILED(hr))
                break;
        }
    }
    
    return hr;
    
}

HRESULT CContextMenuExtension::Command( 
                                       /* [in] */ long lCommandID,
                                       /* [in] */ LPDATAOBJECT piDataObject)
{
    WCHAR pszName[255];
    HRESULT hr = ExtractString(piDataObject, s_cfDisplayName, pszName, sizeof(pszName));
    MAKE_TSTRPTR_FROMWIDE(ptrname, pszName);
    
    if (SUCCEEDED(hr)) {
        switch (lCommandID)
        {
        case 1:
            ::MessageBox(NULL, ptrname, _T("Menu Command"), MB_OK|MB_ICONEXCLAMATION);
            break;
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {CONTEXTEXTENSION = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "globals.h"
#include "resource.h"
#include "guids.h"
#include "basesnap.h"
#include "CMenuExt.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CContextMenuExtension) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CContextMenuExtension)
        pFactory = new CClassFactory(CClassFactory::CONTEXTEXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (CONTEXTEXTENSION == m_factoryType) {
        pObj = new CContextMenuExtension();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CContextMenuExtension, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CContextMenuExtension, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CContextMenuExtension) == S_OK)
        return UnregisterSnapin(CLSID_CContextMenuExtension);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
	DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_SMOPEN                      124
#define IDB_SMBMP                       125
#define IDB_LGBMP                       126
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTON40016                  40016
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTON40022                  40022
#define ID_BUTTON40023                  40023
#define ID_BUTTON40024                  40024
#define ID_BUTTON40025                  40025
#define ID_BUTTON40026                  40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {CE0F5BF0-ABFB-11d2-993A-0080C76878BF}
DEFINE_GUID(CLSID_CContextMenuExtension, 
            0xce0f5bf0, 0xabfb, 0x11d2, 0x99, 0x3a, 0x0, 0x80, 0xc7, 0x68, 0x78, 0xbf);

// {CE0F5BF2-ABFB-11d2-993A-0080C76878BF}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xce0f5bf2, 0xabfb, 0x11d2, 0x99, 0x3a, 0x0, 0x80, 0xc7, 0x68, 0x78, 0xbf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cmenuext\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "Extend.h"
#include "globals.h"

// list all of the nodes that we extend
EXTENDER_NODE _NodeExtensions[] = {
    {ContextMenuExtension,
    {0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28}},
    {0xce0f5bf0, 0xabfb, 0x11d2, {0x99, 0x3a, 0x0, 0x80, 0xc7, 0x68, 0x78, 0xbf}},
    _T("Extension to the People-powered Node Context Menu")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

//            0xce0f5bf0, 0xabfb, 0x11d2, 0x99, 0x3a, 0x0, 0x80, 0xc7, 0x68, 0x78, 0xbf);
////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//

HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    LPOLESTR wszNodeCLSID = NULL;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;


    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {
        hr = StringFromCLSID(pNodeExtension->guidNode, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        _tcscat(szKeyBuf, pszExtendCLSID);

        switch (pNodeExtension->eType) {
        case ContextMenuExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ContextMenu"));
            break;
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        hr = StringFromCLSID(pNodeExtension->guidExtension, &wszNodeCLSID);
        assert(SUCCEEDED(hr));

        MAKE_TSTRPTR_FROMWIDE(pszNodeCLSID, wszNodeCLSID);
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, pszNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey) ;

        CoTaskMemFree(wszExtendCLSID);
        CoTaskMemFree(wszNodeCLSID);
    }


    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;

// list all nodes that are extendable here
// List the GUID and then the description
// terminate with a NULL, NULL set.
NODESTRUCT g_Nodes[] = {

    { 0xc094012c, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Snap-in Static Node")},

    { 0x96713509, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} ,
        _T("People-powered Vehicles Scope Item")},

    { 0x9671350a, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Bicyles Scope Item")},
		
    { 0x9671350b, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} ,
        _T("Skate Boards Scope Item")},

    { 0x9e3ff365, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} ,
        _T("Ice Skates Scope Item")},

    { 0x9e3ff366, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Bicyle Result Item")},

    { 0xa6707e01, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Skateboard Result Item")},

    { 0xa6707e02, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} ,
        _T("IceSkate Result Item")},

    {  0x8512760b, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Land-based Vehicles Scope Item")},

    { 0xb17867b9, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Sky-based Vehicles Scope Item")},

    { 0xb95e11f4, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9},
        _T("Future Vehicles Scope Item")},

    {  0xb95e11f5, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} ,
        _T("Rocket Result Item")},

    {NULL, NULL}
};



BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2, IExtendControlbar
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IControlbar*    m_ipControlBar;
    IToolbar*       m_ipToolbar;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);

            ///////////////////////////////
            // Interface IExtendControlBar
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);

    public:
        IToolbar *getToolbar() { return m_ipToolbar; }

};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"
#include "globals.h"


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
    m_ipControlBar  = NULL;
    m_ipToolbar     = NULL;
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendControlbar))
        *ppv = static_cast<IExtendControlbar *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

    // we need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
    if (MMCN_PROPERTY_CHANGE != event && MMCN_VIEW_CHANGE != event) {
        if (NULL == lpDataObject)
            return S_FALSE;

        base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    } else if (MMCN_PROPERTY_CHANGE == event) {
        base = (CDelegationBase *)param;
    }


	// MMCN_VIEW_CHANGE

	static CDelegationBase *pLastPasteQuery = NULL;

	if (MMCN_VIEW_CHANGE == event) {	

		switch (param) {//arg holds the data. For a scope item, this is the
						//item's myhscopeitem. For a result item, this is
						//the item's nId value, but we don't use it

						//param holds the hint passed to IConsole::UpdateAllViews.
					    //hint is a value of the UPDATE_VIEWS_HINT enumeration
		
		case UPDATE_SCOPEITEM:
			hr = m_ipConsole->SelectScopeItem( (HSCOPEITEM)arg );
			_ASSERT( S_OK == hr);
			break;
		case UPDATE_RESULTITEM:
			base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
			hr = base->OnUpdateItem(m_ipConsole, (long)arg, RESULT);
			break;
		}

		return S_OK;
	}


	//The remaining notifications

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(this, m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);

		//Now call IConsole::UpdateAllViews to redraw the item in all views.
		hr = m_pComponentData->m_ipConsole->UpdateAllViews(lpDataObject, 0, UPDATE_RESULTITEM);
		_ASSERT( S_OK == hr);		
		break;

	case MMCN_REFRESH:
		//we pass CComponentData's stored IConsole pointer here,
		//so that the IConsole::UpdateAllViews can be called in OnRefresh
		hr = base->OnRefresh(m_pComponentData->m_ipConsole);
		break;

	case MMCN_DELETE: {		
		//first delete the selected result item
		hr = base->OnDelete(m_ipConsole);

		//Now call IConsole::UpdateAllViews to redraw all views
		//owned by the parent scope item. OnRefresh already does
		//this for us, so use it.
		hr = base->OnRefresh(m_pComponentData->m_ipConsole);
		break;
	}

    // handle the property change notification if we need to do anything
    // special with it
    case MMCN_PROPERTY_CHANGE:
		//we pass CComponentData's stored IConsole pointer here,
		//so that the IConsole::UpdateAllViews can be called in OnPropertyChange
        hr = base->OnPropertyChange(m_pComponentData->m_ipConsole, this);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////
static MMCBUTTON SnapinButtons1[] =
{
    { 0, ID_BUTTONSTART, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Start Vehicle", L"Start Vehicle" },
    { 1, ID_BUTTONPAUSE, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Pause Vehicle", L"Pause Vehicle"},
    { 2, ID_BUTTONSTOP,  TBSTATE_ENABLED, TBSTYLE_GROUP, L"Stop Vehicle",  L"Stop Vehicle" },
};

HRESULT CComponent::SetControlbar(
                                  /* [in] */ LPCONTROLBAR pControlbar)
{
    HRESULT hr = S_OK;

    //
    //  Clean up
    //

    // if we've got a cached toolbar, release it
    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    // if we've got a cached control bar, release it
    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }


    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) {
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        hr = m_ipControlBar->Create(TOOLBAR,  // type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipToolbar));
        _ASSERT(SUCCEEDED(hr));

        // The IControlbar::Create AddRefs the toolbar object it created
        // so no need to do any addref on the interface.

        // add the bitmap to the toolbar
        HBITMAP hbmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_TOOLBAR1));
        hr = m_ipToolbar->AddBitmap(3, hbmp, 16, 16, RGB(0, 128, 128)); // NOTE, hardcoded value 3
        _ASSERT(SUCCEEDED(hr));

        // Add the buttons to the toolbar
        hr = m_ipToolbar->AddButtons(ARRAYLEN(SnapinButtons1), SnapinButtons1);
        _ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

HRESULT CComponent::ControlbarNotify(
                                     /* [in] */ MMC_NOTIFY_TYPE event,
                                     /* [in] */ LPARAM arg,
                                     /* [in] */ LPARAM param)
{
    HRESULT hr = S_OK;

    if (event == MMCN_SELECT) {
        BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);

        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(param))->GetBaseNodeObject();
        hr = base->OnSetToolbar(m_ipControlBar, m_ipToolbar, bScope, bSelect);
    } 
	
	else if (event == MMCN_BTN_CLICK) {
        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(arg))->GetBaseNodeObject();
        hr = base->OnToolbarCommand(m_pComponentData->m_ipConsole, (MMC_CONSOLE_VERB)param, reinterpret_cast<IDataObject *>(arg));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    // ditto for context menus
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
        *ppv = static_cast<IExtendContextMenu *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;

    case MMCN_DELETE:
        hr = S_FALSE;
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponentData::AddMenuItems(
                                     /* [in] */ LPDATAOBJECT piDataObject,
                                     /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                     /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnAddMenuItems(piCallback, pInsertionAllowed);
}

HRESULT CComponentData::Command(
                                /* [in] */ long lCommandID,
                                /* [in] */ LPDATAOBJECT piDataObject)
{
    CDelegationBase *base = GetOurDataObject(piDataObject)->GetBaseNodeObject();

    return base->OnMenuCommand(m_ipConsole, m_ipConsoleNameSpace, lCommandID, piDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, IExtendPropertySheet2, IExtendContextMenu
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);

        ///////////////////////////////
        // Interface IExtendContextMenu
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(
        /* [in] */ LPDATAOBJECT piDataObject,
        /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
        /* [out][in] */ long __RPC_FAR *pInsertionAllowed);

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(
        /* [in] */ long lCommandID,
        /* [in] */ LPDATAOBJECT piDataObject);

};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x786c6f77, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {786C6F77-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>, 
//0x786c6f77, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);



HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

#include <tchar.h>

struct NODESTRUCT
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\delebase.h ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponent;
class CComponentData;

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }

    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;

    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }

    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { _ASSERT(FALSE); }
    virtual HSCOPEITEM GetParentScopeItem() { _ASSERT(FALSE); return 0;}

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype) { return S_FALSE; }
    virtual HRESULT OnRefresh(IConsole *pConsole) { return S_FALSE; }
    virtual HRESULT     OnDelete(IConsole *pConsoleComp) { return S_FALSE; }

    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }

    virtual HRESULT OnPropertyChange(IConsole *pConsole, CComponent *pComponent) { return S_OK; }

    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed) { return S_FALSE; }
    virtual HRESULT OnMenuCommand(IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *piDataObject) { return S_FALSE; }

    virtual HRESULT OnToolbarCommand(IConsole *pConsole, MMC_CONSOLE_VERB verb, IDataObject *pDataObject) { return S_FALSE; }
    virtual HRESULT OnSetToolbar(IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect) { return S_FALSE; }

public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;

protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }

    BOOL bExpanded;

private:
    // {786C6F77-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;         

};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x8512760b, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };

// {8512760B-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>, 
//0x8512760b, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {CF03AC2A-6BE6-11d3-9156-00C04F65B3F9}
DEFINE_GUID(CLSID_CComponentData, 
0xcf03ac2a, 0x6be6, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


// {D740704B-6BE6-11d3-9156-00C04F65B3F9}
DEFINE_GUID(CLSID_CSnapinAbout, 
0xd740704b, 0x6be6, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\land.h ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }

    virtual ~CLandBasedVehicle() {}

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }

    virtual void SetScopeItemValue(LONG scopeitem) { m_hParentHScopeItem = scopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

private:
    enum { IDM_NEW_LAND = 2 };

    HSCOPEITEM m_hParentHScopeItem;

    // {8512760B-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <mmc.h>
#include <tchar.h>

#ifndef STRINGS_ONLY
		
		enum UPDATE_VIEWS_HINT {UPDATE_SCOPEITEM = 1000, DELETE_SCOPEITEM, UPDATE_RESULTITEM, DELETE_RESULTITEM}; 
		enum ITEM_TYPE {SCOPE = 10, RESULT}; 


        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);


#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x96713509, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {96713509-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0x96713509, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


const GUID CBicycleFolder::thisGuid = { 0x9671350a, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {9671350A-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0x9671350a, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


const GUID CSkateboardFolder::thisGuid = { 0x9671350b, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {9671350B-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0x9671350b, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);

const GUID CIceSkateFolder::thisGuid = { 0x9e3ff365, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {9E3FF365-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0x9e3ff365, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);

const GUID CBicycle::thisGuid = { 0x9e3ff366, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {9E3FF366-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0x9e3ff366, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


const GUID CSkateboard::thisGuid = { 0xa6707e01, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {A6707E01-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0xa6707e01, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


const GUID CIceSkate::thisGuid = { 0xa6707e02, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };
// {A6707E02-6BE7-11d3-9156-00C04F65B3F9}
//DEFINE_GUID(<<name>>,
//0xa6707e02, 0x6be7, 0x11d3, 0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );

            children[n]->SetScopeItemValue(sdi.ID);
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );
                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );
                _ASSERT( SUCCEEDED(hr) );
           }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );
                _ASSERT( SUCCEEDED(hr) );
           }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\people.h ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}

    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

private:
    // {9E3FF366-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;
        
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }
        
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);

private:
    // {9671350A-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    HSCOPEITEM m_hParentHScopeItem;

    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}

    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

private:
    // {A6707E01-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);

private:
    // {9671350B-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    HSCOPEITEM m_hParentHScopeItem;

    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}

    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

private:
    // {A6707E02-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);

private:
    // {9E3FF365-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    HSCOPEITEM m_hParentHScopeItem;

    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);

    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

private:
    enum { IDM_NEW_PEOPLE = 1 };

    // {96713509-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    HSCOPEITEM m_hParentHScopeItem;

        enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout);		// Class Id for About Class


HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDI_PSI_LANDBASED               2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDS_PST_LANDBASED               11
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDR_TOOLBAR1                    122
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTONSTART                  40021
#define ID_BUTTONPAUSE                  40022
#define ID_BUTTONSTOP                   40023


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>
#include "Extend.h"
#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

// we need access to our g_nodes
extern NODESTRUCT g_Nodes[];

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout)         // Class Id for About Class

{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    NODESTRUCT *pNode;

    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    // register each of the node types in g_Nodes as an extendable node
    for (pNode = &(g_Nodes[0]);*pNode->szDescription;pNode++)
    {
        hr = StringFromCLSID(pNode->GUID, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        setSnapInExtensionNode(pszCLSID, pszExtendCLSID, pNode->szDescription);
        CoTaskMemFree(wszExtendCLSID);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	//Uncomment following for loop to unregister all extendable node types
	//Note that if a snap-in's extendable node types are unregistered,
	//any extension snap-ins for these node types will have to be re-registered
	//in order to rebuild their entries under the SOFTWARE\Microsoft\MMC\NodeTypes key

/*
    // Unregister each of the node types in g_Nodes as an extendable node

    NODESTRUCT *pNode;
	LPOLESTR wszExtendCLSID = NULL;

    for (pNode = &(g_Nodes[0]);*pNode->szDescription;pNode++)
    {
        hr = StringFromCLSID(pNode->GUID, &wszExtendCLSID);
        // Load the buffer with the Snap-In Location
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        // Copy keyname into buffer.
        _tcscat(szKeyBuf, pszExtendCLSID);
        recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
        CoTaskMemFree(wszExtendCLSID);
    }
*/


    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription)
{
    HKEY hKey;
    _TCHAR szSnapNodeKeyBuf[1024] ;
    _TCHAR szMMCNodeKeyBuf[1024];

    // Load the buffer with the Snap-In Location
    _tcscpy(szSnapNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns\\"));
    // add in the clisid into buffer.
    _tcscat(szSnapNodeKeyBuf, szSnapID) ;
    _tcscat(szSnapNodeKeyBuf, _T("\\NodeTypes\\"));
    _tcscat(szSnapNodeKeyBuf, szNodeID) ;

    // Load the buffer with the NodeTypes Location
    _tcscpy(szMMCNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
    _tcscat(szMMCNodeKeyBuf, szNodeID) ;

    // Create and open the Snapin Key.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szSnapNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    // Create and open the NodeTypes Key.
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szMMCNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\sky.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0xb17867b9, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\sky.h ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }

    virtual ~CSkyBasedVehicle() {}

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }

    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

private:
    enum { IDM_NEW_SKY = 3 };

    HSCOPEITEM m_hParentHScopeItem;

    // {B17867B9-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "globals.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0xb95e11f4, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };

const GUID CRocket::thisGuid = { 0xb95e11f5, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };


//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle() : m_cchildren(NUMBER_OF_CHILDREN)
{
    for (int n = 0; n < m_cchildren; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000, this);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < m_cchildren; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
                
                hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < m_cchildren; n++)
            {
                BOOL childDeleteStatus = children[n]->getDeletedStatus();                               

                // If the child is deleted by the user do not insert it.
                if ( !childDeleteStatus)
                {
                    ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                    rdi.mask       = RDI_STR       |   // Displayname is valid
                        RDI_IMAGE     |
                        RDI_PARAM;        // nImage is valid

                    rdi.nImage      = children[n]->GetBitmapIndex();
                    rdi.str         = MMC_CALLBACK;
                    rdi.nCol        = 0;
                    rdi.lParam      = (LPARAM)children[n];

                    hr = pResultData->InsertItem( &rdi );
                    _ASSERT( SUCCEEDED(hr) );
                }
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}


HRESULT CSpaceVehicle::OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM menuItemsNew[] =
    {
        {
            L"New future vehicle", L"Add a new future vehicle",
            IDM_NEW_SPACE, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, CCM_SPECIAL_DEFAULT_ITEM
        },
        { NULL, NULL, 0, 0, 0 }
    };

    // Loop through and add each of the menu items, we
    // want to add to new menu, so see if it is allowed.
    if (*pInsertionsAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        for (LPCONTEXTMENUITEM m = menuItemsNew; m->strName; m++)
        {
            hr = pContextMenuCallback->AddItem(m);

            if (FAILED(hr))
                break;
        }
    }

    return hr;
}

HRESULT CSpaceVehicle::OnMenuCommand(IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *pDataObject)
{
    switch (lCommandID)
    {
    case IDM_NEW_SPACE:

        if (m_cchildren < MAX_NUMBER_OF_CHILDREN)
        {       //create new Rocket
            children[m_cchildren] = new CRocket(_T("Rocket"), m_cchildren+1, 500000, 265, 75000, this);

            pConsole->MessageBox(L"Created a new future vehicle", L"Menu Command", MB_OK|MB_ICONINFORMATION, NULL);

            m_cchildren++;      

            // We created a new object in result pane. We need to insert this object
            // in all the views, call UpdateAllViews for this.
            // Pass pointer to data object passed into OnMenuCommand.
            HRESULT hr;                 
            hr = pConsole->UpdateAllViews(pDataObject, m_hParentHScopeItem, UPDATE_SCOPEITEM);
            _ASSERT( S_OK == hr);

        }
        else
            pConsole->MessageBox(L"No more future vehicles allowed", L"Menu Command", MB_OK|MB_ICONWARNING, NULL);
        break;
    }

    return S_OK;
}


//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload, CSpaceVehicle *pParent)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED), m_pParent(pParent)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

    m_ppHandle = 0;

    isDeleted = FALSE;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{

    HRESULT hr = S_FALSE;

    if (szName)
    {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return hr;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special to do...
// ...except to update all views
HRESULT CRocket::OnPropertyChange(IConsole *pConsole, CComponent *pComponent)
{

    HRESULT hr = S_FALSE;

    //Call IConsole::UpdateAllViews to redraw the item
    //in all views. We need a data object because of the
    //way UpdateAllViews is implemented, and because
    //MMCN_PROPERTY_CHANGE doesn't give us one

    LPDATAOBJECT pDataObject;
    hr = pComponent->QueryDataObject((MMC_COOKIE)this, CCT_RESULT, &pDataObject );
    _ASSERT( S_OK == hr);       
        
    hr = pConsole->UpdateAllViews(pDataObject, nId, UPDATE_RESULTITEM);
    _ASSERT( S_OK == hr);

    pDataObject->Release();

    return hr;
}

HRESULT CRocket::OnSelect(CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect)
{

    // enable rename, refresh, and delete verbs
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);


    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this will give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    //also set MMC_VERB_PROPERTIES as the default verb
    hr = pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);

    pConsoleVerb->Release();

        // now set toolbar button states
    if (bSelect) {
        switch (iStatus)
        {
        case RUNNING:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
            break;

        case PAUSED:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
            break;

        case STOPPED:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
            break;
        }
    }

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        // catch the "this" pointer so we can actually operate on the object
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pRocket->m_ppHandle);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // update the information
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);

            // ask MMC to send us a message (on the main thread) so
            // we know the Apply button was clicked.
            HRESULT hr = MMCPropertyChangeNotify(pRocket->m_ppHandle, (long)pRocket);

            _ASSERT(SUCCEEDED(hr));

            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}


HRESULT CRocket::OnSetToolbar(IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect)
{
    HRESULT hr = S_OK;

    if (bSelect) {
        // Always make sure the menuButton is attached
        hr = pControlbar->Attach(TOOLBAR, pToolbar);
    } else {
        // Always make sure the toolbar is detached
        hr = pControlbar->Detach(pToolbar);
    }

    return hr;
}

HRESULT CRocket::OnToolbarCommand(IConsole *pConsole, MMC_CONSOLE_VERB verb, IDataObject *pDataObject)
{
    _TCHAR szVehicle[128];
    static _TCHAR buf[128];

    _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);

    switch (verb)
    {
    case ID_BUTTONSTART:
        iStatus = RUNNING;
        break;

    case ID_BUTTONPAUSE:
        iStatus = PAUSED;
        break;

    case ID_BUTTONSTOP:
        iStatus = STOPPED;
        break;
    }

    wsprintf(szVehicle, _T("%s has been %s"), buf,
        (long)verb == ID_BUTTONSTART ? _T("started") :
    (long)verb == ID_BUTTONPAUSE ? _T("paused") :
    (long)verb == ID_BUTTONSTOP ? _T("stopped") : _T("!!!unknown command!!!"));

    int ret = 0;
    MAKE_WIDEPTR_FROMTSTR_ALLOC(wszVehicle, szVehicle);
    pConsole->MessageBox(wszVehicle,
        L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);

    // Now call IConsole::UpdateAllViews to redraw the item in all views
    HRESULT hr;
    hr = pConsole->UpdateAllViews(pDataObject, nId, UPDATE_RESULTITEM);
    _ASSERT( S_OK == hr);


    return S_OK;
}

HRESULT CRocket::OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype)

{
    HRESULT hr = S_FALSE;

    _ASSERT(NULL != this || isDeleted || RESULT == itemtype);                   

    //redraw the item
    IResultData *pResultData = NULL;

    hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
    _ASSERT( SUCCEEDED(hr) );   

    HRESULTITEM myhresultitem;
    _ASSERT(NULL != &myhresultitem);    
        
    //lparam == this. See CSpaceStation::OnShow
    hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );

    if ( FAILED(hr) )
    {
        // Failed : Reason may be that current view does not have this item.
        // So exit gracefully.
        hr = S_FALSE;
    } else

    {
        hr = pResultData->UpdateItem( myhresultitem );
        _ASSERT( SUCCEEDED(hr) );
    }

    pResultData->Release();
        
    return hr;
}

HRESULT CRocket::OnRefresh(IConsole *pConsole)

{
    //Call IConsole::UpdateAllViews to redraw all views
    //owned by the parent scope item

    IDataObject *dummy = NULL;

    HRESULT hr;

    hr = pConsole->UpdateAllViews(dummy, m_pParent->GetParentScopeItem(), UPDATE_SCOPEITEM);
    _ASSERT( S_OK == hr);

    return hr;
}

HRESULT CRocket::OnDelete(IConsole *pConsoleComp)
{
    HRESULT hr;

    //Delete the item
    IResultData *pResultData = NULL;

    hr = pConsoleComp->QueryInterface(IID_IResultData, (void **)&pResultData);
    _ASSERT( SUCCEEDED(hr) );   

    HRESULTITEM myhresultitem;  
        
    //lparam == this. See CSpaceVehicle::OnShow
    hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );
    if ( FAILED(hr) )
    {
        // Failed : Reason may be that current view does not have this item.
        // So exit gracefully.
        hr = S_FALSE;
    } else

    {
        hr = pResultData->DeleteItem( myhresultitem, 0 );
        _ASSERT( SUCCEEDED(hr) );
    }
        
    pResultData->Release();

    //Now set isDeleted member so that the parent doesn't try to
    //to insert it again in CSpaceVehicle::OnShow. Admittedly, a hack...
    isDeleted = TRUE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\statnode.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0xc094012c, 0x6be7, 0x11d3, {0x91, 0x56, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9} };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{

    //cache static node's HSCOPEITEM for future use
    m_hParentHScopeItem = parent;

    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            _ASSERT( SUCCEEDED(hr) );
                        
            children[n]->SetScopeItemValue(sdi.ID);


        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\space.h ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "globals.h"
#include "DeleBase.h"

//forward declaration
class CSpaceVehicle;

class CRocket : public CDelegationBase {

public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload, CSpaceVehicle *pParent);
    virtual ~CRocket();

    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    BOOL getDeletedStatus() { return isDeleted; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(CComponent *pComponent, IConsole *pConsole, BOOL bScope, BOOL bSelect);

    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);

    virtual HRESULT OnPropertyChange(IConsole *pConsole, CComponent *pComponent);

    virtual HRESULT OnToolbarCommand(IConsole *pConsole, MMC_CONSOLE_VERB verb, IDataObject *pDataObject);
    virtual HRESULT OnSetToolbar(IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnUpdateItem(IConsole *pConsole, long item, ITEM_TYPE itemtype);
    virtual HRESULT OnRefresh(IConsole *pConsole);      
    virtual HRESULT OnDelete(IConsole *pConsoleComp);


private:
    // {B95E11F5-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;

    LONG_PTR m_ppHandle;

    static BOOL CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );

        CSpaceVehicle* m_pParent;

        BOOL isDeleted;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();

    virtual ~CSpaceVehicle();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }

    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddMenuItems(IContextMenuCallback *pContextMenuCallback, long *pInsertionsAllowed);
    virtual HRESULT OnMenuCommand(IConsole *pConsole, IConsoleNameSpace *pConsoleNameSpace, long lCommandID, IDataObject *piDataObject);

private:
    enum { IDM_NEW_SPACE = 4 };

    // {B95E11F4-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;

private:
    enum { NUMBER_OF_CHILDREN = 4 };
    enum { MAX_NUMBER_OF_CHILDREN = 6 };
    CRocket *children[MAX_NUMBER_OF_CHILDREN];
    int m_cchildren;
    HSCOPEITEM m_hParentHScopeItem;
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\complete\statnode.h ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();

    virtual ~CStaticNode();

    virtual const _TCHAR *GetDisplayName(int nCol = 0) {
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName;
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    virtual void SetScopeItemValue(HSCOPEITEM hscopeitem) { m_hParentHScopeItem = hscopeitem; }
    virtual HSCOPEITEM GetParentScopeItem() { return m_hParentHScopeItem; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);

private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];

    HSCOPEITEM m_hParentHScopeItem;

    // {C094012C-6BE7-11d3-9156-00C04F65B3F9}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\backgrnd.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Backgrnd.h"

const GUID CBackgroundFolder::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CBackground::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

#define WM_NEWOBJECT WM_APP
#define WM_DISCOVERYCOMPLETE (WM_APP + 1)

//==============================================================
//
// CBackgroundFolder implementation
//
//
CBackgroundFolder::CBackgroundFolder()
: m_pConsoleNameSpace(NULL), m_scopeitem(0), m_threadId(0), m_thread(NULL), 
m_running(false), m_bViewUpdated(false)
{
    ZeroMemory(m_children, sizeof(m_children));

    WNDCLASS wndClass;

    ZeroMemory(&wndClass, sizeof(WNDCLASS));

    wndClass.lpfnWndProc = WindowProc; 
    wndClass.lpszClassName = _T("backgroundthreadwindow"); 
    wndClass.hInstance = g_hinst;

    ATOM atom = RegisterClass(&wndClass);
    m_backgroundHwnd = CreateWindow(
            _T("backgroundthreadwindow"),  // pointer to registered class name
            NULL, // pointer to window name
            0,        // window style
            0,                // horizontal position of window
            0,                // vertical position of window
            0,           // window width
            0,          // window height
            NULL,      // handle to parent or owner window
            NULL,          // handle to menu or child-window identifier
            g_hinst,     // handle to application instance
            (void *)this        // pointer to window-creation data
        );

    if (m_backgroundHwnd)
        SetWindowLong(m_backgroundHwnd, GWL_USERDATA, (LONG)this);

    InitializeCriticalSection(&m_critSect);
}

CBackgroundFolder::~CBackgroundFolder()
{
    StopThread();

    for (int n = 0; n < MAX_CHILDREN; n++)
        if (m_children[n] != NULL)
            delete m_children[n];

    if (m_backgroundHwnd != NULL)
        DestroyWindow(m_backgroundHwnd);

    UnregisterClass(_T("backgroundthreadwindow"), NULL);

    DeleteCriticalSection(&m_critSect);
}

LRESULT CALLBACK CBackgroundFolder::WindowProc(
      HWND hwnd,      // handle to window
      UINT uMsg,      // message identifier
      WPARAM wParam,  // first message parameter
      LPARAM lParam   // second message parameter
    )
{
    CBackgroundFolder *pThis = (CBackgroundFolder *)GetWindowLong(hwnd, GWL_USERDATA);

    switch (uMsg) {
    case WM_NEWOBJECT:
        _ASSERT(pThis != NULL);
        pThis->AddItem(lParam);
        break;

    case WM_DISCOVERYCOMPLETE:
        _ASSERT(pThis != NULL);
        pThis->m_bViewUpdated = true;
        pThis->StopThread();
        break;
   }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

DWORD WINAPI CBackgroundFolder::ThreadProc(
  LPVOID lpParameter   // thread data
)
{
    CBackgroundFolder *pThis = (CBackgroundFolder *)lpParameter;

    EnterCriticalSection(&pThis->m_critSect);
    pThis->m_running = true;
    LeaveCriticalSection(&pThis->m_critSect);

    for (int n = 0; n < MAX_CHILDREN; n++) {
        EnterCriticalSection(&pThis->m_critSect);
        bool running = pThis->m_running;
        LeaveCriticalSection(&pThis->m_critSect);

        if (running == false)
            return 0;

        PostMessage(pThis->m_backgroundHwnd, WM_NEWOBJECT, 0, n);
        Sleep(500);
    }

    PostMessage(pThis->m_backgroundHwnd, WM_DISCOVERYCOMPLETE, 0, 0);

    return 0;
}

void CBackgroundFolder::StartThread()
{
    EnterCriticalSection(&m_critSect);
    m_thread = CreateThread(NULL, 0, ThreadProc, (void *)this, 0, &m_threadId);
    LeaveCriticalSection(&m_critSect);
}

void CBackgroundFolder::StopThread()
{
    EnterCriticalSection(&m_critSect);
    m_running = false;

    if (m_thread != NULL) {
        // this is ugly, wait for 10 seconds, then kill the thread
        DWORD res = WaitForSingleObject(m_thread, 10000);

        if (res == WAIT_TIMEOUT)
            TerminateThread(m_thread, 0);

        CloseHandle(m_thread);

        m_thread = NULL;
    }
    LeaveCriticalSection(&m_critSect);
}

void CBackgroundFolder::AddItem(int id)
{
    HRESULT hr;

    EnterCriticalSection(&m_critSect);

    _ASSERT(m_children[id] == NULL);

    m_children[id] = new CBackground(id);

    SCOPEDATAITEM sdi;

    // insert items here
    ZeroMemory(&sdi, sizeof(SCOPEDATAITEM));

    sdi.mask = SDI_STR       |   // Displayname is valid
        SDI_PARAM     |   // lParam is valid
        SDI_IMAGE     |   // nImage is valid
        SDI_OPENIMAGE |   // nOpenImage is valid
        SDI_PARENT    |
        SDI_CHILDREN;
    
    sdi.relativeID  = (HSCOPEITEM)m_scopeitem;
    sdi.nImage      = m_children[id]->GetBitmapIndex();
    sdi.nOpenImage  = INDEX_OPENFOLDER;
    sdi.displayname = MMC_CALLBACK;
    sdi.lParam      = (LPARAM)m_children[id];       // The cookie
    sdi.cChildren   = 0;

    hr = m_pConsoleNameSpace->InsertItem( &sdi );
    _ASSERT( SUCCEEDED(hr) );

    m_children[id]->SetHandle((HANDLE)sdi.ID);
    
    LeaveCriticalSection(&m_critSect);

    return;
}

HRESULT CBackgroundFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CBackgroundFolder::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    // cache the stuff
    m_pConsoleNameSpace = pConsoleNameSpace;
    m_scopeitem = parent;

    if (m_bViewUpdated == false && m_running == false)
        StartThread();

    return S_OK;
}

HRESULT CBackgroundFolder::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    m_bSelected = (bSelect && bScope) ? true : false;

    if (bSelect && !m_running) {
        IConsoleVerb *pConsoleVerb;
    
        HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
        _ASSERT(SUCCEEDED(hr));
    
        hr = pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
    
        pConsoleVerb->Release();
    }
    
    return S_OK;
}

HRESULT CBackgroundFolder::OnRefresh()
{
    HRESULT hr = S_OK;

    StopThread();

    EnterCriticalSection(&m_critSect);
    for (int n = 0; n < MAX_CHILDREN; n++) {
        if (m_children[n] != NULL) {
            HSCOPEITEM hItem = (HSCOPEITEM)m_children[n]->GetHandle();
            hr = m_pConsoleNameSpace->DeleteItem(hItem, TRUE);

            delete m_children[n];
            m_children[n] = NULL;
        }
    }
    LeaveCriticalSection(&m_critSect);

    m_bViewUpdated = false;

    StartThread();

    return S_OK;
}

const _TCHAR *CBackground::GetDisplayName(int nCol) 
{
    static _TCHAR buf[128];
    
    _stprintf(buf, _T("Background object #%d"), m_id);
    
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
//  
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\backgrnd.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BACKGROUND_H
#define _BACKGROUND_H

#include "DeleBase.h"

class CBackground : public CDelegationBase {
public:
    CBackground(int id) : m_itemId(NULL), m_id(id) { }
    virtual ~CBackground() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_BACKGROUND; }
    
private:
    enum { IDM_NEW_BACKGROUND = 6 };
    
    static const GUID thisGuid;
    int m_id;
    HSCOPEITEM m_itemId;
};

class CBackgroundFolder : public CDelegationBase {
public:
    CBackgroundFolder();
    virtual ~CBackgroundFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Background Objects"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_BACKGROUND; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRefresh();
   
private:
    enum { MAX_CHILDREN = 30 };

    CBackground *m_children[MAX_CHILDREN];

    HWND m_backgroundHwnd;
    
    static const GUID thisGuid;

    static LRESULT CALLBACK WindowProc(
          HWND hwnd,      // handle to window
          UINT uMsg,      // message identifier
          WPARAM wParam,  // first message parameter
          LPARAM lParam   // second message parameter
        );

    static DWORD WINAPI ThreadProc(
      LPVOID lpParameter   // thread data
    );

    DWORD m_threadId;
    HANDLE m_thread;
    bool m_running;

    IConsoleNameSpace *m_pConsoleNameSpace;
    HSCOPEITEM m_scopeitem;
    void AddItem(int id);

    CRITICAL_SECTION m_critSect;

    void StopThread();
    void StartThread();

    bool m_bSelected;
    bool m_bViewUpdated;
};


#endif // _BACKGROUND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "Space.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *pParent)
: m_pParent(pParent), m_cref(0), m_ipConsole(NULL), m_pLastNode(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IResultOwnerData))
        *ppv = static_cast<IResultOwnerData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                   /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

	//Return S_FALSE for any unhandled notifications. MMC then
	//performs a default operation for the particular notification
    HRESULT hr = S_FALSE;


    // MMCN_VIEW_CHANGE and MMCN_CUTORMOVE

    static CDelegationBase *pLastPasteQuery = NULL;

    if (MMCN_VIEW_CHANGE == event)
    {
        switch (param)
        {//arg holds the data. For a scope item, this is the
         //item's HSCOPEITEM. For a result item, this is
         //the item's nId value, but we don't use it

         //param holds the hint passed to IConsole::UpdateAllViews.
         //hint is a value of the UPDATE_VIEWS_HINT enumeration

        case UPDATE_SCOPEITEM:
            hr = m_ipConsole->SelectScopeItem( (HSCOPEITEM)arg );
            _ASSERT( S_OK == hr);
            break;
        case UPDATE_RESULTITEM:
            CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
            hr = base->OnUpdateItem(m_ipConsole, (long)arg, RESULT);
            break;
        }

        return S_OK;
    }

    if (MMCN_CUTORMOVE == event && pLastPasteQuery != NULL)
    {
        //arg contains the data object of the cut object
        //we get its CDelegationBase and then cast it
        //to its proper type.
        CDelegationBase *base = GetOurDataObject( (LPDATAOBJECT)arg )->GetBaseNodeObject();
        CRocket *pRocket = dynamic_cast<CRocket *>(base);

        if (NULL == pRocket)
        {// The cut item is a scope item. Delete it.
            CSpaceStation* pSpaceStn = dynamic_cast<CSpaceStation*>(base);
            if (NULL != pSpaceStn)
            {
				hr = pSpaceStn->OnDeleteScopeItem(m_pParent->GetConsoleNameSpace());

                return hr;
            }
        }
		
		//The cut item is a result item. Set its isDeleted member to TRUE.
		//This tells the source scope item that the object no longer
        //needs to be inserted in its result pane
        pRocket->setDeletedStatus(TRUE);

        //Update the source scope item in all views. We need
        //a dummy data object for UpdateAllViews.
        //pLastPasteQuery is the lpDataObject of the source scope item
        //See MMCN_SHOW below
        IDataObject *pDummy = NULL;
        hr = m_pParent->m_ipConsole->UpdateAllViews(pDummy, (long)(pLastPasteQuery->GetHandle()), UPDATE_SCOPEITEM);
        _ASSERT( S_OK == hr);

        return S_OK;
    }

    //Remaining notifications

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_SHOW:
        if (arg)
        {//scope item selected
            OutputDebugString(_T("Changing selected scope node\n"));
            //We use this for drag-and-drop operations.
            pLastPasteQuery = base;
        }
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_REFRESH:
        hr = base->OnRefresh(m_pParent->m_ipConsole);
        break;

    case MMCN_DELETE:
        //first delete the selected result item
        hr = base->OnDelete(m_ipConsole);

        //Now call IConsole::UpdateAllViews to redraw all views
        //owned by the parent scope item. OnRefresh already does
        //this for us, so use it.
        hr = base->OnRefresh(m_pParent->m_ipConsole);
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);

        //Now call IConsole::UpdateAllViews to redraw the item in all views.
        hr = m_pParent->m_ipConsole->UpdateAllViews(lpDataObject, 0, UPDATE_RESULTITEM);
        _ASSERT( S_OK == hr);

        break;


    case MMCN_QUERY_PASTE:
        {
            CDataObject *pPastedDO = GetOurDataObject((IDataObject *)arg);
            if (pPastedDO != NULL)
            {
                CDelegationBase *pasted = pPastedDO->GetBaseNodeObject();

                if (pasted != NULL)
                {
                    hr = base->OnQueryPaste(pasted);
                }
            }
        }
        break;

    case MMCN_PASTE:
        {
            CDataObject *pPastedDO = GetOurDataObject((IDataObject *)arg);
            if (pPastedDO != NULL)
            {
                CDelegationBase *pasted = pPastedDO->GetBaseNodeObject();

                if (pasted != NULL)
                {
                    hr = base->OnPaste(m_ipConsole, m_pParent, pasted);

                    if (SUCCEEDED(hr))
                    {
                        // Determine if the item to be pasted is scope or result item.
                        CRocket* pRocket = dynamic_cast<CRocket*>(pasted);
                        BOOL bResult = pRocket ? TRUE : FALSE;     // Rocket item is result item.

                        CDataObject *pObj = new CDataObject((MMC_COOKIE)pasted, bResult ? CCT_RESULT : CCT_SCOPE);

                        if (!pObj)
                            return E_OUTOFMEMORY;

                        pObj->QueryInterface(IID_IDataObject, (void **)param);

                        //now update the destination scope item in all views.
                        //But only do this if this is not a drag-and-drop
                        //operation. That is, the destination scope item
                        //is the currently selected one.

                        if (pLastPasteQuery != NULL && pLastPasteQuery == base)
                        {
                            IDataObject *pDummy = NULL;
                            hr = m_pParent->m_ipConsole->UpdateAllViews(pDummy,
                                                                        (long)(pLastPasteQuery->GetHandle()), UPDATE_SCOPEITEM);
                            _ASSERT( S_OK == hr);
                        }
                    }
                }
            }
        }

        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole)
    {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;
    CDelegationBase *pBase = NULL;

    if (IsBadReadPtr((void *)cookie, sizeof(CDelegationBase)))
    {
        if (NULL == m_pLastNode)
            return E_FAIL;

        pBase = m_pLastNode->GetChildPtr((int)cookie);
    }
    else
    {
        pBase = (cookie == 0) ? m_pParent->m_pStaticNode : (CDelegationBase *)cookie;
    }

    if (pBase == NULL)
        return E_FAIL;

    pObj = new CDataObject((MMC_COOKIE)pBase, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                          /* [in] */ MMC_COOKIE cookie,
                                          /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                          /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = m_pLastNode = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                       /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam)
    {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR)
        {
            LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
            MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE)
        {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }
    else
    {
        m_pLastNode->GetChildColumnInfo(pResultDataItem);
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::FindItem(
/* [in] */ LPRESULTFINDINFO pFindInfo,
/* [out] */ int __RPC_FAR *pnFoundIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CComponent::CacheHint(
/* [in] */ int nStartIndex,
/* [in] */ int nEndIndex)
{
    return E_NOTIMPL;
}

STDMETHODIMP CComponent::SortItems(
/* [in] */ int nColumn,
/* [in] */ DWORD dwSortOptions,
/* [in] */ LPARAM lUserParam)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent, IResultOwnerData
{
private:
    ULONG				m_cref;
    
    IConsole          *m_ipConsole;
    
	class CComponentData *m_pParent;
    class CDelegationBase *m_pLastNode;
    
    public:
        CComponent(CComponentData *pParent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();

    LPCONSOLENAMESPACE GetConsoleNameSpace()
    {
        return m_ipConsoleNameSpace;
    }

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "Space.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_DELETE:
		CSpaceStation* pSpaceStn = dynamic_cast<CSpaceStation*>(base);
		if (NULL != pSpaceStn)
		{
			hr = pSpaceStn->OnDeleteScopeItem(m_ipConsoleNameSpace);		
		}

		break;

	}
    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\cutcopy\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                ret