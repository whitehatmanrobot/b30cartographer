				AtmLaneShutdownElan(pElan, TRUE);
								//
								//	lock released in above
								//
							}
							
							break;

						default: 

							//
							//	Call failed, 
							//	Close the LES connection and
							//	return to the Init State in a little while.
							//
							AtmLaneShutdownElan(pElan, TRUE);
							//
							//	lock released in above
							//

							break;
					}


					break;
					
				case ELAN_EVENT_LES_CALL_CLOSED:
				
					DBGP((1, "%d BUS CONNECT - LES CALL CLOSED\n", pElan->ElanNumber));
					
					//
					//	restart the Elan
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d BUS CONNECT - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;

				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d BUS CONNECT - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;

				default:
					DBGP((0, "%d BUS CONNECT - UNEXPECTED EVENT %d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;

			}

			break;
			
		//
		//	OPERATIONAL STATE ---------------------------------------------------
		//
		case ELAN_STATE_OPERATIONAL:

			switch (Event)
			{
				case ELAN_EVENT_START:

					DBGP((1, "%d OPERATIONAL - START\n", pElan->ElanNumber));

					// Initialize the miniport if not already

					if ((pElan->Flags & ELAN_MINIPORT_INITIALIZED) == 0)
					{
						// Only if we have a device name

						if (pElan->CfgDeviceName.Length > 0)
						{
				
							pElan->Flags |= ELAN_MINIPORT_INITIALIZED;

							//
							//	Schedule a PASSIVE_LEVEL thread to call
							//	NdisIMInitializeDeviceInstance
							//
							NdisInitializeWorkItem(
									&pElan->NdisWorkItem,
									AtmLaneInitializeMiniportDevice,
									pElan);

							AtmLaneReferenceElan(pElan, "workitem");

							NdisScheduleWorkItem(&pElan->NdisWorkItem);

						}
						else
						{
							DBGP((0, "EventHandler: No miniport device name configured\n"));
						}
					}

					//
					//	Clear last event log code
					//
					pElan->LastEventCode = 0;
					
					RELEASE_ELAN_LOCK(pElan);
					
					break;

				case ELAN_EVENT_LES_CALL_CLOSED:
				
					DBGP((1, "%d OPERATIONAL - LES CALL CLOSED\n", pElan->ElanNumber));
					
					//
					//	Tear everything down and restart
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

				case ELAN_EVENT_BUS_CALL_CLOSED:
				
					DBGP((1, "%d OPERATIONAL - BUS CALL CLOSED\n", pElan->ElanNumber));

					//
					//	Tear everything down and restart
					//
					AtmLaneShutdownElan(pElan, TRUE);
					//
					//	lock released in above
					//
					break;

					break;

				case ELAN_EVENT_RESTART:
				
					DBGP((1, "%d OPERATIONAL - RESTART\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, TRUE);

					break;
					
				case ELAN_EVENT_STOP:
				
					DBGP((1, "%d OPERATIONAL - STOP\n", pElan->ElanNumber));

					AtmLaneShutdownElan(pElan, FALSE);

					break;
					
				default:
					DBGP((0, "%d OPERATIONAL - UNEXPECTED EVENT%d\n", 
							pElan->ElanNumber, Event));
							
					RELEASE_ELAN_LOCK(pElan);

					break;
			}
			
			break;


		default:

			DBGP((0, "%d UNKOWN STATE  %d EVENT %d\n", 
				pElan->ElanNumber, pElan->State, Event));
		
			RELEASE_ELAN_LOCK(pElan);

			break;


	} // switch (pElan->State)

	TRACEOUT(EventHandler);
	CHECK_EXIT_IRQL(EntryIrql);
	return;
}

VOID
AtmLaneBootStrapElans(
    IN  PATMLANE_ADAPTER            pAdapter
)
/*++

Routine Description:

	Start up the ELANs configured for an adapter.
    Done upon receipt of AF notify from call manager.

Arguments:

	pAdapter	- Pointer to ATMLANE Adapter structure

Return Value:

	None

--*/
{
	NDIS_STATUS						Status;
	NDIS_HANDLE                     AdapterConfigHandle;
	NDIS_STRING				        ElanListKeyName;
	NDIS_HANDLE                     ElanListConfigHandle;
	NDIS_HANDLE                     ElanConfigHandle;
	NDIS_STRING                     ElanKeyName;
	UINT                            Index;
	PLIST_ENTRY                     p;
    PATMLANE_ELAN                   pElan;
    PATMLANE_NAME					pName;
    BOOLEAN							bBootStrapping;
	
	TRACEIN(BootStrapElans);
	
	//
	//  Initialize.
	//
	Status = NDIS_STATUS_SUCCESS;
	AdapterConfigHandle = NULL_NDIS_HANDLE;
    ElanListConfigHandle = NULL_NDIS_HANDLE;
    ElanConfigHandle = NULL_NDIS_HANDLE;
    bBootStrapping = TRUE;
	
    do
	{
		DBGP((1, "BootStrapElans: Starting ELANs on adapter %p\n", pAdapter));
		ACQUIRE_ADAPTER_LOCK(pAdapter);

		if (pAdapter->Flags & (ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS|
                                ADAPTER_FLAGS_UNBINDING))
		{
			DBGP((0, "Skipping bootstrap on adapter %x/%x\n", pAdapter, pAdapter->Flags));
			RELEASE_ADAPTER_LOCK(pAdapter);
			bBootStrapping = FALSE;
			break;
		}

		pAdapter->Flags |= ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS;
		INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);
		RELEASE_ADAPTER_LOCK(pAdapter);
	
		//
		//  Open the AtmLane protocol configuration section for this adapter.
		//

    	NdisOpenProtocolConfiguration(
	    					&Status,
		    				&AdapterConfigHandle,
			    			&pAdapter->ConfigString
	    					);
    
	    if (NDIS_STATUS_SUCCESS != Status)
	    {
		    AdapterConfigHandle = NULL_NDIS_HANDLE;
			DBGP((0, "BootStrapElans: OpenProtocolConfiguration failed\n"));
			Status = NDIS_STATUS_OPEN_FAILED;
			break;
	    }

		//
		//	Get the protocol specific configuration
		//
		AtmLaneGetProtocolConfiguration(AdapterConfigHandle, pAdapter);

        //
        //  We bootstrap the ELANs differently on NT5 and Memphis(Win98)
        //
        if (!pAdapter->RunningOnMemphis)
        {
            //
            //  This is the NT5 ELAN bootstrap case
            //        
            do
            {
        		//
	        	//	Open the Elan List configuration key.
        		//
            	NdisInitUnicodeString(&ElanListKeyName, ATMLANE_ELANLIST_STRING);

            	NdisOpenConfigurationKeyByName(
				        &Status,
				        AdapterConfigHandle,
    				    &ElanListKeyName,
				        &ElanListConfigHandle);

	            if (NDIS_STATUS_SUCCESS != Status)
	            {
		            ElanListConfigHandle = NULL_NDIS_HANDLE;
			        DBGP((0, "BootStrapElans: Failed open of ElanList key\n"));
			        Status = NDIS_STATUS_FAILURE;
			        break;
	            }

    		    //
    	    	//	Iterate thru the configured Elans
    		    //
                for (Index = 0;
			    	;			// Stop only on error or no more Elans
        			 Index++)
		        {
        			//
		        	//	Open the "next" Elan key
        			//
	                NdisOpenConfigurationKeyByIndex(
				                &Status,
				                ElanListConfigHandle,
				                Index,
				                &ElanKeyName,
				                &ElanConfigHandle
				                );

	                if (NDIS_STATUS_SUCCESS != Status)
	                {
		                ElanConfigHandle = NULL_NDIS_HANDLE;
	                }
	                
			        //
			        //	If NULL handle, assume no more ELANs.
			        //
			        if (NULL_NDIS_HANDLE == ElanConfigHandle)
			        {
				        break;
			        }

                    //
                    //  Create this Elan
                    //
                    DBGP((2, "Bootstrap ELANs: Adapter %x, KeyName: len %d, max %d, name: [%ws]\n",
                    			pAdapter,
                    			ElanKeyName.Length,
                    			ElanKeyName.MaximumLength,
                    			ElanKeyName.Buffer));
                    (VOID)AtmLaneCreateElan(pAdapter, &ElanKeyName, &pElan);
                }   
                
            } while (FALSE);

            Status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            //
            //  This is the Memphis/Win98 ELAN bootstrap case
            // 
			//	Create Elans for each entry in the UpperBindings List
			//				
			pName = pAdapter->UpperBindingsList;

			while (pName != NULL)
			{
				(VOID)AtmLaneCreateElan(pAdapter, NULL, &pElan);
           
				pName = pName->pNext;
            }
		}


	} while (FALSE);
        

	//
	//	Close config handles
	//		
	if (NULL_NDIS_HANDLE != ElanConfigHandle)
	{
		NdisCloseConfiguration(ElanConfigHandle);
		ElanConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != ElanListConfigHandle)
	{
		NdisCloseConfiguration(ElanListConfigHandle);
		ElanListConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != AdapterConfigHandle)
	{
	    NdisCloseConfiguration(AdapterConfigHandle);
		AdapterConfigHandle = NULL_NDIS_HANDLE;
	}


	//
    //  Loop thru the ELANs and kickstart them - only the newly
    //  allocated ones.
    //
	if (!IsListEmpty(&pAdapter->ElanList))
	{
		p = pAdapter->ElanList.Flink;
		while (p != &pAdapter->ElanList)
		{
			pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
			STRUCT_ASSERT(pElan, atmlane_elan);
			
		    ACQUIRE_ELAN_LOCK(pElan);
		    if (ELAN_STATE_ALLOCATED == pElan->State)
		    {
				pElan->AdminState = ELAN_STATE_OPERATIONAL;
				pElan->State = ELAN_STATE_INIT;
				AtmLaneQueueElanEvent(pElan, ELAN_EVENT_START, Status);
			}
			RELEASE_ELAN_LOCK(pElan);
		
			p = p->Flink;
		}
	}
	
	if (bBootStrapping)
	{
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pAdapter->Flags &= ~ADAPTER_FLAGS_BOOTSTRAP_IN_PROGRESS;
		RELEASE_ADAPTER_LOCK(pAdapter);

		SIGNAL_BLOCK_STRUCT(&pAdapter->UnbindBlock, NDIS_STATUS_SUCCESS);
	}

	TRACEOUT(BootStrapElans);
	return;
}


NDIS_STATUS
AtmLaneCreateElan(
    IN  PATMLANE_ADAPTER            pAdapter,
    IN  PNDIS_STRING                pElanKey,
    OUT	PATMLANE_ELAN *				ppElan
)
/*++

Routine Description:

	Create and start an ELAN.
	
Arguments:

	pAdapter	    -   Pointer to ATMLANE Adapter structure
	pElanKey	    -   Points to a Unicode string naming the elan to create. 
	ppElan			- 	Pointer to pointer to ATMLANE_ELAN (output)
	
Return Value:

	None

--*/
{
	NDIS_STATUS			Status;
	PATMLANE_ELAN       pElan;


    TRACEIN(CreateElan);


    Status = NDIS_STATUS_SUCCESS;
    pElan = NULL_PATMLANE_ELAN;

    DBGP((1, "CreateElan: Adapter %p, ElanKey %ws\n", pAdapter, pElanKey->Buffer));

	do
	{
		//
		//  Weed out duplicates.
		//
		if (pElanKey != NULL)
		{

			pElan = AtmLaneFindElan(pAdapter, pElanKey);

			if (NULL_PATMLANE_ELAN != pElan)
			{
				// Duplicate
				DBGP((0, "CreateElan: found duplicate pElan %p\n", pElan));

				Status = NDIS_STATUS_FAILURE;
				pElan = NULL_PATMLANE_ELAN;
				break;
			}
		}

		//
		//	Allocate an ELAN data structure.
		//
		Status = AtmLaneAllocElan(pAdapter, &pElan);
		if (NDIS_STATUS_SUCCESS != Status)
		{
			DBGP((0, "CreateElan: Failed allocate of elan data\n"));
			break;
		}

		//
		//	Put initial reference on the Elan struct.
		//
		AtmLaneReferenceElan(pElan, "adapter");		

		//
		//	Store in bind name (NT only, not supplied on Win98)
		//
		if (pElanKey != NULL)
		{
			if (!AtmLaneCopyUnicodeString(&pElan->CfgBindName, pElanKey, TRUE, TRUE))
			{
				DBGP((0, "CreateElan: Failed allocate of bind name string\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		//
		//	Get the ELAN's configuration.
		//
		AtmLaneGetElanConfiguration(pElanKey, pElan);
		

		//
		//  Allocate protocol buffers for this Elan.
		//
		Status = AtmLaneInitProtoBuffers(pElan);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"CreateElan: bad status (%x) from InitBufs\n",
				Status));
			break;
		}

		//
		//	Allocate transmit packet descriptors for this Elan.
		//
		NdisAllocatePacketPool(
				&Status, 
				&pElan->TransmitPacketPool, 
				pElan->MaxHeaderBufs,
				sizeof(SEND_PACKET_RESERVED)
				);
#if PKT_HDR_COUNTS
		pElan->XmitPktCount = pElan->MaxHeaderBufs;
		DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
#endif

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"CreateElan: bad status (%x)"
				" from NdisAllocatePacketPool (xmit)\n",
				Status));
			break;
		}

		//
		//	Allocate receive packet descriptors for this Elan.
		//
		NdisAllocatePacketPool(
				&Status, 
				&pElan->ReceivePacketPool, 
				pElan->MaxHeaderBufs,
				sizeof(RECV_PACKET_RESERVED)
				);
#if PKT_HDR_COUNTS
		pElan->RecvPktCount = pElan->MaxHeaderBufs;
		DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
#endif
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"CreateElan: bad status (%x)"
				" from NdisAllocatePacketPool (xmit)\n",
				Status));
			break;
		}

		//
		//	Allocate receive buffer descriptors for this Elan.
		//
		NdisAllocateBufferPool(&Status, 
					&pElan->ReceiveBufferPool, 
					pElan->MaxHeaderBufs
					);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"AfRegisterNotifyHandler: bad status (%x)"
				" from NdisAllocateBufferPool\n",
				Status));
			break;
		}
	
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//	There was a failure in processing this Elan.
		//
		if (NULL_PATMLANE_ELAN != pElan)
		{
			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneDereferenceElan(pElan, "adapter");
		}

		*ppElan = NULL_PATMLANE_ELAN;
	}
	else
	{
		//	Output created Elan
	
		*ppElan = pElan;
	}


    TRACEOUT(CreateElan);

    return Status;
}

NDIS_STATUS
AtmLaneReconfigureHandler(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNET_PNP_EVENT			pNetPnPEvent
)
/*++

Routine Description:

	Handler for PnP Reconfigure events.

Arguments:

	pAdapter		-	Pointer to our adapter struct.

	pNetPnPEvent	- 	Pointer to PnP Event structure describing the event.

Return Value:

	Status of handling the reconfigure event.
	
--*/
{
	NDIS_STATUS						Status;
	PATMLANE_PNP_RECONFIG_REQUEST	pReconfig;
	NDIS_STRING						ElanKey;
	PATMLANE_ELAN					pElan;

	TRACEIN(ReconfigureHandler);

	do
	{
		DBGP((1, "Reconfigurehandler: Buffer 0x%x BufferLength %d\n",
					pNetPnPEvent->Buffer, pNetPnPEvent->BufferLength));

		Status = NDIS_STATUS_SUCCESS;

		if (pAdapter == NULL_PATMLANE_ADAPTER)
		{
			//
			//  Either a global reconfig notification or this is
			//  NDIS itself asking us to re-evaluate our ELANs.
			//  We go through the list of configured ELANs on all
			//  adapters and start any that haven't been started.
			//
			{
				PLIST_ENTRY		pEnt, pNextEnt;

				ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

				for (pEnt = pAtmLaneGlobalInfo->AdapterList.Flink;
					 pEnt != &pAtmLaneGlobalInfo->AdapterList;
					 pEnt = pNextEnt)
				{
					pNextEnt = pEnt->Flink;
					RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

					pAdapter = CONTAINING_RECORD(pEnt, ATMLANE_ADAPTER, Link);

			        if (pAdapter->Flags & ADAPTER_FLAGS_AF_NOTIFIED)
			        {
						DBGP((1, "Reconfig: Will bootstrap ELANs on Adapter %x\n",
								pAdapter));

						AtmLaneBootStrapElans(pAdapter);
					}

					ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
				}

				RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
			}


			break;
		}
	
		//	Get pointer to LANE reconfig struct inside the generic PnP struct
	
		pReconfig = (PATMLANE_PNP_RECONFIG_REQUEST)(pNetPnPEvent->Buffer);

		// 	Check for null pointer

		if (pReconfig == NULL)
		{
			DBGP((0, "ReconfigureHandler: NULL pointer to event buffer!\n"));
			Status = NDIS_STATUS_INVALID_DATA;
			break;
		}

		//	Validate the version

		if (pReconfig->Version != 1)
		{
			DBGP((0, "ReconfigureHandler: Version not 1\n"));
			Status = NDIS_STATUS_BAD_VERSION;
			break;
		}

		//	Build a UNICODE string containing the ELAN's key

		NdisInitUnicodeString(&ElanKey, pReconfig->ElanKey);

		//	First find the Elan

		pElan = AtmLaneFindElan(pAdapter, &ElanKey);

		DBGP((0, "ReconfigHandler: Adapter %x, ELAN %x, OpType %d\n",
					pAdapter, pElan, pReconfig->OpType));

		//  Sanity check: don't add an existing ELAN

		if (ATMLANE_RECONFIG_OP_ADD_ELAN == pReconfig->OpType &&
			NULL_PATMLANE_ELAN != pElan)
		{
			DBGP((0, "ReconfigureHandler: Ignoring ADD existing Elan %x\n", pElan));
			Status = NDIS_STATUS_SUCCESS;
			break;
		}

		//	If MOD or DEL first shutdown the existing ELAN

		if (ATMLANE_RECONFIG_OP_MOD_ELAN == pReconfig->OpType ||
			ATMLANE_RECONFIG_OP_DEL_ELAN == pReconfig->OpType)
		{
			
			if (NULL_PATMLANE_ELAN == pElan)
			{
				DBGP((0, "ReconfigureHandler: No existing Elan found for Modify/Delete\n"));
				Status = NDIS_STATUS_FAILURE;
				break;
			}
			
			//	Shut down the existing Elan

			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneShutdownElan(pElan, FALSE);
		}

		// 	If ADD or MOD startup the new ELAN

		if (ATMLANE_RECONFIG_OP_ADD_ELAN == pReconfig->OpType ||
			ATMLANE_RECONFIG_OP_MOD_ELAN == pReconfig->OpType)
		{
			Status = AtmLaneCreateElan(pAdapter, &ElanKey, &pElan);
			if (NDIS_STATUS_SUCCESS == Status)
			{
		    	pElan->AdminState = ELAN_STATE_OPERATIONAL;
		    	pElan->State = ELAN_STATE_INIT;
				AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, Status, 1*1000);
			}
		}

	} while (FALSE);

	TRACEOUT(ReconfigureHandler);
	DBGP((0, "Reconfigure: pAdapter %x, returning %x\n", pAdapter, Status));
	return Status;
}

PATMLANE_ELAN
AtmLaneFindElan(
	IN	PATMLANE_ADAPTER		pAdapter,
	IN	PNDIS_STRING			pElanKey
)
/*++

Routine Description:

	Find an ELAN by bind name/key

Arguments:

	pAdapter		-	Pointer to an adapter struct.

	pElanKey		- 	Pointer to NDIS_STRING containing Elan's bind name.

Return Value:

	Pointer to matching Elan or NULL if not found.
	
--*/
{
	PLIST_ENTRY 		p;
	PATMLANE_ELAN		pElan;
	BOOLEAN				Found;
	NDIS_STRING			ElanKeyName;

	TRACEIN(FindElan);
	DBGP((1, "FindElan: Adapter %p, ElanKey %ws\n", pAdapter, pElanKey->Buffer));

	Found = FALSE;
	ElanKeyName.Buffer = NULL;
	pElan = NULL_PATMLANE_ELAN;

	do
	{
		//
		//  Make an up-cased copy of the given string.
		//
		ALLOC_MEM(&ElanKeyName.Buffer, pElanKey->MaximumLength);
		if (ElanKeyName.Buffer == NULL)
		{
			break;
		}

		ElanKeyName.Length = pElanKey->Length;
		ElanKeyName.MaximumLength = pElanKey->MaximumLength;

#ifndef LANE_WIN98
		(VOID)NdisUpcaseUnicodeString(&ElanKeyName, pElanKey);
#else
		memcpy(ElanKeyName.Buffer, pElanKey->Buffer, ElanKeyName.Length);
#endif // LANE_WIN98

		ACQUIRE_ADAPTER_LOCK(pAdapter);

		p = pAdapter->ElanList.Flink;
		while (p != &pAdapter->ElanList)
		{
			pElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);
			STRUCT_ASSERT(pElan, atmlane_elan);

			// compare the key

			if ((ElanKeyName.Length == pElan->CfgBindName.Length) &&
				(memcmp(ElanKeyName.Buffer, pElan->CfgBindName.Buffer, ElanKeyName.Length) == 0))
			{
				//
				//  Skip ELANs that are shutting down and not restarting
				//
				if ((pElan->AdminState != ELAN_STATE_SHUTDOWN) ||
					((pElan->Flags & ELAN_NEEDS_RESTART) != 0))
				{
					Found = TRUE;
					break;
				}
			}
		
			// get next link

			p = p->Flink;
		}

		RELEASE_ADAPTER_LOCK(pAdapter);
	}
	while (FALSE);

	if (!Found)
	{
		DBGP((2, "FindElan: No match found!\n"));
	
		pElan = NULL_PATMLANE_ELAN;
	}

	if (ElanKeyName.Buffer)
	{
		FREE_MEM(ElanKeyName.Buffer);
	}

	TRACEOUT(FindElan);
	return pElan;
}

VOID
AtmLaneConnectToServer(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						ServerType,
	IN	BOOLEAN						UsePvc
)
/*++

Routine Description:

	Setup and make call to a LANE Server.


Arguments:

	pElan		- Pointer to ATMLANE Elan structure

	ServerType	- LECS, LES, or BUS

Return Value:

	None

--*/
{
	NDIS_STATUS				Status;
	ULONG					rc;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	BOOLEAN					bAtmEntryAlloced = FALSE;

	TRACEIN(ConnectToServer);

	do
	{
		switch (ServerType)
		{
			case ATM_ENTRY_TYPE_LECS:

				//
				//	Create the ATM Entry
				//
				pAtmEntry = AtmLaneAllocateAtmEntry(pElan);
				if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
				{
					bAtmEntryAlloced = TRUE;
					//
					//	Init ATM Entry
					//
					pAtmEntry->Type = ServerType;
					NdisMoveMemory(
						&pAtmEntry->AtmAddress, 
						&pElan->LecsAddress, 
						sizeof(ATM_ADDRESS));

					//
					//  Add it to the Elan's list
					//
					ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
					pElan->pLecsAtmEntry = pAtmEntry;
					pAtmEntry->pNext = pElan->pAtmEntryList;
					pElan->pAtmEntryList = pAtmEntry;
					pElan->NumAtmEntries++;
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);

					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

				}
				break;

			case ATM_ENTRY_TYPE_LES:
				//
				//	Create the ATM Entry
				//
				pAtmEntry = AtmLaneAllocateAtmEntry(pElan);
				if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
				{
					bAtmEntryAlloced = TRUE;
					//
					//	Init ATM Entry
					//
					pAtmEntry->Type = ServerType;

					NdisMoveMemory(
						&pAtmEntry->AtmAddress, 
						&pElan->LesAddress, 
						sizeof(ATM_ADDRESS));
					//
					//  Add it to the Elan's list
					//
					ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
					pElan->pLesAtmEntry = pAtmEntry;
					pAtmEntry->pNext = pElan->pAtmEntryList;
					pElan->pAtmEntryList = pAtmEntry;
					pElan->NumAtmEntries++;
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);

					ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				}
				break;
				
			case ATM_ENTRY_TYPE_BUS:
			
				ASSERT(NULL_PATMLANE_ATM_ENTRY != pElan->pBusAtmEntry);
				
				NdisMoveMemory(
					&pElan->BusAddress, 
					&pElan->pBusAtmEntry->AtmAddress, 
					sizeof(ATM_ADDRESS));

				pAtmEntry = pElan->pBusAtmEntry;

				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				
				break;
		}

		if (NULL_PATMLANE_ATM_ENTRY == pAtmEntry)
		{
			break;
		}
		
		//
		//	Call the Server
		//
		DBGP((1, "%d: ConnectToServer: pElan %x/ref %d, Type %d, pAtmEnt %x, Ref %d\n",
					pElan->ElanNumber,
					pElan,
					pElan->RefCount,
					ServerType,
					pAtmEntry,
					pAtmEntry->RefCount));

		
		Status = AtmLaneMakeCall(pElan, pAtmEntry, UsePvc);
	
		if (NDIS_STATUS_SUCCESS == Status)
		{
			//
			//	Call completed synchronously.
			//	
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_SVR_CALL_COMPLETE, Status);
			break;
		}
				
		if (NDIS_STATUS_PENDING != Status)
		{
			// 
			//	Call failed.
			//	Dereference Atm Entry (should delete it).
			//	Signal the elan state machine.
			//
			DBGP((1, "ConnectToServer: MakeCall Failed: Elan %p, Type %d, AtmEnt %p, Ref %d\n",
				pElan,
				ServerType,
				pAtmEntry,
				pAtmEntry->RefCount));

			if (bAtmEntryAlloced)
			{
				ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
				rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "elan");		// Elan list reference
				ASSERT(0 == rc);
			}

			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_SVR_CALL_COMPLETE, Status);
			
			break;
		}
	}
	while (FALSE);

	TRACEOUT(ConnectToServer);

	return;
}


VOID
AtmLaneInvalidateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry	LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Invalidate an ATM Entry by unlinking it from MAC entries and
	closing VC's on it.

Arguments:

	pAtmEntry		- The ATM Entry needing invalidating.

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;
	PATMLANE_MAC_ENTRY		pNextMacEntry;
	ULONG					rc;			// Ref Count of ATM Entry
	INT						MacEntriesUnlinked;

	TRACEIN(InvalidateAtmEntry);

	DBGP((1, "%d Del ATM %x: %s\n", 
		pAtmEntry->pElan->ElanNumber,
		pAtmEntry,
		AtmAddrToString(pAtmEntry->AtmAddress.Address)));

	DBGP((3, 
		"InvalidateAtmEntry: pAtmEntry %x, pMacEntryList %x\n",
				pAtmEntry,
				pAtmEntry->pMacEntryList));
	//
	//  Initialize.
	//
	MacEntriesUnlinked = 0;

	//
	//  Take the MAC Entry list out of the ATM Entry.
	//
	pMacEntry = pAtmEntry->pMacEntryList;
	pAtmEntry->pMacEntryList = NULL_PATMLANE_MAC_ENTRY;

	//
	//  We let go of the ATM Entry lock here because we'll need
	//  to lock each MAC Entry in the above list, and we need to make
	//  sure that we don't deadlock.
	//
	//  However, we make sure that the ATM Entry doesn't go away
	//  by adding a reference to it.
	//
	AtmLaneReferenceAtmEntry(pAtmEntry, "temp");	// Temp ref
	RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

	//
	//  Now unlink all MAC entries.
	//
	while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		pNextMacEntry = pMacEntry->pNextToAtm;

		//
		//  Remove the mapping.
		//
		pMacEntry->Flags = MAC_ENTRY_NEW;
		pMacEntry->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;
		pMacEntry->pNextToAtm = NULL_PATMLANE_MAC_ENTRY;

		//
		//  Remove the ATM Entry linkage reference.
		//
		if (AtmLaneDereferenceMacEntry(pMacEntry, "atm") != 0)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		}
		//
		//  else the MAC Entry is gone
		//

		MacEntriesUnlinked++;

		pMacEntry = pNextMacEntry;
	}

	ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

	//
	//  Now dereference the ATM Entry as many times as we unliked
	//  MAC Entries from it.
	//
	while (MacEntriesUnlinked-- > 0)
	{
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "mac");	// MAC Entry reference
		ASSERT(rc != 0);
	}

	//
	//  Take out the reference we added at the beginning of
	//  this routine.
	//
	rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "temp");	// Temp ref

	//
	//  Close the SVCs attached to the ATM Entry. 
	//  But do all this only if the ATM Entry
	//  hasn't been dereferenced away already.
	//
	if (rc != 0)
	{
		//
		//  The ATM Entry still exists.
		//	Close the VCs.
		//
		AtmLaneCloseVCsOnAtmEntry(pAtmEntry);
		//
		//  The ATM Entry lock is released within the above.
		//
	}
	//
	//  else the ATM Entry is gone
	//
	TRACEOUT(InvalidateAtmEntry);
	return;
}


VOID
AtmLaneCloseVCsOnAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	Close the (potentially two) VCs attached to an ATM Entry.
	
Arguments:

	pAtmEntry			- Pointer to ATM Entry on which we want to close SVCs.

Return Value:

	None

--*/
{
	PATMLANE_VC		pVcList;			// List of "Main" VCs on the ATM Entry
	PATMLANE_VC		pVc;				// Main VC on the ATM Entry
	PATMLANE_VC		pVcIncomingList;	// List of Optional incoming VCs on ATM Entry
	PATMLANE_VC		pVcIncoming;		// Optional incoming VC on ATM Entry
	PATMLANE_VC		pNextVc;			// Temp, for traversing VC lists.
	ULONG			rc;					// Ref count on ATM Entry

	TRACEIN(CloseVCsOnAtmEntry);

	//
	//  Initialize.
	//
	rc = pAtmEntry->RefCount;

	//
	//	Take out the Main VC list from the ATM Entry.
	//	
	pVcList = pAtmEntry->pVcList;
	pAtmEntry->pVcList = NULL_PATMLANE_VC;

	//
	//  Deref the ATM Entry for each of the Main VCs.
	//
	for (pVc = pVcList;
		 NULL_PATMLANE_VC != pVc;
		 pVc = pNextVc)
	{
		ASSERT(rc != 0);

		ACQUIRE_VC_LOCK(pVc);
		pNextVc = pVc->pNextVc;
	
		//
		//	Unlink this VC from the ATM Entry.
		//
		pVc->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

		//
		//	Leave AtmEntry Reference on VC so it doesn't go away
		//	
		RELEASE_VC_LOCK(pVc);

		DBGP((1, "%d unlink VC %x/%x, Ref %d from ATM Entry %x\n",
				pAtmEntry->pElan->ElanNumber,
				pVc, pVc->Flags, pVc->RefCount,
				pAtmEntry));

		//
		//	Dereference the ATM Entry.
		//
		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "vc");	// VC reference
	}

	if (rc != 0)
	{
		//
		//  Take out the Incoming VC list from the ATM Entry.
		//
		pVcIncomingList = pAtmEntry->pVcIncoming;
		pAtmEntry->pVcIncoming = NULL_PATMLANE_VC;

		//
		//  Deref the ATM Entry for each of the Incoming VCs.
		//
		for (pVcIncoming = pVcIncomingList;
 			NULL_PATMLANE_VC != pVcIncoming;
 			pVcIncoming = pNextVc)
		{
			ASSERT(rc != 0);

			ACQUIRE_VC_LOCK(pVcIncoming);
			pNextVc = pVcIncoming->pNextVc;

			//
			//	Unlink this VC from the ATM Entry.
			//
			pVcIncoming->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;
		
			//
			//	Leave AtmEntry Reference on VC so it doesn't go away
			//	
			RELEASE_VC_LOCK(pVcIncoming);

			DBGP((1, "%d unlink Incoming VC %x from ATM Entry %x\n",
					pAtmEntry->pElan->ElanNumber,
					pVcIncoming,
					pAtmEntry));

			//
			//	Dereference the ATM Entry.
			//
			rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "vc");	// VC reference
		}
	}
	else
	{
		pVcIncomingList = NULL_PATMLANE_VC;
	}
	
	if (rc != 0)
	{
		//
		//  The ATM Entry lives on. We don't need a lock to it anymore.
		//
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}

	//
	//  Now close the VC(s).
	//

	for (pVc = pVcList;
		 NULL_PATMLANE_VC != pVc;
		 pVc = pNextVc)
	{
		ACQUIRE_VC_LOCK(pVc);
		pNextVc = pVc->pNextVc;
		
		rc = AtmLaneDereferenceVc(pVc, "atm");	// ATM Entry reference
		if (rc != 0)
		{
			AtmLaneCloseCall(pVc);
			//
			//  The VC lock is released within the above.
			//
		}
		//
		//  else the VC is gone.
		//
	}
	
	for (pVcIncoming = pVcIncomingList;
		 NULL_PATMLANE_VC != pVcIncoming;
		 pVcIncoming = pNextVc)
	{
		ACQUIRE_VC_LOCK(pVcIncoming);
		pNextVc = pVcIncoming->pNextVc;
		
		rc = AtmLaneDereferenceVc(pVcIncoming, "atm");	// ATM Entry reference
		if (rc != 0)
		{
			AtmLaneCloseCall(pVcIncoming);
			//
			//  The VC lock is released within the above.
			//
		}
		//
		//  else the VC is gone.
		//
	}

	TRACEOUT(CloseVCsOnAtmEntry);

	return;
}


VOID
AtmLaneGenerateMacAddr(
	PATMLANE_ELAN					pElan
)
/*++

Routine Description:

	Generates a "virtual" MAC address for Elans after the first
	Elan on an ATM interface.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{

	TRACEIN(GenerateMacAddress);

	//
	//	Start by using the real ATM card's MAC address
	//
	
	NdisMoveMemory(
		&pElan->MacAddressEth,
		&pElan->pAdapter->MacAddress, 
		sizeof(MAC_ADDRESS)
		);
		
	if (pElan->ElanNumber != 0)
	{
		//
		//	Not Elan number zero so generate a locally 
		//	administered address by manipulating the first two bytes.
		//
		pElan->MacAddressEth.Byte[0] = 
			0x02 | (((UCHAR)pElan->ElanNumber & 0x3f) << 2);
		pElan->MacAddressEth.Byte[1] = 
			(pElan->pAdapter->MacAddress.Byte[1] & 0x3f) | 
			((UCHAR)pElan->ElanNumber & 0x3f);
	}	

	//
	//	Create the Token Ring version of the MAC Address
	//
	NdisMoveMemory(
		&pElan->MacAddressTr, 
		&pElan->MacAddressEth,
		sizeof(MAC_ADDRESS)
		);

	AtmLaneBitSwapMacAddr((PUCHAR)&pElan->MacAddressTr);

	DBGP((1, "%d MacAddrEth %s\n",
		pElan->ElanNumber, MacAddrToString(&pElan->MacAddressEth)));
	DBGP((1, "%d MacAddrTr  %s\n",
		pElan->ElanNumber, MacAddrToString(&pElan->MacAddressTr)));

	TRACEOUT(GenerateMacAddress);
	return;
}

PATMLANE_MAC_ENTRY
AtmLaneSearchForMacAddress(
	PATMLANE_ELAN					pElan,
	ULONG							MacAddrType,
	PMAC_ADDRESS					pMacAddress,
	BOOLEAN							CreateNew
)
/*++

Routine Description:

	Search for an MAC Address in the MAC Table. Optionally, create one
	if a match is not found.

	The caller is assumed to hold a lock to the MAC Table.

Arguments:

	pElan					- Pointer to ATMLANE Elan
	MacAddrType				- Type of MAC Addr (MAC vs RD)
	pMacAddress				- what we are looking for
	CreateNew				- Should a new entry be created if no match?

Return Value:

	Pointer to a matching Mac Entry if found (or created anew).

--*/
{
	ULONG					HashIndex;
	PATMLANE_MAC_ENTRY		pMacEntry;
	BOOLEAN					Found;

	TRACEIN(SearchForMacAddress);

	HashIndex = ATMLANE_HASH(pMacAddress);
	Found = FALSE;

	pMacEntry = pElan->pMacTable[HashIndex];

	//
	//  Go through the addresses in this hash list.
	//
	while (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		if (!IS_FLAG_SET(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ABORTING) &&
			(MAC_ADDR_EQUAL(&pMacEntry->MacAddress, pMacAddress)) &&
			(pMacEntry->MacAddrType == MacAddrType))
		{
			Found = TRUE;
			break;
		}
		pMacEntry = pMacEntry->pNextEntry;
	}

	if (!Found && CreateNew && (pElan->AdminState != ELAN_STATE_SHUTDOWN))
	{
		pMacEntry = AtmLaneAllocateMacEntry(pElan);

		if (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
		{
			//
			//  Fill in this new entry.
			//
			NdisMoveMemory(&pMacEntry->MacAddress, pMacAddress, sizeof(MAC_ADDRESS));
			pMacEntry->MacAddrType = MacAddrType;
			AtmLaneReferenceMacEntry(pMacEntry, "table");	// Mac Table linkage

			//
			//  Link it to the hash table.
			//
			pMacEntry->pNextEntry = pElan->pMacTable[HashIndex];
			pElan->pMacTable[HashIndex] = pMacEntry;
			pElan->NumMacEntries++;

			DBGP((1, "%d New MAC %x: %s\n", 
				pElan->ElanNumber,
				pMacEntry,
				MacAddrToString(pMacAddress)));
		}
		else
		{
			DBGP((0, "SearchForMacAddress: alloc of new mac entry failed\n"));
		}
	}

	TRACEOUT(SearchForMacAddress);
	return (pMacEntry);
}

PATMLANE_ATM_ENTRY
AtmLaneSearchForAtmAddress(
	IN	PATMLANE_ELAN				pElan,
	IN	PUCHAR						pAtmAddress,
	IN	ULONG						Type,
	IN	BOOLEAN						CreateNew
)
/*++

Routine Description:

	Search for an ATM Entry that matches the given ATM address and type.
	Optionally, create one if there is no match.

	NOTE: this routine references the ATM entry it returns. The caller
	should deref it.

Arguments:

	pElan					- Pointer to ATMLANE Elan
	pAtmAddress				- ATM Address
	Type					- ATM Entry Type (Peer, LECS, LES, BUS)
	CreateNew				- Do we create a new entry if we don't find one?

Return Value:

	Pointer to a matching ATM Entry if found (or created anew).

--*/
{
	PATMLANE_ATM_ENTRY			pAtmEntry;
	BOOLEAN						Found;

	TRACEIN(SearchForAtmAddress);

	ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

	//
	//  Go through the list of ATM Entries on this interface.
	//
	Found = FALSE;
	for (pAtmEntry = pElan->pAtmEntryList;
			 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
			 pAtmEntry = pAtmEntry->pNext)
	{
		//
		//  Compare the ATM Address and Type
		//
		if ((ATM_ADDR_EQUAL(pAtmAddress, pAtmEntry->AtmAddress.Address)) &&
		     (pAtmEntry->Type == Type) &&
			 ((pAtmEntry->Flags & ATM_ENTRY_WILL_ABORT) == 0))
		{
			Found = TRUE;
			break;
		}
	}

	if (!Found && CreateNew && (pElan->State != ELAN_STATE_SHUTDOWN))
	{
		pAtmEntry = AtmLaneAllocateAtmEntry(pElan);

		if (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			//
			//  Fill in this new entry.
			//
			pAtmEntry->Flags = ATM_ENTRY_VALID;

			//
			//  The ATM Address.
			//
			pAtmEntry->AtmAddress.AddressType = ATM_NSAP;
			pAtmEntry->AtmAddress.NumberOfDigits = ATM_ADDRESS_LENGTH;
			NdisMoveMemory(
					pAtmEntry->AtmAddress.Address,
					pAtmAddress,
					ATM_ADDRESS_LENGTH);

			//
			//	The Type.
			//
			pAtmEntry->Type = Type;

			//
			//  Link in this entry to the Elan
			//
			pAtmEntry->pNext = pElan->pAtmEntryList;
			pElan->pAtmEntryList = pAtmEntry;
			pElan->NumAtmEntries++;


			DBGP((1, "%d New ATM %x: %s\n", 
				pElan->ElanNumber, 
				pAtmEntry,
				AtmAddrToString(pAtmAddress)));
		}
	}

	//
	//  Reference this ATM entry so that it won't be derefed away
	//  before the caller gets to use this.
	//
	if (NULL_PATMLANE_ATM_ENTRY != pAtmEntry)
	{
		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		AtmLaneReferenceAtmEntry(pAtmEntry, "search");
		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
	}

	RELEASE_ELAN_ATM_LIST_LOCK(pElan);

	TRACEOUT(SearchForAtmAddress);
	return (pAtmEntry);
}

ULONG
AtmLaneMacAddrEqual(
	PMAC_ADDRESS			pMacAddr1,
	PMAC_ADDRESS			pMacAddr2
)
/*++

Routine Description:

	Compares two 48bit(6 Byte) MAC Addresses.
	
Arguments:

	pMacAddr1			- First MAC Address.
	pMacAddr2			- Second MAC Address.
	
Return Value:

	1 if equal, 0 if not equal.

--*/
{
	ULONG		Result;

	TRACEIN(MacAddrEqual);

	//
	//	Assume not equal
	//
	Result = 0;
		
	do
	{
		//
		//	Studies have shown the fifth byte to be
		//	the most unique on a network.
		//	
		if (pMacAddr1->Byte[4] != pMacAddr2->Byte[4])
			break;
		if (pMacAddr1->Byte[5] != pMacAddr2->Byte[5])
			break;
		if (pMacAddr1->Byte[3] != pMacAddr2->Byte[3])
			break;
		if (pMacAddr1->Byte[2] != pMacAddr2->Byte[2])
			break;
		if (pMacAddr1->Byte[1] != pMacAddr2->Byte[1])
			break;
		if (pMacAddr1->Byte[0] != pMacAddr2->Byte[0])
			break;
	
		Result = 1;
		break;
	}
	while (FALSE);

	TRACEOUT(MacAddrEqual);
	return Result;
}

VOID
AtmLaneAbortMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Clean up and delete an Mac entry.

	The caller is assumed to hold a lock to the Mac Entry,
	which will be released here.

Arguments:

	pMacEntry		- Pointer to Mac Entry to be deleted.

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
	PATMLANE_MAC_ENTRY *	ppNextMacEntry;
	ULONG					rc;	
	BOOLEAN					Found;
	BOOLEAN					TimerWasRunning;
	ULONG					HashIndex;
	PNDIS_PACKET			pNdisPacket;

	TRACEIN(AbortMacEntry);

	DBGP((1, "%d Del MAC %p: AtmEntry %p, NextToAtm %p, %s\n", 
		pMacEntry->pElan->ElanNumber,
		pMacEntry, pMacEntry->pAtmEntry, pMacEntry->pNextToAtm,
		MacAddrToString(&pMacEntry->MacAddress)));

	//
	//  Initialize.
	//
	rc = pMacEntry->RefCount;
	pElan = pMacEntry->pElan;

	do
	{
		if (IS_FLAG_SET(
			pMacEntry->Flags,
			MAC_ENTRY_STATE_MASK,
			MAC_ENTRY_ABORTING))
		{
			DBGP((1, "%d MAC %x already aborting\n",
				pMacEntry->pElan->ElanNumber,
				pMacEntry));
			
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

		//
		//	Set State to ABORTING
		//
		SET_FLAG(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ABORTING);

		//
		//	Put temp reference on mac entry
		//
		AtmLaneReferenceMacEntry(pMacEntry, "temp");

		//
		//  Reacquire the desired locks in the right order.
		//
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);

		//
		//  Unlink this MAC Entry from the MAC Table
		//
		Found = FALSE;

		HashIndex = ATMLANE_HASH(&pMacEntry->MacAddress);
		ppNextMacEntry = &(pElan->pMacTable[HashIndex]);
		while (*ppNextMacEntry != NULL_PATMLANE_MAC_ENTRY)
		{
			if (*ppNextMacEntry == pMacEntry)
			{
				//
				//  Make the predecessor point to the next
				//  in the list.
				//
				*ppNextMacEntry = pMacEntry->pNextEntry;
				Found = TRUE;
				pElan->NumMacEntries--;
				break;
			}
			else
			{
				ppNextMacEntry = &((*ppNextMacEntry)->pNextEntry);
			}
		}

		if (Found)
		{
			AtmLaneDereferenceMacEntry(pMacEntry, "table");	
		}

		RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);
		RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	
		//
		//  Unlink MAC Entry from the Atm Entry
		//
		if (pMacEntry->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW);

			Found = AtmLaneUnlinkMacEntryFromAtmEntry(pMacEntry);
			pMacEntry->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

			if (Found)
			{
				AtmLaneDereferenceMacEntry(pMacEntry, "atm");
			}
		}

		//
		//  Stop Arp or Aging timer running on the MAC Entry.
		//
		TimerWasRunning = AtmLaneStopTimer(&(pMacEntry->Timer), pElan);
		if (TimerWasRunning)
		{
			AtmLaneDereferenceMacEntry(pMacEntry, "timer");
		}

		//
		//	Stop Bus Timer
		//
		NdisCancelTimer(&pMacEntry->BusTimer, &TimerWasRunning);
		if (TimerWasRunning)
		{	
			AtmLaneDereferenceMacEntry(pMacEntry, "bus timer");
		}

		//
		//	Stop Flush Timer
		//
		TimerWasRunning = AtmLaneStopTimer(&pMacEntry->FlushTimer, pElan);
		if (TimerWasRunning)
		{
			AtmLaneDereferenceMacEntry(pMacEntry, "flush timer");
		}

		//
		//	Now complete all packets hanging on the MacEntry
		//
		DBGP((1, "%d: Aborting MAC %x, Before: PktList %x, PktListCount %d\n",
				pElan->ElanNumber, pMacEntry, pMacEntry->PacketList, pMacEntry->PacketListCount));
		AtmLaneFreePacketQueue(pMacEntry, NDIS_STATUS_SUCCESS);

		DBGP((1, "%d: Aborting MAC %x, After:  PktList %x, PktListCount %d\n",
				pElan->ElanNumber, pMacEntry, pMacEntry->PacketList, pMacEntry->PacketListCount));
		
		//
		//	Remove temp reference and unlock if still around
		//
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "temp");
		if (rc > 0)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
		}
	}
	while (FALSE);

	TRACEOUT(AbortMacEntry);

	return;
}

VOID
AtmLaneMacEntryAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This routine is called if some time has passed since an
	MAC entry was last validated.

	If there is no VC associated with this MAC entry, delete it.
	If there has been no sends on the entry since last validated, delete it.
	Otherwise  revalidate the entry by starting the ARP protocol.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE Mac Entry structure

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;		// Mac Entry that has aged out
	ULONG					rc;				// Ref count on Mac Entry
	PATMLANE_VC				pVc;			// VC going to this Mac Entry
	ULONG					Flags;			// Flags on above VC
	PATMLANE_ELAN			pElan;
	PATMLANE_ATM_ENTRY		pAtmEntry;

	TRACEOUT(MacEntryAgingTimeout);

	pMacEntry = (PATMLANE_MAC_ENTRY)Context;
	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	do
	{
		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	
		DBGP((2, "MacEntryAgingTimeout: pMacEntry %x MacAddr %s\n",
				pMacEntry, MacAddrToString(&pMacEntry->MacAddress)));

		rc = AtmLaneDereferenceMacEntry(pMacEntry, "aging timer");
		if (rc == 0)
		{
			break; 	// It's gone!
		}

		//
		//  Continue only if the Elan is not going down
		//
		pElan = pMacEntry->pElan;
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);
			break;
		}

		pVc = NULL_PATMLANE_VC;
		pAtmEntry = pMacEntry->pAtmEntry;
		if (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			pVc = pAtmEntry->pVcList;
		}


		if (pVc != NULL_PATMLANE_VC &&
			(pMacEntry->Flags & MAC_ENTRY_USED_FOR_SEND) != 0)
		{
			//
			//  There is a VC for this Mac Address and it's been
			//	used for a send in the last aging period.
			//  So we try to revalidate this Mac entry.
			//
			//
			//	Set state to AGED
			//
			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_AGED);

			pMacEntry->Flags &= ~ MAC_ENTRY_USED_FOR_SEND;

			//
			// Send ARP Request
			//
			pMacEntry->RetriesLeft = pElan->MaxRetryCount;
			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			AtmLaneStartTimer(
					pElan,
					&pMacEntry->Timer,
					AtmLaneArpTimeout,
					pElan->ArpResponseTime,
					(PVOID)pMacEntry
					);
			
			AtmLaneSendArpRequest(pElan, pMacEntry);
			//
			//	MAC Entry lock released in above
			//
		}
		else
		{
			//
			//  No VC associated with this Mac Entry or
			//  it hasn't been used in last aging period.
			//	Delete it.
			//
			AtmLaneAbortMacEntry(pMacEntry);
			//
			//  The Mac Entry lock is released in the above routine.
			//
		}

	}
	while (FALSE);

	TRACEOUT(MacEntryAgingTimeout);
	return;		

}


VOID
AtmLaneArpTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response to an ARP Request
	we had sent ages ago in order to resolve/refresh an MAC entry.

	Check if we	have tried enough times. If we have retries left, send another 
	ARP	Request.

	If we have run out of retries, delete the MAC entry, and any VCs going to it.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE MAC Entry structure
	ContextValue		- ignored

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;		// MAC Entry being ARP'ed for.
	PATMLANE_VC				pVc;			// VC to this MAC destination
	PATMLANE_ELAN			pElan;
	ULONG					rc;				// Ref Count on MAC Entry
	ULONG					IsBroadcast;

	TRACEIN(ArpTimeout);

	do
	{
		pMacEntry = (PATMLANE_MAC_ENTRY)Context;
		STRUCT_ASSERT(pMacEntry, atmlane_mac);

		ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

		pElan = pMacEntry->pElan;

		DBGP((2, "ArpTimeout: Mac Entry %x\n", pMacEntry));
				
		rc = AtmLaneDereferenceMacEntry(pMacEntry, "timer");	// Timer reference
		if (rc == 0)
		{
			break;	// It's gone!
		}
		
		//
		//	Retry if any retries left
		//
		if (pMacEntry->RetriesLeft != 0)
		{
			pMacEntry->RetriesLeft--;

			AtmLaneReferenceMacEntry(pMacEntry, "timer");
			
			AtmLaneStartTimer(
						pElan,
						&pMacEntry->Timer,
						AtmLaneArpTimeout,
						pElan->ArpResponseTime,
						(PVOID)pMacEntry
						);

			AtmLaneSendArpRequest(pElan, pMacEntry);
			//
			//	MAC Entry lock released in above
			//
			
			break;
		}


		//
		//	Is this the broadcast/BUS entry?
		//	
		IsBroadcast = (pMacEntry->Flags & MAC_ENTRY_BROADCAST);

		//
		//  We are out of retries. Abort the Mac Entry
		//
		AtmLaneAbortMacEntry(pMacEntry);
		//
		//  lock is released in the above routine
		//

		if (IsBroadcast)
		{
			//
			//	Signal the event to the state machine
			//
			ACQUIRE_ELAN_LOCK(pElan);
			AtmLaneQueueElanEvent(pElan, ELAN_EVENT_ARP_RESPONSE, NDIS_STATUS_TIMEOUT);
			RELEASE_ELAN_LOCK(pElan);
		}
	}
	while (FALSE);
	
	TRACEOUT(ArpTimeout);
	return;
}

VOID
AtmLaneConfigureResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response 
	to an LE_CONFIGURE_REQUEST we sent to the LECS.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE Elan structure

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
	ULONG					rc;

	TRACEIN(ConfigureResponseTimeout);
	
	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	do
	{
		ACQUIRE_ELAN_LOCK_DPC(pElan);
		rc = AtmLaneDereferenceElan(pElan, "timer"); // Timer deref

		if (rc == 0)
		{
			//
			//  The ELAN is gone.
			//
			break;
		}

		AtmLaneQueueElanEvent(pElan, ELAN_EVENT_CONFIGURE_RESPONSE, NDIS_STATUS_TIMEOUT);

		RELEASE_ELAN_LOCK_DPC(pElan);

	}
	while (FALSE);

	TRACEOUT(ConfigureResponseTimeout);
	return;
}


VOID
AtmLaneJoinResponseTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response 
	to an LE_JOIN_REQUEST we sent to the LES.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to our ATMLANE Elan structure

Return Value:

	None

--*/
{
	PATMLANE_ELAN			pElan;
	ULONG					rc;

	TRACEIN(JoinResponseTimeout);
	
	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	do
	{
		ACQUIRE_ELAN_LOCK_DPC(pElan);

		rc = AtmLaneDereferenceElan(pElan, "timer"); // Timer deref

		if (rc == 0)
		{
			//
			//  The ELAN is gone.
			//
			break;
		}

		AtmLaneQueueElanEvent(pElan, ELAN_EVENT_JOIN_RESPONSE, NDIS_STATUS_TIMEOUT);

		RELEASE_ELAN_LOCK_DPC(pElan);
	}
	while (FALSE);

	TRACEOUT(JoinResponseTimeout);
	return;
}

VOID
AtmLaneInitializeMiniportDevice(
	IN	PNDIS_WORK_ITEM				NdisWorkItem,
	IN	PVOID						Context
)
{
	PATMLANE_ELAN			pElan;
	ULONG					rc;
	BOOLEAN					bDontBotherToInit;
	NDIS_STATUS				Status;

	TRACEIN(InitializeMiniportDevice);

	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//  If we are shutting down this ELAN (e.g. because we are
	//  unbinding from the ATM adapter), then don't bother to
	//  initiate MiniportInit.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	if (pElan->AdminState == ELAN_STATE_SHUTDOWN)
	{
		bDontBotherToInit = TRUE;
	}
	else
	{
		bDontBotherToInit = FALSE;
		pElan->Flags |= ELAN_MINIPORT_INIT_PENDING;
		INIT_BLOCK_STRUCT(&pElan->InitBlock);
	}
	RELEASE_ELAN_LOCK(pElan);

	if (!bDontBotherToInit)
	{
		DBGP((1, "%d Miniport INITIALIZING Device %s\n", 
			pElan->ElanNumber,
			UnicodeToString(&pElan->CfgDeviceName)));
	
		Status = NdisIMInitializeDeviceInstanceEx(
					pAtmLaneGlobalInfo->MiniportDriverHandle,
					&pElan->CfgDeviceName,
					(NDIS_HANDLE)pElan);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "%d IMInitializeDeviceInstanceEx failed on ELAN %p (%x)\n",
					pElan->ElanNumber, pElan, Status));

			ACQUIRE_ELAN_LOCK(pElan);
			pElan->Flags &= ~ELAN_MINIPORT_INIT_PENDING;
			SIGNAL_BLOCK_STRUCT(&pElan->InitBlock, NDIS_STATUS_SUCCESS);
			RELEASE_ELAN_LOCK(pElan);
		}
	}

	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "workitem");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	
	TRACEOUT(InitializeMiniportDevice);
	return;
}

VOID
AtmLaneDeinitializeMiniportDevice(
	IN	PNDIS_WORK_ITEM				NdisWorkItem,
	IN	PVOID						Context
)

{
	PATMLANE_ELAN			pElan;
	NDIS_STATUS				Status;
	ULONG					rc;
	NDIS_HANDLE				AdapterHandle;

	TRACEIN(DeinitializeMiniportDevice);

	pElan = (PATMLANE_ELAN)Context;
	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((1, "%d Miniport DEINITIALIZING, AdapterHandle %x, RefCount %d\n",
			pElan->ElanNumber, pElan->MiniportAdapterHandle, pElan->RefCount));

	ACQUIRE_ELAN_LOCK(pElan);

	AdapterHandle = pElan->MiniportAdapterHandle;

	RELEASE_ELAN_LOCK(pElan);

	if (NULL != AdapterHandle)
	{
		DBGP((1, "Will call NdisIMDeInit %x\n", AdapterHandle));
		Status = NdisIMDeInitializeDeviceInstance(AdapterHandle);
		ASSERT(Status == NDIS_STATUS_SUCCESS);
		//
		//  Our MHalt routine will be called at some point.
		//
	}
	//
	//  else our MHalt routine was called already.
	//

	DBGP((0, "DeInit completing, pElan %x, RefCount %d, State %d\n",
			pElan, pElan->RefCount, pElan->State));
	
	ACQUIRE_ELAN_LOCK(pElan);
	rc = AtmLaneDereferenceElan(pElan, "workitem");
	if (rc > 0)
	{
		RELEASE_ELAN_LOCK(pElan);
	}
	
	TRACEOUT(DeinitializeMiniportDevice);
	return;
}

VOID
AtmLaneReadyTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a ready indication
	on a incoming data direct VC.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to an ATMLANE Vc structure

Return Value:

	None

--*/
{
	PATMLANE_VC			pVc;
	PATMLANE_ELAN		pElan;
	ULONG				rc;

	TRACEIN(AtmLaneReadyTimeout);
	
	pVc = (PATMLANE_VC)Context;
	STRUCT_ASSERT(pVc, atmlane_vc);
	pElan = pVc->pElan;
	STRUCT_ASSERT(pElan, atmlane_elan);

	do
	{
	
		ACQUIRE_VC_LOCK(pVc);

		//
		//	Remove ready timer reference
		//
		rc = AtmLaneDereferenceVc(pVc, "ready timer");
		if (rc == 0)
		{
			break;
		}

		//
		//	Vc is still around, check state
		//
		if (!IS_FLAG_SET(
				pVc->Flags,
				VC_CALL_STATE_MASK,
				VC_CALL_STATE_ACTIVE
				))
		{
			RELEASE_VC_LOCK(pVc);
			break;
		}

		//
		//	Check if any retries left
		//
		if (pVc->RetriesLeft--)
		{
			//
			//	Start timer again
			//
			SET_FLAG(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_WAIT
					);
			AtmLaneReferenceVc(pVc, "ready timer");
			AtmLaneStartTimer(	
					pElan, 
					&pVc->ReadyTimer, 
					AtmLaneReadyTimeout, 
					pElan->ConnComplTimer, 
					pVc);
			//
			//	Send Ready Query
			//
			AtmLaneSendReadyQuery(pElan, pVc);
			//
			//	VC lock is released in above.
			//
		}
		else
		{
			//
			//	Give up and mark as having received indication anyway
			//
			SET_FLAG(
					pVc->Flags,
					VC_READY_STATE_MASK,
					VC_READY_INDICATED
					);
			RELEASE_VC_LOCK(pVc);
		}
	}
	while (FALSE);

	TRACEOUT(AtmLaneReadyTimeout);

	return;
}

VOID
AtmLaneFlushTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when we time out waiting for a response to a FLUSH Request.

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to a ATMLANE MAC Entry structure

Return Value:

	None

--*/
{
	PATMLANE_MAC_ENTRY			pMacEntry;
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PATMLANE_VC					pVc;
	PNDIS_PACKET				pNdisPacket;
	ULONG						rc;
	
	TRACEIN(FlushTimeout);
	
	pMacEntry = (PATMLANE_MAC_ENTRY)Context;
	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
	
	do
	{
		if (!IS_FLAG_SET(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_FLUSHING))
		{
			DBGP((0, "%d FlushTimeout: MacEntry %p, bad state, Flags %x\n",
					pMacEntry->pElan->ElanNumber,
					pMacEntry,
					pMacEntry->Flags));
			break;
		}

		if (pMacEntry->pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
		{
			DBGP((0, "%d FlushTimeout: Mac Entry %p, Flags %x, NULL AtmEntry\n",
					pMacEntry->pElan->ElanNumber,
					pMacEntry,
					pMacEntry->Flags));

			SET_FLAG(
					pMacEntry->Flags,
					MAC_ENTRY_STATE_MASK,
					MAC_ENTRY_NEW);

			break;
		}
			
		//
		//	Mark MAC Entry active
		//
		SET_FLAG(
				pMacEntry->Flags,
				MAC_ENTRY_STATE_MASK,
				MAC_ENTRY_ACTIVE);

		//
		//	Send any queued packets
		//
		if (pMacEntry->PacketList == (PNDIS_PACKET)NULL)
		{
			break;
		}

		pVc = pMacEntry->pAtmEntry->pVcList;

		if (pVc == NULL_PATMLANE_VC)
		{
			break;
		}

		ACQUIRE_VC_LOCK(pVc);

		//
		//  Make sure this VC doesn't go away.
		//
		AtmLaneReferenceVc(pVc, "flushtemp");

		RELEASE_VC_LOCK(pVc);
	
		while ((pNdisPacket = AtmLaneDequeuePacketFromHead(pMacEntry)) !=
				(PNDIS_PACKET)NULL)
		{
			//
			//	Send it
			//
			RELEASE_MAC_ENTRY_LOCK(pMacEntry);

			ACQUIRE_VC_LOCK(pVc);
			AtmLaneSendPacketOnVc(pVc, pNdisPacket, TRUE);

			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);
		}

		ACQUIRE_VC_LOCK(pVc);

		rc = AtmLaneDereferenceVc(pVc, "flushtemp");

		if (rc != 0)
		{
			RELEASE_VC_LOCK(pVc);
		}
		break;
	}
	while (FALSE);

	rc = AtmLaneDereferenceMacEntry(pMacEntry, "flush timer");
	if (rc != 0)
	{
		RELEASE_MAC_ENTRY_LOCK(pMacEntry);
	}

	TRACEOUT(FlushTimeout);
	return;
}

VOID
AtmLaneVcAgingTimeout(
	IN	PATMLANE_TIMER				pTimer,
	IN	PVOID						Context
)
/*++

Routine Description:

	This is called when the VC aging timeout fires.
	It will fire if this VC hasn't been used to transmit
	a packet for the timeout period.  The VC will be 
	closed unless it has had receive activity since the last
	timeout.  The data receive path sets a flag if a packet
	has been received.  
	

Arguments:

	pTimer				- Pointer to timer that went off
	Context				- Actually a pointer to a ATMLANE VC structure

Return Value:

	None

--*/
{
	PATMLANE_VC				pVc;			
	ULONG					rc;
	PATMLANE_ELAN			pElan;

	TRACEIN(VcAgingTimeout);

	do
	{
		pVc = (PATMLANE_VC)Context;
		STRUCT_ASSERT(pVc, atmlane_vc);
		ASSERT(IS_FLAG_SET(pVc->Flags, VC_TYPE_MASK, VC_TYPE_SVC));

		ACQUIRE_VC_LOCK(pVc);
		pElan = pVc->pElan;

		//
		//	Continue only if VC still active
		//	Otherwise dereference, unlock it, and return
		//
		if (!(IS_FLAG_SET(pVc->Flags,
						VC_CALL_STATE_MASK,
						VC_CALL_STATE_ACTIVE)))
		{
			rc = AtmLaneDereferenceVc(pVc, "aging timer");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			break;
		}

		//
		//	Continue only if the ELAN isn't going down
		//	Otherwise dereference, unlock it, and return
		//
		if (ELAN_STATE_OPERATIONAL != pElan->AdminState)
		{
			rc = AtmLaneDereferenceVc(pVc, "aging timer");
			if (rc > 0)
			{
				RELEASE_VC_LOCK(pVc);
			}
			break;
		}

		//
		//	If received activity is non-zero, 
		//	clear flag, restart aging timer, release lock
		//	and return
		//
		if (pVc->ReceiveActivity != 0)
		{
			pVc->ReceiveActivity = 0;

			// timer reference still on VC no need to re-reference
			
			AtmLaneStartTimer(
						pElan,
						&pVc->AgingTimer,
						AtmLaneVcAgingTimeout,
						pVc->AgingTime,
						(PVOID)pVc
						);

			DBGP((1, "%d Vc %x aging timer refreshed due to receive activity\n", 
				pVc->pElan->ElanNumber,
				pVc));

						
			RELEASE_VC_LOCK(pVc);
			break;
		}

		//
		//	VC is to be closed
		//
		DBGP((1, "%d Vc %x aged out\n", 
			pVc->pElan->ElanNumber,
			pVc));

		
		DBGP((3, "VcAgingTimeout: Vc %x RefCount %d Flags %x pAtmEntry %x\n",
			pVc, pVc->RefCount, pVc->Flags, pVc->pAtmEntry));

		//
		//	Remove timer reference and return if refcount goes to zero
		//
		rc = AtmLaneDereferenceVc(pVc, "aging timer");
		if (rc == 0)
		{
			break;
		}

		//
		//  Take this VC out of the VC list for this ATM destination
		//	and return if refcount goes to zero
		//
		if (pVc->pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
		{
			if (AtmLaneUnlinkVcFromAtmEntry(pVc))
			{
				rc = AtmLaneDereferenceVc(pVc, "atm");
				if (rc == 0)
				{
					break;
				}
			}
		}

		//
		//  Close this VC
		//
		AtmLaneCloseCall(pVc);
		//
		//  The VC lock is released in CloseCall
		//
	} while (FALSE);
	
	
	TRACEOUT(VcAgingTimeout);
	return;
}


VOID
AtmLaneShutdownElan(
	IN	PATMLANE_ELAN				pElan		LOCKIN	NOLOCKOUT,
	IN	BOOLEAN						Restart
)
/*++

Routine Description:

	This routine will "shutdown" an ELAN prior to it going back
	to the Initial state or driver shutdown.  The caller is 
	expected to hold the ELAN lock and it will be released here.
	
Arguments:

	pElan				- Pointer to an ATMLANE Elan structure.
	Restart				- If TRUE ELAN should restart at Initial state.
						  If FALSE ELAN should not restart.
						  
Return Value:

	None

--*/

{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_ATM_ENTRY		pNextAtmEntry;
	PATMLANE_MAC_ENTRY		pMacEntry;
	ULONG					rc;
	ULONG					i;
	BOOLEAN					WasCancelled;
	NDIS_STATUS				Status;
	NDIS_HANDLE				NdisAfHandle;
	BOOLEAN					bTempRef;

	TRACEIN(ShutdownElan);
	STRUCT_ASSERT(pElan, atmlane_elan);

	//
	//  Add a temp ref
	//
	bTempRef = TRUE;
	AtmLaneReferenceElan(pElan, "tempshutdown");

    do
    {
        DBGP((0, "%d ShutDownElan pElan %p/%x, Ref %d State %d, Restart %d\n",
			pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, pElan->State,
			Restart));

        //
        //  If state already == SHUTDOWN nothing to do
        //
        if (ELAN_STATE_SHUTDOWN == pElan->State)
        {
            RELEASE_ELAN_LOCK(pElan);
            break;
        }

        //
        //  If we are transitioning from operational to shutdown,
        //  and our miniport is active, then indicate a media disconnect
        //  event.
        //
        if (pElan->State == ELAN_STATE_OPERATIONAL &&
        	pElan->MiniportAdapterHandle != NULL)
        {
        	NdisMIndicateStatus(
        		pElan->MiniportAdapterHandle,
        		NDIS_STATUS_MEDIA_DISCONNECT,
        		NULL,
        		0);
        	
        	NdisMIndicateStatusComplete(pElan->MiniportAdapterHandle);
        }
            
		//
		//	Change state to shutdown.  If restarting state will
		//	be changed back to init after cleanup below.
		//
		pElan->AdminState = ELAN_STATE_SHUTDOWN;
	    pElan->State = ELAN_STATE_SHUTDOWN;

	    //
	    //  Wait for any pending OpenAF operation to finish.
	    //
	    while (pElan->Flags & ELAN_OPENING_AF)
	    {
			RELEASE_ELAN_LOCK(pElan);

			DBGP((0, "%d: Shutdown Elan %p/%x is opening AF\n",
					pElan->ElanNumber, pElan, pElan->Flags));

			(VOID)WAIT_ON_BLOCK_STRUCT(&pElan->AfBlock);

			ACQUIRE_ELAN_LOCK(pElan);
		}

	    NdisAfHandle = pElan->NdisAfHandle;
	    pElan->NdisAfHandle = NULL;

	    if (Restart)
	    {
	    	pElan->Flags |= ELAN_NEEDS_RESTART;
	    }

	    //
	    //  Are we waiting for MiniportInitialize to run and finish?
	    //  If so, try to cancel IMInit.
	    //
	    if (pElan->Flags & ELAN_MINIPORT_INIT_PENDING)
	    {
			RELEASE_ELAN_LOCK(pElan);

			Status = NdisIMCancelInitializeDeviceInstance(
						pAtmLaneGlobalInfo->MiniportDriverHandle,
						&pElan->CfgDeviceName);

			DBGP((0, "%d ShutdownElan Elan %p/%x, Ref %d, CancelInit returned %x\n",
						pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, Status));

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				//  Canceled the IMInit process.
				//
				ACQUIRE_ELAN_LOCK(pElan);
				pElan->Flags &= ~ELAN_MINIPORT_INIT_PENDING;
			}
			else
			{
				//
				//  Our MiniportInit function -will- be called.
				//  Wait for it to finish.
				//
				(VOID)WAIT_ON_BLOCK_STRUCT(&pElan->InitBlock);
				DBGP((2, "%d: Shutdown ELAN %p, Flags %x, woke up from InitBlock\n",
							pElan->ElanNumber, pElan, pElan->Flags));
				ACQUIRE_ELAN_LOCK(pElan);
				ASSERT((pElan->Flags & ELAN_MINIPORT_INIT_PENDING) == 0);
			}
		}
	    
	    //
	    //	Stop any timers running on the elan.
	    //

	    if (AtmLaneStopTimer(&pElan->Timer, pElan))
	    {
		    rc = AtmLaneDereferenceElan(pElan, "timer"); // Timer ref
		    ASSERT(rc > 0);
	    }

	    if (NULL != pElan->pDelayedEvent)
	    {
	    	BOOLEAN		TimerCancelled;

	    	NdisCancelTimer(
	    		&pElan->pDelayedEvent->DelayTimer,
	    		&TimerCancelled);

			DBGP((0, "ATMLANE: %d ShutdownElan %p, DelayedEvent %p, Cancelled %d\n",
						pElan->ElanNumber,
						pElan,
						pElan->pDelayedEvent,
						TimerCancelled));

	    	if (TimerCancelled)
	    	{
				FREE_MEM(pElan->pDelayedEvent);
				pElan->pDelayedEvent = NULL;

	    		rc = AtmLaneDereferenceElan(pElan, "delayeventcancel");
	    		ASSERT(rc > 0);
	    	}
	    }

	    RELEASE_ELAN_LOCK(pElan);

	    //
	    //	Deregister all SAPs. 
	    //
	    AtmLaneDeregisterSaps(pElan);
		
	    //
	    //	Abort all MAC table entries.
	    //
	    for (i = 0; i < ATMLANE_MAC_TABLE_SIZE; i++)
	    {
		    ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		    while (pElan->pMacTable[i] != NULL_PATMLANE_MAC_ENTRY)
		    {
			    pMacEntry = pElan->pMacTable[i];

			    //
			    //  Place a temp ref so that this won't go away
			    //  when we release the MAC table lock.
			    //
			    ACQUIRE_MAC_ENTRY_LOCK_DPC(pMacEntry);
			    AtmLaneReferenceMacEntry(pMacEntry, "ShutDownTemp");
			    RELEASE_MAC_ENTRY_LOCK_DPC(pMacEntry);

			    RELEASE_ELAN_MAC_TABLE_LOCK(pElan);

			    ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

			    //
			    //  Remove the temp ref
			    //
			    rc = AtmLaneDereferenceMacEntry(pMacEntry, "ShutDownTemp");
			    if (rc != 0)
			    {
					AtmLaneAbortMacEntry(pMacEntry);
					//
					//  MAC Entry Lock is released within the above.
					//
			    }
			    //
			    //  else the MAC entry is gone.
			    //

			    ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan);
		    }
			RELEASE_ELAN_MAC_TABLE_LOCK(pElan);
	    }

	    //
	    //  Abort all ATM Entries.
	    //

		//  First, run through the list and reference
	    //  all of them first, so that we don't
	    //  skip to an invalid pointer when aborting the entries.
	    //
	    ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

	    for (pAtmEntry = pElan->pAtmEntryList;
	    	 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
	    	 pAtmEntry = pNextAtmEntry)
	    {
			ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

			pAtmEntry->Flags |= ATM_ENTRY_WILL_ABORT;
	    	AtmLaneReferenceAtmEntry(pAtmEntry, "tempS");
	    	pNextAtmEntry = pAtmEntry->pNext;

			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		}

		//
		//  Now, do the actual abort.
		//
	    pAtmEntry = pElan->pAtmEntryList;
	    while (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
	    {
		    RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		    ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
		    pNextAtmEntry = pAtmEntry->pNext;
		    AtmLaneInvalidateAtmEntry(pAtmEntry);
		    //
		    //  The ATM Entry lock is released within the above.
		    //

		    ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
		    pAtmEntry = pNextAtmEntry;
	    }

	    //
	    //  Remove all temp references.
	    //
	    for (pAtmEntry = pElan->pAtmEntryList;
	    	 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
	    	 pAtmEntry = pNextAtmEntry)
	    {
		    RELEASE_ELAN_ATM_LIST_LOCK(pElan);

			ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

			ASSERT(pAtmEntry->Flags & ATM_ENTRY_WILL_ABORT);
			pAtmEntry->Flags &= ~ATM_ENTRY_WILL_ABORT;

	    	pNextAtmEntry = pAtmEntry->pNext;

	    	rc = AtmLaneDereferenceAtmEntry(pAtmEntry,"tempS");
	    	if (rc != 0)
	    	{
	    		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	    	}

		    ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
		}

	    RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		//
		//  Remove the temp ref
		//
		STRUCT_ASSERT(pElan, atmlane_elan);
		bTempRef = FALSE;
	    ACQUIRE_ELAN_LOCK(pElan);
	    rc = AtmLaneDereferenceElan(pElan, "tempshutdown");
	    if (rc == 0)
	    {
	    	break;
	    }
	    RELEASE_ELAN_LOCK(pElan);

	    if (NULL != NdisAfHandle)
	    {
	    	Status = NdisClCloseAddressFamily(NdisAfHandle);
	    	if (NDIS_STATUS_PENDING != Status)
	    	{
	    		AtmLaneCloseAfCompleteHandler(Status, (NDIS_HANDLE)pElan);
	    	}
	    }
	    else
	    {
	    	AtmLaneContinueShutdownElan(pElan);
	    }

	} while (FALSE);
	

	if (bTempRef)
	{
	    ACQUIRE_ELAN_LOCK(pElan);
	    rc = AtmLaneDereferenceElan(pElan, "tempshutdown");
	    if (rc != 0)
	    {
	    	RELEASE_ELAN_LOCK(pElan);
	    }
	}

	TRACEOUT(ShutdownElan);

	return;
}

VOID
AtmLaneContinueShutdownElan(
	IN	PATMLANE_ELAN			pElan
	)
/*++

Routine Description:

	This routine continues the shutting down process for an ELAN,
	after the Af handle with the Call Manager has been closed.

Arguments:

	pElan	- the ELAN being shutdown.

Return Value:

	None.
--*/
{
	ULONG		rc;

	TRACEIN(ContinueShutdownElan);

	DBGP((0, "%d ContinueShutdown ELAN %x Flags 0x%x State %d\n",
				pElan->ElanNumber,
				pElan,
				pElan->Flags,
				pElan->State));

	do
	{
	    if (pElan->Flags & ELAN_NEEDS_RESTART)
	    {
		    ACQUIRE_ELAN_LOCK(pElan);
			//
			//	Change state to INIT
			//
			pElan->AdminState = ELAN_STATE_OPERATIONAL;
 		    pElan->State = ELAN_STATE_INIT;
		    pElan->RetriesLeft = 4;

		    pElan->Flags &= ~ELAN_NEEDS_RESTART;

		    //
		    //  Clear out the local ATM address so that we start off the
		    //  ELAN properly when we obtain it from the Call manager.
		    //
		    NdisZeroMemory(&pElan->AtmAddress, sizeof(ATM_ADDRESS));

			//
            //  Empty the event queue and schedule a restart in a little while
            //	
			AtmLaneDrainElanEventQueue(pElan);
		    AtmLaneQueueElanEventAfterDelay(pElan, ELAN_EVENT_START, 0, 2*1000);

		    RELEASE_ELAN_LOCK(pElan);
	    }
	    else
	    {
            //
            //  Completely remove the ELAN
            //
		    AtmLaneUnlinkElanFromAdapter(pElan);
		    
    	    ACQUIRE_ELAN_LOCK(pElan);

    	    //
    	    //	Add workitem reference and remove adapter reference
    	    //
    	    AtmLaneReferenceElan(pElan, "workitem");
    	    rc = AtmLaneDereferenceElan(pElan, "adapter");

	        //
	        //  We are here for one of the following reasons:
	        //
	        //  1. Unbinding from an ATM adapter
	        //  2. The CM asked us to shut down the AF open on an ATM adapter
	        //  3. The virtual miniport was halted.
	        //
	        //  If it isn't case (3), then we should make sure that the miniport
	        //  gets halted, by calling NdisIMDeInitializeDeviceInstance.
	        //

		    if (pElan->MiniportAdapterHandle != NULL)
		    {

				DBGP((1, "%d ContinueShutdown: pElan x%x, scheduling NdisIMDeInit, Handle %x\n",
				        pElan->ElanNumber, pElan, pElan->MiniportAdapterHandle));
				        
		    	//
				//	Schedule a PASSIVE_LEVEL thread to call
				//	NdisIMInitializeDeviceInstance
				//
				NdisInitializeWorkItem(
						&pElan->NdisWorkItem,
						AtmLaneDeinitializeMiniportDevice,
						pElan);

				//	workitem reference already on Elan from above
				
				NdisScheduleWorkItem(&pElan->NdisWorkItem);

				RELEASE_ELAN_LOCK(pElan);
			}
			else
			{
				// 
				// 	Just remove workitem reference and unlock if Elan still around
				//
				rc = AtmLaneDereferenceElan(pElan, "workitem");
				if (rc > 0)
					RELEASE_ELAN_LOCK(pElan);
			}
		}

		break;

	}
	while (FALSE);

	TRACEOUT(ContinueShutdownElan);
	return;
}


VOID
AtmLaneGetProtocolConfiguration(
	IN	NDIS_HANDLE				AdapterConfigHandle,
	IN	PATMLANE_ADAPTER		pAdapter
	)
/*++

Routine Description:

	This routine will attempt to get any ATMLANE protocol specific
	configuration information optionally stored under an adapter's
	registry parameters.  

Arguments:

	AdapterConfigHandle	- the handle that was returned by
						  AtmLaneOpenAdapterConfiguration.
	pAdapter			- Pointer to ATMLANE adapter structure.

Return Value:

	None.
	
--*/
{
	NDIS_STATUS						Status;
	PNDIS_CONFIGURATION_PARAMETER 	ParameterValue;
	ATM_ADDRESS						LecsAddress;
	NDIS_STRING						ValueName;
	PATMLANE_NAME *					ppNext;
	PATMLANE_NAME					pName;
	PWSTR							pTempStr;
	USHORT							StrLength;
	
	TRACEIN(GetProtocolConfiguration);

	//
	//	Get the UpperBindings parameter (it will only exist on Memphis)
	//
	NdisInitUnicodeString(&ValueName, ATMLANE_UPPERBINDINGS_STRING);
	NdisReadConfiguration(
		&Status,
		&ParameterValue,
		AdapterConfigHandle,
		&ValueName,
		NdisParameterString);
	if (NDIS_STATUS_SUCCESS == Status)
	{
		//	Copy the string into adapter struct

		(VOID)AtmLaneCopyUnicodeString(
				&(pAdapter->CfgUpperBindings),
				&(ParameterValue->ParameterData.StringData),
				TRUE,
				FALSE);
		DBGP((1, "GetProtocolConfiguration: UpperBindings %s\n",
			UnicodeToString(&pAdapter->CfgUpperBindings)));
		
		//
		//  Existence of this parameter is a definite clue we're running
		//  on Memphis/Win98
		//
		pAdapter->RunningOnMemphis = TRUE;
	}

    //
    //  Get the ElanName parameter (it will only exist on Memphis)
    //
	NdisInitUnicodeString(&ValueName, ATMLANE_ELANNAME_STRING);
	NdisReadConfiguration(
		&Status,
		&ParameterValue,
		AdapterConfigHandle,
		&ValueName,
		NdisParameterString);
	if (NDIS_STATUS_SUCCESS == Status)
	{

		//	Copy the string into adapter struct

		(VOID)AtmLaneCopyUnicodeString(
				&(pAdapter->CfgElanName),
				&(ParameterValue->ParameterData.StringData),
				TRUE,
				FALSE);
		DBGP((1, "GetProtocolConfiguration: ElanName %s\n",
			UnicodeToString(&pAdapter->CfgElanName)));

		//
		//  Existence of this parameter is definite clue we're running
		//  on Memphis/Win98
		//
		pAdapter->RunningOnMemphis = TRUE;
	}

	//
	//	If on Win98 we have to parse the upper bindings and elan name strings
	//

	if (pAdapter->RunningOnMemphis)
	{
		// cut up the upper bindings string

		ppNext = &(pAdapter->UpperBindingsList);
		pTempStr = AtmLaneStrTok(pAdapter->CfgUpperBindings.Buffer, L',', &StrLength);

		do
		{
			*ppNext = NULL;

			if (pTempStr == NULL)
			{
				break;
			}

			ALLOC_MEM(&pName, sizeof(ATMLANE_NAME));

			if (pName == NULL)
			{
				break;
			}

			pName->Name.Buffer = pTempStr;
			pName->Name.MaximumLength = StrLength+1;
			pName->Name.Length = StrLength;

			*ppNext = pName;
			ppNext = &(pName->pNext);
		
			pTempStr = AtmLaneStrTok(NULL, L',', &StrLength);

		} while (TRUE);


		// cut up the elan name string

		ppNext = &(pAdapter->ElanNameList);
		pTempStr = AtmLaneStrTok(pAdapter->CfgElanName.Buffer, L',', &StrLength);

		do
		{
			*ppNext = NULL;

			if (pTempStr == NULL)
			{
				break;
			}

			ALLOC_MEM(&pName, sizeof(ATMLANE_NAME));
			
			if (pName == NULL)
			{
				break;
			}

			pName->Name.Buffer = pTempStr;
			pName->Name.MaximumLength = StrLength+1;
			pName->Name.Length = StrLength;

			*ppNext = pName;
			ppNext = &(pName->pNext);
		
			pTempStr = AtmLaneStrTok(NULL, L',', &StrLength);

		} while (TRUE);
		
	}

	TRACEOUT(GetProtocolConfiguration);

	return;
}

VOID
AtmLaneGetElanConfiguration(
	IN	PNDIS_STRING			pElanKey,
	IN	PATMLANE_ELAN			pElan
	)
/*++

Routine Description:

	This routine will first initialize the configuration parameters
	for the specified ELAN.   Then it will attempt to get any ELAN
	configuration information optionally stored	under the ELAN's
	registry key.

Arguments:

    pElanKey            - UNICODE string containing ELAN's 
                          registry key

Return Value:

	None.
	
--*/
{
	NDIS_STATUS						Status;
	PNDIS_CONFIGURATION_PARAMETER 	ParameterValue;
	NDIS_STRING						ValueName;
	ANSI_STRING						TempAnsiString;
	ATM_ADDRESS						LecsAddress;
	NDIS_HANDLE                     AdapterConfigHandle;
	NDIS_HANDLE                     ElanListConfigHandle;
	NDIS_HANDLE                     ElanConfigHandle;
	NDIS_HANDLE						CommonConfigHandle;
	NDIS_STRING				        ElanListKeyName;
	PATMLANE_NAME					pName;
	ULONG							Index;
	
	TRACEIN(GetElanConfiguration);

	//
	//	Init handles to null for proper cleanup later
	//
	AdapterConfigHandle = NULL_NDIS_HANDLE;
	ElanListConfigHandle = NULL_NDIS_HANDLE;
	ElanConfigHandle = NULL_NDIS_HANDLE;

    //
    //  Init some defaults
    //
	pElan->CfgUseLecs = TRUE;
	pElan->CfgDiscoverLecs = TRUE;
	pElan->CfgLecsAddress = gWellKnownLecsAddress;

    do
    {
    	//
    	//  Open the AtmLane protocol configuration section for this adapter.
    	//	This must succeed on NT and Win98.
    	//
       	NdisOpenProtocolConfiguration(
	    			&Status,
		    		&AdapterConfigHandle,
			    	&pElan->pAdapter->ConfigString
	    			);
    
	    if (NDIS_STATUS_SUCCESS != Status)
	    {
		    AdapterConfigHandle = NULL_NDIS_HANDLE;
			DBGP((0, "GetElanConfiguration: OpenProtocolConfiguration failed\n"));
			Status = NDIS_STATUS_OPEN_FAILED;
			break;
	    }


		//
		//	If running on Win98 we will get ELAN config info from the
		//	adapter's parameters.  For NT we will get ELAN config info
		//	from the ELAN's own parameters.
		//
    	if (pElan->pAdapter->RunningOnMemphis)
    	{
			//
			//	Use the adapter's config handle
			//    	
			CommonConfigHandle = AdapterConfigHandle;
    	}
    	else
		{
	    	//
		    //	Open the Elan List configuration key.
	        //
	        NdisInitUnicodeString(&ElanListKeyName, ATMLANE_ELANLIST_STRING);

	       	NdisOpenConfigurationKeyByName(
			        &Status,
					AdapterConfigHandle,
	    			&ElanListKeyName,
					&ElanListConfigHandle);

		    if (NDIS_STATUS_SUCCESS != Status)
		    {
	            ElanListConfigHandle = NULL_NDIS_HANDLE;
	            DBGP((0, "GetElanConfiguration: Failed open of ElanList key\n"));
	            Status = NDIS_STATUS_FAILURE;
	            break;
	        }

    		//
		    //  Open ELAN key
		    //
			NdisOpenConfigurationKeyByName(
			        &Status,
					ElanListConfigHandle,
					pElanKey,
					&ElanConfigHandle);

		    if (NDIS_STATUS_SUCCESS != Status)
		    {
	            ElanConfigHandle = NULL_NDIS_HANDLE;
	            DBGP((0, "GetElanConfiguration: Failed open of ELAN key\n"));
	            Status = NDIS_STATUS_FAILURE;
	            break;
	        }

			//
			//	Use the ELAN's config handle
			//
			CommonConfigHandle = ElanConfigHandle;
	        
		}

		//
		//	Get the UseLECS parameter
		//
		NdisInitUnicodeString(&ValueName, ATMLANE_USELECS_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgUseLecs = 
				(ParameterValue->ParameterData.IntegerData == 0) ? FALSE : TRUE;
			DBGP((1, "%d UseLECS = %s\n", 
				pElan->ElanNumber,
				pElan->CfgUseLecs?"TRUE":"FALSE"));
		}

		//
		//	Get the DiscoverLECS parameter
		//
		NdisInitUnicodeString(&ValueName, ATMLANE_DISCOVERLECS_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgDiscoverLecs = 
				(ParameterValue->ParameterData.IntegerData == 0) ? FALSE : TRUE;
			DBGP((1, "%d DiscoverLECS = %s\n",
					pElan->ElanNumber,
					pElan->CfgDiscoverLecs?"TRUE":"FALSE"));
		}

		//
		//	Get the LECS Address (only if Discover LECS is FALSE)
		//
		if (FALSE == pElan->CfgDiscoverLecs)
		{
			NdisInitUnicodeString(&ValueName, ATMLANE_LECSADDR_STRING);
			NdisReadConfiguration(
				&Status,
				&ParameterValue,
				CommonConfigHandle,
				&ValueName,
				NdisParameterString);
			if (NDIS_STATUS_SUCCESS == Status)
			{
				NdisConvertStringToAtmAddress(
					&Status,
					&ParameterValue->ParameterData.StringData,
					&LecsAddress);
				if (NDIS_STATUS_SUCCESS == Status)
				{
					pElan->CfgLecsAddress = LecsAddress;
					DBGP((1, "%d LECSAddr = %s\n",
						pElan->ElanNumber,
						AtmAddrToString(pElan->CfgLecsAddress.Address)));
				}
			}
		}

    	//
		//	Get the DeviceName parameter (different on NT5 and Memphis/Win98)
		//
    	if (!pElan->pAdapter->RunningOnMemphis)
    	{
        	//
        	//  NT5
        	//    
    		NdisInitUnicodeString(&ValueName, ATMLANE_DEVICE_STRING);
    		NdisReadConfiguration(
    				&Status,
    				&ParameterValue,
    				ElanConfigHandle,
    				&ValueName,
    				NdisParameterString);
    		if (NDIS_STATUS_SUCCESS == Status)
    		{
    			//
    			//	Copy into Elan struct.
    			//
				(VOID)AtmLaneCopyUnicodeString(
					&(pElan->CfgDeviceName),
					&(ParameterValue->ParameterData.StringData),
					TRUE,
					FALSE);
    		}
    	}
    	else
    	{
    	    //
        	//  Memphis/Win98
        	//
        	//
        	//	Index to this elan's device name string
        	//
			pName = pElan->pAdapter->UpperBindingsList;
			Index = pElan->ElanNumber;
			while (Index > 0)
			{
				ASSERT(pName != NULL);
				pName = pName->pNext;
				Index--;
			}
   
			//
			//	Copy it to the Elan CfgDeviceName string
			//
			(VOID)AtmLaneCopyUnicodeString(
				&(pElan->CfgDeviceName),
				&(pName->Name),
				TRUE,
				FALSE);
    	}	
 		DBGP((1, "%d Device Name = %s\n",
			pElan->ElanNumber,
			UnicodeToString(&pElan->CfgDeviceName)));
   

		//
		//	Get the ELANName Parameter (different on NT5 and Memphis/Win98
		//
    	if (!pElan->pAdapter->RunningOnMemphis)
    	{
        	//
        	//  NT5
        	//    
	    	NdisInitUnicodeString(&ValueName, ATMLANE_ELANNAME_STRING);
	    	NdisReadConfiguration(
			    	&Status,
			    	&ParameterValue,
			    	ElanConfigHandle,
			    	&ValueName,
			    	NdisParameterString);

	    	if (NDIS_STATUS_SUCCESS != Status)
	    	{
	    		NDIS_STRING	DefaultNameString = NDIS_STRING_CONST("");

    			//
    			//	Copy into the Elan data structure.
    			//
    			if (!AtmLaneCopyUnicodeString(
					&(pElan->CfgElanName),
					&DefaultNameString,
					TRUE,
					FALSE))
				{
					Status = NDIS_STATUS_RESOURCES;
					break;
				}

				Status = NDIS_STATUS_SUCCESS;
			}
			else
    		{
    			//
    			//	Copy into the Elan data structure.
    			//
    			if (!AtmLaneCopyUnicodeString(
					&(pElan->CfgElanName),
					&(ParameterValue->ParameterData.StringData),
					TRUE,
					FALSE))
				{
					Status = NDIS_STATUS_RESOURCES;
					break;
				}
			}
  			
    		//
			//	Convert it to ANSI and copy into run-time Elan variable
			//
			TempAnsiString.Length = 0;
			TempAnsiString.MaximumLength = 32;
			TempAnsiString.Buffer = pElan->ElanName;

			NdisUnicodeStringToAnsiString(
		    		&TempAnsiString,
			    	&pElan->CfgElanName);

			pElan->ElanNameSize = (UCHAR) TempAnsiString.Length;
    	}
    	else
   		{
        	//
        	//  Memphis/Win98
			//
  			DBGP((2, "GetElanConfiguration: Getting Elan Name for Win98\n"));

	      	//
        	//	Index to this elan's name string
        	//
			pName = pElan->pAdapter->ElanNameList;
			Index = pElan->ElanNumber;
			while (Index > 0 && pName != NULL)
			{
				pName = pName->pNext;
				Index--;
			}
   
			//
			//	Copy it to the Elan CfgElanName string
			//
			if (pName != NULL)
			{
				DBGP((2, "GetElanConfiguration: Using Elan Name at 0x%x\n", pName->Name.Buffer));

				(VOID)AtmLaneCopyUnicodeString(
					&(pElan->CfgElanName),
					&(pName->Name),
					TRUE,
					FALSE);

 				//
   				//	Convert it to ANSI and copy into run-time Elan variable
   				//
   				TempAnsiString.Length = 0;
   				TempAnsiString.MaximumLength = 32;
   				TempAnsiString.Buffer = pElan->ElanName;
    
    			NdisUnicodeStringToAnsiString(
	    			&TempAnsiString,
		    		&pName->Name);

   				pElan->ElanNameSize = (UCHAR) TempAnsiString.Length;
  			}
  		}
	   	DBGP((1, "%d ELAN Name = %s\n",
			pElan->ElanNumber,
			UnicodeToString(&pElan->CfgElanName)));


		//
		//	Get the LAN type.
		//
		pElan->CfgLanType = LANE_LANTYPE_UNSPEC;
		NdisInitUnicodeString(&ValueName, ATMLANE_LANTYPE_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgLanType = (UCHAR) ParameterValue->ParameterData.IntegerData;
			DBGP((1, "%d LAN Type = %u\n", 
					ParameterValue->ParameterData.IntegerData));
		}

		if (pElan->CfgLanType > LANE_LANTYPE_TR)
		{
			pElan->CfgLanType = LANE_LANTYPE_UNSPEC;
		}
		DBGP((1, "%d LAN Type = %u\n", pElan->ElanNumber, pElan->CfgLanType));

		//
		//	Get the Max Frame Size.
		//
		pElan->CfgMaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_UNSPEC;
		NdisInitUnicodeString(&ValueName, ATMLANE_MAXFRAMESIZE_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterInteger);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			pElan->CfgMaxFrameSizeCode = (UCHAR) ParameterValue->ParameterData.IntegerData;
		}

		if (pElan->CfgMaxFrameSizeCode > LANE_MAXFRAMESIZE_CODE_18190)
		{
			pElan->CfgMaxFrameSizeCode = LANE_MAXFRAMESIZE_CODE_UNSPEC;
		}
		DBGP((1, "%d MaxFrameSize Code = %u\n", 
			pElan->ElanNumber, 
			pElan->CfgMaxFrameSizeCode));

		//
		//	Get the LES Address
		//
		NdisZeroMemory(&pElan->CfgLesAddress, sizeof(ATM_ADDRESS));
		NdisInitUnicodeString(&ValueName, ATMLANE_LESADDR_STRING);
		NdisReadConfiguration(
			&Status,
			&ParameterValue,
			CommonConfigHandle,
			&ValueName,
			NdisParameterString);
		if (NDIS_STATUS_SUCCESS == Status)
		{
			NdisConvertStringToAtmAddress(
				&Status,
				&ParameterValue->ParameterData.StringData,
				&pElan->CfgLesAddress);
				DBGP((1, "%d LESAddr = %s\n",
					pElan->ElanNumber,
					AtmAddrToString(pElan->CfgLesAddress.Address)));
		}
	
		//
		//	Get the HeaderBufSize
		//
		pElan->HeaderBufSize = DEF_HEADER_BUF_SIZE;
	
		//
		//	Round the "real" HeaderBufSize up to mult of 4.
		//
		pElan->RealHeaderBufSize = (((pElan->HeaderBufSize + 3) / 4) * 4);

	
		//
		//	Get the MaxHeaderBufs
		//
		pElan->MaxHeaderBufs = DEF_MAX_HEADER_BUFS;

		//
		//	Make max pad buffers same as header buffers
		//
		pElan->MaxPadBufs = pElan->MaxHeaderBufs;
		//
		//	PadBufSize not configurable - but make it multiple of 4
		//
		pElan->PadBufSize = MAX(LANE_MIN_ETHPACKET, LANE_MIN_TRPACKET);
		pElan->PadBufSize = (((pElan->PadBufSize + 3) / 4) * 4);
		
		
		//
		//	ProtocolBufSize not configurable.
		//
		pElan->ProtocolBufSize = ROUND_OFF(DEF_PROTOCOL_BUF_SIZE);

		//
		//	Get the MaxProtocolBufs
		//
		pElan->MaxProtocolBufs = DEF_MAX_PROTOCOL_BUFS;

	} while (FALSE);

	//
	//	Close config handles
	//		
	if (NULL_NDIS_HANDLE != ElanConfigHandle)
	{
		NdisCloseConfiguration(ElanConfigHandle);
		ElanConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != ElanListConfigHandle)
	{
		NdisCloseConfiguration(ElanListConfigHandle);
		ElanListConfigHandle = NULL_NDIS_HANDLE;
	}
	if (NULL_NDIS_HANDLE != AdapterConfigHandle)
	{
	    NdisCloseConfiguration(AdapterConfigHandle);
		AdapterConfigHandle = NULL_NDIS_HANDLE;
	}

	TRACEOUT(GetElanConfiguration);

	return;
}

VOID
AtmLaneQueueElanEventAfterDelay(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus,
	IN	ULONG					DelayMs
	)
/*++

Routine Description:

	Queue an ELAN event on the ELAN's event queue after
	a specified delay. Caller is assumed to hold the ELAN
	lock.

Arguments:

    pElan				- Pointer to ELAN structure.
    Event				- Event code.
    EventStatus			- Status related to event.
    DelayMs				- Time to wait before queueing this event.

Return Value:

	None.
	
--*/
{	
	PATMLANE_DELAYED_EVENT	pDelayedEvent;
	PATMLANE_EVENT			pEvent;

	TRACEIN(QueueElanEventAfterDelay);

	do
	{
		//
		//	If the ELAN is being shut down, don't queue any events.
		//
		if (ELAN_STATE_SHUTDOWN == pElan->AdminState)
		{
			DBGP((0, "QueueElanEventAfterDelay: Not queuing event (ELAN shutdown)\n"));
			break;
		}

		if (NULL != pElan->pDelayedEvent)
		{
			DBGP((0, "QueueElanEventAfterDelay: Not queueing event %d (ELAN %x/%x already has one)\n",
					Event, pElan, pElan->Flags));
			DBGP((0, "QueueElanEventAfterDelay: ELAN %x: existing event %d\n",
						pElan, pElan->pDelayedEvent->DelayedEvent.Event));

			//
			//  Make sure we don't drop an ELAN_EVENT_STOP on the floor!
			//
			if (Event == ELAN_EVENT_STOP)
			{
				pElan->pDelayedEvent->DelayedEvent.Event = ELAN_EVENT_STOP;
			}

			break;
		}

		//
		//	Alloc an event struct and a timer struct.
		//
		ALLOC_MEM(&pDelayedEvent, sizeof(ATMLANE_DELAYED_EVENT));
		if ((PATMLANE_DELAYED_EVENT)NULL == pDelayedEvent)
		{
			DBGP((0, "QueueElanEventAfterDelay: Event object alloc failed\n"));
			break;
		}

		//
		//	Stash event data in event struct
		//
		pEvent = &pDelayedEvent->DelayedEvent;
		pEvent->Event = Event;
		pEvent->EventStatus = EventStatus;

		//
		//  Remember the ELAN.
		//
		pDelayedEvent->pElan = pElan;

		//
		//  Stash a pointer to this delayed event in the ELAN
		//
		pElan->pDelayedEvent = pDelayedEvent;

		//
		//  Reference the ELAN so that it doesn't go away for the
		//  duration this delayed event is alive.
		//
		AtmLaneReferenceElan(pElan, "delayevent");

		//
		//  Set up the timer to fire after the specified delay.
		//
		NdisInitializeTimer(&pDelayedEvent->DelayTimer,
							AtmLaneQueueDelayedElanEvent,
							(PVOID)pDelayedEvent);
		
		NdisSetTimer(&pDelayedEvent->DelayTimer, DelayMs);

	} while (FALSE);

	TRACEOUT(QueueElanEventAfterDelay);
	return;
}


VOID
AtmLaneQueueDelayedElanEvent(
	IN	PVOID					SystemSpecific1,
	IN	PVOID					TimerContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
	)
/*++

Routine Description:

	This is the routine fired off after a delay in order to
	queue an event on an ELAN. The event is queued now.

Arguments:

    SystemSpecific[1-3]	- Ignored
    TimerContext		- Actually a pointer to the delayed event structure

Return Value:

	None.
	
--*/
{	
	PATMLANE_DELAYED_EVENT	pDelayedEvent;
	PATMLANE_EVENT			pEvent;
	PATMLANE_ELAN			pElan;
	ULONG					rc;

	TRACEIN(QueueDelayedElanEvent);

	pDelayedEvent = (PATMLANE_DELAYED_EVENT)TimerContext;

	do
	{
		pElan = pDelayedEvent->pElan;

		ACQUIRE_ELAN_LOCK(pElan);

		pElan->pDelayedEvent = NULL;

		//
		//  Take out the delay event reference.
		//
		rc = AtmLaneDereferenceElan(pElan, "delayevent");

		if (rc == 0)
		{
			break;
		}

		pEvent = &pDelayedEvent->DelayedEvent;
		AtmLaneQueueElanEvent(pElan, pEvent->Event, pEvent->EventStatus);

		RELEASE_ELAN_LOCK(pElan);
	}
	while (FALSE);

	FREE_MEM(pDelayedEvent);

	TRACEOUT(QueueDelayedElanEvent);
	return;
}

VOID
AtmLaneQueueElanEvent(
	IN	PATMLANE_ELAN			pElan,
	IN	ULONG					Event,
	IN	NDIS_STATUS				EventStatus
	)
/*++

Routine Description:

	Queue an ELAN event on the ELAN's event queue and if
	not already scheduled, schedule the handler.  Caller
	is assumed to hold ELAN's lock.

Arguments:

    pElan				- Pointer to ELAN structure.
    Event				- Event code.
    EventStatus			- Status related to event.

Return Value:

	None.
	
--*/
{	
	PATMLANE_EVENT	pEvent;

	TRACEIN(AtmLaneQueueElanEvent);

	do
	{
		//
		//	If the ELAN is being shut down, don't queue any events.
		//
		if (ELAN_STATE_SHUTDOWN == pElan->AdminState)
		{
			if ((Event != ELAN_EVENT_START) &&
				(Event != ELAN_EVENT_RESTART))
			{
				DBGP((0, "%d: QueueElanEvent: Not queuing event %d (ELAN shutdown)\n", pElan->ElanNumber, Event));
				break;
			}
		}

		//
		//	Alloc an event struct 
		//
		ALLOC_MEM(&pEvent, sizeof(ATMLANE_EVENT));
		if ((PATMLANE_EVENT)NULL == pEvent)
		{
			DBGP((0, "QueueElanEvent: Event object alloc failed\n"));
			break;
		}

		//
		//	Stash event data in event struct
		//
		pEvent->Event = Event;
		pEvent->EventStatus = EventStatus;
	
		//
		//	Queue it at tail, reference Elan, and if required, schedule
		//  work item to handle it.
		//
		InsertTailList(&pElan->EventQueue, &pEvent->Link);
		AtmLaneReferenceElan(pElan, "event");

		if ((pElan->Flags & ELAN_EVENT_WORK_ITEM_SET) == 0)
		{
			NDIS_STATUS	Status;

			AtmLaneReferenceElan(pElan, "workitemevent");
			pElan->Flags |= ELAN_EVENT_WORK_ITEM_SET;

			NdisInitializeWorkItem(&pElan->EventWorkItem, AtmLaneEventHandler, pElan);
			Status = NdisScheduleWorkItem(&pElan->EventWorkItem);
			ASSERT(Status == NDIS_STATUS_SUCCESS);
		}

	} while (FALSE);

	TRACEOUT(QueueElanEvent);
	return;
}

PATMLANE_EVENT
AtmLaneDequeueElanEvent(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Remove an ELAN event from the head of the ELAN's
	event queue.  Caller is assumed to hold ELAN's lock.
  	Caller is responsible for freeing event object.
Arguments:

    pElan				- Pointer to ELAN structure.

Return Value:

	Pointer to removed ELAN event or NULL if queue empty.
	
--*/
{
	PLIST_ENTRY		p;
	PATMLANE_EVENT 	pEvent;

	TRACEIN(DequeueElanEvent);

	if (!IsListEmpty(&pElan->EventQueue))
	{
		p = RemoveHeadList(&pElan->EventQueue);
		pEvent = CONTAINING_RECORD(p, ATMLANE_EVENT, Link);
		(VOID)AtmLaneDereferenceElan(pElan, "event");
	}
	else
	{
		pEvent = NULL;
	}
	
	TRACEIN(DequeueElanEvent);

	return pEvent;
}

VOID
AtmLaneDrainElanEventQueue(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Remove all ELAN events from the ELAN's event queue.
	Caller is assumed to hold ELAN's lock.

Arguments:

    pElan				- Pointer to ELAN structure.

Return Value:

	None.
	
--*/
{
	BOOLEAN			WasCancelled;
	PATMLANE_EVENT 	pEvent;

	TRACEIN(DrainElanEventQueue);

	while ((pEvent = AtmLaneDequeueElanEvent(pElan)) != NULL)
	{
		DBGP((0, "%d Drained event %x, Status %x from Elan %x\n",
				pElan->ElanNumber,
				pEvent->Event,
				pEvent->EventStatus,
				pElan));

		FREE_MEM(pEvent);
	}
	
	TRACEIN(DrainElanEventQueue);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\lane10.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	lane10.h

Abstract:

	Definitions from ATM Forum LANE 1.0 Specification.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#ifndef	__ATMLANE_LANE10_H
#define __ATMLANE_LANE10_H


//
//	Minimum packet sizes including 2 byte LANE header
//
#define LANE_MIN_ETHPACKET			62
#define LANE_MIN_TRPACKET			16

//
//	Maximum bytes for ethernet/802.3 header and token ring header
//	including the 2 byte LANE header.  See section 4.1 of the LE spec
//  for the derivation.
//
#define LANE_ETH_HEADERSIZE			16
#define LANE_TR_HEADERSIZE			46
#define LANE_MAX_HEADERSIZE			46
#define LANE_HEADERSIZE				2

//
//	Type of LAN
//
#define LANE_LANTYPE_UNSPEC			0x00
#define LANE_LANTYPE_ETH			0x01
#define LANE_LANTYPE_TR				0x02

//
//	Maximum Frame Size Codes
//
#define LANE_MAXFRAMESIZE_CODE_UNSPEC	0x00
#define LANE_MAXFRAMESIZE_CODE_1516		0x01
#define LANE_MAXFRAMESIZE_CODE_4544		0x02
#define LANE_MAXFRAMESIZE_CODE_9234		0x03
#define LANE_MAXFRAMESIZE_CODE_18190	0x04

//
//	Maximum Size of an ELAN Name
//
#define LANE_ELANNAME_SIZE_MAX		32


#include <pshpack1.h>

//
//	Mac Address as LANE defines them in 
//	control packets.
//
typedef struct _LANE_MAC_ADDRESS
{
	USHORT			Type;
	UCHAR			Byte[6];
}
	LANE_MAC_ADDRESS;

typedef LANE_MAC_ADDRESS UNALIGNED 	*PLANE_MAC_ADDRESS;

//
//	LANE Mac Address types.
//	With USHORTS nicely preswapped for little-endian.
//
#define LANE_MACADDRTYPE_NOTPRESENT		0x0000	// no address here
#define LANE_MACADDRTYPE_MACADDR		0x0100	// this is a mac addr
#define LANE_MACADDRTYPE_ROUTEDESCR		0x0200	// this is a route descriptor

//
//	LAN Emulation Control Frame
//
typedef struct _LANE_CONTROL_FRAME
{
	USHORT				Marker;
	UCHAR				Protocol;
	UCHAR				Version;
	USHORT				OpCode;
	USHORT				Status;
	ULONG				Tid;
	USHORT				LecId;
	USHORT				Flags;
	LANE_MAC_ADDRESS	SourceMacAddress;
	LANE_MAC_ADDRESS	TargetMacAddress;
	UCHAR				SourceAtmAddr[20];
	UCHAR				LanType;
	UCHAR				MaxFrameSize;
	UCHAR				NumTlvs;
	UCHAR				ElanNameSize;
	UCHAR				TargetAtmAddr[20];
	UCHAR				ElanName[LANE_ELANNAME_SIZE_MAX];
}
	LANE_CONTROL_FRAME;

typedef LANE_CONTROL_FRAME UNALIGNED	*PLANE_CONTROL_FRAME;


//
//	LAN Emulation Ready Frame (really just a short control frame)
//
typedef struct _LANE_READY_FRAME
{
	USHORT				Marker;
	UCHAR				Protocol;
	UCHAR				Version;
	USHORT				OpCode;
}
	LANE_READY_FRAME;
	
typedef LANE_READY_FRAME UNALIGNED	*PLANE_READY_FRAME;


//
//	TLV (type/length/value)
//
typedef struct _LANE_TLV
{
	ULONG				Type;
	UCHAR				Length;
	UCHAR				Value[1];
}
	LANE_TLV;

typedef LANE_TLV UNALIGNED	*PLANE_TLV;

#include <poppack.h>

//
//	LANE Status codes
//	With USHORTS nicely preswapped for little-endian.
//
#define	LANE_STATUS_SUCCESS			0x0000	// Success
#define	LANE_STATUS_VERSNOSUPP		0x0100	// Version not supported
#define	LANE_STATUS_REQPARMINVAL	0x0200	// Invalid request parameters
#define	LANE_STATUS_DUPLANDEST		0x0400	// Duplicate LAN destination
#define	LANE_STATUS_DUPATMADDR		0x0500	// Duplicate ATM address
#define	LANE_STATUS_INSUFFRES		0x0600	// Insufficient resources
#define	LANE_STATUS_NOACCESS		0x0700	// Access denied
#define	LANE_STATUS_REQIDINVAL		0x0800	// Invalid requester ID
#define	LANE_STATUS_LANDESTINVAL	0x0900	// Invalid LAN destination
#define	LANE_STATUS_ATMADDRINVAL	0x0A00	// Invalid ATM address
#define	LANE_STATUS_NOCONF			0x1400	// No configuration
#define	LANE_STATUS_CONFERROR		0x1500	// Configuration error
#define	LANE_STATUS_INSUFFINFO		0x1600	// Insufficient information

//
//	LANE Operation Codes.
//	With USHORTS nicely preswapped for little-endian.
//
#define LANE_CONFIGURE_REQUEST		0x0100
#define LANE_CONFIGURE_RESPONSE		0x0101
#define LANE_JOIN_REQUEST			0x0200
#define LANE_JOIN_RESPONSE			0x0201
#define LANE_READY_QUERY			0x0300
#define LANE_READY_IND				0x0301
#define LANE_REGISTER_REQUEST		0x0400
#define LANE_REGISTER_RESPONSE		0x0401
#define LANE_UNREGISTER_REQUEST		0x0500
#define LANE_UNREGISTER_RESPONSE	0x0501
#define LANE_ARP_REQUEST			0x0600
#define LANE_ARP_RESPONSE			0x0601
#define LANE_FLUSH_REQUEST			0x0700
#define LANE_FLUSH_RESPONSE			0x0701
#define LANE_NARP_REQUEST			0x0800
#define LANE_TOPOLOGY_REQUEST		0x0900

//
//	Control Frame Marker, Protocol, and Version.
//	With USHORTS nicely preswapped for little-endian.
//
#define	LANE_CONTROL_MARKER			0x00FF
#define LANE_PROTOCOL				0x01
#define LANE_VERSION				0x01

//
//	Type codes for TLVs in Configure Response
//	With USHORTS nicely preswapped for little-endian.
//
#define LANE_CFG_CONTROL_TIMEOUT	0x013EA000
#define LANE_CFG_UNK_FRAME_COUNT	0x023EA000
#define LANE_CFG_UNK_FRAME_TIME		0x033EA000
#define LANE_CFG_VCC_TIMEOUT		0x043EA000
#define LANE_CFG_MAX_RETRY_COUNT	0x053EA000
#define LANE_CFG_AGING_TIME			0x063EA000
#define LANE_CFG_FWD_DELAY_TIME		0x073EA000
#define LANE_CFG_ARP_RESP_TIME		0x083EA000
#define LANE_CFG_FLUSH_TIMEOUT		0x093EA000
#define LANE_CFG_PATH_SWITCH_DELAY	0x0A3EA000
#define LANE_CFG_LOCAL_SEGMENT_ID	0x0B3EA000
#define LANE_CFG_MCAST_VCC_TYPE		0x0C3EA000
#define LANE_CFG_MCAST_VCC_AVG		0x0D3EA000
#define LANE_CFG_MCAST_VCC_PEAK		0x0E3EA000
#define LANE_CFG_CONN_COMPL_TIMER	0x0F3EA000

//
//	Definitions for Control Frame Flags field
//
#define LANE_CONTROL_FLAGS_REMOTE_ADDRESS		0x0001
#define LANE_CONTROL_FLAGS_TOPOLOGY_CHANGE		0x0100
#define LANE_CONTROL_FLAGS_PROXY				0x0800


//
//	Default/min/max for ELAN run-time configuration parameters
//	Units are seconds if time related parameter.
//
#define LANE_C7_MIN					10		// Control Time-out
#define LANE_C7_DEF					10
#define LANE_C7_MAX					300

#define LANE_C10_MIN				1		// Maximum Unknown Framount Count
#define LANE_C10_DEF				1
#define LANE_C10_MAX				100		// non-standard but reasonable!

#define LANE_C11_MIN				1		// Maximum Unknown Frame Time
#define LANE_C11_DEF				1
#define LANE_C11_MAX				60

#define LANE_C12_MIN				1
#define LANE_C12_DEF				(20*60)	// VCC Time-out Period
// no max defined

#define LANE_C13_MIN				0		// Maximum Retry Count
#define LANE_C13_DEF				1
#define LANE_C13_MAX				2

#define LANE_C17_MIN				10		// ARP Aging Time
#define LANE_C17_DEF				300		
#define LANE_C17_MAX				300

#define LANE_C18_MIN				4		// Forward Delay Time
#define LANE_C18_DEF				15
#define LANE_C18_MAX				30

#define LANE_C20_MIN				1		// Expected LE_ARP Response Time
#define LANE_C20_DEF				1
#define LANE_C20_MAX				30

#define LANE_C21_MIN				1		// Flush Time-out
#define LANE_C21_DEF				4
#define LANE_C21_MAX				4

#define LANE_C22_MIN				1		// Path Switching Delay
#define LANE_C22_DEF				6
#define LANE_C22_MAX				8

#define LANE_C28_MIN				1		// Expected LE_ARP Response Time
#define LANE_C28_DEF				4
#define LANE_C28_MAX				10


#endif // __ATMLANE_LANE10_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\precomp.h ===
#include <ndis.h>
#include <atm.h>

#include "tracelog.h"
#include "lane10.h"
#include "debug.h"
#include "event.h"
#include "atmlane.h"
#include "laneinfo.h"
#include "macros.h"
#include "externs.h"
#include "netevent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\oidstrng.h ===
struct _string_table oid_string_table[] = {
    {"OID_GEN_SUPPORTED_LIST",				OID_GEN_SUPPORTED_LIST},
    {"OID_GEN_HARDWARE_STATUS",				OID_GEN_HARDWARE_STATUS},
    {"OID_GEN_MEDIA_SUPPORTED",				OID_GEN_MEDIA_SUPPORTED},
    {"OID_GEN_MEDIA_IN_USE",				OID_GEN_MEDIA_IN_USE},
    {"OID_GEN_MAXIMUM_LOOKAHEAD",			OID_GEN_MAXIMUM_LOOKAHEAD},
    {"OID_GEN_MAXIMUM_FRAME_SIZE",			OID_GEN_MAXIMUM_FRAME_SIZE},
    {"OID_GEN_MAXIMUM_TOTAL_SIZE",			OID_GEN_MAXIMUM_TOTAL_SIZE},
    {"OID_GEN_MAC_OPTIONS",					OID_GEN_MAC_OPTIONS},
    {"OID_GEN_PROTOCOL_OPTIONS",			OID_GEN_PROTOCOL_OPTIONS},
    {"OID_GEN_LINK_SPEED",					OID_GEN_LINK_SPEED},
    {"OID_GEN_TRANSMIT_BUFFER_SPACE",		OID_GEN_TRANSMIT_BUFFER_SPACE},
    {"OID_GEN_RECEIVE_BUFFER_SPACE",		OID_GEN_RECEIVE_BUFFER_SPACE},
    {"OID_GEN_TRANSMIT_BLOCK_SIZE",			OID_GEN_TRANSMIT_BLOCK_SIZE},
    {"OID_GEN_TRANSMIT_QUEUE_LENGTH",		OID_GEN_TRANSMIT_QUEUE_LENGTH},
    {"OID_GEN_RECEIVE_BLOCK_SIZE",			OID_GEN_RECEIVE_BLOCK_SIZE},
    {"OID_GEN_VENDOR_DESCRIPTION",			OID_GEN_VENDOR_DESCRIPTION},
    {"OID_GEN_VENDOR_ID",					OID_GEN_VENDOR_ID},
    {"OID_GEN_DRIVER_VERSION",				OID_GEN_DRIVER_VERSION},
    {"OID_GEN_CURRENT_PACKET_FILTER",		OID_GEN_CURRENT_PACKET_FILTER},
    {"OID_GEN_CURRENT_LOOKAHEAD",			OID_GEN_CURRENT_LOOKAHEAD},
    {"OID_GEN_XMIT_OK",						OID_GEN_XMIT_OK},
    {"OID_GEN_RCV_OK",						OID_GEN_RCV_OK},
    {"OID_GEN_XMIT_ERROR",					OID_GEN_XMIT_ERROR},
    {"OID_GEN_RCV_ERROR",					OID_GEN_RCV_ERROR},
    {"OID_GEN_RCV_NO_BUFFER",				OID_GEN_RCV_NO_BUFFER},
    {"OID_GEN_RCV_CRC_ERROR",				OID_GEN_RCV_CRC_ERROR},
    {"OID_GEN_MAXIMUM_SEND_PACKETS",		OID_GEN_MAXIMUM_SEND_PACKETS},
    {"OID_802_3_PERMANENT_ADDRESS",			OID_802_3_PERMANENT_ADDRESS},
    {"OID_802_3_CURRENT_ADDRESS",			OID_802_3_CURRENT_ADDRESS},
    {"OID_802_3_MULTICAST_LIST",			OID_802_3_MULTICAST_LIST},
    {"OID_802_3_MAXIMUM_LIST_SIZE",			OID_802_3_MAXIMUM_LIST_SIZE},
    {"OID_802_3_RCV_ERROR_ALIGNMENT",		OID_802_3_RCV_ERROR_ALIGNMENT},
    {"OID_802_3_XMIT_ONE_COLLISION",		OID_802_3_XMIT_ONE_COLLISION},
    {"OID_802_3_XMIT_MORE_COLLISIONS",		OID_802_3_XMIT_MORE_COLLISIONS},
    {"OID_802_5_PERMANENT_ADDRESS",			OID_802_5_PERMANENT_ADDRESS},
    {"OID_802_5_CURRENT_ADDRESS",			OID_802_5_CURRENT_ADDRESS},
    {"OID_802_5_CURRENT_FUNCTIONAL",		OID_802_5_CURRENT_FUNCTIONAL},
    {"OID_802_5_CURRENT_GROUP",				OID_802_5_CURRENT_GROUP},
    {"OID_802_5_LAST_OPEN_STATUS",			OID_802_5_LAST_OPEN_STATUS},
    {"OID_802_5_CURRENT_RING_STATUS",		OID_802_5_CURRENT_RING_STATUS},
    {"OID_802_5_CURRENT_RING_STATE",		OID_802_5_CURRENT_RING_STATE},
    {"OID_802_5_LINE_ERRORS",				OID_802_5_LINE_ERRORS},
    {"OID_802_5_LOST_FRAMES",				OID_802_5_LOST_FRAMES},
    {"OID_802_5_BURST_ERRORS",				OID_802_5_BURST_ERRORS},
    {"OID_802_5_FRAME_COPIED_ERRORS",		OID_802_5_FRAME_COPIED_ERRORS},
    {"OID_802_5_TOKEN_ERRORS",				OID_802_5_TOKEN_ERRORS},
    {"*** UNKNOWN OID ***",             	0}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\space.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	space.c

Abstract:

	This file contains global definitions.

Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  Global Info structure. Initialized in DriverEntry (ntentry.c).
// 
ATMLANE_GLOBALS		gAtmLaneGlobalInfo;
PATMLANE_GLOBALS	pAtmLaneGlobalInfo = &gAtmLaneGlobalInfo;


//
//	The well-know ATM address for the LECS.
//
ATM_ADDRESS 		gWellKnownLecsAddress = 
{
	ATM_NSAP,						// type
	20,								// num digits
	{								// address bytes
	0x47, 0x00, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xa0, 0x3e, 0x00, 0x00, 0x01, 0x00
    }
};

MAC_ADDRESS			gMacBroadcastAddress =
{
	0xff,0xff,0xff,0xff,0xff,0xff
};

//
//  Max timeout value (in seconds) for each class.
//
ULONG	AtmLaneMaxTimerValue[ALT_CLASS_MAX] =
						{
							ALT_MAX_TIMER_SHORT_DURATION,
							ALT_MAX_TIMER_LONG_DURATION
						};

//
//  Size of each timer wheel.
//
ULONG	AtmLaneTimerListSize[ALT_CLASS_MAX] =
						{
							SECONDS_TO_SHORT_TICKS(ALT_MAX_TIMER_SHORT_DURATION)+1,
							SECONDS_TO_LONG_TICKS(ALT_MAX_TIMER_LONG_DURATION)+1
						};
//
//  Interval between ticks, in seconds, for each class.
//
ULONG	AtmLaneTimerPeriod[ALT_CLASS_MAX] =
						{
							ALT_SHORT_DURATION_TIMER_PERIOD,
							ALT_LONG_DURATION_TIMER_PERIOD
						};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\macros.h ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

    macros.h

Abstract:

	Macros for the ATMLANE module

Author:


Revision History:

--*/
#ifndef __ATMLANE_MACROS_H
#define __ATMLANE_MACROS_H

#include "atmlane.h"

#ifndef LOCKIN
#define LOCKIN
#endif

#ifndef NOLOCKOUT
#define NOLOCKOUT
#endif

#define NULL_NDIS_HANDLE	((NDIS_HANDLE)NULL)

#ifndef MAX

/*++
OPAQUE
MAX(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MAX(Fred, Shred)		(((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MIN(Fred, Shred)		(((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN

#define ROUND_OFF(_size)		(((_size) + 7) & ~0x7)

/*++
ULONG
ATMLANE_HASH(
	IN	PMAC_ADDRESS	pMacAddress
)
--*/
#define ATMLANE_HASH(pMacAddress)	\
			((ULONG)(pMacAddress)->Byte[4])

/*++
BOOLEAN
MAC_ADDR_EQUAL(
	IN	PMAC_ADDRESS	pMacAddr1,
	IN 	PMAC_ADDRESS	pMacAddr2
)
--*/
#define MAC_ADDR_EQUAL(_pMac1, _pMac2)                            \
			((*(ULONG UNALIGNED *)&((PUCHAR)(_pMac1))[2] ==       \
			  *(ULONG UNALIGNED *)&((PUCHAR)(_pMac2))[2])    &&   \
			 (*(USHORT UNALIGNED *)(_pMac1) ==                    \
			  *(USHORT UNALIGNED *)(_pMac2)))

/*++
VOID
SET_FLAG(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)


/*++
BOOLEAN
IS_FLAG_SET(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))

// ----------------------------------------------------------------------------

/*++
VOID
INIT_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock
)
--*/
#define INIT_BLOCK_STRUCT(pBlock)		NdisInitializeEvent(&((pBlock)->Event))


/*++
NDIS_STATUS
WAIT_ON_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock
)
--*/
#define WAIT_ON_BLOCK_STRUCT(pBlock)		\
			(NdisWaitEvent(&((pBlock)->Event), 0), (pBlock)->Status)


/*++
VOID
SIGNAL_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock,
	IN	UINT			Status
)
--*/
#define SIGNAL_BLOCK_STRUCT(pBlock, _Status)	\
			{ (pBlock)->Status = _Status; NdisSetEvent(&((pBlock)->Event)); }


/*++
VOID
FREE_BLOCK_STRUCT(
	IN	ATMLANE_BLOCK	*pBlock
)
--*/
#define FREE_BLOCK_STRUCT(pBlock)		// Nothing to be done here

// ----------------------------------------------------------------------------

/*++
VOID
INIT_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_LOCK(pLock, Str)	\
				AtmLaneAllocateSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define INIT_LOCK(pLock)	\
				NdisAllocateSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
ACQUIRE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock,
	IN	PUCHAR				Str
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_LOCK(pLock, Str)	\
				AtmLaneAcquireSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define ACQUIRE_LOCK(pLock)	\
				NdisAcquireSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
ACQUIRE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_LOCK_DPC(pLock, Str)	\
				AtmLaneAcquireSpinLock(pLock, Str"-dpc", __FILE__, __LINE__)
#else
#define ACQUIRE_LOCK_DPC(pLock)	\
				NdisDprAcquireSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
RELEASE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock,
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_LOCK(pLock, Str)		\
				AtmLaneReleaseSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define RELEASE_LOCK(pLock)		\
				NdisReleaseSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
RELEASE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_LOCK_DPC(pLock, Str)		\
				AtmLaneReleaseSpinLock(pLock, Str"-dpc", __FILE__, __LINE__)
#else
#define RELEASE_LOCK_DPC(pLock)		\
				NdisDprReleaseSpinLock(pLock)
#endif // DEBUG_SPIN_LOCK


/*++
VOID
FREE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_LOCK(pLock, Str)		\
				AtmLaneFreeSpinLock(pLock, Str, __FILE__, __LINE__)
#else
#define FREE_LOCK(pLock)			\
				NdisFreeSpinLock(pLock)
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_ADAPTER_LOCK(
	IN PATMLANE_ADAPTER	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ADAPTER_LOCK(pAdapter)		\
				INIT_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define INIT_ADAPTER_LOCK(pAdapter)		\
				INIT_LOCK(&((pAdapter)->AdapterLock))
#endif

/*++
VOID
ACQUIRE_ADAPTER_LOCK(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ADAPTER_LOCK(pAdapter)		\
				ACQUIRE_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define ACQUIRE_ADAPTER_LOCK(pAdapter)		\
				ACQUIRE_LOCK(&((pAdapter)->AdapterLock))
#endif

/*++
VOID
ACQUIRE_ADAPTER_LOCK_DPC(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ADAPTER_LOCK_DPC(pAdapter)		\
				ACQUIRE_LOCK_DPC(&((pAdapter)->AdapterLock), "adapter")
#else
#define ACQUIRE_ADAPTER_LOCK_DPC(pAdapter)		\
				ACQUIRE_LOCK_DPC(&((pAdapter)->AdapterLock))
#endif


/*++
VOID
RELEASE_ADAPTER_LOCK(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ADAPTER_LOCK(pAdapter)		\
				RELEASE_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define RELEASE_ADAPTER_LOCK(pAdapter)		\
				RELEASE_LOCK(&((pAdapter)->AdapterLock))
#endif


/*++
VOID
RELEASE_ADAPTER_LOCK_DPC(
	IN PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ADAPTER_LOCK_DPC(pAdapter)		\
				RELEASE_LOCK_DPC(&((pAdapter)->AdapterLock), "adapter")
#else
#define RELEASE_ADAPTER_LOCK_DPC(pAdapter)		\
				RELEASE_LOCK_DPC(&((pAdapter)->AdapterLock))
#endif


/*++
VOID
FREE_ADAPTER_LOCK(
	IN	PATMLANE_ELAN	pAdapter
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ADAPTER_LOCK(pAdapter)	\
				FREE_LOCK(&((pAdapter)->AdapterLock), "adapter")
#else
#define FREE_ADAPTER_LOCK(pAdapter)	\
				FREE_LOCK(&((pAdapter)->AdapterLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_ELAN_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->ElanLock), "elan")
#else
#define INIT_ELAN_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->ElanLock))
#endif

/*++
VOID
ACQUIRE_ELAN_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->ElanLock), "elan")
#else
#define ACQUIRE_ELAN_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->ElanLock))
#endif


/*++
VOID
ACQUIRE_ELAN_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->ElanLock), "elan")
#else
#define ACQUIRE_ELAN_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->ElanLock))
#endif


/*++
VOID
RELEASE_ELAN_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->ElanLock), "elan")
#else
#define RELEASE_ELAN_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->ElanLock))
#endif


/*++
VOID
RELEASE_ELAN_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->ElanLock), "elan")
#else
#define RELEASE_ELAN_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->ElanLock))
#endif


/*++
VOID
FREE_ELAN_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->ElanLock), "elan")
#else
#define FREE_ELAN_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->ElanLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_HEADER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_HEADER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define INIT_HEADER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->HeaderBufferLock))
#endif

/*++
VOID
ACQUIRE_HEADER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_HEADER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define ACQUIRE_HEADER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
ACQUIRE_HEADER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_HEADER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->HeaderBufferLock), "header")
#else
#define ACQUIRE_HEADER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
RELEASE_HEADER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_HEADER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define RELEASE_HEADER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
RELEASE_HEADER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_HEADER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->HeaderBufferLock), "header")
#else
#define RELEASE_HEADER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->HeaderBufferLock))
#endif


/*++
VOID
FREE_HEADER_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_HEADER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->HeaderBufferLock), "header")
#else
#define FREE_HEADER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->HeaderBufferLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_ELAN_TIMER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_TIMER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->TimerLock), "timer")
#else
#define INIT_ELAN_TIMER_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->TimerLock))
#endif

/*++
VOID
ACQUIRE_ELAN_TIMER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_TIMER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->TimerLock), "timer")
#else
#define ACQUIRE_ELAN_TIMER_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->TimerLock))
#endif

/*++
VOID
ACQUIRE_ELAN_TIMER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_TIMER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->TimerLock), "timer")
#else
#define ACQUIRE_ELAN_TIMER_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->TimerLock))
#endif

/*++
VOID
RELEASE_ELAN_TIMER_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_TIMER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->TimerLock), "timer")
#else
#define RELEASE_ELAN_TIMER_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->TimerLock))
#endif

/*++
VOID
RELEASE_ELAN_TIMER_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_TIMER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->TimerLock), "timer")
#else
#define RELEASE_ELAN_TIMER_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->TimerLock))
#endif


/*++
VOID
FREE_ELAN_TIMER_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_TIMER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->TimerLock), "timer")
#else
#define FREE_ELAN_TIMER_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->TimerLock))
#endif
// ----------------------------------------------------------------------------

/*++
VOID
INIT_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ATM_ENTRY_LOCK(pAe)		\
				INIT_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define INIT_ATM_ENTRY_LOCK(pAe)		\
				INIT_LOCK(&((pAe)->AeLock))
#endif

/*++
VOID
ACQUIRE_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ATM_ENTRY_LOCK(pAe)		\
				ACQUIRE_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define ACQUIRE_ATM_ENTRY_LOCK(pAe)		\
				ACQUIRE_LOCK(&((pAe)->AeLock))
#endif

/*++
VOID
ACQUIRE_ATM_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ATM_ENTRY_LOCK_DPC(pAe)		\
				ACQUIRE_LOCK_DPC(&((pAe)->AeLock), "atmentry")
#else
#define ACQUIRE_ATM_ENTRY_LOCK_DPC(pAe)		\
				ACQUIRE_LOCK_DPC(&((pAe)->AeLock))
#endif

/*++
VOID
RELEASE_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ATM_ENTRY_LOCK(pAe)		\
				RELEASE_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define RELEASE_ATM_ENTRY_LOCK(pAe)		\
				RELEASE_LOCK(&((pAe)->AeLock))
#endif

/*++
VOID
RELEASE_ATM_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ATM_ENTRY_LOCK_DPC(pAe)		\
				RELEASE_LOCK_DPC(&((pAe)->AeLock), "atmentry")
#else
#define RELEASE_ATM_ENTRY_LOCK_DPC(pAe)		\
				RELEASE_LOCK_DPC(&((pAe)->AeLock))
#endif

/*++
VOID
FREE_ATM_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pAe
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ATM_ENTRY_LOCK(pAe)		\
				FREE_LOCK(&((pAe)->AeLock), "atmentry")
#else
#define FREE_ATM_ENTRY_LOCK(pAe)		\
				FREE_LOCK(&((pAe)->AeLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_MAC_ENTRY_LOCK(pMe)		\
				INIT_LOCK(&((pMe)->MeLock), "macentry")
#else
#define INIT_MAC_ENTRY_LOCK(pMe)		\
				INIT_LOCK(&((pMe)->MeLock))
#endif

/*++
VOID
ACQUIRE_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_MAC_ENTRY_LOCK(pMe)		\
				ACQUIRE_LOCK(&((pMe)->MeLock), "macentry")
#else
#define ACQUIRE_MAC_ENTRY_LOCK(pMe)		\
				ACQUIRE_LOCK(&((pMe)->MeLock))
#endif

/*++
VOID
ACQUIRE_MAC_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_MAC_ENTRY_LOCK_DPC(pMe)		\
				ACQUIRE_LOCK_DPC(&((pMe)->MeLock), "macentry")
#else
#define ACQUIRE_MAC_ENTRY_LOCK_DPC(pMe)		\
				ACQUIRE_LOCK_DPC(&((pMe)->MeLock))
#endif

/*++
VOID
RELEASE_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_MAC_ENTRY_LOCK(pMe)		\
				RELEASE_LOCK(&((pMe)->MeLock), "macentry")
#else
#define RELEASE_MAC_ENTRY_LOCK(pMe)		\
				RELEASE_LOCK(&((pMe)->MeLock))
#endif

/*++
VOID
RELEASE_MAC_ENTRY_LOCK_DPC(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_MAC_ENTRY_LOCK_DPC(pMe)		\
				RELEASE_LOCK_DPC(&((pMe)->MeLock), "macentry")
#else
#define RELEASE_MAC_ENTRY_LOCK_DPC(pMe)		\
				RELEASE_LOCK_DPC(&((pMe)->MeLock))
#endif

/*++
VOID
FREE_MAC_ENTRY_LOCK(
	IN PATMLANE_ATM_ENTRY	pMe
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_MAC_ENTRY_LOCK(pMe)		\
				FREE_LOCK(&((pMe)->MeLock), "macentry")
#else
#define FREE_MAC_ENTRY_LOCK(pMe)		\
				FREE_LOCK(&((pMe)->MeLock))
#endif
				
// ----------------------------------------------------------------------------

/*++
VOID
INIT_ELAN_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_ATM_LIST_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define INIT_ELAN_ATM_LIST_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->AtmEntryListLock))
#endif

/*++
VOID
ACQUIRE_ELAN_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_ATM_LIST_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define ACQUIRE_ELAN_ATM_LIST_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->AtmEntryListLock))
#endif

/*++
VOID
ACQUIRE_ELAN_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define ACQUIRE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->AtmEntryListLock))
#endif


/*++
VOID
RELEASE_ELAN_ATM_LIST_LOCK(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_ATM_LIST_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define RELEASE_ELAN_ATM_LIST_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->AtmEntryListLock))
#endif

/*++
VOID
RELEASE_ELAN_ATM_LIST_LOCK_DPC(
	IN PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define RELEASE_ELAN_ATM_LIST_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->AtmEntryListLock))
#endif


/*++
VOID
FREE_ELAN_ATM_LIST_LOCK(
	IN	PATMARP_INTERFACE	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_ATM_LIST_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->AtmEntryListLock), "atmlist")
#else
#define FREE_ELAN_ATM_LIST_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->AtmEntryListLock))
#endif

// ----------------------------------------------------------------------------
				
/*++
VOID
INIT_ELAN_MAC_TABLE_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_ELAN_MAC_TABLE_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define INIT_ELAN_MAC_TABLE_LOCK(pElan)		\
				INIT_LOCK(&((pElan)->MacTableLock))
#endif

/*++
VOID
ACQUIRE_ELAN_MAC_TABLE_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define ACQUIRE_ELAN_MAC_TABLE_LOCK(pElan)		\
				ACQUIRE_LOCK(&((pElan)->MacTableLock))
#endif

/*++
VOID
ACQUIRE_ELAN_MAC_TABLE_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->MacTableLock), "mactable")
#else
#define ACQUIRE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				ACQUIRE_LOCK_DPC(&((pElan)->MacTableLock))
#endif


/*++
VOID
RELEASE_ELAN_MAC_TABLE_LOCK(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_MAC_TABLE_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define RELEASE_ELAN_MAC_TABLE_LOCK(pElan)		\
				RELEASE_LOCK(&((pElan)->MacTableLock))
#endif

/*++
VOID
RELEASE_ELAN_MAC_TABLE_LOCK_DPC(
	IN PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->MacTableLock), "mactable")
#else
#define RELEASE_ELAN_MAC_TABLE_LOCK_DPC(pElan)		\
				RELEASE_LOCK_DPC(&((pElan)->MacTableLock))
#endif


/*++
VOID
FREE_ELAN_MAC_TABLE_LOCK(
	IN	PATMLANE_ELAN	pElan
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_ELAN_MAC_TABLE_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->MacTableLock), "mactable")
#else
#define FREE_ELAN_MAC_TABLE_LOCK(pElan)	\
				FREE_LOCK(&((pElan)->MacTableLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_VC_LOCK(pVc)		\
				INIT_LOCK(&((pVc)->VcLock), "vc")
#else
#define INIT_VC_LOCK(pVc)		\
				INIT_LOCK(&((pVc)->VcLock))
#endif

/*++
VOID
ACQUIRE_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_VC_LOCK(pVc)		\
				ACQUIRE_LOCK(&((pVc)->VcLock), "vc")
#else
#define ACQUIRE_VC_LOCK(pVc)		\
				ACQUIRE_LOCK(&((pVc)->VcLock))
#endif

/*++
VOID
ACQUIRE_VC_LOCK_DPC(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_VC_LOCK_DPC(pVc)		\
				ACQUIRE_LOCK_DPC(&((pVc)->VcLock), "vc")
#else
#define ACQUIRE_VC_LOCK_DPC(pVc)		\
				ACQUIRE_LOCK_DPC(&((pVc)->VcLock))
#endif

/*++
VOID
RELEASE_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_VC_LOCK(pVc)		\
				RELEASE_LOCK(&((pVc)->VcLock), "vc")
#else
#define RELEASE_VC_LOCK(pVc)		\
				RELEASE_LOCK(&((pVc)->VcLock))
#endif

/*++
VOID
RELEASE_VC_LOCK_DPC(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_VC_LOCK_DPC(pVc)		\
				RELEASE_LOCK_DPC(&((pVc)->VcLock), "vc")
#else
#define RELEASE_VC_LOCK_DPC(pVc)		\
				RELEASE_LOCK_DPC(&((pVc)->VcLock))
#endif

/*++
VOID
FREE_VC_LOCK(
	IN PATMLANE_VC	pVc
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_VC_LOCK(pVc)		\
				FREE_LOCK(&((pVc)->VcLock), "vc")
#else
#define FREE_VC_LOCK(pVc)		\
				FREE_LOCK(&((pVc)->VcLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_SENDPACKET_LOCK(pPkt)		\
				INIT_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define INIT_SENDPACKET_LOCK(pPkt)		\
				INIT_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

/*++
VOID
ACQUIRE_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_SENDPACKET_LOCK(pPkt)		\
				ACQUIRE_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define ACQUIRE_SENDPACKET_LOCK(pPkt)		\
				ACQUIRE_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

/*++
VOID
RELEASE_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_SENDPACKET_LOCK(pPkt)		\
				RELEASE_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define RELEASE_SENDPACKET_LOCK(pPkt)		\
				RELEASE_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

/*++
VOID
FREE_SENDPACKET_LOCK(
	IN PNDIS_PACKET	pPkt
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_SENDPACKET_LOCK(pPkt)		\
				FREE_LOCK(&(PSEND_RSVD(pPkt)->Lock), "packet")
#else
#define FREE_SENDPACKET_LOCK(pPkt)		\
				FREE_LOCK(&(PSEND_RSVD(pPkt)->Lock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID
INIT_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define INIT_GLOBAL_LOCK(pGlob)		\
				INIT_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define INIT_GLOBAL_LOCK(pGlob)		\
				INIT_LOCK(&((pGlob)->GlobalLock))
#endif

/*++
VOID
ACQUIRE_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define ACQUIRE_GLOBAL_LOCK(pGlob)		\
				ACQUIRE_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define ACQUIRE_GLOBAL_LOCK(pGlob)		\
				ACQUIRE_LOCK(&((pGlob)->GlobalLock))
#endif

/*++
VOID
RELEASE_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define RELEASE_GLOBAL_LOCK(pGlob)		\
				RELEASE_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define RELEASE_GLOBAL_LOCK(pGlob)		\
				RELEASE_LOCK(&((pGlob)->GlobalLock))
#endif

/*++
VOID
FREE_GLOBAL_LOCK(
	IN PATMLANE_GLOBALS	pGlob
)
--*/
#if DEBUG_SPIN_LOCK
#define FREE_GLOBAL_LOCK(pGlob)		\
				FREE_LOCK(&((pGlob)->GlobalLock), "global")
#else
#define FREE_GLOBAL_LOCK(pGlob)		\
				FREE_LOCK(&((pGlob)->GlobalLock))
#endif

// ----------------------------------------------------------------------------

/*++
VOID *
ALLOC_MEM(
	OUT	PVOID *		pPtr,
	IN	ULONG		SizeInBytes
)
--*/
#define ALLOC_MEM(pPtr, SizeInBytes)	\
			*(pPtr) = ExAllocatePoolWithTagPriority(NonPagedPool, SizeInBytes, (ULONG)'ENAL', NormalPoolPriority)

/*++
VOID *
ALLOC_MEM_PRIORITY(
	OUT	PVOID *		pPtr,
	IN	ULONG		SizeInBytes,
	IN	EX_POOL_PRIORITY _Priority
)
--*/
#define ALLOC_MEM_PRIORITY(pPtr, SizeInBytes, _Priority)	\
			*(pPtr) = ExAllocatePoolWithTagPriority(NonPagedPool, SizeInBytes, (ULONG)'ENAL', _Priority)


/*++
VOID
FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#define FREE_MEM(pMem)	ExFreePool((PVOID)(pMem));

// ----------------------------------------------------------------------------

/*++
VOID
INIT_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTON	pFunc,
	IN	PVOID				Context
)
--*/
#define INIT_SYSTEM_TIMER(pTimer, pFunc, Context)	\
			NdisInitializeTimer(pTimer, (PNDIS_TIMER_FUNCTION)(pFunc), (PVOID)Context)



/*++
VOID
START_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	UINT				PeriodInSeconds
)
--*/
#define START_SYSTEM_TIMER(pTimer, PeriodInSeconds)	\
			NdisSetTimer(pTimer, (UINT)(PeriodInSeconds * 1000))


/*++
VOID
STOP_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer
)
--*/
#define STOP_SYSTEM_TIMER(pTimer)						\
			{												\
				BOOLEAN		WasCancelled;					\
				NdisCancelTimer(pTimer, &WasCancelled);		\
			}

/*++
BOOLEAN
IS_TIMER_ACTIVE(
	IN	PATMLANE_TIMER		pArpTimer
)
--*/
#define IS_TIMER_ACTIVE(pTmr)	((pTmr)->pTimerList != (PATMLANE_TIMER_LIST)NULL)

	
// ----------------------------------------------------------------------------


/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_LONG_TICKS(Seconds)		((Seconds)/10)


/*++
ULONG
SECONDS_TO_SHORT_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "short duration timer ticks"
--*/
#define SECONDS_TO_SHORT_TICKS(Seconds)		(Seconds)

// ----------------------------------------------------------------------------

/*++
VOID
SET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket,
	IN	PNDIS_PACKET		pNextPacket
)
--*/
#define SET_NEXT_PACKET(pPkt, pNext) \
		((PSEND_PACKET_RESERVED)((pPkt)->ProtocolReserved))->pNextNdisPacket = pNext;

/*++
PNDIS_PACKET
GET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket
)
--*/
#define GET_NEXT_PACKET(pPkt)			\
		((PSEND_PACKET_RESERVED)((pPkt)->ProtocolReserved))->pNextNdisPacket

// ----------------------------------------------------------------------------

/*++
ULONG
CELLS_TO_BYTES(
	IN	ULONG				NumberOfCells
)
Convert from cell count to byte count
--*/
#define CELLS_TO_BYTES(NumberOfCells)	((NumberOfCells) * 48)


/*++
ULONG
BYTES_TO_CELLS(
	IN	ULONG				ByteCount
)
Convert from byte count to cell count
--*/
#define BYTES_TO_CELLS(ByteCount)		((ByteCount) / 48)


/*++
ULONG
LINKSPEED_TO_CPS(
	IN	ULONG				LinkSpeed
)
Convert from NDIS "Link Speed" to cells per second
--*/
#define LINKSPEED_TO_CPS(_LinkSpeed)		(((_LinkSpeed)*100)/(48*8))

// ----------------------------------------------------------------------------

/*++
ULONG
SWAPULONG(
	IN	ULONG	Val
)
--*/
#define SWAPULONG(Val)	\
	((((Val)&0xff)<<24)|(((Val)&0xff00)<<8)| \
	(((Val)&0xff0000)>>8)|(((Val)&0xff000000)>>24))

/*++
USHORT
SWAPUSHORT(
	IN	USHORT	Val
)
--*/
#define SWAPUSHORT(Val)	\
	((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))
	
// ----------------------------------------------------------------------------

/*++
BOOLEAN
ATM_ADDR_EQUAL(
	IN	PUCHAR Addr1,
	IN	PUCHAR Addr2
)
--*/
#define ATM_ADDR_EQUAL(_Addr1, _Addr2) \
	NdisEqualMemory((_Addr1), (_Addr2), ATM_ADDRESS_LENGTH)

/*++
BOOLEAN
ETH_ADDR_MULTICAST(
	IN	PUCHAR	Addr,
)
--*/
#define ETH_ADDR_MULTICAST(_Addr) ((_Addr)[0]&1)

/*++
BOOLEAN
TR_ADDR_MULTICAST(
	IN	PUCHAR	Addr,
)
--*/
#define TR_ADDR_MULTICAST(_Addr) ((_Addr)[0]&0x80)

// ----------------------------------------------------------------------------

#endif // __ATMLANE_MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\tracelog.h ===
//
// tracelog.h
//
// Copyright (c) 1996 FORE Systems, Inc.
// All rights reserved.
//
// THIS SOURCE CODE CONTAINS CONFIDENTIAL INFORMATION THAT IS OWNED BY FORE
// SYSTEMS, INC. AND MAY NOT BE COPIED, DISCLOSED OR OTHERWISE USED WITHOUT
// THE EXPRESS WRITTEN CONSENT OF FORE SYSTEMS, INC.
//

#ifndef _FORE_TRACELOG_H_
#define _FORE_TRACELOG_H_

#define MAX_TRACELOG_PARAMS 8

#define TL_GET_PARAM_COUNT(eid)  ((eid)&0xF)
#define TL_GET_EVENT(eid)        ((eid)>>4)
#define TL_BUILD_EVENT_ID(ev,p)  (((ev)<<4)|((p)&0xF))

typedef struct _TraceEntry
	{
	unsigned long EventId;
	unsigned long Time;
	unsigned long  Params[MAX_TRACELOG_PARAMS];
	} TRACEENTRY, *PTRACEENTRY;

typedef struct _TraceLog
	{
	unsigned char *Storage;
	unsigned long StorageSizeBytes;
	PTRACEENTRY First;
	PTRACEENTRY Last;
	PTRACEENTRY Current;
	} TRACELOG, *PTRACELOG;

extern void 
InitTraceLog(PTRACELOG TraceLog, unsigned char *Storage, 
	unsigned long StorageSizeBytes);

extern void 
TraceLogWrite(PTRACELOG TraceLog, unsigned long EventId, ...);

#endif // _FORE_TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\tracelog.c ===
//
// tracelog.c
//
// Copyright (c) 1996 FORE Systems, Inc.
// All rights reserved.
//
// THIS SOURCE CODE CONTAINS CONFIDENTIAL INFORMATION THAT IS OWNED BY FORE
// SYSTEMS, INC. AND MAY NOT BE COPIED, DISCLOSED OR OTHERWISE USED WITHOUT
// THE EXPRESS WRITTEN CONSENT OF FORE SYSTEMS, INC.
//

#include <precomp.h>
#include <stdlib.h>
#include <stdarg.h>
#pragma hdrstop

void
InitTraceLog(PTRACELOG TraceLog, unsigned char *Storage, 
	unsigned long StorageSizeBytes)
    {
	memset(TraceLog, 0, sizeof(TraceLog));
	if (Storage == NULL)
		return;
	TraceLog->Storage = Storage;
	TraceLog->StorageSizeBytes = StorageSizeBytes;
	TraceLog->First = (PTRACEENTRY)TraceLog->Storage;
	TraceLog->Last  = 
		(PTRACEENTRY) (TraceLog->Storage + 
		((TraceLog->StorageSizeBytes / sizeof(TRACEENTRY)) * sizeof(TRACEENTRY)) -
		sizeof(TRACEENTRY));
	TraceLog->Current = TraceLog->First;
	memset(TraceLog->Storage, 0, TraceLog->StorageSizeBytes);
    }


void
TraceLogWrite(PTRACELOG TraceLog, unsigned long EventId, ...)
	{
	PTRACEENTRY TraceEntry;
	unsigned long ParamCount;
	unsigned long i;
	va_list ap;

	if (TraceLog->Storage == NULL)
		return;
		
	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	TraceEntry = TraceLog->Current;

	ParamCount = TL_GET_PARAM_COUNT(EventId);

	memset(TraceEntry, 0, sizeof(TRACEENTRY));

	TraceEntry->EventId = EventId;

	TraceEntry->Time = AtmLaneSystemTimeMs();

	if (ParamCount > 0)
		{
		va_start(ap, EventId);
		for(i = 0; i < ParamCount; i++)
			TraceEntry->Params[i] = va_arg(ap, unsigned long);
		}

	if (TraceLog->Current >= TraceLog->Last)
		TraceLog->Current = TraceLog->First;
	else
		TraceLog->Current++;

	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\ntentry.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	ntentry.c

Abstract:

	NT entry points for ATMLANE driver.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"


#pragma hdrstop


//
//  Due to problems with including zwapi.h:
//
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );


EXTERN
NTSTATUS
AtmLaneIoctlRequest(
	IN	PIRP			pIrp
);

NTSTATUS
AtmLaneDeviceControl(
	IN	PDEVICE_OBJECT DeviceObject,
	IN	PIRP		   pIrp
);

VOID
AtmLaneUnload(
	IN	PDRIVER_OBJECT	pDriverObject
);

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	pDriverObject,
	IN	PUNICODE_STRING	RegistryPath
	)
/*++

Routine Description:

	Entry point for the driver.

Arguments:

	DriverObject	-	Pointer to the system allocated DRIVER_OBJECT.
	RegistryPath	-	Pointer to the UNICODE string defining the registry
						path for the driver's information.

Return Value:

	Appropriate NDIS_STATUS value.

--*/
{
	NTSTATUS						NtStatus	= STATUS_SUCCESS;
	UNICODE_STRING					DeviceName;
	UNICODE_STRING					DeviceLinkUnicodeString;
	NDIS_STATUS						NdisStatus;
	NDIS_HANDLE						NdisWrapperHandle = NULL;
	NDIS_HANDLE						MiniportDriverHandle;
	NDIS_HANDLE						NdisProtocolHandle;
	NDIS50_PROTOCOL_CHARACTERISTICS	AtmLaneProtChars;
	NDIS_MINIPORT_CHARACTERISTICS	AtmLaneMiniChars;
	PDRIVER_DISPATCH				DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];
	ULONG							i;
	UNICODE_STRING AtmUniKeyName = 
	NDIS_STRING_CONST("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Atmuni");

#if DBG
	volatile ULONG					DontRun = 0;
#endif

	TRACEIN(DriverEntry);

#if DBG
	DbgPrint("ATMLANE built %s %s\n", __DATE__, __TIME__);
	DbgPrint("ATMLANE: DbgVerbosity is at %p, currently set to %d\n",
				&DbgVerbosity, DbgVerbosity);

	if (DontRun > 0)
	{
		TRACEOUT(DriverEntry);
		return NDIS_STATUS_FAILURE;
	}
#endif // DBG
	
	//
	//  Initialize our globals.
	//
	AtmLaneInitGlobals();

	//
	//	Save the pointer to the Driver Object
	//
	
	pAtmLaneGlobalInfo->pDriverObject = pDriverObject;

	do
	{
		//
		//	Initialize the wrapper.
		//
		NdisInitializeWrapper(
			&NdisWrapperHandle,
			pDriverObject,
			RegistryPath,
			NULL);
		if (NULL == NdisWrapperHandle)
		{
			DBGP((0, "DriverEntry: NdisMInitializeWrapper failed!\n"));

			NdisStatus = NDIS_STATUS_FAILURE;
			break;
		}
		else
		{
			DBGP((3, "DriverEntry: NdisWrapperhandle %x\n", NdisWrapperHandle));
			//
			//	Save the handle to the wrapper.
			//	
			pAtmLaneGlobalInfo->NdisWrapperHandle = NdisWrapperHandle;
		}
		
		//
		//  Attempt to load the standard UNI 3.1 Call Manager
		//
		NtStatus = ZwLoadDriver(&AtmUniKeyName);
		DBGP((1, "ATMLANE: attempt to load ATMUNI returned %x\n", NtStatus));

		//
		//  We don't care whether we successfully loaded the call manager or not.
		//
		NtStatus = STATUS_SUCCESS;

		//
		//	Initialize the miniport characteristics.
		//
		NdisZeroMemory(&AtmLaneMiniChars, sizeof(AtmLaneMiniChars));
		AtmLaneMiniChars.MajorNdisVersion = 		4;
		AtmLaneMiniChars.MinorNdisVersion = 		0;
		// CheckForHangHandler
		// DisableInterruptHandler
		// EnableInterruptHandler
		AtmLaneMiniChars.HaltHandler = 				AtmLaneMHalt;
		// HandleInterruptHandler
		AtmLaneMiniChars.InitializeHandler = 		AtmLaneMInitialize;
		// ISRHandler
		AtmLaneMiniChars.QueryInformationHandler = 	AtmLaneMQueryInformation;
		// ReconfigureHandler
		AtmLaneMiniChars.ResetHandler = 			AtmLaneMReset;
		// SendHandler
		AtmLaneMiniChars.SetInformationHandler = 	AtmLaneMSetInformation;
		// TransferDataHandler
		AtmLaneMiniChars.ReturnPacketHandler = 		AtmLaneMReturnPacket;
		AtmLaneMiniChars.SendPacketsHandler = 		AtmLaneMSendPackets;
		// AllocateCompleteHandler

		//
		//	Register the Layered Miniport with NDIS.
		//
		NdisStatus = NdisIMRegisterLayeredMiniport(
					NdisWrapperHandle,
					&AtmLaneMiniChars,
					sizeof(AtmLaneMiniChars),
					&MiniportDriverHandle);
		if (NDIS_STATUS_SUCCESS == NdisStatus)
		{
			DBGP((3, "DriverEntry: NdisIMRegisterLayeredMiniport succeeded.\n"));
			//
			//	Save the handle to the driver.
			//
			pAtmLaneGlobalInfo->MiniportDriverHandle = MiniportDriverHandle;
		}
		else
		{
			DBGP((0, "DriverEntry: NdisIMRegisterLayeredMiniport failed! Status: %x\n",
				NdisStatus));
			break;
		}

		//
		//	Initialize the protocol characteristics.
		//
		NdisZeroMemory(&AtmLaneProtChars, sizeof(AtmLaneProtChars));
		AtmLaneProtChars.MajorNdisVersion = 			5;
		AtmLaneProtChars.MinorNdisVersion = 			0;
		AtmLaneProtChars.OpenAdapterCompleteHandler	= 	AtmLaneOpenAdapterCompleteHandler;
		AtmLaneProtChars.CloseAdapterCompleteHandler = 	AtmLaneCloseAdapterCompleteHandler;
		AtmLaneProtChars.SendCompleteHandler =			AtmLaneSendCompleteHandler;
		AtmLaneProtChars.TransferDataCompleteHandler =	AtmLaneTransferDataCompleteHandler;
		AtmLaneProtChars.ResetCompleteHandler = 		AtmLaneResetCompleteHandler;
		AtmLaneProtChars.RequestCompleteHandler = 		AtmLaneRequestCompleteHandler;
		AtmLaneProtChars.ReceiveHandler =				AtmLaneReceiveHandler;
		AtmLaneProtChars.ReceiveCompleteHandler =		AtmLaneReceiveCompleteHandler;
		AtmLaneProtChars.StatusHandler =				AtmLaneStatusHandler;
		AtmLaneProtChars.StatusCompleteHandler = 		AtmLaneStatusCompleteHandler;
		NdisInitUnicodeString(&AtmLaneProtChars.Name, ATMLANE_PROTOCOL_STRING);

		// ReceivePacketHandler;
		AtmLaneProtChars.BindAdapterHandler = 			AtmLaneBindAdapterHandler;
		AtmLaneProtChars.UnbindAdapterHandler = 		AtmLaneUnbindAdapterHandler;
		AtmLaneProtChars.PnPEventHandler = 				AtmLanePnPEventHandler;
		AtmLaneProtChars.UnloadHandler = 				AtmLaneUnloadProtocol;

		AtmLaneProtChars.CoSendCompleteHandler = 		AtmLaneCoSendCompleteHandler;
		AtmLaneProtChars.CoStatusHandler = 				AtmLaneCoStatusHandler;
		AtmLaneProtChars.CoReceivePacketHandler = 		AtmLaneCoReceivePacketHandler;
		AtmLaneProtChars.CoAfRegisterNotifyHandler =	AtmLaneAfRegisterNotifyHandler;

		//
		//	Register the Protocol with NDIS.
		//
		NdisRegisterProtocol(
			&NdisStatus,
			&NdisProtocolHandle,
			&AtmLaneProtChars,
			sizeof(AtmLaneProtChars));
		if (NDIS_STATUS_SUCCESS == NdisStatus)
		{
			DBGP((3, "DriverEntry: NdisProtocolhandle %x\n", 
				NdisProtocolHandle));
			//
			//	Save the NDIS Protocol handle.
			//	
			pAtmLaneGlobalInfo->NdisProtocolHandle = NdisProtocolHandle;
		}
		else
		{
			DBGP((0, "DriverEntry: NdisRegisterProtocol failed! Status: %x\n",
				NdisStatus));
			break;
		}

#ifndef LANE_WIN98
		//
		// Associate the miniport and protocol now
		//
		NdisIMAssociateMiniport(MiniportDriverHandle,
								NdisProtocolHandle);

#endif // LANE_WIN98

		//
		//	Register our protocol device name for special ioctls
		//
		for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
		{
			DispatchTable[i] = AtmLaneDeviceControl;
		}

		NdisInitUnicodeString(&DeviceName, ATMLANE_NTDEVICE_STRING);
		NdisInitUnicodeString(&DeviceLinkUnicodeString, ATMLANE_LINKNAME_STRING);

		NdisStatus = NdisMRegisterDevice(
						NdisWrapperHandle,
						&DeviceName,
						&DeviceLinkUnicodeString,
						&DispatchTable[0],
						&pAtmLaneGlobalInfo->pSpecialDeviceObject,   
						&pAtmLaneGlobalInfo->SpecialNdisDeviceHandle
						);

		if (NDIS_STATUS_SUCCESS != NdisStatus)
		{
			DBGP((0, "DriverEntry: NdisMRegisterDevice failed! Status: %x\n",
				NdisStatus));
			break;
		}
		
		DBGP((3, "DriverEntry: NdisMRegisterDevice: pDevObj %x DevHandle %x\n",
				pAtmLaneGlobalInfo->pSpecialDeviceObject, 
				pAtmLaneGlobalInfo->SpecialNdisDeviceHandle));

		NdisMRegisterUnloadHandler(NdisWrapperHandle,
								   AtmLaneUnload);

	} while(FALSE);


	if (NDIS_STATUS_SUCCESS != NdisStatus)
	{
		//
		//	Clean up.
		//
		if (NULL != NdisWrapperHandle)
		{
	    	NdisTerminateWrapper(
    	    		NdisWrapperHandle,
        			NULL);
        }
	}

	TRACEOUT(DriverEntry);

	return(NtStatus);
}


NTSTATUS
AtmLaneDeviceControl(
	IN	PDEVICE_OBJECT 	DeviceObject,
	IN	PIRP			pIrp
	)
/*++

Routine Description:

    This is the function that hooks NDIS's Device Control IRP
    handler to implement some protocol specific Ioctls.

Arguments:

    DeviceObject - Pointer to device object for target device
    pIrp         - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    PIO_STACK_LOCATION 	pIrpSp;
    NTSTATUS 			Status;
    
	TRACEIN(DeviceControl);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	DBGP((3, "DeviceControl %x %s\n", pIrpSp->MajorFunction, 
		IrpToString(pIrpSp->MajorFunction)));

	//
	//	We only hanle the IRP_MJ_DEVICE_CONTROL IRPs.
	//
	if (pIrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)
	{
		DBGP((3, "DeviceControl: Handling request\n"));
		Status = AtmLaneIoctlRequest(pIrp);
	}
	else
	{
		switch (pIrpSp->MajorFunction)
		{
			case IRP_MJ_CREATE:
			case IRP_MJ_CLOSE:
			case IRP_MJ_CLEANUP:
				Status = STATUS_SUCCESS;
				break;
			case IRP_MJ_SHUTDOWN:
				Status = STATUS_NOT_IMPLEMENTED;
				break;
			default:
				DBGP((3, "DeviceControl: MajorFunction not supported\n"));
				Status = STATUS_NOT_SUPPORTED;
		}
	}

	ASSERT(STATUS_PENDING != Status);

	pIrp->IoStatus.Status = Status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	TRACEOUT(DeviceControl);

	return Status;
}


VOID
AtmLaneUnload(
	IN	PDRIVER_OBJECT				pDriverObject
)
/*++

Routine Description:

	This routine is called by the system prior to unloading us.
	Currently, we just undo everything we did in DriverEntry,
	that is, de-register ourselves as an NDIS protocol, and delete
	the device object we had created.

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.

Return Value:

	None

--*/
{
	UNICODE_STRING			DeviceLinkUnicodeString;
	NDIS_STATUS				Status;

	TRACEIN(Unload);
	DBGP((0, "AtmLaneUnload\n"));

    //  Shut down the protocol first.  This is synchronous (i.e. blocks)

	AtmLaneUnloadProtocol();

	//  Delete the symbolic link created for the admin util

	if (pAtmLaneGlobalInfo->SpecialNdisDeviceHandle)
	{
		DBGP((0, "Deregistering device handle %x from AtmLaneUnload\n",
				pAtmLaneGlobalInfo->SpecialNdisDeviceHandle));
		Status = NdisMDeregisterDevice(pAtmLaneGlobalInfo->SpecialNdisDeviceHandle);
		pAtmLaneGlobalInfo->SpecialNdisDeviceHandle = NULL;
		ASSERT(NDIS_STATUS_SUCCESS == Status);
	}
	
	TRACEOUT(Unload);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\miniport.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	miniport.c

Abstract:

	Miniport upper-edge functions.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include <precomp.h>
#pragma	hdrstop

//
// List of supported OIDs for this driver when an Ethernet Elan.
//
static
NDIS_OID EthernetSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    };

static
NDIS_OID TokenRingSupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
 	OID_GEN_MAXIMUM_SEND_PACKETS,
	OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_5_PERMANENT_ADDRESS,
    OID_802_5_CURRENT_ADDRESS,
    OID_802_5_CURRENT_FUNCTIONAL,
    OID_802_5_CURRENT_GROUP,
    OID_802_5_LAST_OPEN_STATUS,
    OID_802_5_CURRENT_RING_STATUS,
    OID_802_5_CURRENT_RING_STATE,
    OID_802_5_LINE_ERRORS,
    OID_802_5_LOST_FRAMES,
    OID_802_5_BURST_ERRORS,
    OID_802_5_FRAME_COPIED_ERRORS,
    OID_802_5_TOKEN_ERRORS,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
	};



NDIS_STATUS 
AtmLaneMInitialize(
	OUT	PNDIS_STATUS			OpenErrorStatus,
	OUT	PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				WrapperConfigurationContext
)
{
    UINT 					i;
    NDIS_MEDIUM				MediumToFind;
    NDIS_STATUS				Status;
    PATMLANE_ELAN			pElan;
    PUCHAR					pMacAddr;
    UINT					MacAddrLength;
    

	TRACEIN(MInitialize);

	//
	//	Get context (Elan) supplied with NdisIMInitializeDeviceEx
	//
	pElan = NdisIMGetDeviceContext(MiniportAdapterHandle);
	STRUCT_ASSERT(pElan, atmlane_elan);

	ASSERT(pElan->Flags & ELAN_MINIPORT_INIT_PENDING);

	DBGP((1, "%d MInitialize\n", pElan->ElanNumber));

	do
	{
		Status = NDIS_STATUS_SUCCESS;
		
		//
		//	Are we Ethernet or Token Ring?
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			MediumToFind = NdisMedium802_3;
		}
		else
		{
			MediumToFind = NdisMedium802_5;
		}
	
		//
		//	Look for MediumToFind in MediumArray.
		//
    	for (i = 0; i < MediumArraySize; i++) 
       	{
        	if (MediumArray[i] == MediumToFind)
            	break;   
        }

		//
		//	Not found, return error.
        
    	if (i == MediumArraySize)
    	{
    		Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
			break;
    	}

		Status = NDIS_STATUS_SUCCESS;

    	//
    	//	Output select medium
    	//
	    *SelectedMediumIndex = i;   

		//
		//	Set my attributes
		//
		NdisMSetAttributesEx(
				MiniportAdapterHandle,					// MiniportAdapterHandle
				(NDIS_HANDLE)pElan,						// MiniportAdapterContext
				0,										// CheckForHangTimeInSeconds
				NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |	// AttributeFlags
				NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
				NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
				NDIS_ATTRIBUTE_DESERIALIZE,
				0										// AdapterType
				);

		ACQUIRE_ELAN_LOCK(pElan);
		AtmLaneReferenceElan(pElan, "miniport");

		//
		//  Save away the MiniportAdapterHandle now. This is so that we
		//  don't call NdisMIndicateStatus before calling NdisMSetAttributesEx.
		//
		pElan->MiniportAdapterHandle = MiniportAdapterHandle;
	
		RELEASE_ELAN_LOCK(pElan);

		break;
	}
	while (FALSE);

	//
	//  Wake up any thread (i.e. AtmLaneShutdownElan) waiting for
	//  a pending Init to be over.
	//
	ACQUIRE_ELAN_LOCK(pElan);
	pElan->Flags &= ~ELAN_MINIPORT_INIT_PENDING;
	RELEASE_ELAN_LOCK(pElan);

	DBGP((2, "%d MInitialize ELAN %p/%x, Ref %d, Status %x\n",
			pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, Status));

	SIGNAL_BLOCK_STRUCT(&pElan->InitBlock, NDIS_STATUS_SUCCESS);

	TRACEOUT(MInitialize);
	return Status;
}

VOID
AtmLaneMSendPackets(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PPNDIS_PACKET			PacketArray,
	IN	UINT					NumberOfPackets
)
{
	PATMLANE_ELAN		pElan;
	UINT				PacketIndex;
	PNDIS_PACKET		pSendNdisPacket;
	PNDIS_PACKET		pNewNdisPacket;
	PNDIS_BUFFER		pHeaderNdisBuffer;
	PUCHAR				pHeaderBuffer;
	PUCHAR				pPktHeader;
	PNDIS_BUFFER		pTempNdisBuffer;
	PATMLANE_VC			pVc;
	ULONG				TotalLength;
	ULONG				BufferLength;
	NDIS_STATUS			Status;
	ULONG				DestAddrType;
	MAC_ADDRESS			DestAddress;
	BOOLEAN				SendViaBUS;
	PATMLANE_MAC_ENTRY	pMacEntry;
	PATMLANE_ATM_ENTRY	pAtmEntry;
	ULONG				rc;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif

	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(MSendPackets);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	TRACELOGWRITE((&TraceLog, TL_MSENDPKTIN, NumberOfPackets));

	DBGP((2, "MSendPackets: Count %d\n", NumberOfPackets));
		
	//
	// loop thru the array of packets to send
	//
	for (PacketIndex = 0; PacketIndex < NumberOfPackets; PacketIndex++)
	{
		pSendNdisPacket = PacketArray[PacketIndex];

		pNewNdisPacket = (PNDIS_PACKET)NULL;
		SendViaBUS = FALSE;
		pMacEntry = NULL_PATMLANE_MAC_ENTRY;
		pVc = NULL_PATMLANE_VC;

		Status = NDIS_STATUS_PENDING;
		
		// DBGP((0, "MSendPackets: Pkt %x\n", pSendNdisPacket));
		
		TRACELOGWRITE((&TraceLog, TL_MSENDPKTBEGIN, PacketIndex, pSendNdisPacket));
		TRACELOGWRITEPKT((&TraceLog, pSendNdisPacket));
		
		//
		//	ALWAYS set packet status to NDIS_STATUS_PENDING
		//
		NDIS_SET_PACKET_STATUS(pSendNdisPacket, NDIS_STATUS_PENDING);

		do
		{
			//
			//	If Elan is down then just set local status to failure
			//
			if (ELAN_STATE_OPERATIONAL != pElan->State ||
				ELAN_STATE_OPERATIONAL != pElan->AdminState)
			{
				DBGP((0, "%d Send failure on ELAN %x flags %x state %d AdminSt %d\n",
						pElan->ElanNumber,
						pElan,
						pElan->Flags,
						pElan->State,
						pElan->AdminState));

				pNewNdisPacket = NULL;
				Status = NDIS_STATUS_FAILURE;
				break;
			}

			//
			//	Wrap it up for sending
			//
			pNewNdisPacket = AtmLaneWrapSendPacket(
									pElan, 
									pSendNdisPacket, 
									&DestAddrType,
									&DestAddress, 
									&SendViaBUS
									);
			if (pNewNdisPacket == (PNDIS_PACKET)NULL)
			{
				//
				//	Out of resources
				//			
				Status = NDIS_STATUS_RESOURCES;
				break;
			}

			if (SendViaBUS)
			{
				//
				//	Packet is multicast so send it to the bus
				//
				ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);

				pAtmEntry = pElan->pBusAtmEntry;

				if (pAtmEntry == NULL_PATMLANE_ATM_ENTRY)
				{
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
				pVc = pAtmEntry->pVcList;
				if (pVc == NULL_PATMLANE_VC)
				{
					RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
					RELEASE_ELAN_ATM_LIST_LOCK(pElan);
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				//
				//	Reference the VC to keep it around
				//
				ACQUIRE_VC_LOCK_DPC(pVc);
				AtmLaneReferenceVc(pVc, "temp");
				RELEASE_VC_LOCK_DPC(pVc);
		
				RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
				RELEASE_ELAN_ATM_LIST_LOCK(pElan);


				//
				//	Reacquire VC lock and dereference it
				//
				ACQUIRE_VC_LOCK(pVc);
				rc = AtmLaneDereferenceVc(pVc, "temp");
				if (rc == 0)
				{
					//
					//	Vc pulled out from under us.
					//
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				if (IS_FLAG_SET(
							pVc->Flags,
							VC_CALL_STATE_MASK,
							VC_CALL_STATE_ACTIVE))
				{
					//
					// Send it!
					//
					DBGP((2, "MSendPackets: Sending to BUS, VC %x\n", pVc));
					AtmLaneSendPacketOnVc(pVc, pNewNdisPacket, FALSE);
					//
					//	VC lock released in above
					//
				}
				else
				{
					//
					// The VC is being torn down. This should be a rare
					// occurrance, so simply drop this packet.
					//
					RELEASE_VC_LOCK(pVc);
					Status = NDIS_STATUS_FAILURE;
					break;
				}

				break;
			}

			// 
			//	Packet is unicast 
			//
			DBGP((2, "MSendPackets: Sending unicast, dest %x:%x:%x:%x:%x:%x\n", 
						((PUCHAR)&DestAddress)[0],
						((PUCHAR)&DestAddress)[1],
						((PUCHAR)&DestAddress)[2],
						((PUCHAR)&DestAddress)[3],
						((PUCHAR)&DestAddress)[4],
						((PUCHAR)&DestAddress)[5]
						));

			Status = AtmLaneSendUnicastPacket(
							pElan, 
							DestAddrType,
							&DestAddress,
							pNewNdisPacket							
							);

			break;
		}
		while (FALSE);
		
		//
		//	If no new packet header than it must be a resource failure
		//  or Elan is down. 
		//	Complete the packet with NDIS_STATUS_SUCCESS.
		//
		if (pNewNdisPacket == (PNDIS_PACKET)NULL)
		{
			ASSERT(Status != NDIS_STATUS_PENDING);

			// DBGP((0, "NdisMSendComplete: Pkt %x Stat %x\n", pSendNdisPacket, NDIS_STATUS_SUCCESS));

			NdisMSendComplete(
					pElan->MiniportAdapterHandle, 
					pSendNdisPacket, 
					NDIS_STATUS_SUCCESS);

			TRACELOGWRITE((&TraceLog, TL_MSENDPKTEND, PacketIndex, pSendNdisPacket, Status));

			continue;
		}

		//
		//	If status isn't pending then some other failure to send occurred.
		//	Complete the packet with NDIS_STATUS_SUCCESS.
		//
		if (Status != NDIS_STATUS_PENDING)
		{
#if PROTECT_PACKETS
			ACQUIRE_SENDPACKET_LOCK(pNewNdisPacket);
			ASSERT((PSEND_RSVD(pNewNdisPacket)->Flags & PACKET_RESERVED_COSENDRETURNED) == 0);
			ASSERT((PSEND_RSVD(pNewNdisPacket)->Flags & PACKET_RESERVED_COMPLETED) == 0);
			PSEND_RSVD(pNewNdisPacket)->Flags |= PACKET_RESERVED_COSENDRETURNED;			
			PSEND_RSVD(pNewNdisPacket)->Flags |= PACKET_RESERVED_COMPLETED;
#endif	// PROTECT_PACKETS
			AtmLaneCompleteSendPacket(pElan, pNewNdisPacket, NDIS_STATUS_SUCCESS);
			//
			//	packet lock released in above
			//
			TRACELOGWRITE((&TraceLog, TL_MSENDPKTEND, PacketIndex, pSendNdisPacket, Status));
			
			continue;
		}

		//
		//	Otherwise do nothing
		//
		ASSERT(Status == NDIS_STATUS_PENDING);
		TRACELOGWRITE((&TraceLog, TL_MSENDPKTEND, PacketIndex, pSendNdisPacket, Status));
		
	}	// for(...next packet

	TRACELOGWRITE((&TraceLog, TL_MSENDPKTOUT));
	
	TRACEOUT(MSendPackets);

	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

VOID
AtmLaneMReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			pNdisPacket
)
/*++

Routine Description:

	This function is called by a protocol or by NDIS on
	behalf of a protocol to return a packet that was
	retained beyond the context of the receive indication.
	
Arguments:

	MiniportAdapterContext	- Pointer to ATMLANE elan structure

	pNdisPacket				- Pointer to NDIS packet

Return Value:

	none.
	
--*/
{
	PATMLANE_ELAN		pElan;
	PNDIS_PACKET		pOrigNdisPacket;
	PNDIS_BUFFER		pTempNdisBuffer;
	ULONG				Length;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(MReturnPacket);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	TRACELOGWRITE((&TraceLog, 
			TL_MRETNPACKET,	
			pNdisPacket));

	ASSERT(NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES);

	pOrigNdisPacket = AtmLaneUnwrapRecvPacket(pElan, pNdisPacket);

	TRACELOGWRITE((&TraceLog, 
			TL_CORETNPACKET,	
			pOrigNdisPacket));
			
	//
	//  Return original packet to ATM miniport.
	//
	NdisReturnPackets(
				&pOrigNdisPacket, 
				1);

	TRACEOUT(MReturnPacket);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}

NDIS_STATUS 
AtmLaneMQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesWritten,
	OUT	PULONG					BytesNeeded
)
/*++

Routine Description:

    The QueryInformation Handler for the virtual miniport.

Arguments:

    MiniportAdapterContext 	- a pointer to the Elan.

    Oid 					- the NDIS_OID to process.

    InformationBuffer 		- a pointer into the NdisRequest->InformationBuffer
    						  into which store the result of the query.

    InformationBufferLength	- a pointer to the number of bytes left in the
    InformationBuffer.

    BytesWritten 			- a pointer to the number of bytes written into the
    InformationBuffer.

    BytesNeeded 			- If there is not enough room in the information
    						  buffer then this will contain the number of bytes
    						  needed to complete the request.

Return Value:

    The function value is the status of the operation.

--*/
{
    UINT 					BytesLeft 		= InformationBufferLength;
    PUCHAR					InfoBuffer 		= (PUCHAR)(InformationBuffer);
    NDIS_STATUS 			StatusToReturn	= NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS	HardwareStatus	= NdisHardwareStatusReady;
    NDIS_MEDIA_STATE		MediaState;
    NDIS_MEDIUM 			Medium;
  	PATMLANE_ELAN			pElan;	
  	PATMLANE_ADAPTER		pAdapter;
    ULONG 					GenericULong;
    USHORT 					GenericUShort;
    UCHAR 					GenericArray[6];
    UINT 					MoveBytes 		= sizeof(ULONG);
    PVOID 					MoveSource 		= (PVOID)(&GenericULong);
	ULONG 					i;
	PATMLANE_MAC_ENTRY		pMacEntry;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	BOOLEAN					IsShuttingDown;
#if DEBUG_IRQL
	KIRQL					EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);

	TRACEIN(MQueryInformation);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((1, "%d Query OID %x %s\n", pElan->ElanNumber, Oid, OidToString(Oid)));

	ACQUIRE_ELAN_LOCK(pElan);
	IsShuttingDown = (ELAN_STATE_OPERATIONAL != pElan->AdminState);
	pAdapter = pElan->pAdapter;
	RELEASE_ELAN_LOCK(pElan);

    //
    // Switch on request type
    //
    switch (Oid) 
    {
	    case OID_GEN_MAC_OPTIONS:

    	    GenericULong = 						
    	    	NDIS_MAC_OPTION_NO_LOOPBACK;

    	    DBGP((2, "Value %d\n", GenericULong));

        	break;

    	case OID_GEN_SUPPORTED_LIST:

    		if (pElan->LanType == LANE_LANTYPE_ETH)
    		{
	        	MoveSource = (PVOID)(EthernetSupportedOids);
    	    	MoveBytes = sizeof(EthernetSupportedOids);
    	    }
    	    else
    	    {
	        	MoveSource = (PVOID)(TokenRingSupportedOids);
    	    	MoveBytes = sizeof(TokenRingSupportedOids);
    	    }
        	break;

	    case OID_GEN_HARDWARE_STATUS:

    	    HardwareStatus = NdisHardwareStatusReady;
        	MoveSource = (PVOID)(&HardwareStatus);
	        MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

    	    break;

		case OID_GEN_MEDIA_CONNECT_STATUS:
			if (ELAN_STATE_OPERATIONAL == pElan->State)
			{
				MediaState = NdisMediaStateConnected;
			}
			else
			{
				MediaState = NdisMediaStateDisconnected;
			}
			DBGP((2, "%d Elan %p returning conn status %d: %s\n",
						pElan->ElanNumber,
						pElan,
						MediaState,
						((MediaState == NdisMediaStateConnected)?
							"Connected": "Disconnected")));
			MoveSource = (PVOID)(&MediaState);
			MoveBytes = sizeof(NDIS_MEDIA_STATE);

			break;

	    case OID_GEN_MEDIA_SUPPORTED:
	    case OID_GEN_MEDIA_IN_USE:

    		if (pElan->LanType == LANE_LANTYPE_ETH)
    		{
    			Medium = NdisMedium802_3;
    			DBGP((2, "Media is NdisMedium802_3\n"));
    		}
    		else
    		{
    			Medium = NdisMedium802_5;
    			DBGP((2, "Media is NdisMedium802_5\n"));
	   		}
    	    MoveSource = (PVOID) (&Medium);
        	MoveBytes = sizeof(NDIS_MEDIUM);

	        break;

	    case OID_GEN_MAXIMUM_LOOKAHEAD:
	    
    	    if (pAdapter != NULL_PATMLANE_ADAPTER)
    	    {
    	    	GenericULong = pElan->pAdapter->MaxAAL5PacketSize;
    	    }
    	    else
    	    {
    	    	GenericULong = pElan->CurLookAhead;
    	    }
    	    
   			DBGP((2, "Value %d\n", GenericULong));
    	    
        	break;
        	
    	case OID_GEN_CURRENT_LOOKAHEAD:

    		if (pElan->CurLookAhead == 0)
    		{
    			if (pAdapter != NULL_PATMLANE_ADAPTER)
    			{
					pElan->CurLookAhead = pAdapter->MaxAAL5PacketSize;
				}
    		}

    	    GenericULong = pElan->CurLookAhead;
    	    
   			DBGP((2, "Value %d\n", GenericULong));
    	    
        	break;

   		case OID_GEN_MAXIMUM_FRAME_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_ETH_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

        	break;

		case OID_GEN_MAXIMUM_TOTAL_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;

    	case OID_GEN_TRANSMIT_BLOCK_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;
			
    	case OID_GEN_RECEIVE_BLOCK_SIZE:

			GenericULong = (pElan->MaxFrameSize - LANE_HEADERSIZE);
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;
    	
		case OID_GEN_MAXIMUM_SEND_PACKETS:

			GenericULong = 32;		// XXX What is our limit? From adapter?
			
   			DBGP((2, "Value %d\n", GenericULong));

			break;
		
		case OID_GEN_LINK_SPEED:

        	if (pAdapter != NULL_PATMLANE_ADAPTER)
        	{
        		GenericULong = pElan->pAdapter->LinkSpeed.Outbound;
        	}
        	else
        	{
        		GenericULong = ATM_USER_DATA_RATE_SONET_155;
        	}
			
   			DBGP((2, "Value %d\n", GenericULong));

        	break;

    	case OID_GEN_TRANSMIT_BUFFER_SPACE:
    	case OID_GEN_RECEIVE_BUFFER_SPACE:

        	GenericULong = 32 * 1024;	// XXX What should this really be?
			
   			DBGP((2, "Value %d\n", GenericULong));

        	break;

	    case OID_GEN_VENDOR_ID:

       		NdisMoveMemory(
            	(PVOID)&GenericULong,
            	&pElan->MacAddressEth,
            	3
            	);
        	GenericULong &= 0xFFFFFF00;
        	MoveSource = (PVOID)(&GenericULong);
        	MoveBytes = sizeof(GenericULong);
        	break;

    	case OID_GEN_VENDOR_DESCRIPTION:

        	MoveSource = (PVOID)"Microsoft ATM LAN Emulation";
        	MoveBytes = 28;

        	break;

    	case OID_GEN_DRIVER_VERSION:
    	case OID_GEN_VENDOR_DRIVER_VERSION:

        	GenericUShort = ((USHORT)5 << 8) | 0;
        	MoveSource = (PVOID)(&GenericUShort);
        	MoveBytes = sizeof(GenericUShort);

        	DBGP((2, "Value %x\n", GenericUShort));

        	break;

    	case OID_802_3_PERMANENT_ADDRESS:
    	case OID_802_3_CURRENT_ADDRESS:
    	
        	NdisMoveMemory((PCHAR)GenericArray,
        				&pElan->MacAddressEth,
        				sizeof(MAC_ADDRESS));
        	MoveSource = (PVOID)(GenericArray);
        	MoveBytes = sizeof(MAC_ADDRESS);

        	DBGP((1, "%d Address is %s\n", pElan->ElanNumber, 
        		MacAddrToString(MoveSource)));

        	break;

    	case OID_802_5_PERMANENT_ADDRESS:
    	case OID_802_5_CURRENT_ADDRESS:

        	NdisMoveMemory((PCHAR)GenericArray,
        				&pElan->MacAddressTr,
        				sizeof(MAC_ADDRESS));
        	MoveSource = (PVOID)(GenericArray);
        	MoveBytes = sizeof(MAC_ADDRESS);

        	DBGP((1, "%d Address is %s\n", pElan->ElanNumber,
        		MacAddrToString(MoveSource)));

        	break;

		case OID_802_3_MULTICAST_LIST:

			MoveSource = (PVOID) &pElan->McastAddrs[0];
			MoveBytes = pElan->McastAddrCount * sizeof(MAC_ADDRESS);

			break;

    	case OID_802_3_MAXIMUM_LIST_SIZE:

        	GenericULong = MCAST_LIST_SIZE;
		
   			DBGP((2, "Value %d\n", GenericULong));
        	
        	break;
        	
    	case OID_802_5_CURRENT_FUNCTIONAL:
		case OID_802_5_CURRENT_GROUP:

        	NdisZeroMemory((PCHAR)GenericArray,
        				sizeof(MAC_ADDRESS));
        	MoveSource = (PVOID)(GenericArray);
        	MoveBytes = sizeof(MAC_ADDRESS);

        	DBGP((2, "Address is %s\n", MacAddrToString(MoveSource)));

			break;
			
		case OID_802_5_LAST_OPEN_STATUS:
		case OID_802_5_CURRENT_RING_STATUS:
		case OID_802_5_CURRENT_RING_STATE:

		   	GenericULong = 0;

		   	DBGP((2, "Value %d\n", GenericULong));

        	break;


    	case OID_GEN_XMIT_OK:

        	GenericULong = (UINT)(pElan->FramesXmitGood);

		   	DBGP((2, "Value %d\n", GenericULong));
		   	
        	break;

    	case OID_GEN_RCV_OK:

        	GenericULong = (UINT)(pElan->FramesRecvGood);

		   	DBGP((2, "Value %d\n", GenericULong));
		   	
        	break;

    	case OID_GEN_XMIT_ERROR:
    	case OID_GEN_RCV_ERROR:
    	case OID_GEN_RCV_NO_BUFFER:
    	case OID_802_3_RCV_ERROR_ALIGNMENT:
    	case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
		case OID_802_5_LINE_ERRORS:
    	case OID_802_5_LOST_FRAMES:
    	case OID_802_5_BURST_ERRORS:
    	case OID_802_5_FRAME_COPIED_ERRORS:
    	case OID_802_5_TOKEN_ERRORS:

        	GenericULong = 0;

		   	DBGP((2, "Value %d\n", GenericULong));
        	
        	break;

    	default:

        	StatusToReturn = NDIS_STATUS_INVALID_OID;
        	break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        if (MoveBytes > BytesLeft) 
        {
            //
            // Not enough room in InformationBuffer. Punt
            //
            *BytesNeeded = MoveBytes;

            *BytesWritten = 0;

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            //
            // Store result.
            //
            NdisMoveMemory(InfoBuffer, MoveSource, MoveBytes);

            *BytesWritten = MoveBytes;
        }
    }

	DBGP((2, "Query Status %x\n", StatusToReturn));

	TRACEOUT(MQueryInformation);
	CHECK_EXIT_IRQL(EntryIrql); 
    return StatusToReturn;
}

NDIS_STATUS 
AtmLaneMSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
)
/*++

Routine Description:

    Handles a set operation for a single OID.

Arguments:

    MiniportAdapterContext 	- a pointer to the Elan.

    Oid 					- the NDIS_OID to process.

    InformationBuffer 		- Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead 				- If the call is successful, returns the number
        					  of bytes read from InformationBuffer.

    BytesNeeded 			- If there is not enough data in InformationBuffer
        					  to satisfy the OID, returns the amount of storage
        					  needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID

--*/
{
    NDIS_STATUS 		StatusToReturn	= NDIS_STATUS_SUCCESS;
    UINT 				BytesLeft 		= InformationBufferLength;
    PUCHAR 				InfoBuffer		= (PUCHAR)(InformationBuffer);
    UINT 				OidLength;
    ULONG 				LookAhead;
    ULONG 				Filter;
    PATMLANE_ELAN		pElan;
    BOOLEAN				IsShuttingDown;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
    
	TRACEIN(MSetInformation);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);
	
	DBGP((1, "%d Set OID %x %s\n", pElan->ElanNumber, Oid, OidToString(Oid)));

	ACQUIRE_ELAN_LOCK(pElan);
	IsShuttingDown = (ELAN_STATE_OPERATIONAL != pElan->AdminState);
	RELEASE_ELAN_LOCK(pElan);

	if (IsShuttingDown)
	{
		DBGP((1, "%d ELAN shutting down. Trivially succeeding Set OID %x %s\n", 
			pElan->ElanNumber, Oid, OidToString(Oid)));
        *BytesRead = 0;
        *BytesNeeded = 0;

		StatusToReturn = NDIS_STATUS_SUCCESS;
		return (StatusToReturn);
	}

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) 
    {

    	case OID_802_3_MULTICAST_LIST:

			if (OidLength % sizeof(MAC_ADDRESS))
			{
				StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	    *BytesRead = 0;
    	        *BytesNeeded = 0;
	            break;
			}
			
			if (OidLength > (MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)))
			{
	            StatusToReturn = NDIS_STATUS_MULTICAST_FULL;
        	    *BytesRead = 0;
    	        *BytesNeeded = 0;
	            break;
			}
			
			NdisZeroMemory(
					&pElan->McastAddrs[0], 
					MCAST_LIST_SIZE * sizeof(MAC_ADDRESS)
					);
			NdisMoveMemory(
					&pElan->McastAddrs[0], 
					InfoBuffer,
					OidLength
					);
			pElan->McastAddrCount = OidLength / sizeof(MAC_ADDRESS);

#if DBG
			{
				ULONG i;

				for (i = 0; i < pElan->McastAddrCount; i++)
				{
					DBGP((2, "%s\n", MacAddrToString(&pElan->McastAddrs[i])));
				}
			}
#endif // DBG

			break;

    	case OID_GEN_CURRENT_PACKET_FILTER:
	        //
   	     	// Verify length
   	     	//
        	if (OidLength != sizeof(ULONG)) 
        	{
	            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	    *BytesRead = 0;
    	        *BytesNeeded = sizeof(ULONG);
	            break;
    	    }

	        //
	        // Store the new value.
	        //
			NdisMoveMemory(&Filter, InfoBuffer, sizeof(ULONG));

			//
			// Don't allow promisc mode, because we can't support that.
			//
			if (Filter & NDIS_PACKET_TYPE_PROMISCUOUS)
			{
				StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;
				break;
			}

			ACQUIRE_ELAN_LOCK(pElan);
		
           	pElan->CurPacketFilter = Filter;

			//
			//	Mark Miniport Running if not already
			//
			if ((pElan->Flags & ELAN_MINIPORT_OPERATIONAL) == 0)
			{
				pElan->Flags |= ELAN_MINIPORT_OPERATIONAL;

				DBGP((1, "%d Miniport OPERATIONAL\n", pElan->ElanNumber));
			}
			
			RELEASE_ELAN_LOCK(pElan);
           	
           	DBGP((2, "CurPacketFilter now %x\n", Filter));

            break;

	    case OID_802_5_CURRENT_FUNCTIONAL:
		case OID_802_5_CURRENT_GROUP:

			// XXX just accept whatever for now ???
			
            break;

    	case OID_GEN_CURRENT_LOOKAHEAD:

	        //
   	     	// Verify length
   	     	//
        	if (OidLength != 4) 
        	{
	            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	    *BytesRead = 0;
    	        *BytesNeeded = 0;
	            break;
    	    }

	        //
	        // Store the new value.
	        //
			NdisMoveMemory(&LookAhead, InfoBuffer, 4);
		
	        if ((pElan->pAdapter == NULL_PATMLANE_ADAPTER) ||
				(LookAhead <= pElan->pAdapter->MaxAAL5PacketSize))
	        {
            	pElan->CurLookAhead = LookAhead;
            	DBGP((2, "CurLookAhead now %d\n", LookAhead));
        	}
        	else 
        	{
           		StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        	}

        	break;

    	case OID_GEN_NETWORK_LAYER_ADDRESSES:
    		StatusToReturn = AtmLaneMSetNetworkAddresses(
    							pElan,
    							InformationBuffer,
    							InformationBufferLength,
    							BytesRead,
    							BytesNeeded);
    		break;
    							
    	default:

        	StatusToReturn = NDIS_STATUS_INVALID_OID;

        	*BytesRead = 0;
       		*BytesNeeded = 0;

        	break;

	}

    if (StatusToReturn == NDIS_STATUS_SUCCESS) 
    {
        *BytesRead = BytesLeft;
        *BytesNeeded = 0;
    }

	DBGP((2, "Set Status %x\n", StatusToReturn));

	TRACEOUT(MSetInformation);
	CHECK_EXIT_IRQL(EntryIrql); 
	return StatusToReturn;
}


NDIS_STATUS 
AtmLaneMReset(
	OUT	PBOOLEAN 				AddressingReset,
	IN	NDIS_HANDLE 			MiniportAdapterContext
)
{
	TRACEIN(MReset);

	TRACEOUT(MReset);
	return NDIS_STATUS_NOT_RESETTABLE;
}

VOID 
AtmLaneMHalt(
	IN	NDIS_HANDLE 			MiniportAdapterContext
)
{
    PATMLANE_ELAN		pElan;
    ULONG				rc;
#if DEBUG_IRQL
	KIRQL				EntryIrql;
#endif
	GET_ENTRY_IRQL(EntryIrql);
	TRACEIN(MHalt);

	pElan = (PATMLANE_ELAN)MiniportAdapterContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	ACQUIRE_ELAN_LOCK(pElan);

	DBGP((1, "%d MHalt pElan %x, ref count %d, Admin state %d, State %d\n",
			 pElan->ElanNumber, pElan, pElan->RefCount, pElan->AdminState, pElan->State));

	pElan->MiniportAdapterHandle = NULL;

	rc = AtmLaneDereferenceElan(pElan, "miniport");	// Miniport handle is gone.

	if (rc != 0)
	{
		AtmLaneShutdownElan(pElan, FALSE);
		// lock released in above
	}
	//
	//  else the Elan is gone.
	//

	TRACEOUT(MHalt);
	CHECK_EXIT_IRQL(EntryIrql); 
	return;
}



PNDIS_PACKET
AtmLaneWrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pSendNdisPacket,
	OUT	ULONG *					pAddressType,					
	OUT	PMAC_ADDRESS			pDestAddress,
	OUT	BOOLEAN	*				pSendViaBUS
)
/*++

Routine Description:

	This function repackages a protocol sent NDIS packet.
	It puts on a new NDIS packet header and a buffer for
	the LANE header. It saves away the original packet
	header in the ProtocolReserved area of the new packet header.
	Additionally, it determines if packet is to be sent via
	the BUS and the destination address of the packet.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pSendNdisPacket			- Pointer to NDIS packet

	pAddressType			- Pointer to ULONG that gets one of
							  (LANE_MACADDRTYPE_MACADDR, 
							   LANE_MACADDRTYPE_ROUTEDESCR).
							   
	pDestAddress			- Pointer to 6-byte buffer that gets
							  destination address.

	pSendViaBus				- Pointer to boolean

Return Value:

	New NDIS packet header or NULL if out of resources.
	
--*/
{
	PNDIS_PACKET			pNewNdisPacket;
	PNDIS_BUFFER			pTempNdisBuffer;
	PUCHAR					pHeaderBuffer;
	PUCHAR					pNewHeaderBuffer;
	PUCHAR					pNewPadBuffer;
	ULONG					BufferLength;
	ULONG					TotalLength;
	PNDIS_BUFFER			pHeaderNdisBuffer;
	PNDIS_BUFFER			pPadNdisBuffer;
	NDIS_STATUS				Status;
	PSEND_PACKET_RESERVED	pNewPacketContext;
	ULONG					OrigBufferCount;
	ULONG					WrappedBufferCount;
	ULONG					RILength;
	BOOLEAN					DirectionBit;
	PUCHAR					pCurRouteDescr;
	PUCHAR					pNextRouteDescr;

	TRACEIN(WrapSendPacket);

	//
	//	Initialize
	//
	pNewNdisPacket = (PNDIS_PACKET)NULL;
	pHeaderNdisBuffer = (PNDIS_BUFFER)NULL;
	pPadNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	OrigBufferCount = 0;
	WrappedBufferCount = 0;

	do
	{
		//
		//	Get first buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pSendNdisPacket, 
				&pTempNdisBuffer, 
				&pHeaderBuffer,
				&BufferLength,
				&TotalLength);

		DBGP((3, "WrapSendPacket: SendPkt %x Length %d\n", 
				pSendNdisPacket, TotalLength));

		ASSERT(pTempNdisBuffer != NULL);

		//
		//	Allocate a new transmit packet descriptor
		//	
		NdisAllocatePacket(&Status, &pNewNdisPacket, pElan->TransmitPacketPool);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "WrapSendPacket: Alloc xmit NDIS Packet failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
#if PKT_HDR_COUNTS
		InterlockedDecrement(&pElan->XmitPktCount);
		if ((pElan->XmitPktCount % 20) == 0)
		{
			DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
		}
#endif

		//
		//	Allocate a Header Buffer
		//
		pHeaderNdisBuffer = AtmLaneAllocateHeader(pElan, &pNewHeaderBuffer);
		if (pHeaderNdisBuffer == (PNDIS_BUFFER)NULL)
		{
			DBGP((0, "WrapSendPacket: Alloc Header Buffer failed\n"));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//	Spec says we can put zero or our LECID in the header.
		//	We'll put our LECID in the header for echo-filtering purposes.
		//
		ASSERT(pElan->HeaderBufSize == LANE_HEADERSIZE);
		*((PUSHORT)pNewHeaderBuffer) = pElan->LecId;
			

		//
		//	Allocate a pad buffer now, if necessary, before we get all tied
		//	up in knots.
		//
		if ((TotalLength + LANE_HEADERSIZE) < pElan->MinFrameSize)
		{
			pPadNdisBuffer = AtmLaneAllocatePadBuf(pElan, &pNewPadBuffer);
			if (pPadNdisBuffer == (PNDIS_BUFFER)NULL)
			{
				DBGP((0, "WrapSendPacket: Alloc Pad Buffer failed\n"));
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		//
		//	Put new header buffer at head of new NDIS Packet
		//
		NdisChainBufferAtFront(pNewNdisPacket, pHeaderNdisBuffer);
		WrappedBufferCount++;

		//
		//	Chain buffers from send packet onto tail of new NDIS Packet
		//
		do
		{
			NdisUnchainBufferAtFront(pSendNdisPacket, &pTempNdisBuffer);

			if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
				break;
			ASSERT(pTempNdisBuffer->Next == NULL);
			OrigBufferCount++;
			NdisChainBufferAtBack(pNewNdisPacket, pTempNdisBuffer);
			WrappedBufferCount++;
		}
		while (TRUE);

		//
		//	Chain pad buffer on tail if needed (it would be allocated already)
		//
		if (pPadNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NdisChainBufferAtBack(pNewNdisPacket, pPadNdisBuffer);
			WrappedBufferCount++;

			//
			//	Set size of pad buffer to minimum necessary
			//
			NdisAdjustBufferLength(pPadNdisBuffer, 
					pElan->MinFrameSize - TotalLength - LANE_HEADERSIZE);
		}

		//
		//	Save away pointer to original NDIS Packet header in reserved
		//	area of our new NDIS Packet header.
		//
		//	NOTE use of ProtocolReserved in this case!
		//
		//	Also set Owner and Multicast flags appropriately.
		//
		pNewPacketContext = 
			(PSEND_PACKET_RESERVED)&pNewNdisPacket->ProtocolReserved;
		NdisZeroMemory(pNewPacketContext, sizeof(SEND_PACKET_RESERVED));
#if PROTECT_PACKETS
		INIT_SENDPACKET_LOCK(pNewNdisPacket);
#endif	// PROTECT_PACKETS
#if DBG
		pNewPacketContext->Signature = 'ENAL';
#endif
		pNewPacketContext->pOrigNdisPacket = pSendNdisPacket;
		pNewPacketContext->OrigBufferCount = OrigBufferCount;
		pNewPacketContext->OrigPacketLength = TotalLength;
		pNewPacketContext->WrappedBufferCount = WrappedBufferCount;
		SET_FLAG(
				pNewPacketContext->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_PROTOCOL
				);
		ASSERT(pNewPacketContext->Flags == PACKET_RESERVED_OWNER_PROTOCOL);

		//
		//	Branch on Ethernet v.s. Token Ring to sniff pkt contents
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{

			//	Send packet via BUS if it has a multicast
			// 	Destination Address. If low-order bit in
			//	first byte of the Destination Address is set then
			//  it's a multicast or broadcast address.
			//	Destination Address is first in packet header and it's
			//	always a MAC address.
			//
			*pSendViaBUS = ((*pHeaderBuffer) & 1) != 0;
			*pAddressType = LANE_MACADDRTYPE_MACADDR;
			NdisMoveMemory(pDestAddress, pHeaderBuffer, 6);
		}
		else
		{
			ASSERT(pElan->LanType == LANE_LANTYPE_TR);
		
			//
			//	now the very complicated sorting of TR packets
			//
			do
			{
				//
				//	Section 8.5.3 of LANE Specification.
				//	Multicast frames go to the BUS.
				//
				if ((*(pHeaderBuffer+2) & 0x80) != 0)		// DA multicast bit present?
				{
					*pSendViaBUS = TRUE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Section 8.5.2 of LANE Specification.
				//	NSR frames go to destination address.
				//
				if ( (*(pHeaderBuffer+8) & 0x80) == 0)		// SA RI bit not present?
				{
					*pSendViaBUS = FALSE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Section 8.5.4 of LANE Specification.
				//	ARE or STE frames go to the BUS.
				//
				if ( ((*(pHeaderBuffer+8) & 0x80) != 0) &&	// SA RI bit present and
					 ((*(pHeaderBuffer+14) & 0xe0) !=0) )	// RI type field upper bits on?
				{
					*pSendViaBUS = TRUE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				// 	Frame is source routed so extract Routing Information (RI) length.
				//
				RILength = *(pHeaderBuffer+14) & 0x1f;
				
				//
				//	Section 8.5.7 of LANE Specification.
				//	SR frame with a RI length less than 6 contains no hops.
				//	Send to destination address.
				//
				if (RILength < 6)
				{
					*pSendViaBUS = FALSE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Section 8.5.6 of LANE Specification.
				//	Odd RILength is invalid, we choose to send via BUS.
				//
				if ((RILength & 1) != 0)
				{
					*pSendViaBUS = FALSE;
					*pAddressType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddress, pHeaderBuffer+2, 6);
					break;
				}

				
				//
				//	Section 8.5.5 of LANE Specification.
				//	At this point we have a SR frame with RI Length >= 6;
				//	We are never a bridge so frame should go to "next RD".
				//
				*pSendViaBUS = FALSE;
				*pAddressType = LANE_MACADDRTYPE_ROUTEDESCR;
				NdisZeroMemory(pDestAddress, 4);

				DirectionBit = (*(pHeaderBuffer+15) & 0x80) != 0;

				if (DirectionBit)
				{
					//
					//	Frame is traversing LAN in reverse order of RDs.
					//	"next RD" is the next-to-last RD in the packet.
					//	Use Segment ID and Bridge Num from this RD.
					//
					pNextRouteDescr = pHeaderBuffer+14+RILength-4;
					pDestAddress->Byte[4] = pNextRouteDescr[0];
					pDestAddress->Byte[5] = pNextRouteDescr[1];
				}
				else
				{
					//
					//	Frame is traversing LAN in the order of the RDs.
					//	"next RD" straddles the first and second RD in the packet.
					//	Use Segment ID from second RD and Bridge Num from first RD.
					//
					pCurRouteDescr	= pHeaderBuffer+14+2;	// first RD
					pNextRouteDescr	= pHeaderBuffer+14+4;	// second RD
					pDestAddress->Byte[4] = pNextRouteDescr[0];
					pDestAddress->Byte[5] = (pNextRouteDescr[1] & 0xf0) | (pCurRouteDescr[1] & 0x0f);
				}
				break;
			}
			while (FALSE);
		}

		NdisQueryPacket(pNewNdisPacket, NULL, NULL, NULL, &TotalLength);
		DBGP((3, "WrapSendPacket: SendPkt %x NewPkt %x Bufs %d Length %d\n", 
			pSendNdisPacket, pNewNdisPacket, WrappedBufferCount, TotalLength));

		TRACELOGWRITE((&TraceLog, 
				TL_WRAPSEND,
				pSendNdisPacket, 
				pNewNdisPacket, 
				WrappedBufferCount, 
				TotalLength));
		TRACELOGWRITEPKT((&TraceLog, pNewNdisPacket));

		break;
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNewNdisPacket != (PNDIS_PACKET)NULL)
		{
#if PROTECT_PACKETS
			FREE_SENDPACKET_LOCK(pNewNdisPacket);
#endif	// PROTECT_PACKETS
			NdisFreePacket(pNewNdisPacket);
			pNewNdisPacket = (PNDIS_PACKET)NULL;
#if PKT_HDR_COUNTS
			InterlockedIncrement(&pElan->XmitPktCount);
			if ((pElan->XmitPktCount % 20) == 0 &&
				pElan->XmitPktCount != pElan->MaxHeaderBufs)
			{
				DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
			}
#endif
		}
		
		if (pHeaderNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeHeader(pElan, pHeaderNdisBuffer, FALSE);
			pHeaderNdisBuffer = (PNDIS_BUFFER)NULL;
		}

		if (pPadNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreePadBuf(pElan, pPadNdisBuffer, FALSE);
			pPadNdisBuffer = (PNDIS_BUFFER)NULL;
		}

	}

	TRACEOUT(WrapSendPacket);

	return pNewNdisPacket;
}


PNDIS_PACKET
AtmLaneUnwrapSendPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pNdisPacket		LOCKIN NOLOCKOUT
)
/*++

Routine Description:

	This function basically undoes what AtmLaneWrapSendPacket
	does.  It removes the new NDIS packet header and the LANE 
	header and frees them.  It restores the original packet header.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pNdisPacket				- Pointer to NDIS packet

Return Value:

	Original NDIS packet header.
	
--*/
{
	PSEND_PACKET_RESERVED	pPacketContext;
	UINT					TotalLength;
	PNDIS_PACKET			pOrigNdisPacket;
	PNDIS_BUFFER			pTempNdisBuffer;
	ULONG					OrigPacketLength;
	ULONG					OrigBufferCount;
	ULONG					WrappedBufferCount;
	ULONG					BufferCount;
	BOOLEAN 				First;

	TRACEIN(UnwrapSendPacket);

	//
	//	Get original packet header from reserved area.
	//
	pPacketContext = PSEND_RSVD(pNdisPacket);
	pOrigNdisPacket = pPacketContext->pOrigNdisPacket;
	OrigBufferCount = pPacketContext->OrigBufferCount;
	OrigPacketLength = pPacketContext->OrigPacketLength;
	WrappedBufferCount = pPacketContext->WrappedBufferCount;
	
	ASSERT(pPacketContext->Signature == 'ENAL');
	ASSERT((pPacketContext->Flags & PACKET_RESERVED_OWNER_PROTOCOL) != 0);
	ASSERT(pPacketContext->pOrigNdisPacket != NULL);

	//
	//	Unchain first buffer (ours) and free it.
	//

	pTempNdisBuffer = (PNDIS_BUFFER)NULL;
	NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
	ASSERT(pTempNdisBuffer != (PNDIS_BUFFER)NULL);
	AtmLaneFreeHeader(pElan, pTempNdisBuffer, FALSE);

	//
	//	If padded, unchain last buffer (ours) and free it.
	//
	if ((WrappedBufferCount - OrigBufferCount) > 1)
	{
		pTempNdisBuffer = (PNDIS_BUFFER)NULL;
		NdisUnchainBufferAtBack(pNdisPacket, &pTempNdisBuffer);
		ASSERT(pTempNdisBuffer != (PNDIS_BUFFER)NULL);
		AtmLaneFreePadBuf(pElan, pTempNdisBuffer, FALSE);
	}
		
	//
	//	Put rest of buffers back on original packet header.
	//
	First = TRUE;
	BufferCount = 0;
	do 
	{
		NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
		ASSERT(!((pTempNdisBuffer == NULL) && First));
		First = FALSE;
		if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
			break;
		NdisChainBufferAtBack(pOrigNdisPacket, pTempNdisBuffer);
		BufferCount++;
	}
	while (TRUE);

	NdisQueryPacket(pOrigNdisPacket, NULL, NULL, NULL, &TotalLength);
	DBGP((3, "UnwrapSendPacket: SendPkt %x Bufcnt %d Length %d\n",
		pOrigNdisPacket, BufferCount, TotalLength));

	TRACELOGWRITE((&TraceLog, 
				TL_UNWRAPSEND,	
				pNdisPacket,
				pOrigNdisPacket,
				BufferCount, 
				TotalLength));
	TRACELOGWRITEPKT((&TraceLog, pOrigNdisPacket));
				
	ASSERT(OrigBufferCount == BufferCount);
//	ASSERT(OrigPacketLength == TotalLength);

	//
	//	Free the packet header
	//
#if PROTECT_PACKETS
	RELEASE_SENDPACKET_LOCK(pNdisPacket);
	FREE_SENDPACKET_LOCK(pNdisPacket);
#endif	// PROTECT_PACKETS
	NdisFreePacket(pNdisPacket);
#if PKT_HDR_COUNTS
	InterlockedIncrement(&pElan->XmitPktCount);
	if ((pElan->XmitPktCount % 20) == 0 &&
		pElan->XmitPktCount != pElan->MaxHeaderBufs)
	{
		DBGP((1, "XmitPktCount %d\n", pElan->XmitPktCount));
	}
#endif
	
	TRACEOUT(UnwrapSendPacket);

	return pOrigNdisPacket;
}

PNDIS_PACKET
AtmLaneWrapRecvPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pRecvNdisPacket,
	OUT	ULONG *					pMacHdrSize,
	OUT	ULONG *					pDestAddrType,					
	OUT	PMAC_ADDRESS			pDestAddr,
	OUT	BOOLEAN	*				pDestIsMulticast
)
/*++

Routine Description:

	This function repackages an adapter received NDIS packet.
	It puts on a new packet header and creates a new buffer
	descriptor for the first fragment that skips the 2-byte
	LANE header.  It then saves away the original packet 
	header with the original first buffer descriptor in the
	MiniportReserved area of the new packet header.
	Additionally, it outputs the destination address, the
	destination's address type if the packet is a destination
	address is a multicast address.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pRecvNdisPacket			- Pointer to NDIS packet

	pMacHdrSize				- Pointer to ULONG that get the length
							  of the MAC header.

	pDestAddrType			- Pointer to ULONG that gets one of
							  (LANE_MACADDRTYPE_MACADDR, 
							   LANE_MACADDRTYPE_ROUTEDESCR).
							   
	pDestAddr				- Pointer to 6-byte buffer that gets
							  destination address.

	pDestIsMulticast		- Pointer to boolean that gets TRUE if
							  destination address is a multicast.

Return Value:

	New NDIS packet header or NULL if out of resources.
	
--*/
{
	ULONG					TotalLength;
	ULONG					TempLength;
	PUCHAR					pHeaderBuffer;
	PUCHAR					pBuffer;
	PNDIS_PACKET			pNewNdisPacket;
	PNDIS_BUFFER			pFirstNdisBuffer;
	PNDIS_BUFFER			pTempNdisBuffer;
	PNDIS_BUFFER			pNewNdisBuffer;
	PUCHAR					pTempBuffer;
	PRECV_PACKET_RESERVED	pNewPacketContext;
	NDIS_STATUS				Status;
	ULONG					BufferCount;
	
	TRACEIN(WrapRecvPacket);

	//
	//	Initialize
	//
	pNewNdisPacket = (PNDIS_PACKET)NULL;
	pNewNdisBuffer = (PNDIS_BUFFER)NULL;
	Status = NDIS_STATUS_SUCCESS;
	BufferCount = 0;

	do
	{
		//
		//	Get first buffer and total length of packet
		//		
		NdisGetFirstBufferFromPacket(
				pRecvNdisPacket, 
				&pTempNdisBuffer, 
				&pHeaderBuffer,
				&TempLength,
				&TotalLength);

		DBGP((3, "WrapRecvPacket: RecvPkt %x Length %d\n", 
				pRecvNdisPacket, TotalLength));
		//
		//	Allocate a new recv packet descriptor
		//	
		NdisAllocatePacket(&Status, &pNewNdisPacket, pElan->ReceivePacketPool);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "WrapRecvPacket: Alloc recv NDIS Packet failed\n"));
			break;
		}
		
#if PKT_HDR_COUNTS
		InterlockedDecrement(&pElan->RecvPktCount);
		if ((pElan->RecvPktCount % 20) == 0)
		{
			DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
		}
#endif

		//
		//	Unchain first buffer 
		//
		NdisUnchainBufferAtFront(pRecvNdisPacket, &pFirstNdisBuffer);
		ASSERT(pFirstNdisBuffer != (PNDIS_BUFFER)NULL);
		NdisQueryBuffer(pFirstNdisBuffer, &pTempBuffer, &TempLength);
		ASSERT(TempLength > 2);

		//
		//	"Copy" it to another buffer header skipping the first 2 bytes
		//
		NdisCopyBuffer(
				&Status, 
				&pNewNdisBuffer, 
				pElan->ReceiveBufferPool, 
				pFirstNdisBuffer, 
				2, 
				(TempLength - 2)
				);
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, "DataPacketHandler: NdisCopyBuffer failed (%x)\n",
				Status));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
			
		//
		//	Chain new buffer onto new packet header.
		//
		NdisChainBufferAtFront(pNewNdisPacket, pNewNdisBuffer);
		BufferCount++;
		
		//
		//	Chain rest of buffers onto tail of new NDIS Packet
		//
		do
		{
			NdisUnchainBufferAtFront(pRecvNdisPacket, &pTempNdisBuffer);

			if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
				break;
			ASSERT(pTempNdisBuffer->Next == NULL);
			NdisChainBufferAtBack(pNewNdisPacket, pTempNdisBuffer);
			BufferCount++;
		}
		while (TRUE);

		//
		//	Chain original first buffer back on original packet
		//
		NdisChainBufferAtFront(pRecvNdisPacket, pFirstNdisBuffer);

		//
		//	Save away pointer to original NDIS Packet header in reserved
		//	area of our new NDIS Packet header.
		//
		//	NOTE use of MiniportReserved in this case!
		//
		//	Also set Owner flag appropriately.
		pNewPacketContext = 
			(PRECV_PACKET_RESERVED)&pNewNdisPacket->MiniportReserved;
		NdisZeroMemory(pNewPacketContext, sizeof(*pNewPacketContext));
		pNewPacketContext->pNdisPacket = pRecvNdisPacket;
		SET_FLAG(
				pNewPacketContext->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_MINIPORT
				);

		//
		//	Increment the frame header pointer past the
		//	LANE header (+2 bytes)
		//
		pHeaderBuffer += 2;
		
		//
		//	Output the MAC header length.
		//	Output the address type.
		//	Output the destination address.
		//	Determine if packet is a multicast.
		//
		if (pElan->LanType == LANE_LANTYPE_ETH)
		{
			//	
			//	Ethernet/802.3 is simple.
			//
			//	Header size is always 14.
			//	Type is always a MAC address.
			//	Dest Addr is first 6 bytes of header.
			//	DestAddress is Multicast if low-order bit in
			//	first byte of the Destination Address is set.
			//
			*pMacHdrSize = 14;
			*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
			NdisMoveMemory(pDestAddr, pHeaderBuffer, 6);
			*pDestIsMulticast = (((*pHeaderBuffer) & 1) != 0);
		}
		else
		{
			//
			//	Token Ring/802.5 is a slightly less simple (understatement!).
			//

			do
			{
				//
				//	Calculate MAC header size.
				//
				*pMacHdrSize = 14;								// start with minimum
				if (pHeaderBuffer[8] & 0x80)					// if SR info present
				{
					*pMacHdrSize += (pHeaderBuffer[14] & 0x1F);// add on SR info length
				}

				//
				//	Is it a true Multicast?
				//
				if ((*(pHeaderBuffer+2) & 0x80) != 0)		// DA multicast bit present?
				{
					*pDestIsMulticast = TRUE;
					*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddr, pHeaderBuffer+2, 6);
					break;
				}

				//
				//	Is it an All Routes Explorer (ARE) or Spanning Tree Explorer (STE)?
				//	If so treat it as a multicast.
				//
				if ( ((*(pHeaderBuffer+8) & 0x80) != 0) &&	// SA RI bit present and
					 ((*(pHeaderBuffer+14) & 0xe0) !=0) )	// RI type field upper bits on?
				{
					*pDestIsMulticast = TRUE;
					*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
					NdisMoveMemory(pDestAddr, pHeaderBuffer+2, 6);
					break;
				}
				
				//
				//	Otherwise it is unicast, Source Routed or not.
				//
				*pDestIsMulticast = FALSE;
				*pDestAddrType = LANE_MACADDRTYPE_MACADDR;
				NdisMoveMemory(pDestAddr, pHeaderBuffer+2, 6);
				break;
			}
			while (FALSE);

		} // if (pElan->LanType == LANE_LANTYPE_ETH)


		NdisQueryPacket(pNewNdisPacket, NULL, NULL, NULL, &TotalLength);
		DBGP((3, "WrapRecvPacket: RecvPkt %x NewPkt %x Length %d\n",
			pRecvNdisPacket, pNewNdisPacket, TempLength));

		TRACELOGWRITE((&TraceLog, 
				TL_WRAPRECV,
				pRecvNdisPacket, 
				pNewNdisPacket, 
				BufferCount, 
				TotalLength));
		break;
	}	
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pNewNdisPacket != (PNDIS_PACKET)NULL)
		{
			NdisFreePacket(pNewNdisPacket);
#if PKT_HDR_COUNTS
			InterlockedIncrement(&pElan->RecvPktCount);
			if ((pElan->RecvPktCount % 20) == 0 &&
				pElan->RecvPktCount != pElan->MaxHeaderBufs)
			{
				DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
			}
#endif
			pNewNdisPacket = NULL;
		}

		if (pNewNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			AtmLaneFreeProtoBuffer(pElan, pNewNdisBuffer);
		}
	}

	TRACEOUT(WrapRecvPacket);
	
	return pNewNdisPacket;
}


PNDIS_PACKET
AtmLaneUnwrapRecvPacket(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_PACKET				pNdisPacket
)
/*++

Routine Description:

	This function basically undoes what AtmLaneWrapRecvPacket
	does.  It removes the new NDIS packet header and the 
	2-byte offset buffer descriptor. It restores the original
	packet header and first buffer descriptor.
	
Arguments:

	pElan					- Pointer to ATMLANE elan structure

	pNdisPacket				- Pointer to NDIS packet

Return Value:

	Original NDIS packet header.
	
--*/
{
	PRECV_PACKET_RESERVED	pPacketContext;
	PNDIS_PACKET			pOrigNdisPacket;
	PNDIS_BUFFER			pTempNdisBuffer;
	ULONG					BufferCount;
	ULONG					TotalLength;	

	TRACEIN(UnwrapRecvPacket);

	//
	//	Get original packet from MiniportReserved.
	//	Should have original first buffer on it still.
	//
	pPacketContext = (PRECV_PACKET_RESERVED)&pNdisPacket->MiniportReserved;
	pOrigNdisPacket = pPacketContext->pNdisPacket;
	ASSERT(pOrigNdisPacket != (PNDIS_PACKET)NULL);
	ASSERT(pOrigNdisPacket->Private.Head != (PNDIS_BUFFER)NULL);
	BufferCount = 1;

	//
	//	Unchain first buffer (ours) and free it.
	//
	NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
	NdisFreeBuffer(pTempNdisBuffer);
	
	//
	//	Put rest of buffers back on original packet header.
	//
	do 
	{
		NdisUnchainBufferAtFront(pNdisPacket, &pTempNdisBuffer);
		if (pTempNdisBuffer == (PNDIS_BUFFER)NULL)
			break;
		ASSERT(pTempNdisBuffer->Next == NULL);
		NdisChainBufferAtBack(pOrigNdisPacket, pTempNdisBuffer);
		BufferCount++;
	}
	while (TRUE);

	NdisQueryPacket(pOrigNdisPacket, NULL, NULL, NULL, &TotalLength);
	DBGP((3, "UnwrapRecvPacket: Pkt %x Length %d\n", pOrigNdisPacket, TotalLength));

	TRACELOGWRITE((&TraceLog, 
				TL_UNWRAPRECV,	
				pNdisPacket,
				pOrigNdisPacket,
				BufferCount, 
				TotalLength));

	//
	//	Free the recv packet descriptor.
	//
	NdisFreePacket(pNdisPacket);
	
#if PKT_HDR_COUNTS
	InterlockedIncrement(&pElan->RecvPktCount);
			if ((pElan->RecvPktCount % 20) == 0 &&
				pElan->RecvPktCount != pElan->MaxHeaderBufs)
	{
		DBGP((1, "RecvPktCount %d\n", pElan->RecvPktCount));
	}
#endif

	TRACEOUT(UnwrapRecvPacket);

	return pOrigNdisPacket;
}



NDIS_STATUS
AtmLaneMSetNetworkAddresses(
	IN	PATMLANE_ELAN			pElan,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT	PULONG					BytesRead,
	OUT	PULONG					BytesNeeded
)
/*++

Routine Description:

    Called when the protocol above us wants to let us know about
    the network address(es) assigned to this interface. If this is TCP/IP,
    then we reformat and send a request to the ATM Call Manager to set
    its atmfMyIpNmAddress object. We pick the first IP address given to us.

Arguments:

	pElan					- Pointer to the ELAN

    InformationBuffer 		- Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead 				- If the call is successful, returns the number
        					  of bytes read from InformationBuffer.

    BytesNeeded 			- If there is not enough data in InformationBuffer
        					  to satisfy the OID, returns the amount of storage
        					  needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
--*/
{
	NETWORK_ADDRESS_LIST UNALIGNED *		pAddrList;
	NETWORK_ADDRESS UNALIGNED *				pAddr;
	NETWORK_ADDRESS_IP UNALIGNED *			pIpAddr;
	PNDIS_REQUEST							pNdisRequest;
	ULONG									RequestSize;
	PUCHAR									pNetworkAddr;
	NDIS_HANDLE								NdisAdapterHandle;
	NDIS_HANDLE								NdisAfHandle;
	NDIS_STATUS								Status;

	//
	//  Initialize.
	//
	*BytesRead = 0;
	Status = NDIS_STATUS_SUCCESS;

	pAddrList = (NETWORK_ADDRESS_LIST UNALIGNED *)InformationBuffer;

	do
	{
		ACQUIRE_ELAN_LOCK(pElan);

		if (NULL_PATMLANE_ADAPTER != pElan->pAdapter)
		{
			NdisAfHandle = pElan->NdisAfHandle;
			NdisAdapterHandle = pElan->pAdapter->NdisAdapterHandle;
		}
		else
		{
			Status = NDIS_STATUS_FAILURE;
		}

		RELEASE_ELAN_LOCK(pElan);

		if (NDIS_STATUS_SUCCESS != Status)
		{
			break;
		}

		*BytesNeeded = sizeof(*pAddrList) -
						FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
						sizeof(NETWORK_ADDRESS) -
						FIELD_OFFSET(NETWORK_ADDRESS, Address);

		if (InformationBufferLength < *BytesNeeded)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		if (pAddrList->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
		{
			// Not interesting.
			break;
		}

		if (pAddrList->AddressCount <= 0)
		{
			Status = NDIS_STATUS_INVALID_DATA;
			break;
		}

		pAddr = (NETWORK_ADDRESS UNALIGNED *)&pAddrList->Address[0];

		if ((pAddr->AddressLength > InformationBufferLength - *BytesNeeded) ||
			(pAddr->AddressLength == 0))
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		if (pAddr->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
		{
			// Not interesting.
			break;
		}

		if (pAddr->AddressLength < sizeof(NETWORK_ADDRESS_IP))
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}

		pIpAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];

		//
		//  Allocate an NDIS request to send down to the call manager.
		//
		RequestSize = sizeof(NDIS_REQUEST) + sizeof(pIpAddr->in_addr);
		ALLOC_MEM(&pNdisRequest, RequestSize);

		if (pNdisRequest == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Copy the network address in.
		//
		pNetworkAddr = ((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
		NdisMoveMemory(pNetworkAddr, &pIpAddr->in_addr, sizeof(pIpAddr->in_addr));

		DBGP((3, "%d Set network layer addr: length %d\n", pElan->ElanNumber, pAddr->AddressLength));
#if DBG
		if (pAddr->AddressLength >= 4)
		{
			DBGP((1, "Network layer addr: %d.%d.%d.%d\n",
					pNetworkAddr[0],
					pNetworkAddr[1],
					pNetworkAddr[2],
					pNetworkAddr[3]));
		}
#endif // DBG

		//
		//  Send off the request.
		//
		Status = AtmLaneSendNdisCoRequest(
					NdisAdapterHandle,
					NdisAfHandle,
					pNdisRequest,
					NdisRequestSetInformation,
					OID_ATM_MY_IP_NM_ADDRESS,
					pNetworkAddr,
					sizeof(pIpAddr->in_addr)
					);
		
		if (Status == NDIS_STATUS_PENDING)
		{
			Status = NDIS_STATUS_SUCCESS;
		}

		break;
	}
	while (FALSE);


	return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\config.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\config.h

Abstract:

	Configurable constants for Null transport.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/

#ifndef _TDI__RWAN_CONFIG__H
#define _TDI__RWAN_CONFIG__H


//
//  Initial size of send packet pool.
//
#define RWAN_INITIAL_SEND_PACKET_COUNT			100
//
//  How much do we allow the send packet pool to overflow?
//
#define RWAN_OVERFLOW_SEND_PACKET_COUNT			1000


//
//  Initial size of receive packet pool. Allocated if/when we need to
//  copy a received packet because the miniport doesn't allow us to
//  keep the original.
//
#define RWAN_INITIAL_COPY_PACKET_COUNT			100
//
//  How much do we allow the receive copy packet pool to overflow?
//
#define RWAN_OVERFLOW_COPY_PACKET_COUNT			500


#endif // _TDI__RWAN_CONFIG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\core\debug.c

Abstract:

    This module contains all debug-related code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		05-29-97	Created, based on ATM ARP.

Notes:

--*/


#include <precomp.h>
#include "ntddk.h"
#include "ndis.h"
#include "atm.h"

#define STRUCT_OF(type, address, field) CONTAINING_RECORD(address, type, field)

#include "debug.h"

ULONG	gHackSendSize = 0;

#if DBG

INT		RWanDebugLevel=DL_WARN;
ULONG	RWanDebugComp=DC_WILDCARD;
INT	RWanDataDebugLevel=0;
INT	RWandBigDataLength=8000;
INT	RWanSkipAll = 0;

#if DBG_LOG_PACKETS
NDIS_SPIN_LOCK		RWanDPacketLogLock;
#endif

NDIS_SPIN_LOCK		RWanDbgLogLock;

PRWAND_ALLOCATION	RWandMemoryHead = (PRWAND_ALLOCATION)NULL;
PRWAND_ALLOCATION	RWandMemoryTail = (PRWAND_ALLOCATION)NULL;
ULONG				RWandAllocCount = 0;	// how many allocated so far (unfreed)

NDIS_SPIN_LOCK		RWandMemoryLock;
BOOLEAN				RWandInitDone = FALSE;


PVOID
RWanAuditAllocMem(
	PVOID	pPointer,
	ULONG	Size,
	ULONG	FileNumber,
	ULONG	LineNumber
)
{
	PVOID				pBuffer;
	PRWAND_ALLOCATION	pAllocInfo;

	if (!RWandInitDone)
	{
		NdisAllocateSpinLock(&(RWandMemoryLock));
		RWandInitDone = TRUE;
	}

	NdisAllocateMemoryWithTag(
		(PVOID *)&pAllocInfo,
		Size+sizeof(RWAND_ALLOCATION),
		(ULONG)'naWR'
	);

	if (pAllocInfo == (PRWAND_ALLOCATION)NULL)
	{
		RWANDEBUGP(DL_VERY_LOUD+50, DC_WILDCARD,
			("RWanAuditAllocMem: file %d, line %d, Size %d failed!\n",
				FileNumber, LineNumber, Size));
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pAllocInfo->UserData);
		RWAN_SET_MEM(pBuffer, 0xaf, Size);
		pAllocInfo->Signature = RWAND_MEMORY_SIGNATURE;
		pAllocInfo->FileNumber = FileNumber;
		pAllocInfo->LineNumber = LineNumber;
		pAllocInfo->Size = Size;
		pAllocInfo->Location = (ULONG_PTR)pPointer;
		pAllocInfo->Next = (PRWAND_ALLOCATION)NULL;

		NdisAcquireSpinLock(&(RWandMemoryLock));

		pAllocInfo->Prev = RWandMemoryTail;
		if (RWandMemoryTail == (PRWAND_ALLOCATION)NULL)
		{
			// empty list
			RWandMemoryHead = RWandMemoryTail = pAllocInfo;
		}
		else
		{
			RWandMemoryTail->Next = pAllocInfo;
		}
		RWandMemoryTail = pAllocInfo;
		
		RWandAllocCount++;
		NdisReleaseSpinLock(&(RWandMemoryLock));
	}

	RWANDEBUGP(DL_VERY_LOUD+100, DC_WILDCARD,
	 ("RWanAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x%p] <- 0x%p\n",
	 			(CHAR)(FileNumber & 0xff),
	 			(CHAR)((FileNumber >> 8) & 0xff),
	 			(CHAR)((FileNumber >> 16) & 0xff),
	 			(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber, Size, pPointer, pBuffer));

	return (pBuffer);

}


VOID
RWanAuditFreeMem(
	PVOID	Pointer
)
{
	PRWAND_ALLOCATION	pAllocInfo;

	NdisAcquireSpinLock(&(RWandMemoryLock));

	pAllocInfo = STRUCT_OF(RWAND_ALLOCATION, Pointer, UserData);

	if (pAllocInfo->Signature != RWAND_MEMORY_SIGNATURE)
	{
		RWANDEBUGP(DL_ERROR, DC_WILDCARD,
		 ("RWanAuditFreeMem: unknown buffer 0x%p!\n", Pointer));
		NdisReleaseSpinLock(&(RWandMemoryLock));
#ifdef DBG
		DbgBreakPoint();
#endif
		return;
	}

	pAllocInfo->Signature = (ULONG)'DEAD';
	if (pAllocInfo->Prev != (PRWAND_ALLOCATION)NULL)
	{
		pAllocInfo->Prev->Next = pAllocInfo->Next;
	}
	else
	{
		RWandMemoryHead = pAllocInfo->Next;
	}
	if (pAllocInfo->Next != (PRWAND_ALLOCATION)NULL)
	{
		pAllocInfo->Next->Prev = pAllocInfo->Prev;
	}
	else
	{
		RWandMemoryTail = pAllocInfo->Prev;
	}
	RWandAllocCount--;
	NdisReleaseSpinLock(&(RWandMemoryLock));

	NdisFreeMemory(pAllocInfo, 0, 0);
}


VOID
RWanAuditShutdown(
	VOID
)
{
	if (RWandInitDone)
	{
		if (RWandAllocCount != 0)
		{
			RWANDEBUGP(DL_ERROR, DC_WILDCARD, ("AuditShutdown: unfreed memory, %d blocks!\n",
					RWandAllocCount));
			RWANDEBUGP(DL_ERROR, DC_WILDCARD, ("MemoryHead: 0x%p, MemoryTail: 0x%p\n",
					RWandMemoryHead, RWandMemoryTail));
			DbgBreakPoint();
			{
				PRWAND_ALLOCATION		pAllocInfo;

				while (RWandMemoryHead != (PRWAND_ALLOCATION)NULL)
				{
					pAllocInfo = RWandMemoryHead;
					RWANDEBUGP(DL_INFO, DC_WILDCARD, ("AuditShutdown: will free 0x%p\n", pAllocInfo));
					RWanAuditFreeMem(&(pAllocInfo->UserData));
				}
			}
		}
		RWandInitDone = FALSE;
	}
}

#define MAX_HD_LENGTH		128

VOID
DbgPrintHexDump(
	IN	PUCHAR			pBuffer,
	IN	ULONG			Length
)
/*++

Routine Description:

	Print a hex dump of the given contiguous buffer. If the length
	is too long, we truncate it.

Arguments:

	pBuffer			- Points to start of data to be dumped
	Length			- Length of above.

Return Value:

	None

--*/
{
	ULONG		i;

	if (Length > MAX_HD_LENGTH)
	{
		Length = MAX_HD_LENGTH;
	}

	for (i = 0; i < Length; i++)
	{
		//
		//  Check if we are at the end of a line
		//
		if ((i > 0) && ((i & 0xf) == 0))
		{
			DbgPrint("\n");
		}

		//
		//  Print addr if we are at start of a new line
		//
		if ((i & 0xf) == 0)
		{
			DbgPrint("%08x ", pBuffer);
		}

		DbgPrint(" %02x", *pBuffer++);
	}

	//
	//  Terminate the last line.
	//
	if (Length > 0)
	{
		DbgPrint("\n");
	}
}


VOID
DbgPrintAtmAddr(
	IN	PCHAR					pString,
	IN	ATM_ADDRESS UNALIGNED *	pAddr
)
{
	ULONG			i;
	ULONG			NumOfDigits;
	PUCHAR			pSrc, pDst;
	UCHAR			AddrString[(ATM_ADDRESS_LENGTH*2) + 1];

	//
	// Prepare the Address string in ASCII
	//
	if ((NumOfDigits = pAddr->NumberOfDigits) > ATM_ADDRESS_LENGTH)
	{
		NumOfDigits = ATM_ADDRESS_LENGTH;
	}

	pSrc = pAddr->Address;
	pDst = AddrString;
	for (i = 0; i < NumOfDigits; i++, pSrc++)
	{
		*pDst = ((*pSrc) >> 4);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
		*pDst = ((*pSrc) & 0x0F);
		*pDst += (((*pDst) > 9) ? ('A' - 10) : '0');
		pDst++;
	}

	*pDst = '\0';

	DbgPrint("%s%s\n", pString, AddrString);
}



VOID
RWanCoSendPackets(
	IN	NDIS_HANDLE				NdisVcHandle,
	IN	PNDIS_PACKET *			PacketArray,
	IN	UINT					PacketCount
)
{
	PNDIS_PACKET		pNdisPacket;
	UINT				c;
	NDIS_STATUS			Status;
	PNDIS_BUFFER		pNdisBuffer;
	PULONG				pContext;

	for (c = 0; c < PacketCount; c++)
	{
		pNdisPacket = PacketArray[c];
		RWAN_ASSERT(pNdisPacket->Private.Head != NULL);
		Status = NDIS_GET_PACKET_STATUS(pNdisPacket);
		RWAN_ASSERT(Status != NDIS_STATUS_FAILURE);
		for (pNdisBuffer = pNdisPacket->Private.Head;
			 pNdisBuffer != NULL;
			 pNdisBuffer = pNdisBuffer->Next)
		{
			if (pNdisBuffer->Next == NULL)
			{
				RWAN_ASSERT(pNdisBuffer == pNdisPacket->Private.Tail);
			}
		}
		pContext = (PULONG)&(pNdisPacket->WrapperReserved[0]);
		*pContext = 'RWan';
	}

	NdisCoSendPackets(NdisVcHandle, PacketArray, PacketCount);
}

#endif // DBG


#if DBG_SPIN_LOCK
ULONG	RWandSpinLockInitDone = 0;
NDIS_SPIN_LOCK	RWandLockLock;

VOID
RWanAllocateSpinLock(
	IN	PRWAN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	if (RWandSpinLockInitDone == 0)
	{
		RWandSpinLockInitDone = 1;
		NdisAllocateSpinLock(&(RWandLockLock));
	}

	NdisAcquireSpinLock(&(RWandLockLock));
	pLock->Signature = RWANL_SIG;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired = 0;
	pLock->OwnerThread = 0;
	NdisAllocateSpinLock(&(pLock->NdisLock));
	NdisReleaseSpinLock(&(RWandLockLock));
}


VOID
RWanAcquireSpinLock(
	IN	PRWAN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	PKTHREAD		pThread;

	pThread = KeGetCurrentThread();
	NdisAcquireSpinLock(&(RWandLockLock));
	if (pLock->Signature != RWANL_SIG)
	{
		DbgPrint("Trying to acquire uninited lock 0x%p, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired != 0)
	{
		if (pLock->OwnerThread == pThread)
		{
			DbgPrint("Detected multiple locking!: pLock 0x%p, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
			DbgPrint("pLock 0x%p already acquired in File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(pLock->TouchedByFileNumber & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 8) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 16) & 0xff),
				(CHAR)((pLock->TouchedByFileNumber >> 24) & 0xff),
				pLock->TouchedInLineNumber);
			DbgBreakPoint();
		}
	}

	pLock->IsAcquired++;

	NdisReleaseSpinLock(&(RWandLockLock));
	NdisAcquireSpinLock(&(pLock->NdisLock));

	//
	//  Mark this lock.
	//
	pLock->OwnerThread = pThread;
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
}


VOID
RWanReleaseSpinLock(
	IN	PRWAN_LOCK		pLock,
	IN	ULONG				FileNumber,
	IN	ULONG				LineNumber
)
{
	NdisDprAcquireSpinLock(&(RWandLockLock));
	if (pLock->Signature != RWANL_SIG)
	{
		DbgPrint("Trying to release uninited lock 0x%p, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}

	if (pLock->IsAcquired == 0)
	{
		DbgPrint("Detected release of unacquired lock 0x%p, File %c%c%c%c, Line %d\n",
				pLock,
				(CHAR)(FileNumber & 0xff),
				(CHAR)((FileNumber >> 8) & 0xff),
				(CHAR)((FileNumber >> 16) & 0xff),
				(CHAR)((FileNumber >> 24) & 0xff),
				LineNumber);
		DbgBreakPoint();
	}
	pLock->TouchedByFileNumber = FileNumber;
	pLock->TouchedInLineNumber = LineNumber;
	pLock->IsAcquired--;
	pLock->OwnerThread = 0;
	NdisDprReleaseSpinLock(&(RWandLockLock));

	NdisReleaseSpinLock(&(pLock->NdisLock));
}
#endif // DBG_SPIN_LOCK


#ifdef PERF


#define MAX_SEND_LOG_ENTRIES		100

LARGE_INTEGER		TimeFrequency;
BOOLEAN				SendLogInitDone = FALSE;
BOOLEAN				SendLogUpdate = TRUE;
NDIS_SPIN_LOCK		SendLogLock;

DL_SEND_LOG_ENTRY	SendLog[MAX_SEND_LOG_ENTRIES];
ULONG				SendLogIndex = 0;
PDL_SEND_LOG_ENTRY	pSendLog = SendLog;

ULONG				MaxSendTime;

#define TIME_TO_ULONG(_pTime)	 *((PULONG)_pTime)

VOID
RWandLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
)
{
	ULONG		Length;

	if (SendLogInitDone == FALSE)
	{
		SendLogInitDone = TRUE;
		(VOID)KeQueryPerformanceCounter(&TimeFrequency);
		MaxSendTime = (TIME_TO_ULONG(&TimeFrequency) * 2)/3;
		NdisAllocateSpinLock(&SendLogLock);
	}

	NdisQueryPacket(
			pNdisPacket,
			NULL,
			NULL,
			NULL,
			&Length
			);

	NdisAcquireSpinLock(&SendLogLock);
	pSendLog->Flags = DL_SEND_FLAG_WAITING_COMPLETION;
	if (pRCE != NULL)
	{
		pSendLog->Flags |= DL_SEND_FLAG_RCE_GIVEN;
	}
	pSendLog->pNdisPacket = pNdisPacket;
	pSendLog->Destination = Destination;
	pSendLog->Length = Length;
	pSendLog->SendTime = KeQueryPerformanceCounter(&TimeFrequency);

	pSendLog++;
	SendLogIndex++;
	if (SendLogIndex == MAX_SEND_LOG_ENTRIES)
	{
		SendLogIndex = 0;
		pSendLog = SendLog;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
RWandLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PDL_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	if (!SendLogUpdate)
	{
		return;
	}

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & DL_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->SendTime = KeQueryPerformanceCounter(&TimeFrequency);
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}



VOID
RWandLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
)
{
	PDL_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;

	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & DL_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags &= ~DL_SEND_FLAG_WAITING_COMPLETION;
			pEntry->Flags |= DL_SEND_FLAG_COMPLETED;
			pEntry->SendCompleteTime = KeQueryPerformanceCounter(&TimeFrequency);

			if (((pEntry->Flags & DL_SEND_FLAG_RCE_GIVEN) != 0) &&
				((SendTime = TIME_TO_ULONG(&pEntry->SendCompleteTime) -
							TIME_TO_ULONG(&pEntry->SendTime)) > MaxSendTime))
			{
				DbgPrint("Dest %d.%d.%d.%d, Pkt 0x%p, Len %d, Flags 0x%x, Took Long %d (0x%x)\n",
						((PUCHAR)&pEntry->Destination)[0],
						((PUCHAR)&pEntry->Destination)[1],
						((PUCHAR)&pEntry->Destination)[2],
						((PUCHAR)&pEntry->Destination)[3],
						pNdisPacket, pEntry->Length, pEntry->Flags, SendTime, SendTime);
			}
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}


VOID
RWandLogSendAbort(
	IN	PNDIS_PACKET		pNdisPacket
)
{
	PDL_SEND_LOG_ENTRY	pEntry;
	ULONG				Index;
	ULONG				SendTime;


	NdisAcquireSpinLock(&SendLogLock);

	pEntry = SendLog;
	for (Index = 0; Index < MAX_SEND_LOG_ENTRIES; Index++)
	{
		if (((pEntry->Flags & DL_SEND_FLAG_WAITING_COMPLETION) != 0) &&
			(pEntry->pNdisPacket == pNdisPacket))
		{
			pEntry->Flags = 0;
			break;
		}
		pEntry++;
	}

	NdisReleaseSpinLock(&SendLogLock);
}

#endif // PERF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\addr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\addr.c

Abstract:

	TDI Entry points and support routines for Address Objects.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-29-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'RDDA'


//
//  Context we use to keep track of NDIS SAP registration
//
typedef struct _RWAN_REGISTER_SAP_CONTEXT
{
	PRWAN_NDIS_SAP				pRWanNdisSap;
	CO_SAP						CoSap;

} RWAN_REGISTER_SAP_CONTEXT, *PRWAN_REGISTER_SAP_CONTEXT;




TDI_STATUS
RWanTdiOpenAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
    IN	ULONG						AddrListLength,
    IN	UINT						Protocol,
    IN	PUCHAR						pOptions
    )
/*++

Routine Description:

	This is the TDI entry point for opening (creating) an Address Object.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pAddrList		- List of alternative addresses, one of which we're to open.
	AddrListLength	- Length of the above
	Protocol		- Identifies the TDI Protocol being opened.
	pOptions		- Unused.

Return Value:

	TDI_STATUS -- TDI_SUCCESS if a new Address Object was successfully
	created, TDI_BAD_ADDR if the given address isn't valid,
	TDI_ADDR_IN_USE if it is a duplicate.

--*/
{
	PRWAN_TDI_PROTOCOL				pProtocol;
	PRWAN_TDI_ADDRESS				pAddrObject;
	TA_ADDRESS *			        pTransportAddress;
	TDI_STATUS						Status;
	INT								rc;

	UNREFERENCED_PARAMETER(pOptions);

	//
	//  Initialize.
	//
	pAddrObject = NULL_PRWAN_TDI_ADDRESS;
	Status = TDI_SUCCESS;

	do
	{
		//
		//  Get our protocol structure for the protocol being opened.
		//
		pProtocol = RWanGetProtocolFromNumber(Protocol);
		if (pProtocol == NULL_PRWAN_TDI_PROTOCOL)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: unknown protocol number %d\n", Protocol));
			Status = TDI_BAD_ADDR;
			break;
		}

		//
		//  Does this protocol allow creation of address objects?
		//
		if (!pProtocol->bAllowAddressObjects)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: Protocol %d/x%x doesn't allow addr objs\n",
						Protocol, pProtocol));
			Status = TDI_BAD_ADDR;
			break;
		}

		//
		//  Go through the given Address list and find the first one
		//  that matches the protocol.
		//
		pTransportAddress = (*pProtocol->pAfInfo->AfChars.pAfSpGetValidTdiAddress)(
								pProtocol->pAfInfo->AfSpContext,
								pAddrList,
								AddrListLength
								);

		if (pTransportAddress == NULL)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: No valid addr for Protocol x%x in list x%x\n",
						pProtocol, pAddrList));
			Status = TDI_BAD_ADDR;
			break;
		}


		RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
				("RWanTdiOpenAddress: pProto x%x, addr x%x, type %d, length %d\n",
					pProtocol,
					pTransportAddress,
					pTransportAddress->AddressType,
					pTransportAddress->AddressLength));


		//
		//  Allocate an Address Object.
		//
		pAddrObject = RWanAllocateAddressObject(pTransportAddress);

		if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
		{
			RWANDEBUGP(DL_WARN, DC_ADDRESS,
					("RWanTdiOpenAddress: couldnt allocate addr obj: %d bytes\n",
						sizeof(RWAN_TDI_ADDRESS)+pTransportAddress->AddressLength));

			Status = TDI_NO_RESOURCES;
			break;
		}

		pAddrObject->pProtocol = pProtocol;


		//
		//  Get a context for this address object from the media-specific
		//  module.
		//
		if (pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpOpenAddress)
		{
			RWAN_STATUS		RWanStatus;

			RWanStatus = (*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpOpenAddress)(
							pAddrObject->pProtocol->pAfInfo->AfSpContext,
							(RWAN_HANDLE)pAddrObject,
							&(pAddrObject->AfSpAddrContext));

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				Status = RWanToTdiStatus(RWanStatus);
				break;
			}

			RWAN_SET_BIT(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID);
		}


		RWAN_ACQUIRE_ADDRESS_LIST_LOCK();


		//
		//  If this is a non-NULL address, register NDIS SAPs on all
		//  AF bindings for this protocol.
		//
		if (!((*pProtocol->pAfInfo->AfChars.pAfSpIsNullAddress)(
						pProtocol->pAfInfo->AfSpContext,
						pTransportAddress)))
		{
			//
			//  Add a temp ref so that the address object doesn't go away.
			//
			RWanReferenceAddressObject(pAddrObject);	// TdiOpenAddress temp ref

			Status = RWanCreateNdisSaps(pAddrObject, pProtocol);

			if (Status != TDI_SUCCESS)
			{
				if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID))
				{
					(*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpCloseAddress)(
						pAddrObject->AfSpAddrContext);
					
					RWAN_RESET_BIT(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID);
				}
			}

			//
			//  Get rid of the temp reference.
			//
			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
			rc = RWanDereferenceAddressObject(pAddrObject);	// TdiOpenAddr temp ref

			if (rc != 0)
			{
				RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
			}
			else
			{
				//
				//  The address object is gone. Meaning no SAPs got registered.
				//
				pAddrObject = NULL;

				//
				//  Fix up the status only if we haven't got one already.
				//
				if (Status == TDI_SUCCESS)
				{
					Status = TDI_BAD_ADDR;
				}
			}

			if (Status != TDI_SUCCESS)
			{
				RWAN_RELEASE_ADDRESS_LIST_LOCK();
				break;
			}
		}

		RWAN_ASSERT(pAddrObject != NULL);

		RWanReferenceAddressObject(pAddrObject);	// TdiOpenAddress ref

		//
		//  Link this to the list of address objects on this protocol.
		//
		RWAN_INSERT_HEAD_LIST(&(pProtocol->AddrObjList),
							 &(pAddrObject->AddrLink));

		RWAN_RELEASE_ADDRESS_LIST_LOCK();

		//
		//  Fix up all return values.
		//
		pTdiRequest->Handle.AddressHandle = (PVOID)pAddrObject;
		break;

	}
	while (FALSE);


	if (Status != TDI_SUCCESS)
	{
		//
		//  Clean up.
		//
		if (pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{
			RWAN_FREE_MEM(pAddrObject);
		}
		RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("OpenAddr: failure status %x\n", Status));
	}

	return (Status);
}




TDI_STATUS
RWanTdiSetEvent(
	IN	PVOID						AddrObjContext,
	IN	INT							TdiEventType,
	IN	PVOID						Handler,
	IN	PVOID						HandlerContext
	)
/*++

Routine Description:

	Set an event handler (up-call) for an address object.

Arguments:

	AddrObjContext	- Our context for an Address Object (pointer to it).
	TdiEventType	- The TDI Event for which we are given an up-call handler.
	Handler			- The handler function
	HandlerContext	- Context to be passed to the handler function.

Return Value:

	TDI_STATUS - TDI_SUCCESS if the event type is a supported one, else
	TDI_BAD_EVENT_TYPE

--*/
{
	PRWAN_TDI_ADDRESS			pAddrObject;
	TDI_STATUS					Status;

	pAddrObject = (PRWAN_TDI_ADDRESS)AddrObjContext;
	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	Status = TDI_SUCCESS;

	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

	switch (TdiEventType)
	{
		case TDI_EVENT_CONNECT:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[CONN IND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pConnInd = Handler;
			pAddrObject->ConnIndContext = HandlerContext;
			break;
	
		case TDI_EVENT_DISCONNECT:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[DISC IND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pDisconInd = Handler;
			pAddrObject->DisconIndContext = HandlerContext;
			break;
		
		case TDI_EVENT_ERROR:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[ERRORIND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pErrorInd = Handler;
			pAddrObject->ErrorIndContext = HandlerContext;
			break;
		
		case TDI_EVENT_RECEIVE:

			RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
					("SetEvent[RECV IND]: pAddrObject x%x, Handler x%x, Ctxt x%x\n",
							pAddrObject, Handler, HandlerContext));

			pAddrObject->pRcvInd = Handler;
			pAddrObject->RcvIndContext = HandlerContext;
			break;
		
		default:

			Status = TDI_BAD_EVENT_TYPE;
			break;
	}

	RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

	return (Status);
}




TDI_STATUS
RWanTdiCloseAddress(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI entry point for closing (deleting) an Address Object.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_STATUS -- TDI_SUCCESS if we successfully deleted the address
	object immediately, TDI_PENDING if we have to complete some operations
	(e.g. deregister NDIS SAP) before we can complete this.

--*/
{
	TDI_STATUS					Status;
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_TDI_PROTOCOL			pProtocol;
	INT							rc;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pAddrObject = (PRWAN_TDI_ADDRESS)pTdiRequest->Handle.AddressHandle;
	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	pProtocol = pAddrObject->pProtocol;

	RWANDEBUGP(DL_EXTRA_LOUD, DC_BIND,
			("TdiCloseAddr: pAddrObj x%x, RefCnt %d\n",
				pAddrObject, pAddrObject->RefCount));

	//
	//  Delete this from the list of address objects on this protocol.
	//
	RWAN_ACQUIRE_ADDRESS_LIST_LOCK();

	RWAN_DELETE_FROM_LIST(&(pAddrObject->AddrLink));

	RWAN_RELEASE_ADDRESS_LIST_LOCK();

	//
	//  Tell the media-specific module that this address object is closing.
	//
	if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID))
	{
		(*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpCloseAddress)(
			pAddrObject->AfSpAddrContext);
		
		RWAN_RESET_BIT(pAddrObject->Flags, RWANF_AO_AFSP_CONTEXT_VALID);
	}

	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

#if DBG
	if (!RWAN_IS_LIST_EMPTY(&pAddrObject->SapList) ||
		!RWAN_IS_LIST_EMPTY(&pAddrObject->IdleConnList) ||
		!RWAN_IS_LIST_EMPTY(&pAddrObject->ListenConnList) ||
		!RWAN_IS_LIST_EMPTY(&pAddrObject->ActiveConnList)
	   )
	{
		RWAN_ASSERT(pAddrObject->RefCount > 1);
	}
#endif // DBG

	rc = RWanDereferenceAddressObject(pAddrObject); // CloseAddress deref

	if (rc == 0)
	{
		Status = TDI_SUCCESS;
	}
	else
	{
		//
		//  Mark this address object as closing, so that we
		//  complete this operation when the reference count
		//  falls to 0.
		//
		RWAN_SET_BIT(pAddrObject->Flags, RWANF_AO_CLOSING);

		RWANDEBUGP(DL_LOUD, DC_BIND,
				("TdiCloseAddr: will pend, pAddrObj x%x, RefCnt %d, DelNotify x%x\n",
					pAddrObject, pAddrObject->RefCount, pTdiRequest->RequestNotifyObject));

		RWAN_SET_DELETE_NOTIFY(&pAddrObject->DeleteNotify,
							  pTdiRequest->RequestNotifyObject,
							  pTdiRequest->RequestContext);

		//
		//  Deregister all NDIS SAPs attached to this Address Object.
		//
		RWanDeleteNdisSaps(pAddrObject);

		Status = TDI_PENDING;
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return (Status);

}




TDI_STATUS
RWanCreateNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	)
/*++

Routine Description:

	Create NDIS SAPs on behalf of the given TDI Address Object.
	We create NDIS SAPs on all AF opens that match the specified
	TDI protocol.

Arguments:

	pAddrObject		- Pointer to our TDI Address Object
	pProtocol		- Pointer to TDI protocol to which the addr object belongs

Return Value:

	TDI_STATUS -- this is TDI_SUCCESS if we started SAP registration
	on atleast one NDIS AF open, TDI_NOT_ASSOCIATED otherwise.

--*/
{
	TDI_STATUS					Status;
	PCO_SAP						pCoSap;
	PRWAN_NDIS_SAP				pSap;
	PLIST_ENTRY					pSapEntry;
	PLIST_ENTRY					pNextSapEntry;
	PRWAN_NDIS_ADAPTER			pAdapter;
	PLIST_ENTRY					pAdEntry;
	PRWAN_NDIS_AF				pAf;
	PLIST_ENTRY					pAfEntry;
	PRWAN_NDIS_AF_INFO			pAfInfo;

	pAfInfo = pProtocol->pAfInfo;

	RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
			("CreateNdisSaps: pAddrObject x%x, pProtocol x%x, pAfInfo x%x\n",
				 pAddrObject, pProtocol, pAfInfo));

	RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->SapList));

	RWAN_ACQUIRE_GLOBAL_LOCK();

	//
	//  Prepare NDIS SAP structures for each NDIS AF open that matches
	//  this protocol.
	//
	for (pAdEntry = pRWanGlobal->AdapterList.Flink;
		 pAdEntry != &(pRWanGlobal->AdapterList);
		 pAdEntry = pAdEntry->Flink)
	{
		pAdapter = CONTAINING_RECORD(pAdEntry, RWAN_NDIS_ADAPTER, AdapterLink);

		RWANDEBUGP(DL_EXTRA_LOUD, DC_BIND,
				("CreateNdisSaps: looking at adapter x%x\n", pAdapter));

		for (pAfEntry = pAdapter->AfList.Flink;
			 pAfEntry != &(pAdapter->AfList);
			 pAfEntry = pAfEntry->Flink)
		{
			pAf = CONTAINING_RECORD(pAfEntry, RWAN_NDIS_AF, AfLink);

			RWANDEBUGP(DL_EXTRA_LOUD, DC_BIND,
					("CreateNdisSaps: looking at AF x%x, AfInfo x%x\n",
						 pAf, pAf->pAfInfo));

			if (pAf->pAfInfo == pAfInfo)
			{
				//
				//  This NDIS AF open matches the TDI protocol for which
				//  the address object is opened. We will create an NDIS
				//  SAP here.
				//

				ULONG		SapSize;

				//
				//  Allocate a new SAP structure.
				//
				SapSize = sizeof(RWAN_NDIS_SAP);

				RWAN_ALLOC_MEM(pSap, RWAN_NDIS_SAP, SapSize);

				if (pSap == NULL_PRWAN_NDIS_SAP)
				{
					RWANDEBUGP(DL_WARN, DC_ADDRESS,
							("RWanCreateNdisSaps: failed to alloc SAP %d bytes\n",
								SapSize));
					continue;
				}

				//
				//  Fill it in.
				//
				RWAN_SET_SIGNATURE(pSap, nsp);
				pSap->pAddrObject = pAddrObject;
				pSap->NdisSapHandle = NULL;
				pSap->pNdisAf = pAf;
				pSap->pCoSap = NULL;

				//
				//  Link to all SAPs associated with address object.
				//
				RWAN_INSERT_TAIL_LIST(&(pAddrObject->SapList),
									 &(pSap->AddrObjLink));

				RWanReferenceAddressObject(pAddrObject); // NDIS SAP ref

			}
		}
	}

	RWAN_RELEASE_GLOBAL_LOCK();

	//
	//  Now go through the SAP list and call NDIS to register them.
	//
	for (pSapEntry = pAddrObject->SapList.Flink;
		 pSapEntry != &(pAddrObject->SapList);
		 pSapEntry = pNextSapEntry)
	{
		RWAN_STATUS		RWanStatus;
		NDIS_STATUS		NdisStatus;

		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AddrObjLink);
		pNextSapEntry = pSap->AddrObjLink.Flink;

		//
		//  Convert the transport address to NDIS SAP format.
		//
		RWanStatus = (*pAfInfo->AfChars.pAfSpTdi2NdisSap)(
							pAfInfo->AfSpContext,
							pAddrObject->AddressType,
							pAddrObject->AddressLength,
							pAddrObject->pAddress,
							&(pSap->pCoSap));


		if (RWanStatus == RWAN_STATUS_SUCCESS)
		{
			RWAN_ASSERT(pSap->pCoSap != NULL);

			//
			//  Register this SAP with the Call Manager.
			//
			NdisStatus = NdisClRegisterSap(
							pSap->pNdisAf->NdisAfHandle,
							(NDIS_HANDLE)pSap,
							pSap->pCoSap,
							&(pSap->NdisSapHandle)
							);
		}
		else
		{
			NdisStatus = NDIS_STATUS_FAILURE;
		}

		if (NdisStatus != NDIS_STATUS_PENDING)
		{
			RWanNdisRegisterSapComplete(
							NdisStatus,
							(NDIS_HANDLE)pSap,
							pSap->pCoSap,
							pSap->NdisSapHandle
							);

		}
	}

	if (!RWAN_IS_LIST_EMPTY(&pAddrObject->SapList))
	{
		Status = TDI_SUCCESS;
	}
	else
	{
		Status = RWanNdisToTdiStatus(pAddrObject->SapStatus);
		RWANDEBUGP(DL_WARN, DC_WILDCARD,
			("CreateNdisSaps: NdisStatus %x, TdiStatus %x\n",
					pAddrObject->SapStatus, Status));
	}

	return (Status);
}




VOID
RWanNdisRegisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					OurSapContext,
	IN	PCO_SAP						pCoSap,
	IN	NDIS_HANDLE					NdisSapHandle
	)
/*++

Routine Description:

	This is called by NDIS to signal completion of a previously
	pended call to NdisClRegisterSap.

Arguments:

	NdisStatus		- Final status of SAP registration.
	OurSapContext	- Points to our NDIS SAP structure.
	pCoSap			- The parameter we passed to NdisClRegisterSap. Not used.
	NdisSapHandle	- If NdisStatus indicates success, this contains the
					  assigned handle for this SAP.

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP				pSap;
	PRWAN_TDI_ADDRESS			pAddrObject;
	INT							rc;
	PRWAN_NDIS_AF_INFO			pAfInfo;
	PRWAN_NDIS_AF				pAf;

	UNREFERENCED_PARAMETER(pCoSap);

	pSap = (PRWAN_NDIS_SAP)OurSapContext;
	RWAN_STRUCT_ASSERT(pSap, nsp);

	pAddrObject = pSap->pAddrObject;

	pAfInfo = pSap->pNdisAf->pAfInfo;
	pCoSap = pSap->pCoSap;
	pSap->pCoSap = NULL;

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("RegisterSapComplete: pAddrObj x%x, pSap x%x, Status x%x\n",
				pAddrObject, pSap, NdisStatus));

	if (NdisStatus == NDIS_STATUS_SUCCESS)
	{
		pSap->NdisSapHandle = NdisSapHandle;
		pAf = pSap->pNdisAf;

		//
		//  Link this SAP to the list of all SAPs on the AF.
		//
		RWAN_ACQUIRE_AF_LOCK(pAf);

		RWAN_INSERT_TAIL_LIST(&pAf->NdisSapList,
							 &pSap->AfLink);

		RWanReferenceAf(pAf);	// New SAP registered.
		
		RWAN_RELEASE_AF_LOCK(pAf);
	}
	else
	{
		//
		//  Failed to register this SAP. Clean up.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		pAddrObject->SapStatus = NdisStatus;

		RWAN_DELETE_FROM_LIST(&(pSap->AddrObjLink));

		rc = RWanDereferenceAddressObject(pAddrObject); // Reg SAP failed

		if (rc != 0)
		{
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		}

		RWAN_FREE_MEM(pSap);
	}

	//
	//  If the AF-specific module had given us a SAP structure,
	//  return it now.
	//
	if (pCoSap != NULL)
	{
		(*pAfInfo->AfChars.pAfSpReturnNdisSap)(
				pAfInfo->AfSpContext,
				pCoSap
				);
	}

	return;
}




VOID
RWanDeleteNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	)
/*++

Routine Description:

	Delete all NDIS SAPs on the given address object. We call NDIS
	to deregister them.

Arguments:

	pAddrObject		- Pointer to TDI Address Object

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP			pSap;
	PLIST_ENTRY				pSapEntry;
	PLIST_ENTRY				pFirstSapEntry;
	PLIST_ENTRY				pNextSapEntry;
	NDIS_STATUS				NdisStatus;
	NDIS_HANDLE				NdisSapHandle;

	//
	//  Mark all SAPs as closing, while we hold a lock to the address object.
	//
	for (pSapEntry = pAddrObject->SapList.Flink;
		 pSapEntry != &(pAddrObject->SapList);
		 pSapEntry = pNextSapEntry)
	{
		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AddrObjLink);
		pNextSapEntry = pSap->AddrObjLink.Flink;
		RWAN_SET_BIT(pSap->Flags, RWANF_SAP_CLOSING);
	}

	//
	//  Unlink the SAP list from the Address Object.
	//  This will protect us if at all we re-enter this routine.
	//
	pFirstSapEntry = pAddrObject->SapList.Flink;
	RWAN_INIT_LIST(&pAddrObject->SapList);

	RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

	for (pSapEntry = pFirstSapEntry;
		 pSapEntry != &(pAddrObject->SapList);
		 pSapEntry = pNextSapEntry)
	{
		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AddrObjLink);
		pNextSapEntry = pSap->AddrObjLink.Flink;

		NdisSapHandle = pSap->NdisSapHandle;
		RWAN_ASSERT(NdisSapHandle != NULL);

		RWANDEBUGP(DL_LOUD, DC_BIND,
			("RWanDeleteNdisSaps: pAddrObj x%x, pSap x%x, pAf x%x\n",
				pAddrObject, pSap, pSap->pNdisAf));

		NdisStatus = NdisClDeregisterSap(NdisSapHandle);

		if (NdisStatus != NDIS_STATUS_PENDING)
		{
			RWanNdisDeregisterSapComplete(
				NdisStatus,
				(NDIS_HANDLE)pSap
				);
		}
	}
}




VOID
RWanNdisDeregisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					ProtocolSapContext
	)
/*++

Routine Description:

	This is called by NDIS to signal completion of a previously
	pended call to NdisClDeregisterSap.

	We unlink the SAP from the two lists it is linked to: the
	Address Object's SAP list and the AF's SAP list.

Arguments:

	NdisStatus		- Final status of SAP deregistration.

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP				pSap;
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_NDIS_AF				pAf;
	INT							rc;

	RWAN_ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);

	pSap = (PRWAN_NDIS_SAP)ProtocolSapContext;
	RWAN_STRUCT_ASSERT(pSap, nsp);

	RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
			("RWanDeregSapComplete: pSap x%x, pAddrObj x%x, pAf x%x\n",
			pSap, pSap->pAddrObject, pSap->pNdisAf));

	pAddrObject = pSap->pAddrObject;

	//
	//  Unlink the SAP from the Address Object.
	//
	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

	RWAN_DELETE_FROM_LIST(&(pSap->AddrObjLink));

	rc = RWanDereferenceAddressObject(pAddrObject); // SAP dereg complete

	if (rc != 0)
	{
		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
	}

	//
	//  Unlink the SAP from the AF.
	//
	pAf = pSap->pNdisAf;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	RWAN_DELETE_FROM_LIST(&(pSap->AfLink));

	rc = RWanDereferenceAf(pAf);	// SAP deregister complete

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}

	RWAN_FREE_MEM(pSap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\debug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\core\debug.h

Abstract:

    Debug macros for the Null Transport module.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    arvindm		05-29-97	created based on ATM ARP.

Notes:

--*/

#ifndef _RWANDEBUG__H
#define _RWANDEBUG__H

//
// Message verbosity: lower values indicate higher urgency
//
#define DL_EXTRA_LOUD		20
#define DL_VERY_LOUD		10
#define DL_LOUD			 	 8
#define DL_INFO			 	 6
#define DL_WARN		 	 	 4
#define DL_ERROR			 2
#define DL_FATAL			 0

//
// Component being debugged.
//
#define DC_DISPATCH			0x00000001
#define DC_BIND				0x00000002
#define DC_ADDRESS			0x00000004
#define DC_CONNECT			0x00000008
#define DC_DISCON			0x00000010
#define DC_DATA_TX			0x00000020
#define DC_DATA_RX			0x00000040
#define DC_UTIL				0x00000080
#define DC_WILDCARD			0xffffffff


//
//  Data traffic debug message flags
//
#define RWAND_DATA_IN			0x01
#define RWAND_DATA_OUT			0x02
#define RWAND_TRACK_BIG_SENDS	0x04

//
//  Logging for sends and receives
//
typedef struct _RWAND_DATA_LOG_ENTRY
{
	ULONG				Operation;
	#define RWAND_DLOG_TX_START				'  xt'
	#define RWAND_DLOG_TX_END				'  xT'
	#define RWAND_DLOG_RX_START				'  xr'
	#define RWAND_DLOG_RX_END				'  xR'
	PNDIS_PACKET		pNdisPacket;
	PVOID				Context;
	ULONG				PendingCount;

} RWAND_DATA_LOG_ENTRY, *PRWAND_DATA_LOG_ENTRY;

#define MAX_RWAND_PKT_LOG	32

#ifdef PERF

typedef struct _RWAND_SEND_LOG_ENTRY
{
	ULONG				Flags;
	PNDIS_PACKET		pNdisPacket;
	ULONG				Destination;
	ULONG				Length;
	LARGE_INTEGER		SendTime;
	LARGE_INTEGER		SendCompleteTime;
} RWAND_SEND_LOG_ENTRY, *PRWAND_SEND_LOG_ENTRY;

#define RWAND_SEND_FLAG_UNUSED					0x00000000
#define RWAND_SEND_FLAG_WAITING_COMPLETION		0x00000001
#define RWAND_SEND_FLAG_COMPLETED					0x00000002
#define RWAND_SEND_FLAG_RCE_GIVEN					0x00000100


extern VOID
RWandLogSendStart(
	IN	PNDIS_PACKET	pNdisPacket,
	IN	ULONG			Destination,
	IN	PVOID			pRCE
);

extern VOID
RWandLogSendUpdate(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
RWandLogSendComplete(
	IN	PNDIS_PACKET	pNdisPacket
);

extern VOID
RWandLogSendAbort(
	IN	PNDIS_PACKET	pNdisPacket
);

extern LARGE_INTEGER	TimeFrequency;


#endif // PERF

#if DBG_SPIN_LOCK

typedef struct _RWAN_LOCK
{
	ULONG					Signature;
	ULONG					IsAcquired;
	PKTHREAD				OwnerThread;
	ULONG					TouchedByFileNumber;
	ULONG					TouchedInLineNumber;
	NDIS_SPIN_LOCK			NdisLock;
} RWAN_LOCK, *PRWAN_LOCK;

#define RWANL_SIG	'KCOL'

extern
VOID
RWanAllocateSpinLock(
    IN  PRWAN_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
RWanAcquireSpinLock(
    IN  PRWAN_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
RWanReleaseSpinLock(
    IN  PRWAN_LOCK        pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);


#define CHECK_LOCK_COUNT(Count)		\
			{								\
				if ((INT)(Count) < 0)		\
				{							\
					DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",	\
						Count, __FILE__, __LINE__);		\
					DbgBreakPoint();					\
				}							\
			}
#else
#define CHECK_LOCK_COUNT(Count)

#define RWAN_LOCK		NDIS_SPIN_LOCK
#define PRWAN_LOCK	PNDIS_SPIN_LOCK

#endif	// DBG_SPIN_LOCK

#if DBG

extern NDIS_SPIN_LOCK		RWanDbgLogLock;

extern INT	RWanDebugLevel;	// The value here defines what the user wants to see
								// all messages with this urgency and higher are enabled

extern ULONG	RWanDebugComp;	// The bits set here define what components are being
								// debugged
extern INT	RWanDataDebugLevel;
extern INT	RWandBigDataLength;


#define RWANDEBUGP(lev, comp, stmt)										\
		{																\
			if (((lev) <= RWanDebugLevel) && ((comp) & RWanDebugComp))	\
			{															\
				DbgPrint("RWan: "); DbgPrint stmt;						\
			}															\
		}

#define RWANDEBUGPDUMP(lev, comp, pBuf, Len)	\
		{																\
			if (((lev) <= RWanDebugLevel) && ((comp) & RWanDebugComp))	\
			{															\
				DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len));			\
			}															\
		}

#define RWANDEBUGPATMADDR(lev, comp, pString, pAddr)		\
		{																\
			if (((lev) <= RWanDebugLevel) && ((comp) & RWanDebugComp))	\
			{															\
				DbgPrintAtmAddr(pString, pAddr);						\
			}															\
		}

#define RWAN_ASSERT(exp)	\
		{																\
			if (!(exp))													\
			{															\
				DbgPrint("RWan: assert " #exp " failed in file %s, line %d\n", __FILE__, __LINE__);	\
				DbgBreakPoint();										\
			}															\
		}

#define RWAN_SET_SIGNATURE(s, t)\
				(s)->t##_sig = t##_signature;

#define RWAN_STRUCT_ASSERT(s, t)\
				if ((s)->t##_sig != t##_signature) {\
					DbgPrint("RWan: assertion failure for type " #t " at 0x%x in file %s, line %d\n", (PUCHAR)s, __FILE__, __LINE__);	\
					DbgBreakPoint();	\
				}

#if DBG_CO_SEND

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			RWanCoSendPackets(_VcHandle, _PktArray, _Count)

#else

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#endif // DBG_CO_SEND

extern INT	RWanSkipAll;		// Used as an emergency exit mechanism!

//
// Memory Allocation/Freeing Audit:
//

//
// The RWAND_ALLOCATION structure stores all info about one allocation
//
typedef struct _RWAND_ALLOCATION {

		ULONG					Signature;
		struct _RWAND_ALLOCATION	*Next;
		struct _RWAND_ALLOCATION *Prev;
		ULONG					FileNumber;
		ULONG					LineNumber;
		ULONG					Size;
		ULONG_PTR				Location;	// where the returned pointer was put
		union
		{
			ULONGLONG			Alignment;
			UCHAR					UserData;
		};

} RWAND_ALLOCATION, *PRWAND_ALLOCATION;

#define RWAND_MEMORY_SIGNATURE	(ULONG)'CSII'

extern
PVOID
RWanAuditAllocMem (
	PVOID		pPointer,
	ULONG		Size,
	ULONG		FileNumber,
	ULONG		LineNumber
);

extern
VOID
RWanAuditFreeMem(
	PVOID		Pointer
);

extern
VOID
RWanAuditShutdown(
	VOID
);

extern
VOID
DbgPrintHexDump(
	PUCHAR		pBuffer,
	ULONG		Length
);

extern
VOID
DbgPrintAtmAddr(
	PCHAR			pString,
	ATM_ADDRESS UNALIGNED *	pAddr
);

extern
VOID
DbgPrintMapping(
	PCHAR			pString,
	UCHAR UNALIGNED *	pIpAddr,
	ATM_ADDRESS UNALIGNED *	pAddr
);


extern
VOID
RWanCoSendPackets(
	IN	NDIS_HANDLE			NdisVcHandle,
	IN	PNDIS_PACKET *		PacketArray,
	IN	UINT				PacketCount
);

extern NDIS_SPIN_LOCK		RWanDPacketLogLock;


#if DBG_LOG_PACKETS
#define RWAND_LOG_PACKET(_pVc, _Op, _pPkt, _Ctxt)	\
{													\
	struct _RWAND_DATA_LOG_ENTRY *	pEnt;			\
	NdisAcquireSpinLock(&RWanDPacketLogLock);		\
	pEnt = &(_pVc)->DataLog[(_pVc)->Index];			\
	(_pVc)->Index++;								\
	if ((_pVc)->Index == MAX_RWAND_PKT_LOG)			\
		(_pVc)->Index = 0;							\
	pEnt->Operation = _Op;							\
	pEnt->pNdisPacket = _pPkt;						\
	pEnt->Context = _Ctxt;							\
	pEnt->PendingCount = (_pVc)->PendingPacketCount;\
	NdisReleaseSpinLock(&RWanDPacketLogLock);		\
}

#else
#define RWAND_LOG_PACKET(_pVc, _Op, _pPkt, _Ctxt)
#endif

#else
//
// No debug
//
#define RWANDEBUGP(lev, comp, stmt)
#define RWANDEBUGPDUMP(lev, comp, pBuf, Len)
#define RWANDEBUGPATMADDR(lev, comp, pString, pAddr)

#define RWAN_ASSERT(exp)
#define RWAN_SET_SIGNATURE(s, t)
#define RWAN_STRUCT_ASSERT(s, t)

#define NDIS_CO_SEND_PACKETS(_VcHandle, _PktArray, _Count)	\
			NdisCoSendPackets(_VcHandle, _PktArray, _Count)

#define RWAND_LOG_PACKET(_pVc, _Op, _pPkt, _Ctxt)

#endif	// DBG


extern ULONG	gHackSendSize;

#endif // _RWANDEBUG__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\lane\sys\utils.c ===
/*++

Copyright (c) 1997 FORE Systems, Inc.
Copyright (c) 1997 Microsoft Corporation

Module Name:

	utils.c

Abstract:

	Utility routines.
	
Author:

	Larry Cleeton, FORE Systems	(v-lcleet@microsoft.com, lrc@fore.com)		

Environment:

	Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
AtmLaneInitGlobals(
	VOID
	)
/*++

Routine Description:

	Initialize the global data structures.

Arguments:

	None

Return Value:

	None

--*/
{
	TRACEIN(InitGlobals);
	
	NdisZeroMemory(pAtmLaneGlobalInfo, sizeof(ATMLANE_GLOBALS));

	INIT_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	NdisInitializeListHead(&pAtmLaneGlobalInfo->AdapterList);

#if DBG_TRACE
	//
	// Init trace log
	//
	pTraceLogSpace = NULL;
	InitTraceLog(&TraceLog, NULL, 0);

	// allocate space and init trace log if configured

	if (DbgLogSize > 0)
	{
		ALLOC_MEM(&pTraceLogSpace, DbgLogSize);
		if (pTraceLogSpace  == NULL)
		{
			DBGP((0, "Failed to allocate %d bytes space for trace log\n",
				DbgLogSize));
		}
		else
		{
			InitTraceLog(
					&TraceLog, 
					pTraceLogSpace, 
					DbgLogSize);
		}
	}
#endif	// DBG_TRACE

	TRACEOUT(InitGlobals);

	return;
}


PATMLANE_ADAPTER
AtmLaneAllocAdapter(
	IN	PNDIS_STRING			pDeviceName,
	IN	PVOID					SystemSpecific1
)
/*++

Routine Description:

	Allocates an Adapter data structure.

Arguments:

	pDeviceName		- Points to name of adapter device
	SystemSpecific1	- What we got into our BindAdapter handler.

Return Value:

	Pointer to allocated Adapter structure or NULL.

--*/
{
	PATMLANE_ADAPTER	pAdapter;
	NDIS_STATUS			Status;
	ULONG				TotalLength;
	PNDIS_STRING		pConfigString;

	TRACEIN(AllocAdapter);

	//
	//	Initialize
	//
	pAdapter = NULL_PATMLANE_ADAPTER;
	pConfigString = (PNDIS_STRING)SystemSpecific1;
	
	do
	{
		//
		//	Allocate everything.  Adapter struct size plus two 
		//  UNICODE string buffers with extra WCHAR each for NULL termination.
		//
		TotalLength =   sizeof(ATMLANE_ADAPTER) + 
		                pDeviceName->MaximumLength + sizeof(WCHAR) + 
		                pConfigString->MaximumLength + sizeof(WCHAR);

		ALLOC_MEM(&pAdapter, TotalLength);

		if (NULL_PATMLANE_ADAPTER == pAdapter)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
		
		//
		// 	Zero it.
		//
		NdisZeroMemory(pAdapter, TotalLength);

		//
		// 	Debugging info.
		//
#if DBG
		pAdapter->atmlane_adapter_sig =  atmlane_adapter_signature;
#endif

		//
		//	Init lock.
		//
		INIT_ADAPTER_LOCK(pAdapter);

		//
		//	Init blocking objects.
		//
		INIT_BLOCK_STRUCT(&pAdapter->Block);
		INIT_BLOCK_STRUCT(&pAdapter->UnbindBlock);

		//
		//	Init ElanList
		//
		NdisInitializeListHead(&pAdapter->ElanList);

		//
		//  Copy in the device name
		//
		pAdapter->DeviceName.MaximumLength = pDeviceName->MaximumLength + sizeof(WCHAR);
		pAdapter->DeviceName.Length = pDeviceName->Length;
		pAdapter->DeviceName.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(ATMLANE_ADAPTER));
		NdisMoveMemory(pAdapter->DeviceName.Buffer,
					   pDeviceName->Buffer,
					   pDeviceName->Length);
		pAdapter->DeviceName.Buffer[pDeviceName->Length/sizeof(WCHAR)] = ((WCHAR)0);


		//
		//  Copy in the Config string - we will use this to open the
		//  registry section for this adapter at a later point.
		//
		pAdapter->ConfigString.MaximumLength = pConfigString->MaximumLength;
		pAdapter->ConfigString.Length = pConfigString->Length;
		pAdapter->ConfigString.Buffer = (PWCHAR)((PUCHAR)pAdapter + 
										sizeof(ATMLANE_ADAPTER) + 
										pAdapter->DeviceName.MaximumLength);

		NdisMoveMemory(pAdapter->ConfigString.Buffer,
					   pConfigString->Buffer,
					   pConfigString->Length);
		pAdapter->ConfigString.Buffer[pConfigString->Length/sizeof(WCHAR)] = ((WCHAR)0);

		//
		//	Link into global Adapter list.
		//
		ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
		InsertTailList(&pAtmLaneGlobalInfo->AdapterList, &pAdapter->Link);
		RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);

	} while (FALSE);
	
	TRACEOUT(AllocAdapter);

	return pAdapter;
}


VOID
AtmLaneDeallocateAdapter(
	IN	PATMLANE_ADAPTER	pAdapter
)
/*++

Routine Description:

	Deallocate an Adapter structure. It is assumed that all
	references to this structure have gone, so it is not necessary
	to acquire a lock to it.

	Also unlink this from the global Adapter list.

Arguments:

	pAdapter		- Pointer to Adapter structure to be deallocated.

Return Value:

	None

--*/
{
	PATMLANE_NAME	pName;


	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	TRACEIN(DeallocateAdapter);

	ASSERT(pAdapter->RefCount == 0);

	//
	//  Unlink from global Adapter list.
	//
	ACQUIRE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	RemoveEntryList(&pAdapter->Link);
	RELEASE_GLOBAL_LOCK(pAtmLaneGlobalInfo);
	
	//
	//	Free the lock.
	//
	FREE_ADAPTER_LOCK(pAdapter);

#if DBG
	pAdapter->atmlane_adapter_sig++;
#endif

    //
    //  Free string buffers that may have been allocated
    //
	if (NULL != pAdapter->CfgUpperBindings.Buffer)
	{
		FREE_MEM(pAdapter->CfgUpperBindings.Buffer);
	}
	if (NULL != pAdapter->CfgElanName.Buffer)
	{
		FREE_MEM(pAdapter->CfgElanName.Buffer);
	}


	//
	//	Free the name lists that may have been allocated.
	//
	while (pAdapter->UpperBindingsList)
	{
		DBGP((1, "DeallocateAdapter: pname 0x%x\n"));
		pName = pAdapter->UpperBindingsList;
		pAdapter->UpperBindingsList = pName->pNext;
		FREE_MEM(pName);
	}
	while (pAdapter->ElanNameList)
	{
		DBGP((1, "DeallocateAdapter: pname 0x%x\n"));
		pName = pAdapter->ElanNameList;
		pAdapter->ElanNameList = pName->pNext;
		FREE_MEM(pName);
	}


	//
	//  Finally free the Adapter structure.
	//
	FREE_MEM(pAdapter);

	TRACEOUT(DeallocateAdapter);

	return;
}

BOOLEAN
AtmLaneReferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
	)
/*++

Routine Description:

	Add a references to an Adapter structure.
	NOTE: The caller is assumed to possess the Adapter's lock.

Arguments:

	pAdapter	-	Pointer to the Adapter structure.


Return Value:

	None.

--*/
{
	BOOLEAN			bReferenced;

	TRACEIN(ReferenceAdapter);

	STRUCT_ASSERT(pAdapter, atmlane_adapter);
	
	if ((pAdapter->Flags & ADAPTER_FLAGS_DEALLOCATING) == 0)
	{
		pAdapter->RefCount++;
		bReferenced = TRUE;
	}
	else
	{
		bReferenced = FALSE;
	}
	
	DBGP((5, "ReferenceAdapter: Adapter %x (%s) new count %d\n",
			 pAdapter, String, pAdapter->RefCount));

	TRACEOUT(ReferenceAdapter);

	return bReferenced;
}

ULONG
AtmLaneDereferenceAdapter(
	IN	PATMLANE_ADAPTER	pAdapter,
	IN	PUCHAR				String
	)
/*++

Routine Description:

	Subtract a reference from an Adapter structure. 
	If the reference count becomes zero, deallocate it.
	NOTE: The caller is assumed to posses the Adapter's lock.

Arguments:

	pAdapter	-	Pointer to an adapter structure.


Return Value:

	None.

--*/
{
	ULONG		rc;

	TRACEIN(DereferenceAdapter);

	STRUCT_ASSERT(pAdapter, atmlane_adapter);

	ASSERT(pAdapter->RefCount > 0);

	rc = --(pAdapter->RefCount);

	if (rc == 0)
	{
	    pAdapter->Flags |= ADAPTER_FLAGS_DEALLOCATING;
		RELEASE_ADAPTER_LOCK(pAdapter);
		AtmLaneDeallocateAdapter(pAdapter);
	}

	DBGP((5, "DereferenceAdapter: Adapter %x (%s) new count %d\n", 
		pAdapter, String, rc));

	TRACEOUT(DereferenceAdapter);

	return (rc);
}
	
NDIS_STATUS
AtmLaneAllocElan(
	IN		PATMLANE_ADAPTER	pAdapter,
	IN OUT	PATMLANE_ELAN		*ppElan
)
/*++

Routine Description:

	Allocates an ELAN data structure.

Arguments:

	None

Return Value:

	NDIS_STATUS_SUCCESS or NDIS_STATUS_RESOURCES.

--*/
{
	NDIS_STATUS				Status;
	PATMLANE_ELAN			pElan;
	PATMLANE_MAC_ENTRY *	pMacTable;
	PATMLANE_TIMER_LIST		pTimerList;
	USHORT					NameBufferSize;
	UINT					i;
	ULONG					SapSize;
	PCO_SAP					pLesSapInfo;
	PCO_SAP					pBusSapInfo;
	PCO_SAP					pDataSapInfo;
	ULONG					ElanNumber;

	TRACEIN(AllocElan);

	//
	//  Initialize
	//

	Status = NDIS_STATUS_SUCCESS;
	pElan = NULL_PATMLANE_ELAN;
	pMacTable = (PATMLANE_MAC_ENTRY *)NULL;

	pLesSapInfo = pBusSapInfo = pDataSapInfo = (PCO_SAP)NULL;
	
	SapSize = sizeof(CO_SAP)+sizeof(ATM_SAP)+sizeof(ATM_ADDRESS);

	do
	{
		//
		//	Allocate everything.
		//
		ALLOC_MEM(&pElan, sizeof(ATMLANE_ELAN));
		ALLOC_MEM((PVOID *)&pMacTable, ATMLANE_MAC_TABLE_SIZE*sizeof(PATMLANE_MAC_ENTRY));
		ALLOC_MEM(&pLesSapInfo, SapSize);
		ALLOC_MEM(&pBusSapInfo, SapSize);
		ALLOC_MEM(&pDataSapInfo, SapSize);

		if (NULL_PATMLANE_ELAN != pElan)
		{
			//
			// 	Zero the Elan structure now so that we clean up properly
			//  if any errors occur later on.
			//
			NdisZeroMemory(pElan, sizeof(ATMLANE_ELAN));
		}

		if ((NULL_PATMLANE_ELAN == pElan) ||
			(NULL == pMacTable) ||
			(NULL == pLesSapInfo) ||
			(NULL == pBusSapInfo) ||
			(NULL == pDataSapInfo))
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Allocate timer structures
		//
		for (i = 0; i < ALT_CLASS_MAX; i++)
		{
			pTimerList = &(pElan->TimerList[i]);
#if DBG
			pTimerList->atmlane_timerlist_sig = atmlane_timerlist_signature;
#endif
			ALLOC_MEM(&(pTimerList->pTimers), 
						sizeof(ATMLANE_TIMER) * AtmLaneTimerListSize[i]);
			if (NULL_PATMLANE_TIMER == pTimerList->pTimers)
			{
				Status = NDIS_STATUS_RESOURCES;
				break;
			}
		}

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//	Continue initializing the ELAN structure
		//
#if DBG
		//
		// 	Signatures, for debugging.
		//
		pElan->atmlane_elan_sig =  atmlane_elan_signature;
		pElan->LesSap.atmlane_sap_sig = atmlane_sap_signature;
		pElan->BusSap.atmlane_sap_sig = atmlane_sap_signature;
		pElan->DataSap.atmlane_sap_sig = atmlane_sap_signature;
#endif

		//
		//	Initialize state fields.
		//
		pElan->AdminState = ELAN_STATE_INIT;
		pElan->State = ELAN_STATE_ALLOCATED;
		NdisInitializeWorkItem(&pElan->EventWorkItem, AtmLaneEventHandler, pElan);
		
		//
		//	Initialize spinlocks.
		//
#if SENDLIST
		NdisAllocateSpinLock(&pElan->SendListLock);
#endif // SENDLIST
		INIT_ELAN_LOCK(pElan);
		INIT_ELAN_MAC_TABLE_LOCK(pElan);
		INIT_ELAN_ATM_LIST_LOCK(pElan);
		INIT_ELAN_TIMER_LOCK(pElan);
		INIT_BLOCK_STRUCT(&pElan->Block);
		INIT_BLOCK_STRUCT(&pElan->InitBlock);
		INIT_BLOCK_STRUCT(&pElan->AfBlock);
		INIT_HEADER_LOCK(pElan);

		//
		//	Init event queue.
		//
		InitializeListHead(&pElan->EventQueue);

		//
		//  Initialize timer wheels.
		//
		for (i = 0; i < ALT_CLASS_MAX; i++)
		{
			pTimerList = &(pElan->TimerList[i]);
			NdisZeroMemory(
				pTimerList->pTimers,
				sizeof(ATMLANE_TIMER) * AtmLaneTimerListSize[i]
				);
			pTimerList->MaxTimer = AtmLaneMaxTimerValue[i];
			pTimerList->TimerPeriod = AtmLaneTimerPeriod[i];
			pTimerList->ListContext = (PVOID)pElan;
			pTimerList->TimerListSize = AtmLaneTimerListSize[i];

			INIT_SYSTEM_TIMER(
					&(pTimerList->NdisTimer),
					AtmLaneTickHandler,
					(PVOID)pTimerList
					);
		}

		//
		//	Initialize all sub-components.
		//
		NdisZeroMemory(pMacTable, ATMLANE_MAC_TABLE_SIZE*sizeof(PATMLANE_MAC_ENTRY));
		NdisZeroMemory(pLesSapInfo, SapSize);
		NdisZeroMemory(pBusSapInfo, SapSize);
		NdisZeroMemory(pDataSapInfo, SapSize);

		//
		//	Link sub-components to the Elan structure.
		//
		pElan->pMacTable = pMacTable;

		pElan->LesSap.pInfo = pLesSapInfo;
		pElan->BusSap.pInfo = pBusSapInfo;
		pElan->DataSap.pInfo = pDataSapInfo;
				
		//
		//	Link the Elan to the adapter.
		//
		pElan->pAdapter = pAdapter;
		ACQUIRE_ADAPTER_LOCK(pAdapter);

		//
		//  Find a free ELAN number.
		//
		for (ElanNumber = 0; ElanNumber <= pAdapter->ElanCount; ElanNumber++)
		{
			PATMLANE_ELAN		pThisElan = NULL;
			PLIST_ENTRY			p;

			for (p = pAdapter->ElanList.Flink;
 				 p != &pAdapter->ElanList;
 				 p = p->Flink)
			{
				pThisElan = CONTAINING_RECORD(p, ATMLANE_ELAN, Link);

				if (pThisElan->ElanNumber == ElanNumber)
				{
					break;
				}
			}

			//
			//  See if we made it to the end of the list without hitting
			//  the current ElanNumber. If so, use this ElanNumber.
			//
			if (p == &pAdapter->ElanList)
			{
				break;
			}
		}

		DBGP((0, "%d Assign ElanNumber to ELAN %p\n", ElanNumber, pElan));
		(VOID)AtmLaneReferenceAdapter(pAdapter, "elan");
		InsertTailList(&pAdapter->ElanList,	&pElan->Link);
		pElan->ElanNumber = ElanNumber;
		pAdapter->ElanCount++;
		RELEASE_ADAPTER_LOCK(pAdapter);

		//
		//	Cache NdisAdapterHandle.
		//
		pElan->NdisAdapterHandle = pAdapter->NdisAdapterHandle;

		//
		//	Generate a MAC Address for the elan
		//
		AtmLaneGenerateMacAddr(pElan);		

		//
		//	Set the rest of the LANE Run-time parameters to defaults
		//
		pElan->ControlTimeout 		= LANE_C7_DEF;
		pElan->MaxUnkFrameCount 	= LANE_C10_DEF;
		pElan->MaxUnkFrameTime	 	= LANE_C11_DEF;
		pElan->VccTimeout 			= LANE_C12_DEF;
		pElan->MaxRetryCount 		= LANE_C13_DEF;
		pElan->AgingTime		 	= LANE_C17_DEF;
		pElan->ForwardDelayTime		= LANE_C18_DEF;
		pElan->ArpResponseTime	 	= LANE_C20_DEF;
		pElan->FlushTimeout 		= LANE_C21_DEF;
		pElan->PathSwitchingDelay 	= LANE_C22_DEF;
		pElan->ConnComplTimer 		= LANE_C28_DEF;

		//
		//	Calc the bus rate limiter parameters
		//			
		pElan->LimitTime 			= pElan->MaxUnkFrameTime * 1000;
		pElan->IncrTime 			= pElan->LimitTime / pElan->MaxUnkFrameCount;

		Status = NDIS_STATUS_SUCCESS;
		break;

	} while (FALSE);

	if (NDIS_STATUS_SUCCESS != Status)
	{
		//
		//	Failure cleanup.
		//
		if (NULL_PATMLANE_ELAN != pElan)
		{
			for (i = 0; i < ALT_CLASS_MAX; i++)
			{
				pTimerList = &(pElan->TimerList[i]);
				if (NULL != pTimerList->pTimers)
				{
					FREE_MEM(pTimerList->pTimers);
				}
			}
		}
		if (NULL != pLesSapInfo)
		{
			FREE_MEM(pLesSapInfo);
		}
		if (NULL != pBusSapInfo)
		{
			FREE_MEM(pBusSapInfo);
		}
		if (NULL != pDataSapInfo)
		{
			FREE_MEM(pDataSapInfo);
		}
		if (NULL != pMacTable)
		{
			FREE_MEM(pMacTable);
		}
		if (NULL_PATMLANE_ELAN != pElan)
		{
			FREE_MEM(pElan);
			pElan = NULL_PATMLANE_ELAN;
		}
	}
	//
	// 	Output pElan
	//
	*ppElan = pElan;

	TRACEOUT(AllocElan);

	return Status;
}


VOID
AtmLaneDeallocateElan(
	IN	PATMLANE_ELAN		pElan
)
/*++

Routine Description:

	Deallocate an Elan structure. It is assumed that all
	references to this structure have gone, so it is not necessary
	to acquire a lock to it.

	Also delink this from the Adapter's Elan list.

Arguments:

	pElan		- Pointer to Elan structure to be deallocated.

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_ATM_ENTRY		pNext;
	UINT					i;
	
	TRACEIN(DeallocateElan);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ASSERT(pElan->RefCount == 0);

	DBGP((0, "%d Deleting ELAN %p\n", pElan->ElanNumber, pElan));


	//
	//	Free all subcomponents
	//

	//
	//	MAC Table
	//
	if ((PATMLANE_MAC_ENTRY *)NULL != pElan->pMacTable)
	{
		FREE_MEM(pElan->pMacTable);
		pElan->pMacTable = (PATMLANE_MAC_ENTRY *)NULL;
	}

	//
	//	ATM Entry List
	//
	for (pAtmEntry = pElan->pAtmEntryList;
		 pAtmEntry != NULL_PATMLANE_ATM_ENTRY;
		 pAtmEntry = (PATMLANE_ATM_ENTRY)pNext)
	{
		pNext = (PVOID)pAtmEntry->pNext;
		FREE_MEM(pAtmEntry);
	}
	pElan->pAtmEntryList = NULL_PATMLANE_ATM_ENTRY;

	//
	//  Timers
	//
	for (i = 0; i < ALT_CLASS_MAX; i++)
	{
		PATMLANE_TIMER_LIST pTimerList = &(pElan->TimerList[i]);
		if (NULL != pTimerList->pTimers)
		{
			FREE_MEM(pTimerList->pTimers);
		}
		pTimerList->pTimers = NULL_PATMLANE_TIMER;
	}

	//
	//	ProtocolPacketPool
	//	ProtocolBufferPool
	//	ProtocolBufList
	//
	AtmLaneDeallocateProtoBuffers(pElan);

	//
	//	TransmitPacketPool
	//
	if (pElan->TransmitPacketPool != NULL_NDIS_HANDLE)
	{
		NdisFreePacketPool(pElan->TransmitPacketPool);
		pElan->TransmitPacketPool = NULL_NDIS_HANDLE;
	}

	//
	//	ReceivePacketPool
	//
	if (pElan->ReceivePacketPool != NULL_NDIS_HANDLE)
	{
		NdisFreePacketPool(pElan->ReceivePacketPool);
		pElan->ReceivePacketPool = NULL_NDIS_HANDLE;
	}

	//
	//	ReceiveBufferPool
	//
	if (pElan->ReceiveBufferPool != NULL_NDIS_HANDLE)
	{
		NdisFreeBufferPool(pElan->ReceiveBufferPool);
		pElan->ReceiveBufferPool = NULL_NDIS_HANDLE;
	}

	//
	//	HeaderBufList
	//	pHeaderTrkList
	//
	AtmLaneDeallocateHeaderBuffers(pElan);

	//
	//	PadBufList
	//	pPadTrkList
	//
	AtmLaneDeallocatePadBufs(pElan);
		
	//
	//	Free the config strings
	//
	if (NULL != pElan->CfgBindName.Buffer)
	{
		FREE_MEM(pElan->CfgBindName.Buffer);
	}
	if (NULL != pElan->CfgDeviceName.Buffer)
	{
		FREE_MEM(pElan->CfgDeviceName.Buffer);
	}
	if (NULL != pElan->CfgElanName.Buffer)
	{
		FREE_MEM(pElan->CfgElanName.Buffer);
	}

	//
	//	Free the Sap info
	//

	if (NULL != pElan->LesSap.pInfo)
	{
		FREE_MEM(pElan->LesSap.pInfo);
	}
	if (NULL != pElan->BusSap.pInfo)
	{
		FREE_MEM(pElan->BusSap.pInfo);
	}
	if (NULL != pElan->DataSap.pInfo)
	{
		FREE_MEM(pElan->DataSap.pInfo);
	}
	
	//
	//	Free the locks.
	//
#if SENDLIST
	NdisFreeSpinLock(&pElan->SendListLock);
#endif // SENDLIST
	FREE_ELAN_LOCK(pElan);
	FREE_ELAN_MAC_TABLE_LOCK(pElan);
	FREE_ELAN_ATM_LIST_LOCK(pElan);
	FREE_ELAN_TIMER_LOCK(pElan);
	FREE_BLOCK_STRUCT(&pElan->Block);
	FREE_HEADER_LOCK(pElan);

	AtmLaneUnlinkElanFromAdapter(pElan);

#if DBG
	pElan->atmlane_elan_sig++;
#endif
	//
	//  Finally free the Elan structure.
	//
	FREE_MEM(pElan);

	TRACEOUT(DeallocateElan);

	return;
}

VOID
AtmLaneReferenceElan(
	IN	PATMLANE_ELAN	pElan,
	IN	PUCHAR			String
	)
/*++

Routine Description:

	Add a references to an Elan structure.
	NOTE: The caller is assumed to possess the Elan's lock.

Arguments:

	pElan	-	Pointer to the Elan structure.


Return Value:

	None.

--*/
{
	TRACEIN(ReferenceElan);

	STRUCT_ASSERT(pElan, atmlane_elan);
	
	pElan->RefCount++;
	
	DBGP((5, "ReferenceElan: Elan %p/%x (%s) new count %d\n",
			 pElan, pElan->Flags, String, pElan->RefCount));

	TRACEOUT(ReferenceElan);

	return;
}

ULONG
AtmLaneDereferenceElan(
	IN	PATMLANE_ELAN		pElan,
	IN	PUCHAR				String
	)
/*++

Routine Description:

	Subtract a reference from an Elan structure. 
	If the reference count becomes zero, deallocate it.
	NOTE: The caller is assumed to posses the Elan's lock.

Arguments:

	pElan	-	Pointer to an Elan structure.


Return Value:

	None.

--*/
{
	ULONG		rc;
#if DBG
	ULONG		Flags = pElan->Flags;
#endif

	TRACEIN(DereferenceElan);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ASSERT(pElan->RefCount > 0);

	rc = --(pElan->RefCount);

	if (rc == 0)
	{
		pElan->Flags |= ELAN_DEALLOCATING;
		RELEASE_ELAN_LOCK(pElan);
		AtmLaneDeallocateElan(pElan);
	}
	
	DBGP((5, "DereferenceElan: Elan %p/%x (%s) new count %d\n",
			pElan, Flags, String, rc));

	TRACEOUT(DereferenceElan);

	return (rc);
}

VOID
AtmLaneUnlinkElanFromAdapter(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Unlinks an ELAN structure from the Adapter structure it is linked to.
	Also continues any pending operation on the Adapter.

Arguments:

	pElan		- Pointer to Elan

Return Value:

	None

--*/
{
	PATMLANE_ADAPTER		pAdapter;
	BOOLEAN					CompleteUnbind;

	DBGP((1, "%d UnlinkElanFromAdapter: pElan %p/%x, Ref %d, pAdapter %p\n",
			pElan->ElanNumber, pElan, pElan->Flags, pElan->RefCount, pElan->pAdapter));

	pAdapter = pElan->pAdapter;

	if (pAdapter != NULL_PATMLANE_ADAPTER)
	{
		DBGP((1, "UnlinkElanFromAdapter: pAdapter %x, Flags %x, RefCount %d\n",
					pAdapter,
					pAdapter->Flags, pAdapter->RefCount));
		//
		//  Unlink from adapter list.
		//
		ACQUIRE_ADAPTER_LOCK(pAdapter);
		pElan->pAdapter = NULL_PATMLANE_ADAPTER;
		RemoveEntryList(&pElan->Link);
		pAdapter->ElanCount--;
		AtmLaneDereferenceAdapter(pAdapter, "elan");

		if (IsListEmpty(&pAdapter->ElanList) &&
			(pAdapter->Flags & ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING))
		{
			pAdapter->Flags &= ~ADAPTER_FLAGS_UNBIND_COMPLETE_PENDING;
			CompleteUnbind = TRUE;
		}
		else
		{
			CompleteUnbind = FALSE;
		}

		RELEASE_ADAPTER_LOCK(pAdapter);

		//
		//  If we just freed the last elan structure on this
		//  adapter, and an Unbind operation was in progress, complete
		//  it now.
		//
		if (CompleteUnbind)
		{
			AtmLaneCompleteUnbindAdapter(pAdapter);
		}
	}
}

PATMLANE_ATM_ENTRY
AtmLaneAllocateAtmEntry(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate an ATM Entry structure, initialize it, and return it.

Arguments:

	pElan		- Pointer to Elan on which the entry is allocated

Return Value:

	Pointer to allocated ATM Entry structure if successful, NULL otherwise.

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;

	TRACEIN(AllocateAtmEntry);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ALLOC_MEM(&pAtmEntry, sizeof(ATMLANE_ATM_ENTRY));
	if (pAtmEntry != NULL_PATMLANE_ATM_ENTRY)
	{
		NdisZeroMemory(pAtmEntry, sizeof(ATMLANE_ATM_ENTRY));
#if DBG
		pAtmEntry->atmlane_atm_sig = atmlane_atm_signature;
#endif
		pAtmEntry->Flags = ATM_ENTRY_IDLE;
		INIT_ATM_ENTRY_LOCK(pAtmEntry);
		pAtmEntry->pElan = pElan;
		
	}

	DBGP((5, "AllocateAtmEntry:ATM Entry: Elan %x, Entry %x\n",
				pElan, pAtmEntry));
				
	TRACEOUT(AllocateAtmEntry);

	return (pAtmEntry);
}


VOID
AtmLaneDeallocateAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry
)
/*++

Routine Description:

	Free an ATM Entry structure. It is assumed that all references
	to the structure have gone. We don't need any locks here.

Arguments:

	pAtmEntry		- Pointer to ATM Entry to be freed.

Return Value:

	None

--*/
{
	TRACEIN(DeallocateAtmEntry);


	STRUCT_ASSERT(pAtmEntry, atmlane_atm);
	ASSERT(pAtmEntry->RefCount == 0);
	ASSERT(pAtmEntry->pVcList == NULL_PATMLANE_VC);

#if DBG
	pAtmEntry->atmlane_atm_sig++;
#endif

	FREE_ATM_ENTRY_LOCK(pAtmEntry);
	FREE_MEM(pAtmEntry);

	DBGP((5, "DeallocateAtmEntry: ATM Entry: %x\n", pAtmEntry));

	TRACEOUT(DeallocateAtmEntry);
}


VOID
AtmLaneReferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Add a reference to the specified ATM Entry.
	NOTE: The caller is assumed to possess a lock for the Entry.

Arguments:

	pAtmEntry			- Pointer to the Entry to be referenced

Return Value:

	None

--*/
{
	TRACEIN(ReferenceAtmEntry);
	
	STRUCT_ASSERT(pAtmEntry, atmlane_atm);

	pAtmEntry->RefCount++;

	DBGP((5, "ReferenceAtmEntry: Entry %x (%s) new count %d\n",
			 pAtmEntry, String, pAtmEntry->RefCount));
			 
	TRACEOUT(ReferenceAtmEntry);
}


ULONG
AtmLaneDereferenceAtmEntry(
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Subtract a reference from the specified ATM Entry. If the Entry's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the Entry.
	SIDE EFFECT: See Return Value below

Arguments:

	pAtmEntry			- Pointer to the Entry to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the Entry's reference count became zero, the Entry will be
	deallocated -- the Entry lock is, obviously, released in this case.

--*/
{
	ULONG					rc;
	PATMLANE_ELAN			pElan;

	TRACEIN(DereferenceAtmEntry);
	
	STRUCT_ASSERT(pAtmEntry, atmlane_atm);

	if (pAtmEntry->RefCount == 0)
	{
		rc = 0;
	}
	else
	{
		rc = --(pAtmEntry->RefCount);
	}

	if (rc == 0)
	{
		PATMLANE_ATM_ENTRY *	ppAtmEntry;

		DBGP((5, "DerefAtmEntry %x, RefCount is 0\n", pAtmEntry));

		//
		//  Unlink this entry from the Elan's list of ATM Entries.
		//

		//
		//  Acquire locks in the right order. However note that in doing so,
		//  some other thread might stumble across this ATM entry and reference
		//  it (and also dereference it!). To handle this, add a temp ref first.
		//
		pAtmEntry->RefCount++;

		pElan = pAtmEntry->pElan;
		STRUCT_ASSERT(pElan, atmlane_elan);

		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

		ACQUIRE_ELAN_ATM_LIST_LOCK(pElan);
		ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

		//
		//  Remove the temp ref above. If the ref count is still at 0,
		//  nobody is using this ATM entry and it is safe to remove it
		//  from the list.
		//
		rc = --(pAtmEntry->RefCount);
		
		if (rc == 0)
		{
			//
			//  Safe to delete this ATM entry.
			//
#if DBG 
			if (pAtmEntry->pMacEntryList != NULL)
			{
				DBGP((0, "ATMLANE: derefed pAtmEntry %x, but MACEntryList isn't NULL!\n",
					pAtmEntry));
				ASSERT(FALSE);
			}
#endif // DBG
                
			ppAtmEntry = &(pElan->pAtmEntryList);
			while (*ppAtmEntry != pAtmEntry)
			{
				ASSERT(*ppAtmEntry != NULL_PATMLANE_ATM_ENTRY);
				ppAtmEntry = &((*ppAtmEntry)->pNext);
			}

			*ppAtmEntry = pAtmEntry->pNext;

			pElan->NumAtmEntries--;
		
			//
			//	If ATM Entry is for a LANE server 
			//	then also invalidate elan's cached pointer to it
			//
			switch (pAtmEntry->Type)
			{
				case ATM_ENTRY_TYPE_LECS:
					pElan->pLecsAtmEntry = NULL_PATMLANE_ATM_ENTRY;
					break;
				case ATM_ENTRY_TYPE_LES:
					pElan->pLesAtmEntry = NULL_PATMLANE_ATM_ENTRY;
					break;
				case ATM_ENTRY_TYPE_BUS:
					pElan->pBusAtmEntry = NULL_PATMLANE_ATM_ENTRY;
					break;
			}
		}

		RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);
		RELEASE_ELAN_ATM_LIST_LOCK(pElan);

		if (rc == 0)
		{
			AtmLaneDeallocateAtmEntry(pAtmEntry);
		}
		else
		{
			//
			//  As far as this caller is concerned, the ATM entry is gone.
			//  Return 0.
			//
			rc = 0;
		}
	}

	DBGP((5, "DereferenceAtmEntry: Entry %x (%s) new count %d\n", 
			pAtmEntry, String, rc));

	TRACEOUT(DereferenceAtmEntry);
	
	return (rc);
}

PATMLANE_VC
AtmLaneAllocateVc(
	IN	PATMLANE_ELAN				pElan
)
/*++

Routine Description:

	Allocate an ATMLANE VC structure, initialize it, and return it.

Arguments:

	pElan		- Elan for which this VC is created.

Return Value:

	Pointer to VC if allocated, NULL otherwise.

--*/
{
	PATMLANE_VC			pVc;

	TRACEIN(AllocateVc);

	STRUCT_ASSERT(pElan, atmlane_elan);

	ALLOC_MEM_PRIORITY(&pVc, sizeof(ATMLANE_VC), LowPoolPriority);

	if (pVc != NULL_PATMLANE_VC)
	{
		NdisZeroMemory(pVc, sizeof(ATMLANE_VC));
#if DBG
		pVc->atmlane_vc_sig = atmlane_vc_signature;
#endif // DBG
		pVc->pElan = pElan;
		INIT_VC_LOCK(pVc);
	}

	DBGP((3, "Allocated Vc %x\n", pVc));

	TRACEOUT(AllocateVc);

	return (pVc);
}

VOID
AtmLaneDeallocateVc(
	IN	PATMLANE_VC					pVc
)
/*++

Routine Description:

	Deallocate an ATMLANE VC structure. It is assumed that all references
	to this VC have gone, so there is no need to acquire a lock to the VC.

Arguments:

	pVc			- Pointer to the VC to be deallocated

Return Value:

	None

--*/
{
	TRACEIN(DeallocateVc);

	STRUCT_ASSERT(pVc, atmlane_vc);
	ASSERT(pVc->RefCount == 0);

#if DBG
	pVc->atmlane_vc_sig++;
#endif
	FREE_VC_LOCK(pVc);
	FREE_MEM(pVc);

	DBGP((5, "Deallocated Vc %x\n", pVc));

	TRACEOUT(DeallocateVc);

	return;
}

VOID
AtmLaneReferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Add a reference to the specified ATMLANE VC.
	NOTE: The caller is assumed to possess a lock for the VC.

Arguments:

	pVc			- Pointer to the VC to be referenced

Return Value:

	None

--*/
{
	TRACEIN(ReferenceVc);

	STRUCT_ASSERT(pVc, atmlane_vc);

	pVc->RefCount++;

	DBGP((5, "ReferenceVc: Vc %x (%s) new count %d\n",
			 pVc, String, pVc->RefCount));

	TRACEOUT(ReferenceVc);

	return;
}


ULONG
AtmLaneDereferenceVc(
	IN	PATMLANE_VC					pVc,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Subtract a reference from the specified ATMLANE VC. If the VC's
	reference count becomes zero, deallocate it.

	NOTE: The caller is assumed to possess a lock for the VC.
	SIDE EFFECT: See Return Value below

Arguments:

	pVc			- Pointer to the VC to be dereferenced.

Return Value:

	Is the new reference count.
	[IMPORTANT] If the VC's reference count became zero, the VC will be
	deallocated -- the VC lock is, obviously, released in this case.

--*/
{
	ULONG		rv;

	TRACEIN(DereferenceVc);

	STRUCT_ASSERT(pVc, atmlane_vc);
	ASSERT(pVc->RefCount > 0);

	rv = --(pVc->RefCount);
	if (rv == 0)
	{
		RELEASE_VC_LOCK(pVc);
		AtmLaneDeallocateVc(pVc);
	}

	DBGP((5, "DereferenceVc: Vc %x (%s) new count %d\n", 
			pVc, String, rv));

	TRACEOUT(DereferenceVc);

	return (rv);
}

PATMLANE_MAC_ENTRY
AtmLaneAllocateMacEntry(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate an ATMLANE MAC Entry structure, initialize it, and
	return it.

Arguments:

	pElan		- Pointer to ATMLANE Interface on which this MAC
				  Entry is allocated.

Return Value:

	Pointer to allocated MAC Entry structure if successful,
	NULL otherwise.

--*/
{
	PATMLANE_MAC_ENTRY		pMacEntry;

	TRACEIN(AllocateMacEntry);

	ALLOC_MEM_PRIORITY(&pMacEntry, sizeof(ATMLANE_MAC_ENTRY), LowPoolPriority);

	if (pMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		NdisZeroMemory(pMacEntry, sizeof(ATMLANE_MAC_ENTRY));
#if DBG
		pMacEntry->atmlane_mac_sig = atmlane_mac_signature;
#endif // DBG
		pMacEntry->pElan = pElan;
		pMacEntry->Flags = MAC_ENTRY_NEW;
		INIT_MAC_ENTRY_LOCK(pMacEntry);

		INIT_SYSTEM_TIMER(
					&pMacEntry->BusTimer, 
					AtmLaneBusSendTimer, 
					pMacEntry);

		pMacEntry->LimitTime = pElan->LimitTime;
		pMacEntry->IncrTime = pElan->IncrTime;
	}

	DBGP((5, "AllocateMacEntry: Allocated Entry %x\n", pMacEntry));

	TRACEOUT(AllocateMacEntry);
	return (pMacEntry);
}

VOID
AtmLaneDeallocateMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Deallocate an ATMLANE Mac Entry. It is assumed that all references
	to this Mac Entry have gone, so there is no need to acquire its
	lock.

Arguments:

	pMacEntry			- Pointer to the Mac Entry to be deallocated.

Return Value:

	None

--*/
{
	TRACEIN(DeallocateMacEntry);

	STRUCT_ASSERT(pMacEntry, atmlane_mac);
	ASSERT(pMacEntry->RefCount == 0);

#if DBG
	pMacEntry->atmlane_mac_sig++;
#endif

	FREE_MAC_ENTRY_LOCK(pMacEntry);
	FREE_MEM(pMacEntry);

	DBGP((5,"DeallocateMacEntry: Deallocated Entry %x\n", pMacEntry));

	TRACEOUT(DeallocateMacEntry);
	return;
}

VOID
AtmLaneReferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Add a reference to an ATMLANE Mac Entry.
	NOTE: The caller is assumed to possess a lock for the Mac Entry.

Arguments:

	pMacEntry			- Pointer to an ATMLANE Mac Entry.

Return Value:

	None

--*/
{
	TRACEIN(ReferenceMacEntry);

	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	pMacEntry->RefCount++;

	DBGP((5, "ReferenceMacEntry: Entry %x (%s) new count %d\n",
			pMacEntry, String, pMacEntry->RefCount));

	TRACEOUT(ReferenceMacEntry);
	return;
}

ULONG
AtmLaneDereferenceMacEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry,
	IN	PUCHAR						String
)
/*++

Routine Description:

	Subtract a reference from an ATMLANE MAC Entry. If the reference
	count becomes zero, deallocate it.
	NOTE: It is assumed that the caller holds a lock to the MAC Entry.
	See SIDE EFFECT below.

Arguments:

	pMacEntry			- Pointer to ATMLANE MAC Entry

Return Value:

	The resulting reference count. If this is zero, then there are two
	SIDE EFFECTS: (1) the MAC Entry lock is released (2) the structure
	is freed.

--*/
{
	ULONG		rc;
	
	TRACEIN(DereferenceMacEntry);

	STRUCT_ASSERT(pMacEntry, atmlane_mac);

	rc = --(pMacEntry->RefCount);

	if (rc == 0)
	{
		PVOID	Caller, CallersCaller;

		RELEASE_MAC_ENTRY_LOCK(pMacEntry);

		//
		//  Save away the caller's address for debugging purposes...
		//
		RtlGetCallersAddress(&Caller, &CallersCaller);
		pMacEntry->Timer.ContextPtr = Caller;

		AtmLaneDeallocateMacEntry(pMacEntry);
	}

	DBGP((5, "DereferenceMacEntry: Entry %x (%s) new count %d\n",
			pMacEntry, String, rc));

	TRACEOUT(DereferenceMacEntry);
	return (rc);
}

PNDIS_PACKET
AtmLaneAllocProtoPacket(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate an NDIS packet for use as a LANE control frame.

Arguments:

	pElan		- Pointer to ATMLANE ELAN structure

Return Value:

	Pointer to NDIS packet if allocated, NULL otherwise.

--*/
{
	NDIS_STATUS		Status;
	PNDIS_PACKET	pNdisPacket;

	TRACEIN(AllocProtoPacket);

	NdisAllocatePacket(
			&Status,
			&pNdisPacket,
			pElan->ProtocolPacketPool
		);
		
	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
		//
		//	Init ProtocolReserved and mark packet owned by ATMLANE
		//
		ZERO_SEND_RSVD(pNdisPacket);
	#if PROTECT_PACKETS
		INIT_SENDPACKET_LOCK(pNdisPacket);
	#endif	// PROTECT_PACKETS
		SET_FLAG(
				PSEND_RSVD(pNdisPacket)->Flags,
				PACKET_RESERVED_OWNER_MASK,
				PACKET_RESERVED_OWNER_ATMLANE
				);
		
#if PKT_HDR_COUNTS
		InterlockedDecrement(&pElan->ProtPktCount);
		if ((pElan->ProtPktCount % 20) == 0)
		{
			DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
		}
#endif
	}	

	TRACEOUT(AllocProtoPacket);

	return (pNdisPacket);
}

VOID
AtmLaneFreeProtoPacket(
	IN	PATMLANE_ELAN			pElan,
	IN	PNDIS_PACKET			pNdisPacket
)
/*++

Routine Description:

	Allocate an NDIS packet used as a LANE control frame.

Arguments:

	pElan			- Pointer to ATMLANE ELAN structure

	pNdisPacket		- pointer to NDIS_PACKET to free.

Return Value:

	None
	
--*/
{
	TRACEIN(FreeProtoPacket);

	if (pNdisPacket != (PNDIS_PACKET)NULL)
	{
#if PROTECT_PACKETS
		FREE_SENDPACKET_LOCK(pNdisPacket);
#endif	// PROTECT_PACKETS
		NdisFreePacket(pNdisPacket);
#if PKT_HDR_COUNTS
		InterlockedIncrement(&pElan->ProtPktCount);
		if ((pElan->ProtPktCount % 20) == 0 && 
			pElan->ProtPktCount != pElan->MaxProtocolBufs)
		{
			DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
		}
#endif
	}

	TRACEOUT(FreeProtoPacket);
	return;
}

PNDIS_BUFFER
AtmLaneGrowHeaders(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate a bunch of header buffers on the specified ATMLANE Elan.
	Return one of them.

	We allocate a new Buffer tracker structure, a new NDIS Buffer pool, and
	finally a chunk of system memory that we break down into header buffers.
	These header buffers are then attached to NDIS Buffers before they are
	inserted into the list of free header buffers for this Interface.

	Caller is assumed to hold appropriate lock.

Arguments:

	pElan		- Pointer to ATMLANE Elan structure

Return Value:

	Pointer to allocated NDIS buffer if successful, NULL otherwise.

--*/
{
	PATMLANE_BUFFER_TRACKER		pTracker;		// for new set of buffers
	PUCHAR						pSpace;
	PNDIS_BUFFER				pNdisBuffer;
	PNDIS_BUFFER				pReturnBuffer;
	PNDIS_BUFFER				pBufferList;	// allocated list
	INT							i;				// iteration counter
	NDIS_STATUS					Status;

	TRACEIN(GrowHeaders);

	//
	//  Initialize
	//
	pTracker = NULL_PATMLANE_BUFFER_TRACKER;
	pReturnBuffer = (PNDIS_BUFFER)NULL;

	do
	{
		if (pElan->CurHeaderBufs >= pElan->MaxHeaderBufs)
		{
			DBGP((2, "GrowHeaders: Elan %x, CurHdrBufs %d > MaxHdrBufs %d\n",
					pElan, pElan->CurHeaderBufs, pElan->MaxHeaderBufs));
			break;
		}

		//
		//  Allocate and initialize Buffer tracker
		//
		ALLOC_MEM(&pTracker, sizeof(ATMLANE_BUFFER_TRACKER));
		if (pTracker == NULL_PATMLANE_BUFFER_TRACKER)
		{
			DBGP((0, "GrowHeaders: Elan %x, alloc failed for tracker\n",
					pElan));
			break;
		}

		NdisZeroMemory(pTracker, sizeof(ATMLANE_BUFFER_TRACKER));

		//
		//  Get the NDIS Buffer pool
		//
		NdisAllocateBufferPool(
				&Status,
				&(pTracker->NdisHandle),
				DEF_HDRBUF_GROW_SIZE
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"GrowHeaders: Elan %x, NdisAllocateBufferPool err status %x\n",
					pElan, Status));
			break;
		}

		//
		//  Allocate system space for a bunch of header buffers
		//	Note we use RealHeaderBufSize here so that the
		//	buffers end up on ULONG boundaries.
		//
		ALLOC_MEM(&(pTracker->pPoolStart),  
					pElan->RealHeaderBufSize * DEF_HDRBUF_GROW_SIZE);
		if (pTracker->pPoolStart == (PUCHAR)NULL)
		{
			DBGP((0, "GrowHeaders: Elan %x, could not alloc buf space %d bytes\n",
					pElan, pElan->HeaderBufSize * DEF_HDRBUF_GROW_SIZE));
			break;
		}

		//
		//  Make NDIS buffers out of the allocated space, and put them
		//  into the free header buffer list. Retain one for returning
		//  to caller.
		//
		pBufferList = (PNDIS_BUFFER)NULL;
		pSpace = pTracker->pPoolStart;
		for (i = 0; i < DEF_HDRBUF_GROW_SIZE; i++)
		{
			NdisAllocateBuffer(
					&Status,
					&pNdisBuffer,
					pTracker->NdisHandle,
					pSpace,
					pElan->HeaderBufSize
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				DBGP((0, 
					"GrowHeaders: NdisAllocateBuffer failed: Elan %x, status %x\n",
							pElan, Status));
				break;
			}

			if (i == 0)
			{
				pReturnBuffer = pNdisBuffer;
			}
			else
			{
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = pBufferList;
				pBufferList = pNdisBuffer;
			}
			pSpace += pElan->RealHeaderBufSize;
		}

		if (i > 0)
		{
			//
			//  Successfully allocated at least one more header buffer
			//
			pTracker->pNext = pElan->pHeaderTrkList;
			pElan->pHeaderTrkList = pTracker;
			pElan->CurHeaderBufs += i;

			pNdisBuffer = pBufferList;
			while (pNdisBuffer != (PNDIS_BUFFER)NULL)
			{
				pBufferList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				AtmLaneFreeHeader(pElan, pNdisBuffer, TRUE);
				pNdisBuffer = pBufferList;
			}
		}

	} while (FALSE);

	if (pReturnBuffer == (PNDIS_BUFFER)NULL)
	{
		//
		//  Failed to allocate. Undo all.
		//
		if (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
		{
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				FREE_MEM(pTracker->pPoolStart);
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
			}
			FREE_MEM(pTracker);
		}
	}

	DBGP((2, "GrowHeaders: Elan %x, RetBuf %x, New Tracker %x\n",
				pElan, pReturnBuffer, pTracker));

	TRACEOUT(GrowHeaders);

	return (pReturnBuffer);
}

PNDIS_BUFFER
AtmLaneAllocateHeader(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
)
/*++

Routine Description:

	Allocate an NDIS Buffer to be used for LECID a MAC packet. 
	We pick up the buffer at the top of the pre-allocated
	buffer list, if one exists. Otherwise, we try to grow this list and
	allocate.

Arguments:

	pElan			- Pointer to ATMLANE Elan
	pBufferAddress	- Place to return virtual address of allocated buffer

Return Value:

	Pointer to NDIS buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					Length;

	TRACEIN(AllocateHeader);

	ACQUIRE_HEADER_LOCK(pElan);

	pNdisBuffer = pElan->HeaderBufList;
	if (pNdisBuffer != (PNDIS_BUFFER)NULL)
	{
		pElan->HeaderBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
		NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
		NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
	}
	else
	{
		pNdisBuffer = AtmLaneGrowHeaders(pElan);
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
		}
	}

	DBGP((5, "AllocateHeader: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(AllocateHeader);
	return (pNdisBuffer);
}

VOID
AtmLaneFreeHeader(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
)
/*++

Routine Description:

	Deallocate a header buffer.

Arguments:

	pElan			- Pointer to ATMLANE Elan from which the buffer came
	pNdisBuffer		- Pointer to NDIS buffer being freed
	LockHeld		- TRUE if appropriate lock already held

Return Value:

	None

--*/
{
	TRACEIN(FreeHeader);

	if (!LockHeld)
	{
		ACQUIRE_HEADER_LOCK(pElan);
	}

	NDIS_BUFFER_LINKAGE(pNdisBuffer) = pElan->HeaderBufList;
	pElan->HeaderBufList = pNdisBuffer;

	DBGP((5, "FreeHeader: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));
					
	if (!LockHeld)
	{
		RELEASE_HEADER_LOCK(pElan);
	}
	
	TRACEOUT(FreeHeader);
}

VOID
AtmLaneDeallocateHeaderBuffers(
	IN	PATMLANE_ELAN				pElan
)
/*++

Routine Description:

	Deallocate everything pertaining to header buffers on an Elan.

Arguments:

	pElan				- Pointer to ATMLANE Elan.

Return Value:

	None

--*/
{
	PNDIS_BUFFER				pNdisBuffer;
	NDIS_STATUS					Status;
	PATMLANE_BUFFER_TRACKER		pTracker;
	PATMLANE_BUFFER_TRACKER		pNextTracker;

	TRACEIN(DeallocateHeaderBuffers);

	//
	//  Free all NDIS buffers in the header buffer list.
	//
	ACQUIRE_HEADER_LOCK(pElan);
	do
	{
		pNdisBuffer = pElan->HeaderBufList;
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			pElan->HeaderBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisFreeBuffer(pNdisBuffer);
		}
		else
		{
			//
			//  No more NDIS buffers.
			//
			break;
		}
	}
	while (TRUE);

	//
	//  Now free all the buffer trackers.
	//
	pTracker = pElan->pHeaderTrkList;

	while (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
	{
		pNextTracker = pTracker->pNext;
		if (pTracker->pPoolStart != (PUCHAR)NULL)
		{
			FREE_MEM(pTracker->pPoolStart);
			pTracker->pPoolStart = (PUCHAR)NULL;
		}
		if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
		{
			NdisFreeBufferPool(pTracker->NdisHandle);
			pTracker->NdisHandle = (NDIS_HANDLE)NULL;
		}
		FREE_MEM(pTracker);
		pTracker = pNextTracker;
	}

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(DeallocateHeaderBuffers);
}

PNDIS_BUFFER
AtmLaneGrowPadBufs(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Allocate a bunch of packet pad buffers on the specified ATMLANE Elan.
	Return one of them.

	We allocate a new Buffer tracker structure, a new NDIS Buffer pool, and
	finally a chunk of system memory (if not allocated already, only need one).
	This buffer is then attached to the NDIS Buffers before they are
	inserted into the list of free pad buffers for this Interface.

	Caller is assumed to hold appropriate lock.

Arguments:

	pElan		- Pointer to ATMLANE Elan structure

Return Value:

	Pointer to allocated NDIS buffer if successful, NULL otherwise.

--*/
{
	PATMLANE_BUFFER_TRACKER		pTracker;		// for new set of buffers
	PUCHAR						pSpace;
	PNDIS_BUFFER				pNdisBuffer;
	PNDIS_BUFFER				pReturnBuffer;
	PNDIS_BUFFER				pBufferList;	// allocated list
	INT							i;				// iteration counter
	NDIS_STATUS					Status;

	TRACEIN(GrowPadBufs);

	//
	//  Initialize
	//
	pTracker = NULL_PATMLANE_BUFFER_TRACKER;
	pReturnBuffer = (PNDIS_BUFFER)NULL;

	do
	{
		if (pElan->CurPadBufs >= pElan->MaxPadBufs)
		{
			DBGP((0, "GrowPadBufs: Max Reached! Elan %x, CurPadBufs %d > MaxPadBufs %d\n",
					pElan, pElan->CurPadBufs, pElan->MaxPadBufs));
			break;
		}

		//
		//  Allocate and initialize Buffer tracker
		//
		ALLOC_MEM(&pTracker, sizeof(ATMLANE_BUFFER_TRACKER));
		if (pTracker == NULL_PATMLANE_BUFFER_TRACKER)
		{
			DBGP((0, "GrowPadBufs: Elan %x, alloc failed for tracker\n",
					pElan));
			break;
		}

		NdisZeroMemory(pTracker, sizeof(ATMLANE_BUFFER_TRACKER));

		//
		//  Get the NDIS Buffer pool
		//
		NdisAllocateBufferPool(
				&Status,
				&(pTracker->NdisHandle),
				DEF_HDRBUF_GROW_SIZE
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGP((0, 
				"GrowPadBufs: Elan %x, NdisAllocateBufferPool err status %x\n",
					pElan, Status));
			break;
		}

		//
		//  Allocate system space for a single pad buffer.
		//
		ALLOC_MEM(&(pTracker->pPoolStart), pElan->PadBufSize);
		if (pTracker->pPoolStart == (PUCHAR)NULL)
		{
			DBGP((0, "GrowPadBufs: Elan %x, could not alloc buf space %d bytes\n",
					pElan, pElan->PadBufSize * DEF_HDRBUF_GROW_SIZE));
			break;
		}

		//
		//  Make NDIS buffers out of the allocated space, and put them
		//  into the free pad buffer list. Retain one for returning
		//  to caller.  NOTE we put same pad buffer in each ndis buffer header
		//	since contents is irrelevent.
		//
		pBufferList = (PNDIS_BUFFER)NULL;
		pSpace = pTracker->pPoolStart;
		for (i = 0; i < DEF_HDRBUF_GROW_SIZE; i++)
		{
			NdisAllocateBuffer(
					&Status,
					&pNdisBuffer,
					pTracker->NdisHandle,
					pSpace,
					pElan->PadBufSize
				);

			if (Status != NDIS_STATUS_SUCCESS)
			{
				DBGP((0, 
					"GrowPadBufs: NdisAllocateBuffer failed: Elan %x, status %x\n",
							pElan, Status));
				break;
			}

			if (i == 0)
			{
				pReturnBuffer = pNdisBuffer;
			}
			else
			{
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = pBufferList;
				pBufferList = pNdisBuffer;
			}
		}

		if (i > 0)
		{
			//
			//  Successfully allocated at least one more pad buffer
			//
			pTracker->pNext = pElan->pPadTrkList;
			pElan->pPadTrkList = pTracker;
			pElan->CurPadBufs += i;

			pNdisBuffer = pBufferList;
			while (pNdisBuffer != (PNDIS_BUFFER)NULL)
			{
				pBufferList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
				NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
				AtmLaneFreePadBuf(pElan, pNdisBuffer, TRUE);
				pNdisBuffer = pBufferList;
			}
		}

	} while (FALSE);

	if (pReturnBuffer == (PNDIS_BUFFER)NULL)
	{
		//
		//  Failed to allocate. Undo all.
		//
		if (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
		{
			if (pTracker->pPoolStart != (PUCHAR)NULL)
			{
				FREE_MEM(pTracker->pPoolStart);
			}
			if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
			{
				NdisFreeBufferPool(pTracker->NdisHandle);
			}
			FREE_MEM(pTracker);
		}
	}

	DBGP((2, "GrowPadBufs: Elan %x, RetBuf %x, New Tracker %x\n",
				pElan, pReturnBuffer, pTracker));

	TRACEOUT(GrowPadBufs);

	return (pReturnBuffer);
}

PNDIS_BUFFER
AtmLaneAllocatePadBuf(
	IN	PATMLANE_ELAN			pElan,
	OUT	PUCHAR *				pBufferAddress
)
/*++

Routine Description:

	Allocate an NDIS Buffer to be used to pad a MAC packet to min length.
	We pick up the buffer at the top of the pre-allocated
	buffer list, if one exists. Otherwise, we try to grow this list and
	allocate.

Arguments:

	pElan			- Pointer to ATMLANE Elan
	pBufferAddress	- Place to return virtual address of allocated buffer

Return Value:

	Pointer to NDIS buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER			pNdisBuffer;
	NDIS_STATUS				Status;
	ULONG					Length;

	TRACEIN(AtmLaneAllocatePadBuf);

	ACQUIRE_HEADER_LOCK(pElan);

	pNdisBuffer = pElan->PadBufList;
	if (pNdisBuffer != (PNDIS_BUFFER)NULL)
	{
		pElan->PadBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
		NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
		NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
	}
	else
	{
		pNdisBuffer = AtmLaneGrowPadBufs(pElan);
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisQueryBuffer(pNdisBuffer, (PVOID)pBufferAddress, &Length);
		}
	}

	DBGP((5, "AllocatePadBuf: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(AllocatePadBuf);
	return (pNdisBuffer);
}

VOID
AtmLaneFreePadBuf(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer,
	IN	BOOLEAN						LockHeld
)
/*++

Routine Description:

	Deallocate a Pad buffer.

Arguments:

	pElan			- Pointer to ATMLANE Elan from which the buffer came
	pNdisBuffer		- Pointer to NDIS buffer being freed
	LockHeld		- TRUE if appropriate lock already held

Return Value:

	None

--*/
{
	TRACEIN(FreePadBuf);

	if (!LockHeld)
	{
		ACQUIRE_HEADER_LOCK(pElan);
	}

	NDIS_BUFFER_LINKAGE(pNdisBuffer) = pElan->PadBufList;
	pElan->PadBufList = pNdisBuffer;

	DBGP((5, "FreePadBuf: Buffer %x, Elan %x\n",
					pNdisBuffer, pElan));
					
	if (!LockHeld)
	{
		RELEASE_HEADER_LOCK(pElan);
	}
	
	TRACEOUT(FreePadBuf);
}

VOID
AtmLaneDeallocatePadBufs(
	IN	PATMLANE_ELAN				pElan
)
/*++

Routine Description:

	Deallocate everything pertaining to Pad buffers on an Elan.

Arguments:

	pElan				- Pointer to ATMLANE Elan.

Return Value:

	None

--*/
{
	PNDIS_BUFFER				pNdisBuffer;
	NDIS_STATUS					Status;
	PATMLANE_BUFFER_TRACKER		pTracker;
	PATMLANE_BUFFER_TRACKER		pNextTracker;

	TRACEIN(DeallocatePadBufs);

	//
	//  Free all NDIS buffers in the Pad buffer list.
	//
	ACQUIRE_HEADER_LOCK(pElan);
	do
	{
		pNdisBuffer = pElan->PadBufList;
		if (pNdisBuffer != (PNDIS_BUFFER)NULL)
		{
			pElan->PadBufList = NDIS_BUFFER_LINKAGE(pNdisBuffer);
			NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
			NdisFreeBuffer(pNdisBuffer);
		}
		else
		{
			//
			//  No more NDIS buffers.
			//
			break;
		}
	}
	while (TRUE);

	//
	//  Now free all the buffer trackers.
	//
	pTracker = pElan->pPadTrkList;

	while (pTracker != NULL_PATMLANE_BUFFER_TRACKER)
	{
		pNextTracker = pTracker->pNext;
		if (pTracker->pPoolStart != (PUCHAR)NULL)
		{
			FREE_MEM(pTracker->pPoolStart);
			pTracker->pPoolStart = (PUCHAR)NULL;
		}
		if (pTracker->NdisHandle != (NDIS_HANDLE)NULL)
		{
			NdisFreeBufferPool(pTracker->NdisHandle);
			pTracker->NdisHandle = (NDIS_HANDLE)NULL;
		}
		FREE_MEM(pTracker);
		pTracker = pNextTracker;
	}

	RELEASE_HEADER_LOCK(pElan);

	TRACEOUT(DeallocatePadBufs);
}

PNDIS_BUFFER
AtmLaneAllocateProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	ULONG						Length,
	OUT	PUCHAR *					pBufferAddress
)
/*++

Routine Description:

	Allocate a buffer to be used for a LANE protocol message. Attach
	it to an NDIS_BUFFER structure and return a pointer to this.

Arguments:

	pElan			- Pointer to ATMLANE Elan
	Length			- Length, in bytes, of the buffer.
	pBufferAddress	- Place to return virtual address of allocated buffer.

Return Value:

	Pointer to NDIS Buffer if successful, NULL otherwise.

--*/
{
	PNDIS_BUFFER		pNdisBuffer;
	NDIS_STATUS			Status;

	TRACEIN(AllocateProtobuffer);
	
	//
	//  Initialize
	//
	pNdisBuffer = NULL;

	ACQUIRE_ELAN_LOCK(pElan);

	ASSERT(Length <= pElan->ProtocolBufSize);

	*pBufferAddress = pElan->ProtocolBufList;
	if (*pBufferAddress != (PUCHAR)NULL)
	{
		NdisAllocateBuffer(
				&Status,
				&pNdisBuffer,
				pElan->ProtocolBufferPool,
				*pBufferAddress,
				Length
			);

		if (Status == NDIS_STATUS_SUCCESS)
		{
			pElan->ProtocolBufList = *((PUCHAR *)*pBufferAddress);
		}
	}

	RELEASE_ELAN_LOCK(pElan);

	DBGP((5, 
		"AllocateProtoBuffer:  ELan %x, pNdisBuffer %x, Length %d, Loc %x\n",
				pElan, pNdisBuffer, Length, *pBufferAddress));

	TRACEOUT(AllocateProtoBuffer);
	
	return (pNdisBuffer);
}


VOID
AtmLaneFreeProtoBuffer(
	IN	PATMLANE_ELAN				pElan,
	IN	PNDIS_BUFFER				pNdisBuffer
)
/*++

Routine Description:

	Free an NDIS buffer (and associated memory) used for a protocol
	packet. We return the associated memory to the ProtocolBufList
	in the Elan structure, and the NDIS buffer to NDIS.

Arguments:

	pElan			- Pointer to ATMLANE Elan structure
	pNdisBuffer		- Pointer to NDIS buffer to be freed

Return Value:

	None

--*/
{
	PUCHAR *		pBufferLinkage;
	ULONG			Length;

	TRACEIN(FreeProtoBuffer);

#if 0
	pBufferLinkage = (PUCHAR *)NdisBufferVirtualAddress(pNdisBuffer);
#else
	NdisQueryBuffer(pNdisBuffer, (PVOID)&pBufferLinkage, &Length);
#endif

	ACQUIRE_ELAN_LOCK(pElan);

	*pBufferLinkage = pElan->ProtocolBufList;
	pElan->ProtocolBufList = (PUCHAR)pBufferLinkage;

	RELEASE_ELAN_LOCK(pElan);

	NdisFreeBuffer(pNdisBuffer);

	DBGP((5, "FreeProtoBuffer: Elan %x, pNdisBuffer %x, Loc %x\n",
			pElan, pNdisBuffer, (ULONG_PTR)pBufferLinkage));

	TRACEOUT(FreeProtoBuffer);
	return;
}


NDIS_STATUS
AtmLaneInitProtoBuffers(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Initialize the protocol buffer pool for an elan.

	Allocate a chunk of memory to be used for ATMLANE protocol messages.
	We prepare a linked list of protocol buffers, and attach it to the
	Interface structure.

Arguments:

	pElan			- Pointer to Interface on which we need to allocate
					  protocol buffers.
Return Value:

	NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_RESOURCES if we run
	into a resource failure.

--*/
{
	NDIS_STATUS			Status;
	PUCHAR				pSpace;
	ULONG				i;

	TRACEIN(InitProtoBuffers);

	do
	{
		NdisAllocatePacketPool(
				&Status,
				&(pElan->ProtocolPacketPool),
				pElan->MaxProtocolBufs,
				sizeof(SEND_PACKET_RESERVED)
				);
#if PKT_HDR_COUNTS
		pElan->ProtPktCount = pElan->MaxProtocolBufs;
		DBGP((1, "ProtPktCount %d\n", pElan->ProtPktCount));
#endif

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NdisAllocateBufferPool(
				&Status,
				&(pElan->ProtocolBufferPool),
				pElan->MaxProtocolBufs
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a big chunk of system memory that we can divide up into
		//  protocol buffers.
		//
		ALLOC_MEM(
				&(pElan->ProtocolBufTracker),
				(pElan->ProtocolBufSize * pElan->MaxProtocolBufs)
				);

		if (pElan->ProtocolBufTracker == (PUCHAR)NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		Status = NDIS_STATUS_SUCCESS;

		//
		//  Make all protocol buffers free.
		//
		pSpace = pElan->ProtocolBufTracker;
		{
			PUCHAR	LinkPtr;

			LinkPtr = (PUCHAR)NULL;
			for (i = 0; i < pElan->MaxProtocolBufs; i++)
			{
				*((PUCHAR *)pSpace) = LinkPtr;
				LinkPtr = pSpace;
				pSpace += pElan->ProtocolBufSize;
			}
			pSpace -= pElan->ProtocolBufSize;
			pElan->ProtocolBufList = pSpace;
		}
	}
	while (FALSE);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		//
		//  Undo everything.
		//
		AtmLaneDeallocateProtoBuffers(pElan);
	}

	TRACEOUT(InitProtoBuffers);
	
	return (Status);
}


VOID
AtmLaneDeallocateProtoBuffers(
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Free the protocol buffer pool for an interface.

Arguments:

	pElan		- Pointer to ATMLANE elan structure

Return Value:

	None

--*/
{
	if (pElan->ProtocolPacketPool != (NDIS_HANDLE)NULL)
	{
		NdisFreePacketPool(pElan->ProtocolPacketPool);
		pElan->ProtocolPacketPool = NULL;
	}

	if (pElan->ProtocolBufferPool != (NDIS_HANDLE)NULL)
	{
		NdisFreeBufferPool(pElan->ProtocolBufferPool);
		pElan->ProtocolBufferPool = NULL;
	}

	if (pElan->ProtocolBufTracker != (PUCHAR)NULL)
	{
		FREE_MEM(pElan->ProtocolBufTracker);
		pElan->ProtocolBufTracker = (PUCHAR)NULL;
	}
}

VOID
AtmLaneLinkVcToAtmEntry(
	IN	PATMLANE_VC					pVc,
	IN	PATMLANE_ATM_ENTRY			pAtmEntry,
	IN	BOOLEAN						ServerIncoming
)
/*++

Routine Description:

	Link an ATMLANE VC to an ATM Entry. The caller is assumed to
	hold locks to both structures.

Arguments:

	pVc					- Pointer to ATMLANE VC structure
	pAtmEntry			- Pointer to ATMLANE ATM Entry structure
	ServerIncoming		- Incoming call from server 

Return Value:

	None

--*/
{
	PATMLANE_VC *		ppNext;
	PATMLANE_VC			pVcEntry;
	BOOLEAN				WasRunning;

	TRACEIN(LinkVcToAtmEntry);

	DBGP((2, "LinkVcToAtmEntry: pVc %x to pAtmEntry %x ServerIncoming %s\n",
			pVc, pAtmEntry, ServerIncoming?"TRUE":"FALSE"));

	//
	//  Back pointer from VC to ATM Entry.
	//
	pVc->pAtmEntry = pAtmEntry;
	
	//
	//	If server incoming connection cache the VC
	//	special location in the AtmEntry.
	//
	if (ServerIncoming)
	{
		pAtmEntry->pVcIncoming = pVc;
		pVc->pNextVc = NULL_PATMLANE_VC;
	}
	else
	{
		//
		//	Otherwise...
		//
		//	Add VC to the list in ascending calling party ATM address order
		//
		ppNext = &pAtmEntry->pVcList;
		while (*ppNext != NULL_PATMLANE_VC)
		{
			if (memcmp(
					&pVc->CallingAtmAddress.Address, 
					(*ppNext)->CallingAtmAddress.Address, 
					ATM_ADDRESS_LENGTH) < 0)
			{
				// 
				//	Calling address is less than existing VC.
				//
				break;
			}
			else
			{
				//
				//	Calling address is equal or greater than existing VC.
				//	Move on to next.
				//			
				ppNext = &((*ppNext)->pNextVc);
			}
		}

		//
		//  Found the place we were looking for. Insert the VC here.
		//
		pVc->pNextVc = *ppNext;
		*ppNext = pVc;

	}

	//
	//	Add the VC reference to the ATM entry.
	//
	AtmLaneReferenceAtmEntry(pAtmEntry, "vc");	// VC reference

	//
	//	Add the ATM Entry reference to the VC.
	//
	AtmLaneReferenceVc(pVc, "atm");

	//
	//	If this VC is not the first in the list, i.e., not the lowest
	//	calling party number, then set the timeout to the fast VC 
	//	timeout value.  This will get rid of redundant DataDirect VCs quickly 
	//	ONLY if they don't get used within the fast timeout period. 
	//	Otherwise the timeout handler to keep the VC and set
	//	the timeout to the normal C12-VccTimeout value.
	//
	if (pVc != pAtmEntry->pVcList)
	{
		pVc->AgingTime = FAST_VC_TIMEOUT;
	}

	TRACEOUT(LinkVcToAtmEntry);
}

BOOLEAN
AtmLaneUnlinkVcFromAtmEntry(
	IN	PATMLANE_VC					pVc
)
/*++

Routine Description:

	Unlink an ATMLANE VC from the ATM Entry it is linked to.
	The caller is assumed to hold a lock for the VC structure.

Arguments:

	pVc				- Pointer to ATMLANE VC structure

Return Value:

	TRUE if we found the VC linked to the list on the ATM entry, and unlinked it.

--*/
{
	PATMLANE_ATM_ENTRY			pAtmEntry;
	PATMLANE_MAC_ENTRY			pMacEntry, pNextMacEntry;
	ULONG						rc;
	PATMLANE_VC *				ppVc;
	BOOLEAN						Found;

	DBGP((3, "UnlinkVcFromAtmEntry: pVc %x from pAtmEntry %x\n",
			pVc, pVc->pAtmEntry));

	pAtmEntry = pVc->pAtmEntry;
	ASSERT(NULL_PATMLANE_ATM_ENTRY != pAtmEntry);
	
	pVc->pAtmEntry = NULL_PATMLANE_ATM_ENTRY;

	//
	//	Reacquire locks in the right order.
	//
	AtmLaneReferenceVc(pVc, "temp");
	RELEASE_VC_LOCK(pVc);
	ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);
	ACQUIRE_VC_LOCK(pVc);


	//
	//	VC is either a server incoming uni-directional connection,
	//	where it is linked to the AtmEntry via pVcIncoming, or a 
	// 	bi-directional connection that is in the pVcList.
	//
	if (pAtmEntry->pVcIncoming == pVc)
	{
		//
		//  If server incoming VC just remove single entry
		//
		pAtmEntry->pVcIncoming = NULL_PATMLANE_VC;
		Found = TRUE;
	}
	else
	{
		//
		//  Otherwise, find this VC in the ATM Entry's VC list
		//
		ppVc = &(pAtmEntry->pVcList);
		while (*ppVc != NULL_PATMLANE_VC && *ppVc != pVc)
		{
			ppVc = &((*ppVc)->pNextVc);
		}

		//
		//  Remove this VC by making it's predecessor in the list
		//	point to the next VC in the list.
		//
		if (*ppVc == pVc)
		{
			*ppVc = pVc->pNextVc;
			Found = TRUE;
		}
		else
		{
			Found = FALSE;
		}
	}

	rc = AtmLaneDereferenceVc(pVc, "temp");
	if (rc > 0)
	{
		RELEASE_VC_LOCK(pVc);
	}

	//
	//	If no more VC's in list mark AtmEntry as NOT connected
	//
	if (pAtmEntry->pVcList == NULL_PATMLANE_VC)
	{
		SET_FLAG(
				pAtmEntry->Flags,
				ATM_ENTRY_STATE_MASK,
				ATM_ENTRY_VALID);

		DBGP((2, "UnlinkVcFromAtmEntry: Aborting MAC Entries\n"));
		
		pMacEntry = pAtmEntry->pMacEntryList;

		//
		//  Take the MAC entry list out so that we can reference
		//  entries in this list in peace later on below.
		//
		pAtmEntry->pMacEntryList = NULL_PATMLANE_MAC_ENTRY;

		//
		//  Let go of the ATM entry lock while we abort all
		//  the MAC entries in the list above. The ATM entry
		//  won't go away because of the VC reference still on it.
		//  The MAC entries in the list won't go away since they
		//  have the ATM entry reference on them (see UnlinkMacEntry..).
		//
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);

		while (pMacEntry != NULL)
		{
			//
			//  Now abort the MAC Entry. Put this MAC entry back
			//  on the ATM entry's list so that it gets handled
			//  appropriately by AbortMacEntry.
			//
			ACQUIRE_MAC_ENTRY_LOCK(pMacEntry);

			pNextMacEntry = pMacEntry->pNextToAtm;

			ACQUIRE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

			pMacEntry->pNextToAtm = pAtmEntry->pMacEntryList;
			pAtmEntry->pMacEntryList = pMacEntry;

			RELEASE_ATM_ENTRY_LOCK_DPC(pAtmEntry);

			AtmLaneAbortMacEntry(pMacEntry);
			//	MacEntry lock released in above

			pMacEntry = pNextMacEntry;
		}

		ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

	}

	rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "vc"); // VC reference
	if (rc > 0)	
	{
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}
	//
	//  else the ATM Entry is gone!
	//

	//
	//  Acquire the VC lock again for the caller's sake
	//
	ACQUIRE_VC_LOCK(pVc);
	return (Found);
}

BOOLEAN
AtmLaneUnlinkMacEntryFromAtmEntry(
	IN	PATMLANE_MAC_ENTRY			pMacEntry
)
/*++

Routine Description:

	Unlink a Mac Entry from the ATM Entry it is linked to.
	Allow for the MAC entry to be absent in the ATM Entry's list.
	The caller is assumed to hold a lock for the Mac Entry.

Arguments:

	pMacEntry			- Pointer to Mac Entry to be unlinked.

Return Value:

	TRUE iff the MAC entry was found and unlinked.

--*/
{
	PATMLANE_ATM_ENTRY		pAtmEntry;
	PATMLANE_MAC_ENTRY *	ppNextMacEntry;
	ULONG					rc;				// Ref Count on ATM Entry
	BOOLEAN					bFound = FALSE;

	pAtmEntry = pMacEntry->pAtmEntry;
	ASSERT(pAtmEntry != NULL_PATMLANE_ATM_ENTRY);

	DBGP((2, "%d UnlinkMacEntryFromAtmEntry: MacEntry %x AtmEntry %x\n",
			pAtmEntry->pElan->ElanNumber,
			pMacEntry, pMacEntry->pAtmEntry));

	ACQUIRE_ATM_ENTRY_LOCK(pAtmEntry);

	//
	//  Locate the position of this MAC Entry in the ATM Entry's list.
	//
	ppNextMacEntry = &(pAtmEntry->pMacEntryList);

	while (*ppNextMacEntry != NULL_PATMLANE_MAC_ENTRY)
	{
		if (*ppNextMacEntry == pMacEntry)
		{
			//
			//  Found it.
			//
			bFound = TRUE;
			break;
		}
		else
		{
			ppNextMacEntry = &((*ppNextMacEntry)->pNextToAtm);
		}
	}

	if (bFound)
	{
		//
		//  Make the predecessor point to the next entry.
		//
		*ppNextMacEntry = pMacEntry->pNextToAtm;

		rc = AtmLaneDereferenceAtmEntry(pAtmEntry, "mac");	// MAC entry reference
		if (rc != 0)
		{
			RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
		}
		//
		//  else the ATM Entry is gone.
		//
	}
	else
	{
		//
		//  The entry wasn't found.
		//
		RELEASE_ATM_ENTRY_LOCK(pAtmEntry);
	}

	return bFound;
}


VOID
AtmLaneStartTimer(
	IN	PATMLANE_ELAN				pElan,
	IN	PATMLANE_TIMER				pTimer,
	IN	ATMLANE_TIMEOUT_HANDLER		TimeoutHandler,
	IN	ULONG						SecondsToGo,
	IN	PVOID						ContextPtr
)
/*++

Routine Description:

	Start an ATMLANE timer. Based on the length (SecondsToGo) of the
	timer, we decide on whether to insert it in the short duration
	timer list or in the long duration timer list in the Elan
	structure.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

Arguments:

	pElan			- Pointer to the ATMLANE Elan
	pTimer			- Pointer to ATMLANE Timer structure
	TimeoutHandler	- Handler function to be called if this timer expires
	SecondsToGo		- When does this timer go off?
	ContextPtr		- To be passed to timeout handler if this timer expires
	ContextValue	- To be passed to timeout handler if this timer expires
	
Return Value:

	None

--*/
{
	PATMLANE_TIMER_LIST	pTimerList;		// List to which this timer goes
	PATMLANE_TIMER		pTimerListHead; // Head of above list
	ULONG				Index;			// Into timer wheel
	ULONG				TicksToGo;
	INT					i;

	TRACEIN(StartTimer);

	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((5,
		"StartTimer: pElan %x, Secs %d, Handler %x, Ctxtp %x, pTimer %x\n",
 	 			pElan, SecondsToGo, TimeoutHandler, ContextPtr, pTimer));

	if (IS_TIMER_ACTIVE(pTimer))
	{
		DBGP((5, 
		"Start timer: pTimer %x: is active (list %x, hndlr %x), stopping it\n",
				pTimer, pTimer->pTimerList, pTimer->TimeoutHandler));
		AtmLaneStopTimer(pTimer, pElan);
	}

	ACQUIRE_ELAN_TIMER_LOCK(pElan);
	
	ASSERT(!IS_TIMER_ACTIVE(pTimer));

	//
	//  Find the list to which this timer should go, and the
	//  offset (TicksToGo)
	//
Try_Again:
	for (i = 0; i < ALT_CLASS_MAX; i++)
	{
		pTimerList = &(pElan->TimerList[i]);
		if (SecondsToGo <= pTimerList->MaxTimer)
		{
			//
			//  Found it.
			//
			TicksToGo = SecondsToGo / (pTimerList->TimerPeriod);
			if (TicksToGo >= 1)
				TicksToGo--;
			break;
		}
	}
	
	if (i == ALT_CLASS_MAX)
	{
		//
		//  Force this timer down!
		//
		SecondsToGo = pTimerList->MaxTimer;
		goto Try_Again;
	}


	//
	//  Find the position in the list for this timer
	//
	Index = pTimerList->CurrentTick + TicksToGo;
	if (Index >= pTimerList->TimerListSize)
	{
		Index -= pTimerList->TimerListSize;
	}
	ASSERT(Index < pTimerList->TimerListSize);

	pTimerListHead = &(pTimerList->pTimers[Index]);

	//
	//  Fill in the timer
	//
	pTimer->pTimerList = pTimerList;
	pTimer->LastRefreshTime = pTimerList->CurrentTick;
	pTimer->Duration = TicksToGo;
	pTimer->TimeoutHandler = TimeoutHandler;
	pTimer->ContextPtr = ContextPtr;
 
 	//
 	//  Insert this timer in the "ticking" list
 	//
 	pTimer->pPrevTimer = pTimerListHead;
 	pTimer->pNextTimer = pTimerListHead->pNextTimer;
 	if (pTimer->pNextTimer != NULL_PATMLANE_TIMER)
 	{
 		pTimer->pNextTimer->pPrevTimer = pTimer;
 	}
 	pTimerListHead->pNextTimer = pTimer;

	//
	//  Start off the system tick timer if necessary.
	//
	pTimerList->TimerCount++;
	if (pTimerList->TimerCount == 1)
	{
		DBGP((5,
			"StartTimer: Starting system timer %x, class %d on Elan %x\n",
					&(pTimerList->NdisTimer), i, pElan));

		START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
	}

	RELEASE_ELAN_TIMER_LOCK(pElan);

	//
	//  We're done
	//
	DBGP((5,
		"Started timer %x, Elan %x, Secs %d, Index %d, Head %x\n",
				pTimer,
				pElan,
				SecondsToGo,
				Index,
				pTimerListHead));

	TRACEOUT(StartTimer);

	return;
}


BOOLEAN
AtmLaneStopTimer(
	IN	PATMLANE_TIMER			pTimer,
	IN	PATMLANE_ELAN			pElan
)
/*++

Routine Description:

	Stop an ATMLANE timer, if it is running. We remove this timer from
	the active timer list and mark it so that we know it's not running.

	NOTE: the caller is assumed to either hold a lock to the structure
	that contains the timer, or ensure that it is safe to access the
	timer structure.

	SIDE EFFECT: If we happen to stop the last timer (of this "duration") on
	the Interface, we also stop the appropriate Tick function.

Arguments:

	pTimer			- Pointer to ATMLANE Timer structure
	pElan			- Pointer to interface to which the timer belongs

Return Value:

	TRUE if the timer was running, FALSE otherwise.

--*/
{
	PATMLANE_TIMER_LIST	pTimerList;			// Timer List to which this timer belongs
	BOOLEAN				WasRunning;

	TRACEIN(StopTimer);

	DBGP((5,
		"Stopping Timer %x, Elan %x, List %x, Prev %x, Next %x\n",
					pTimer,
					pElan,
					pTimer->pTimerList,
					pTimer->pPrevTimer,
					pTimer->pNextTimer));

	ACQUIRE_ELAN_TIMER_LOCK(pElan);

	if (IS_TIMER_ACTIVE(pTimer))
	{
		WasRunning = TRUE;

		//
		//  Unlink timer from the list
		//
		ASSERT(pTimer->pPrevTimer);	// the list head always exists

		pTimer->pPrevTimer->pNextTimer = pTimer->pNextTimer;
		if (pTimer->pNextTimer)
		{
			pTimer->pNextTimer->pPrevTimer = pTimer->pPrevTimer;
		}

		pTimer->pNextTimer = pTimer->pPrevTimer = NULL_PATMLANE_TIMER;

		//
		//  Update timer count on Interface, for this class of timers
		//
		pTimerList = pTimer->pTimerList;
		pTimerList->TimerCount--;

		//
		//  If all timers of this class are gone, stop the system tick timer
		//  for this class
		//
		if (pTimerList->TimerCount == 0)
		{
		DBGP((5,
			"Stopping system timer %x, List %x, Elan %x\n",
						&(pTimerList->NdisTimer),
						pTimerList,
						pElan));

			pTimerList->CurrentTick = 0;
			STOP_SYSTEM_TIMER(&(pTimerList->NdisTimer));
		}

		//
		//  Mark stopped timer as not active
		//
		pTimer->pTimerList = (PATMLANE_TIMER_LIST)NULL;

	}
	else
	{
		WasRunning = FALSE;
	}

	RELEASE_ELAN_TIMER_LOCK(pElan);

	TRACEOUT(StopTimer);

	return (WasRunning);
}




VOID
AtmLaneRefreshTimer(
	IN	PATMLANE_TIMER				pTimer
)
/*++

Routine Description:

	Refresh a timer that is already running.

	NOTE: The caller is assumed to possess a lock protecting the
	timer structure (i.e. to the structure containing the timer).

	NOTE: We don't acquire the IF Timer Lock here, to optimize
	the refresh operation. So, _within_ the confines of this routine,
	the tick handler may fire, and expire this timer. The only care
	that we take here is to make sure that we don't crash if the
	timer expires while we access the Timer list.

Arguments:

	pTimer		- Pointer to ATMLANE_TIMER structure

Return Value:

	None

--*/
{
	PATMLANE_TIMER_LIST	pTimerList;

	TRACEIN(RefreshTimer);

	if ((pTimerList = pTimer->pTimerList) != (PATMLANE_TIMER_LIST)NULL)
	{
		pTimer->LastRefreshTime = pTimerList->CurrentTick;
	}
	else
	{
		DBGP((5,
			"RefreshTimer: pTimer %x not active: Hnd %x, Ctxtp %x\n",
			 	pTimer,
			 	pTimer->TimeoutHandler,
			 	pTimer->ContextPtr
			 ));
	}

	DBGP((5,
		"Refreshed timer %x, List %x, hnd %x, Ctxtp %x, LastRefresh %d\n",
				pTimer,
				pTimer->pTimerList,
				pTimer->TimeoutHandler,
				pTimer->ContextPtr,
				pTimer->LastRefreshTime));

	TRACEOUT(RefreshTimer);

	return;
}


VOID
AtmLaneTickHandler(
	IN	PVOID						SystemSpecific1,
	IN	PVOID						Context,
	IN	PVOID						SystemSpecific2,
	IN	PVOID						SystemSpecific3
)
/*++

Routine Description:

	This is the handler we register with the system for processing each
	Timer List. This is called every "tick" seconds, where "tick" is
	determined by the granularity of the timer type.

Arguments:

	Context				- Actually a pointer to a Timer List structure
	SystemSpecific[1-3]	- Not used

Return Value:

	None

--*/
{

	PATMLANE_ELAN			pElan;
	PATMLANE_TIMER_LIST		pTimerList;

	PATMLANE_TIMER			pExpiredTimer;		// Start of list of expired timers
	PATMLANE_TIMER			pNextTimer;			// for walking above list
	PATMLANE_TIMER			pTimer;				// temp, for walking timer list
	PATMLANE_TIMER			pPrevExpiredTimer;	// for creating expired timer list

	ULONG					Index;				// into the timer wheel
	ULONG					NewIndex;			// for refreshed timers

	TRACEIN(TickHandler);

	pTimerList = (PATMLANE_TIMER_LIST)Context;
	STRUCT_ASSERT(pTimerList, atmlane_timerlist);

	pElan = (PATMLANE_ELAN)pTimerList->ListContext;
	STRUCT_ASSERT(pElan, atmlane_elan);

	DBGP((5,
		"Tick: pElan %x, List %x, Count %d\n",
		pElan, pTimerList, pTimerList->TimerCount));

	pExpiredTimer = NULL_PATMLANE_TIMER;

	ACQUIRE_ELAN_TIMER_LOCK(pElan);

	if (ELAN_STATE_OPERATIONAL == pElan->AdminState)
	{
		//
		//  Pick up the list of timers scheduled to have expired at the
		//  current tick. Some of these might have been refreshed.
		//
		Index = pTimerList->CurrentTick;
		pExpiredTimer = (pTimerList->pTimers[Index]).pNextTimer;
		(pTimerList->pTimers[Index]).pNextTimer = NULL_PATMLANE_TIMER;

		//
		//  Go through the list of timers scheduled to expire at this tick.
		//  Prepare a list of expired timers, using the pNextExpiredTimer
		//  link to chain them together.
		//
		//  Some timers may have been refreshed, in which case we reinsert
		//  them in the active timer list.
		//
		pPrevExpiredTimer = NULL_PATMLANE_TIMER;

		for (pTimer = pExpiredTimer;
		 	pTimer != NULL_PATMLANE_TIMER;
		 	pTimer = pNextTimer)
		{
			//
			// Save a pointer to the next timer, for the next iteration.
			//
			pNextTimer = pTimer->pNextTimer;

			DBGP((5,
				"Tick Handler: pElan %x, looking at timer %x, next %x\n",
					pElan, pTimer, pNextTimer));

			//
			//  Find out when this timer should actually expire.
			//
			NewIndex = pTimer->LastRefreshTime + pTimer->Duration;
			if (NewIndex >= pTimerList->TimerListSize)
			{
				NewIndex -= pTimerList->TimerListSize;
			}

			//
			//  Check if we are currently at the point of expiry.
			//
			if (NewIndex != Index)
			{
				//
				//  This timer still has some way to go, so put it back.
				//
				DBGP((5,
				"Tick: Reinserting Timer %x: Hnd %x, Durn %d, Ind %d, NewInd %d\n",
					pTimer, pTimer->TimeoutHandler, pTimer->Duration, Index, NewIndex));

				//
				//  Remove it from the expired timer list. Note that we only
				//  need to update the forward (pNextExpiredTimer) links.
				//
				if (pPrevExpiredTimer == NULL_PATMLANE_TIMER)
				{
					pExpiredTimer = pNextTimer;
				}
				else
				{
					pPrevExpiredTimer->pNextExpiredTimer = pNextTimer;
				}

				//
				//  And insert it back into the running timer list.
				//
				pTimer->pNextTimer = (pTimerList->pTimers[NewIndex]).pNextTimer;
				if (pTimer->pNextTimer != NULL_PATMLANE_TIMER)
				{
					pTimer->pNextTimer->pPrevTimer = pTimer;
				}
				pTimer->pPrevTimer = &(pTimerList->pTimers[NewIndex]);
				(pTimerList->pTimers[NewIndex]).pNextTimer = pTimer;
			}
			else
			{
				//
				//  This one has expired. Keep it in the expired timer list.
				//
				pTimer->pNextExpiredTimer = pNextTimer;
				if (pPrevExpiredTimer == NULL_PATMLANE_TIMER)
				{
					pExpiredTimer = pTimer;
				}
				pPrevExpiredTimer = pTimer;

				//
				//  Mark it as inactive.
				//
				ASSERT(pTimer->pTimerList == pTimerList);
				pTimer->pTimerList = (PATMLANE_TIMER_LIST)NULL;

				//
				//  Update the active timer count.
				//
				pTimerList->TimerCount--;
			}
		}

		//
		//  Update current tick index in readiness for the next tick.
		//
		if (++Index == pTimerList->TimerListSize)
		{
			pTimerList->CurrentTick = 0;
		}
		else
		{
			pTimerList->CurrentTick = Index;
		}

		if (pTimerList->TimerCount > 0)
		{
			//
			//  Re-arm the tick handler
			//
			DBGP((5,
				"Tick[%d]: Starting system timer %x, on Elan %x\n",
						pTimerList->CurrentTick, &(pTimerList->NdisTimer), pElan));
			
			START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
		}
		else
		{
			pTimerList->CurrentTick = 0;
		}

	}

	RELEASE_ELAN_TIMER_LOCK(pElan);

	//
	//  Now pExpiredTimer is a list of expired timers.
	//  Walk through the list and call the timeout handlers
	//  for each timer.
	//
	while (pExpiredTimer != NULL_PATMLANE_TIMER)
	{
		pNextTimer = pExpiredTimer->pNextExpiredTimer;

		DBGP((5,
			"Expired timer %x: handler %x, next %x\n",
					pExpiredTimer, pExpiredTimer->TimeoutHandler, pNextTimer));

		(*(pExpiredTimer->TimeoutHandler))(
				pExpiredTimer,
				pExpiredTimer->ContextPtr
			);

		pExpiredTimer = pNextTimer;
	}


	TRACEOUT(TickHandler);

	return;
}

ULONG
AtmLaneSystemTimeMs(void)
/*++

Routine Description:

	This routine get the current system clock tick value and
	returns this value converted to milliseconds.
	
Arguments:

	None
	
Return Value:

	The system clock value in milliseconds.

--*/
{
#if BINARY_COMPATIBLE
    LARGE_INTEGER SystemTime;

    NdisGetCurrentSystemTime(&SystemTime);
    
    // comes back in 100 nanosecond units, we want milliseconds

	SystemTime.QuadPart /= 10000;
    
    return SystemTime.LowPart;
#else
	static LARGE_INTEGER Frequency = {0L,0L};
    LARGE_INTEGER SystemTime;

	SystemTime = KeQueryPerformanceCounter(Frequency.LowPart == 0?&Frequency:NULL);

	SystemTime.QuadPart = SystemTime.QuadPart * 1000000 / Frequency.QuadPart;

    return SystemTime.LowPart;
#endif
}


VOID
AtmLaneBitSwapMacAddr(
	IN OUT	PUCHAR		ap
)
/*++

Routine Description:

	This routine swaps (reverses) the bits in each individual
	byte of a MAC Address.  Use for Token Ring MAC addresses.
	
Arguments:

	ap		-	Pointer to array of bytes to bitswap in-place.
	
Return Value:

	None
	
--*/
{
	int 			i;
	unsigned int 	x;

    for (i = 0; i != 6; i++) 
    {
		x = ap[i];
		x = ((x & 0xaau) >> 1) | ((x & 0x55u) << 1);
		x = ((x & 0xccu) >> 2) | ((x & 0x33u) << 2);
		x = ((x & 0xf0u) >> 4) | ((x & 0x0fu) << 4);
		ap[i] = (UCHAR)x;
    }
}

BOOLEAN
AtmLaneCopyUnicodeString(
	IN OUT	PUNICODE_STRING pDestString,
	IN OUT	PUNICODE_STRING pSrcString,
	IN		BOOLEAN			AllocDest,
	IN		BOOLEAN			ConvertToUpper
)
{
/*++

Routine Description:

	This routine optionally allocates space in the destination string
	for the source string plus a terminating null.  It
	copies the source string to the destination string and 
	terminates the destination string with a null.
	
-*/
	BOOLEAN Result 		= TRUE;

	TRACEIN(CopyUnicodeString);

	do
	{
		//	Alloc space for the destination string if requested

		if (AllocDest)
		{
			ALLOC_MEM(&(pDestString->Buffer), pSrcString->Length + sizeof(WCHAR));
			if (NULL == pDestString->Buffer)
			{
				Result = FALSE;
				break;
			}

			//	Init lengths in dest string

			pDestString->Length = 0;
			pDestString->MaximumLength = pSrcString->Length + sizeof(WCHAR);
		}
		
		//	Copy the string

		if (ConvertToUpper)
		{
#ifndef LANE_WIN98
			(VOID)NdisUpcaseUnicodeString(pDestString, pSrcString);
#else
			memcpy(pDestString->Buffer, pSrcString->Buffer, pSrcString->Length);
#endif // LANE_WIN98
		}
		else
		{
			RtlCopyUnicodeString(pDestString, pSrcString);
		}

		//	Null terminate the dest string

		if (pDestString->Length < pDestString->MaximumLength)
		{
			pDestString->Buffer[pDestString->Length/sizeof(WCHAR)] = ((WCHAR)0);
		}
		else
		{
			pDestString->Buffer[(pDestString->MaximumLength - sizeof(WCHAR))/sizeof(WCHAR)] =
				((WCHAR)0);
		}
	
	} while (FALSE);

	TRACEOUT(CopyUnicodeString);
	return Result;
}

PWSTR
AtmLaneStrTok(
	IN	PWSTR	StrToken,
	IN	WCHAR	ChrDelim,
	OUT	PUSHORT	pStrLength
)
{
	static PWSTR 	StrSave = NULL;
	USHORT			StrLength = 0;	
	PWSTR 			StrOut = NULL;

	TRACEIN(StrTok);
	do
	{
		//	check for bad input
	
		if ((StrToken == NULL && StrSave == NULL) ||
			ChrDelim == ((WCHAR)0))
		{
			break;
		}

		//	if starting with new string, reset StrSave

		if (StrToken != NULL)
		{
			StrSave = StrToken;
		}

		//	token starts at start of current string

		StrOut = StrSave;

		//	walk string until delimiter or NULL
		
		while (*StrSave != ChrDelim && *StrSave != ((WCHAR)0))
		{
			StrSave++;
			StrLength++;
		}

		//	If we found a delimiter then NULL it out and
		//	move saved ptr to next token to setup for next 
		//	call on same string.  
		
		if (*StrSave == ChrDelim)
		{
			*StrSave = ((WCHAR)0);
			StrSave++;
		}

		//	If pointing at empty string then return null ptr
	
		if (*StrOut == ((WCHAR)0))
		{
			StrOut = NULL;
		}
		
	} while (FALSE);

	TRACEOUT(StrTok);
	*pStrLength = StrLength * sizeof(WCHAR);
	return StrOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\externs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\externs.h

Abstract:

	All external declarations for Null Transport (functions, globals)
	are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/


#ifndef __TDI_RWAN_EXTERNS__H
#define __TDI_RWAN_EXTERNS__H


#ifndef EXTERN
#define EXTERN	extern
#endif // EXTERN

//
//  ---- From space.c
//
EXTERN ULONG							RWanMaxTdiConnections;

EXTERN RWAN_STATUS						RWanAtmSpInitialize(VOID);
EXTERN VOID								RWanAtmSpShutdown(VOID);

EXTERN NDIS_HANDLE						RWanCopyBufferPool;
EXTERN NDIS_HANDLE						RWanCopyPacketPool;
EXTERN NDIS_HANDLE						RWanSendPacketPool;

EXTERN RWAN_GLOBALS						RWanGlobals;
EXTERN PRWAN_GLOBALS						pRWanGlobal;

EXTERN NDIS_PROTOCOL_CHARACTERISTICS	RWanNdisProtocolCharacteristics;
EXTERN NDIS_CLIENT_CHARACTERISTICS		RWanNdisClientCharacteristics;

EXTERN RWAN_AFSP_MODULE_CHARS			RWanMediaSpecificInfo[];


//
//  ---- From addr.c
//

EXTERN
TDI_STATUS
RWanTdiOpenAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
    IN	ULONG						AddrListLength,
    IN	UINT						Protocol,
    IN	PUCHAR						pOptions
    );

EXTERN
TDI_STATUS
RWanTdiSetEvent(
	IN	PVOID						AddrObjContext,
	IN	INT							TdiEventType,
	IN	PVOID						Handler,
	IN	PVOID						HandlerContext
	);

EXTERN
TDI_STATUS
RWanTdiCloseAddress(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanCreateNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	);

EXTERN
VOID
RWanNdisRegisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					OurSapContext,
	IN	PCO_SAP						pCoSap,
	IN	NDIS_HANDLE					NdisSapHandle
	);

EXTERN
VOID
RWanDeleteNdisSaps(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	);

EXTERN
VOID
RWanNdisDeregisterSapComplete(
	IN	NDIS_STATUS					NdisStatus,
	IN	NDIS_HANDLE					ProtocolSapContext
	);


//
//  ---- From info.c
//
EXTERN
TDI_STATUS
RWanTdiQueryInformation(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	UINT						QueryType,
    IN	PNDIS_BUFFER				pNdisBuffer,
    IN	PUINT						pBufferSize,
    IN	UINT						IsConnection
    );

EXTERN
RWAN_STATUS
RWanHandleGenericConnQryInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    );

EXTERN
RWAN_STATUS
RWanHandleGenericAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanHandleMediaSpecificAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanHandleMediaSpecificConnQryInfo(
    IN	HANDLE						ConnectionContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    );

EXTERN
PNDIS_BUFFER
RWanCopyFlatToNdis(
    IN	PNDIS_BUFFER				pDestBuffer,
    IN	PUCHAR						pSrcBuffer,
    IN	UINT						LengthToCopy,
    IN OUT	PUINT					pStartOffset,
    OUT	PUINT						pBytesCopied
    );


//
//  ---- From mediasp.c
//
RWAN_STATUS
RWanInitMediaSpecific(
	VOID
	);

EXTERN
VOID
RWanShutdownMediaSpecific(
	VOID
	);


//
//  ---- From ndisbind.c
//
VOID
RWanNdisBindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
	);

EXTERN
VOID
RWanNdisUnbindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
	);

EXTERN
VOID
RWanNdisOpenAdapterComplete(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
	);

EXTERN
VOID
RWanNdisCloseAdapterComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
	);

EXTERN
VOID
RWanNdisAfRegisterNotify(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
	);

EXTERN
VOID
RWanNdisOpenAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
	);

EXTERN
VOID
RWanShutdownAf(
	IN	PRWAN_NDIS_AF				pAf
	);

EXTERN
VOID
RWanNdisCloseAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext
	);

EXTERN
PNDIS_MEDIUM
RWanGetSupportedMedia(
	IN	PULONG						pMediaCount
	);

EXTERN
VOID
RWanCloseAdapter(
	IN	PRWAN_NDIS_ADAPTER			pAdapter
	);

EXTERN
VOID
RWanNdisRequestComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
	);

EXTERN
VOID
RWanNdisStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	);

EXTERN
VOID
RWanNdisCoStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	);

EXTERN
VOID
RWanNdisStatusComplete(
	IN	NDIS_HANDLE					OurBindingContext
	);

EXTERN
NDIS_STATUS
RWanNdisCoRequest(
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
	);

EXTERN
VOID
RWanNdisCoRequestComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
	);

EXTERN
NDIS_STATUS
RWanNdisReset(
	IN	NDIS_HANDLE					OurBindingContext
	);

EXTERN
VOID
RWanNdisResetComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					Status
	);

EXTERN
NDIS_STATUS
RWanNdisPnPEvent(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPSetPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPQueryPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPQueryRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);

EXTERN
NDIS_STATUS
RWanNdisPnPCancelRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	);


//
//  ---- From ndisconn.c
//
NDIS_STATUS
RWanNdisCreateVc(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
	);

EXTERN
NDIS_STATUS
RWanNdisDeleteVc(
	IN	NDIS_HANDLE					ProtocolVcContext
	);

EXTERN
VOID
RWanNdisMakeCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
VOID
RWanNdisAddPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
NDIS_STATUS
RWanNdisIncomingCall(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS		pCallParameters
	);

EXTERN
VOID
RWanNdisCallConnected(
	IN	NDIS_HANDLE					ProtocolVcContext
	);

EXTERN
VOID
RWanNdisIncomingCloseCall(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData,
	IN	UINT						CloseDataLength
	);

EXTERN
VOID
RWanNdisCloseCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext
	);

EXTERN
VOID
RWanNdisDropPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
	);

EXTERN
VOID
RWanNdisIncomingDropParty(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurPartyContext,
	IN	PVOID						pBuffer,
	IN	UINT						BufferLength
	);

EXTERN
VOID
RWanNdisModifyQoSComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
VOID
RWanNdisRejectIncomingCall(
	IN	PRWAN_TDI_CONNECTION			pConnObject,
	IN	NDIS_STATUS					RejectStatus
	);

EXTERN
VOID
RWanStartCloseCall(
	IN	PRWAN_TDI_CONNECTION			pConnObject,
	IN	PRWAN_NDIS_VC				pVc
	);

EXTERN
VOID
RWanUnlinkVcFromAf(
	IN	PRWAN_NDIS_VC				pVc
	);

EXTERN
VOID
RWanCompleteConnReq(
	IN	PRWAN_NDIS_AF				pAf,
	IN	PRWAN_CONN_REQUEST			pConnReq,
	IN	BOOLEAN						IsOutgoingCall,
	IN	PCO_CALL_PARAMETERS			pCallParameters	OPTIONAL,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	TDI_STATUS					TdiStatus
	);


//
//  ---- From ntentry.c
//
NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
	);

EXTERN
VOID
RWanUnload(
	IN	PDRIVER_OBJECT				pDriverObject
	);

EXTERN
VOID
RWanUnloadProtocol(
	VOID
	);

EXTERN
NTSTATUS
RWanDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	);

EXTERN
NTSTATUS
RWanCreate(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanCleanup(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanClose(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanDispatchInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	);

EXTERN
NTSTATUS
RWanDispatchPrivateDeviceControl(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	);

EXTERN
FILE_FULL_EA_INFORMATION UNALIGNED *
RWanFindEa(
	IN	FILE_FULL_EA_INFORMATION *	pStartEa,
	IN	CHAR *						pTargetName,
	IN	USHORT						TargetNameLength
	);

EXTERN
NTSTATUS
RWanSendData(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanReceiveData(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanAssociateAddress(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanDisassociateAddress(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanConnect(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanDisconnect(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanListen(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanAccept(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanSetEventHandler(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
NTSTATUS
RWanQueryInformation(
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	);

EXTERN
VOID
RWanCloseObjectComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	);

EXTERN
VOID
RWanDataRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				ByteCount
	);

EXTERN
VOID
RWanRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	);

EXTERN
VOID
RWanNonCancellableRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	);

EXTERN
VOID
RWanCancelComplete(
	IN	PVOID				Context,
	IN	UINT				Unused1,
	IN	UINT				Unused2
	);

EXTERN
VOID
RWanCancelRequest(
	IN	PDEVICE_OBJECT		pDeviceObject,
	IN	PIRP				pIrp
	);

EXTERN
NTSTATUS
RWanPrepareIrpForCancel(
	IN	PRWAN_ENDPOINT		pEndpoint,
	IN	PIRP				pIrp,
	IN	PDRIVER_CANCEL		pCancelRoutine
	);

EXTERN
ULONG
RWanGetMdlChainLength(
	IN	PMDL				pMdl
	);

EXTERN
NTSTATUS
RWanToNTStatus(
	IN	RWAN_STATUS			RWanStatus
	);

//
//  ---- From receive.c
//
RWAN_STATUS
RWanInitReceive(
	VOID
	);

EXTERN
VOID
RWanShutdownReceive(
	VOID
	);

EXTERN
TDI_STATUS
RWanTdiReceive(
    IN	PTDI_REQUEST				pTdiRequest,
	OUT	PUSHORT						pFlags,
	IN	PUINT						pReceiveLength,
	IN	PNDIS_BUFFER				pNdisBuffer
	);

EXTERN
UINT
RWanNdisCoReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    );

EXTERN
VOID
RWanIndicateData(
    IN	PRWAN_TDI_CONNECTION			pConnObject
    );

EXTERN
VOID
RWanNdisReceiveComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext
	);

EXTERN
VOID
RWanNdisTransferDataComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket,
    IN	NDIS_STATUS					Status,
    IN	UINT						BytesTransferred
    );

EXTERN
NDIS_STATUS
RWanNdisReceive(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					MacReceiveContext,
    IN	PVOID						HeaderBuffer,
    IN	UINT						HeaderBufferSize,
    IN	PVOID						pLookAheadBuffer,
    IN	UINT						LookAheadBufferSize,
    IN	UINT						PacketSize
    );

EXTERN
INT
RWanNdisReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket
    );

EXTERN
PRWAN_RECEIVE_REQUEST
RWanAllocateReceiveReq(
	VOID
	);

EXTERN
VOID
RWanFreeReceiveReq(
    IN	PRWAN_RECEIVE_REQUEST		pRcvReq
   	);

EXTERN
PRWAN_RECEIVE_INDICATION
RWanAllocateReceiveInd(
	VOID
	);

EXTERN
VOID
RWanFreeReceiveInd(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	);

EXTERN
PNDIS_PACKET
RWanMakeReceiveCopy(
    IN	PNDIS_PACKET				pNdisPacket
	);

EXTERN
VOID
RWanFreeReceiveCopy(
    IN	PNDIS_PACKET				pCopyPacket
	);

EXTERN
VOID
RWanFreeReceiveIndList(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	);

//
//  ---- From send.c
//
RWAN_STATUS
RWanInitSend(
	VOID
	);

EXTERN
VOID
RWanShutdownSend(
	VOID
	);

EXTERN
TDI_STATUS
RWanTdiSendData(
    IN	PTDI_REQUEST				pTdiRequest,
	IN	USHORT						SendFlags,
	IN	UINT						SendLength,
	IN	PNDIS_BUFFER				pSendBuffer
	);

EXTERN
VOID
RWanNdisCoSendComplete(
    IN	NDIS_STATUS					NdisStatus,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    );

EXTERN
PNDIS_PACKET
RWanAllocateSendPacket(
	VOID
	);

EXTERN
VOID
RWanFreeSendPacket(
    IN	PNDIS_PACKET				pSendPacket
    );

EXTERN
VOID
RWanNdisSendComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
	);


//
//  ---- From tdiconn.c
//
TDI_STATUS
RWanTdiOpenConnection(
    IN OUT	PTDI_REQUEST			pTdiRequest,
    IN		PVOID					ConnectionHandle
    );

#if DBG

PVOID
RWanTdiDbgGetConnObject(
	IN	HANDLE						ConnectionContext
	);
#endif

EXTERN
TDI_STATUS
RWanTdiCloseConnection(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanTdiAssociateAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						AddressContext
    );

EXTERN
TDI_STATUS
RWanTdiDisassociateAddress(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanTdiConnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout 		OPTIONAL,
    IN	PTDI_CONNECTION_INFORMATION	pRequestInfo,
    IN	PTDI_CONNECTION_INFORMATION	pReturnInfo
    );

EXTERN
TDI_STATUS
RWanTdiPMPConnect(
	IN	PRWAN_NDIS_AF_INFO			pAfInfo,
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_CONNECTION		pConnObject,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						CallFlags,
	IN	PRWAN_CONN_REQUEST			pConnReq
	);

EXTERN
TDI_STATUS
RWanTdiListen(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptableAddr,
    IN	PTDI_CONNECTION_INFORMATION	pConnectedAddr
    );

EXTERN
TDI_STATUS
RWanTdiUnListen(
    IN	PTDI_REQUEST				pTdiRequest
    );

EXTERN
TDI_STATUS
RWanTdiAccept(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptInfo,
    IN	PTDI_CONNECTION_INFORMATION	pConnectInfo
    );

EXTERN
TDI_STATUS
RWanTdiDisconnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo
    );

EXTERN
TDI_STATUS
RWanDoTdiDisconnect(
    IN	PRWAN_TDI_CONNECTION		pConnObject,
    IN	PTDI_REQUEST				pTdiRequest		OPTIONAL,
    IN	PVOID						pTimeout		OPTIONAL,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo	OPTIONAL,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo		OPTIONAL
	);

EXTERN
RWAN_CONN_ID
RWanGetConnId(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
PRWAN_TDI_CONNECTION
RWanGetConnFromId(
	IN	RWAN_CONN_ID					ConnId
	);

EXTERN
VOID
RWanFreeConnId(
	IN	RWAN_CONN_ID					ConnId
	);

EXTERN
TDI_STATUS
RWanToTdiStatus(
	IN	RWAN_STATUS					RWanStatus
	);

EXTERN
PRWAN_CONN_REQUEST
RWanAllocateConnReq(
	VOID
	);

EXTERN
VOID
RWanFreeConnReq(
	IN	PRWAN_CONN_REQUEST			pConnReq
	);

EXTERN
VOID
RWanAbortConnection(
	IN	CONNECTION_CONTEXT			ConnectionContext
	);

EXTERN
VOID
RWanDoAbortConnection(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
VOID
RWanScheduleDisconnect(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
VOID
RWanDelayedDisconnectHandler(
	IN	PNDIS_WORK_ITEM					pCloseWorkItem,
	IN	PVOID							Context
	);

//
//  ---- From utils.c
//
RWAN_STATUS
RWanInitGlobals(
	IN	PDRIVER_OBJECT				pDriverObject
	);

EXTERN
VOID
RWanDeinitGlobals(
	VOID
	);

EXTERN
PRWAN_TDI_PROTOCOL
RWanGetProtocolFromNumber(
	IN	UINT						Protocol
	);

EXTERN
TA_ADDRESS *
RWanGetValidAddressFromList(
	IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	);

EXTERN
PRWAN_TDI_CONNECTION
RWanAllocateConnObject(
	VOID
	);

EXTERN
VOID
RWanReferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
INT
RWanDereferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	);

EXTERN
PRWAN_TDI_ADDRESS
RWanAllocateAddressObject(
	IN	TA_ADDRESS *		            pTransportAddress
	);

EXTERN
VOID
RWanReferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	);

EXTERN
INT
RWanDereferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	);

EXTERN
PRWAN_NDIS_AF
RWanAllocateAf(
	VOID
	);

EXTERN
VOID
RWanReferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	);

EXTERN
INT
RWanDereferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	);

#if 0

EXTERN
VOID
RWanReferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	);

EXTERN
INT
RWanDereferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	);

#endif // 0

EXTERN
TDI_STATUS
RWanNdisToTdiStatus(
	IN	NDIS_STATUS				Status
	);


//
//  ---- vc.c
//
PRWAN_NDIS_VC
RWanAllocateVc(
	IN	PRWAN_NDIS_AF				pAf,
	IN	BOOLEAN						IsOutgoing
	);

EXTERN
VOID
RWanFreeVc(
	IN	PRWAN_NDIS_VC				pVc
	);


#endif // __TDI_RWAN_EXTERNS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\macros.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\core\macros.h

Abstract:

	Macros for the NullTrans module. Adapted from ATMARP Client.

Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     05-07-97    created

Notes:


--*/
#ifndef __RWAN_MACROS_H_INCLUDED
#define __RWAN_MACROS_H_INCLUDED



#ifndef MAX

/*++
OPAQUE
MAX(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MAX(Fred, Shred)		(((Fred) > (Shred)) ? (Fred) : (Shred))

#endif // MAX


#ifndef MIN

/*++
OPAQUE
MIN(
	IN	OPAQUE		Fred,
	IN	OPAQUE		Shred
)
--*/
#define MIN(Fred, Shred)		(((Fred) < (Shred)) ? (Fred) : (Shred))

#endif // MIN



/*++
VOID
RWAN_SET_FLAG(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define RWAN_SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)


/*++
BOOLEAN
RWAN_IS_FLAG_SET(
	IN	ULONG		Flags,
	IN	ULONG		Mask,
	IN	ULONG		Val
)
--*/
#define RWAN_IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))


#define RWAN_SET_BIT(_Flags, _Bit)			\
			(_Flags) = (_Flags) | (_Bit);

#define RWAN_RESET_BIT(_Flags, _Bit)			\
			(_Flags) &= ~(_Bit);

#define RWAN_IS_BIT_SET(_Flags, _Bit)		\
			(((_Flags) & (_Bit)) != 0)


/*++
VOID
RWAN_INIT_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent
)
--*/
#define RWAN_INIT_EVENT_STRUCT(pEvent)		NdisInitializeEvent(&((pEvent)->Event))


/*++
NDIS_STATUS
RWAN_WAIT_ON_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent
)
--*/
#define RWAN_WAIT_ON_EVENT_STRUCT(pEvent)		\
			(NdisWaitEvent(&((pEvent)->Event), 0), (pEvent)->Status)


/*++
VOID
RWAN_SIGNAL_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent,
	IN	UINT			Status
)
--*/
#define RWAN_SIGNAL_EVENT_STRUCT(pEvent, _Status)	\
			{ (pEvent)->Status = _Status; NdisSetEvent(&((pEvent)->Event)); }


/*++
VOID
RWAN_FREE_EVENT_STRUCT(
	IN	RWAN_EVENT	*pEvent
)
--*/
#define RWAN_FREE_EVENT_STRUCT(pEvent)		// Nothing to be done here


/*++
VOID
RWAN_INIT_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_INIT_LOCK(pLock)	\
				RWanAllocateSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_INIT_LOCK(pLock)	\
				NdisAllocateSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_ACQUIRE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_ACQUIRE_LOCK(pLock)	\
				RWanAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_ACQUIRE_LOCK(pLock)	\
				NdisAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_ACQUIRE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_ACQUIRE_LOCK_DPC(pLock)	\
				RWanAcquireSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_ACQUIRE_LOCK_DPC(pLock)	\
				NdisDprAcquireSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_RELEASE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_RELEASE_LOCK(pLock)		\
				RWanReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_RELEASE_LOCK(pLock)		\
				NdisReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_RELEASE_LOCK_DPC(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#if DBG_SPIN_LOCK
#define RWAN_RELEASE_LOCK_DPC(pLock)		\
				RWanReleaseSpinLock(pLock, _FILENUMBER, __LINE__)
#else
#define RWAN_RELEASE_LOCK_DPC(pLock)		\
				NdisDprReleaseSpinLock(pLock)
#endif // DBG_SPIN_LOCK


/*++
VOID
RWAN_FREE_LOCK(
	IN	PNDIS_SPIN_LOCK		pLock
)
--*/
#define RWAN_FREE_LOCK(pLock)			\
				NdisFreeSpinLock(pLock)


//
//  Macros for operating the Global lock:
//
#define RWAN_INIT_GLOBAL_LOCK()		\
				RWAN_INIT_LOCK(&((pRWanGlobal)->GlobalLock))

#define RWAN_ACQUIRE_GLOBAL_LOCK()		\
				RWAN_ACQUIRE_LOCK(&((pRWanGlobal)->GlobalLock))

#define RWAN_RELEASE_GLOBAL_LOCK()		\
				RWAN_RELEASE_LOCK(&((pRWanGlobal)->GlobalLock))

#define RWAN_FREE_GLOBAL_LOCK()		\
				RWAN_FREE_LOCK(&((pRWanGlobal)->GlobalLock))


//
//  Macros for operating the Address List lock:
//
#define RWAN_INIT_ADDRESS_LIST_LOCK()		\
				RWAN_INIT_LOCK(&((pRWanGlobal)->AddressListLock))

#define RWAN_ACQUIRE_ADDRESS_LIST_LOCK()		\
				RWAN_ACQUIRE_LOCK(&((pRWanGlobal)->AddressListLock))

#define RWAN_RELEASE_ADDRESS_LIST_LOCK()		\
				RWAN_RELEASE_LOCK(&((pRWanGlobal)->AddressListLock))

#define RWAN_FREE_ADDRESS_LIST_LOCK()		\
				RWAN_FREE_LOCK(&((pRWanGlobal)->AddressListLock))



//
//  Macros for operating the Connection Table lock:
//
#define RWAN_INIT_CONN_TABLE_LOCK()		\
				RWAN_INIT_LOCK(&((pRWanGlobal)->ConnTableLock))

#define RWAN_ACQUIRE_CONN_TABLE_LOCK()		\
				RWAN_ACQUIRE_LOCK(&((pRWanGlobal)->ConnTableLock))

#define RWAN_RELEASE_CONN_TABLE_LOCK()		\
				RWAN_RELEASE_LOCK(&((pRWanGlobal)->ConnTableLock))

#define RWAN_FREE_CONN_TABLE_LOCK()		\
				RWAN_FREE_LOCK(&((pRWanGlobal)->ConnTableLock))



//
//  Macros for operating Connection object locks:
//
#define RWAN_INIT_CONN_LOCK(pConnObj)	\
				RWAN_INIT_LOCK(&(pConnObj)->Lock)

#define RWAN_ACQUIRE_CONN_LOCK(pConnObj)	\
				RWAN_ACQUIRE_LOCK(&(pConnObj)->Lock)

#define RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObj)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pConnObj)->Lock)

#define RWAN_RELEASE_CONN_LOCK(pConnObj)	\
				RWAN_RELEASE_LOCK(&(pConnObj)->Lock)

#define RWAN_RELEASE_CONN_LOCK_DPC(pConnObj)	\
				RWAN_RELEASE_LOCK_DPC(&(pConnObj)->Lock)

#define RWAN_FREE_CONN_LOCK(pConnObj)	\
				RWAN_FREE_CONN_LOCK(&(pConnObj)->Lock)


//
//  Macros for operating Address object locks:
//
#define RWAN_INIT_ADDRESS_LOCK(pAddrObj)	\
				RWAN_INIT_LOCK(&(pAddrObj)->Lock)

#define RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObj)	\
				RWAN_ACQUIRE_LOCK(&(pAddrObj)->Lock)

#define RWAN_ACQUIRE_ADDRESS_LOCK_DPC(pAddrObj)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pAddrObj)->Lock)

#define RWAN_RELEASE_ADDRESS_LOCK(pAddrObj)	\
				RWAN_RELEASE_LOCK(&(pAddrObj)->Lock)

#define RWAN_RELEASE_ADDRESS_LOCK_DPC(pAddrObj)	\
				RWAN_RELEASE_LOCK_DPC(&(pAddrObj)->Lock)

#define RWAN_FREE_ADDRESS_LOCK(pAddrObj)	\
				RWAN_FREE_ADDRESS_LOCK(&(pAddrObj)->Lock)

//
//  Macros for operating AF locks:
//
#define RWAN_INIT_AF_LOCK(pAfBlk)	\
				RWAN_INIT_LOCK(&(pAfBlk)->Lock)

#define RWAN_ACQUIRE_AF_LOCK(pAfBlk)	\
				RWAN_ACQUIRE_LOCK(&(pAfBlk)->Lock)

#define RWAN_ACQUIRE_AF_LOCK_DPC(pAfBlk)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pAfBlk)->Lock)

#define RWAN_RELEASE_AF_LOCK(pAfBlk)	\
				RWAN_RELEASE_LOCK(&(pAfBlk)->Lock)

#define RWAN_RELEASE_AF_LOCK_DPC(pAfBlk)	\
				RWAN_RELEASE_LOCK_DPC(&(pAfBlk)->Lock)

#define RWAN_FREE_AF_LOCK(pAfBlk)	\
				RWAN_FREE_AF_LOCK(&(pAfBlk)->Lock)


//
//  Macros for operating Adapter locks:
//
#define RWAN_INIT_ADAPTER_LOCK(pAdptr)	\
				RWAN_INIT_LOCK(&(pAdptr)->Lock)

#define RWAN_ACQUIRE_ADAPTER_LOCK(pAdptr)	\
				RWAN_ACQUIRE_LOCK(&(pAdptr)->Lock)

#define RWAN_ACQUIRE_ADAPTER_LOCK_DPC(pAdptr)	\
				RWAN_ACQUIRE_LOCK_DPC(&(pAdptr)->Lock)

#define RWAN_RELEASE_ADAPTER_LOCK(pAdptr)	\
				RWAN_RELEASE_LOCK(&(pAdptr)->Lock)

#define RWAN_RELEASE_ADAPTER_LOCK_DPC(pAdptr)	\
				RWAN_RELEASE_LOCK_DPC(&(pAdptr)->Lock)

#define RWAN_FREE_ADAPTER_LOCK(pAdptr)	\
				RWAN_FREE_ADAPTER_LOCK(&(pAdptr)->Lock)


/*++
VOID
RWAN_ALLOC_MEM(
	IN	POPAQUE		pVar,
	IN	OPAQUE		StructureType,
	IN	ULONG		SizeOfStructure
)
--*/
#if DBG
#define RWAN_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			pVar = (StructureType *)RWanAuditAllocMem(				\
										(PVOID)(&(pVar)),			\
										(ULONG)(SizeOfStructure),	\
										_FILENUMBER,				\
										__LINE__					\
									);
#else
#define RWAN_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			NdisAllocateMemoryWithTag((PVOID *)(&pVar), (ULONG)(SizeOfStructure), (ULONG)'naWR');
#endif // DBG


/*++
VOID
RWAN_FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DBG
#define RWAN_FREE_MEM(pMem)	RWanAuditFreeMem((PVOID)(pMem));
#else
#define RWAN_FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG


/*++
VOID
RWAN_SET_MEM(
	IN	POPAQUE		pMem,
	IN	UCHAR		bValue,
	IN	ULONG		NumberOfBytes
)
--*/
#define RWAN_SET_MEM(pMem, bValue, NumberOfBytes)	\
			RtlFillMemory((PVOID)(pMem), (ULONG)(NumberOfBytes), (UCHAR)(bValue));


/*++
VOID
RWAN_ZERO_MEM(
	IN	POPAQUE		pMem,
	IN	ULONG		NumberOfBytes
)
--*/
#define RWAN_ZERO_MEM(pMem, NumberOfBytes)	\
			RtlZeroMemory((PVOID)pMem, (ULONG)(NumberOfBytes));


/*++
VOID
RWAN_COPY_MEM(
	IN	POPAQUE		pDst,
	IN	POPAQUE		pSrc,
	IN	ULONG		NumberOfBytes
)
--*/
#define RWAN_COPY_MEM(pDst, pSrc, NumberOfBytes)	\
			NdisMoveMemory((PVOID)(pDst), (PVOID)(pSrc), NumberOfBytes);


/*++
BOOLEAN
RWAN_EQUAL_MEM(
	IN	POPAQUE		pMem1,
	IN	POPAQUE		pMem2,
	IN	ULONG		Length
)
--*/
#define RWAN_EQUAL_MEM(_pMem1, _pMem2, _Length)	\
			(RtlCompareMemory((PVOID)(_pMem1), (PVOID)(_pMem2), (ULONG)(_Length)) == (_Length))


/*++
VOID
RWAN_SET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket,
	IN	PNDIS_PACKET		pNextPacket
)
--*/
#define RWAN_SET_NEXT_PACKET(pPkt, pNext)			\
			*((PNDIS_PACKET *)((pPkt)->MiniportReserved)) = (pNext);



/*++
PNDIS_PACKET
RWAN_GET_NEXT_PACKET(
	IN	PNDIS_PACKET		pNdisPacket
)
--*/
#define RWAN_GET_NEXT_PACKET(pPkt)					\
			(*((PNDIS_PACKET *)((pPkt)->MiniportReserved)))



//
//  Doubly linked list manipulation definitions and macros.
//
#define RWAN_INIT_LIST(_pListHead)					\
			InitializeListHead(_pListHead)

#define RWAN_IS_LIST_EMPTY(_pListHead)				\
			IsListEmpty(_pListHead)

#define RWAN_INSERT_HEAD_LIST(_pListHead, _pEntry)	\
			InsertHeadList((_pListHead), (_pEntry))

#define RWAN_INSERT_TAIL_LIST(_pListHead, _pEntry)	\
			InsertTailList((_pListHead), (_pEntry))

#define RWAN_DELETE_FROM_LIST(_pEntry)				\
			RemoveEntryList(_pEntry)


/*++
ULONG
ROUND_UP(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 4.
--*/
#define ROUND_UP(Val)	(((Val) + 3) & ~0x3)



/*++
VOID
RWAN_ADVANCE_RCV_REQ_BUFFER(
	IN	PRWAN_RECEIVE_REQUEST		pRcvReq
)
--*/
#define RWAN_ADVANCE_RCV_REQ_BUFFER(_pRcvReq)											\
	{																					\
		PNDIS_BUFFER	_pNextBuffer;													\
		NdisGetNextBuffer((_pRcvReq)->pBuffer, &(_pNextBuffer));						\
		(_pRcvReq)->pBuffer = _pNextBuffer;												\
		if (_pNextBuffer != NULL)														\
		{																				\
			NdisQueryBuffer(															\
				(_pNextBuffer),															\
				&(_pRcvReq)->pWriteData, 												\
				&(_pRcvReq)->BytesLeftInBuffer											\
				);																		\
																						\
			if (((_pRcvReq)->BytesLeftInBuffer > (_pRcvReq)->AvailableBufferLength))	\
			{																			\
				(_pRcvReq)->BytesLeftInBuffer = (_pRcvReq)->AvailableBufferLength;		\
			}																			\
		}																				\
		else																			\
		{																				\
			(_pRcvReq)->BytesLeftInBuffer = 0;											\
			(_pRcvReq)->pWriteData = NULL;												\
		}																				\
	}


/*++
VOID
RWAN_ADVANCE_RCV_IND_BUFFER(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
)
--*/
#define RWAN_ADVANCE_RCV_IND_BUFFER(_pRcvInd)							\
	{																	\
		PNDIS_BUFFER	_pNextBuffer;									\
		NdisGetNextBuffer((_pRcvInd)->pBuffer, &(_pNextBuffer));		\
		(_pRcvInd)->pBuffer = _pNextBuffer;								\
		if (_pNextBuffer != NULL)										\
		{																\
			NdisQueryBuffer(											\
				(_pNextBuffer),											\
				&(_pRcvInd)->pReadData, 								\
				&(_pRcvInd)->BytesLeftInBuffer							\
				);														\
		}																\
		else															\
		{																\
			(_pRcvInd)->BytesLeftInBuffer = 0;							\
			(_pRcvInd)->pReadData = NULL;								\
		}																\
	}



/*++
VOID
RWAN_SET_DELETE_NOTIFY(
	IN	PRWAN_DELETE_NOTIFY			pNotifyObject,
	IN	PCOMPLETE_RTN				pDeleteRtn,
	IN	PVOID						DeleteContext
)
--*/
#define RWAN_SET_DELETE_NOTIFY(_pNotifyObj, _pDeleteRtn, _DeleteContext)	\
	{																	\
		(_pNotifyObj)->pDeleteRtn = (_pDeleteRtn);						\
		(_pNotifyObj)->DeleteContext = (_DeleteContext);				\
	}



/*++
PRWAN_SEND_REQUEST
RWAN_SEND_REQUEST_FROM_PACKET(
	IN	PNDIS_PACKET				pNdisPacket
	)
--*/
#define RWAN_SEND_REQUEST_FROM_PACKET(_pNdisPacket)					\
			(PRWAN_SEND_REQUEST)((_pNdisPacket)->ProtocolReserved)


#if DBG
#define RWAN_LINK_CONNECTION_TO_VC(_pConn, _pVc)					\
			{														\
				(_pConn)->NdisConnection.pNdisVc = _pVc;			\
				(_pConn)->pNdisVcSave = _pVc;						\
				(_pVc)->pConnObject = (_pConn);						\
			}
#else
#define RWAN_LINK_CONNECTION_TO_VC(_pConn, _pVc)					\
			{														\
				(_pConn)->NdisConnection.pNdisVc = _pVc;			\
				(_pConn)->pNdisVcSave = _pVc;						\
				(_pVc)->pConnObject = (_pConn);						\
			}
#endif // DBG

#define RWAN_UNLINK_CONNECTION_AND_VC(_pConn, _pVc)					\
			{														\
				(_pConn)->NdisConnection.pNdisVc = NULL_PRWAN_NDIS_VC;\
				(_pVc)->pConnObject = NULL_PRWAN_TDI_CONNECTION;	\
			}


/*++
VOID
RWAN_SET_VC_CALL_PARAMS(
	IN	PRWAN_NDIS_VC				pVc,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
--*/
#define RWAN_SET_VC_CALL_PARAMS(_pVc, _pCallParameters)				\
{																	\
	if ((_pCallParameters != NULL) &&								\
		(_pCallParameters->CallMgrParameters != NULL))				\
	{																\
		_pVc->MaxSendSize = _pCallParameters->CallMgrParameters->Transmit.MaxSduSize;	\
	}																\
	if (gHackSendSize)												\
	{																\
		_pVc->MaxSendSize = gHackSendSize;							\
	}																\
	/* DbgPrint("RWan: set vc %x: maxsendsize to %d\n", _pVc, _pVc->MaxSendSize); */	\
}


#define RWAN_SET_VC_EVENT(_pVc, _Flags)	((_pVc)->Flags) |= (_Flags);


#if STATS

#define INCR_STAT(_pSt)	InterlockedIncrement(_pSt);

#define ADD_STAT(_pSt, Incr)	*(_pSt) += Incr;

#endif // STATS

#endif // __RWAN_MACROS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\info.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\info.c

Abstract:

	Routines for handling query/set information requests.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-09-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'OFNI'


//
//  Kludgy way to ensure we have enough space for a transport
//  address in the following INFO BUF structure.
//
#define MAX_RWAN_TDI_INFO_LENGTH		200


typedef union _RWAN_TDI_INFO_BUF
{
	TDI_CONNECTION_INFO			ConnInfo;
	TDI_ADDRESS_INFO			AddrInfo;
	TDI_PROVIDER_INFO			ProviderInfo;
	TDI_PROVIDER_STATISTICS		ProviderStats;
	UCHAR						Space[MAX_RWAN_TDI_INFO_LENGTH];

} RWAN_TDI_INFO_BUF, *PRWAN_TDI_INFO_BUF;



TDI_STATUS
RWanTdiQueryInformation(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	UINT						QueryType,
    IN	PNDIS_BUFFER				pNdisBuffer,
    IN	PUINT						pBufferSize,
    IN	UINT						IsConnection
    )
/*++

Routine Description:

	This is the TDI entry point to handle a QueryInformation TDI request.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	QueryType		- Information being queried for
	pNdisBuffer		- Start of list of buffers containing query data
	pBufferSize		- Total space in above list
	IsConnection	- Is this query on a connection endpoint?

Return Value:

	TDI_STATUS:  TDI_SUCCESS if the query was processed
	successfully, TDI_STATUS_XXX for any error.

--*/
{
	TDI_STATUS				TdiStatus;
	RWAN_TDI_INFO_BUF		InfoBuf;
	PVOID					InfoPtr;
	UINT					InfoSize;
	UINT					Offset;
	UINT					Size;
	UINT					BytesCopied;
	PRWAN_TDI_PROTOCOL		pProtocol;
	PRWAN_TDI_ADDRESS		pAddrObject;
	PRWAN_TDI_CONNECTION		pConnObject;
	RWAN_CONN_ID				ConnId;

	TdiStatus = TDI_SUCCESS;
	InfoPtr = NULL;

	switch (QueryType)
	{
		case TDI_QUERY_BROADCAST_ADDRESS:

			TdiStatus = TDI_INVALID_QUERY;
			break;

		case TDI_QUERY_PROVIDER_INFO:

			pProtocol = pTdiRequest->Handle.ControlChannel;
			RWAN_STRUCT_ASSERT(pProtocol, ntp);

			InfoBuf.ProviderInfo = pProtocol->ProviderInfo;
			InfoSize = sizeof(TDI_PROVIDER_INFO);
			InfoPtr = &InfoBuf.ProviderInfo;
			break;
	
		case TDI_QUERY_ADDRESS_INFO:

			if (IsConnection)
			{
				ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

				RWAN_ACQUIRE_CONN_TABLE_LOCK();

				pConnObject = RWanGetConnFromId(ConnId);

				RWAN_RELEASE_CONN_TABLE_LOCK();

				if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
				{
					TdiStatus = TDI_INVALID_CONNECTION;
					break;
				}

				pAddrObject = pConnObject->pAddrObject;

			}
			else
			{
				pAddrObject = (PRWAN_TDI_ADDRESS)pTdiRequest->Handle.AddressHandle;
			}

			if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
			{
				TdiStatus = TDI_INVALID_CONNECTION;
				break;
			}

			RWAN_STRUCT_ASSERT(pAddrObject, nta);

			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

			RWAN_ASSERT(pAddrObject->AddressLength <=
							(sizeof(RWAN_TDI_INFO_BUF) - sizeof(TDI_ADDRESS_INFO)));

			InfoSize = sizeof(TDI_ADDRESS_INFO) - sizeof(TRANSPORT_ADDRESS) +
						pAddrObject->AddressLength;

			InfoBuf.AddrInfo.ActivityCount = 1;	// same as TCP
			InfoBuf.AddrInfo.Address.TAAddressCount = 1;
			InfoBuf.AddrInfo.Address.Address[0].AddressLength = pAddrObject->AddressLength;
			InfoBuf.AddrInfo.Address.Address[0].AddressType = pAddrObject->AddressType;
			RWAN_COPY_MEM(InfoBuf.AddrInfo.Address.Address[0].Address,
						 pAddrObject->pAddress,
						 pAddrObject->AddressLength);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
						("RWanTdiQueryInfo: IsConn %d, Addr dump:\n", IsConnection));
			RWANDEBUGPDUMP(DL_LOUD, DC_DISPATCH, pAddrObject->pAddress, pAddrObject->AddressLength);
			InfoPtr = &InfoBuf.AddrInfo;

			TdiStatus = TDI_SUCCESS;

			break;
		
		case TDI_QUERY_CONNECTION_INFO:

			TdiStatus = TDI_INVALID_QUERY;
			break;
		
		case TDI_QUERY_PROVIDER_STATISTICS:

			pProtocol = pTdiRequest->Handle.ControlChannel;
			RWAN_STRUCT_ASSERT(pProtocol, ntp);

			InfoBuf.ProviderStats = pProtocol->ProviderStats;
			InfoSize = sizeof(TDI_PROVIDER_STATISTICS);
			InfoPtr = &InfoBuf.ProviderStats;
			break;
		
		default:

			TdiStatus = TDI_INVALID_QUERY;
			break;
	}

	if (TdiStatus == TDI_SUCCESS)
	{
		RWAN_ASSERT(InfoPtr != NULL);
		Offset = 0;
		Size = *pBufferSize;

		(VOID)RWanCopyFlatToNdis(
					pNdisBuffer,
					InfoPtr,
					MIN(InfoSize, Size),
					&Offset,
					&BytesCopied
					);
		
		if (Size < InfoSize)
		{
			TdiStatus = TDI_BUFFER_OVERFLOW;
		}
		else
		{
			*pBufferSize = InfoSize;
		}
	}

	return (TdiStatus);
	
}


RWAN_STATUS
RWanHandleGenericConnQryInfo(
    IN	HANDLE						ConnectionContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    )
/*++

Routine Description:

	Handle a generic QueryInformation command on a Connection Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	ConnectionContext	- TDI Connection ID
	pInputBuffer		- Query Info structure
	InputBufferLength	- Length of the above
	pOutputBuffer		- Output buffer
	pOutputBufferLength	- Space available/bytes filled in.

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_TDI_CONNECTION		pConnObject;
	RWAN_STATUS					RWanStatus;
	PRWAN_QUERY_INFORMATION_EX	pQueryInfo;

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		if (InputBufferLength < sizeof(RWAN_QUERY_INFORMATION_EX) ||
			pOutputBuffer == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId((RWAN_CONN_ID)PtrToUlong(ConnectionContext));

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL)
		{
			RWanStatus = RWAN_STATUS_BAD_PARAMETER;
			break;
		}

		RWAN_STRUCT_ASSERT(pConnObject, ntc);

		pQueryInfo = (PRWAN_QUERY_INFORMATION_EX)pInputBuffer;

		if (InputBufferLength < sizeof(RWAN_QUERY_INFORMATION_EX) + pQueryInfo->ContextLength - sizeof(UCHAR))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		switch (pQueryInfo->ObjectId)
		{
			case RWAN_OID_CONN_OBJECT_MAX_MSG_SIZE:

				if (*(PULONG)(ULONG_PTR)pOutputBufferLength < sizeof(ULONG))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				RWAN_ACQUIRE_CONN_LOCK(pConnObject);

				if (pConnObject->NdisConnection.pNdisVc)
				{
					*(PULONG)(ULONG_PTR)pOutputBuffer = pConnObject->NdisConnection.pNdisVc->MaxSendSize;
					*(PULONG)(ULONG_PTR)pOutputBufferLength = sizeof(ULONG);
				}
				else
				{
					RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				}

				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			
			default:

				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_LOUD, DC_BIND,
		("RWanHandleGenericConnQry: returning status %x\n", RWanStatus));

	return (RWanStatus);
}


RWAN_STATUS
RWanHandleGenericAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Handle a non-media specific SetInformation command on an Address Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	pInputBuffer		- Set Info structure
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_SET_INFORMATION_EX	pSetInfo;
	RWAN_STATUS					RWanStatus;
	ULONG						Flags;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAddrObject = (PRWAN_TDI_ADDRESS)AddrHandle;

	do
	{
		if (pAddrObject == NULL)
		{
			RWanStatus = RWAN_STATUS_BAD_ADDRESS;
			break;
		}

		RWAN_STRUCT_ASSERT(pAddrObject, nta);

		if (InputBufferLength < sizeof(RWAN_SET_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pSetInfo = (PRWAN_SET_INFORMATION_EX)pInputBuffer;

		if (InputBufferLength < sizeof(RWAN_SET_INFORMATION_EX) + pSetInfo->BufferSize - sizeof(UCHAR))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		switch (pSetInfo->ObjectId)
		{
			case RWAN_OID_ADDRESS_OBJECT_FLAGS:

				if (pSetInfo->BufferSize < sizeof(ULONG))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				Flags = *((PULONG)&pSetInfo->Buffer[0]);

				if (Flags & RWAN_AOFLAG_C_ROOT)
				{
					//
					//  This Address Object is designated as the Root of
					//  an outgoing Point to Multipoint connection.
					//

					RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

					RWAN_SET_BIT(pAddrObject->Flags, RWANF_AO_PMP_ROOT);

					if (pAddrObject->pRootConnObject != NULL)
					{
						RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
						RWanStatus = RWAN_STATUS_BAD_ADDRESS;
						break;
					}

					//
					//  There should be a single Connection Object associated
					//  with this Address Object. That should now be designated
					//  the Root Connection Object.
					//
					RWAN_ASSERT(!RWAN_IS_LIST_EMPTY(&pAddrObject->IdleConnList));
					pConnObject = CONTAINING_RECORD(pAddrObject->IdleConnList.Flink, RWAN_TDI_CONNECTION, ConnLink);

					RWAN_STRUCT_ASSERT(pConnObject, ntc);

					pAddrObject->pRootConnObject = pConnObject;

					RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

					RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_ROOT);

					RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

					RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

					RWANDEBUGP(DL_LOUD, DC_ADDRESS,
						("Marked PMP Root: AddrObj x%x, ConnObj x%x\n",
							pAddrObject, pConnObject));

				}

				break;

			default:

				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("Generic Set Addr: AddrObj x%x, returning x%x\n", pAddrObject, RWanStatus));

	return (RWanStatus);
}


RWAN_STATUS
RWanHandleMediaSpecificAddrSetInfo(
    IN	HANDLE						AddrHandle,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Handle a media specific SetInformation command on an Address Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	pInputBuffer		- Set Info structure
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PRWAN_TDI_ADDRESS			pAddrObject;
	RWAN_STATUS					RWanStatus;
	ULONG						Flags;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAddrObject = (PRWAN_TDI_ADDRESS)AddrHandle;

	do
	{
		if (pAddrObject == NULL)
		{
			RWanStatus = RWAN_STATUS_BAD_ADDRESS;
			break;
		}

		RWAN_STRUCT_ASSERT(pAddrObject, nta);

		pAfChars = &(pAddrObject->pProtocol->pAfInfo->AfChars);

		if (pAfChars->pAfSpSetAddrInformation != NULL)
		{
			RWanStatus = (*pAfChars->pAfSpSetAddrInformation)(
							pAddrObject->AfSpAddrContext,
							pInputBuffer,
							InputBufferLength
							);
		}
		else
		{
			RWanStatus = RWAN_STATUS_FAILURE;
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}


RWAN_STATUS
RWanHandleMediaSpecificConnQryInfo(
    IN	HANDLE						ConnectionContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT	PVOID					pOutputBufferLength
    )
/*++

Routine Description:

	Handle a media specific QueryInformation command on a Connection Object.

Arguments:

	AddrHandle			- Pointer to our address object structure
	ConnectionContext	- TDI Connection ID
	pInputBuffer		- Query Info structure
	InputBufferLength	- Length of the above
	pOutputBuffer		- Output buffer
	pOutputBufferLength	- Space available/bytes filled in.

Return Value:

	RWAN_STATUS_SUCCESS if the command was processed successfully,
	RWAN_STATUS_XXX if not.

--*/
{
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PRWAN_TDI_CONNECTION		pConnObject;
	RWAN_STATUS					RWanStatus;
	ULONG						Flags;

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId((RWAN_CONN_ID)PtrToUlong(ConnectionContext));

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if ((pConnObject == NULL) ||
			(pConnObject->pAddrObject == NULL))
		{
			RWanStatus = RWAN_STATUS_BAD_PARAMETER;
			break;
		}

		RWAN_STRUCT_ASSERT(pConnObject, ntc);

		pAfChars = &(pConnObject->pAddrObject->pProtocol->pAfInfo->AfChars);

		if (pAfChars->pAfSpQueryConnInformation != NULL)
		{
			RWanStatus = (*pAfChars->pAfSpQueryConnInformation)(
							pConnObject->AfSpConnContext,
							pInputBuffer,
							InputBufferLength,
							pOutputBuffer,
							pOutputBufferLength
							);
		}
		else
		{
			RWanStatus = RWAN_STATUS_FAILURE;
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}



PNDIS_BUFFER
RWanCopyFlatToNdis(
    IN	PNDIS_BUFFER				pDestBuffer,
    IN	PUCHAR						pSrcBuffer,
    IN	UINT						LengthToCopy,
    IN OUT	PUINT					pStartOffset,
    OUT	PUINT						pBytesCopied
    )
/*++

Routine Description:

	Copy from a flat memory buffer to an NDIS buffer chain. It is assumed
	that the NDIS buffer chain has enough space.

	TBD: Use the TDI function for copying from flat mem to MDL.

Arguments:

	pDestBuffer		- First buffer in the destination NDIS buffer chain.
	pSrcBuffer		- Pointer to start of flat memory
	LengthToCopy	- Max bytes to copy
	pStartOffset	- Copy offset in first buffer
	pBytesCopied	- Place to return actual bytes copied

Return Value:

	Pointer to buffer in chain where data can be copied into next.
	Also, *pStartOffset and *pBytesCopied are set.

--*/
{
	UINT		CopyLength;
	PUCHAR		pDest;
	UINT		Offset;
	UINT		BytesCopied;
	UINT		DestSize;
	UINT		CopySize;

	BytesCopied = 0;
	Offset = *pStartOffset;

	pDest = (PUCHAR)NdisBufferVirtualAddress(pDestBuffer) + Offset;
	DestSize = NdisBufferLength(pDestBuffer) - Offset;

	for (;;)
	{
		CopySize = MIN(DestSize, LengthToCopy);

		RWAN_COPY_MEM(pDest, pSrcBuffer, CopySize);

		pDest += CopySize;
		pSrcBuffer += CopySize;
		BytesCopied += CopySize;

		LengthToCopy -= CopySize;

		if (LengthToCopy == 0)
		{
			break;
		}

		DestSize -= CopySize;

		if (DestSize == 0)
		{
			pDestBuffer = NDIS_BUFFER_LINKAGE(pDestBuffer);
			RWAN_ASSERT(pDestBuffer != NULL);

			pDest = NdisBufferVirtualAddress(pDestBuffer);
			DestSize = NdisBufferLength(pDestBuffer);
		}
	}

	//
	//  Prepare return values.
	//
	*pStartOffset = (UINT)(pDest - (PUCHAR)NdisBufferVirtualAddress(pDestBuffer));
	*pBytesCopied = BytesCopied;

	return (pDestBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\mediasp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\mediasp.c

Abstract:

	Media and Address Family Specific routines. These are exported routines
	that a media/AF specific module can call.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-02-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER ' DEM'



RWAN_STATUS
RWanInitMediaSpecific(
	VOID
	)
/*++

Routine Description:

	Initialize all media/AF specific modules. For now, we just
	run through our list of media-specific Init routines and call
	each of them.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if initialization completed successfully for
	atleast one module, RWAN_STATUS_FAILURE otherwise.

--*/
{
	RWAN_STATUS				RWanStatus;
	PRWAN_AFSP_MODULE_CHARS	pModuleChars;
	INT						SuccessfulInits;

	SuccessfulInits = 0;

	for (pModuleChars = &RWanMediaSpecificInfo[0];
		 pModuleChars->pAfSpInitHandler != NULL;
		 pModuleChars++)
	{
		RWanStatus = (*pModuleChars->pAfSpInitHandler)();
		if (RWanStatus == RWAN_STATUS_SUCCESS)
		{
			SuccessfulInits++;
		}
	}

	if (SuccessfulInits > 0)
	{
		return (RWAN_STATUS_SUCCESS);
	}
	else
	{
		return (RWAN_STATUS_FAILURE);
	}
}




VOID
RWanShutdownMediaSpecific(
	VOID
	)
/*++

Routine Description:

	Tell all media/AF-specific modules to shut down.

Arguments:

	None

Return Value:

	None

--*/
{
	PRWAN_AFSP_MODULE_CHARS	pModuleChars;

	for (pModuleChars = &RWanMediaSpecificInfo[0];
		 pModuleChars->pAfSpInitHandler != NULL;
		 pModuleChars++)
	{
		(*pModuleChars->pAfSpShutdownHandler)();
	}
}




RWAN_STATUS
RWanAfSpRegisterNdisAF(
	IN	PRWAN_NDIS_AF_CHARS			pAfChars,
	IN	RWAN_HANDLE					AfSpContext,
	OUT	PRWAN_HANDLE					pRWanSpHandle
	)
/*++

Routine Description:

	This is called by a media-specific module to register support
	of an NDIS Address family for a particular medium. The characteristics
	structure contains the module's entry points for various media-specific
	operations.

	We create an AF_INFO structure to keep track of this AF+Medium,
	and return a pointer to it as the handle.

Arguments:

	pAfChars			- Entry points for the module
	AfSpContext			- The media-specific module's context for this AF+medium
	pRWanSpHandle		- Place to return our handle for this AF+medium

Return Value:

	RWAN_STATUS_SUCCESS if the new NDIS AF+medium was successfully registered,
	RWAN_STATUS_RESOURCES if we failed due to lack of resources.
	XXX: Check for duplicates?

--*/
{
	PRWAN_NDIS_AF_INFO			pAfInfo;
	RWAN_STATUS					RWanStatus;

	do
	{
		RWAN_ALLOC_MEM(pAfInfo, RWAN_NDIS_AF_INFO, sizeof(RWAN_NDIS_AF_INFO));

		if (pAfInfo == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_SET_SIGNATURE(pAfInfo, nai);

		pAfInfo->Flags = 0;
		RWAN_INIT_LIST(&pAfInfo->NdisAfList);
		RWAN_INIT_LIST(&pAfInfo->TdiProtocolList);

		RWAN_COPY_MEM(&pAfInfo->AfChars, pAfChars, sizeof(RWAN_NDIS_AF_CHARS));

		pAfInfo->AfSpContext = AfSpContext;

		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_INSERT_HEAD_LIST(&pRWanGlobal->AfInfoList,
							 &pAfInfo->AfInfoLink);

		pRWanGlobal->AfInfoCount++;

		RWAN_RELEASE_GLOBAL_LOCK();

		*pRWanSpHandle = (RWAN_HANDLE)pAfInfo;
		RWanStatus = RWAN_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (RWanStatus);
}



RWAN_STATUS
RWanAfSpDeregisterNdisAF(
	IN	RWAN_HANDLE					RWanSpAFHandle
	)
/*++

Routine Description:

	This is called by a media-specific module to deregister support
	of an NDIS Address family for a particular medium.

Arguments:

	RWanSpAFHandle		- Actually a pointer to an NDIS_AF_INFO block.

Return Value:

	RWAN_STATUS_SUCCESS if we successfully completed the deregistration
	here, RWAN_STATUS_PENDING if there are open AFs or TDI protocols
	on this block.

--*/
{
	PRWAN_NDIS_AF_INFO			pAfInfo;
	RWAN_STATUS					RWanStatus;

	pAfInfo = (PRWAN_NDIS_AF_INFO)RWanSpAFHandle;

	RWAN_STRUCT_ASSERT(pAfInfo, nai);

	RWAN_ACQUIRE_GLOBAL_LOCK();

	//
	//  See if all AF blocks and TDI protocols are gone.
	//
	if (RWAN_IS_LIST_EMPTY(&pAfInfo->TdiProtocolList) &&
		RWAN_IS_LIST_EMPTY(&pAfInfo->NdisAfList))
	{
		RWanStatus = RWAN_STATUS_SUCCESS;

		//
		//  Remove this AF INFO block from the global list.
		//
		RWAN_DELETE_FROM_LIST(&pAfInfo->AfInfoLink);

		//
		//  Free this AF INFO block.
		//
		RWAN_FREE_MEM(pAfInfo);
	}
	else
	{
		//
		//  There is still some activity on this AF INFO.
		//  Pend this request till all these go away.
		//
		RWanStatus = RWAN_STATUS_PENDING;

		RWAN_SET_BIT(pAfInfo->Flags, RWANF_AFI_CLOSING);

		RWAN_ASSERT(FALSE);
	}

	RWAN_RELEASE_GLOBAL_LOCK();

	return (RWanStatus);

}


RWAN_STATUS
RWanAfSpRegisterTdiProtocol(
	IN	RWAN_HANDLE						RWanSpHandle,
	IN	PRWAN_TDI_PROTOCOL_CHARS		pTdiChars,
	OUT	PRWAN_HANDLE					pRWanProtHandle
	)
/*++

Routine Description:

	This is the API called by a media-specific module to register
	support for a TDI protocol over an NDIS AF. We create a TDI
	Protocol block and a device object to represent this protocol.

Arguments:

	RWanSpHandle			- Actually a pointer to our NDIS_AF_INFO structure
	pTdiChars			- Characteristics of the protocol being registered
	pRWanProtHandle		- Place to return our context for this protocol

Return Value:

	RWAN_STATUS_SUCCESS if we successfully registered this TDI protocol,
	RWAN_STATUS_XXX error code otherwise.

--*/
{
	RWAN_STATUS					RWanStatus;
	PRWAN_NDIS_AF_INFO			pAfInfo;
	PRWAN_TDI_PROTOCOL			pProtocol;
#ifdef NT
	PRWAN_DEVICE_OBJECT			pRWanDeviceObject;
	NTSTATUS					Status;
#endif // NT

	pAfInfo = (PRWAN_NDIS_AF_INFO)RWanSpHandle;
	RWAN_STRUCT_ASSERT(pAfInfo, nai);

	pProtocol = NULL;
	pRWanDeviceObject = NULL;

	do
	{
		RWAN_ALLOC_MEM(pProtocol, RWAN_TDI_PROTOCOL, sizeof(RWAN_TDI_PROTOCOL));

		if (pProtocol == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_SET_SIGNATURE(pProtocol, ntp);
		pProtocol->pAfInfo = pAfInfo;
		pProtocol->TdiProtocol = pTdiChars->TdiProtocol;
		pProtocol->SockAddressFamily = pTdiChars->SockAddressFamily;
		pProtocol->SockProtocol = pTdiChars->SockProtocol;
		pProtocol->TdiProtocol = pTdiChars->TdiProtocol;
		pProtocol->SockType = pTdiChars->SockType;
		pProtocol->bAllowAddressObjects = pTdiChars->bAllowAddressObjects;
		pProtocol->bAllowConnObjects = pTdiChars->bAllowConnObjects;
		pProtocol->pAfSpDeregTdiProtocolComplete =
							pTdiChars->pAfSpDeregTdiProtocolComplete;
		pProtocol->ProviderInfo = pTdiChars->ProviderInfo;

		RWAN_INIT_LIST(&pProtocol->AddrObjList);

#ifdef NT
		//
		//  Create an I/O Device on which we can receive IRPs for this
		//  protocol.
		//
		RWAN_ALLOC_MEM(pRWanDeviceObject, RWAN_DEVICE_OBJECT, sizeof(RWAN_DEVICE_OBJECT));

		if (pRWanDeviceObject == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		RWAN_SET_SIGNATURE(pRWanDeviceObject, ndo);
		pRWanDeviceObject->pProtocol = pProtocol;
		pProtocol->pRWanDeviceObject = (PVOID)pRWanDeviceObject;

		//
		//  Create the device now. A pointer's worth of space is requested
		//  in the device extension.
		//
		Status = IoCreateDevice(
						pRWanGlobal->pDriverObject,
						sizeof(PRWAN_DEVICE_OBJECT),
						pTdiChars->pDeviceName,
						FILE_DEVICE_NETWORK,
						0,
						FALSE,
						&(pRWanDeviceObject->pDeviceObject)
						);

		if (!NT_SUCCESS(Status))
		{
			RWanStatus = RWAN_STATUS_FAILURE;
			break;
		}

		pRWanDeviceObject->pDeviceObject->Flags |= DO_DIRECT_IO;

		//
		//  Store a pointer to our device context in the
		//  NT device object extension.
		//
		*(PRWAN_DEVICE_OBJECT *)(pRWanDeviceObject->pDeviceObject->DeviceExtension) =
						pRWanDeviceObject;

		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_INSERT_HEAD_LIST(&(pRWanGlobal->DeviceObjList),
							 &(pRWanDeviceObject->DeviceObjectLink));

		//
		//  Add this Protocol to the list of TDI protocols on the
		//  AF INFO block.
		//
		RWAN_INSERT_TAIL_LIST(&(pAfInfo->TdiProtocolList),
							 &(pProtocol->AfInfoLink));

		//
		//  Add this Protocol to the global list of TDI protocols.
		//
		RWAN_INSERT_TAIL_LIST(&(pRWanGlobal->ProtocolList),
							 &(pProtocol->TdiProtocolLink));
		
		pRWanGlobal->ProtocolCount++;

		RWAN_RELEASE_GLOBAL_LOCK();
#endif // NT

		RWanStatus = RWAN_STATUS_SUCCESS;
		*pRWanProtHandle = (RWAN_HANDLE)pProtocol;

		break;
	}
	while (FALSE);

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		if (pProtocol != NULL)
		{
			RWAN_FREE_MEM(pProtocol);
		}
#ifdef NT
		if (pRWanDeviceObject != NULL)
		{
			RWAN_FREE_MEM(pRWanDeviceObject);
		}
#endif // NT
	}

	return (RWanStatus);
}




VOID
RWanAfSpDeregisterTdiProtocol(
	IN	RWAN_HANDLE					RWanProtHandle
	)
/*++

Routine Description:

	This is the API called by a media-specific module to de-register
	support for a TDI protocol. We delete the TDI Protocol block
	that holds information about this protocol.

Arguments:

	RWanProtHandle		- Pointer to the TDI Protocol block

Return Value:

	None

--*/
{
	PRWAN_TDI_PROTOCOL		pProtocol;
	PRWAN_NDIS_AF_INFO		pAfInfo;
#ifdef NT
	PRWAN_DEVICE_OBJECT		pRWanDeviceObject;
#endif // NT

	pProtocol = (PRWAN_TDI_PROTOCOL)RWanProtHandle;
	RWAN_STRUCT_ASSERT(pProtocol, ntp);

	RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pProtocol->AddrObjList));

	//
	//  Unlink this TDI protocol.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	RWAN_DELETE_FROM_LIST(&(pProtocol->TdiProtocolLink));
	RWAN_DELETE_FROM_LIST(&(pProtocol->AfInfoLink));

	pRWanGlobal->ProtocolCount--;

	RWAN_RELEASE_GLOBAL_LOCK();

#ifdef NT
	//
	//  Delete the I/O device we'd created for this protocol.
	//
	pRWanDeviceObject = (PRWAN_DEVICE_OBJECT)pProtocol->pRWanDeviceObject;
	RWAN_ASSERT(pRWanDeviceObject != NULL);

	IoDeleteDevice(pRWanDeviceObject->pDeviceObject);

	RWAN_FREE_MEM(pRWanDeviceObject);
#endif // NT

	RWAN_FREE_MEM(pProtocol);

	return;
}




VOID
RWanAfSpOpenAfComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						MaxMessageSize
   	)
/*++

Routine Description:

	This is called by an AF-specific module to signify completion
	of our call to its OpenAfHandler routine. If the AF-specific module
	has successfully set up its context for this AF open, we store
	its context for this in our NDIS AF structure.

	Otherwise, we tear down this AF.

Arguments:

	RWanStatus		- Final status of our call to AF-specific module's AfOpen handler
	RWanAfHandle	- Our context for an NDIS AF Open
	AfSpAFContext	- AF-Specific module's context for this Open
	MaxMessageSize	- Max message size for this AF

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_ADAPTER		pAdapter;
	PRWAN_NDIS_AF_INFO		pAfInfo;
	PLIST_ENTRY				pEnt;
	PRWAN_TDI_PROTOCOL		pTdiProtocol;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	pAdapter = pAf->pAdapter;

	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

		RWAN_ACQUIRE_AF_LOCK_DPC(pAf);
		pAf->AfSpAFContext = AfSpAFContext;

		RWAN_SET_BIT(pAf->Flags, RWANF_AF_IN_ADAPTER_LIST);

		//
		//  Add this AF to the adapter's list of open AFs.
		//
		RWAN_INSERT_HEAD_LIST(&(pAdapter->AfList),
							 &(pAf->AfLink));

		RWAN_RELEASE_AF_LOCK_DPC(pAf);

#if 0
		RWanReferenceAdapter(pAdapter);	// AF linkage
#endif

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

		RWAN_ACQUIRE_GLOBAL_LOCK();

		pAfInfo = pAf->pAfInfo;
		for (pEnt = pAfInfo->TdiProtocolList.Flink;
			 pEnt != &pAfInfo->TdiProtocolList;
			 pEnt = pEnt->Flink)
		{
			pTdiProtocol = CONTAINING_RECORD(pEnt, RWAN_TDI_PROTOCOL, AfInfoLink);

			pTdiProtocol->ProviderInfo.MaxSendSize =
				MIN(pTdiProtocol->ProviderInfo.MaxSendSize, MaxMessageSize);
		}

		RWAN_RELEASE_GLOBAL_LOCK();
	}
	else
	{
		RWanShutdownAf(pAf);
	}
}




VOID
RWanAfSpCloseAfComplete(
    IN	RWAN_HANDLE					RWanAfHandle
    )
/*++

Routine Description:

	This is called by an AF-specific module to signify completion
	of our call to its CloseAfHandler routine.

	We now call NDIS to close this AF.

Arguments:

	RWanAfHandle		- Our context for an NDIS AF Open

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAfHandle;
	NDIS_STATUS				Status;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	pAf->AfSpAFContext = NULL;
	NdisAfHandle = pAf->NdisAfHandle;

	RWAN_RELEASE_AF_LOCK(pAf);

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("AfSpCloseAfComplete: pAf x%p, will CloseAF, AfHandle x%p\n",
					pAf, NdisAfHandle));

	Status = NdisClCloseAddressFamily(NdisAfHandle);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisCloseAddressFamilyComplete(
			Status,
			(NDIS_HANDLE)pAf
			);
	}
}





RWAN_STATUS
RWanAfSpSendAdapterRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request down to the miniport on behalf of the media
	specific module.

Arguments:

	RWanAfHandle		- Our context for an NDIS AF Open
	AfSpReqContext	- The caller's context for this request
	RequestType		- NDIS request type
	Oid				- The object being set or queried
	pBuffer			- Points to parameter value
	BufferLength	- Length of the above

Return Value:

	RWAN_STATUS_PENDING if the request was sent to the miniport,
	RWAN_STATUS_RESOURCES if we couldn't allocate resources for the
	request.

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAdapterHandle;
	PNDIS_REQUEST			pNdisRequest;
	NDIS_STATUS				Status;
	PRWAN_NDIS_REQ_CONTEXT	pContext;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	if ((RequestType != NdisRequestQueryInformation) &&
		(RequestType != NdisRequestSetInformation))
	{
		return RWAN_STATUS_BAD_PARAMETER;
	}

	RWAN_ALLOC_MEM(pNdisRequest, NDIS_REQUEST, sizeof(NDIS_REQUEST) + sizeof(RWAN_NDIS_REQ_CONTEXT));

	if (pNdisRequest == NULL)
	{
	    return RWAN_STATUS_RESOURCES;
	}

	RWAN_ZERO_MEM(pNdisRequest, sizeof(NDIS_REQUEST));

	pNdisRequest->RequestType = RequestType;

	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
	}

	//
	//  Fill in context about this request, so that we can complete
	//  it to the media-specific module later.
	//
	pContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
	pContext->pAf = pAf;
	pContext->AfSpReqContext = AfSpReqContext;

	NdisRequest(&Status,
				pAf->pAdapter->NdisAdapterHandle,
				pNdisRequest);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisRequestComplete(
			pAf->pAdapter,
			pNdisRequest,
			Status
			);
	}

	return RWAN_STATUS_PENDING;
}




RWAN_STATUS
RWanAfSpSendAfRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request down to the call manager on behalf of the media
	specific module.

Arguments:

	RWanAfHandle	- Our context for an NDIS AF Open
	AfSpReqContext	- The caller's context for this request
	RequestType		- NDIS request type
	Oid				- The object being set or queried
	pBuffer			- Points to parameter value
	BufferLength	- Length of the above

Return Value:

	RWAN_STATUS_PENDING if the request was sent to the call manager,
	RWAN_STATUS_RESOURCES if we couldn't allocate resources for the
	request.

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAfHandle;
	PNDIS_REQUEST			pNdisRequest;
	NDIS_STATUS				Status;
	PRWAN_NDIS_REQ_CONTEXT	pContext;

	pAf = (PRWAN_NDIS_AF)RWanAfHandle;
	RWAN_STRUCT_ASSERT(pAf, naf);

	if ((RequestType != NdisRequestQueryInformation) &&
		(RequestType != NdisRequestSetInformation))
	{
		return RWAN_STATUS_BAD_PARAMETER;
	}

	RWAN_ALLOC_MEM(pNdisRequest, NDIS_REQUEST, sizeof(NDIS_REQUEST) + sizeof(RWAN_NDIS_REQ_CONTEXT));

	if (pNdisRequest == NULL)
	{
	    return RWAN_STATUS_RESOURCES;
	}

	RWAN_ZERO_MEM(pNdisRequest, sizeof(NDIS_REQUEST));

	pNdisRequest->RequestType = RequestType;

	if (RequestType == NdisRequestQueryInformation)
	{
		pNdisRequest->DATA.QUERY_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesWritten = 0;
		pNdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = BufferLength;
	}
	else
	{
		pNdisRequest->DATA.SET_INFORMATION.Oid = Oid;
		pNdisRequest->DATA.SET_INFORMATION.InformationBuffer = pBuffer;
		pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
		pNdisRequest->DATA.SET_INFORMATION.BytesRead = 0;
		pNdisRequest->DATA.SET_INFORMATION.BytesNeeded = BufferLength;
	}

	//
	//  Fill in context about this request, so that we can complete
	//  it to the media-specific module later.
	//
	pContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));
	pContext->pAf = pAf;
	pContext->AfSpReqContext = AfSpReqContext;

	Status = NdisCoRequest(
				pAf->pAdapter->NdisAdapterHandle,
				pAf->NdisAfHandle,
				NULL,	// NdisVcHandle,
				NULL,	// NdisPartyHandlem
				pNdisRequest
				);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisCoRequestComplete(
			Status,
			(NDIS_HANDLE)pAf,
			NULL,
			NULL,
			pNdisRequest
			);
	}

	return RWAN_STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\precomp.h ===
#include <ndis.h>

#include <tdikrnl.h>
#include <tdistat.h>

#include "system.h"

#include "debug.h"

#include "rwanpub.h"
#include "rwandata.h"
#ifdef NT
#include "rwannt.h"
#include "rwanuser.h"
#endif // NT
#include "config.h"
#include "macros.h"
#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\ndisbind.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\ndisbind.c

Abstract:

	NDIS entry points and helper routines for binding, unbinding, opening
	and closing adapters.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-02-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'DNIB'




VOID
RWanNdisBindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					BindContext,
	IN	PNDIS_STRING				pDeviceName,
	IN	PVOID						SystemSpecific1,
	IN	PVOID						SystemSpecific2
	)
/*++

Routine Description:

	This is the NDIS protocol entry point for binding to an adapter.
	We open the adapter and see if it is one of the supported types.
	Action continues when we get notified of a Call Manager that
	has registered support for an Address Family.

Arguments:

	pStatus			- Place to return status of this call
	BindContext		- Used to complete this call, if we pend it.
	pDeviceName		- Name of adapter we are asked to bind to.
	SystemSpecific1	- Handle to use to access configuration information
	SystemSpecific2	- Not used

Return Value:

	None directly. But we set *pStatus to NDIS_STATUS_PENDING if we
	made the call to open the adapter, NDIS_STATUS_NOT_RECOGNIZED
	if this adapter isn't one of the supported media types, NDIS_STATUS_RESOURCES
	if we hit any allocation failures.

--*/
{
	PRWAN_NDIS_ADAPTER		pAdapter;
	PNDIS_MEDIUM			pMediaArray;
	UINT					MediaCount;	// Number of media-types we support
	NDIS_STATUS				Status;
	NDIS_STATUS				OpenStatus;
	ULONG					TotalLength;


	RWANDEBUGP(DL_LOUD, DC_BIND,
			("BindAdapter: Context x%x, Device %Z, SS1 x%x, SS2 x%x\n",
				BindContext, pDeviceName, SystemSpecific1, SystemSpecific2));

#if DBG
	if (RWanSkipAll)
	{
		RWANDEBUGP(DL_ERROR, DC_WILDCARD,
				("BindAdapter: bailing out!\n"));
		*pStatus = NDIS_STATUS_NOT_RECOGNIZED;
		return;
	}
#endif // DBG

	//
	//  Initialize.
	//
	pAdapter = NULL_PRWAN_NDIS_ADAPTER;
	pMediaArray = NULL;

	do
	{
		//
		//  Allocate an Adapter structure, along with space for the device
		//  name.
		//
		TotalLength = sizeof(RWAN_NDIS_ADAPTER) + (pDeviceName->MaximumLength)*sizeof(WCHAR);

		RWAN_ALLOC_MEM(pAdapter, RWAN_NDIS_ADAPTER, TotalLength);

		if (pAdapter == NULL_PRWAN_NDIS_ADAPTER)
		{
			RWANDEBUGP(DL_WARN, DC_BIND,
					("BindAdapter: Couldnt allocate adapter (%d bytes)\n", TotalLength));
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		//
		//  Get the list of NDIS media that we support.
		//
		pMediaArray = RWanGetSupportedMedia(&MediaCount);

		if (pMediaArray == NULL)
		{
			RWANDEBUGP(DL_WARN, DC_BIND,
					("BindAdapter: Couldnt get supported media list!\n"));
			Status = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

		//
		//  Initialize the Adapter.
		//
		RWAN_ZERO_MEM(pAdapter, TotalLength);
		RWAN_SET_SIGNATURE(pAdapter, nad);

		RWAN_INIT_LIST(&(pAdapter->AfList));
		RWAN_INIT_LOCK(&(pAdapter->Lock));

		pAdapter->pMediaArray = pMediaArray;
		pAdapter->BindContext = BindContext;

		//
		//  Copy in the device name.
		//
		pAdapter->DeviceName.Buffer = (PWCHAR)((PUCHAR)pAdapter + sizeof(RWAN_NDIS_ADAPTER));
		pAdapter->DeviceName.MaximumLength = pDeviceName->MaximumLength;
		pAdapter->DeviceName.Length = pDeviceName->Length;
		RWAN_COPY_MEM(pAdapter->DeviceName.Buffer, pDeviceName->Buffer, pDeviceName->Length);

		pAdapter->State = RWANS_AD_OPENING;


		//
		//  Link this adapter to the global list of adapters.
		//
		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_INSERT_HEAD_LIST(&(pRWanGlobal->AdapterList),
							 &(pAdapter->AdapterLink));

		pRWanGlobal->AdapterCount++;
		RWAN_RELEASE_GLOBAL_LOCK();


		//
		//  Open the Adapter.
		//
		NdisOpenAdapter(
			&Status,
			&OpenStatus,
			&(pAdapter->NdisAdapterHandle),
			&(pAdapter->MediumIndex),		// place to return selected medium index
			pMediaArray,					// List of media types we support
			MediaCount,						// Length of above list
			pRWanGlobal->ProtocolHandle,
			(NDIS_HANDLE)pAdapter,			// our context for the adapter binding
			pDeviceName,
			0,								// open options (none)
			(PSTRING)NULL					// Addressing info (none)
			);

		if (Status != NDIS_STATUS_PENDING)
		{
			RWanNdisOpenAdapterComplete(
				(NDIS_HANDLE)pAdapter,
				Status,
				OpenStatus
				);
		}

		Status = NDIS_STATUS_PENDING;

		break;
	}
	while (FALSE);


	if (Status != NDIS_STATUS_PENDING)
	{
		//
		//  Failed somewhere; clean up.
		//
		if (pAdapter != NULL_PRWAN_NDIS_ADAPTER)
		{
			RWAN_FREE_MEM(pAdapter);
		}

		if (pMediaArray != NULL)
		{
			RWAN_FREE_MEM(pMediaArray);
		}
	}

	*pStatus = Status;

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("BindAdapter: pAdapter x%x, returning x%x\n", pAdapter, Status));

	return;

}



VOID
RWanNdisUnbindAdapter(
	OUT	PNDIS_STATUS				pStatus,
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_HANDLE					UnbindContext
	)
/*++

Routine Description:

	This is the NDIS protocol entry point for unbinding from an adapter
	that we have opened.

Arguments:

	pStatus			- Place to return status of this call
	ProtocolBindingContext - Our context for the bound adapter
	UnbindContext	- To be used when we complete the unbind.

Return Value:

	None. We set *pStatus to NDIS_STATUS_PENDING.

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	PLIST_ENTRY					pAfEntry;
	PLIST_ENTRY					pNextAfEntry;
	PRWAN_NDIS_AF				pAf;


	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	RWANDEBUGP(DL_WARN, DC_BIND,
			("UnbindAdapter: pAdapter x%x, State x%x\n", pAdapter, pAdapter->State));

	RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

	//
	//  Store away the unbind context for use in completing this
	//  unbind later.
	//
	pAdapter->BindContext = UnbindContext;
	RWAN_SET_BIT(pAdapter->Flags, RWANF_AD_UNBIND_PENDING);

	*pStatus = NDIS_STATUS_PENDING;

	if (RWAN_IS_LIST_EMPTY(&(pAdapter->AfList)))
	{
		RWanCloseAdapter(pAdapter);
		//
		//  Lock is released within the above.
		//
	}
	else
	{
		//
		//  Shut down all AFs on this adapter. We release the lock
		//  early since we are unbinding and don't expect any other
		//  events now.
		//

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

		for (pAfEntry = pAdapter->AfList.Flink;
			 pAfEntry != &(pAdapter->AfList);
			 pAfEntry = pNextAfEntry)
		{
			pNextAfEntry = pAfEntry->Flink;

			pAf = CONTAINING_RECORD(pAfEntry, RWAN_NDIS_AF, AfLink);

			RWanShutdownAf(pAf);
		}

	}

	return;
}




VOID
RWanNdisOpenAdapterComplete(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	NDIS_STATUS					Status,
	IN	NDIS_STATUS					OpenErrorStatus
	)
/*++

Routine Description:

	This is the NDIS Entry point called when a previous call we made
	to NdisOpenAdapter has completed.

Arguments:

	ProtocolContext	- our context for the adapter being opened,
					  which is a pointer to our Adapter structure.
	Status			- Final status of NdisOpenAdapter
	OpenErrorStatus	- Error code in case of failure

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	NDIS_HANDLE					BindContext;
	PNDIS_MEDIUM				pMediaArray;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolContext;

	RWAN_STRUCT_ASSERT(pAdapter, nad);

	BindContext = pAdapter->BindContext;
	pMediaArray = pAdapter->pMediaArray;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

		pAdapter->Medium = pMediaArray[pAdapter->MediumIndex];

		pAdapter->State = RWANS_AD_OPENED;

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);
	}
	else
	{
		//
		//  Remove this adapter from the global list.
		//
		//
		RWAN_ACQUIRE_GLOBAL_LOCK();

		RWAN_DELETE_FROM_LIST(&(pAdapter->AdapterLink));

		pRWanGlobal->AdapterCount--;

		RWAN_RELEASE_GLOBAL_LOCK();

		RWAN_FREE_MEM(pAdapter);
	}

	RWAN_FREE_MEM(pMediaArray);
	
	RWANDEBUGP(DL_INFO, DC_BIND, ("OpenAdapterComplete: pAdapter x%x, Status x%x\n",
						pAdapter, Status));

	//
	//  Now complete the BindAdapter that we had pended.
	//
	NdisCompleteBindAdapter(
		BindContext,
		Status,
		OpenErrorStatus
		);

	return;
}




VOID
RWanNdisCloseAdapterComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of a pended call
	to NdisCloseAdapter. If we were unbinding from the adapter, complete
	the unbind now.

Arguments:

	ProtocolBindingContext	- our context for an adapter binding,
					  which is a pointer to our Adapter structure.
	Status			- Final status of NdisCloseAdapter

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	NDIS_HANDLE					UnbindContext;

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	//
	//  Unlink this adapter from the global list of adapters.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	RWAN_DELETE_FROM_LIST(&(pAdapter->AdapterLink));

	pRWanGlobal->AdapterCount--;

	RWAN_RELEASE_GLOBAL_LOCK();

	UnbindContext = pAdapter->BindContext;

	RWAN_FREE_MEM(pAdapter);

	//
	//  We would have closed the adapter because of one of the following:
	//  1. NDIS told us to Unbind from the adapter -> complete the Unbind
	//  2. We are unloading -> continue this process
	//
	if (UnbindContext != NULL)
	{

		NdisCompleteUnbindAdapter(
				UnbindContext,
				NDIS_STATUS_SUCCESS
				);
	}
	else
	{
		//
		//  We are here because our Unload handler got called.
		//  Wake up the thread that's waiting for this adapter
		//  to be closed.
		//

		RWAN_SIGNAL_EVENT_STRUCT(&pRWanGlobal->Event, Status);
	}

	return;
}




VOID
RWanNdisAfRegisterNotify(
	IN	NDIS_HANDLE					ProtocolContext,
	IN	PCO_ADDRESS_FAMILY			pAddressFamily
	)
/*++

Routine Description:

	This is the NDIS entry point to announce the presence of a
	Call manager supporting a specified Address Family on an
	adapter that we are bound to.

	If this address family is one that we support, we create an
	AF block, and open the address family.

Arguments:

	ProtocolContext	- our context for an adapter binding,
					  which is a pointer to our Adapter structure.
	pAddressFamily	- pointer to structure describing the Address Family

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER		pAdapter;
	NDIS_STATUS				Status;
	PLIST_ENTRY				pAfInfoEntry;
	PRWAN_NDIS_AF_INFO		pAfInfo;
	PRWAN_NDIS_AF			pAf;
	BOOLEAN					bFound;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolContext;

	RWAN_STRUCT_ASSERT(pAdapter, nad);

	do
	{
		//
		//  Create a new NDIS AF block.
		//
		pAf = RWanAllocateAf();

		if (pAf == NULL)
		{
			break;
		}

		pAf->pAdapter = pAdapter;

		RWanReferenceAf(pAf);	// Open AF ref

		//
		//  Search for an AF_INFO structure matching this <NDIS AF, Medium>
		//  pair.
		//
		bFound = FALSE;

		RWAN_ACQUIRE_GLOBAL_LOCK();

		for (pAfInfoEntry = pRWanGlobal->AfInfoList.Flink;
			 pAfInfoEntry != &(pRWanGlobal->AfInfoList);
			 pAfInfoEntry = pAfInfoEntry->Flink)
		{
			pAfInfo = CONTAINING_RECORD(pAfInfoEntry, RWAN_NDIS_AF_INFO, AfInfoLink);

			if ((pAfInfo->AfChars.Medium == pAdapter->Medium)
					&&
				(RWAN_EQUAL_MEM(pAddressFamily,
							   &(pAfInfo->AfChars.AddressFamily),
							   sizeof(*pAddressFamily))))
			{
				bFound = TRUE;
				pAf->pAfInfo = pAfInfo;

				RWAN_INSERT_TAIL_LIST(&(pAfInfo->NdisAfList),
									&(pAf->AfInfoLink));
				break;
			}
		}

		RWAN_RELEASE_GLOBAL_LOCK();

		if (!bFound)
		{
			RWAN_FREE_MEM(pAf);
			break;
		}

		//
		//  Open the Address Family.
		//
		Status = NdisClOpenAddressFamily(
						pAdapter->NdisAdapterHandle,
						pAddressFamily,
						(NDIS_HANDLE)pAf,
						&RWanNdisClientCharacteristics,
						sizeof(RWanNdisClientCharacteristics),
						&(pAf->NdisAfHandle)
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			RWanNdisOpenAddressFamilyComplete(
				Status,
				(NDIS_HANDLE)pAf,
				pAf->NdisAfHandle
				);
		}

		break;
	}
	while (FALSE);

	return;
}




VOID
RWanNdisOpenAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisAfHandle
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of a call
	we made to NdisClOpenAddressFamily. If the Address Family open
	was successful, we store the returned handle in our AF block.
	Otherwise we delete the AF block.

Arguments:

	Status				- Final status of NdisClOpenAddressFamily
	ProtocolAfContext	- Our context for an AF open, which is a pointer
						  to an RWAN_NDIS_AF structure
	NdisAfHandle		- If successful, this is the handle we should use
						  to refer to this AF henceforth

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	NDIS_HANDLE				NdisAdapterHandle;
	PRWAN_NDIS_AF_INFO		pAfInfo;
	INT						rc;
	RWAN_STATUS				RWanStatus;
	ULONG					MaxMsgSize;

	pAf = (PRWAN_NDIS_AF)ProtocolAfContext;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pAf->NdisAfHandle = NdisAfHandle;
		NdisAdapterHandle = pAf->pAdapter->NdisAdapterHandle;

		pAfInfo = pAf->pAfInfo;

		RWAN_RELEASE_AF_LOCK(pAf);

		//
		//  Tell the AF-specific module about this successful AF open,
		//  so that it can initialize and return its context for this open.
		//
		RWanStatus = (*pAfInfo->AfChars.pAfSpOpenAf)(
						pAfInfo->AfSpContext,
						(RWAN_HANDLE)pAf,
						&pAf->AfSpAFContext,
						&MaxMsgSize
						);

		if (RWanStatus != RWAN_STATUS_PENDING)
		{
			RWanAfSpOpenAfComplete(
						RWanStatus,
						(RWAN_HANDLE)pAf,
						pAf->AfSpAFContext,
						MaxMsgSize
						);
		}
	}
	else
	{
		RWANDEBUGP(DL_WARN, DC_WILDCARD,
				("OpenAfComplete: Af x%x, bad status x%x\n", pAf, Status));

		rc = RWanDereferenceAf(pAf);	// Open AF failure

		RWAN_ASSERT(rc == 0);
	}

	return;
}



VOID
RWanShutdownAf(
	IN	PRWAN_NDIS_AF				pAf
	)
/*++

Routine Description:

	Shut down an AF open: deregister all SAPs and abort all calls.

Arguments:

	pAf					- Points to NDIS AF block

Return Value:

	None

--*/
{
	PRWAN_TDI_ADDRESS		pAddrObject;
	PRWAN_NDIS_SAP			pSap;
	PLIST_ENTRY				pSapEntry;
	PLIST_ENTRY				pNextSapEntry;
	NDIS_HANDLE				NdisSapHandle;
	NDIS_STATUS				Status;

	PRWAN_TDI_CONNECTION	pConnObject;
	PLIST_ENTRY				pVcEntry;
	PLIST_ENTRY				pNextVcEntry;
	PRWAN_NDIS_VC			pVc;

	INT						rc;
	RWAN_HANDLE				AfSpAFContext;
	RWAN_STATUS				RWanStatus;

	//
	//  Check if we are already closing this AF.
	//
	RWAN_ACQUIRE_AF_LOCK(pAf);

	RWANDEBUGP(DL_LOUD, DC_BIND,
			("ShutdownAf: AF x%x, Flags x%x, AfHandle x%x\n", pAf, pAf->Flags, pAf->NdisAfHandle));

	if (RWAN_IS_BIT_SET(pAf->Flags, RWANF_AF_CLOSING))
	{
		RWAN_RELEASE_AF_LOCK(pAf);
		return;
	}

	RWAN_SET_BIT(pAf->Flags, RWANF_AF_CLOSING);
	
	//
	//  Make sure the AF doesn't go away while we are here.
	//
	RWanReferenceAf(pAf);	// temp ref: RWanShutdownAf

	//
	//  Deregister all SAPs.
	//
	for (pSapEntry = pAf->NdisSapList.Flink;
		 pSapEntry != &(pAf->NdisSapList);
		 pSapEntry = pNextSapEntry)
	{
		pNextSapEntry = pSapEntry->Flink;

		pSap = CONTAINING_RECORD(pSapEntry, RWAN_NDIS_SAP, AfLink);

		pAddrObject = pSap->pAddrObject;

		RWAN_RELEASE_AF_LOCK(pAf);

		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		if (!RWAN_IS_BIT_SET(pSap->Flags, RWANF_SAP_CLOSING))
		{
			RWAN_SET_BIT(pSap->Flags, RWANF_SAP_CLOSING);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			NdisSapHandle = pSap->NdisSapHandle;
			RWAN_ASSERT(NdisSapHandle != NULL);

			Status = NdisClDeregisterSap(NdisSapHandle);

			if (Status != NDIS_STATUS_PENDING)
			{
				RWanNdisDeregisterSapComplete(
					Status,
					(NDIS_HANDLE)pSap
					);
			}
		}
		else
		{
			//
			//  This SAP is already closing.
			//
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		}
		
		RWAN_ACQUIRE_AF_LOCK(pAf);
	}

	//
	//  Close all connections on this AF.
	//
	for (pVcEntry = pAf->NdisVcList.Flink;
		 pVcEntry != &(pAf->NdisVcList);
		 pVcEntry = pNextVcEntry)
	{
		pNextVcEntry = pVcEntry->Flink;

		pVc = CONTAINING_RECORD(pVcEntry, RWAN_NDIS_VC, VcLink);

		RWAN_STRUCT_ASSERT(pVc, nvc);

		pConnObject = pVc->pConnObject;

		if (pConnObject != NULL)
		{
			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
			RWanReferenceConnObject(pConnObject);   // temp - ShutdownAf
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWAN_RELEASE_AF_LOCK(pAf);

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
			rc = RWanDereferenceConnObject(pConnObject);    // temp - ShutdownAf

			if (rc != 0)
			{
				RWanDoTdiDisconnect(
					pConnObject,
					NULL,			// pTdiRequest,
					NULL,			// pTimeout
					0,				// Flags
					NULL,			// pDisconnInfo
					NULL			// pReturnInfo
					);
				//
				//  Conn Object lock is released within the above.
				//
			}
			
			RWAN_ACQUIRE_AF_LOCK(pAf);
		}
	}

	//
	//  Tell the Media-specific module to clean up because this AF
	//  is being closed.
	//
	AfSpAFContext = pAf->AfSpAFContext;

	RWAN_RELEASE_AF_LOCK(pAf);

	if (AfSpAFContext != NULL)
	{
		RWAN_ASSERT(pAf->pAfInfo->AfChars.pAfSpCloseAf != NULL);

		RWanStatus = (*pAf->pAfInfo->AfChars.pAfSpCloseAf)(AfSpAFContext);

		if (RWanStatus != RWAN_STATUS_PENDING)
		{
			RWanAfSpCloseAfComplete((RWAN_HANDLE)pAf);
		}
	}
	else
	{
		//
		//  We don't have to inform the media-specific module.
		//
		RWanAfSpCloseAfComplete((RWAN_HANDLE)pAf);
	}


	RWAN_ACQUIRE_AF_LOCK(pAf);

	rc = RWanDereferenceAf(pAf);	// temp ref: RWanShutdownAf

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}
	//
	//  else the AF is gone.
	//

	return;
}




VOID
RWanNdisCloseAddressFamilyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of
	a call to NdisClCloseAddressFamily.

Arguments:

	Status			- Final status of the Close AF
	OurAfContext	- Pointer to AF block

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	INT						rc;

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pAf = (PRWAN_NDIS_AF)OurAfContext;
	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	rc = RWanDereferenceAf(pAf);		// CloseAfComplete

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}
	
	return;
}




PNDIS_MEDIUM
RWanGetSupportedMedia(
	OUT	PULONG						pMediaCount
	)
/*++

Routine Description:

	Return a list of NDIS Media types that we support.

Arguments:

	pMediaCount - Place to return the number of media types.

Return Value:

	An allocated and filled list of media types. The caller is responsible
	for freeing this via RWAN_FREE_MEM.

--*/
{
	PNDIS_MEDIUM			pMediaArray;
	UINT					NumMedia;
	UINT					i;

	PLIST_ENTRY				pAfInfoEntry;
	PRWAN_NDIS_AF_INFO		pAfInfo;

	pMediaArray = NULL;

	do
	{
		RWAN_ACQUIRE_GLOBAL_LOCK();

		//
		//  An upper bound on the total number of media types supported
		//  is this:
		//
		NumMedia = pRWanGlobal->AfInfoCount;

		if (NumMedia == 0)
		{
			break;
		}

		RWAN_ALLOC_MEM(pMediaArray, NDIS_MEDIUM, NumMedia * sizeof(NDIS_MEDIUM));

		if (pMediaArray == NULL)
		{
			break;
		}

		NumMedia = 0;

		for (pAfInfoEntry = pRWanGlobal->AfInfoList.Flink;
			 pAfInfoEntry != &(pRWanGlobal->AfInfoList);
			 pAfInfoEntry = pAfInfoEntry->Flink)
		{
			NDIS_MEDIUM		Medium;

			pAfInfo = CONTAINING_RECORD(pAfInfoEntry, RWAN_NDIS_AF_INFO, AfInfoLink);

			Medium = pAfInfo->AfChars.Medium;

			//
			//  Check if this medium type is already in the output list.
			//
			for (i = 0; i < NumMedia; i++)
			{
				if (pMediaArray[i] == Medium)
				{
					break;
				}
			}

			if (i == NumMedia)
			{
				//
				//  This is the first time we've seen this Medium type.
				//  Create a new entry.
				//
				pMediaArray[i] = Medium;
				NumMedia++;
			}
		}

		RWAN_RELEASE_GLOBAL_LOCK();

		if (NumMedia == 0)
		{
			RWAN_FREE_MEM(pMediaArray);
			pMediaArray = NULL;
		}

		break;
	}
	while (FALSE);

	*pMediaCount = NumMedia;

	return (pMediaArray);

}



VOID
RWanCloseAdapter(
	IN	PRWAN_NDIS_ADAPTER			pAdapter
	)
/*++

Routine Description:

	Initiate closing an adapter. The caller is assumed to hold
	the adapter lock, which will be released here.

Arguments:

	pAdapter			- Points to adapter to be closed

Return Value:

	None

--*/
{
	NDIS_HANDLE				NdisAdapterHandle;
	NDIS_STATUS				Status;

	NdisAdapterHandle = pAdapter->NdisAdapterHandle;

	RWAN_ASSERT(NdisAdapterHandle != NULL);
	RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&(pAdapter->AfList)));

	pAdapter->State = RWANS_AD_CLOSING;

	RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

	NdisCloseAdapter(
			&Status,
			NdisAdapterHandle
			);

	if (Status != NDIS_STATUS_PENDING)
	{
		RWanNdisCloseAdapterComplete(
			(NDIS_HANDLE)pAdapter,
			Status
			);
	}
}



VOID
RWanNdisRequestComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	PNDIS_REQUEST				pNdisRequest,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

	This is the NDIS entry point called when a previous pended call
	to NdisRequest() has completed. We would have called NdisRequest
	on behalf of the media-specific module. Complete it now.

Arguments:

	OurBindingContext	- Points to our adapter structure
	pNdisRequest		- Points to completed request
	Status				- Final status of the request

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	PRWAN_NDIS_REQ_CONTEXT		pReqContext;

	pAdapter = (PRWAN_NDIS_ADAPTER)OurBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	pReqContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAdapterRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.QUERY_INFORMATION.Oid,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength
				);
	}
	else
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAdapterRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.SET_INFORMATION.Oid,
				pNdisRequest->DATA.SET_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength
				);
	}

	RWAN_FREE_MEM(pNdisRequest);

	return;
}



VOID
RWanNdisStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}




VOID
RWanNdisCoStatus(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_STATUS					GeneralStatus,
	IN	PVOID						StatusBuffer,
	IN	UINT						StatusBufferSize
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}




VOID
RWanNdisStatusComplete(
	IN	NDIS_HANDLE					OurBindingContext
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}




NDIS_STATUS
RWanNdisCoRequest(
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN OUT PNDIS_REQUEST			pNdisRequest
	)
/*++

Routine Description:

	Handle events from the Call Manager.

Arguments:

	OurAfContext		- Points to our AF structure
	OurVcContext		- If not NULL, points to our VC structure
	OurPartyContext		- If not NULL, points to our Party structure
	pNdisRequest		- Points to request

Return Value:

	NDIS_STATUS_SUCCESS if the OID is one that we know about, else
	NDIS_STATUS_NOT_RECOGNIZED.

--*/
{
	NDIS_STATUS			Status;
	PRWAN_NDIS_AF		pAf;

	Status = NDIS_STATUS_SUCCESS;

	if (pNdisRequest->RequestType == NdisRequestSetInformation)
	{
		switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
		{
			case OID_CO_ADDRESS_CHANGE:

				break;

			case OID_CO_AF_CLOSE:
				//
				//  The Call manager wants us to shutdown this AF open.
				//
				pAf = (PRWAN_NDIS_AF)OurAfContext;
				RWAN_STRUCT_ASSERT(pAf, naf);

				RWanShutdownAf(pAf);

				break;
				
			default:

				Status = NDIS_STATUS_NOT_RECOGNIZED;
				break;
		}
	}

	return (Status);
}




VOID
RWanNdisCoRequestComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurAfContext,
	IN	NDIS_HANDLE					OurVcContext OPTIONAL,
	IN	NDIS_HANDLE					OurPartyContext OPTIONAL,
	IN	PNDIS_REQUEST				pNdisRequest
	)
/*++

Routine Description:

	Handle completion of a CO-request we had sent to the Call Manager on
	behalf of a media-specific module. Inform the media-specific module
	of this completion.

Arguments:

	Status				- Status of request.
	OurAfContext		- Points to our AF structure
	OurVcContext		- If not NULL, points to our VC structure
	OurPartyContext		- If not NULL, points to our Party structure
	pNdisRequest		- Points to request

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF				pAf;
	PRWAN_NDIS_REQ_CONTEXT		pReqContext;

	pAf = (PRWAN_NDIS_AF)OurAfContext;
	RWAN_STRUCT_ASSERT(pAf, naf);

	pReqContext = (PRWAN_NDIS_REQ_CONTEXT)((PUCHAR)pNdisRequest + sizeof(NDIS_REQUEST));

	if (pNdisRequest->RequestType == NdisRequestQueryInformation)
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAfRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.QUERY_INFORMATION.Oid,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength
				);
	}
	else
	{
		(*pReqContext->pAf->pAfInfo->AfChars.pAfSpAfRequestComplete)(
				Status,
				pReqContext->pAf->AfSpAFContext,
				pReqContext->AfSpReqContext,
				pNdisRequest->RequestType,
				pNdisRequest->DATA.SET_INFORMATION.Oid,
				pNdisRequest->DATA.SET_INFORMATION.InformationBuffer,
				pNdisRequest->DATA.SET_INFORMATION.InformationBufferLength
				);
	}

	RWAN_FREE_MEM(pNdisRequest);

	return;
}



NDIS_STATUS
RWanNdisReset(
	IN	NDIS_HANDLE					OurBindingContext
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return (NDIS_STATUS_SUCCESS);
}




VOID
RWanNdisResetComplete(
	IN	NDIS_HANDLE					OurBindingContext,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Ignore this.
	//
	return;
}



NDIS_STATUS
RWanNdisPnPEvent(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Handle a PnP Event from NDIS. The event structure contains the event
	code, includes power-management events and reconfigure events.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure. Could be
							  NULL for notification of global config changes
	pNetPnPEvent			- Points to event structure

Return Value:

	NDIS_STATUS_SUCCESS if we processed the event successfully.
	NDIS_STATUS_NOT_SUPPORTED for unsupported notifications.

--*/
{
	NDIS_STATUS				Status;
	PRWAN_NDIS_ADAPTER		pAdapter;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;

	switch (pNetPnPEvent->NetEvent)
	{
		case NetEventSetPower:

			Status = RWanNdisPnPSetPower(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventQueryPower:

			Status = RWanNdisPnPQueryPower(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventQueryRemoveDevice:

			Status = RWanNdisPnPQueryRemove(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventCancelRemoveDevice:

			Status = RWanNdisPnPCancelRemove(pAdapter, pNetPnPEvent);
			break;
		
		case NetEventReconfigure:

			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		
		case NetEventBindList:

			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
		
		default:

			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
	}

	return (Status);
}


NDIS_STATUS
RWanNdisPnPSetPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Handle a Set Power event.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS if we successfully processed this event,
	NDIS_STATUS_XXX error code otherwise.

--*/
{
	PNET_DEVICE_POWER_STATE		pPowerState;
	NDIS_STATUS					Status;

	pPowerState = (PNET_DEVICE_POWER_STATE)pNetPnPEvent->Buffer;
	
	switch (*pPowerState)
	{
		case NetDeviceStateD0:

			Status = NDIS_STATUS_SUCCESS;
			break;

		default:
			
			//
			//  We can't suspend, so we ask NDIS to unbind us
			//  by returning this status:
			//
			Status = NDIS_STATUS_NOT_SUPPORTED;
			break;
	}

	return (Status);
}


NDIS_STATUS
RWanNdisPnPQueryPower(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Called to see if we allow power to be shut off to the adapter.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RWanNdisPnPQueryRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
	)
/*++

Routine Description:

	Called to see if we allow the adapter to be removed.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	return (NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
RWanNdisPnPCancelRemove(
	IN	PRWAN_NDIS_ADAPTER			pAdapter,
	IN	PNET_PNP_EVENT				pNetPnPEvent
)
/*++

Routine Description:

	Called to cancel the above remove.

Arguments:

	pAdapter		- Points to our adapter structure
	pNetPnPEvent	- Points to event to be processed.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	return (NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\rwannt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\rwannt.h

Abstract:

	NT-specific definitions for Raw WAN.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-17-97    Created

Notes:

--*/

#ifndef __TDI_RWANNT__H
#define __TDI_RWANNT__H

#ifdef NT


#if DBG_LOG_EP

#define MAX_EP_LOG_ENTRIES			32

typedef struct _RWAND_EP_LOG_ENTRY
{
	ULONG							LineNumber;
	ULONG							Event;
	PVOID							Context1;
	PVOID							Context2;

} RWAND_EP_LOG_ENTRY, *PRWAND_EP_LOG_ENTRY;

#define RWAN_EP_DBGLOG_SET_SIGNATURE(_pEp)						\
	(_pEp)->EpLogSig = 'GOLE'

#define RWAN_EP_DBGLOG_ENTRY(_pEp, _Event, _Ctx1, _Ctx2)		\
{																\
	PRWAND_EP_LOG_ENTRY		pLogEnt;							\
	ULONG					Index;								\
	NdisAcquireSpinLock(&RWanDbgLogLock);						\
	(_pEp)->EpLogCount++;										\
	Index = (_pEp)->EpLogIndex;									\
	pLogEnt = &((_pEp)->EpLog[Index]);							\
	pLogEnt->LineNumber = __LINE__;								\
	pLogEnt->Event = _Event;									\
	pLogEnt->Context1 = (PVOID)_Ctx1;							\
	pLogEnt->Context2 = (PVOID)_Ctx2;							\
	(_pEp)->EpLogIndex++;										\
	if ((_pEp)->EpLogIndex == MAX_EP_LOG_ENTRIES)				\
	{															\
		(_pEp)->EpLogIndex = 0;									\
	}															\
	NdisReleaseSpinLock(&RWanDbgLogLock);						\
}


#else

#define RWAN_EP_DBGLOG_SET_SIGNATURE(_pEp)	
#define RWAN_EP_DBGLOG_ENTRY(_pEp, _Event, _Ctx1, _Ctx2)

#endif

//
//  ***** Endpoint *****
//
//  One of these is allocated for each MJ_CREATE successfully processed.
//  A pointer to this structure is returned in FileObject->FsContext.
//
//  The object it represents is one of these:
//  Address object, Connection object, Control channel.
//
//  Reference Count: RefCount is incremented for each of the following:
//  - for the duration an IRP pertaining to this object is pending
//
typedef struct RWAN_ENDPOINT
{
#if DBG
	ULONG							nep_sig;
#endif
#ifdef REFDBG
	ULONG							SendIncrRefs;
	ULONG							RecvIncrRefs;
	ULONG							CloseComplDecrRefs;
	ULONG							DataReqComplDecrRefs;
	ULONG							CancelComplDecrRefs;
	ULONG							CancelIncrRefs;
	ULONG							NonDataIncrRefs;
#endif
#if DBG
	PVOID							pConnObject;			// Transport's context
#endif
	union
	{
		HANDLE					AddressHandle;				// Address Object
		CONNECTION_CONTEXT		ConnectionContext;			// Connection Object
		HANDLE					ControlChannel;				// Control channel

	}								Handle;
	struct _RWAN_TDI_PROTOCOL *		pProtocol;
	ULONG							RefCount;
	BOOLEAN							bCancelIrps;			// are we cleaning up?
	KEVENT							CleanupEvent;			// synchronization
#if DBG_LOG_EP
	ULONG							EpLogSig;
	ULONG							EpLogCount;
	ULONG							EpLogIndex;
	struct _RWAND_EP_LOG_ENTRY		EpLog[MAX_EP_LOG_ENTRIES];
#endif

} RWAN_ENDPOINT, *PRWAN_ENDPOINT;

#if DBG
#define nep_signature				'NlEp'
#endif // DBG

#define NULL_PRWAN_ENDPOINT			((PRWAN_ENDPOINT)NULL)




//
//  ***** Device Object *****
//
//  We create one NT device object for each TDI protocol that we
//  expose i.e. each Winsock triple <Family, Proto, Type>.
//
typedef struct _RWAN_DEVICE_OBJECT
{
#if DBG
	ULONG							ndo_sig;
#endif // DBG
	PDEVICE_OBJECT					pDeviceObject;			// NT device object
	struct _RWAN_TDI_PROTOCOL *		pProtocol;				// Info about the protocol
	LIST_ENTRY						DeviceObjectLink;		// in list of device objs

} RWAN_DEVICE_OBJECT, *PRWAN_DEVICE_OBJECT;

#if DBG
#define ndo_signature				'NlDo'
#endif // DBG



#ifdef REFDBG

#define RWAN_INCR_EP_REF_CNT(_pEp, _Type)	\
		{									\
			(_pEp)->RefCount++;				\
			(_pEp)->_Type##Refs++;			\
		}

#define RWAN_DECR_EP_REF_CNT(_pEp, _Type)	\
		{									\
			(_pEp)->RefCount--;				\
			(_pEp)->_Type##Refs--;			\
		}

#else

#define RWAN_INCR_EP_REF_CNT(_pEp, _Type)	\
			(_pEp)->RefCount++;

#define RWAN_DECR_EP_REF_CNT(_pEp, _Type)	\
			(_pEp)->RefCount--;

#endif // REFDBG

/*++
LARGE_INTEGER
RWAN_CONVERT_100NS_TO_MS(
	IN	LARGE_INTEGER				HnsTime,
	OUT	PULONG						pRemainder
	)
--*/
#define RWAN_CONVERT_100NS_TO_MS(_HnsTime, _pRemainder)	\
			RtlExtendedLargeIntegerDivide(_HnsTime, 10000, _pRemainder);

#endif // NT

#endif // __TDI_RWANNT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\rwandata.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\nltdata.h

Abstract:

	All private data structure definitions for Null Transport.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-17-97    Created

Notes:

--*/

#ifndef __TDI_RWANDATA__H
#define __TDI_RWANDATA__H



//
//  Forward definitions
//
struct _RWAN_TDI_CONNECTION ;
struct _RWAN_TDI_ADDRESS ;
struct _RWAN_NDIS_VC ;
struct _RWAN_NDIS_SAP ;
struct _RWAN_NDIS_AF ;
struct _RWAN_NDIS_AF_INFO ;
struct _RWAN_TDI_PROTOCOL ;

struct _RWAN_CONN_REQUEST ;
struct _RWAN_RECEIVE_INDICATION ;


typedef UCHAR				RWAN_CONN_INSTANCE;
typedef ULONG				RWAN_CONN_ID;



//
//  Completion routines.
//
typedef
VOID
(*PCOMPLETE_RTN)(PVOID CompletionContext, UINT, UINT);

typedef
VOID
(*PDATA_COMPLETE_RTN)(PVOID CompletionContext, UINT Status, UINT ByteCount);

typedef
VOID
(*PDELETE_COMPLETE_RTN)(PVOID CompletionContext);


//
//  A structure to hold a call-back routine and context to
//  be called when a structure is dereferenced away.
//
typedef struct _RWAN_DELETE_NOTIFY
{
	PCOMPLETE_RTN					pDeleteRtn;
	PVOID							DeleteContext;

} RWAN_DELETE_NOTIFY, *PRWAN_DELETE_NOTIFY;




//
//  ***** TDI Connection Object *****
//
//  Our context for a TDI Connection Object. This is created during
//  TdiOpenConnection(), and deleted during TdiCloseConnection().
//
//  Reference Count keeps track of:
//  - TdiOpenConnection
//  - Linkage to Address Object
//  - Linkage to NDIS VC or NDIS Party
//  - Each party in list on VC (for C-Root)
//  - Each work item queued for this Conn Object
//
typedef struct _RWAN_TDI_CONNECTION
{
#if DBG
	ULONG							ntc_sig;
#endif
	INT								RefCount;
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	PVOID							ConnectionHandle;	// TDI handle
	struct _RWAN_TDI_ADDRESS *		pAddrObject;		// Associated Address Object
	LIST_ENTRY						ConnLink;			// In list of connections on
														// address object
	RWAN_HANDLE						AfSpConnContext;	// Media-Sp module's context
	RWAN_LOCK						Lock;				// Mutex
	union {
		struct _RWAN_NDIS_VC *	pNdisVc;
		struct _RWAN_NDIS_PARTY *pNdisParty;
	}								NdisConnection;
	struct _RWAN_TDI_CONNECTION *	pRootConnObject;	// For PMP Calls
	RWAN_CONN_INSTANCE				ConnInstance;		// Used to validate Conn Context
	RWAN_DELETE_NOTIFY				DeleteNotify;		// Things to do on freeing this
	struct _RWAN_CONN_REQUEST *		pConnReq;			// Info about a pended TDI request
	NDIS_WORK_ITEM					CloseWorkItem;		// Used to schedule a Close
	struct _RWAN_NDIS_VC *			pNdisVcSave;
#if DBG
	ULONG							ntcd_sig;
	USHORT							OldState;
	USHORT							OldFlags;
#endif

} RWAN_TDI_CONNECTION, *PRWAN_TDI_CONNECTION;

#if DBG
#define ntc_signature				'cTwR'
#endif // DBG

#define NULL_PRWAN_TDI_CONNECTION	((PRWAN_TDI_CONNECTION)NULL)

//
//  TDI Connection Object states
//
#define RWANS_CO_CREATED			0x0000	// After TdiOpenConnection
#define RWANS_CO_ASSOCIATED			0x0001	// After TdiAssociateAddress
#define RWANS_CO_LISTENING			0x0002	// After TdiListen
#define RWANS_CO_OUT_CALL_INITIATED	0x0003	// TdiConnect in progress
#define RWANS_CO_IN_CALL_INDICATED	0x0004	// Incoming call indicated to user
#define RWANS_CO_IN_CALL_ACCEPTING	0x0005	// TdiAccept in progress
#define RWANS_CO_CONNECTED			0x0006	// Connection established
#define RWANS_CO_DISCON_INDICATED	0x0007	// Incoming release indicated to user
#define RWANS_CO_DISCON_HELD		0x0008	// Incoming release not indicated to user
#define RWANS_CO_DISCON_REQUESTED	0x0009	// TdiDisconnect in progress
#define RWANS_CO_ABORTING			0x000A	// Aborting

//
//  TDI Connection Object flags
//
#define RWANF_CO_LEAF				0x0001	// This is a PMP leaf conn object
#define RWANF_CO_ROOT				0x0002	// This is a PMP root conn object
#define RWANF_CO_INDICATING_DATA	0x0010	// Receive processing going on
#define RWANF_CO_PAUSE_RECEIVE		0x0020	// The TDI Client has paused receiving
#define RWANF_CO_AFSP_CONTEXT_VALID	0x0040	// AfSpConnContext is valid
#define RWANF_CO_PENDED_DISCON		0x0100	// Pended a DisconInd until data ind is over
#define RWANF_CO_CLOSE_SCHEDULED	0x4000	// Scheduled work item for Closing
#define RWANF_CO_CLOSING			0x8000	// TdiCloseConnection in progress




//
//  ***** TDI Address Object *****
//
//  This is created on processing TdiOpenAddress, and deleted during
//  TdiCloseAddress. If this is a non-NULL (i.e. listening) address object,
//  we also register NDIS SAPs on all adapters supporting this address
//  family.
//
//  Reference Count keeps track of:
//  - TdiOpenAddress
//  - Each Connection Object associated with this
//  - Each NDIS SAP registered for this
//  
typedef struct _RWAN_TDI_ADDRESS
{
#if DBG
	ULONG							nta_sig;
#endif // DBG
	INT								RefCount;
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	struct _RWAN_TDI_PROTOCOL *		pProtocol;			// Back ptr to protocol
	RWAN_HANDLE						AfSpAddrContext;	// Media-Sp module's context
	struct _RWAN_TDI_CONNECTION *	pRootConnObject;	// For PMP Calls
	LIST_ENTRY						AddrLink;			// In list of Address Objects
	LIST_ENTRY						IdleConnList;		// After TDI_ASSOCIATE_ADDRESS
	LIST_ENTRY						ListenConnList;		// After TDI_LISTEN
	LIST_ENTRY						ActiveConnList;		// After connection setup
	LIST_ENTRY						SapList;			// List of RWAN_NDIS_SAP structs
	RWAN_EVENT						Event;				// Used for synchronization
	RWAN_LOCK						Lock;				// Mutex
	RWAN_DELETE_NOTIFY				DeleteNotify;		// Things to do on freeing this
	PConnectEvent					pConnInd;			// Connect Indication up-call
	PVOID							ConnIndContext;		// Context for Connect
	PDisconnectEvent				pDisconInd;			// Disconnect Indication up-call
	PVOID							DisconIndContext;	// Context for Disconnect
	PErrorEvent						pErrorInd;			// Error Indication up-call
	PVOID							ErrorIndContext;	// Context for Error
	PRcvEvent						pRcvInd;			// Receive Indication up-call
	PVOID							RcvIndContext;		// Context for Receive
	USHORT							AddressType;		// From TdiOpenAddress
	USHORT							AddressLength;		// From TdiOpenAddress
	PVOID							pAddress;			// Protocol-dependent string
	NDIS_STATUS						SapStatus;			// Failure from RegisterSap

} RWAN_TDI_ADDRESS, *PRWAN_TDI_ADDRESS;

#if DBG
#define nta_signature				'aTwR'
#endif // DBG

#define NULL_PRWAN_TDI_ADDRESS		((PRWAN_TDI_ADDRESS)NULL)

//
//  Bit definitions for Flags in RWAN_TDI_ADDRESS
//
#define RWANF_AO_PMP_ROOT				0x0001			// Root of an outgoing PMP call
#define RWANF_AO_CLOSING				0x8000			// TdiCloseAddress() in progress
#define RWANF_AO_AFSP_CONTEXT_VALID		0x0040			// AfSpAddrContext is valid



//
//  ***** NDIS VC Block *****
//
//  Created during a CoCreateVc operation, and contains our context for
//  an NDIS VC. For an outgoing call, creation is initiated by us, by
//  calling NdisCoCreateVc. For an incoming call, the Call Manager initiates
//  VC creation.
//
typedef struct _RWAN_NDIS_VC
{
#if DBG
	ULONG							nvc_sig;
#endif
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	NDIS_HANDLE						NdisVcHandle;		// For all NDIS calls
	struct _RWAN_TDI_CONNECTION *	pConnObject;		// To Connection Object
	PCO_CALL_PARAMETERS				pCallParameters;	// Call setup parameters
	struct _RWAN_NDIS_AF *			pNdisAf;			// Back pointer
	struct _RWAN_NDIS_PARTY *		pPartyMakeCall;		// First party in PMP call
	LIST_ENTRY						VcLink;				// In list of all VCs on AF
	LIST_ENTRY						NdisPartyList;		// List of NDIS Party (PMP only)
	ULONG							AddingPartyCount;	// Pending NdisClAddParty/MakeCall
	ULONG							ActivePartyCount;	// Connected parties
	ULONG							DroppingPartyCount;	// Pending NdisClDropParty
	ULONG							PendingPacketCount;	// Pending send+rcv packets
	ULONG							MaxSendSize;
	struct _RWAN_RECEIVE_INDICATION *pRcvIndHead;		// Head of the receive ind queue
	struct _RWAN_RECEIVE_INDICATION *pRcvIndTail;		// Tail of the receive ind queue
	struct _RWAN_RECEIVE_REQUEST *	pRcvReqHead;		// Head of the receive req queue
	struct _RWAN_RECEIVE_REQUEST *	pRcvReqTail;		// Tail of the receive req queue
#if DBG_LOG_PACKETS
	ULONG							DataLogSig;
	ULONG							Index;
	struct _RWAND_DATA_LOG_ENTRY	DataLog[MAX_RWAND_PKT_LOG];
#endif
} RWAN_NDIS_VC, *PRWAN_NDIS_VC;

#if DBG
#define nvc_signature				'cVwR'
#endif // DBG

#define NULL_PRWAN_NDIS_VC			((PRWAN_NDIS_VC)NULL)

//
//  NDIS VC flags
//
#define RWANF_VC_OUTGOING			0x0001	// Created by us.
#define RWANF_VC_PMP				0x0002	// Point to Multipoint call
#define RWANF_VC_CLOSING_CALL		0x8000	// NdisClCloseCall in progress
#define RWANF_VC_NEEDS_CLOSE		0x4000	// Waiting for conditions to be right
											// for NdisClCloseCall

//
// Various events seen on the VC
//
#define RWANF_VC_EVT_MAKECALL_OK	0x0010
#define RWANF_VC_EVT_MAKECALL_FAIL	0x0020
#define RWANF_VC_EVT_INCALL			0x0040
#define RWANF_VC_EVT_CALLCONN		0x0080
#define RWANF_VC_EVT_INCLOSE		0x0100
#define RWANF_VC_EVT_CLOSECOMP		0x0200


//
//  ***** NDIS Party Block *****
//
//  Represents our context for a party of an outgoing point to multipoint
//  NDIS call. This is created on processing a Winsock2 JoinLeaf, and deleted
//  when the leaf is no longer a member of the connection.
//
typedef struct _RWAN_NDIS_PARTY
{
#if DBG
	ULONG							npy_sig;
#endif // DBG
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	NDIS_HANDLE						NdisPartyHandle;	// Supplied by NDIS
	struct _RWAN_NDIS_VC *			pVc;				// Back pointer
	struct _RWAN_TDI_CONNECTION *	pConnObject;		// To Connection Object
	LIST_ENTRY						PartyLink;			// To next party on VC
	PCO_CALL_PARAMETERS				pCallParameters;	// Party setup parameters

} RWAN_NDIS_PARTY, *PRWAN_NDIS_PARTY;

#if DBG
#define npy_signature				'yPwR'
#endif // DBG

#define NULL_PRWAN_NDIS_PARTY		((PRWAN_NDIS_PARTY)NULL)

#define RWANF_PARTY_DROPPING		0x8000


//
//  ***** NDIS SAP Block *****
//
//  This represents our context for an NDIS Service Access Point (SAP).
//  When a new Address Object is created, and it represents a listening
//  endpoint, we register SAPs on all adapters that support the bound
//  address family. A SAP block contains information for one such SAP.
//
typedef struct _RWAN_NDIS_SAP
{
#if DBG
	ULONG							nsp_sig;
#endif // DBG
	struct _RWAN_TDI_ADDRESS *		pAddrObject;		// Back pointer
	USHORT							Flags;
	LIST_ENTRY						AddrObjLink;		// To list of SAPs on addr object
	LIST_ENTRY						AfLink;				// To list of SAPs on AF
	NDIS_HANDLE						NdisSapHandle;		// Supplied by NDIS
	struct _RWAN_NDIS_AF *			pNdisAf;			// Back pointer
	PCO_SAP							pCoSap;

} RWAN_NDIS_SAP, *PRWAN_NDIS_SAP;

#if DBG
#define nsp_signature				'pSwR'
#endif // DBG

#define NULL_PRWAN_NDIS_SAP			((PRWAN_NDIS_SAP)NULL)

#define RWANF_SAP_CLOSING			0x8000



//
//  ***** NDIS AF Block *****
//
//  This represents our context for an NDIS Address Family open.
//  When we get notified of a Call Manager that supports a protocol
//  that is of interest to us, on an adapter that we are bound to,
//  we open the AF represented by the Call Manager. This goes away
//  when we unbind from the adapter.
//
//  Note that there could be multiple Call Managers running over
//  a single adapter, each supporting a different NDIS AF.
//
//  An NDIS AF supports one or more Winsock2 triples: <Family, Type, Proto>.
//
//  Reference Count keeps track of:
//  - OpenAf
//  - Each VC on this AF open
//  - Each SAP on this AF open
// 
typedef struct _RWAN_NDIS_AF
{
#if DBG
	ULONG							naf_sig;
#endif // DBG
	INT								RefCount;			// Reference Count
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	LIST_ENTRY						AfLink;				// In list of AFs on adapter
	NDIS_HANDLE						NdisAfHandle;		// Supplied by NDIS
	LIST_ENTRY						NdisVcList;			// List of open VCs
	LIST_ENTRY						NdisSapList;		// List of registered SAPs
	RWAN_HANDLE						AfSpAFContext;		// AF-specific module's context
														// for this open
	struct _RWAN_NDIS_ADAPTER *		pAdapter;			// Back pointer
	struct _RWAN_NDIS_AF_INFO *		pAfInfo;			// Information about this NDIS AF
	LIST_ENTRY						AfInfoLink;			// In list of AFs with same Info
	RWAN_LOCK						Lock;				// Mutex
	ULONG							MaxAddrLength;		// For this Address Family
	RWAN_DELETE_NOTIFY				DeleteNotify;		// Things to do on freeing this

} RWAN_NDIS_AF, *PRWAN_NDIS_AF;

#if DBG
#define naf_signature				'fAwR'
#endif // DBG

#define NULL_PRWAN_NDIS_AF			((PRWAN_NDIS_AF)NULL)

#define RWANF_AF_CLOSING			0x8000
#define RWANF_AF_IN_ADAPTER_LIST	0x0001				// AfLink is valid



//
//  ***** NDIS Adapter Block *****
//
//  This is our context for an NDIS Adapter Binding. One of these is
//  created for each adapter that we bind to.
//
typedef struct _RWAN_NDIS_ADAPTER
{
#if DBG
	ULONG							nad_sig;
#endif
	USHORT							State;
	USHORT							Flags;				// Pending events etc
	NDIS_HANDLE						NdisAdapterHandle;	// Supplied by NDIS
	NDIS_MEDIUM						Medium;				// Supported by adapter
	PNDIS_MEDIUM					pMediaArray;		// Used in NdisOpenAdapter
	UINT							MediumIndex;		// Used in NdisOpenAdapter
	PVOID							BindContext;		// From BindAdapter/UnbindAdapter
	RWAN_LOCK						Lock;				// Mutex
	LIST_ENTRY						AdapterLink;		// In list of all adapters
	LIST_ENTRY						AfList;				// List of opened AFs on adapter
	struct _RWAN_RECEIVE_INDICATION *pCompletedReceives;	// List of completed rcv indns
	NDIS_STRING						DeviceName;			// Name of adapter

} RWAN_NDIS_ADAPTER, *PRWAN_NDIS_ADAPTER;

#if DBG
#define nad_signature				'dAwR'
#endif // DBG

#define NULL_PRWAN_NDIS_ADAPTER		((PRWAN_NDIS_ADAPTER)NULL)

//
//  Adapter states:
//
#define RWANS_AD_CREATED			0x0000
#define RWANS_AD_OPENING			0x0001
#define RWANS_AD_OPENED				0x0002
#define RWANS_AD_CLOSING			0x0003

//
//  Adapter flags:
//
#define RWANF_AD_UNBIND_PENDING		0x0001



//
//  ***** TDI Protocol Block *****
//
//  Maintains information about one Winsock protocol <Family, Protocol, Type>
//  supported by NullTrans. On NT, each TDI protocol block is represented
//  by a Device Object.
//
typedef struct _RWAN_TDI_PROTOCOL
{
#if DBG
	ULONG							ntp_sig;
#endif // DBG
	UINT							TdiProtocol;		// Matches TdiOpenAddress
	UINT							SockAddressFamily;
	UINT							SockProtocol;
	UINT							SockType;
	PVOID							pRWanDeviceObject;	// NT: to RWAN_DEVICE_OBJECT
	BOOLEAN							bAllowAddressObjects;
	BOOLEAN							bAllowConnObjects;
	USHORT							MaxAddrLength;		// For this TDI protocol
	LIST_ENTRY						AddrObjList;		// List of open AddressObjects
	LIST_ENTRY						TdiProtocolLink;	// In list of all TDI protocols
	struct _RWAN_NDIS_AF_INFO *		pAfInfo;			// NDIS Address Family
	LIST_ENTRY						AfInfoLink;			// List of TDI Protocols on AfInfo
	RWAN_EVENT						Event;				// Used for synchronization
	AFSP_DEREG_TDI_PROTO_COMP_HANDLER   pAfSpDeregTdiProtocolComplete;
	TDI_PROVIDER_INFO				ProviderInfo;
	TDI_PROVIDER_STATISTICS			ProviderStats;

} RWAN_TDI_PROTOCOL, *PRWAN_TDI_PROTOCOL;

#if DBG
#define ntp_signature				'pTwR'
#endif // DBG

#define NULL_PRWAN_TDI_PROTOCOL		((PRWAN_TDI_PROTOCOL)NULL)



//
//  ***** NDIS Address-Family Information Block *****
//
//  This contains information about a supported <NDIS AF, NDIS Medium> pair.
//  Each such pair could support one or more TDI Protocols, each identified by a
//  <Family, Protocol, Type> triple.
// 
typedef struct _RWAN_NDIS_AF_INFO
{
#if DBG
	ULONG							nai_sig;
#endif // DBG
	USHORT							Flags;
	LIST_ENTRY						AfInfoLink;			// In list of supported NDIS AFs
	LIST_ENTRY						TdiProtocolList;	// List of RWAN_TDI_PROTOCOL
	LIST_ENTRY						NdisAfList;			// List of RWAN_NDIS_AF
	RWAN_HANDLE						AfSpContext;		// AF-specific module's context
	RWAN_NDIS_AF_CHARS				AfChars;

} RWAN_NDIS_AF_INFO, *PRWAN_NDIS_AF_INFO;

#if DBG
#define nai_signature				'iAwR'
#endif // DBG

#define RWANF_AFI_CLOSING			0x8000



//
//  ***** Global Information Block *****
//
//  Root of all information for NullTrans. One of these structures exists
//  per system.
//
typedef struct _RWAN_GLOBALS
{
#if DBG
	ULONG							nlg_sig;
#endif // DBG
	NDIS_HANDLE						ProtocolHandle;		// from NdisRegisterProtocol
	LIST_ENTRY						AfInfoList;			// All supported NDIS AFs
	ULONG							AfInfoCount;		// Size of above list
	LIST_ENTRY						ProtocolList;		// All supported TDI protocols
	ULONG							ProtocolCount;		// Size of above list
	LIST_ENTRY						AdapterList;		// All bound adapters
	ULONG							AdapterCount;		// Size of above list
	RWAN_LOCK						GlobalLock;			// Mutex
	RWAN_LOCK						AddressListLock;	// Mutex for AddrObject table
	RWAN_LOCK						ConnTableLock;		// Mutex for ConnObject table

	RWAN_CONN_INSTANCE				ConnInstance;		// Counts ConnId's allocated sofar
	PRWAN_TDI_CONNECTION *			pConnTable;			// Pointers to open connections
	ULONG							ConnTableSize;		// Size of above table
	ULONG							MaxConnections;		// Max size of above table
	ULONG							NextConnIndex;		// Starting point for next search
	RWAN_EVENT						Event;				// Used for synchronization
	BOOLEAN							UnloadDone;			// Has our UnloadProtocol run?
#ifdef NT
	PDRIVER_OBJECT					pDriverObject;		// From DriverEntry()
	LIST_ENTRY						DeviceObjList;		// All device objs we've created
#endif // NT

} RWAN_GLOBALS, *PRWAN_GLOBALS;

#if DBG
#define nlg_signature				'lGwR'
#endif // DBG




//
//  ***** Request structure *****
//
//  This structure keeps context information about each TDI request
//  that we pend.
//
typedef struct _RWAN_REQUEST
{
#if DBG
	ULONG							nrq_sig;
#endif // DBG
	PCOMPLETE_RTN					pReqComplete;		// Call-back routine
	PVOID							ReqContext;			// Context for above
	TDI_STATUS						Status;				// Final status

} RWAN_REQUEST, *PRWAN_REQUEST;

#if DBG
#define nrq_signature				'qRwR'
#endif // DBG




//
//  ***** Connect Request structure *****
//
//  This structure is used to maintain information about a pended
//  TDI_CONNECT or TDI_LISTEN or TDI_ACCEPT or TDI_DISCONNECT.
//
typedef struct _RWAN_CONN_REQUEST
{
#if DBG
	ULONG									nrc_sig;
#endif // DBG
	struct _RWAN_REQUEST 					Request;	// Common stuff
	struct _TDI_CONNECTION_INFORMATION *	pConnInfo;	// Return info
	USHORT									Flags;

} RWAN_CONN_REQUEST, *PRWAN_CONN_REQUEST;

#if DBG
#define nrc_signature				'cRwR'
#endif // DBG



//
//  ***** Data Request structure *****
//
//  This is the common part of a send/receive data request.
//
typedef struct _RWAN_DATA_REQUEST
{
	PDATA_COMPLETE_RTN						pReqComplete;
	PVOID									ReqContext;

} RWAN_DATA_REQUEST, *PRWAN_DATA_REQUEST;




//
//  ***** Send Request structure *****
//
//  This structure is used to maintain information about a pended
//  TDI_SEND.
//
typedef struct _RWAN_SEND_REQUEST
{
#if DBG
	ULONG									nrs_sig;
#endif // DBG
	struct _RWAN_DATA_REQUEST				Request;	// Common stuff
	USHORT									SendFlags;
	UINT									SendLength;

} RWAN_SEND_REQUEST, *PRWAN_SEND_REQUEST;


#if DBG
#define nrs_signature				'sRwR'
#endif // DBG



//
//  ***** Receive Request structure *****
//
//  This structure is used to maintain information about a pended
//  TDI_RECEIVE.
//
typedef struct _RWAN_RECEIVE_REQUEST
{
#if DBG
	ULONG									nrr_sig;
#endif // DBG
	struct _RWAN_RECEIVE_REQUEST *			pNextRcvReq;		// For chaining
	struct _RWAN_DATA_REQUEST				Request;			// Common stuff
	PUSHORT									pUserFlags;			// Info about the rcv
	UINT									TotalBufferLength;	// From TdiReceive
	UINT									AvailableBufferLength; // out of the above
	PNDIS_BUFFER							pBuffer;			// Current buffer in chain
	PUCHAR									pWriteData;			// Write pointer
	UINT									BytesLeftInBuffer;	// Left in current buffer

} RWAN_RECEIVE_REQUEST, *PRWAN_RECEIVE_REQUEST;

#if DBG
#define nrr_signature				'rRwR'
#endif // DBG



//
//  ***** Receive Indication structure *****
//
//  This structure is used to maintain information about one
//  indicated NDIS packet.
//
typedef struct _RWAN_RECEIVE_INDICATION
{
#if DBG
	ULONG									nri_sig;
#endif // DBG
	struct _RWAN_RECEIVE_INDICATION *		pNextRcvInd;		// For chaining
	PNDIS_BUFFER							pBuffer;			// Next byte is read from
																// this buffer:
	PUCHAR									pReadData;			// Points to next byte
																// to be read
	UINT									BytesLeftInBuffer;
	UINT									TotalBytesLeft;		// Within this packet
	PNDIS_PACKET							pPacket;
	UINT									PacketLength;
	BOOLEAN									bIsMiniportPacket;	// Does this packet
																// belong to the miniport
	PRWAN_NDIS_VC							pVc;				// back-pointer

} RWAN_RECEIVE_INDICATION, *PRWAN_RECEIVE_INDICATION;

#if DBG
#define nri_signature				'iRwR'
#endif // DBG




//
//  Saved context for an NDIS Request sent to the miniport on behalf of
//  an AF/media specific module.
//
typedef struct _RWAN_NDIS_REQ_CONTEXT
{
	struct _RWAN_NDIS_AF *					pAf;
	RWAN_HANDLE								AfSpReqContext;

} RWAN_NDIS_REQ_CONTEXT, *PRWAN_NDIS_REQ_CONTEXT;



#endif // __TDI_RWANDATA__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\ndisconn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\ndisconn.c

Abstract:

	NDIS Entry points and support routines for Connection setup and
	release.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-06-97    Created

Notes:

	Code under ifndef NO_POST_DISCON: Nov 17, 98
		Added code to send a TDI DisconInd to AFD before completing
		a TDI Disconnect Request that AFD had sent to us. Without this,
		if an app calls shutdown(SD_SEND) -> TDI Disconnect Request,
		a subsequent call by the app to recv() blocks forever, because
		AFD expects the TDI transport to send up a TDI DisconInd!

--*/

#include <precomp.h>

#define _FILENUMBER 'NCDN'



NDIS_STATUS
RWanNdisCreateVc(
	IN	NDIS_HANDLE					ProtocolAfContext,
	IN	NDIS_HANDLE					NdisVcHandle,
	OUT	PNDIS_HANDLE				pProtocolVcContext
	)
/*++

Routine Description:

	This is the NDIS entry point for creating a new endpoint (VC).
	We allocate a new NDIS_VC structure and return a pointer to it
	as our context for the VC.

Arguments:

	ProtocolAfContext	- Pointer to our NDIS AF block
	NdisVcHandle		- Handle for the newly created VC
	pProtocolVcContext	- Place where we return our context for the VC

Return Value:

	NDIS_STATUS_SUCCESS if we could allocate a VC,
	NDIS_STATUS_RESOURCES otherwise.

--*/
{
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	NDIS_STATUS				Status;

	pAf = (PRWAN_NDIS_AF)ProtocolAfContext;

	RWAN_STRUCT_ASSERT(pAf, naf);

	do
	{
		pVc = RWanAllocateVc(pAf, FALSE);

		if (pVc == NULL_PRWAN_NDIS_VC)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		pVc->NdisVcHandle = NdisVcHandle;

		RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
				("CreateVc: pVc x%x, pAf x%x\n", pVc, pAf));

		Status = NDIS_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	*pProtocolVcContext = (NDIS_HANDLE)pVc;

	return (Status);
}




NDIS_STATUS
RWanNdisDeleteVc(
	IN	NDIS_HANDLE					ProtocolVcContext
	)
/*++

Routine Description:

	This entry point is called by NDIS to delete a VC context
	used for an incoming call. At this time, there should be
	no call on the VC. All we need to do is unlink the VC from
	the list it belongs to, and free it.

Arguments:

	ProtocolVcContext		- Points to our VC context.

Return Value:

	NDIS_STATUS_SUCCESS always.

--*/
{
	PRWAN_NDIS_VC			pVc;

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWAN_ASSERT(pVc->pConnObject == NULL_PRWAN_TDI_CONNECTION);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_DISCON,
			("DeleteVc: pVc x%x, pAf x%x\n", pVc, pVc->pNdisAf));

	//
	//  Unlink the VC from the list of VCs on the AF block
	//
	RWanUnlinkVcFromAf(pVc);

	RWanFreeVc(pVc);

	return (NDIS_STATUS_SUCCESS);
}




VOID
RWanNdisMakeCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					NdisPartyHandle		OPTIONAL,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

	This is the NDIS entry point that is called when a previous
	call we made to NdisClMakeCall has completed.

	We locate the TDI Connection Object for this call. If the
	user hasn't aborted the Connect/JoinLeaf, we complete the
	pended request. Otherwise, we initiate a CloseCall.

	This primitive can happen only when the endpoint is in
	the "Out call initiated" state.

Arguments:

	Status				- Final status of the MakeCall
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	NdisPartyHandle		- If this is a PMP call, this is the handle to the
						  first party
	pCallParameters		- Final call parameters.

Return Value:

	None

--*/
{
	PRWAN_TDI_CONNECTION	pRootConnObject;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_ADDRESS		pAddrObject;
	NDIS_HANDLE				NdisVcHandle;
	TDI_STATUS				TdiStatus;
	PRWAN_CONN_REQUEST		pConnReq;		// Saved context about the TdiConnect
	BOOLEAN					bIsConnClosing;	// Have we seen a TdiCloseConnection?
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_PARTY		pParty;
	PCO_CALL_PARAMETERS		pOriginalParams;// What we used in the MakeCall
	RWAN_HANDLE				AfSpConnContext;
#if DBG
	RWAN_IRQL				EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;

	RWAN_STRUCT_ASSERT(pVc, nvc);

	//
	//  Check if this is a point-to-multipoint call.
	//
	if (!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_PMP))
	{
		//
		//  Point-to-point call.
		//
		pConnObject = pVc->pConnObject;
		pRootConnObject = pConnObject; // for consistency.
		pParty = NULL;
		pOriginalParams = pVc->pCallParameters;
	}
	else
	{
		//
		//  PMP Call. Get at the Party structure.
		//
		pParty = pVc->pPartyMakeCall;
		RWAN_STRUCT_ASSERT(pParty, npy);

		pConnObject = pParty->pConnObject;
		pRootConnObject = pVc->pConnObject;
		pOriginalParams = pParty->pCallParameters;
	}

	RWAN_ASSERT(pOriginalParams != NULL);

	pAf = pVc->pNdisAf;

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("MakeCallComplete: pConn x%x, State/Flags/Ref x%x/x%x/%d, pAddr %x, pVc x%x, Status x%x\n",
				pConnObject, pConnObject->State, pConnObject->Flags, pConnObject->RefCount, pConnObject->pAddrObject, pVc, Status));

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	RWAN_ASSERT(pConnObject->State == RWANS_CO_OUT_CALL_INITIATED ||
				pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	//
	//  Has the user initiated a TdiCloseConnection() or a TdiDisconnect()
	//  while this outgoing call was in progress?
	//
	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING) ||
						(pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	//
	//  We would have saved context about the TdiConnect(). Get it.
	//
	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;


	if (pParty)
	{
		pVc->AddingPartyCount --;
		pParty->pCallParameters = NULL;
		pParty->NdisPartyHandle = NdisPartyHandle;
	}
	else
	{
		pVc->pCallParameters = NULL;
	}

	if (Status == NDIS_STATUS_SUCCESS)
	{
		RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_MAKECALL_OK);

		if (!bIsConnClosing)
		{
			//
			//  Outgoing connection successfully set up.
			//

			pConnObject->State = RWANS_CO_CONNECTED;

			//
			//  Update PMP information.
			//
			if (pParty)
			{
				pVc->ActivePartyCount ++;	// MakeCall PMP complete
				pRootConnObject->State = RWANS_CO_CONNECTED;
			}

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWanCompleteConnReq(		// MakeCall OK
						pAf,
						pConnReq,
						TRUE,
						pCallParameters,
						AfSpConnContext,
						TDI_SUCCESS
						);
		}
		else
		{
			//
			//  Abort this call.
			//
			pConnObject->State = RWANS_CO_ABORTING;

			RWanStartCloseCall(pConnObject, pVc);
		}
		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}
	else
	{
		//
		//  MakeCall failed.
		//

		INT				rc;

		//
		//  XXX TBD : how about trying this call on another NDIS AF?
		//

		RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_MAKECALL_FAIL);

		if (pParty == NULL)
		{
			//
			//  Point-to-Point call.
			//

			//
			//  Unlink the NDIS VC from this Conn Object.
			//
			RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);	// MakeCall fail

		}
		else
		{
			//
			//  PMP Call. The VC would be attached to the Root
			//  Connection Object. Unlink the VC and the Root Connection.
			//
			RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

			RWAN_UNLINK_CONNECTION_AND_VC(pRootConnObject, pVc);	// MakeCallPMP fail

			rc = RWanDereferenceConnObject(pRootConnObject);	// VC deref: MakeCallPMP fail

			if (rc > 0)
			{
				RWAN_RELEASE_CONN_LOCK(pRootConnObject);
			}

			//
			//  Unlink the Party from the Connection and VC.
			//
			RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));
			pParty->pVc = NULL;

			pParty->pConnObject = NULL;
			pConnObject->NdisConnection.pNdisParty = NULL;
		}

		rc = RWanDereferenceConnObject(pConnObject);	// VC/Pty deref: MakeCall fail

		//
		//  Continue with the Connection Object for this MakeCall,
		//  if it is still alive.
		//
		if (rc > 0)
		{
			if (pConnObject->pAddrObject != NULL)
			{
				//
				//  Move the Connection Object to the Idle list.
				//

				pAddrObject = pConnObject->pAddrObject;

				//
				//  Reacquire some locks in the right order.
				//
				RWAN_RELEASE_CONN_LOCK(pConnObject);

				RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
				RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

				//
				//  Move this Connection to the Idle list.
				//
				RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
				RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
 									&(pConnObject->ConnLink));

				//
				//  Send this back to the state it was in before the TdiConnect.
				//
				pConnObject->State = RWANS_CO_ASSOCIATED;

				AfSpConnContext = pConnObject->AfSpConnContext;

				RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

				RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

				//
				//  Complete the TdiConnect() with a failure status.
				//
				TdiStatus = RWanNdisToTdiStatus(Status);

				if (TdiStatus == TDI_NOT_ACCEPTED)
				{
					TdiStatus = TDI_CONN_REFUSED;
				}

				RWanCompleteConnReq(		// MakeCall Fail
						pAf,
						pConnReq,
						TRUE,
						NULL,
						AfSpConnContext,
						TdiStatus
						);
			}
			else
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
			}
		}
		//
		//  else the Conn Object is gone. A TdiCloseConnection might be
		//  (must be?) in progress.
		//
#if 1
		// XXX: Remove this after debugging.
		pVc = (PRWAN_NDIS_VC)ProtocolVcContext;

		RWAN_STRUCT_ASSERT(pVc, nvc);
#endif // 1

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Unlink the VC from the AF it is attached to.
		//
		RWanUnlinkVcFromAf(pVc);

		//
		//  Get rid of the VC.
		//
		Status = NdisCoDeleteVc(NdisVcHandle);
		RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

		RWanFreeVc(pVc);	// MakeCall complete fail

		if (pParty != NULL)
		{
			RWAN_FREE_MEM(pParty);	// MakeCall complete fail
		}

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}

	//
	//  Return the Call Parameters structure to the AF-specific module.
	//
	(*pAf->pAfInfo->AfChars.pAfSpReturnNdisOptions)(
						pAf->AfSpAFContext,
						pOriginalParams
						);
	return;

}



VOID
RWanNdisAddPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext,
	IN	NDIS_HANDLE					NdisPartyHandle,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

	This is the NDIS entry indicating completion of a call to NdisClAddParty
	that had pended.

Arguments:

	Status				- Final status of the AddParty
	ProtocolPartyContext- Actually a pointer to our NDIS PARTY structure
	NdisPartyHandle		- If the AddParty was successful, an NDIS handle for it
	pCallParameters		- Final parameters after the AddParty

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY		pParty;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_ADDRESS		pAddrObject;
	PRWAN_CONN_REQUEST		pConnReq;
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	PCO_CALL_PARAMETERS		pOriginalParams;	// what was used in the AddParty
	TDI_STATUS				TdiStatus;
	BOOLEAN					bIsConnClosing;
	RWAN_HANDLE				AfSpConnContext;
#if DBG
	RWAN_IRQL				EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pParty = (PRWAN_NDIS_PARTY)ProtocolPartyContext;
	RWAN_STRUCT_ASSERT(pParty, npy);

	pVc = pParty->pVc;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	pAf = pVc->pNdisAf;
	pConnObject = pParty->pConnObject;

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	pOriginalParams = pParty->pCallParameters;
	RWAN_ASSERT(pOriginalParams != NULL);

	pParty->pCallParameters = NULL;

	RWAN_ASSERT(pConnObject->State == RWANS_CO_OUT_CALL_INITIATED ||
				pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	//
	//  Has the user initiated a TdiCloseConnection() or a TdiDisconnect()
	//  while this outgoing call was in progress?
	//
	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING) ||
						(pConnObject->State == RWANS_CO_DISCON_REQUESTED);

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("AddPartyComplete: pConn x%x, State/Flags x%x/x%x, pVc x%x, Pty x%x, Status x%x\n",
				pConnObject, pConnObject->State, pConnObject->Flags, pVc, pParty, Status));

	//
	//  We would have saved context about the TdiConnect(). Get it.
	//
	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;

	pVc->AddingPartyCount --;

	if (Status == NDIS_STATUS_SUCCESS)
	{
		pParty->NdisPartyHandle = NdisPartyHandle;

		pConnObject->State = RWANS_CO_CONNECTED;

		//
		//  Outgoing party successfully set up.
		//
		pVc->ActivePartyCount ++;	// AddParty OK

		if (!bIsConnClosing)
		{
			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWanCompleteConnReq(		// AddParty OK
						pAf,
						pConnReq,
						TRUE,
						pCallParameters,
						AfSpConnContext,
						TDI_SUCCESS
						);
		}
		else
		{
			//
			//  Abort this Party.
			//
			RWanDoTdiDisconnect(
				pConnObject,
				NULL,		// pTdiRequest
				NULL,		// pTimeout
				0,			// Flags
				NULL,		// pDisconnInfo
				NULL		// pReturnInfo
				);

			//
			//  Conn Object lock is released above.
			//
		}

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}
	else
	{
		//
		//  AddParty failed.
		//

		INT				rc;

		//
		//  Unlink the Party from the VC.
		//
		RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));

		pAddrObject = pConnObject->pAddrObject;

		rc = RWanDereferenceConnObject(pConnObject);	// Party deref: AddParty fail

		if (rc > 0)
		{
			//
			//  Reacquire some locks in the right order.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
			RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

			//
			//  Move this Connection to the Idle list.
			//
			RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
			RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
 								  &(pConnObject->ConnLink));

			//
			//  Send this back to the state it was in before the TdiConnect.
			//
			pConnObject->State = RWANS_CO_ASSOCIATED;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			//
			//  Complete the TdiConnect() with a failure status.
			//
			TdiStatus = RWanNdisToTdiStatus(Status);

			if (TdiStatus == TDI_NOT_ACCEPTED)
			{
				TdiStatus = TDI_CONN_REFUSED;
			}

			RWanCompleteConnReq(		// JoinLeaf Fail
				pAf,
				pConnReq,
				TRUE,
				NULL,
				AfSpConnContext,
				TdiStatus
				);
		}
		//
		//  else the ConnObject is gone.
		//

		RWAN_FREE_MEM(pParty);	// AddParty fail

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	}

	//
	//  Return the Call Parameters structure to the AF-specific module.
	//
	(*pAf->pAfInfo->AfChars.pAfSpReturnNdisOptions)(
						pAf->AfSpAFContext,
						pOriginalParams
						);
	return;

}




NDIS_STATUS
RWanNdisIncomingCall(
	IN		NDIS_HANDLE				ProtocolSapContext,
	IN		NDIS_HANDLE				ProtocolVcContext,
	IN OUT	PCO_CALL_PARAMETERS		pCallParameters
	)
/*++

Routine Description:

	This is the NDIS entry point announcing a new Incoming call request,
	on the specified SAP.

	The SAP corresponds to an Address Object. If there are no Listens posted
	on the Address object, we reject this call. Otherwise, we pick up an
	arbitrary listening connection object and indicate this call on that.

	TBD: support selection of listening conn object based on specified
	remote criteria.

Arguments:

	ProtocolSapContext	- Our SAP context is a pointer to an NDIS SAP structure
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	pCallParameters		- Points to Incoming call parameters.

Return Value:

	None

--*/
{
	PRWAN_NDIS_SAP				pSap;
	PRWAN_NDIS_VC				pVc;
	PRWAN_NDIS_AF				pAf;
	PRWAN_TDI_ADDRESS			pAddrObject;
	BOOLEAN						IsAddrLockAcquired;
	PRWAN_TDI_CONNECTION		pConnObject;
	PLIST_ENTRY					pConnEntry;
	NDIS_STATUS					Status;
	TDI_STATUS					TdiStatus;
	RWAN_STATUS					RWanStatus;
	PRWAN_CONN_REQUEST			pConnReq;

	PConnectEvent				pConnInd;
	PTDI_CONNECTION_INFORMATION	pTdiInfo;
	RWAN_HANDLE					AfSpTdiOptionsContext;
	PVOID						pTdiQoS;
	ULONG						TdiQoSLength;

	PVOID						ConnIndContext;
	PVOID						AcceptConnContext;
	RWAN_HANDLE					AfSpConnContext;
#ifdef NT
	PIO_STACK_LOCATION			pIrpSp;
	PTDI_REQUEST_KERNEL_ACCEPT	pAcceptReq;
	ConnectEventInfo			*EventInfo;
#else
	ConnectEventInfo			EventInfo;
#endif // NT


	pSap = (PRWAN_NDIS_SAP)ProtocolSapContext;
	RWAN_STRUCT_ASSERT(pSap, nsp);

	pAddrObject = pSap->pAddrObject;
	RWAN_ASSERT(pAddrObject != NULL);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_INCALL);

	pAf = pVc->pNdisAf;

	RWANDEBUGP(DL_INFO, DC_CONNECT,
			("IncomingCall: pVc x%x, pAddrObj x%x/x%x, pConnInd x%x\n",
				pVc, pAddrObject, pAddrObject->Flags, pAddrObject->pConnInd));

	//
	//  Initialize.
	//
	pTdiInfo = NULL;
	AfSpTdiOptionsContext = NULL;
	pConnReq = NULL;

	IsAddrLockAcquired = TRUE;
	RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

	do
	{
		if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_CLOSING))
		{
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		if (pVc->pConnObject != NULL)
		{
			RWAN_ASSERT(FALSE);
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Convert from NDIS Call Parameters to TDI Options.
		//
		RWanStatus = (*pAf->pAfInfo->AfChars.pAfSpNdis2TdiOptions)(
							pAf->AfSpAFContext,
							RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT,
							pCallParameters,
							&pTdiInfo,
							&pTdiQoS,
							&TdiQoSLength,
							&AfSpTdiOptionsContext
							);
					
		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWANDEBUGP(DL_LOUD, DC_CONNECT,
					("IncomingCall: conversion from NDIS to TDI failed, status x%x\n",
							RWanStatus));

			Status = NDIS_STATUS_FAILURE;
			break;
		}

		RWAN_ASSERT(pTdiInfo != NULL);
		RWAN_ASSERT(AfSpTdiOptionsContext != NULL);

		//
		//  It has been decided to pass QOS and any provider-specific info
		//  as part of TDI options.
		//
		pTdiInfo->Options = pTdiQoS;
		pTdiInfo->OptionsLength = TdiQoSLength;

		pVc->pCallParameters = pCallParameters;
		RWAN_SET_VC_CALL_PARAMS(pVc, pCallParameters);

		//
		//  Find a listening connection.
		//
		for (pConnEntry = pAddrObject->ListenConnList.Flink;
			 pConnEntry != &pAddrObject->ListenConnList;
			 pConnEntry = pConnEntry->Flink)
		{
			pConnObject = CONTAINING_RECORD(pConnEntry, RWAN_TDI_CONNECTION, ConnLink);
			RWAN_STRUCT_ASSERT(pConnObject, ntc);

			RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
					("Incoming Call: looking at pConnObj x%x, state %d\n",
						pConnObject, pConnObject->State));

			if (pConnObject->State == RWANS_CO_LISTENING)
			{
				break;
			}
		}

		if (pConnEntry != &pAddrObject->ListenConnList)
		{
			//
			//  Found a listening connection.
			//
			RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

			//
			//  Move the Connection from the Idle list to the Active list.
			//
			RWAN_DELETE_FROM_LIST(&pConnObject->ConnLink);
			RWAN_INSERT_TAIL_LIST(&pAddrObject->ActiveConnList,
 								&pConnObject->ConnLink);

			RWAN_LINK_CONNECTION_TO_VC(pConnObject, pVc);

			RWanReferenceConnObject(pConnObject);	// VC ref - InCall, Listening conn

			RWANDEBUGP(DL_LOUD, DC_CONNECT,
					("IncomingCall: pVc x%x, pConnObj x%x is listening, ConnReqFlags x%x\n",
							pVc, pConnObject, pConnObject->pConnReq->Flags));

			if (pConnObject->pConnReq->pConnInfo)
			{
				*pConnObject->pConnReq->pConnInfo = *pTdiInfo;
			}

			//
			//  Check if it is pre-accepted. If so, tell NDIS that we have
			//  accepted the call.
			//
			if (!(pConnObject->pConnReq->Flags & TDI_QUERY_ACCEPT))
			{
				pConnObject->State = RWANS_CO_IN_CALL_ACCEPTING;

				RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

				//
				//  Request the media-specific module to update NDIS call parameters.
				//
				if (pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)
				{
					(VOID)(*pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)(
								pAf->AfSpAFContext,
								pConnObject->AfSpConnContext,
								RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT,
								pTdiInfo,
								pTdiQoS,
								TdiQoSLength,
								&pCallParameters
								);
				}

				Status = NDIS_STATUS_SUCCESS;
				break;
			}

			//
			//  It isn't pre-accepted. Complete the pended listen.
			//

			pConnReq = pConnObject->pConnReq;
			pConnObject->pConnReq = NULL;

			pConnObject->State = RWANS_CO_IN_CALL_INDICATED;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			IsAddrLockAcquired = FALSE;

			RWanCompleteConnReq(		// InCall: Listen OK
						pSap->pNdisAf,
						pConnReq,
						FALSE,
						NULL,
						AfSpConnContext,
						TDI_SUCCESS
						);

			pConnReq = NULL;

			Status = NDIS_STATUS_PENDING;
			break;
		}


		//
		//  There wasn't a listening connection available.
		//  See if there is a Connect Indication event handler on this
		//  Address Object.
		//
		if (pAddrObject->pConnInd == NULL)
		{
			//
			//  No event handler. Reject this call.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Get some resources.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}

		pConnInd = pAddrObject->pConnInd;
		ConnIndContext = pAddrObject->ConnIndContext;

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		IsAddrLockAcquired = FALSE;

		RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
				("IncomingCall: Will Indicate: pVc x%x, RemAddr x%x/%d, Options x%x/%d\n",
					pVc,
					pTdiInfo->RemoteAddress,
					pTdiInfo->RemoteAddressLength,
					pTdiInfo->Options,
					pTdiInfo->OptionsLength));

		//
		//  Indicate the call to the user.
		//
		TdiStatus = (*pConnInd)(
							ConnIndContext,
							pTdiInfo->RemoteAddressLength,
							pTdiInfo->RemoteAddress,
							pTdiInfo->UserDataLength,
							pTdiInfo->UserData,
							pTdiInfo->OptionsLength,
							pTdiInfo->Options,
							&AcceptConnContext,
							&EventInfo
							);

		RWANDEBUGP(DL_LOUD, DC_CONNECT,
				("IncomingCall: pVc x%x, pAddrObj x%x, Connect Ind returned x%x\n",
						pVc, pAddrObject, TdiStatus));

		if (TdiStatus != TDI_MORE_PROCESSING)
		{
			//
			//  Connection rejected.
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}


		//
		//  This connection has been accepted. Collect all information
		//  about this implicit TdiAccept Request.
		//
#ifdef NT
		pIrpSp = IoGetCurrentIrpStackLocation(EventInfo);

		Status = RWanPrepareIrpForCancel(
						(PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext,
						EventInfo,
						RWanCancelRequest
						);

		if (!NT_SUCCESS(Status))
		{
			//
			//  Reject this incoming call.
			//
			break;
		}

		pAcceptReq = (PTDI_REQUEST_KERNEL_ACCEPT) &(pIrpSp->Parameters);

		pConnReq->Request.pReqComplete = (PVOID)RWanRequestComplete;
		pConnReq->Request.ReqContext = EventInfo;
		pConnReq->pConnInfo = pAcceptReq->ReturnConnectionInformation;
#else
		pConnReq->Request.pReqComplete = EventInfo.cei_rtn;
		pConnReq->Request.ReqContext = EventInfo.cei_context;
		pConnReq->pConnInfo = EventInfo.cei_conninfo;
#endif // NT

		//
		//  Find the connection object on which it has been accepted.
		//
		IsAddrLockAcquired = TRUE;
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		for (pConnEntry = pAddrObject->IdleConnList.Flink;
 			 pConnEntry != &pAddrObject->IdleConnList;
 			 pConnEntry = pConnEntry->Flink)
		{
			pConnObject = CONTAINING_RECORD(pConnEntry, RWAN_TDI_CONNECTION, ConnLink);
			RWAN_STRUCT_ASSERT(pConnObject, ntc);

			if ((pConnObject->ConnectionHandle == AcceptConnContext) &&
				!(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
			{
				break;
			}
		}

		if (pConnEntry == &pAddrObject->IdleConnList)
		{
			//
			//  Invalid connection context!
			//
			TdiStatus = TDI_INVALID_CONNECTION;
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

			IsAddrLockAcquired = FALSE;

			//
			//  Fail the Accept req
			//
			RWanCompleteConnReq(		// InCall: Accept is bad
						pAf,
						pConnReq,
						FALSE,
						NULL,
						NULL,
						TdiStatus
						);

			pConnReq = NULL;

			//
			//  Reject the incoming call
			//
			Status = NDIS_STATUS_FAILURE;
			break;
		}

		//
		//  Request the media-specific module to update NDIS call parameters.
		//
		if (pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)
		{
			(VOID)(*pAf->pAfInfo->AfChars.pAfSpUpdateNdisOptions)(
						pAf->AfSpAFContext,
						pConnObject->AfSpConnContext,
						RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT,
						pTdiInfo,
						pTdiQoS,
						TdiQoSLength,
						&pCallParameters
						);
		}

		//
		//  Set up the Connection Object for accepting this call.
		//
		RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

		pConnObject->State = RWANS_CO_IN_CALL_ACCEPTING;

		//
		//  Save info to help us complete the Accept Req when
		//  we get a CallConnected from NDIS.
		//
		RWAN_ASSERT(pConnObject->pConnReq == NULL);
		pConnObject->pConnReq = pConnReq;

		//
		//  Move the Connection from the Idle list to the Active list.
		//
		RWAN_DELETE_FROM_LIST(&pConnObject->ConnLink);
		RWAN_INSERT_TAIL_LIST(&pAddrObject->ActiveConnList,
							 &pConnObject->ConnLink);

		RWAN_LINK_CONNECTION_TO_VC(pConnObject, pVc);

		RWanReferenceConnObject(pConnObject);	// VC ref

		RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

		//
		//  Accept the call.
		//
		Status = NDIS_STATUS_SUCCESS;
		break;

	}
	while (FALSE);

	if (IsAddrLockAcquired)
	{
		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
	}

	//
	//  If we are rejecting this call, clean up.
	//
	if ((Status != NDIS_STATUS_SUCCESS) &&
		(Status != NDIS_STATUS_PENDING))
	{
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}

	}

	//
	//  Return TDI options space to the media-specific module.
	//
	if (pTdiInfo != NULL)
	{
		RWAN_ASSERT(pAf);
		RWAN_ASSERT(AfSpTdiOptionsContext);

		(*pAf->pAfInfo->AfChars.pAfSpReturnTdiOptions)(
				pAf->AfSpAFContext,
				AfSpTdiOptionsContext
				);
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("IncomingCall: pVc x%x, returning status x%x\n", pVc, Status));

	return (Status);
}




VOID
RWanNdisCallConnected(
	IN	NDIS_HANDLE					ProtocolVcContext
	)
/*++

Routine Description:

	This is the NDIS entry point signifying successful setup of an
	incoming call. If required, we complete the TDI user's Accept Request
	here.

	This primitive can happen only when the call is in the "Accepting" state.

Arguments:

	ProtocolVcContext	- Actually a pointer to our NDIS VC structure

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC				pVc;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_TDI_ADDRESS			pAddrObject;
	NDIS_HANDLE					NdisVcHandle;
	NDIS_STATUS					Status;
	PRWAN_CONN_REQUEST			pConnReq;
	RWAN_HANDLE					AfSpConnContext;
	ULONG						rc;
	BOOLEAN						IsAborting = FALSE;


	pVc = (PRWAN_NDIS_VC) ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);
	RWAN_ASSERT(pVc->pConnObject != NULL_PRWAN_TDI_CONNECTION);

	pConnObject = pVc->pConnObject;
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	pAddrObject = pConnObject->pAddrObject;

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_CALLCONN);

	IsAborting = ((pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING) ||
					RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING));

	//
	//  Incoming Connection setup successfully.
	//
	if (!IsAborting)
	{
		pConnObject->State = RWANS_CO_CONNECTED;
	}

	//
	//  Add a temp ref to keep the conn object from going away.
	//
	RWanReferenceConnObject(pConnObject);	// Temp ref, CallConn

	//
	//  If we have an Accept Request to complete, complete it
	//  now. Note that we might not have one pending in case
	//  we had a pre-accepted listen.
	//
	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;

	AfSpConnContext = pConnObject->AfSpConnContext;

	RWAN_RELEASE_CONN_LOCK(pConnObject);

	if (pConnReq != NULL)
	{
		//
		//  Complete the Accept request.
		//
		RWanCompleteConnReq(		// CallConnected: Accept OK
					pVc->pNdisAf,
					pConnReq,
					FALSE,
					NULL,
					AfSpConnContext,
					TDI_SUCCESS
					);
	}

	//
	//  Trigger off data indications for any packets that were received and queued
	//  while we were in the process of accepting the call.
	//
	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	rc = RWanDereferenceConnObject(pConnObject);	// Temp ref - CallConn

	//
	//  But first make sure that the connection still exists and is in a good
	//  state.
	//
	if (rc != 0)
	{
		if (!IsAborting)
		{
			RWanIndicateData(pConnObject);
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("CallConn: ConnObj %x/%x, State %d, aborting\n",
					pConnObject, pConnObject->Flags, pConnObject->State));
			RWanDoAbortConnection(pConnObject);
		}
	}
	//
	//  else the Connection is gone!
	//

	return;
}




VOID
RWanNdisIncomingCloseCall(
	IN	NDIS_STATUS					CloseStatus,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	PVOID						pCloseData,
	IN	UINT						CloseDataLength
	)
/*++

Routine Description:

	This is the NDIS entry point called when a connection is torn
	down by the remote peer or network. We mark the affected endpoint,
	and if possible, indicate a Disconnect Event to the user. If we
	do indicate to the user, call teardown is continued when the
	user calls TdiDisconnect.

	This primitive can happen while the endpoint is in one of these
	states:
	(1) Connected
	(2) Accepting incoming call (TdiAccept pending)

Arguments:

	CloseStatus			- Status for the incoming close
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	pCloseData			- Data/options associated with the close - NOT USED
	CloseDataLength		- Length of the above - NOT USED

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC				pVc;
	PRWAN_NDIS_PARTY			pParty;
	PRWAN_NDIS_AF				pAf;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_CONN_REQUEST			pConnReq;
	NDIS_HANDLE					NdisVcHandle;
	BOOLEAN						bIsConnClosing;	// TdiCloseConnection?
	BOOLEAN						bScheduleDisconnect;
	RWAN_HANDLE					AfSpConnContext;

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	if (!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_PMP))
	{
		pConnObject = pVc->pConnObject;
		pParty = NULL;
	}
	else
	{
		//
		//  Locate the connection object for the last leaf.
		//
		pParty = CONTAINING_RECORD(pVc->NdisPartyList.Flink, RWAN_NDIS_PARTY, PartyLink);
		RWAN_STRUCT_ASSERT(pParty, npy);

		pConnObject = pParty->pConnObject;
	}

	RWAN_ASSERT(pConnObject != NULL_PRWAN_TDI_CONNECTION);
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("IncomingClose: pVc x%x, pConnObj x%x/x%x, pParty x%x\n",
				pVc, pConnObject, pConnObject->Flags, pParty));

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_INCLOSE);

	NdisVcHandle = pVc->NdisVcHandle;

	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING);

	if (bIsConnClosing)
	{
		//
		//  The user has initiated a TdiCloseConnection.
		//  Continue NDIS call teardown. When this completes,
		//  we'll complete the CloseConnection.
		//  
		RWanStartCloseCall(pConnObject, pVc);
		return;
	}

	pAf = pVc->pNdisAf;

	switch (pConnObject->State)
	{
		case RWANS_CO_IN_CALL_ACCEPTING:
			//
			//  If we have a pended Accept Request, fail it now.
			//  Otherwise, we must have had a pre-accepted listen,
			//  so we fall through and indicate a Disconnect.
			//
			pConnReq = pConnObject->pConnReq;
			pConnObject->pConnReq = NULL;

			if (pConnReq != NULL)
			{
				//
				//  Fix the state so that TdiDisconnect does the right thing
				//
				pConnObject->State = RWANS_CO_DISCON_INDICATED;

				AfSpConnContext = pConnObject->AfSpConnContext;

				RWanScheduleDisconnect(pConnObject);
				//
				//  Conn Lock is released within the above.
				//

				RWanCompleteConnReq(		// Incoming Close during IN_CALL_ACCEPT
							pAf,
							pConnReq,
							FALSE,
							NULL,
							AfSpConnContext,
							TDI_CONNECTION_ABORTED
							);
				break;
			}
			//
			//  else this must be a pre-accepted listen.
			//
			//  FALLTHRU on "else" to RWANS_CO_CONNECTED
			//

		case RWANS_CO_CONNECTED:
			//
			//  If there is a Disconnect Event handler, call it.
			//  Otherwise, simply mark this endpoint as having
			//  seen a Disconnect.
			//
			bScheduleDisconnect = TRUE;
			if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				//
				//  Don't send up a Disconnect Indication if we are in the
				//  middle of indicating data.
				//
				if ((pDisconInd != NULL) &&
					!(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_INDICATING_DATA)))
				{
					RWANDEBUGP(DL_INFO, DC_WILDCARD,
						("IncomingClose: pConnObj %x/%x, st %x, will discon ind\n",
							pConnObject, pConnObject->Flags, pConnObject->State));

					pConnObject->State = RWANS_CO_DISCON_INDICATED;
					ConnectionHandle = pConnObject->ConnectionHandle;

					//
					//  Schedule a work item to continue Disconnect
					//  first. This is because the call to DiscInd can
					//  lead to a call to CloseConnection and block there.
					//
					bScheduleDisconnect = FALSE;
					RWanScheduleDisconnect(pConnObject);

					(*pDisconInd)(
							IndContext,
							ConnectionHandle,
							0,			// Disconnect Data Length
							NULL,		// Disconnect Data
							0,			// Disconnect Info Length
							NULL,		// Disconnect Info
							TDI_DISCONNECT_RELEASE
							);

				}
				else
				{
					RWANDEBUGP(DL_FATAL, DC_DISCON,
						("IncomingClose: pConnObj %x/%x, pending discon\n",
							pConnObject, pConnObject->Flags));

					pConnObject->State = RWANS_CO_DISCON_HELD;
					RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_PENDED_DISCON);
				}
			}
			else
			{
				pConnObject->State = RWANS_CO_DISCON_HELD;
			}

			if (bScheduleDisconnect)
			{
				RWanScheduleDisconnect(pConnObject);
				//
				//  Conn Object lock is released within the above.
				//
			}

			break;

		case RWANS_CO_ABORTING:
		case RWANS_CO_DISCON_REQUESTED:
			//
			//  Ignore this.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;

		default:

			RWAN_ASSERT(FALSE);
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;
	}

	return;
}




VOID
RWanNdisCloseCallComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolVcContext,
	IN	NDIS_HANDLE					ProtocolPartyContext
	)
/*++

Routine Description:

	The NDIS entry point that is called when a previous pended call
	we made to NdisClCloseCall has completed.

Arguments:

	Status				- Final status of CloseCall
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	ProtocolPartyContext- Last party context, points to NDIS PARTY structure
						  if this is a point-to-multipoint call.

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_PARTY		pParty;
	PRWAN_NDIS_AF			pAf;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_CONNECTION	pRootConnObject;
	INT						rc;
	PRWAN_CONN_REQUEST		pConnReq;
	BOOLEAN					IsOutgoingCall;
	RWAN_HANDLE				AfSpConnContext;

#ifndef NO_POST_DISCON
	PDisconnectEvent		pDisconInd;
	PVOID					IndContext;
	PVOID					ConnectionHandle;
#endif // !NO_POST_DISCON

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWAN_SET_VC_EVENT(pVc, RWANF_VC_EVT_CLOSECOMP);

	//
	//  Check if this is a point-to-multipoint call.
	//
	pParty = (PRWAN_NDIS_PARTY)ProtocolPartyContext;

	if (ProtocolPartyContext == NULL)
	{
		//
		//  Point to point call.
		//
		pConnObject = pVc->pConnObject;
		pRootConnObject = NULL;
	}
	else
	{
		//
		//  PMP Call.
		//
		RWAN_STRUCT_ASSERT(pParty, npy);

		pConnObject = pParty->pConnObject;
		pRootConnObject = pConnObject->pRootConnObject;
	}

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("CloseCallComplete: pVc x%x, pPty x%x, pConnObj x%x, pRoot x%x\n",
					pVc, pParty, pVc->pConnObject, pRootConnObject));

	if (pConnObject != NULL)
	{
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  A pended Disconnect Request may be around.
		//
		pConnReq = pConnObject->pConnReq;
		pConnObject->pConnReq = NULL;

		pAf = pVc->pNdisAf;

		IsOutgoingCall = RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_OUTGOING);

		//
		//  State change:
		//
		if (pConnObject->State != RWANS_CO_ABORTING)
		{
			pConnObject->State = ((pConnObject->pAddrObject != NULL) ?
										RWANS_CO_ASSOCIATED:
										RWANS_CO_CREATED);
		}

		if (pParty == NULL)
		{
			//
			//  Unlink the VC from the Connection Object.
			//
			RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);	// CloseCallComplete

		}
		else
		{
			//
			//  PMP Call. The VC is linked to the root Conn Object.
			//
			RWAN_STRUCT_ASSERT(pRootConnObject, ntc);

			RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

			pRootConnObject->State = ((pRootConnObject->pAddrObject != NULL) ?
										RWANS_CO_ASSOCIATED:
										RWANS_CO_CREATED);

			pVc->DroppingPartyCount --;	// CloseCallComplete (PMP)

			RWAN_UNLINK_CONNECTION_AND_VC(pRootConnObject, pVc);	// CloseCallCompletePMP

			rc = RWanDereferenceConnObject(pRootConnObject);	// VC deref in CloseCallCompletePMP

			if (rc > 0)
			{
				RWAN_RELEASE_CONN_LOCK(pRootConnObject);
			}

			//
			//  Unlink the Party from the VC and Leaf Conn Object.
			//
			pParty->pVc = NULL;
			RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));

			pParty->pConnObject = NULL;
			pConnObject->NdisConnection.pNdisParty = NULL;
		}

		AfSpConnContext = pConnObject->AfSpConnContext;

#ifndef NO_POST_DISCON
		if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{

			pDisconInd = pConnObject->pAddrObject->pDisconInd;
			IndContext = pConnObject->pAddrObject->DisconIndContext;

			ConnectionHandle = pConnObject->ConnectionHandle;
		}
		else
		{
			pDisconInd = NULL;
		}
#endif // NO_POST_DISCON

		rc = RWanDereferenceConnObject(pConnObject);	// VC/Pty deref in CloseCallComplete

		if (rc > 0)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		if (pConnReq != NULL)
		{
#ifndef NO_POST_DISCON
			if (pDisconInd != NULL)
			{
				(*pDisconInd)(
						IndContext,
						ConnectionHandle,
						0,			// Disconnect Data Length
						NULL,		// Disconnect Data
						0,			// Disconnect Info Length
						NULL,		// Disconnect Info
						TDI_DISCONNECT_ABORT
						);
			}
#endif // !NO_POST_DISCON

			RWanCompleteConnReq(		// CloseCallComplete - completing discon req
						pAf,
						pConnReq,
						IsOutgoingCall,
						NULL,
						AfSpConnContext,
						TDI_SUCCESS
						);

		}
	}

	//
	//  See if the VC was created by us. If so, call NDIS to delete it,
	//  and free it.
	//
	if (RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_OUTGOING))
	{
		NDIS_HANDLE			NdisVcHandle;

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Unlink the VC from the list of VCs on the AF block
		//
		RWanUnlinkVcFromAf(pVc);

		Status = NdisCoDeleteVc(NdisVcHandle);
		RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

		RWanFreeVc(pVc);
	}
	//
	//  Otherwise this VC was created by the Call Manager.
	//  Leave it as it is.
	//

	if (pParty != NULL)
	{
		RWAN_FREE_MEM(pParty);	// CloseCallComplete PMP
	}

	return;

}




VOID
RWanNdisDropPartyComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					ProtocolPartyContext
	)
/*++

Routine Description:

	This is the NDIS entry point signifying completion of a previous
	call to NdisClDropParty that had pended.

	We locate and complete the TDI Disconnect, if any, that lead to this.

Arguments:

	Status				- Final status of the Drop party request
	ProtocolPartyContext- Actually a pointer to our NDIS PARTY structure

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY		pParty;
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_AF			pAf;
	PRWAN_TDI_CONNECTION	pConnObject;
	PRWAN_TDI_CONNECTION	pRootConnObject;
	PRWAN_CONN_REQUEST		pConnReq;
	ULONG					rc;
	BOOLEAN					IsOutgoingCall = TRUE;
	BOOLEAN					bVcNeedsClose;
	RWAN_HANDLE				AfSpConnContext;
#ifndef NO_POST_DISCON
	PDisconnectEvent		pDisconInd;
	PVOID					IndContext;
	PVOID					ConnectionHandle;
#endif // !NO_POST_DISCON

	RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);

	pParty = (PRWAN_NDIS_PARTY)ProtocolPartyContext;
	RWAN_STRUCT_ASSERT(pParty, npy);

	pVc = pParty->pVc;

	pConnObject = pParty->pConnObject;

	if (pConnObject != NULL)
	{
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  A pended Disconnect Request may be around.
		//
		pConnReq = pConnObject->pConnReq;
		pConnObject->pConnReq = NULL;

		pAf = pVc->pNdisAf;

		//
		//  State change:
		//
		if (pConnObject->State != RWANS_CO_ABORTING)
		{
			pConnObject->State = ((pConnObject->pAddrObject != NULL) ?
										RWANS_CO_ASSOCIATED:
										RWANS_CO_CREATED);
		}

		AfSpConnContext = pConnObject->AfSpConnContext;

		pRootConnObject = pVc->pConnObject;
		RWAN_STRUCT_ASSERT(pRootConnObject, ntc);

#if DBG
		if (pConnObject->pAddrObject != NULL)
		{
			RWAN_ASSERT(pRootConnObject == pConnObject->pAddrObject->pRootConnObject);
		}
#endif // DBG

#ifndef NO_POST_DISCON
		if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{

			pDisconInd = pConnObject->pAddrObject->pDisconInd;
			IndContext = pConnObject->pAddrObject->DisconIndContext;

			ConnectionHandle = pConnObject->ConnectionHandle;
		}
		else
		{
			pDisconInd = NULL;
		}
#endif // NO_POST_DISCON

		pConnObject->NdisConnection.pNdisParty = NULL;
		rc = RWanDereferenceConnObject(pConnObject);	// Pty deref in DropPartyComplete

		if (rc > 0)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		if (pConnReq != NULL)
		{
#ifndef NO_POST_DISCON
			if (pDisconInd != NULL)
			{
				(*pDisconInd)(
						IndContext,
						ConnectionHandle,
						0,			// Disconnect Data Length
						NULL,		// Disconnect Data
						0,			// Disconnect Info Length
						NULL,		// Disconnect Info
						TDI_DISCONNECT_ABORT
						);
			}
#endif // NO_POST_DISCON
			RWanCompleteConnReq(		// DropPartyComplete - completing discon req
						pAf,
						pConnReq,
						IsOutgoingCall,
						NULL,
						AfSpConnContext,
						TDI_SUCCESS
						);
		}

		//
		//  The Root Connection object lock controls access to
		//  the VC structure.
		//
		RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

		//
		//  Unlink the Party from the VC.
		//
		RWAN_DELETE_FROM_LIST(&(pParty->PartyLink));
		pVc->DroppingPartyCount --;	// DropPartyComplete

		//
		//  We may be in the process of shutting down this connection.
		//  This may be the penultimate Party going away. If so,
		//  continue the call close.
		//
		if (RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_NEEDS_CLOSE))
		{
			RWanStartCloseCall(pRootConnObject, pVc);
			//
			//  Root Conn lock is released within the above.
			//
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pRootConnObject);
		}
	}
	else
	{
		//
		//  Not sure if we can be here.
		//
		RWAN_ASSERT(FALSE);
	}
	

	//
	//  End of the road for this Party structure.
	//
	RWAN_FREE_MEM(pParty);	// DropParty Complete

}




VOID
RWanNdisIncomingDropParty(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurPartyContext,
	IN	PVOID						pBuffer,
	IN	UINT						BufferLength
	)
/*++

Routine Description:

	This is the NDIS entry point notifying us that a leaf of a PMP call is
	being dropped, either because the remote station terminated its session
	or because of network conditions.

	We simply inform the TDI client of a Disconnect on the Connection Object
	representing this leaf, similar to an incoming Close on a VC.

Arguments:

	Status				- Status code for the Drop party
	OurPartyContext		- Pointer to our Party structure
	pBuffer				- Optional accompanying info (ignored)
	BufferLength		- Length of above (ignored)

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY			pParty;
	PRWAN_NDIS_VC				pVc;
	PRWAN_TDI_CONNECTION		pConnObject;
	PRWAN_CONN_REQUEST			pConnReq;
	NDIS_HANDLE					NdisPartyHandle;
	BOOLEAN						bIsConnClosing;	// TdiCloseConnection?
	BOOLEAN						bIsLastLeaf;
	BOOLEAN						bScheduleDisconnect;

	pParty = (PRWAN_NDIS_PARTY)OurPartyContext;
	RWAN_STRUCT_ASSERT(pParty, npy);

	pVc = pParty->pVc;
	RWAN_STRUCT_ASSERT(pVc, nvc);

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("IncomingDrop: pPty x%x, pVc x%x, pConnObj x%x, AddingCnt %d, ActiveCnt %d\n",
				pParty, pVc, pParty->pConnObject, pVc->AddingPartyCount, pVc->ActivePartyCount));

	pConnObject = pParty->pConnObject;

	RWAN_ASSERT(pConnObject != NULL_PRWAN_TDI_CONNECTION);
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RWAN_ACQUIRE_CONN_LOCK(pConnObject);

	bIsLastLeaf = (pVc->AddingPartyCount + pVc->ActivePartyCount == 0);

	bIsConnClosing = RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING);

	if (bIsConnClosing)
	{
		//
		//  The user has initiated a TdiCloseConnection.
		//  Continue NDIS call teardown. When this completes,
		//  we'll complete the CloseConnection.
		//
		if (bIsLastLeaf)
		{
			RWanStartCloseCall(pConnObject, pVc);

			//
			//  Conn Lock is released within the above.
			//
		}
		else
		{
			NdisPartyHandle = pParty->NdisPartyHandle;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			Status = NdisClDropParty(
						NdisPartyHandle,
						NULL,		// No Drop Data
						0			// Length of above
						);
			
			if (Status != NDIS_STATUS_PENDING)
			{
				RWanNdisDropPartyComplete(
						Status,
						(NDIS_HANDLE)pParty
						);
			}
		}

		return;
	}


	switch (pConnObject->State)
	{
		case RWANS_CO_IN_CALL_ACCEPTING:

			RWAN_ASSERT(FALSE);
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;

		case RWANS_CO_CONNECTED:
			//
			//  If there is a Disconnect Event handler, call it.
			//  Otherwise, simply mark this endpoint as having
			//  seen a Disconnect.
			//
			bScheduleDisconnect = TRUE;
			if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				if (pDisconInd != NULL)
				{
					pConnObject->State = RWANS_CO_DISCON_INDICATED;
					ConnectionHandle = pConnObject->ConnectionHandle;

					bScheduleDisconnect = FALSE;

					RWanScheduleDisconnect(pConnObject);
					//
					//  Conn Object lock is released within the above.
					//

					RWANDEBUGP(DL_EXTRA_LOUD, DC_DISCON,
							("IncomingDrop: will indicate Discon, pConnObj x%x, pAddrObj x%x\n",
								pConnObject, pConnObject->pAddrObject));

					(*pDisconInd)(
							IndContext,
							ConnectionHandle,
							0,			// Disconnect Data Length
							NULL,		// Disconnect Data
							0,			// Disconnect Info Length
							NULL,		// Disconnect Info
							TDI_DISCONNECT_ABORT
							);
				}
				else
				{
					pConnObject->State = RWANS_CO_DISCON_HELD;
				}
			}
			else
			{
				pConnObject->State = RWANS_CO_DISCON_HELD;
			}

			if (bScheduleDisconnect)
			{
				RWanScheduleDisconnect(pConnObject);
				//
				//  Conn Object lock is released within the above.
				//
			}

			break;

		case RWANS_CO_ABORTING:
		case RWANS_CO_DISCON_REQUESTED:
			//
			//  Ignore this.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;

		default:

			RWAN_ASSERT(FALSE);
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;
	}

	return;
}




VOID
RWanNdisModifyQoSComplete(
	IN	NDIS_STATUS					Status,
	IN	NDIS_HANDLE					OurVcContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	//
	//  Not expected, since we don't call NdisClModifyCallQoS
	//
	RWAN_ASSERT(FALSE);
}




VOID
RWanNdisRejectIncomingCall(
	IN	PRWAN_TDI_CONNECTION			pConnObject,
	IN	NDIS_STATUS					RejectStatus
	)
/*++

Routine Description:

	Reject the incoming call present on the specified Connection Object.

Arguments:

	pConnObject			- Points to the TDI Connection
	RejectStatus		- Reason for rejecting the call

Locks on Entry:

	pConnObject

Locks on Exit:

	None

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC				pVc;
	NDIS_HANDLE					NdisVcHandle;
	PCO_CALL_PARAMETERS			pCallParameters;
	INT							rc;
	PRWAN_CONN_REQUEST			pConnReq;
	PRWAN_NDIS_AF				pAf;
	RWAN_HANDLE					AfSpConnContext;

	pVc = pConnObject->NdisConnection.pNdisVc;

	NdisVcHandle = pVc->NdisVcHandle;
	pCallParameters = pVc->pCallParameters;
	pVc->pCallParameters = NULL;
	pAf = pVc->pNdisAf;

	//
	//  Unlink the VC from the Conn Object.
	//
	RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);	// Reject incoming call

	RWAN_SET_BIT(pVc->Flags, RWANF_VC_CLOSING_CALL);

	pConnReq = pConnObject->pConnReq;
	pConnObject->pConnReq = NULL;

	//
	//  State change.
	//
	if (pConnObject->State != RWANS_CO_ABORTING)
	{
		pConnObject->State = ((pConnObject->pAddrObject != NULL) ?
									RWANS_CO_ASSOCIATED:
									RWANS_CO_CREATED);
	}

	AfSpConnContext = pConnObject->AfSpConnContext;

	rc = RWanDereferenceConnObject(pConnObject);	// Unlinking VC in reject in-call

	if (rc > 0)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	NdisClIncomingCallComplete(
		RejectStatus,
		NdisVcHandle,
		pCallParameters
		);

	if (pConnReq != NULL)
	{
		RWanCompleteConnReq(		// Discon Req for rejecting in call
				pAf,
				pConnReq,
				FALSE,
				NULL,			// No Call Parameters
				AfSpConnContext,
				TDI_SUCCESS
				);
	}

	return;
}




VOID
RWanStartCloseCall(
	IN	PRWAN_TDI_CONNECTION		pConnObject,
	IN	PRWAN_NDIS_VC				pVc
	)
/*++

Routine Description:

	Start NDIS call teardown on the VC associated with the given
	connection object, if all pre-conditions are met:

	0. An NDIS CloseCall isn't already going on
	1. No outstanding sends

Arguments:

	pConnObject			- Points to TDI Connection object
	pVc					- Points to corresponding VC

Locks on Entry:

	pConnObject

Locks on Exit:

	None

Return Value:

	None

--*/
{
	PRWAN_NDIS_PARTY		pParty;
	NDIS_HANDLE				NdisVcHandle;
	NDIS_HANDLE				NdisPartyHandle;
	NDIS_STATUS				Status;
	PRWAN_RECEIVE_INDICATION	pRcvIndHead;
	PRWAN_RECEIVE_INDICATION	pRcvInd;

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("StartCloseCall: pVc x%x/x%x, PendingCount %d, pConnObj x%x\n",
					pVc,
					pVc->Flags,
					pVc->PendingPacketCount,
					pConnObject));

	//
	//  Free up any pending receives.
	//
	pRcvIndHead = pVc->pRcvIndHead;
	if (pRcvIndHead != NULL)
	{
		pVc->pRcvIndHead = NULL;
		pVc->pRcvIndTail = NULL;

		//
		//  Update the count of pending packets on this VC.
		//
		for (pRcvInd = pRcvIndHead; pRcvInd != NULL; pRcvInd = pRcvInd->pNextRcvInd)
		{
			pVc->PendingPacketCount--;
		}

		//
		//  We will free this list below.
		//
	}


	if ((pVc != NULL) &&
		(pVc->PendingPacketCount == 0) &&
		(pVc->DroppingPartyCount == 0) &&
		(!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_CLOSING_CALL)))
	{
		NdisVcHandle = pVc->NdisVcHandle;
		RWAN_SET_BIT(pVc->Flags, RWANF_VC_CLOSING_CALL);

		RWAN_RESET_BIT(pVc->Flags, RWANF_VC_NEEDS_CLOSE);

		if (RWAN_IS_LIST_EMPTY(&(pVc->NdisPartyList)))
		{
			pParty = NULL_PRWAN_NDIS_PARTY;
			NdisPartyHandle = NULL;
			RWAN_ASSERT(!RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_PMP));
		}
		else
		{
			pParty = CONTAINING_RECORD(pVc->NdisPartyList.Flink, RWAN_NDIS_PARTY, PartyLink);
			NdisPartyHandle = pParty->NdisPartyHandle;

			RWAN_SET_BIT(pParty->Flags, RWANF_PARTY_DROPPING);

			pVc->DroppingPartyCount ++;	// StartCloseCall PMP
			pVc->ActivePartyCount --;	// StartCloseCall PMP
		}

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		Status = NdisClCloseCall(
						NdisVcHandle,
						NdisPartyHandle,
						NULL,				// No CloseData
						0
						);

		if (Status != NDIS_STATUS_PENDING)
		{
			RWanNdisCloseCallComplete(
						Status,
						(NDIS_HANDLE)pVc,	// ProtocolVcContext
						(NDIS_HANDLE)pParty	// ProtocolPartyContext
					);
		}
	}
	else
	{
		if (pVc != NULL)
		{
			RWAN_SET_BIT(pVc->Flags, RWANF_VC_NEEDS_CLOSE);
		}
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}


	if (pRcvIndHead != NULL)
	{
		RWANDEBUGP(DL_INFO, DC_DISCON,
				("RWanStartCloseCall: will free rcv ind list x%x on VC x%x\n",
						pRcvIndHead, pVc));

		RWanFreeReceiveIndList(pRcvIndHead);
	}
}




VOID
RWanUnlinkVcFromAf(
	IN	PRWAN_NDIS_VC				pVc
	)
/*++

Routine Description:

	Unlink a VC from the AF it belongs to.

Arguments:

	pVc					- Points to VC to be unlinked

Return Value:

	None

--*/
{
	PRWAN_NDIS_AF			pAf;
	INT						rc;

	pAf = pVc->pNdisAf;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RWAN_ACQUIRE_AF_LOCK(pAf);

	RWAN_DELETE_FROM_LIST(&(pVc->VcLink));

	rc = RWanDereferenceAf(pAf);		// VC unlink deref

	if (rc != 0)
	{
		RWAN_RELEASE_AF_LOCK(pAf);
	}

	return;
}



VOID
RWanCompleteConnReq(
	IN	PRWAN_NDIS_AF				pAf,
	IN	PRWAN_CONN_REQUEST			pConnReq,
	IN	BOOLEAN						IsOutgoingCall,
	IN	PCO_CALL_PARAMETERS			pCallParameters	OPTIONAL,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	TDI_STATUS					TdiStatus
	)
/*++

Routine Description:

	Call the completion routine for a pended TDI request on a connection.
	Set up the options and completion status based on what's given to us.

Arguments:

	pAf					- The AF block on which the request was made
	pConnReq			- the pended request to be completed
	IsOutgoingCall		- Is this an outgoing call?
	pCallParameters		- if applicable, this should be mapped to connection info
	AfSpConnContext		- Connection context, if applicable, for the media-specific
						  module.
	TdiStatus			- completion status for the request

Return Value:

	None

--*/
{
	RWAN_STATUS			RWanStatus;
	ULONG				TdiQoSLength = 0;

	if (pConnReq == NULL)
	{
		return;
	}

	RWAN_STRUCT_ASSERT(pConnReq, nrc);

	//
	//  Update Connection Information if we need to.
	//
	if ((pConnReq->pConnInfo != NULL) &&
		(pCallParameters != NULL))
	{
		RWanStatus =  (*pAf->pAfInfo->AfChars.pAfSpUpdateTdiOptions)(
							pAf->AfSpAFContext,
							AfSpConnContext,
							IsOutgoingCall,
							pCallParameters,
							&pConnReq->pConnInfo,
							pConnReq->pConnInfo->Options,
							&pConnReq->pConnInfo->OptionsLength
							);
	}

	//
	//  Call the completion routine.
	//
	(*pConnReq->Request.pReqComplete)(
			pConnReq->Request.ReqContext,
			TdiStatus,
			0
			);

	RWanFreeConnReq(pConnReq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\ntentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\ntentry.c

Abstract:

	NT specific entry points for dispatching and handling TDI IRPs. Based on
	TCP source.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-21-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'IDTN'



#define RWAN_COMPLETE_IRP(_pIrp, _Status, _Info)						\
			{														\
				(_pIrp)->IoStatus.Status = (NTSTATUS)(_Status);		\
				(_pIrp)->IoStatus.Information = (_Info);			\
				IoCompleteRequest(_pIrp, IO_NETWORK_INCREMENT);		\
			}






NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT				pDriverObject,
	IN	PUNICODE_STRING				pRegistryPath
	)
/*++

Routine Description:

	This is the "init" routine called by the system when Raw WAN
	is loaded. We initialize all our global objects, fill in our
	Dispatch and Unload routine addresses in the driver object.

	We initialize the media/AF specific modules, and they register support
	for TDI protocols, at which time we create device objects.

Arguments:

	pDriverObject	- Pointer to the driver object created by the system.
	pRegistryPath	- Pointer to our global registry path. This is ignored.

Return Value:

	NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
	NTSTATUS				Status;
	RWAN_STATUS				RWanStatus;
	PDEVICE_OBJECT			pDeviceObject;
	UNICODE_STRING			DeviceName;
	INT						i;

	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("RWanDebugLevel is %d, &RWanDebugLevel at %p\n",
				RWanDebugLevel, &RWanDebugLevel));
	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("RWanDebugComp is x%x, &RWanDebugComp at %p\n",
				RWanDebugComp, &RWanDebugComp));
	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("RWanGlobals at %p\n", &RWanGlobals));
#if DBG
	RWANDEBUGP(DL_FATAL, DC_WILDCARD,
			("To skip everything set RWanSkipAll at %p to 1\n", &RWanSkipAll));

	if (RWanSkipAll)
	{
		RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Aborting DriverEntry\n"));
		return (STATUS_UNSUCCESSFUL);
	}

	NdisAllocateSpinLock(&RWanDbgLogLock);
#if DBG_LOG_PACKETS
	NdisAllocateSpinLock(&RWanDPacketLogLock);
#endif
#endif // DBG


	RWanStatus = RWanInitGlobals(pDriverObject);

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		return (STATUS_UNSUCCESSFUL);
	}

	//
	//  Register as an NDIS protocol.
	//
	RWAN_ZERO_MEM(&RWanNdisProtocolCharacteristics, sizeof(RWanNdisProtocolCharacteristics));

	RWanNdisProtocolCharacteristics.MajorNdisVersion = RWAN_NDIS_MAJOR_VERSION;
	RWanNdisProtocolCharacteristics.MinorNdisVersion = RWAN_NDIS_MINOR_VERSION;
	RWanNdisProtocolCharacteristics.OpenAdapterCompleteHandler = RWanNdisOpenAdapterComplete;
	RWanNdisProtocolCharacteristics.CloseAdapterCompleteHandler = RWanNdisCloseAdapterComplete;
	RWanNdisProtocolCharacteristics.SendCompleteHandler = RWanNdisSendComplete;
	RWanNdisProtocolCharacteristics.TransferDataCompleteHandler = RWanNdisTransferDataComplete;
	RWanNdisProtocolCharacteristics.ResetCompleteHandler = RWanNdisResetComplete;
	RWanNdisProtocolCharacteristics.RequestCompleteHandler = RWanNdisRequestComplete;
	RWanNdisProtocolCharacteristics.ReceiveHandler = RWanNdisReceive;
	RWanNdisProtocolCharacteristics.ReceiveCompleteHandler = RWanNdisReceiveComplete;
	RWanNdisProtocolCharacteristics.StatusHandler = RWanNdisStatus;
	RWanNdisProtocolCharacteristics.StatusCompleteHandler = RWanNdisStatusComplete;
	NdisInitUnicodeString(
		&RWanNdisProtocolCharacteristics.Name,
		RWAN_NAME
	);
	RWanNdisProtocolCharacteristics.ReceivePacketHandler = RWanNdisReceivePacket;
	RWanNdisProtocolCharacteristics.BindAdapterHandler = RWanNdisBindAdapter;
	RWanNdisProtocolCharacteristics.PnPEventHandler = RWanNdisPnPEvent;
	RWanNdisProtocolCharacteristics.UnbindAdapterHandler = RWanNdisUnbindAdapter;
	RWanNdisProtocolCharacteristics.UnloadHandler = (UNLOAD_PROTOCOL_HANDLER)RWanUnloadProtocol;
#ifdef _PNP_POWER_
	RWanNdisProtocolCharacteristics.PnpEventHandler = RWanNdisPnPEvent;
#endif // _PNP_POWER_
	RWanNdisProtocolCharacteristics.CoSendCompleteHandler = RWanNdisCoSendComplete;
	RWanNdisProtocolCharacteristics.CoStatusHandler = RWanNdisCoStatus;
	RWanNdisProtocolCharacteristics.CoReceivePacketHandler = RWanNdisCoReceivePacket;
#if 0
	RWanNdisProtocolCharacteristics.CoRequestHandler = RWanNdisCoRequest;
	RWanNdisProtocolCharacteristics.CoRequestCompleteHandler = RWanNdisCoRequestComplete;
#endif
	RWanNdisProtocolCharacteristics.CoAfRegisterNotifyHandler = RWanNdisAfRegisterNotify;

	RWAN_ZERO_MEM(&RWanNdisClientCharacteristics, sizeof(RWanNdisClientCharacteristics));

	RWanNdisClientCharacteristics.MajorVersion = RWAN_NDIS_MAJOR_VERSION;
	RWanNdisClientCharacteristics.MinorVersion = RWAN_NDIS_MINOR_VERSION;
	RWanNdisClientCharacteristics.ClCreateVcHandler = RWanNdisCreateVc;
	RWanNdisClientCharacteristics.ClDeleteVcHandler = RWanNdisDeleteVc;
	RWanNdisClientCharacteristics.ClOpenAfCompleteHandler = RWanNdisOpenAddressFamilyComplete;
	RWanNdisClientCharacteristics.ClCloseAfCompleteHandler = RWanNdisCloseAddressFamilyComplete;
	RWanNdisClientCharacteristics.ClRegisterSapCompleteHandler = RWanNdisRegisterSapComplete;
	RWanNdisClientCharacteristics.ClDeregisterSapCompleteHandler = RWanNdisDeregisterSapComplete;
	RWanNdisClientCharacteristics.ClMakeCallCompleteHandler = RWanNdisMakeCallComplete;
	RWanNdisClientCharacteristics.ClModifyCallQoSCompleteHandler = RWanNdisModifyQoSComplete;
	RWanNdisClientCharacteristics.ClCloseCallCompleteHandler = RWanNdisCloseCallComplete;
	RWanNdisClientCharacteristics.ClAddPartyCompleteHandler = RWanNdisAddPartyComplete;
	RWanNdisClientCharacteristics.ClDropPartyCompleteHandler = RWanNdisDropPartyComplete;
	RWanNdisClientCharacteristics.ClIncomingCallHandler = RWanNdisIncomingCall;
	RWanNdisClientCharacteristics.ClIncomingCallQoSChangeHandler = (CL_INCOMING_CALL_QOS_CHANGE_HANDLER)NULL;
	RWanNdisClientCharacteristics.ClIncomingCloseCallHandler = RWanNdisIncomingCloseCall;
	RWanNdisClientCharacteristics.ClIncomingDropPartyHandler = RWanNdisIncomingDropParty;
	RWanNdisClientCharacteristics.ClCallConnectedHandler = RWanNdisCallConnected;
#if 1
	RWanNdisClientCharacteristics.ClRequestHandler = RWanNdisCoRequest;
	RWanNdisClientCharacteristics.ClRequestCompleteHandler = RWanNdisCoRequestComplete;
#endif

	NdisRegisterProtocol(
		&Status,
		&(pRWanGlobal->ProtocolHandle),
		&RWanNdisProtocolCharacteristics,
		sizeof(RWanNdisProtocolCharacteristics)
		);
	
	if (Status != NDIS_STATUS_SUCCESS)
	{
		return (Status);
	}

#if DBG
	if (RWanSkipAll)
	{
		RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Aborting DriverEntry\n"));

		NdisDeregisterProtocol(
			&Status,
			pRWanGlobal->ProtocolHandle
			);

		return (STATUS_UNSUCCESSFUL);
	}
#endif // DBG

	//
	//  Tell all media-specific modules to initialize.
	//
	RWanStatus = RWanInitMediaSpecific();

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		NdisDeregisterProtocol(
			&Status,
			pRWanGlobal->ProtocolHandle
			);

		return (STATUS_UNSUCCESSFUL);
	}


#if !BINARY_COMPATIBLE
	//
	//  Initialize the Driver Object.
	//
	pDriverObject->DriverUnload = RWanUnload;
	pDriverObject->FastIoDispatch = NULL;

	for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
	{
		pDriverObject->MajorFunction[i] = RWanDispatch;
	}

	pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
		RWanDispatchInternalDeviceControl;

#endif // !BINARY_COMPATIBLE


	return (STATUS_SUCCESS);

}



VOID
RWanUnload(
	IN	PDRIVER_OBJECT				pDriverObject
	)
/*++

Routine Description:

	This is called by the system prior to unloading us. Undo everything
	we did in DriverEntry.

Arguments:

	pDriverObject	- Pointer to the driver object representing us.

Return Value:

	None

--*/
{
#if DBG
	RWanDebugLevel = DL_EXTRA_LOUD;
	RWanDebugComp = DC_WILDCARD;
#endif

	RWANDEBUGP(DC_DISPATCH, DL_INFO,
			("RWanUnload entered: RWanGlobals at %p\n", &RWanGlobals));

	RWanUnloadProtocol();

	RWANDEBUGP(DC_DISPATCH, DL_INFO,
			("RWanUnload exiting\n"));
}




VOID
RWanUnloadProtocol(
	VOID
	)
/*++

Routine Description:

	Unloads the Raw WAN protocol module. We unbind from all adapters,
	and shut down all media specific modules.

Arguments:

	None

Return Value:

	None

--*/
{
	NDIS_STATUS					Status;
	PRWAN_NDIS_ADAPTER			pAdapter;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	RWAN_ACQUIRE_GLOBAL_LOCK();

	if (pRWanGlobal->UnloadDone)
	{
		RWANDEBUGP(DL_INFO, DC_WILDCARD,
			("UnloadProtocol: already done!\n"));
		RWAN_RELEASE_GLOBAL_LOCK();
		return;
	}

	pRWanGlobal->UnloadDone = TRUE;

	RWAN_RELEASE_GLOBAL_LOCK();

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWANDEBUGP(DL_FATAL, DC_DISPATCH,
			("RWanUnloadProtocol: will deregister protocol now\n"));

	NdisDeregisterProtocol(
			&Status,
			pRWanGlobal->ProtocolHandle
			);

	RWANDEBUGP(DL_FATAL, DC_DISPATCH,
		("UnloadProtocol: dereg protocol done\n"));

	RWanDeinitGlobals();

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWanShutdownMediaSpecific();

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
#if DBG
	RWanAuditShutdown();
#endif // DBG

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
}




NTSTATUS
RWanDispatch(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	)
/*++

Routine Description:

	System entry point for all IRPs dispatched to Raw WAN device objects.

Arguments:

	pDeviceObject	- Points to a device object created by RawWan. This
					  device object identifies a supported Winsock 2 triple
					  <Address Family, Type, Proto>.
	pIrp			- Pointer to the IRP

Return Value:

	NTSTATUS - STATUS_SUCCESS for immediate requests (such as create) that
	we successfully process, STATUS_PENDING for queued IRPs, and STATUS_XXX
	error codes for any failures.

--*/
{
	PIO_STACK_LOCATION				pIrpSp;
	NTSTATUS						Status;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0;

	RWAN_ASSERT(pIrpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);


	switch (pIrpSp->MajorFunction)
	{
		case IRP_MJ_CREATE:

			Status = RWanCreate(pDeviceObject, pIrp, pIrpSp);
			break;

		case IRP_MJ_CLEANUP:

			Status = RWanCleanup(pDeviceObject, pIrp, pIrpSp);
			break;
		
		case IRP_MJ_CLOSE:

			Status = RWanClose(pDeviceObject, pIrp, pIrpSp);
			break;
		
		case IRP_MJ_DEVICE_CONTROL:

			Status = TdiMapUserRequest(pDeviceObject, pIrp, pIrpSp);
			//
			//  TBD - get rid of the call to TdiMapUserRequest - AFD will be
			//  fixed so that we shouldn't see TDI commands come this way.
			//

			if (Status == STATUS_SUCCESS)
			{
				if (pIrpSp->MinorFunction == TDI_ASSOCIATE_ADDRESS ||
					pIrpSp->MinorFunction == TDI_DISASSOCIATE_ADDRESS)
				{
					return (RWanDispatchInternalDeviceControl(pDeviceObject, pIrp));
				}
				else
				{
					Status = STATUS_ACCESS_DENIED;
				}
			}
			else
			{
				return (RWanDispatchPrivateDeviceControl(pIrp, pIrpSp));
			}
			break;
		
		case IRP_MJ_READ:
		case IRP_MJ_WRITE:
		default:

			RWANDEBUGP(DL_WARN, DC_DISPATCH,
					("RWanDispatch: Unknown MajorFunction x%x\n", pIrpSp->MajorFunction));
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}


	RWAN_ASSERT(Status != TDI_PENDING);

	RWAN_COMPLETE_IRP(pIrp, Status, 0);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanDispatch: pIrp %p, MajorFunc %d, returning Status x%x, Info %d\n",
					pIrp, pIrpSp->MajorFunction, Status, pIrp->IoStatus.Information));

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return (Status);
}




NTSTATUS
RWanCreate(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	PIO_STACK_LOCATION				pIrpSp
	)
/*++

Routine Description:

	This is called when a TDI client calls CreateFile. We allocate an
	ENDPOINT structure as our context for this endpoint. Based on
	parameters in the IRP, this is either an Address object, Connection
	object, or a Control channel.

Arguments:

	pDeviceObject	- Identifies the protocol being CreateFile'd
	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_SUCCESS if we create the endpoint successfully,
	STATUS_INSUFFICIENT_RESOURCES if we fail to allocate, and
	STATUS_INVALID_PARAMETER if we find any parameter incorrect.

--*/
{
	NTSTATUS								Status;
	FILE_FULL_EA_INFORMATION *				pEa;
	FILE_FULL_EA_INFORMATION UNALIGNED *	pTargetEa;

	//
	//  Device being accessed.
	//
	PRWAN_DEVICE_OBJECT						pRWanDevice;

	//
	//  Endpoint to represent this object creation.
	//
	PRWAN_ENDPOINT							pEndpoint;

	//
	//  TDI Request to be passed down to our TDI layer.
	//
	TDI_REQUEST								TdiRequest;

	//
	//  Parameters to be passed down to our TDI layer.
	//
	UINT									Protocol;
	UCHAR									OptionsBuffer[3];
	PUCHAR									pOptions;



	PAGED_CODE();

	//
	//  Initialize.
	//
	pEndpoint = NULL_PRWAN_ENDPOINT;

	do
	{
		//
		//  Locate the TDI Protocol being opened.
		//
		pRWanDevice = *(PRWAN_DEVICE_OBJECT *)(pDeviceObject->DeviceExtension);

		if (pRWanDevice == NULL)
		{
			Status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		//
		//  Allocate and initialize an Endpoint to represent
		//  this newly created object.
		//
		RWAN_ALLOC_MEM(pEndpoint, RWAN_ENDPOINT, sizeof(RWAN_ENDPOINT));

		if (pEndpoint == NULL_PRWAN_ENDPOINT)
		{
			Status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}

		RWAN_ZERO_MEM(pEndpoint, sizeof(RWAN_ENDPOINT));

		RWAN_SET_SIGNATURE(pEndpoint, nep);

		pEndpoint->RefCount = 1;
		pEndpoint->bCancelIrps = FALSE;
		KeInitializeEvent(&pEndpoint->CleanupEvent, SynchronizationEvent, FALSE);
		pEndpoint->pProtocol = pRWanDevice->pProtocol;

		RWAN_EP_DBGLOG_SET_SIGNATURE(pEndpoint);

		pEa = (PFILE_FULL_EA_INFORMATION)pIrp->AssociatedIrp.SystemBuffer;

		//
		//  See if this is a Control Channel.
		//
		if (!pEa)
		{
			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
					("RWanCreate: pIrp %p, File obj %p, Control Channel\n",
						pIrp, pIrpSp->FileObject));

			RWAN_ASSERT(pRWanDevice->pProtocol);

			pEndpoint->Handle.ControlChannel = pRWanDevice->pProtocol;
			pIrpSp->FileObject->FsContext = pEndpoint;
			pIrpSp->FileObject->FsContext2 = (PVOID)TDI_CONTROL_CHANNEL_FILE;

			RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'CCrC', 0, 0);

			Status = STATUS_SUCCESS;
			break;
		}

		//
		//  See if this is an Address Object.
		//

		pTargetEa = RWanFindEa(
						pEa,
						TdiTransportAddress,
						TDI_TRANSPORT_ADDRESS_LENGTH
						);
	
		if (pTargetEa != NULL)
		{
			RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'OArC', 0, 0);

			if (pTargetEa->EaValueLength < sizeof(TRANSPORT_ADDRESS))
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if (!pRWanDevice->pProtocol->bAllowAddressObjects)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			Protocol = pRWanDevice->pProtocol->SockProtocol;
			pOptions = OptionsBuffer;

			if ((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
				(pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE))
			{
				*pOptions = TDI_ADDRESS_OPTION_REUSE;
				pOptions++;
			}

			*pOptions = TDI_OPTION_EOL;

			//
			//  Call our TDI entry point.
			//
			Status = RWanTdiOpenAddress(
							&TdiRequest,
							(TRANSPORT_ADDRESS UNALIGNED *)
								&(pTargetEa->EaName[pTargetEa->EaNameLength + 1]),
							pTargetEa->EaValueLength,
							Protocol,
							OptionsBuffer
							);

			if (NT_SUCCESS(Status))
			{
				pEndpoint->Handle.AddressHandle = TdiRequest.Handle.AddressHandle;
				pIrpSp->FileObject->FsContext = pEndpoint;
				pIrpSp->FileObject->FsContext2 = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
			}

			break;
		}

		//
		//  See if this is a Connection Object.
		//
		pTargetEa = RWanFindEa(
						pEa,
						TdiConnectionContext,
						TDI_CONNECTION_CONTEXT_LENGTH
						);

		if (pTargetEa != NULL)
		{
			RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'OCrC', 0, 0);

			if (pTargetEa->EaValueLength < sizeof(CONNECTION_CONTEXT))
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if (!pRWanDevice->pProtocol->bAllowConnObjects)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			//
			//  Call our TDI entry point for opening a Connection object.
			//
			Status = RWanTdiOpenConnection(
							&TdiRequest,
							*((CONNECTION_CONTEXT UNALIGNED *)
								&(pTargetEa->EaName[pTargetEa->EaNameLength + 1]))
							);

			if (NT_SUCCESS(Status))
			{
#if DBG
				pEndpoint->pConnObject = RWanTdiDbgGetConnObject(
											TdiRequest.Handle.ConnectionContext
											);
#endif
				pEndpoint->Handle.ConnectionContext = TdiRequest.Handle.ConnectionContext;
				pIrpSp->FileObject->FsContext = pEndpoint;
				pIrpSp->FileObject->FsContext2 = (PVOID)TDI_CONNECTION_FILE;
			}

			break;

		}

		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	while (FALSE);

	
	if (Status != STATUS_SUCCESS)
	{
		//
		//  Clean up.
		//
		if (pEndpoint != NULL)
		{
			RWAN_FREE_MEM(pEndpoint);
			pEndpoint = NULL;
		}
	}

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanCreate: pIrp %p, pEndpoint %p, Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanCleanup(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Called to process an MJ_CLEANUP IRP. All outstanding IRPs are cancelled
	by calling the appropriate close routine for the object.

	We block until all outstanding IRPs are completed.

Arguments:

	pDeviceObject	- Not used
	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - this is the final clean-up status.

--*/
{
	RWAN_IRQL				OldIrql;
	PIRP					pCancelIrp;
	PRWAN_ENDPOINT			pEndpoint;
	TDI_REQUEST				TdiRequest;
	NTSTATUS				Status;

	UNREFERENCED_PARAMETER(pDeviceObject);

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;

	RWAN_STRUCT_ASSERT(pEndpoint, nep);


	IoAcquireCancelSpinLock(&OldIrql);

	pEndpoint->bCancelIrps = TRUE;
	KeResetEvent(&(pEndpoint->CleanupEvent));

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'ealC', pIrp, pEndpoint->RefCount);

	IoReleaseCancelSpinLock(OldIrql);


	//
	//  Prepare a Close request for the TDI layer.
	//
	TdiRequest.RequestNotifyObject = RWanCloseObjectComplete;
	TdiRequest.RequestContext = pIrp;

	switch ((INT)PtrToUint(pIrpSp->FileObject->FsContext2))
	{
		case TDI_TRANSPORT_ADDRESS_FILE:

			TdiRequest.Handle.AddressHandle = pEndpoint->Handle.AddressHandle;
			Status = RWanTdiCloseAddress(&TdiRequest);
			break;

		case TDI_CONNECTION_FILE:

			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			Status = RWanTdiCloseConnection(&TdiRequest);
			break;

		case TDI_CONTROL_CHANNEL_FILE:

			Status = STATUS_SUCCESS;
			break;

		default:

			RWAN_ASSERT(FALSE);

			IoAcquireCancelSpinLock(&OldIrql);
			pEndpoint->bCancelIrps = FALSE;
			IoReleaseCancelSpinLock(OldIrql);

			return (STATUS_INVALID_PARAMETER);
	}

	if (Status != TDI_PENDING)
	{
		RWanCloseObjectComplete(pIrp, Status, 0);
	}

	//
	//  Wait until all IRPs are completed.
	//
	Status = KeWaitForSingleObject(
					&(pEndpoint->CleanupEvent),
					UserRequest,
					KernelMode,
					FALSE,
					NULL
					);

	RWAN_ASSERT(NT_SUCCESS(Status));

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanCleanup: pIrp %p, Context2 %d, pEndpoint %p, returning Status x%x\n",
				pIrp, 
				(INT)PtrToUint(pIrpSp->FileObject->FsContext2),
				pEndpoint,
				pIrp->IoStatus.Status));

	return (pIrp->IoStatus.Status);
}




NTSTATUS
RWanClose(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Called to destroy an endpoint that was created via MJ_CREATE.
	We'd have already processed and completed an MJ_CLEANUP,
	meaning that there would be no pending IRPs on this endpoint.
	All we need to do is deallocate the endpoint.

Arguments:

	pDeviceObject	- Identifies the protocol (not used)
	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NT_STATUS - always STATUS_SUCCESS

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;

	UNREFERENCED_PARAMETER(pDeviceObject);

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
			("RWanClose: pIrp %p, pEndpoint %p\n", pIrp, pEndpoint));

	RWAN_FREE_MEM(pEndpoint);

	return (STATUS_SUCCESS);

}




NTSTATUS
RWanDispatchInternalDeviceControl(
	IN	PDEVICE_OBJECT				pDeviceObject,
	IN	PIRP						pIrp
	)
/*++

Routine Description:

	Called to handle MJ_DEVICE_CONTROL IRPs sent to us. These IRPs
	carry TDI primitives (e.g. CONNECT, DISCONNECT, SEND, RECEIVE).
	We call the appropriate TDI routine to handle the specified
	primitive.

Arguments:

	pDeviceObject	- Identifies the protocol (Not used here)
	pIrp			- Pointer to IRP

Return Value:

	NTSTATUS - this is STATUS_PENDING if the IRP was successfully
	queued for processing, STATUS_NOT_IMPLEMENTED for unsupported
	TDI commands, and STATUS_INVALID_DEVICE_REQUEST for unknown
	commands.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	PIO_STACK_LOCATION			pIrpSp;
	NTSTATUS					Status;
	BOOLEAN						bDone;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	UNREFERENCED_PARAMETER(pDeviceObject);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanDispatchInternalDevCtl: pIrp %p, pIrpSp %p, pEndpoint %p, Ctx2 %d\n",
				pIrp, pIrpSp, pEndpoint,
				(INT)PtrToUint(pIrpSp->FileObject->FsContext2)));

	do
	{
		if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE)
		{
			if (pIrpSp->MinorFunction == TDI_SEND)
			{
				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'dneS', 0, 0);
	
				Status = RWanSendData(pIrp, pIrpSp);
				break;
			}

			if (pIrpSp->MinorFunction == TDI_RECEIVE)
			{
				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'vceR', 0, 0);
	
				Status = RWanReceiveData(pIrp, pIrpSp);
				break;
			}

			bDone = TRUE;

			switch (pIrpSp->MinorFunction)
			{
				case TDI_ASSOCIATE_ADDRESS:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'AssA', pIrp, pEndpoint->RefCount);
	
					Status = RWanAssociateAddress(pIrp, pIrpSp);
					RWAN_COMPLETE_IRP(pIrp, Status, 0);
					break;

				case TDI_DISASSOCIATE_ADDRESS:
			
					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'AsiD', pIrp, pEndpoint->RefCount);

					Status = RWanDisassociateAddress(pIrp, pIrpSp);
					break;

				case TDI_CONNECT:
			
					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'nnoC', pIrp, pEndpoint->RefCount);

					Status = RWanConnect(pIrp, pIrpSp);
					break;

				case TDI_DISCONNECT:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'csiD', pIrp, pEndpoint->RefCount);

					Status = RWanDisconnect(pIrp, pIrpSp);
					break;

				case TDI_LISTEN:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'tsiL', pIrp, pEndpoint->RefCount);

					Status = RWanListen(pIrp, pIrpSp);
					break;

				case TDI_ACCEPT:

					RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'eccA', pIrp, pEndpoint->RefCount);

					Status = RWanAccept(pIrp, pIrpSp);
					break;

				default:
					bDone = FALSE;

#if 0
	// Allow TDI_QUERY_INFORMATION on Conn endpoints to fall through
					RWANDEBUGP(DL_WARN, DC_DISPATCH,
						("RWanDispatchInternalDevCtl: pIrp %p, pIrpSp %p, unknown func x%x\n",
							pIrp, pIrpSp, pIrpSp->MinorFunction));

					Status = STATUS_INVALID_DEVICE_REQUEST;

					RWAN_COMPLETE_IRP(pIrp, Status, 0);
#else
					bDone = FALSE;
#endif
					break;
			}

			if (bDone)
			{
				break;
			}
			//
			//  else fall through - may be something common to all types
			//  of endpoints.
			//

		}
		else if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_TRANSPORT_ADDRESS_FILE)
		{
			if (pIrpSp->MinorFunction == TDI_SET_EVENT_HANDLER)
			{
				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'EteS', 0, 0);

				Status = RWanSetEventHandler(pIrp, pIrpSp);

				RWAN_COMPLETE_IRP(pIrp, Status, 0);

				break;
			}
		}

		RWAN_ASSERT(
			(((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_TRANSPORT_ADDRESS_FILE)
			||
			(((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE)
			||
			(((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONTROL_CHANNEL_FILE)
			);

		//
		//  Check if this is a function common to all types of endpoints.
		//
		switch (pIrpSp->MinorFunction)
		{
			case TDI_QUERY_INFORMATION:

				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'IyrQ', 0, 0);

				Status = RWanQueryInformation(pIrp, pIrpSp);
				break;
			
			case TDI_SET_INFORMATION:
			case TDI_ACTION:

				RWANDEBUGP(DL_INFO, DC_DISPATCH,
						("RWanDispatchInternalDevCtl: SET_INFO/ACTION not supported\n"));

				RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'IteS', 0, 0);

				Status = STATUS_NOT_IMPLEMENTED;
				RWAN_COMPLETE_IRP(pIrp, Status, 0);
				break;
			
			default:
			
				Status = STATUS_INVALID_DEVICE_REQUEST;
				RWAN_COMPLETE_IRP(pIrp, Status, 0);
				break;
		}

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanDispatchInternalDevCtl: pIrp %p, pIrpSp %p, Maj/Min %d/%d, Status x%x\n",
					pIrp, pIrpSp, pIrpSp->MajorFunction, pIrpSp->MinorFunction, Status));

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
	return (Status);
}


NTSTATUS
RWanDispatchPrivateDeviceControl(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Called to handle MJ_DEVICE_CONTROL IRPs sent to us that contain
	non-TDI primitives.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - this is STATUS_PENDING if the IRP was successfully
	queued for processing, STATUS_NOT_IMPLEMENTED for unsupported
	commands, and STATUS_INVALID_DEVICE_REQUEST for unknown
	commands.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	RWAN_STATUS					RWanStatus;
	NTSTATUS					Status;
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PVOID						pInputBuffer;
	PVOID						pOutputBuffer;
	ULONG						InputBufferLength;
	ULONG						OutputBufferLength;

	PAGED_CODE();

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	//
	//  Initialize.
	//
	pIrp->IoStatus.Information = 0;
	Status = STATUS_INVALID_DEVICE_REQUEST;

	//
	//  Get some parameters from the IRP.
	//
	pInputBuffer = pIrp->AssociatedIrp.SystemBuffer;
	pOutputBuffer = pIrp->AssociatedIrp.SystemBuffer;

	InputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
	OutputBufferLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

	RWANDEBUGP(DL_INFO, DC_DISPATCH,
			("PrivateDevCtl: pEndpoint %p, CtlCode x%x, InBuf %p/%d, OutBuf %p/%d\n",
				pEndpoint,
				pIrpSp->Parameters.DeviceIoControl.IoControlCode,
				pInputBuffer,
				InputBufferLength,
				pOutputBuffer,
				OutputBufferLength));

	switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
	{
		case IOCTL_RWAN_GENERIC_GLOBAL_QUERY:
		case IOCTL_RWAN_GENERIC_GLOBAL_SET:
			Status = STATUS_NOT_IMPLEMENTED;
			break;
		
		case IOCTL_RWAN_GENERIC_CONN_HANDLE_QUERY:

			if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) != TDI_CONNECTION_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleGenericConnQryInfo(
							pEndpoint->Handle.ConnectionContext,
							pInputBuffer,
							InputBufferLength,
							pOutputBuffer,
							&OutputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);
			if (Status != STATUS_SUCCESS)
			{
				OutputBufferLength = 0;
			}

			break;

		case IOCTL_RWAN_GENERIC_ADDR_HANDLE_QUERY:
		case IOCTL_RWAN_GENERIC_CONN_HANDLE_SET:
			Status = STATUS_NOT_IMPLEMENTED;
			break;

		case IOCTL_RWAN_GENERIC_ADDR_HANDLE_SET:

			if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) != TDI_TRANSPORT_ADDRESS_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleGenericAddrSetInfo(
							pEndpoint->Handle.AddressHandle,
							pInputBuffer,
							InputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);
			OutputBufferLength = 0;

			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_QUERY:
			//
			//  Get the media-specific module's QueryInfo handler.
			//
			pAfChars = &(pEndpoint->pProtocol->pAfInfo->AfChars);

			if (pAfChars->pAfSpQueryGlobalInfo != NULL)
			{
				RWanStatus = (*pAfChars->pAfSpQueryGlobalInfo)(
									pEndpoint->pProtocol->pAfInfo->AfSpContext,
									pInputBuffer,
									InputBufferLength,
									pOutputBuffer,
									&OutputBufferLength
									);
				
				Status = RWanToNTStatus(RWanStatus);
				if (Status != STATUS_SUCCESS)
				{
					OutputBufferLength = 0;
				}
			}
			else
			{
				Status = STATUS_NOT_IMPLEMENTED;
			}
			break;
		
		case IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_SET:
			//
			//  Get the media-specific module's SetInfo handler.
			//
			pAfChars = &(pEndpoint->pProtocol->pAfInfo->AfChars);

			if (pAfChars->pAfSpSetGlobalInfo != NULL)
			{
				RWanStatus = (*pAfChars->pAfSpSetGlobalInfo)(
									pEndpoint->pProtocol->pAfInfo->AfSpContext,
									pInputBuffer,
									InputBufferLength
									);
				
				Status = RWanToNTStatus(RWanStatus);
			}
			else
			{
				Status = STATUS_NOT_IMPLEMENTED;
			}

			OutputBufferLength = 0;
			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_QUERY:

			if ((INT)PtrToUint(pIrpSp->FileObject->FsContext2) != TDI_CONNECTION_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleMediaSpecificConnQryInfo(
							pEndpoint->Handle.ConnectionContext,
							pInputBuffer,
							InputBufferLength,
							pOutputBuffer,
							&OutputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);

			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_QUERY:
		case IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_SET:
			Status = STATUS_NOT_IMPLEMENTED;
			break;

		case IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_SET:

			if ((INT)PtrToUint(pIrpSp->FileObject->FsContext2) != TDI_TRANSPORT_ADDRESS_FILE)
			{
				Status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			RWanStatus = RWanHandleMediaSpecificAddrSetInfo(
							pEndpoint->Handle.AddressHandle,
							pInputBuffer,
							InputBufferLength
							);

			Status = RWanToNTStatus(RWanStatus);
			OutputBufferLength = 0;

			break;

		default:

			OutputBufferLength = 0;
			Status = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	RWAN_ASSERT(Status != STATUS_PENDING);

	RWAN_COMPLETE_IRP(pIrp, Status, OutputBufferLength);
	return (Status);
}



FILE_FULL_EA_INFORMATION UNALIGNED *
RWanFindEa(
	IN	FILE_FULL_EA_INFORMATION *	pStartEa,
	IN	CHAR *						pTargetName,
	IN	USHORT						TargetNameLength
	)
/*++

Routine Description:

	Searches for a target name in an Extended Attribute list
	and returns it.

Arguments:

	pStartEa		- Start of the attribute list
	pTargetName		- Pointer to name to look for
	TargetNameLength- Length of name

Return Value:

	Pointer to attribute matching the target name, if found;
	NULL otherwise.

--*/
{
	FILE_FULL_EA_INFORMATION UNALIGNED *	pEa;
	FILE_FULL_EA_INFORMATION UNALIGNED *	pNextEa;
	BOOLEAN									Found;
	USHORT									i;

	PAGED_CODE();

	pNextEa = pStartEa;
	Found = FALSE;

	do	
	{
		pEa = pNextEa;
		pNextEa = (FILE_FULL_EA_INFORMATION UNALIGNED *)
						((PUCHAR)pNextEa + pNextEa->NextEntryOffset);

		if (pEa->EaNameLength == TargetNameLength)
		{
			for (i = 0; i < TargetNameLength; i++)
			{
				if (pEa->EaName[i] != pTargetName[i])
				{
					break;
				}
			}

			if (i == TargetNameLength)
			{
				Found = TRUE;
				break;
			}
		}
	}
	while (pEa->NextEntryOffset != 0);

	return (Found? pEa: NULL);

}




NTSTATUS
RWanSendData(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert an IRP containing a TDI_SEND request to a call to our TDI
	dispatch routine for sends. We retain enough context to be able
	to complete the IRP when the send completes.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if we managed to queue the send successfully,
	STATUS_CANCELLED if the IRP was cancelled.
	STATUS_SUCCESS if the send completed successfully, immediately.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	PTDI_REQUEST_KERNEL_SEND	pSendRequest;
	TDI_REQUEST					TdiRequest;
	NTSTATUS					Status;


	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pSendRequest = (PTDI_REQUEST_KERNEL_SEND) &(pIrpSp->Parameters);

	//
	//  Prepare a TDI Send request.
	//
	TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID) RWanDataRequestComplete;
	TdiRequest.RequestContext = (PVOID) pIrp;

	IoAcquireCancelSpinLock(&OldIrql);

	if (!pIrp->Cancel)
	{
		//
		//  The IRP hasn't been cancelled. Set it up so that we are
		//  informed if it does get cancelled later.
		//
		IoMarkIrpPending(pIrp);
		IoSetCancelRoutine(pIrp, RWanCancelRequest);

		RWAN_INCR_EP_REF_CNT(pEndpoint, SendIncr);		// Send ref

		RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'DneS', pIrp, pEndpoint->RefCount);

		IoReleaseCancelSpinLock(OldIrql);

		Status = RWanTdiSendData(
					&TdiRequest,
					(USHORT)pSendRequest->SendFlags,
					pSendRequest->SendLength,
					(PNDIS_BUFFER) pIrp->MdlAddress
					);

		if (Status != TDI_PENDING)
		{
			//
			//  The Send either completed immediately, or failed.
			//
			pIrpSp->Control &= ~SL_PENDING_RETURNED;

			if (Status == TDI_SUCCESS)
			{
				//
				//  Examples of immediate successful completion:
				//  - A zero length send
				//
				RWanDataRequestComplete(pIrp, Status, pSendRequest->SendLength);
			}
			else
			{
				//
				//  The Send failed, could be a resource problem.
				//

				RWANDEBUGP(DL_INFO, DC_DATA_TX,
						("RWanSendData: pIrp %p, pEndpoint %p, TDI send fail: x%x\n",
							pIrp, pEndpoint, Status));

				RWanDataRequestComplete(pIrp, Status, 0);
			}
		}
	}
	else
	{
		//
		//  The IRP has been cancelled before it could reach us.
		//
		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_CANCELLED;
		RWAN_COMPLETE_IRP(pIrp, Status, 0);
	}


	RWANDEBUGP(DL_LOUD, DC_DATA_TX,
			("RWanSendData: pIrp %p, pEndpoint %p, ret Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);

}




NTSTATUS
RWanReceiveData(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert an IRP containing a TDI_RECEIVE request to a call to our TDI
	dispatch routine for receives. We retain enough context to be able
	to complete the IRP when the receive completes.

	The FileObject within the IRP refers to the connection endpoint.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if we managed to queue the receive successfully,
	STATUS_CANCELLED if the IRP was cancelled.

--*/
{
	PRWAN_ENDPOINT				pEndpoint;
	KIRQL						OldIrql;
	PTDI_REQUEST_KERNEL_RECEIVE	pReceiveRequest;
	TDI_REQUEST					TdiRequest;
	NTSTATUS					Status;


	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pReceiveRequest = (PTDI_REQUEST_KERNEL_RECEIVE) &(pIrpSp->Parameters);

	//
	//  Prepare a TDI Receive request.
	//
	TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID) RWanDataRequestComplete;
	TdiRequest.RequestContext = (PVOID) pIrp;

	IoAcquireCancelSpinLock(&OldIrql);

	if (!pIrp->Cancel)
	{
		//
		//  The IRP hasn't been cancelled. Set it up so that we are
		//  informed if it does get cancelled later.
		//
		IoMarkIrpPending(pIrp);
		IoSetCancelRoutine(pIrp, RWanCancelRequest);

		RWAN_INCR_EP_REF_CNT(pEndpoint, RecvIncr);		// Receive ref

		RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'DvcR', pIrp, pEndpoint->RefCount);

		IoReleaseCancelSpinLock(OldIrql);

		Status = RWanTdiReceive(
					&TdiRequest,
					(USHORT *) &(pReceiveRequest->ReceiveFlags),
					&(pReceiveRequest->ReceiveLength),
					(PNDIS_BUFFER) pIrp->MdlAddress
					);

		if (Status != TDI_PENDING)
		{
			//
			//  The Receive either completed immediately, or failed.
			//
			pIrpSp->Control &= ~SL_PENDING_RETURNED;

			RWANDEBUGP(DL_WARN, DC_DATA_TX,
					("RWanReceiveData: pIrp %p, pEndpoint %p, TDI recv didnt pend: x%x\n",
						pIrp, pEndpoint, Status));

			RWanDataRequestComplete(pIrp, Status, 0);
		}
	}
	else
	{
		//
		//  The IRP has been cancelled before it could reach us.
		//
		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_CANCELLED;

		RWAN_COMPLETE_IRP(pIrp, Status, 0);
	}


	RWANDEBUGP(DL_LOUD, DC_DATA_TX,
			("RWanReceiveData: pIrp %p, pEndpoint %p, ret Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);

}



NTSTATUS
RWanAssociateAddress(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Converts a TDI_ASSOCIATE_ADDRESS IRP to a call to our AssociateAddress
	entry point.

	The FileObject in the IRP refers to the Connection Object, and the
	AddressHandle field within the kernel request refers to the Address
	Object.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_SUCCESS if successful, STATUS_XXX error code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	PRWAN_ENDPOINT					pAddrEndpoint;
	PTDI_REQUEST_KERNEL_ASSOCIATE	pAssociateRequest;
	TDI_REQUEST						TdiRequest;
	PFILE_OBJECT					pFileObject;
	NTSTATUS						Status;

	PAGED_CODE();

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	//  Prepare a TDI Associate Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	pAssociateRequest = (PTDI_REQUEST_KERNEL_ASSOCIATE) &(pIrpSp->Parameters);

	//
	//  Reference the file corresponding to the Address object.
	//  This is just so that it doesn't go away while we're processing
	//  the Associate.
	//
	//  The Address object is identified by its handle buried inside
	//  the Associate request.
	//
	Status = ObReferenceObjectByHandle(
					pAssociateRequest->AddressHandle,
					GENERIC_ALL,
					*IoFileObjectType,
					pIrp->RequestorMode,
					&pFileObject,
					NULL
					);

	if (NT_SUCCESS(Status) &&
		(pFileObject->DeviceObject->DriverObject == pRWanGlobal->pDriverObject))
	{

		//
		//  Found the file object. See if it is an Address object.
		//
		if ((INT)PtrToUint(pFileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE)
		{
			//
			//  Get our endpoint representing this address object.
			//
			pAddrEndpoint = (PRWAN_ENDPOINT) pFileObject->FsContext;
			RWAN_STRUCT_ASSERT(pAddrEndpoint, nep);

			//
			//  Dispatch this to the TDI layer.
			//
			Status = RWanTdiAssociateAddress(
						&TdiRequest,
						pAddrEndpoint->Handle.AddressHandle
						);

			RWAN_ASSERT(Status != TDI_PENDING);

			ObDereferenceObject(pFileObject);

		}
		else
		{
			ObDereferenceObject(pFileObject);

			RWANDEBUGP(DC_ADDRESS, DL_WARN,
					("RWanAssociateAddress: pIrp %p, pConnEp %p, bad Context2 %d\n",
						pIrp, pConnEndpoint,
						(INT)PtrToUint(pFileObject->FsContext2)));

			Status = STATUS_INVALID_HANDLE;
		}
	}
	else
	{
		RWANDEBUGP(DL_WARN, DC_ADDRESS,
				("RWanAssociateAddress: pIrp %p, pConnEp %p, bad addr handle %p\n",
						pIrp, pConnEndpoint, pAssociateRequest->AddressHandle));
		//
		//  Clean up properly.
		//
		if (NT_SUCCESS(Status))
		{
			ObDereferenceObject(pFileObject);
			Status = STATUS_INVALID_HANDLE;
		}
	}

	RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
			("RWanAssociateAddress: pIrp %p, pConnEp %p, Addr Handle %p, Status x%x\n",
						pIrp, pConnEndpoint, pAssociateRequest->AddressHandle, Status));

	return (Status);
}




NTSTATUS
RWanDisassociateAddress(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Converts a TDI_DISASSOCIATE_ADDRESS IRP to a call to our DisassociateAddress
	entry point.

	The FileObject in the IRP refers to the Connection Object that is
	to be disassociated.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	None

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	NTSTATUS						Status;

	PAGED_CODE();

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	//  Prepare a TDI Disassociate Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiDisassociateAddress(&TdiRequest);

		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = TDI_PENDING;
		}
	}

	RWANDEBUGP(DL_VERY_LOUD, DC_ADDRESS,
			("RWanDisassociateAddr: pIrp %p, pEndp %p, Status x%x\n",
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanConnect(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Connect IRP to a call to our Connect entry point.

	The FileObject in the IRP refers to the Connection Object on which
	the outgoing call is to be placed.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if a call was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_CONNECT		pConnectRequest;
	NTSTATUS						Status;
	PLARGE_INTEGER					pRequestTimeout;
	LARGE_INTEGER					MillisecondTimeout;
	ULONG							Remainder;


	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pConnectRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(pIrpSp->Parameters);
	pRequestInformation = pConnectRequest->RequestConnectionInformation;
	pReturnInformation = pConnectRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI CONNECT Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	pRequestTimeout = (PLARGE_INTEGER)pConnectRequest->RequestSpecific;

	if (pRequestTimeout != NULL)
	{
		MillisecondTimeout = RWAN_CONVERT_100NS_TO_MS(*pRequestTimeout, &Remainder);
	}
	else
	{
		MillisecondTimeout.LowPart = 0;
		MillisecondTimeout.HighPart = 0;
	}

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);


	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiConnect(
					&TdiRequest,
					((MillisecondTimeout.LowPart != 0)?
						&(MillisecondTimeout.LowPart): NULL),
					pRequestInformation,
					pReturnInformation
					);

		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanConnect: pIrp %p, pEndp %p, Status x%x\n", 
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanDisconnect(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Connect IRP to a call to our Connect entry point.

	The FileObject in the IRP refers to the Connection Object hosting
	the connection to be disconnected.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if a disconnect was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_DISCONNECT	pDisconnectRequest;
	NTSTATUS						Status;
	PLARGE_INTEGER					pRequestTimeout;
	LARGE_INTEGER					MillisecondTimeout;
	BOOLEAN							bAbortiveDisconnect;


	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pDisconnectRequest = (PTDI_REQUEST_KERNEL_DISCONNECT) &(pIrpSp->Parameters);
	pRequestInformation = pDisconnectRequest->RequestConnectionInformation;
	pReturnInformation = pDisconnectRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI DISCONNECT Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestContext = (PVOID)pIrp;

	pRequestTimeout = (PLARGE_INTEGER)pDisconnectRequest->RequestSpecific;

	if (pRequestTimeout != NULL)
	{
		ULONG							Remainder;
		MillisecondTimeout = RWAN_CONVERT_100NS_TO_MS(*pRequestTimeout, &Remainder);
#if 0
		if ((pRequestTimeout->LowPart == -1) &&
			(pRequestTimeout->HighPart == -1))
		{
			MillisecondTimeout.LowPart = pRequestTimeout->LowPart;
			MillisecondTimeout.HighPart = 0;
		}
		else
		{
			MillisecondTimeout.QuadPart = -((*pRequestTimeout).QuadPart);
			MillisecondTimeout = RWAN_CONVERT_100NS_TO_MS(MillisecondTimeout);
		}

		RWAN_ASSERT(MillisecondTimeout.HighPart == 0);
#endif // 0
	}
	else
	{
		MillisecondTimeout.LowPart = 0;
		MillisecondTimeout.HighPart = 0;
	}

	if (pDisconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT)
	{
		//
		//  Use non-generic completion routine for abortive disconnects,
		//  because they cannot be cancelled.
		//
		bAbortiveDisconnect = TRUE;
		IoMarkIrpPending(pIrp);
		TdiRequest.RequestNotifyObject = (PVOID)RWanNonCancellableRequestComplete;

		Status = STATUS_SUCCESS;
	}
	else
	{
		//
		//  Non-abortive disconnect.
		//
		bAbortiveDisconnect = FALSE;
		Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);
		TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	}

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiDisconnect(
					&TdiRequest,
					((MillisecondTimeout.LowPart != 0)?
						&(MillisecondTimeout.LowPart): NULL),
					(USHORT)pDisconnectRequest->RequestFlags,
					pRequestInformation,
					pReturnInformation
					);

		if (Status != TDI_PENDING)
		{
			if (bAbortiveDisconnect)
			{
				RWanNonCancellableRequestComplete(pIrp, Status, 0);
			}
			else
			{
				RWanRequestComplete(pIrp, Status, 0);
			}
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_DISCON,
			("RWanDisconnect: pIrp %p, pEndp %p, Abortive %d, Status x%x\n", 
				pIrp, pConnEndpoint, (INT)bAbortiveDisconnect, Status));

	return (Status);
}




NTSTATUS
RWanListen(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Listen IRP to a call to our Listen entry point.

	The FileObject in the IRP refers to the Connection Object on which
	this Listen is posted.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if a Listen was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_LISTEN		pListenRequest;
	NTSTATUS						Status;

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pListenRequest = (PTDI_REQUEST_KERNEL_LISTEN) &(pIrpSp->Parameters);
	pRequestInformation = pListenRequest->RequestConnectionInformation;
	pReturnInformation = pListenRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI LISTEN Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiListen(
					&TdiRequest,
					(USHORT)pListenRequest->RequestFlags,
					pRequestInformation,
					pReturnInformation
					);
		
		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanListen: pIrp %p, pEndp %p, Status x%x\n", 
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanAccept(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Accept IRP to a call to our Accept entry point.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_PENDING if an Accept was initiated, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT					pConnEndpoint;
	TDI_REQUEST						TdiRequest;
	PTDI_CONNECTION_INFORMATION		pRequestInformation;
	PTDI_CONNECTION_INFORMATION		pReturnInformation;
	PTDI_REQUEST_KERNEL_ACCEPT		pAcceptRequest;
	NTSTATUS						Status;

	pConnEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pConnEndpoint, nep);

	//
	// Grab all parameters from the IRP.
	//
	pAcceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT) &(pIrpSp->Parameters);
	pRequestInformation = pAcceptRequest->RequestConnectionInformation;
	pReturnInformation = pAcceptRequest->ReturnConnectionInformation;

	//
	//  Prepare a TDI ACCEPT Request
	//
	TdiRequest.Handle.ConnectionContext = pConnEndpoint->Handle.ConnectionContext;
	TdiRequest.RequestNotifyObject = (PVOID)RWanRequestComplete;
	TdiRequest.RequestContext = (PVOID)pIrp;

	Status = RWanPrepareIrpForCancel(pConnEndpoint, pIrp, RWanCancelRequest);

	if (NT_SUCCESS(Status))
	{
		Status = RWanTdiAccept(
					&TdiRequest,
					pRequestInformation,
					pReturnInformation
					);
		
		if (Status != TDI_PENDING)
		{
			RWanRequestComplete(pIrp, Status, 0);
			Status = STATUS_PENDING;
		}
	}

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanAccept: pIrp %p, pEndp %p, Status x%x\n", 
				pIrp, pConnEndpoint, Status));

	return (Status);
}




NTSTATUS
RWanSetEventHandler(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Convert a TDI Set Event Handler IRP to a call to our set event handler
	entry point.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - STATUS_SUCCESS if the request was successful, STATUS_XXX error
	code otherwise.

--*/
{
	PRWAN_ENDPOINT						pEndpoint;
	PTDI_REQUEST_KERNEL_SET_EVENT		pSetEvent;
	NTSTATUS							Status;

	PAGED_CODE();

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT) &(pIrpSp->Parameters);

	Status = RWanTdiSetEvent(
					pEndpoint->Handle.AddressHandle,
					pSetEvent->EventType,
					pSetEvent->EventHandler,
					pSetEvent->EventContext
					);
	
	RWAN_ASSERT(Status != STATUS_PENDING);

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
			("RWanSetEventHandler: pIrp %p, pEndp %p, Type x%x, Status x%x\n", 
				pIrp, pEndpoint, pSetEvent->EventType, Status));

	return (Status);
}




NTSTATUS
RWanQueryInformation(
	IN	PIRP						pIrp,
	IN	PIO_STACK_LOCATION			pIrpSp
	)
/*++

Routine Description:

	Converts a TDI Query Information IRP to a call to the QueryInformation
	TDI entry point.

Arguments:

	pIrp			- Pointer to IRP
	pIrpSp			- IRP Stack location

Return Value:

	NTSTATUS - this is STATUS_SUCCESS if the query was completed successfully,
	STATUS_PENDING if it will be completed later, STATUS_XXX error code otherwise.

--*/
{
	TDI_REQUEST						TdiRequest;
	NTSTATUS						Status;
	PRWAN_ENDPOINT					pEndpoint;
	PTDI_REQUEST_KERNEL_QUERY_INFORMATION		pQueryInfo;
	UINT							IsConnection;
	UINT							DataSize;

	IsConnection = FALSE;
	DataSize = 0;

	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	pQueryInfo = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION) &(pIrpSp->Parameters);

	TdiRequest.RequestNotifyObject = RWanDataRequestComplete;
	TdiRequest.RequestContext = pIrp;

	Status = STATUS_SUCCESS;

	switch (pQueryInfo->QueryType)
	{
		case TDI_QUERY_BROADCAST_ADDRESS:

			Status = STATUS_NOT_IMPLEMENTED;
			break;
		
		case TDI_QUERY_PROVIDER_INFO:

			TdiRequest.Handle.ControlChannel = pEndpoint->Handle.ControlChannel;
			break;
		
		case TDI_QUERY_ADDRESS_INFO:

			if (((INT)PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE)
			{
				IsConnection = TRUE;
				TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			}
			else
			{
				//
				//  Must be an address object.
				//
				RWAN_ASSERT(((INT) PtrToUint(pIrpSp->FileObject->FsContext2))
									 == TDI_TRANSPORT_ADDRESS_FILE);

				TdiRequest.Handle.AddressHandle = pEndpoint->Handle.AddressHandle;
			}
			break;

		case TDI_QUERY_CONNECTION_INFO:

			//
			//  Must be a connection object.
			//
			RWAN_ASSERT(((INT) PtrToUint(pIrpSp->FileObject->FsContext2)) == TDI_CONNECTION_FILE);

			IsConnection = TRUE;
			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			break;

		case TDI_QUERY_PROVIDER_STATISTICS:

			//
			//  Must be a control channel.
			//
			RWAN_ASSERT(((INT) PtrToUint(pIrpSp->FileObject->FsContext2))
									== TDI_CONTROL_CHANNEL_FILE);
			TdiRequest.Handle.ControlChannel = pEndpoint->Handle.ControlChannel;
			break;

		default:
		
			Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	if (NT_SUCCESS(Status))
	{
		Status = RWanPrepareIrpForCancel(pEndpoint, pIrp, NULL);

		if (NT_SUCCESS(Status))
		{
			DataSize = RWanGetMdlChainLength(pIrp->MdlAddress);

			Status = RWanTdiQueryInformation(
							&TdiRequest,
							pQueryInfo->QueryType,
							pIrp->MdlAddress,
							&DataSize,
							IsConnection
							);
			
			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("RWanQueryInformation: pIrp %p, pEndp %p, Type x%x, Status x%x\n", 
					pIrp, pEndpoint, pQueryInfo->QueryType, Status));

			if (Status != TDI_PENDING)
			{
				RWanDataRequestComplete(pIrp, Status, DataSize);
			}

			return (STATUS_PENDING);
		}
		else
		{
			return (Status);
		}
	}

	RWAN_COMPLETE_IRP(pIrp, Status, 0);

	return (Status);
}




VOID
RWanCloseObjectComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	)
/*++

Routine Description:

	This is the call-back routine that processes a CloseConnection
	or CloseAddress completion. This is called by the core TDI
	provider. We dereference the endpoint; if it goes to 0, we
	wake up the thread that's running the CLEANUP.

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for the CloseConnection/CloseAddress
	Unused			- Not used for this completion

Return Value:

	None

--*/
{
	KIRQL						OldIrql;
	PIRP						pIrp;
	PIO_STACK_LOCATION			pIrpSp;
	PRWAN_ENDPOINT				pEndpoint;

	UNREFERENCED_PARAMETER(Unused);

	pIrp = (PIRP)Context;
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Status = Status;
	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	IoAcquireCancelSpinLock(&OldIrql);

	IoSetCancelRoutine(pIrp, NULL);

	RWAN_DECR_EP_REF_CNT(pEndpoint, CloseComplDecr);		// CloseComplete deref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'pmCC', pIrp, pEndpoint->RefCount);

	if (pEndpoint->RefCount == 0)
	{
		//
		//  The endpoint must be cleaning up.
		//

		RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("RWanCloseObjectComplete: pIrp %p, pEndpoint %p ref count 0\n",
						pIrp, pEndpoint));

		KeSetEvent(&(pEndpoint->CleanupEvent), 0, FALSE);
	}

	IoReleaseCancelSpinLock(OldIrql);

	return;
}




VOID
RWanDataRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				ByteCount
	)
/*++

Routine Description:

	This is the call-back routine that processes a Send/Receive completion.
	This is called by the core TDI provider. We complete the send/receive
	IRP appropriately, and dereference our endpoint.

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for send/receive
	ByteCount		- Actual bytes sent/received.

Return Value:

	None

--*/
{
	KIRQL						OldIrql;
	PIRP						pIrp;
	PIO_STACK_LOCATION			pIrpSp;
	PRWAN_ENDPOINT				pEndpoint;

	pIrp = (PIRP)Context;
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pEndpoint = (PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	IoAcquireCancelSpinLock(&OldIrql);

	IoSetCancelRoutine(pIrp, NULL);

	RWAN_DECR_EP_REF_CNT(pEndpoint, DataReqComplDecr);		// Send/Receive deref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'CerD', pIrp, pEndpoint->RefCount);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_TX|DC_DATA_RX|DC_CONNECT|DC_DISCON,
			("RWanDataReq compl: pIrp %p, pEndpoint %p, RefCnt %d, Sts x%x, ByteCnt %d\n",
					pIrp, pEndpoint, pEndpoint->RefCount, Status, ByteCount));

	if (pEndpoint->RefCount == 0)
	{
		//
		//  The endpoint must be cleaning up.
		//

		RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("RWanDataRequestComplete: pIrp %p, pEndpoint %p ref count 0\n",
						pIrp, pEndpoint));

		KeSetEvent(&(pEndpoint->CleanupEvent), 0, FALSE);
	}

	//
	//  If the IRP was cancelled or we are cleaning up,
	//  update the completion status.
	//
	if (pIrp->Cancel || pEndpoint->bCancelIrps)
	{
		Status = (UINT)STATUS_CANCELLED;
		ByteCount = 0;
	}

	IoReleaseCancelSpinLock(OldIrql);

	RWAN_COMPLETE_IRP(pIrp, Status, ByteCount);

	return;
}




VOID
RWanRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	)
/*++

Routine Description:

	This is our call-back routine for completing requests that don't
	include data. IRP processing is the same as that for data, except
	that the ByteCount is 0.

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for the request.
	Unused			- Not used.

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(Unused);

	RWanDataRequestComplete(Context, Status, 0);
}




VOID
RWanNonCancellableRequestComplete(
	IN	PVOID				Context,
	IN	UINT				Status,
	IN	UINT				Unused
	)
/*++

Routine Description:

	This is our call-back routine for completing requests based
	on non-cancellable IRPs (e.g. Abortive Disconnect).

Arguments:

	Context			- A pointer to the IRP for this request.
	Status			- Final TDI status for the request.
	Unused			- Not used.

Return Value:

	None

--*/
{
	PIRP						pIrp;
	PIO_STACK_LOCATION			pIrpSp;

	UNREFERENCED_PARAMETER(Unused);

	pIrp = (PIRP)Context;
	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	//
	//  Complete the IRP
	//
	RWAN_COMPLETE_IRP(pIrp, Status, 0);

	return;
}




VOID
RWanCancelComplete(
	IN	PVOID				Context,
	IN	UINT				Unused1,
	IN	UINT				Unused2
	)
/*++

Routine Description:

	This is called to process internal completion of an IRP cancellation.
	All we need to do here is to dereference the endpoint on which this
	happened.

Arguments:

	Context			- A pointer to the file object representing the
					  endpoint on which the IRP was cancelled.
	Unused[1-2]		- Not used

Return Value:

	None

--*/
{
	PFILE_OBJECT		pFileObject;
	PRWAN_ENDPOINT		pEndpoint;
	KIRQL				OldIrql;

	UNREFERENCED_PARAMETER(Unused1);
	UNREFERENCED_PARAMETER(Unused2);

	pFileObject = (PFILE_OBJECT)Context;
	pEndpoint = (PRWAN_ENDPOINT)(pFileObject->FsContext);

	RWAN_STRUCT_ASSERT(pEndpoint, nep);


	IoAcquireCancelSpinLock(&OldIrql);

	RWAN_DECR_EP_REF_CNT(pEndpoint, CancelComplDecr);		// CancelComplete deref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'CnaC', 0, pEndpoint->RefCount);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_DISPATCH,
			("RWanCancelComplete: pEndpoint %p, RefCount %d\n",
				pEndpoint, pEndpoint->RefCount));

	if (pEndpoint->RefCount == 0)
	{
		//
		//  Wake up the thread waiting for IRPs to complete
		//
		KeSetEvent(&(pEndpoint->CleanupEvent), 0, FALSE);
	}

	IoReleaseCancelSpinLock(OldIrql);

	return;
}



VOID
RWanCancelRequest(
	IN	PDEVICE_OBJECT		pDeviceObject,
	IN	PIRP				pIrp
	)
/*++

Routine Description:

	This is the cancel routine we attach to IRPs that we queue. This
	is supposed to cancel the IRP.

Arguments:

	pDeviceObject	- Pointer to the device object for this IRP
	pIrp			- Pointer to request packet

Return Value:

	None

--*/
{
	PFILE_OBJECT			pFileObject;
	PIO_STACK_LOCATION		pIrpSp;
	PRWAN_ENDPOINT			pEndpoint;
	NTSTATUS				Status;
	TDI_REQUEST				TdiRequest;
	UCHAR					MinorFunction;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	pFileObject = pIrpSp->FileObject;
	MinorFunction = pIrpSp->MinorFunction;

	pEndpoint = (PRWAN_ENDPOINT) pFileObject->FsContext;
	RWAN_STRUCT_ASSERT(pEndpoint, nep);

	//
	//  This routine is entered with Cancel SpinLock acquired.
	//
	RWAN_ASSERT(pIrp->Cancel);
	IoSetCancelRoutine(pIrp, NULL);

	//
	//  Make sure that the endpoint doesn't go away when
	//  we release the Cancel Spinlock.
	//
	RWAN_INCR_EP_REF_CNT(pEndpoint, CancelIncr);		// Cancel ref

	RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'RnaC', pIrp, pEndpoint->RefCount);

	IoReleaseCancelSpinLock(pIrp->CancelIrql);

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
			("RWanCancelRequest: pIrp %p, MinorFunc %d, pEndpoint %p\n",
				pIrp, MinorFunction, pEndpoint));

	Status = STATUS_SUCCESS;

	switch (MinorFunction)
	{
		case TDI_SEND:
		case TDI_RECEIVE:

			RWanAbortConnection(
				pEndpoint->Handle.ConnectionContext
				);
			break;

		case TDI_DISASSOCIATE_ADDRESS:

			break;

		case TDI_LISTEN:

			//
			//  Initiate an Unlisten.
			//
			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			TdiRequest.RequestNotifyObject = (PVOID)RWanCancelComplete;
			TdiRequest.RequestContext = (PVOID)pFileObject;

			Status = RWanTdiUnListen(
						&TdiRequest
						);
			break;

		default:

			//
			//  Initiate a Disconnect.
			//
			TdiRequest.Handle.ConnectionContext = pEndpoint->Handle.ConnectionContext;
			TdiRequest.RequestNotifyObject = (PVOID)RWanCancelComplete;
			TdiRequest.RequestContext = (PVOID)pFileObject;

			Status = RWanTdiDisconnect(
						&TdiRequest,
						NULL,
						TDI_DISCONNECT_ABORT,
						NULL,
						NULL
						);
			break;
	}

	if (Status != TDI_PENDING)
	{
		RWanCancelComplete(pFileObject, 0, 0);
	}

	return;
}




NTSTATUS
RWanPrepareIrpForCancel(
	IN	PRWAN_ENDPOINT		pEndpoint,
	IN	PIRP				pIrp,
	IN	PDRIVER_CANCEL		pCancelRoutine
	)
/*++

Routine Description:

	Check if an IRP has been cancelled. If so, complete it with the
	right status. Otherwise, set it up so that the supplied cancel
	routine is called if it is cancelled.

	This is called for non-data IRPs that are potentially going to
	pend.

Arguments:

	pEndpoint		- Pointer to endpoint on which this IRP arrived
	pIrp			- Pointer to request packet
	pCancelRoutine	- Cancellation routine to be tacked on to the IRP

Return Value:

	NTSTATUS - this is STATUS_CANCELLED if the IRP has been cancelled
	already, STATUS_SUCCESS otherwise.

--*/
{
	KIRQL			OldIrql;
	NTSTATUS		Status;

	IoAcquireCancelSpinLock(&OldIrql);

	RWAN_ASSERT(pIrp->CancelRoutine == NULL);

	if (!pIrp->Cancel)
	{
		//
		//  This IRP hasn't been cancelled. Mark it as pending, because
		//  it's going to be queued (by the caller).
		//
		IoMarkIrpPending(pIrp);

		IoSetCancelRoutine(pIrp, pCancelRoutine);

		//
		//  Add a reference for this IRP on the endpoint.
		//
		RWAN_INCR_EP_REF_CNT(pEndpoint, NonDataIncr);		// Non data IRP ref

		RWAN_EP_DBGLOG_ENTRY(pEndpoint, 'DnoN', pIrp, pEndpoint->RefCount);

		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_SUCCESS;
	}
	else
	{
		//
		//  The IRP has been cancelled already. Simply complete it.
		//

		IoReleaseCancelSpinLock(OldIrql);

		Status = STATUS_CANCELLED;
		RWAN_COMPLETE_IRP(pIrp, Status, 0);

	}

	RWANDEBUGP(DL_VERY_LOUD, DC_DISPATCH,
			("RWanPrepareIrpForCancel: pIrp %p, pEndp %p, ret Status x%x\n",
				pIrp, pEndpoint, Status));

	return (Status);
}



ULONG
RWanGetMdlChainLength(
	IN	PMDL				pMdl
	)
/*++

Routine Description:

	Return the total byte count of all MDLs in a chain.

Arguments:

	pMdl		- Points to start of MDL chain.

Return Value:

	Byte count of the MDL chain.

--*/
{
	ULONG		Count = 0;

	while (pMdl != NULL)
	{
		Count += MmGetMdlByteCount(pMdl);
		pMdl = pMdl->Next;
	}

	return (Count);
}




NTSTATUS
RWanToNTStatus(
	IN	RWAN_STATUS			RWanStatus
	)
/*++

Routine Description:

	Map from a Raw-WAN status code to an equivalent NT status code.

Arguments:

	RWanStatus		- The RAW WAN status code.

Return Value:

	The NT Status code.

--*/
{
	NTSTATUS		Status;

	switch (RWanStatus)
	{
		case RWAN_STATUS_SUCCESS:
				Status = STATUS_SUCCESS;
				break;
		case RWAN_STATUS_BAD_ADDRESS:
				Status = STATUS_INVALID_ADDRESS;
				break;
		case RWAN_STATUS_BAD_PARAMETER:
				Status = STATUS_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_MISSING_PARAMETER:
				Status = STATUS_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_RESOURCES:
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
		case RWAN_STATUS_FAILURE:
		default:
				Status = STATUS_UNSUCCESSFUL;
				break;
	}

	return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\receive.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\receive.c

Abstract:

	Routines for receiving data, including TDI and NDIS entry
	points and completions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-16-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'VCER'


#if STATS

ULONG		RecvPktsOk = 0;
ULONG		RecvBytesOk = 0;
ULONG		RecvPktsFail = 0;
ULONG		RecvBytesFail = 0;

#endif // STATS

#if DBG

BOOLEAN		bVerifyData = FALSE;
UCHAR		CheckChar = 'X';

VOID
RWanCheckDataForChar(
	IN	PCHAR		pHelpString,
	IN	PVOID		Context,
	IN	PUCHAR		pBuffer,
	IN	ULONG		Length,
	IN	UCHAR		Char
	);


#define RWAN_CHECK_DATA(_pHelp, _Ctxt, _pBuf, _Len)	\
{														\
	if (bVerifyData)									\
	{													\
		RWanCheckDataForChar(_pHelp, _Ctxt, _pBuf, _Len, CheckChar);	\
	}													\
}

#else

#define RWAN_CHECK_DATA(_pHelp, _Ctxt, _pBuf, _Len)

#endif // DBG


#if DBG

VOID
RWanCheckDataForChar(
	IN	PCHAR		pHelpString,
	IN	PVOID		Context,
	IN	PUCHAR		pBuffer,
	IN	ULONG		Length,
	IN	UCHAR		Char
	)
{
	ULONG			i;
	PUCHAR			pBuf = pBuffer+1;

	for (i = 1; i < Length; i++)
	{
		if (*pBuf == Char)
		{
			DbgPrint("RAWWAN: %s: %p: Found char %c at offset %d, 0x%p, of buffer 0x%p\n",
						pHelpString,
						Context,
						Char,
						i,
						pBuf,
						pBuffer);
			DbgBreakPoint();
		}
		pBuf++;
	}
}

#endif // DBG

RWAN_STATUS
RWanInitReceive(
	VOID
	)
/*++

Routine Description:

	Initialize our receive structures. We allocate a buffer pool and
	a packet pool for keeping copies of received packets that we aren't
	allowed to keep by the miniport.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if initialized successfully, else RWAN_STATUS_RESOURCES.

--*/
{
	RWAN_STATUS				RWanStatus;
	NDIS_STATUS				Status;

	//
	//  Initialize.
	//
	RWanCopyPacketPool = NULL;
	RWanCopyBufferPool = NULL;
	RWanStatus = RWAN_STATUS_SUCCESS;

	NdisAllocatePacketPoolEx(
		&Status,
		&RWanCopyPacketPool,
		RWAN_INITIAL_COPY_PACKET_COUNT,
		RWAN_OVERFLOW_COPY_PACKET_COUNT,
		0
		);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		RWanStatus = RWAN_STATUS_RESOURCES;
	}
	else
	{
		NdisAllocateBufferPool(
			&Status,
			&RWanCopyBufferPool,
			RWAN_INITIAL_COPY_PACKET_COUNT+RWAN_OVERFLOW_COPY_PACKET_COUNT
			);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			NdisFreePacketPool(RWanCopyPacketPool);
			RWanCopyPacketPool = NULL;

			RWanStatus = RWAN_STATUS_RESOURCES;
		}
	}

	return (RWanStatus);
}




VOID
RWanShutdownReceive(
	VOID
	)
/*++

Routine Description:
	
	This is shutdown code, to clean up our receive structures.
	We free the packet pool and buffer pool allocated when we
	init'ed.

Arguments:

	None

Return Value:

	None

--*/
{
	if (RWanCopyPacketPool != NULL)
	{
		NdisFreePacketPool(RWanCopyPacketPool);
		RWanCopyPacketPool = NULL;
	}

	if (RWanCopyBufferPool != NULL)
	{
		NdisFreeBufferPool(RWanCopyBufferPool);
		RWanCopyBufferPool = NULL;
	}

	return;
}




TDI_STATUS
RWanTdiReceive(
    IN	PTDI_REQUEST				pTdiRequest,
	OUT	PUSHORT						pFlags,
	IN	PUINT						pReceiveLength,
	IN	PNDIS_BUFFER				pNdisBuffer
	)
/*++

Routine Description:

	This is the TDI Entry point for receiving data over a connection.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pFlags			- Place to return additional information about this
					  receive
	pReceiveLength	- Points to the total length of the receive buffer chain
	pNdisBuffer		- Start of receive buffer chain

Return Value:

	TDI_PENDING if we queued this receive request successfully
	TDI_INVALID_CONNECTION if the Connection context isn't valid
	TDI_NO_RESOURCES if we had a resource problem with this receive

--*/
{
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_CONNECTION			pConnObject;
	BOOLEAN							bIsLockAcquired;	// Do we hold the Conn Object lock
	PRWAN_NDIS_VC					pVc;
	TDI_STATUS						TdiStatus;
	PRWAN_RECEIVE_REQUEST			pRcvReq;
	PRWAN_NDIS_ADAPTER				pAdapter;

	//
	//  Initialize.
	//
	TdiStatus = TDI_PENDING;
	bIsLockAcquired = FALSE;
	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
	pRcvReq = NULL;

	do
	{
		//
		//  Allocate space to hold context for this receive
		//
		pRcvReq = RWanAllocateReceiveReq();
		if (pRcvReq == NULL)
		{
			RWANDEBUGP(DL_INFO, DC_WILDCARD,
				("Rcv: Failed to allocate receive req!\n"));
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}

		//
		//  Prepare the receive request.
		//
		pRcvReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pRcvReq->Request.ReqContext = pTdiRequest->RequestContext;
		pRcvReq->TotalBufferLength = *pReceiveLength;
		pRcvReq->AvailableBufferLength = *pReceiveLength;
		pRcvReq->pUserFlags = pFlags;
		pRcvReq->pBuffer = pNdisBuffer;
		NdisQueryBufferSafe(
				pNdisBuffer,
				&(pRcvReq->pWriteData),
				&(pRcvReq->BytesLeftInBuffer),
				NormalPagePriority
				);

		if (pRcvReq->pWriteData == NULL)
		{
			RWANDEBUGP(DL_INFO, DC_WILDCARD,
				("Rcv: Failed to query req buffer!\n"));
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}
		    
		pRcvReq->pNextRcvReq = NULL;
		if (pRcvReq->BytesLeftInBuffer > pRcvReq->AvailableBufferLength)
		{
			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Rcv: pRcvReq %x, BytesLeft %d > Available %d, pTdiRequest %x\n",
						pRcvReq,
						pRcvReq->BytesLeftInBuffer,
						pRcvReq->AvailableBufferLength,
						pTdiRequest));
			pRcvReq->BytesLeftInBuffer = pRcvReq->AvailableBufferLength;
		}

		//
		//  See if the given Connection is valid.
		//
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();


		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: Invalid connection!\n"));
			TdiStatus = TDI_INVALID_CONNECTION;
			break;
		}

		bIsLockAcquired = TRUE;
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Check the Connection state.
		//
		if ((pConnObject->State != RWANS_CO_CONNECTED) ||
			(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
		{
			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("TdiReceive: Conn %x bad state %d/flags %x\n",
					pConnObject, pConnObject->State, pConnObject->Flags));

			TdiStatus = TDI_INVALID_STATE;
			break;
		}

		pVc = pConnObject->NdisConnection.pNdisVc;
		RWAN_ASSERT(pVc != NULL);

		RWAN_STRUCT_ASSERT(pVc, nvc);
		pAdapter = pVc->pNdisAf->pAdapter;

		//
		//  Queue the receive request at the end of the queue on this VC.
		//
		if (pVc->pRcvReqHead == NULL)
		{
			pVc->pRcvReqHead = pVc->pRcvReqTail = pRcvReq;
		}
		else
		{
			RWAN_ASSERT(pVc->pRcvReqTail != NULL);
			pVc->pRcvReqTail->pNextRcvReq = pRcvReq;
			pVc->pRcvReqTail = pRcvReq;
		}

		RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Rcv: VC %x, queued RcvReq %x, space available %d bytes\n",
						pVc, pRcvReq, pRcvReq->AvailableBufferLength));

		//
		//  Start the common indicate code (for receive requests as well
		//  as for receive indications).
		//
		RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_PAUSE_RECEIVE);

		RWanIndicateData(pConnObject);

		bIsLockAcquired = FALSE;

		//
		//  Force return of any received packets that we have completed
		//  processing, to the miniport.
		//
		RWanNdisReceiveComplete((NDIS_HANDLE)pAdapter);

		break;

	}
	while (FALSE);

	if (bIsLockAcquired)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	if (TdiStatus != TDI_PENDING)
	{
		//
		//  Error - clean up.
		//
		if (pRcvReq != NULL)
		{
			RWanFreeReceiveReq(pRcvReq);
		}
	}

	return (TdiStatus);
}



UINT
RWanNdisCoReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    )
/*++

Routine Description:

	This is the NDIS entry point announcing arrival of a packet
	on a VC known to us.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter context
	ProtocolVcContext		- Pointer to our VC context
	pNdisPacket				- the received packet

Return Value:

	UINT - this is the reference count we place on the packet.
	This is 0 if we either dropped the packet, or if the miniport
	had marked the packet with NDIS_STATUS_RESOURCES. Otherwise,
	this is 1 (we queue the packet and will call NdisReturnPackets
	later).

--*/
{
	PRWAN_NDIS_VC			pVc;
	PRWAN_TDI_CONNECTION	pConnObject;
	UINT					PacketRefCount;
	NDIS_STATUS				ReceiveStatus;
	PRWAN_RECEIVE_INDICATION	pRcvInd;
	BOOLEAN					bIsMiniportPacket;	// Are we queueing the miniport's packet?
	BOOLEAN					bIsLockAcquired;

#if STATS
	PNDIS_BUFFER		StpNdisBuffer;
	PVOID				StFirstBufferVa;
	UINT				StFirstBufferLength;
	UINT				StTotalLength;
#endif // STATS

	UNREFERENCED_PARAMETER(ProtocolBindingContext);

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);
	RWAN_ASSERT(pNdisPacket);

	pConnObject = pVc->pConnObject;

	RWANDEBUGP(DL_INFO, DC_DATA_RX,
			("Rcv: VC %x, NdisVCHandle %x, Pkt %x\n",
				ProtocolVcContext,
				((PRWAN_NDIS_VC)ProtocolVcContext)->NdisVcHandle,
				pNdisPacket));
	//
	//  Initialize.
	//
	PacketRefCount = 1;
	ReceiveStatus = NDIS_STATUS_SUCCESS;
	bIsMiniportPacket = TRUE;
	bIsLockAcquired = TRUE;

	do
	{
#if STATS
		NdisGetFirstBufferFromPacket(
			pNdisPacket,
			&StpNdisBuffer,
			&StFirstBufferVa,
			&StFirstBufferLength,
			&StTotalLength
			);
#endif // STATS
		
#if DBG
		//
		//  Debugging miniports indicating up garbage packets.
		//
		{
			ULONG			DbgTotalLength;
			PNDIS_BUFFER	pDbgFirstBuffer;
			PVOID			pFirstBufferVA;
			UINT			DbgFirstBufferLength;
			UINT			DbgTotalBufferLength;

			if ((pNdisPacket->Private.Head == NULL) || (pNdisPacket->Private.Tail == NULL))
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, Head/Tail is NULL!\n",
						ProtocolVcContext, pNdisPacket));
				RWAN_ASSERT(FALSE);
			}

			NdisGetFirstBufferFromPacket(
				pNdisPacket,
				&pDbgFirstBuffer,
				&pFirstBufferVA,
				&DbgFirstBufferLength,
				&DbgTotalBufferLength
				);

			if (pDbgFirstBuffer == NULL)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, first buffer is NULL!\n",
						ProtocolVcContext, pNdisPacket));
				RWAN_ASSERT(FALSE);
			}

			if (DbgFirstBufferLength == 0)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, first buffer length is 0!\n",
						ProtocolVcContext, pNdisPacket));
				// RWAN_ASSERT(FALSE);
			}

			if (DbgTotalBufferLength == 0)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, Total buffer length is 0, FirstBufferLength %d!\n",
						ProtocolVcContext, pNdisPacket, DbgFirstBufferLength));
				// RWAN_ASSERT(FALSE);
			}

			if (pFirstBufferVA == NULL)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Rcv: VC %x, Pkt %x, FirstBufferVA is NULL, FirstLength %d, Total %d\n",
						ProtocolVcContext, pNdisPacket, DbgFirstBufferLength, DbgTotalBufferLength));
				RWAN_ASSERT(FALSE);
			}

			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Recv: VC %x, Pkt %x, TotalLength %d bytes\n",
					ProtocolVcContext, pNdisPacket, DbgTotalBufferLength));


			if (DbgTotalBufferLength == 0)
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Recv: VC %x, Pkt %x: discarding cuz zero length\n",
						ProtocolVcContext, pNdisPacket));
				bIsLockAcquired = FALSE;
				PacketRefCount = 0;
				ReceiveStatus = NDIS_STATUS_FAILURE;
				break;
			}
		}
#endif

		//
		//  See if we are aborting this connection. If so, drop this packet.
		//
		if (pConnObject == NULL)
		{
			bIsLockAcquired = FALSE;
			PacketRefCount = 0;
			ReceiveStatus = NDIS_STATUS_FAILURE;
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: dropping cuz ConnObj is NULL\n"));
			break;
		}

		RWAN_STRUCT_ASSERT(pConnObject, ntc);

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if connection is closing. If so, drop this packet.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING) ||
			((pConnObject->State != RWANS_CO_CONNECTED) &&
			 (pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING)))
		{
			PacketRefCount = 0;
			ReceiveStatus = NDIS_STATUS_FAILURE;
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: dropping on Conn %p, Flags %x, State %d\n",
						pConnObject, pConnObject->Flags, pConnObject->State));
			break;
		}

		//
		//  If the packet cannot be queued, attempt to make a copy.
		//
		if (NDIS_GET_PACKET_STATUS(pNdisPacket) == NDIS_STATUS_RESOURCES)
		{
			PacketRefCount = 0;	// we cannot hang on to this packet

			pNdisPacket = RWanMakeReceiveCopy(pNdisPacket);
			if (pNdisPacket == NULL)
			{
				RWANDEBUGP(DL_WARN, DC_WILDCARD,
					("Rcv: failed to allocate receive copy!\n"));
				ReceiveStatus = NDIS_STATUS_RESOURCES;
				PacketRefCount = 0;
				break;
			}
			bIsMiniportPacket = FALSE;
		}

		//
		//  Prepare a receive indication element to keep track of this
		//  receive.
		//
		pRcvInd = RWanAllocateReceiveInd();
		if (pRcvInd == NULL)
		{
			PacketRefCount = 0;
			ReceiveStatus = NDIS_STATUS_RESOURCES;
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("Rcv: dropping cuz of failure allocating receive Ind!\n"));
			break;
		}

		pRcvInd->pPacket = pNdisPacket;
		pRcvInd->bIsMiniportPacket = bIsMiniportPacket;
		pRcvInd->pNextRcvInd = NULL;
		pRcvInd->pVc = pVc;

		NdisGetFirstBufferFromPacket(
				pNdisPacket,
				&(pRcvInd->pBuffer),
				(PVOID *)&(pRcvInd->pReadData),
				&(pRcvInd->BytesLeftInBuffer),
				&(pRcvInd->PacketLength)
				);

		pRcvInd->TotalBytesLeft = pRcvInd->PacketLength;

		//
		//  Queue the receive indication at the end of the receive queue on
		//  this VC.
		//
		if (pVc->pRcvIndHead == NULL)
		{
			pVc->pRcvIndHead = pVc->pRcvIndTail = pRcvInd;
		}
		else
		{
			RWAN_ASSERT(pVc->pRcvIndTail != NULL);
			pVc->pRcvIndTail->pNextRcvInd = pRcvInd;
			pVc->pRcvIndTail = pRcvInd;
		}

		RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_RX,
				("CoRcvPacket: Pkt x%x, pVc x%x, pRcvInd x%x, BytesLeft %d, PktLen %d, Head x%x, Tail x%x\n",
					pNdisPacket,
					pVc,
					pRcvInd,
					pRcvInd->BytesLeftInBuffer,
					pRcvInd->PacketLength,
					pVc->pRcvIndHead,
					pVc->pRcvIndTail));

		pVc->PendingPacketCount++;	// Receive Ind

		//
		//  Start the common indicate code (for receive requests as well
		//  as for receive indications).
		//
		if (pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING)
		{
			RWanIndicateData(pConnObject);
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			RWANDEBUGP(DL_FATAL, DC_DATA_RX,
				("Rcv: queued packet %d bytes on accepting VC %x, pConn %x\n",
						pRcvInd->PacketLength, pVc, pConnObject));
		}

		bIsLockAcquired = FALSE;	// It's released within RWanIndicateData

		break;

	}
	while (FALSE);


	if (bIsLockAcquired)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	if (ReceiveStatus != NDIS_STATUS_SUCCESS)
	{
#if STATS
		INCR_STAT(&RecvPktsFail);
		ADD_STAT(&RecvBytesFail, StTotalLength);
#endif // STATS
		
		//
		//  Clean up.
		//
		if (!bIsMiniportPacket &&
			(pNdisPacket != NULL))
		{
			RWanFreeReceiveCopy(pNdisPacket);
		}
	}
#if STATS
	else
	{
		INCR_STAT(&RecvPktsOk);
		ADD_STAT(&RecvBytesOk, StTotalLength);
	}
#endif // STATS
		
	return (PacketRefCount);
}




VOID
RWanIndicateData(
    IN	PRWAN_TDI_CONNECTION			pConnObject
    )
/*++

Routine Description:

	Core internal receive processing routine. This tries to match up
    queued receive requests with queued receive indications and completes
    as many requests as it can. It calls the receive event handler, if any,
    for a receive indication that reaches the head of its queue without
    matching up with a receive request.

Arguments:

	pConnObject		- Points to our TDI Connection context.

Locks on Entry:

	pConnObject

Locks on Exit:

	None

Return Value:

	None

--*/
{
	PRWAN_TDI_ADDRESS			pAddrObject;
	PRWAN_NDIS_VC				pVc;
	PRWAN_NDIS_ADAPTER			pAdapter;
	PRcvEvent					pRcvIndEvent;
	INT							rc;
	PRWAN_RECEIVE_REQUEST		pRcvReq;
	PRWAN_RECEIVE_INDICATION	pRcvInd;
	PRWAN_RECEIVE_INDICATION	pNextRcvInd;
	UINT						BytesToCopy;
	//
	//  List of receive indications that have been completed here.
	//
	PRWAN_RECEIVE_INDICATION	pCompletedRcvIndHead;
	PRWAN_RECEIVE_INDICATION	pCompletedRcvIndTail;

	BOOLEAN						IsMessageMode = TRUE;
	//
	//  TBD: Set IsMessageMode based on the connection type/protocol type.
	//
	PVOID						TdiEventContext;
	BOOLEAN						bConnectionInBadState = FALSE;
	BOOLEAN						bContinue = TRUE;



	pVc = pConnObject->NdisConnection.pNdisVc;
	pAddrObject = pConnObject->pAddrObject;

	RWAN_ASSERT(pAddrObject != NULL);

	pRcvIndEvent = pAddrObject->pRcvInd;
	TdiEventContext = pAddrObject->RcvIndContext;

	pCompletedRcvIndHead = NULL;
	pCompletedRcvIndTail = NULL;
	pAdapter = pVc->pNdisAf->pAdapter;

	//
	//  Check if the client has paused receiving.
	//
	if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_PAUSE_RECEIVE))
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
		return;
	}

	//
	//  Re-entrancy check.
	//
	if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_INDICATING_DATA))
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
		return;
	}

	RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_INDICATING_DATA);

	//
	//  Make sure the Connection Object doesn't go away as long
	//  as we are in this routine.
	//
	RWanReferenceConnObject(pConnObject);	// temp ref: RWanIndicateData

	RWANDEBUGP(DL_INFO, DC_DATA_RX,
		("=> Ind-Rcv: VC %x/%x, ReqHead %x, IndHead %x\n",
				pVc, pVc->Flags, pVc->pRcvReqHead, pVc->pRcvIndHead));

	//
	//  Loop till we run out of receive requests/indications.
	//
	for (/* Nothing */;
		 /* Nothing */;
		 /* Nothing */)
	{
		if (pVc->pRcvIndHead == NULL)
		{
			//
			//  No data to pass up. Quit.
			//
			break;
		}

		//
		//  See if we have data available in the current receive indication.
		//
		pRcvInd = pVc->pRcvIndHead;
		if (pRcvInd->TotalBytesLeft == 0)
		{
			//
			//  Move to the next receive indication.
			//
			pNextRcvInd = pRcvInd->pNextRcvInd;
			
			//
			//  Add the current receive indication to the list of receive
			//  indications to be freed up.
			//
			pRcvInd->pNextRcvInd = NULL;
			if (pCompletedRcvIndTail != NULL)
			{
				pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
			}
			else
			{
				pCompletedRcvIndHead = pRcvInd;
			}
			pCompletedRcvIndTail = pRcvInd;

			pVc->PendingPacketCount--;	// Moved packet to completed list

			//
			//  Move to the next receive indication.
			//
			pVc->pRcvIndHead = pNextRcvInd;
			pRcvInd = pNextRcvInd;

			//
			//  See if there are no more receive indications.
			//
			if (pRcvInd == NULL)
			{
				pVc->pRcvIndTail = NULL;
				break;
			}

		}

#if DBG
		if (pRcvInd)
		{
			RWAN_CHECK_DATA("IndicateData:", pRcvInd, pRcvInd->pReadData, pRcvInd->BytesLeftInBuffer);
		}
#endif // DBG

		//
		//  We have data available to pass up.
		//
		//  If we don't have any pending receive requests, and there
		//  is a Receive Indication event handler available, call the
		//  handler. We may get back a receive request.
		//
		if ((pVc->pRcvReqHead == NULL) &&
			(pRcvIndEvent != NULL))
		{
			CONNECTION_CONTEXT		ConnectionHandle;
			ULONG					ReceiveFlags;
			ULONG					BytesIndicated;
			ULONG					BytesTaken;
			ULONG					BytesAvailable;
			PVOID					pTSDU;
			TDI_STATUS				TdiStatus;
#ifdef NT
			EventRcvBuffer *		ERB;
			EventRcvBuffer **		pERB = &ERB;
			PTDI_REQUEST_KERNEL_RECEIVE	pRequestInformation;
			PIO_STACK_LOCATION		pIrpSp;
#else
			EventRcvBuffer			ERB;
			EventRcvBuffer *		pERB = &ERB;
#endif // !NT

			//
			//  Pre-allocate a receive request.
			//
			pRcvReq = RWanAllocateReceiveReq();
			if (pRcvReq == NULL)
			{
				RWAN_ASSERT(FALSE);
				break;
			}

			pRcvInd = pVc->pRcvIndHead;
			ConnectionHandle = pConnObject->ConnectionHandle;
			BytesIndicated = pRcvInd->BytesLeftInBuffer;
			BytesAvailable = pRcvInd->TotalBytesLeft;
			pTSDU = (PVOID)pRcvInd->pReadData;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			ReceiveFlags = TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE;

			BytesTaken = 0;

			RWAN_ASSERT(BytesIndicated != 0);
			RWAN_ASSERT(BytesAvailable != 0);

			TdiStatus = (*pRcvIndEvent)(
							TdiEventContext,
							ConnectionHandle,
							ReceiveFlags,
							BytesIndicated,
							BytesAvailable,
							&BytesTaken,
							pTSDU,
							pERB
							);


			RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Ind-Rcv: VC %x, Head %x, Indicated %d, Available %d, Bytes taken %d, Status %x\n",
							pVc, pVc->pRcvReqHead, BytesIndicated, BytesAvailable, BytesTaken, TdiStatus));

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);

			//
			//  Check if anything bad happened to this connection
			//  while we were indicating.
			//
			if ((pConnObject->State != RWANS_CO_CONNECTED) ||
				(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
			{
				RWanFreeReceiveReq(pRcvReq);
				bConnectionInBadState = TRUE;
				break;
			}

			//
			//  See if a receive request is given to us.
			//
			if (TdiStatus == TDI_MORE_PROCESSING)
			{
				//
				//  We have a receive request. Get at it.
				//
#ifdef NT
				NTSTATUS			Status;

				RWAN_ASSERT(ERB != NULL);

				pIrpSp = IoGetCurrentIrpStackLocation(*pERB);

				Status = RWanPrepareIrpForCancel(
								(PRWAN_ENDPOINT) pIrpSp->FileObject->FsContext,
								ERB,
								RWanCancelRequest
								);

				if (NT_SUCCESS(Status))
				{
					pRequestInformation = (PTDI_REQUEST_KERNEL_RECEIVE)
											&(pIrpSp->Parameters);
					pRcvReq->Request.pReqComplete = RWanDataRequestComplete;
					pRcvReq->Request.ReqContext = ERB;
					pRcvReq->TotalBufferLength = pRequestInformation->ReceiveLength;
					pRcvReq->pBuffer = ERB->MdlAddress;
					pRcvReq->pUserFlags = (PUSHORT)
											&(pRequestInformation->ReceiveFlags);
#else
					pRcvReq->Request.pReqComplete = ERB.erb_rtn;
					pRcvReq->Request.ReqContext = ERB.erb_context;
					pRcvReq->TotalBufferLength = ERB.erb_size;
					pRcvReq->pBuffer = ERB.erb_buffer;
					pRcvReq->pUserFlags = ERB.erb_flags;
#endif // NT
					pRcvReq->AvailableBufferLength = pRcvReq->TotalBufferLength;
					NdisQueryBufferSafe(
							pRcvReq->pBuffer,
							&(pRcvReq->pWriteData),
							&(pRcvReq->BytesLeftInBuffer),
							NormalPagePriority
							);

					if (pRcvReq->pWriteData != NULL)
					{
						if (pRcvReq->BytesLeftInBuffer > pRcvReq->AvailableBufferLength)
						{
							RWANDEBUGP(DL_INFO, DC_DATA_RX,
								("Indicate: pRcvReq %x, BytesLeft %d > Available %d, pTdiRequest %x\n",
										pRcvReq,
										pRcvReq->BytesLeftInBuffer,
										pRcvReq->AvailableBufferLength,
										pRequestInformation));

							pRcvReq->BytesLeftInBuffer = pRcvReq->AvailableBufferLength;
						}

						pRcvReq->pNextRcvReq = NULL;


						//
						//  Insert this receive request at the head of the pending
						//  request queue.
						//
						if (pVc->pRcvReqHead == NULL)
						{
							pVc->pRcvReqHead = pVc->pRcvReqTail = pRcvReq;
						}
						else
						{
							RWAN_ASSERT(pVc->pRcvReqTail != NULL);
							pRcvReq->pNextRcvReq = pVc->pRcvReqHead;
							pVc->pRcvReqHead = pRcvReq;
						}
					}
					else
					{
						//
						//  Couldn't get virtual address of MDL passed in.
						//
						TdiStatus = TDI_SUCCESS;
						RWanFreeReceiveReq(pRcvReq);
						pRcvReq = NULL;
					}
#ifdef NT
				}
				else
				{
					//
					//  The IRP was cancelled before it got to us.
					//  Continue as if the user returned SUCCESS.
					//
					TdiStatus = TDI_SUCCESS;
					RWanFreeReceiveReq(pRcvReq);
					pRcvReq = NULL;
				}
#endif // NT

				//
				//  Update based on what was consumed during the Indicate.
				//
				pRcvInd->BytesLeftInBuffer -= BytesTaken;
				pRcvInd->TotalBytesLeft -= BytesTaken;

				//
				//  If we still don't have any pending receive requests, quit.
				//
				if (pVc->pRcvReqHead == NULL)
				{
					RWANDEBUGP(DL_FATAL, DC_WILDCARD,
						("Ind: VC %x/%x, ConnObj %x/%x, RcvInd %x, no pending Req\n",
							pVc, pVc->Flags,
							pConnObject, pConnObject->Flags,
							pRcvInd));
					break;
				}

				//
				//  We have receive requests, so continue from the top.
				//
				continue;

			}
			else
			{
				//
				//  We didn't get a receive request.
				//
				if (TdiStatus == TDI_NOT_ACCEPTED)
				{
					BytesTaken = 0;

					//
					//  By returning this status, the TDI client is telling
					//  us to stop indicating data on this connection until
					//  it sends us a TDI receive.
					//
					RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_PAUSE_RECEIVE);
				}

				//
				//  Update based on what was consumed during the Indicate.
				//
				pRcvInd->BytesLeftInBuffer -= BytesTaken;
				pRcvInd->TotalBytesLeft -= BytesTaken;

				RWanFreeReceiveReq(pRcvReq);

				if (TdiStatus == TDI_SUCCESS)
				{
					continue;
				}
			}
	
		} // if Receive Event handler exists

		//
		//  If we still don't have any pending receive requests, quit.
		//
		if (pVc->pRcvReqHead == NULL)
		{
#if DBG1
			if (pVc->pRcvIndHead && (pVc->pRcvIndHead->TotalBytesLeft == 0))
			{
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("Ind: VC %x/%x, No pending recv reqs, RcvInd empty!\n", pVc, pVc->Flags));
				RWAN_ASSERT(FALSE);
			}
#endif
			break;
		}

		//
		//  Fill in the receive request at the head of the queue
		//  as much as we can.
		//
		pRcvReq = pVc->pRcvReqHead;
		pRcvInd = pVc->pRcvIndHead;

		RWAN_ASSERT(pRcvReq != NULL);
		RWAN_ASSERT(pRcvInd != NULL);

		while (pRcvReq->AvailableBufferLength != 0)
		{
			if (pRcvReq->BytesLeftInBuffer == 0)
			{
				//
				//  Move to the next buffer in the chain.
				//
				RWAN_ADVANCE_RCV_REQ_BUFFER(pRcvReq);
				RWAN_ASSERT(pRcvReq->BytesLeftInBuffer != 0);
			}

			RWAN_ASSERT(pRcvInd != NULL);

			if (pRcvInd->BytesLeftInBuffer == 0)
			{
				RWAN_ADVANCE_RCV_IND_BUFFER(pRcvInd);
				RWAN_ASSERT(pRcvInd->BytesLeftInBuffer != 0);
			}

			BytesToCopy = MIN(pRcvReq->BytesLeftInBuffer, pRcvInd->BytesLeftInBuffer);

			RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_RX,
					("IndicateData: pVc x%x, pRcvInd x%x, pRcvReq x%x, copying %d bytes, %x to %x\n",
						pVc,
						pRcvInd,
						pRcvReq,
						BytesToCopy,
						pRcvInd->pReadData,
						pRcvReq->pWriteData));

#if DBG
			if (pRcvInd)
			{
				RWAN_CHECK_DATA("IndicateData - copy:", pRcvInd, pRcvInd->pReadData, BytesToCopy);
			}
#endif // DBG
			RWAN_COPY_MEM(pRcvReq->pWriteData,
						 pRcvInd->pReadData,
						 BytesToCopy);
			
			pRcvReq->pWriteData += BytesToCopy;
			pRcvReq->BytesLeftInBuffer -= BytesToCopy;
			pRcvReq->AvailableBufferLength -= BytesToCopy;
#if DBG
			if (pRcvReq->AvailableBufferLength > pRcvReq->TotalBufferLength)
			{
				RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Indicate: VC %x, RcvRq %x, Avail %d > Total %d, BytesToCopy %d, RcvInd %x\n",
						pVc, pRcvReq,
						pRcvReq->AvailableBufferLength,
						pRcvReq->TotalBufferLength,
						BytesToCopy,
						pRcvInd));

				RWAN_ASSERT(FALSE);
			}
#endif
			pRcvInd->pReadData += BytesToCopy;
			pRcvInd->BytesLeftInBuffer -= BytesToCopy;
			pRcvInd->TotalBytesLeft -= BytesToCopy;

			//
			//  See if we have data available in the current receive indication.
			//
			if (pRcvInd->TotalBytesLeft == 0)
			{
				//
				//  Move to the next receive indication.
				//
				pNextRcvInd = pRcvInd->pNextRcvInd;
				
				//
				//  Add the current receive indication to the list of receive
				//  indications to be freed up.
				//
				pRcvInd->pNextRcvInd = NULL;
				if (pCompletedRcvIndTail != NULL)
				{
					pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
				}
				else
				{
					pCompletedRcvIndHead = pRcvInd;
				}

				pCompletedRcvIndTail = pRcvInd;

				pVc->PendingPacketCount--;	// Moved packet to completed list

				//
				//  Move to the next receive indication.
				//
				pVc->pRcvIndHead = pNextRcvInd;
				pRcvInd = pNextRcvInd;

				//
				//  See if there are no more receive indications.
				//
				if (pRcvInd == NULL)
				{
					pVc->pRcvIndTail = NULL;
					break;
				}

				//
				//  If this connection uses message mode delivery,
				//  we don't allow a receive request to span multiple
				//  received packets.
				//
				if (IsMessageMode)
				{
					break;
				}
			}
		}

		//
		//  A receive request has been filled in either completely
		//  or partially. If we are in message mode, complete the
		//  receive now, otherwise we will wait for more data.
		//
		if ((pRcvReq->AvailableBufferLength == 0) ||
			IsMessageMode)
		{
			TDI_STATUS		ReceiveStatus;
			UINT			BytesCopied;

			//
			//  A receive request has been fully/partially satisfied. Take it
			//  out of the pending list and complete it.
			//
			pVc->pRcvReqHead = pRcvReq->pNextRcvReq;
			if (pVc->pRcvReqHead == NULL)
			{
				pVc->pRcvReqTail = NULL;
			}

			BytesCopied = pRcvReq->TotalBufferLength - pRcvReq->AvailableBufferLength;

			//
			//  Check if we copied in only part of a received packet into
			//  this receive request. If so, indicate an overflow.
			//
			if ((pRcvReq->AvailableBufferLength == 0) &&
				(pVc->pRcvIndHead != NULL) &&
				(pVc->pRcvIndHead->TotalBytesLeft != pVc->pRcvIndHead->PacketLength))
			{
				RWANDEBUGP(DL_LOUD, DC_WILDCARD,
					("Ind-Rcv: Overflow: VC %x/%x, Head %x, BytesCopied %d, Left %d\n",
						pVc, pVc->Flags, pVc->pRcvIndHead, BytesCopied, pVc->pRcvIndHead->TotalBytesLeft));
				ReceiveStatus = TDI_BUFFER_OVERFLOW;
				*(pRcvReq->pUserFlags) = 0;
			}
			else
			{
				ReceiveStatus = TDI_SUCCESS;
				*(pRcvReq->pUserFlags) = TDI_RECEIVE_ENTIRE_MESSAGE;
			}

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			*(pRcvReq->pUserFlags) |= TDI_RECEIVE_NORMAL;

			RWANDEBUGP(DL_INFO, DC_DATA_RX,
				("Ind-Rcv: VC %x/%x, Head %x, completing TDI Rcv %x, %d bytes, Status %x\n",
						pVc, pVc->Flags, pVc->pRcvReqHead, pRcvReq, BytesCopied, ReceiveStatus));

			//
			//  Complete the Receive Req
			//
			(*pRcvReq->Request.pReqComplete)(
						pRcvReq->Request.ReqContext,
						ReceiveStatus,
						BytesCopied
						);
			
			RWanFreeReceiveReq(pRcvReq);

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);

			//
			//  Check if anything bad happened to this connection
			//  while we were completing the receive request.
			//
			if ((pConnObject->State != RWANS_CO_CONNECTED) ||
				(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)))
			{
				bConnectionInBadState = TRUE;
				break;
			}
		}

	} // forever


	RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_INDICATING_DATA);

	rc = RWanDereferenceConnObject(pConnObject);	// end temp ref: RWanIndicateData

	if (rc > 0)
	{
		//
		//  Update receive indication queue on the VC. Only if the VC
		//  is still around...
		//
		if (pVc == pConnObject->NdisConnection.pNdisVc)
		{
			if (bConnectionInBadState)
			{
				ULONG		AbortCount = 0;

				RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Ind: start abort VC %x/%x state %d, pComplRcvHead %p, tail %p\n",
						pVc, pVc->Flags, pVc->State, pCompletedRcvIndHead, pCompletedRcvIndTail));
				//
				//  Take out all pending receives.
				//
				for (pRcvInd = pVc->pRcvIndHead;
 					pRcvInd != NULL;
 					pRcvInd = pNextRcvInd)
				{
					pNextRcvInd = pRcvInd->pNextRcvInd;

					pRcvInd->pNextRcvInd = NULL;
					if (pCompletedRcvIndTail != NULL)
					{
						pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
					}
					else
					{
						pCompletedRcvIndHead = pRcvInd;
					}

					pCompletedRcvIndTail = pRcvInd;

					pVc->PendingPacketCount--;	// Abort: Moved packet to completed list
					AbortCount++;
				}

				pVc->pRcvIndHead = pVc->pRcvIndTail = NULL;

				RWANDEBUGP(DL_INFO, DC_DATA_RX,
					("Ind: end abort VC %x/%x state %d, pComplRcvHead %p, tail %p, Count %d\n",
						pVc, pVc->Flags, pVc->State, pCompletedRcvIndHead, pCompletedRcvIndTail, AbortCount));
			}
			else
			{
				//
				//  Update the first Receive Indication if necessary.
				//
				if (pVc->pRcvIndHead &&
					(pVc->pRcvIndHead->TotalBytesLeft == 0))
				{
					RWANDEBUGP(DL_LOUD, DC_WILDCARD,
						("Ind: VC %x/%x, empty pRcvInd at head %x\n", pVc, pVc->Flags,
							pVc->pRcvIndHead));

					pRcvInd = pVc->pRcvIndHead;
					pNextRcvInd = pRcvInd->pNextRcvInd;

					pRcvInd->pNextRcvInd = NULL;

					if (pCompletedRcvIndTail != NULL)
					{
						pCompletedRcvIndTail->pNextRcvInd = pRcvInd;
					}
					else
					{
						pCompletedRcvIndHead = pRcvInd;
					}

					pCompletedRcvIndTail = pRcvInd;

					pVc->PendingPacketCount--;	// IndComplete: Moved packet to completed list

					pVc->pRcvIndHead = pNextRcvInd;
					if (pVc->pRcvIndHead == NULL)
					{
						pVc->pRcvIndTail = NULL;
					}
				}
			}
		}
#if DBG
		else
		{
			RWANDEBUGP(DL_FATAL, DC_DATA_RX, ("Ind: ConnObj %p, VC %p blown away!\n",
							pConnObject, pVc));
		}
#endif // DBG

		//
		//  Check if we had queued up an IncomingClose while indicating data:
		//
		if (RWAN_IS_FLAG_SET(pConnObject->Flags, RWANF_CO_PENDED_DISCON, RWANF_CO_PENDED_DISCON))
		{
			RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_PENDED_DISCON);

			RWANDEBUGP(DL_FATAL, DC_DATA_RX, ("Ind: Conn %x, State %d, Addr %x, handling pended discon\n",
					pConnObject, pConnObject->State, pConnObject->pAddrObject));

			if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				if (pDisconInd != NULL)
				{
					RWANDEBUGP(DL_FATAL, DC_DATA_RX,
						("IndicateData: pConnObj %x/%x, st %x, will discon ind\n",
							pConnObject, pConnObject->Flags, pConnObject->State));

					pConnObject->State = RWANS_CO_DISCON_INDICATED;
					ConnectionHandle = pConnObject->ConnectionHandle;

					RWanScheduleDisconnect(pConnObject);
					bContinue = FALSE;

					(*pDisconInd)(
							IndContext,
							ConnectionHandle,
							0,			// Disconnect Data Length
							NULL,		// Disconnect Data
							0,			// Disconnect Info Length
							NULL,		// Disconnect Info
							TDI_DISCONNECT_RELEASE
							);
				}
				else
				{
					RWAN_ASSERT(FALSE);
				}
			}
			else
			{
				RWAN_ASSERT(FALSE);
			}
		}

		//
		//  Check if we need to close this connection.
		//
		if (bContinue)
		{
			if (RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_NEEDS_CLOSE))
			{
				RWanStartCloseCall(pConnObject, pVc);
			}
			else
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
			}
		}
	}

	//
	//  Link all completed receive indications to the list on this adapter.
	//  They will be returned to the miniport in the ReceiveComplete
	//  handler.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	{
		PRWAN_RECEIVE_INDICATION *	ppRcvIndTail;

		ppRcvIndTail = &(pAdapter->pCompletedReceives);
		while (*ppRcvIndTail != NULL)
		{
			ppRcvIndTail = &((*ppRcvIndTail)->pNextRcvInd);
		}

#if DBG
		if (bConnectionInBadState)
		{
			RWANDEBUGP(DL_INFO, DC_WILDCARD,
				("Ind: Adapter %p &ComplRcvs %p ComplRcvs %p, will tack on %p\n",
						pAdapter,
						&pAdapter->pCompletedReceives,
						pAdapter->pCompletedReceives,
						pCompletedRcvIndHead));
		}
#endif // DBG

		*ppRcvIndTail = pCompletedRcvIndHead;

	}

	RWAN_RELEASE_GLOBAL_LOCK();

}




VOID
RWanNdisReceiveComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext
	)
/*++

Routine Description:

	This is the entry point called by NDIS when the miniport
	informs it that it has completed indicating a bunch of
	received packets.

	We use this event to free up any completed receives
	on this adapter binding.

Arguments:

	ProtocolBindingContext	- Pointer to our Adapter structure

Return Value:

	None

--*/
{
	PRWAN_NDIS_ADAPTER			pAdapter;
	PRWAN_RECEIVE_INDICATION		pRcvInd;

	pAdapter = (PRWAN_NDIS_ADAPTER)ProtocolBindingContext;
	RWAN_STRUCT_ASSERT(pAdapter, nad);

	//
	//  Detach the list of completed receives from the adapter.
	//
	RWAN_ACQUIRE_GLOBAL_LOCK();

	pRcvInd = pAdapter->pCompletedReceives;
	pAdapter->pCompletedReceives = NULL;

	RWAN_RELEASE_GLOBAL_LOCK();

	RWanFreeReceiveIndList(pRcvInd);

	return;
}



VOID
RWanNdisTransferDataComplete(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket,
    IN	NDIS_STATUS					Status,
    IN	UINT						BytesTransferred
    )
/*++

Routine Description:


Arguments:


Return Value:

	None

--*/
{
	// Not expected.
	RWAN_ASSERT(FALSE);
}




NDIS_STATUS
RWanNdisReceive(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	NDIS_HANDLE					MacReceiveContext,
    IN	PVOID						HeaderBuffer,
    IN	UINT						HeaderBufferSize,
    IN	PVOID						pLookAheadBuffer,
    IN	UINT						LookAheadBufferSize,
    IN	UINT						PacketSize
    )
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	// Not expected.
	RWAN_ASSERT(FALSE);
	return (NDIS_STATUS_FAILURE);
}




INT
RWanNdisReceivePacket(
    IN	NDIS_HANDLE					ProtocolBindingContext,
    IN	PNDIS_PACKET				pNdisPacket
    )
/*++

Routine Description:

Arguments:


Return Value:

	None

--*/
{
	// Not expected.
	RWAN_ASSERT(FALSE);
	return (0);
}




PRWAN_RECEIVE_REQUEST
RWanAllocateReceiveReq(
	VOID
	)
/*++

Routine Description:

	Allocate a structure to keep context of a TDI Receive request.

Arguments:

	None

Return Value:

	Pointer to the allocated receive request structure, or NULL.

--*/
{
	PRWAN_RECEIVE_REQUEST		pRcvReq;

	RWAN_ALLOC_MEM(pRcvReq, RWAN_RECEIVE_REQUEST, sizeof(RWAN_RECEIVE_REQUEST));

	if (pRcvReq != NULL)
	{
		RWAN_SET_SIGNATURE(pRcvReq, nrr);
	}

	return (pRcvReq);
}




VOID
RWanFreeReceiveReq(
    IN	PRWAN_RECEIVE_REQUEST		pRcvReq
   	)
/*++

Routine Description:

	Free a receive request structure.

Arguments:

	pRcvReq			- Points to structure to be freed

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pRcvReq, nrr);

	RWAN_FREE_MEM(pRcvReq);
}




PRWAN_RECEIVE_INDICATION
RWanAllocateReceiveInd(
	VOID
	)
/*++

Routine Description:

	Allocate a structure to keep context about an NDIS receive indication.

Arguments:

	None

Return Value:

	Pointer to the allocated structure, or NULL.

--*/
{
	PRWAN_RECEIVE_INDICATION		pRcvInd;

	RWAN_ALLOC_MEM(pRcvInd, RWAN_RECEIVE_INDICATION, sizeof(RWAN_RECEIVE_INDICATION));

	if (pRcvInd != NULL)
	{
		RWAN_SET_SIGNATURE(pRcvInd, nri);
	}

	return (pRcvInd);
}




VOID
RWanFreeReceiveInd(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	)
/*++

Routine Description:

	Free a receive indication structure.

Arguments:

	pRcvInd		- Points to structure to be freed.

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pRcvInd, nri);
	RWAN_FREE_MEM(pRcvInd);
}




PNDIS_PACKET
RWanMakeReceiveCopy(
    IN	PNDIS_PACKET				pNdisPacket
	)
/*++

Routine Description:

	Make a copy of a received packet to a private packet.

Arguments:

	pNdisPacket	- Points to original packet

Return Value:

	Pointer to private packet if successful, NULL otherwise.

--*/
{
	PNDIS_PACKET		pNewPacket;
	PNDIS_BUFFER		pNewBuffer;
	PUCHAR				pData;
	UINT				TotalLength;
	UINT				BytesCopied;
	NDIS_STATUS			Status;

	//
	//  Initialize.
	//
	pNewPacket = NULL;
	pNewBuffer = NULL;
	pData = NULL;

	do
	{
		NdisQueryPacket(
				pNdisPacket,
				NULL,
				NULL,
				NULL,
				&TotalLength
				);

		//
		//  Allocate space for the data.
		//
		RWAN_ALLOC_MEM(pData, UCHAR, TotalLength);
		if (pData == NULL)
		{
			break;
		}

		//
		//  Make this an NDIS Buffer (MDL).
		//
		NdisAllocateBuffer(
				&Status,
				&pNewBuffer,
				RWanCopyBufferPool,
				pData,
				TotalLength
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		//
		//  Allocate a new packet.
		//
		NdisAllocatePacket(
				&Status,
				&pNewPacket,
				RWanCopyPacketPool
				);

		if (Status != NDIS_STATUS_SUCCESS)
		{
			break;
		}

		NDIS_SET_PACKET_STATUS(pNewPacket, 0);

		//
		//  Link the buffer to the packet.
		//
		NdisChainBufferAtFront(pNewPacket, pNewBuffer);

		//
		//  Copy in the received packet.
		//
		NdisCopyFromPacketToPacket(
				pNewPacket,
				0,	// Destn offset
				TotalLength,
				pNdisPacket,
				0,	// Source offset
				&BytesCopied
				);

		RWAN_ASSERT(BytesCopied == TotalLength);

		break;
	}
	while (FALSE);

	if (pNewPacket == NULL)
	{
		//
		//  Clean up.
		//
		if (pData != NULL)
		{
			RWAN_FREE_MEM(pData);
		}

		if (pNewBuffer != NULL)
		{
			NdisFreeBuffer(pNewBuffer);
		}
	}

	return (pNewPacket);
}




VOID
RWanFreeReceiveCopy(
    IN	PNDIS_PACKET				pCopyPacket
	)
/*++

Routine Description:

	Free a packet that was used to keep a copy of a received packet,
	and its components (buffer etc).

Arguments:

	pCopyPacket	- Points to packet to be freed.

Return Value:

	None

--*/
{
	PNDIS_BUFFER	pCopyBuffer;
	PUCHAR			pCopyData;
	UINT			TotalLength;
	UINT			BufferLength;

	NdisGetFirstBufferFromPacket(
			pCopyPacket,
			&pCopyBuffer,
			(PVOID *)&pCopyData,
			&BufferLength,
			&TotalLength
			);
	
	RWAN_ASSERT(BufferLength == TotalLength);

	RWAN_ASSERT(pCopyBuffer != NULL);

	NdisFreePacket(pCopyPacket);

	NdisFreeBuffer(pCopyBuffer);

	RWAN_FREE_MEM(pCopyData);

	return;
}



VOID
RWanFreeReceiveIndList(
	IN	PRWAN_RECEIVE_INDICATION		pRcvInd
	)
/*++

Routine Description:

	Free a list of receive indications, and return any packets in there
	that belong to the miniport.

Arguments:

	pRcvInd				- Head of list of receives.

Return Value:

	None

--*/
{
	PRWAN_RECEIVE_INDICATION		pNextRcvInd;
	PNDIS_PACKET				pNdisPacket;
#if DBG
	RWAN_IRQL					EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	while (pRcvInd != NULL)
	{
		pNextRcvInd = pRcvInd->pNextRcvInd;

		pNdisPacket = pRcvInd->pPacket;

		RWANDEBUGP(DL_EXTRA_LOUD, DC_DATA_RX,
				("FreeRcvIndList: freeing Pkt x%x, RcvInd x%x\n",
						pNdisPacket, pRcvInd));

		if (pRcvInd->bIsMiniportPacket)
		{
			NdisReturnPackets(&pNdisPacket, 1);
		}
		else
		{
			RWanFreeReceiveCopy(pNdisPacket);
		}

		RWanFreeReceiveInd(pRcvInd);

		pRcvInd = pNextRcvInd;
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\system.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\system.h

Abstract:

	Raw WAN versions of system objects/definitions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/

#ifndef __TDI_RWAN_SYSTEM__H
#define __TDI_RWAN_SYSTEM__H


#define RWAN_NDIS_MAJOR_VERSION		5
#define RWAN_NDIS_MINOR_VERSION		0


#define RWAN_NAME				L"RawWan"
#define RWAN_NAME_STRING		NDIS_STRING_CONST("RawWan")
#define RWAN_DEVICE_NAME		L"\\Device\\RawWan"


#define LOCKIN
#define LOCKOUT
#define NOLOCKOUT


typedef struct _RWAN_EVENT
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} RWAN_EVENT, *PRWAN_EVENT;


//
//  List manipulation stuff
//

typedef SINGLE_LIST_ENTRY RWAN_SINGLE_LIST_ENTRY, *PRWAN_SINGLE_LIST_ENTRY;

#define NULL_PRWAN_SINGLE_LIST_ENTRY	((PRWAN_SINGLE_LIST_ENTRY)NULL)

#define RWAN_POP_FROM_SLIST	ExInterlockedPopEntrySList
#define RWAN_PUSH_TO_SLIST	ExInterlockedPushEntrySList

#if !BINARY_COMPATIBLE

#define RWAN_IRQL			KIRQL


#if DBG

#define RWAN_GET_ENTRY_IRQL(Irql)	\
			Irql = KeGetCurrentIrql()
#define RWAN_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)	\
		{										\
			ExitIrql = KeGetCurrentIrql();		\
			if (ExitIrql != EntryIrql)			\
			{									\
				DbgPrint("File %s, Line %d, Exit IRQ %d != Entry IRQ %d\n",	\
						__FILE__, __LINE__, ExitIrql, EntryIrql);			\
				DbgBreakPoint();				\
			}									\
		}
#else

#define RWAN_GET_ENTRY_IRQL(Irql)
#define RWAN_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#endif // DBG

#else

#define RWAN_GET_ENTRY_IRQL(Irql)
#define RWAN_CHECK_EXIT_IRQL(EntryIrql, ExitIrql)

#define RWAN_IRQL			ULONG

#endif // BINARY_COMPATIBLE


typedef PTDI_IND_CONNECT			PConnectEvent;
typedef PTDI_IND_DISCONNECT			PDisconnectEvent;
typedef PTDI_IND_ERROR				PErrorEvent;
typedef PTDI_IND_RECEIVE			PRcvEvent;

typedef IRP EventRcvBuffer;
typedef IRP ConnectEventInfo;


#endif // __TDI_RWAN_SYSTEM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\send.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\send.c

Abstract:

	Routines for sending data, including TDI entry points and
	NDIS completions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-16-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'DNES'

#if STATS

ULONG		SendPktsOk = 0;
ULONG		SendBytesOk = 0;
ULONG		SendPktsFail = 0;
ULONG		SendBytesFail = 0;

#endif // STATS
RWAN_STATUS
RWanInitSend(
	VOID
	)
/*++

Routine Description:

	Initialize our send side structures. All we need to do is to allocate
	an NDIS packet pool.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if we initialized successfully, RWAN_STATUS_RESOURCES
	if we couldn't allocate what we need.

--*/
{
	NDIS_STATUS			Status;

	NdisAllocatePacketPoolEx(
		&Status,
		&RWanSendPacketPool,
		RWAN_INITIAL_SEND_PACKET_COUNT,
		RWAN_OVERFLOW_SEND_PACKET_COUNT,
		0
		);

	return ((Status == NDIS_STATUS_SUCCESS)? RWAN_STATUS_SUCCESS: RWAN_STATUS_RESOURCES);
}



VOID
RWanShutdownSend(
	VOID
	)
/*++

Routine Description:

	Free up our send resources.

Arguments:

	None

Return Value:

	None

--*/
{
	if (RWanSendPacketPool != NULL)
	{
		NdisFreePacketPool(RWanSendPacketPool);
		RWanSendPacketPool = NULL;
	}

	return;
}




TDI_STATUS
RWanTdiSendData(
    IN	PTDI_REQUEST				pTdiRequest,
	IN	USHORT						SendFlags,
	IN	UINT						SendLength,
	IN	PNDIS_BUFFER				pSendBuffer
	)
/*++

Routine Description:

	This is the TDI Entry point for sending connection-oriented data.
	The Connection Object is identified by its context buried in the
	TDI Request.

	If all is well with the specified Connection, we prepend an NDIS
	packet to the buffer chain, and submit it to the miniport.

Arguments:

	pTdiRequest		- Pointer to the TDI Request containing the Send
	SendFlags		- Options associated with this Send
	SendLength		- Total data bytes in this Send
	pSendBuffer		- Pointer to buffer chain

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully submitted
	a send request via NDIS, TDI_NO_RESOURCES if we failed to allocate
	resources for the send, TDI_INVALID_CONNECTION if the specified

--*/
{
	RWAN_CONN_ID				ConnId;
	PRWAN_TDI_CONNECTION		pConnObject;
	TDI_STATUS				TdiStatus;

	PRWAN_NDIS_VC			pVc;
	NDIS_HANDLE				NdisVcHandle;
	PNDIS_PACKET			pNdisPacket;
	PRWAN_SEND_REQUEST		pSendReq;
	NDIS_STATUS				NdisStatus;


	pNdisPacket = NULL;

	do
	{
		//
		//  XXX: Should we check the length?
		//

		//
		//  Discard zero-length sends.
		//
		if (SendLength == 0)
		{
			TdiStatus = TDI_SUCCESS;
			break;
		}

		//
		//  Fail expedited data.
		//  TBD - base this on the media-specific module.
		//
		if (SendFlags & TDI_SEND_EXPEDITED)
		{
			TdiStatus = STATUS_NOT_SUPPORTED;	// No matching TDI status!
			break;
		}

		pNdisPacket = RWanAllocateSendPacket();
		if (pNdisPacket == NULL)
		{
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();


		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			TdiStatus = TDI_INVALID_CONNECTION;
			break;
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		if ((pConnObject->State != RWANS_CO_CONNECTED) ||
			(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSING)) ||
			(RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSE_SCHEDULED)))
		{
			//
			//  Fix up the return status to get proper Winsock error
			//  codes back to the app.
			//
			RWANDEBUGP(DL_INFO, DC_DATA_TX,
				("Send: bad state %d, pConnObject %x\n", pConnObject->State, pConnObject));
			if ((pConnObject->State == RWANS_CO_DISCON_INDICATED) ||
				(pConnObject->State == RWANS_CO_ASSOCIATED) ||
				(pConnObject->State == RWANS_CO_DISCON_REQUESTED))
			{
				//
				//  AFD would like to see us send an Abort at this time.
				//

				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;
	
				RWAN_ASSERT(pConnObject->pAddrObject != NULL);

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;
				ConnectionHandle = pConnObject->ConnectionHandle;
	
				RWAN_RELEASE_CONN_LOCK(pConnObject);

				(*pDisconInd)(
					IndContext,
					ConnectionHandle,
					0,			// Disconnect Data Length
					NULL,		// Disconnect Data
					0,			// Disconnect Info Length
					NULL,		// Disconnect Info
					TDI_DISCONNECT_ABORT
					);

				TdiStatus = TDI_CONNECTION_RESET;
			}
			else
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
				TdiStatus = TDI_INVALID_STATE;
			}
			break;
		}

		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_LEAF))
		{
			//
			//  Allow sends only on the Root Connection object.
			//
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			TdiStatus = TDI_INVALID_CONNECTION;
			break;
		}

		pVc = pConnObject->NdisConnection.pNdisVc;
		RWAN_ASSERT(pVc != NULL_PRWAN_NDIS_VC);
		RWAN_STRUCT_ASSERT(pVc, nvc);

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Save context about this send.
		//
		pSendReq = RWAN_SEND_REQUEST_FROM_PACKET(pNdisPacket);
		pSendReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pSendReq->Request.ReqContext = pTdiRequest->RequestContext;

		//
		//  XXX: we save the send flags also - may not be needed?
		//
		if ((pVc->MaxSendSize != 0) &&
			(SendLength > pVc->MaxSendSize))
		{
			RWANDEBUGP(DL_WARN, DC_DATA_TX,
					("TdiSendData: Sending %d, which is more than %d\n",
						SendLength, pVc->MaxSendSize));
#if HACK_SEND_SIZE
			pSendReq->SendLength = pVc->MaxSendSize;
		}
		else
		{
			pSendReq->SendLength = SendLength;
#else
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			TdiStatus = TDI_NO_RESOURCES;
			break;
		}

		pSendReq->SendLength = SendLength;
#endif // HACK_SEND_SIZE

		pVc->PendingPacketCount++;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		pSendReq->SendFlags = SendFlags;

		RWANDEBUGP(DL_INFO, DC_DATA_TX,
			("Send: VC %x [%d], %d bytes\n", pVc, pVc->MaxSendSize, SendLength));

		//
		//  Attach the buffer chain to the Packet.
		//
		NdisChainBufferAtFront(pNdisPacket, pSendBuffer);

#if HACK_SEND_SIZE
		if (pSendReq->SendLength != SendLength)
		{
			UINT		TotalPacketLength;

			//
			//  HACK: Recalculate total bytes and fix it.
			//
			NdisQueryPacket(
				pNdisPacket,
				NULL,
				NULL,
				NULL,
				&TotalPacketLength
				);
			
			pNdisPacket->Private.TotalLength = pSendReq->SendLength;
			DbgPrint("RWan: send: real length %d, sending length %d\n",
					TotalPacketLength, pSendReq->SendLength);
		}
#endif // HACK_SEND_SIZE

		RWAND_LOG_PACKET(pVc, RWAND_DLOG_TX_START, pNdisPacket, pTdiRequest->RequestContext);

		//
		//  And send it off.
		//
		NdisCoSendPackets(NdisVcHandle, &pNdisPacket, 1);

		//
		//  Our CoSendComplete handler will be called to signify completion.
		//  So we return PENDING now.
		//
		TdiStatus = TDI_PENDING;
		break;

	}
	while (FALSE);


	if (TdiStatus != TDI_PENDING)
	{
#if STATS
		if (TdiStatus == TDI_SUCCESS)
		{
			INCR_STAT(&SendPktsOk);
			ADD_STAT(&SendBytesOk, SendLength);
		}
		else
		{
			INCR_STAT(&SendPktsFail);
			ADD_STAT(&SendBytesFail, SendLength);
		}
#endif // STATS

		//
		//  Clean up.
		//

		if (pNdisPacket != NULL)
		{
			RWanFreeSendPacket(pNdisPacket);
		}

#if DBG
		if (TdiStatus != TDI_SUCCESS)
		{
			RWANDEBUGP(DL_INFO, DC_DATA_TX,
				("Send: Length %x, failing with status %x\n", SendLength, TdiStatus));
		}
#endif
	}

	return (TdiStatus);
}




VOID
RWanNdisCoSendComplete(
    IN	NDIS_STATUS					NdisStatus,
    IN	NDIS_HANDLE					ProtocolVcContext,
    IN	PNDIS_PACKET				pNdisPacket
    )
/*++

Routine Description:

	This is the NDIS Entry point indicating completion of a
	packet send. We complete the TDI Send Request.

Arguments:

	NdisStatus			- Status of the NDIS Send.
	ProtocolVcContext	- Actually a pointer to our NDIS VC structure
	pNdisPacket			- Packet that has been sent.

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC			pVc;
	PRWAN_SEND_REQUEST		pSendReq;
	PRWAN_TDI_CONNECTION	pConnObject;
	TDI_STATUS				TdiStatus;

	pVc = (PRWAN_NDIS_VC)ProtocolVcContext;
	RWAN_STRUCT_ASSERT(pVc, nvc);

#if STATS
	{
		PNDIS_BUFFER		pNdisBuffer;
		PVOID				FirstBufferVa;
		UINT				FirstBufferLength;
		UINT				TotalLength;

		NdisGetFirstBufferFromPacket(
			pNdisPacket,
			&pNdisBuffer,
			&FirstBufferVa,
			&FirstBufferLength,
			&TotalLength
			);
		
		if (NdisStatus == NDIS_STATUS_SUCCESS)
		{
			INCR_STAT(&SendPktsOk);
			ADD_STAT(&SendBytesOk, TotalLength);
		}
		else
		{
			INCR_STAT(&SendPktsFail);
			ADD_STAT(&SendBytesFail, TotalLength);
		}
	}
#endif // STATS

	if (NdisStatus == NDIS_STATUS_SUCCESS)
	{
		TdiStatus = TDI_SUCCESS;
	}
	else
	{
		TdiStatus = RWanNdisToTdiStatus(NdisStatus);
		RWANDEBUGP(DL_INFO, DC_DATA_TX,
			("CoSendComp: Failing Pkt %x, NDIS Status %x, TDI Status %x\n",
					pNdisPacket, NdisStatus, TdiStatus));
	}

	pSendReq = RWAN_SEND_REQUEST_FROM_PACKET(pNdisPacket);

	RWAND_LOG_PACKET(pVc, RWAND_DLOG_TX_END, pNdisPacket, pSendReq->Request.ReqContext);

	//
	//  Complete the TDI Send.
	//
	(*pSendReq->Request.pReqComplete)(
				pSendReq->Request.ReqContext,
				TdiStatus,
				((TdiStatus == TDI_SUCCESS) ? pSendReq->SendLength: 0)
				);

	//
	//  Free the NDIS Packet structure.
	//
	RWanFreeSendPacket(pNdisPacket);

	//
	//  Update the Connection object.
	//
	pConnObject = pVc->pConnObject;

	if (pConnObject != NULL)
	{
		RWAN_ASSERT(pConnObject->NdisConnection.pNdisVc == pVc);
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		pVc->PendingPacketCount--; // Send complete

		if ((pVc->PendingPacketCount == 0) &&
			(RWAN_IS_BIT_SET(pVc->Flags, RWANF_VC_NEEDS_CLOSE)))
		{
			RWanStartCloseCall(pConnObject, pVc);
		}
		else
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}
	}
	//
	//  else we are aborting this connection.
	//
#if DBG
	else
	{
		RWANDEBUGP(DL_WARN, DC_DATA_TX,
			("SendComp: VC %x, ConnObj is NULL\n", pVc));
	}
#endif // DBG

	return;
}




PNDIS_PACKET
RWanAllocateSendPacket(
	VOID
	)
/*++

Routine Description:

	Allocate and return an NDIS packet to prepare a send.

Arguments:

	None

Return Value:

	Pointer to allocate packet if successful, else NULL.

--*/
{
	PNDIS_PACKET		pSendPacket;
	NDIS_STATUS			Status;

	NdisAllocatePacket(
			&Status,
			&pSendPacket,
			RWanSendPacketPool
			);

	if (Status != NDIS_STATUS_SUCCESS)
	{
		pSendPacket = NULL;
	}

	return (pSendPacket);
}




VOID
RWanFreeSendPacket(
    IN	PNDIS_PACKET				pSendPacket
    )
/*++

Routine Description:

	Free an NDIS_PACKET used for a send.

Arguments:

	pSendPacket			- Points to packet to be freed.

Return Value:

	None

--*/
{
	RWAN_ASSERT(pSendPacket != NULL);

	NdisFreePacket(pSendPacket);
}




VOID
RWanNdisSendComplete(
	IN	NDIS_HANDLE					ProtocolBindingContext,
	IN	PNDIS_PACKET				pNdisPacket,
	IN	NDIS_STATUS					Status
	)
/*++

Routine Description:

	Dummy handler for connection-less send completes.

Arguments:


Return Value:

	None

--*/
{
	//
	//  We don't do connection-less sends yet.
	//
	RWAN_ASSERT(FALSE);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\vc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\vc.c

Abstract:

	Routines that manage NDIS VC objects.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-05-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER '  CV'



PRWAN_NDIS_VC
RWanAllocateVc(
	IN	PRWAN_NDIS_AF				pAf,
	IN	BOOLEAN						IsOutgoing
	)
/*++

Routine Description:

	Allocate and initialize an NDIS VC endpoint on the specified
	Address Family. If it is an "outgoing" VC, we also request
	NDIS to allocate a handle for it.

Arguments:

	pAf					- Points to NDIS AF block
	IsOutgoing			- This VC is for an outgoing call

Return Value:

	Pointer to VC if successful, NULL otherwise.

--*/
{
	PRWAN_NDIS_VC			pVc;
	NDIS_STATUS				Status;


	RWAN_ALLOC_MEM(pVc, RWAN_NDIS_VC, sizeof(RWAN_NDIS_VC));

	if (pVc != NULL)
	{
		RWAN_ZERO_MEM(pVc, sizeof(RWAN_NDIS_VC));

		RWAN_SET_SIGNATURE(pVc, nvc);

		pVc->pNdisAf = pAf;
		pVc->MaxSendSize = 0;	// Initialize.

		RWAN_INIT_LIST(&(pVc->NdisPartyList));

		if (IsOutgoing)
		{
			//
			//  Request the Call manager and Miniport to create a VC.
			//
			Status = NdisCoCreateVc(
						pAf->pAdapter->NdisAdapterHandle,
						pAf->NdisAfHandle,
						(NDIS_HANDLE)pVc,
						&(pVc->NdisVcHandle)
						);

			if (Status == NDIS_STATUS_SUCCESS)
			{
				//
				//  Add this VC to the list on the AF Block.
				//
				RWAN_ACQUIRE_AF_LOCK(pAf);

				RWAN_INSERT_TAIL_LIST(&(pAf->NdisVcList),
 									 &(pVc->VcLink));
			
				RWanReferenceAf(pAf);	// New outgoing VC ref

				RWAN_RELEASE_AF_LOCK(pAf);
			}
			else
			{
				RWAN_FREE_MEM(pVc);
				pVc = NULL;
			}
		}
		else
		{
			//
			//  Add this VC to the list on the AF Block.
			//
			RWAN_ACQUIRE_AF_LOCK(pAf);

			RWAN_INSERT_TAIL_LIST(&(pAf->NdisVcList),
 								&(pVc->VcLink));

			RWanReferenceAf(pAf);	// New incoming VC ref

			RWAN_RELEASE_AF_LOCK(pAf);
		}	
	}

	return (pVc);
}



VOID
RWanFreeVc(
	IN	PRWAN_NDIS_VC				pVc
	)
/*++

Routine Description:

	Free a VC structure.

Arguments:

	pVc				- Pointer to VC to be freed.

Return Value:

	None

--*/
{
	RWAN_FREE_MEM(pVc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\rwanpub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\rwanpub.h

Abstract:

	Null Transport Public definitions. This is included by helper
	routines that perform media/Address family specific actions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-24-97    Created

Notes:

--*/


#ifndef __TDI_RWANPUB__H
#define __TDI_RWANPUB__H

//
//  Null Transport status codes. Used between the core Null Transport
//  and helper routines.
//

typedef ULONG								RWAN_STATUS;

#define RWAN_STATUS_SUCCESS					0x00000000
#define RWAN_STATUS_FAILURE					0xc0000001
#define RWAN_STATUS_BAD_ADDRESS				0x00000001
#define RWAN_STATUS_NULL_ADDRESS			0x00000002
#define RWAN_STATUS_WILDCARD_ADDRESS		0x00000003
#define RWAN_STATUS_BAD_PARAMETER			0x00000010
#define RWAN_STATUS_MISSING_PARAMETER		0x00000020
#define RWAN_STATUS_RESOURCES				0x00000040
#define RWAN_STATUS_PENDING					0x00000103


typedef PVOID								RWAN_HANDLE, *PRWAN_HANDLE;

//
//  Bit definitions for CallFlags
//

//  Bit 0 is set iff Incoming Call:
#define RWAN_CALLF_OUTGOING_CALL			0x00000000
#define RWAN_CALLF_INCOMING_CALL			0x00000001
#define RWAN_CALLF_CALL_DIRECTION_MASK		0x00000001

//  Bit 1 is set iff Point to Multipoint Call:
#define RWAN_CALLF_POINT_TO_POINT			0x00000000
#define RWAN_CALLF_POINT_TO_MULTIPOINT		0x00000002
#define RWAN_CALLF_CALL_TYPE_MASK			0x00000002

//  Bit 2 is set iff Add Party:
#define RWAN_CALLF_PMP_FIRST_LEAF			0x00000000
#define RWAN_CALLF_PMP_ADDNL_LEAF			0x00000004
#define RWAN_CALLF_PMP_LEAF_TYPE_MASK		0x00000004


#ifndef EXTERN
#define EXTERN	extern
#endif


//
//  Entry points for NDIS AF-specific helper routines. All media/AF specific
//  actions are done by these routines.
//

//
//  Init routine. Called once when loading.
//
typedef
RWAN_STATUS
(*AFSP_INIT_HANDLER)();


//
//  Shutdown routine. Called once when unloading.
//
typedef
VOID
(*AFSP_SHUTDOWN_HANDLER)();


//
//  Set up context for an NDIS AF open. This is called after a
//  successful OpenAddressFamily for a supported AF+Medium.
//  The AF-specific module must allocate its context for this AF
//  open, perform any initializations (including OID queries to
//  the CM/Miniport) and return this context to us.
//  If the handler returns RWAN_STATUS_PENDING, it must call
//  RWanAfSpOpenAfComplete to complete this call.
//
typedef
RWAN_STATUS
(*AFSP_OPEN_AF_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	RWAN_HANDLE					RWanAFHandle,
	OUT	PRWAN_HANDLE				pAfSpAFContext,
	OUT PULONG						pMaxMsgSize
	);


//
//  Shut down prior to closing an NDIS AF open. This gives a chance
//  for the AF-specific module to perform any clean up operations,
//  including freeing any context, for an NDIS AF open.
//  If the handler returns RWAN_STATUS_PENDING, it must call
//  RWanAfSpCloseAfComplete to complete this call.
//
typedef
RWAN_STATUS
(*AFSP_CLOSE_AF_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext
	);

//
//  Notify media-specific module of a new Address Object being
//  opened for this medium. The media-specific module creates
//  its context for this address object and returns it.
//
typedef
RWAN_STATUS
(*AFSP_OPEN_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	RWAN_HANDLE					RWanAddrHandle,
	OUT	PRWAN_HANDLE				pAfSpAddrContext
	);


//
//  Notify media-specific module of an Address Object being
//  closed.
//
typedef
VOID
(*AFSP_CLOSE_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext
	);


//
//  Notify media-specific module of a new Connection Object being
//  associated with an Address Object belonging to this media. The
//  media-specific module would typically create its context for
//  the Connection Object and return a pointer to it.
//
typedef
RWAN_STATUS
(*AFSP_ASSOCIATE_CONN_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext,
	IN	RWAN_HANDLE					RWanConnHandle,
	OUT	PRWAN_HANDLE				pAfSpConnContext
	);


//
//  Notify media-specific module of an existing Connection Object
//  being disassociated from an Address Object belonging to this module.
//
typedef
VOID
(*AFSP_DISASSOCIATE_CONN_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext
	);


//
//  Convert options in TDI format to NDIS call parameters. The handler
//  is supposed to allocate space for NDIS call parameters, and return
//  this to the caller (via ppCallParameters).
//
//  Also this returns the RWAN handle for the AF on which the call should
//  be placed. If this is NULL, then the first AF is chosen.
//
typedef
RWAN_STATUS
(*AFSP_TDI2NDIS_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	OUT	PRWAN_HANDLE				pAfHandle,
	OUT PCO_CALL_PARAMETERS *		ppCallParameters
	);


//
//  Update NDIS call parameters with TDI options. This typically
//  happens when an incoming call is accepted with modified parameters.
//
typedef
RWAN_STATUS
(*AFSP_UPDATE_NDIS_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	IN OUT PCO_CALL_PARAMETERS *	ppCallParameters
	);


//
//  Return space allocated for NDIS Options to the AF Specific module.
//  See AFSP_TDI2NDIS_OPTIONS_HANDLER.
//
typedef
VOID
(*AFSP_RETURN_NDIS_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);


//
//  Convert NDIS call parameters to TDI-style options. The handler
//  is supposed to allocate space for options+data+QoS parameters,
//  and return these to the caller. When the caller is done with
//  these, it will call the TDI Options return handler with
//  a context returned by the handler.
//
typedef
RWAN_STATUS
(*AFSP_NDIS2TDI_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	ULONG						CallFlags,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	OUT	PTDI_CONNECTION_INFORMATION *ppTdiInfo,
	OUT	PVOID * 					ppTdiQoS,
	OUT	PULONG						pTdiQoSLength,
	OUT PRWAN_HANDLE				pAfSpTdiOptionsContext
	);


//
//  Update TDI-style options from NDIS call parameters. This is usually
//  done when completing an outgoing call.
//
typedef
RWAN_STATUS
(*AFSP_UPDATE_TDI_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN OUT PTDI_CONNECTION_INFORMATION * pTdiInfo,
	IN OUT PUCHAR 					pTdiQoS,
	IN OUT PULONG					pTdiQoSLength
	);


//
//  Return space allocated for TDI options etc to the AF Specific module.
//  See AFSP_NDIS2TDI_OPTIONS_HANDLER.
//
typedef
VOID
(*AFSP_RETURN_TDI_OPTIONS_HANDLER)(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpTdiOptionsContext
	);



//
//  Get a valid Transport Address from a list of addresses.
//
typedef
TA_ADDRESS *
(*AFSP_GET_VALID_TDI_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	TRANSPORT_ADDRESS UNALIGNED *pAddressList,
	IN	ULONG						AddrListLength
	);


//
//  Check if a given Transport address is non-NULL. This means that it is
//  usable as a SAP address.
//
typedef
BOOLEAN
(*AFSP_IS_NULL_ADDRESS_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	TA_ADDRESS *		        pTransportAddress
	);

//
//  Convert a TDI-style address specification to an NDIS SAP.
//  Allocate space for the NDIS SAP and return it if successful.
//
typedef
RWAN_STATUS
(*AFSP_TDI2NDIS_SAP_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	USHORT						TdiAddressType,
	IN	USHORT						TdiAddressLength,
	IN	PVOID						pTdiAddress,
	OUT	PCO_SAP *					ppCoSap
	);


//
//  Return space allocated for an NDIS SAP. See AFSP_TDI2NDIS_SAP_HANDLER.
//
typedef
VOID
(*AFSP_RETURN_NDIS_SAP_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	PCO_SAP						pCoSap
	);


//
//  Complete a media-specific module's call to RWanAfSpDeregisterNdisAF
//  that had pended.
//
typedef
VOID
(*AFSP_DEREG_NDIS_AF_COMP_HANDLER)(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpNdisAFContext
	);


//
//  Complete a media-specific module's call to RWanAfSpDeregisterTdiProtocol
//  that had pended.
//
typedef
VOID
(*AFSP_DEREG_TDI_PROTO_COMP_HANDLER)(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpTdiProtocolContext
	);


//
//  Complete a media-specific module's call to send an NDIS Request
//  to the miniport
//
typedef
VOID
(*AFSP_ADAPTER_REQUEST_COMP_HANDLER)(
	IN	NDIS_STATUS					Status,
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpReqContext,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
	);


//
//  Complete a media-specific module's call to send an NDIS Request
//  to the Call Manager (AF-specific request)
//
typedef
VOID
(*AFSP_AF_REQUEST_COMP_HANDLER)(
	IN	NDIS_STATUS					Status,
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpReqContext,
	IN	NDIS_REQUEST_TYPE			RequestType,
	IN	NDIS_OID					Oid,
	IN	PVOID						pBuffer,
	IN	ULONG						BufferLength
	);

//
//  Process a media-specific global Query Information IOCTL from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_QUERY_GLOBAL_INFO_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength,
	IN	PVOID						pOutputBuffer,
	IN OUT	PULONG					pOutputBufferLength
	);

//
//  Process a media-specific global Set Information IOCTL from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_SET_GLOBAL_INFO_HANDLER)(
	IN	RWAN_HANDLE					AfSpContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength
	);


//
//  Process a media-specific per-connection Query Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_QUERY_CONN_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength,
	OUT	PVOID						pOutputBuffer,
	IN OUT	PULONG					pOutputBufferLength
	);


//
//  Process a media-specific per-connection Set Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_SET_CONN_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength
	);

//
//  Process a media-specific per-AddressObject Query Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_QUERY_ADDR_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength,
	IN	PVOID						pOutputBuffer,
	IN OUT	PULONG					pOutputBufferLength
	);


//
//  Process a media-specific per-AddressObject Set Information IOCTL
//  from the Winsock2 helper DLL.
//
typedef
RWAN_STATUS
(*AFSP_SET_ADDR_INFORMATION_HANDLER)(
	IN	RWAN_HANDLE					AfSpAddrContext,
	IN	PVOID						pInputBuffer,
	IN	ULONG						InputBufferLength
	);

//
//  ***** NDIS AF Characteristics *****
//
//  AF-specific information about a supported NDIS Address Family on
//  a supported NDIS medium. One of these exists for each
//  <CO_ADDRESS_FAMILY, NDIS_MEDIUM> pair.
//
typedef struct _RWAN_NDIS_AF_CHARS
{
	ULONG								MajorVersion;
	ULONG								MinorVersion;
	NDIS_MEDIUM							Medium;
	CO_ADDRESS_FAMILY					AddressFamily;
	ULONG								MaxAddressLength;
	AFSP_OPEN_AF_HANDLER				pAfSpOpenAf;
	AFSP_CLOSE_AF_HANDLER				pAfSpCloseAf;

	AFSP_OPEN_ADDRESS_HANDLER			pAfSpOpenAddress;
	AFSP_CLOSE_ADDRESS_HANDLER			pAfSpCloseAddress;

	AFSP_ASSOCIATE_CONN_HANDLER			pAfSpAssociateConnection;
	AFSP_DISASSOCIATE_CONN_HANDLER		pAfSpDisassociateConnection;

	AFSP_TDI2NDIS_OPTIONS_HANDLER		pAfSpTdi2NdisOptions;
	AFSP_RETURN_NDIS_OPTIONS_HANDLER	pAfSpReturnNdisOptions;
	AFSP_UPDATE_NDIS_OPTIONS_HANDLER	pAfSpUpdateNdisOptions;

	AFSP_NDIS2TDI_OPTIONS_HANDLER		pAfSpNdis2TdiOptions;
	AFSP_RETURN_TDI_OPTIONS_HANDLER		pAfSpReturnTdiOptions;
	AFSP_UPDATE_TDI_OPTIONS_HANDLER		pAfSpUpdateTdiOptions;

	AFSP_GET_VALID_TDI_ADDRESS_HANDLER	pAfSpGetValidTdiAddress;
	AFSP_IS_NULL_ADDRESS_HANDLER		pAfSpIsNullAddress;

	AFSP_TDI2NDIS_SAP_HANDLER			pAfSpTdi2NdisSap;
	AFSP_RETURN_NDIS_SAP_HANDLER		pAfSpReturnNdisSap;

	AFSP_DEREG_NDIS_AF_COMP_HANDLER		pAfSpDeregNdisAFComplete;
	AFSP_ADAPTER_REQUEST_COMP_HANDLER	pAfSpAdapterRequestComplete;
	AFSP_AF_REQUEST_COMP_HANDLER		pAfSpAfRequestComplete;

	AFSP_QUERY_GLOBAL_INFO_HANDLER		pAfSpQueryGlobalInfo;
	AFSP_SET_GLOBAL_INFO_HANDLER		pAfSpSetGlobalInfo;

	AFSP_QUERY_CONN_INFORMATION_HANDLER	pAfSpQueryConnInformation;
	AFSP_SET_CONN_INFORMATION_HANDLER	pAfSpSetConnInformation;

	AFSP_QUERY_ADDR_INFORMATION_HANDLER	pAfSpQueryAddrInformation;
	AFSP_SET_ADDR_INFORMATION_HANDLER	pAfSpSetAddrInformation;

} RWAN_NDIS_AF_CHARS, *PRWAN_NDIS_AF_CHARS;




//
//  ***** TDI Protocol Characteristics *****
//
//  This contains information about a TDI protocol that's supported over
//  an <NDIS AF, medium> pair. This is used by the AF+Medium specific module
//  in a call to RWanAfSpRegisterTdiProtocol.
//
typedef struct _RWAN_TDI_PROTOCOL_CHARS
{
	UINT								TdiProtocol;
	UINT								SockAddressFamily;
	UINT								SockProtocol;
	UINT								SockType;
	BOOLEAN								bAllowConnObjects;
	BOOLEAN								bAllowAddressObjects;
	USHORT								MaxAddressLength;
	TDI_PROVIDER_INFO					ProviderInfo;
	PNDIS_STRING						pDeviceName;

	AFSP_DEREG_TDI_PROTO_COMP_HANDLER	pAfSpDeregTdiProtocolComplete;

} RWAN_TDI_PROTOCOL_CHARS, *PRWAN_TDI_PROTOCOL_CHARS;




//
//  ***** AF-Specific Module Entry *****
//
//  This contains the basic entry points for an AF/medium-specific module.
//
typedef struct _RWAN_AFSP_MODULE_CHARS
{
	AFSP_INIT_HANDLER				pAfSpInitHandler;
	AFSP_SHUTDOWN_HANDLER			pAfSpShutdownHandler;

} RWAN_AFSP_MODULE_CHARS, *PRWAN_AFSP_MODULE_CHARS;


//
//  Exported Routines. Media/AF specific modules can call these.
//
EXTERN
RWAN_STATUS
RWanAfSpRegisterNdisAF(
	IN	PRWAN_NDIS_AF_CHARS			pAfChars,
	IN	RWAN_HANDLE					AfSpContext,
	OUT	PRWAN_HANDLE				pRWanSpHandle
	);

EXTERN
RWAN_STATUS
RWanAfSpDeregisterNdisAF(
	IN	RWAN_HANDLE					RWanSpAFHandle
	);

EXTERN
RWAN_STATUS
RWanAfSpRegisterTdiProtocol(
	IN	RWAN_HANDLE					RWanSpHandle,
	IN	PRWAN_TDI_PROTOCOL_CHARS	pTdiChars,
	OUT	PRWAN_HANDLE				pRWanProtHandle
	);

EXTERN
VOID
RWanAfSpDeregisterTdiProtocol(
	IN	RWAN_HANDLE					RWanProtHandle
	);

EXTERN
VOID
RWanAfSpOpenAfComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						MaxMessageSize
   	);

EXTERN
VOID
RWanAfSpCloseAfComplete(
    IN	RWAN_HANDLE					RWanAfHandle
    );

EXTERN
RWAN_STATUS
RWanAfSpSendAdapterRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
RWAN_STATUS
RWanAfSpSendAfRequest(
    IN	RWAN_HANDLE					RWanAfHandle,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

#endif // __TDI_RWANPUB__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\utils.c

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-07-97    Created

Notes:

--*/

#include <precomp.h>


#define _FILENUMBER 'LITU'


RWAN_STATUS
RWanInitGlobals(
	IN	PDRIVER_OBJECT				pDriverObject
	)
/*++

Routine Description:

	Initialize global data structures.

Arguments:

	pDriverObject	- Points to our driver object, from DriverEntry.

Return Value:

	RWAN_STATUS_SUCCESS if initialized successfully, else an appropriate
	error code.

--*/
{
	RWAN_STATUS			RWanStatus;

	pRWanGlobal = &RWanGlobals;

	RWAN_ZERO_MEM(pRWanGlobal, sizeof(RWanGlobals));

	RWAN_SET_SIGNATURE(pRWanGlobal, nlg);
	RWAN_INIT_LIST(&pRWanGlobal->AfInfoList);
	RWAN_INIT_LIST(&pRWanGlobal->ProtocolList);
	RWAN_INIT_LIST(&pRWanGlobal->AdapterList);
	RWAN_INIT_GLOBAL_LOCK();
	RWAN_INIT_ADDRESS_LIST_LOCK();
	RWAN_INIT_CONN_TABLE_LOCK();

	RWAN_INIT_EVENT_STRUCT(&pRWanGlobal->Event);

	pRWanGlobal->MaxConnections = RWanMaxTdiConnections;

#ifdef NT
	pRWanGlobal->pDriverObject = pDriverObject;
	RWAN_INIT_LIST(&pRWanGlobal->DeviceObjList);
#endif // NT

	RWanStatus = RWanInitReceive();

	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		RWanStatus = RWanInitSend();

		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWanShutdownReceive();
		}
	}

	return (RWanStatus);
}




VOID
RWanDeinitGlobals(
	VOID
	)
/*++

Routine Description:

	The flip of RWanInitGlobals.

Arguments:

	None

Return Value:

	None

--*/
{
	RWAN_FREE_EVENT_STRUCT(&pRWanGlobal->Event);
	RWAN_FREE_GLOBAL_LOCK();

	if (pRWanGlobal->pConnTable != NULL)
	{
		RWAN_FREE_MEM(pRWanGlobal->pConnTable);
		pRWanGlobal->pConnTable = NULL;
	}

	RWanShutdownReceive();
	RWanShutdownSend();
}




PRWAN_TDI_PROTOCOL
RWanGetProtocolFromNumber(
	IN	UINT						Protocol
	)
/*++

Routine Description:

	Return the TDI Protocol info block that represents the given
	TDI protocol number.

Arguments:

	Protocol		- The TDI protocol number

Return Value:

	Pointer to TDI Protocol block if found, else NULL.

--*/
{
	PLIST_ENTRY			pAfInfoEntry;
	PRWAN_NDIS_AF_INFO	pAfInfo;

	PLIST_ENTRY			pProtocolEntry;
	PRWAN_TDI_PROTOCOL	pProtocol;
	BOOLEAN				bFound = FALSE;

	RWAN_ACQUIRE_GLOBAL_LOCK();

	for (pAfInfoEntry = pRWanGlobal->AfInfoList.Flink;
		 pAfInfoEntry != &(pRWanGlobal->AfInfoList);
		 pAfInfoEntry = pAfInfoEntry->Flink)
	{
		pAfInfo = CONTAINING_RECORD(pAfInfoEntry, RWAN_NDIS_AF_INFO, AfInfoLink);

		for (pProtocolEntry = pAfInfo->TdiProtocolList.Flink;
			 pProtocolEntry != &(pAfInfo->TdiProtocolList);
			 pProtocolEntry = pProtocolEntry->Flink)
		{

			pProtocol = CONTAINING_RECORD(pProtocolEntry, RWAN_TDI_PROTOCOL, AfInfoLink);

			if (pProtocol->TdiProtocol == Protocol)
			{
				bFound = TRUE;
				break;
			}
		}

		if (bFound)
		{
			break;
		}
	}

	RWAN_RELEASE_GLOBAL_LOCK();

	if (!bFound)
	{
		pProtocol = NULL;
	}

	return (pProtocol);
}




TA_ADDRESS *
RWanGetValidAddressFromList(
	IN	TRANSPORT_ADDRESS UNALIGNED *pAddrList,
	IN	PRWAN_TDI_PROTOCOL			pProtocol
	)
/*++

Routine Description:

	Go through the given transport address list, and return the first
	valid protocol address that we find.

	Valid address: one that matches the address type and length for
	the specified TDI protocol.

Arguments:

	pAddrList		- Points to list of addresses
	pProtocol		- Points to TDI Protocol block

Return Value:

	Pointer to the first valid address in the list if found, else NULL.

--*/
{
	INT						i;
	TA_ADDRESS *	        pAddr;

	pAddr = (TA_ADDRESS *)pAddrList->Address;

	for (i = 0; i < pAddrList->TAAddressCount; i++)
	{
		if ((pAddr->AddressType == pProtocol->SockAddressFamily) &&
			(pAddr->AddressLength >= pProtocol->MaxAddrLength))
		{
			return (pAddr);
		}

		pAddr = (TA_ADDRESS *)
					((PUCHAR)(pAddr->Address) + pAddr->AddressLength);
	}

	return (NULL);
}



PRWAN_TDI_CONNECTION
RWanAllocateConnObject(
	VOID
	)
/*++

Routine Description:

	Allocate a TDI Connection object.

Arguments:

	None

Return Value:

	Pointer to allocated Connection Object, or NULL.

--*/
{
	PRWAN_TDI_CONNECTION		pConnObject;

	RWAN_ALLOC_MEM(pConnObject, RWAN_TDI_CONNECTION, sizeof(RWAN_TDI_CONNECTION));

	if (pConnObject != NULL)
	{
		RWAN_ZERO_MEM(pConnObject, sizeof(RWAN_TDI_CONNECTION));

		RWAN_SET_SIGNATURE(pConnObject, ntc);

		RWAN_INIT_LOCK(&(pConnObject->Lock));
#if DBG
		pConnObject->ntcd_sig = ' gbD';
#endif
	}

	return (pConnObject);
}




VOID
RWanReferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Add a reference to the specified Connection Object.

Arguments:

	pConnObject		- Pointer to the TDI Connection Object.

Locks on Entry:

	pConnObject

Locks on Exit:

	pConnObject

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pConnObject, ntc);
	pConnObject->RefCount++;
}




INT
RWanDereferenceConnObject(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Dereference the specified Connection Object. If the reference
	count goes down to 0, free it.

Arguments:

	pConnObject		- Pointer to the TDI Connection Object.

Locks on Entry:

	pConnObject

Locks on Exit:

	pConnObject, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;

	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RefCount = --pConnObject->RefCount;

	if (RefCount == 0)
	{
		DeleteNotify = pConnObject->DeleteNotify;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		RWANDEBUGP(DL_EXTRA_LOUD, DC_UTIL,
				("Derefed away: pConnObj x%x, Notify x%x\n",
					pConnObject, DeleteNotify.pDeleteRtn));

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, TDI_SUCCESS, 0);
		}

		RWAN_FREE_MEM(pConnObject);
	}

	return (RefCount);
}




PRWAN_TDI_ADDRESS
RWanAllocateAddressObject(
	IN	TA_ADDRESS *		        pTransportAddress
	)
/*++

Routine Description:

	Allocate a TDI Address object.

Arguments:

	pTransportAddress	- Points to transport address for which this
						  Address Object is our context.

Return Value:

	Pointer to allocated Address Object, or NULL.

--*/
{
	PRWAN_TDI_ADDRESS		pAddrObject;
	ULONG					Size;
	NDIS_STATUS				Status;

	Size = sizeof(RWAN_TDI_ADDRESS) +
		   pTransportAddress->AddressLength;

	RWAN_ALLOC_MEM(pAddrObject, RWAN_TDI_ADDRESS, Size);

	if (pAddrObject != NULL)
	{
		RWAN_ZERO_MEM(pAddrObject, Size);

		RWAN_SET_SIGNATURE(pAddrObject, nta);

		RWAN_INIT_LOCK(&(pAddrObject->Lock));

		Status = NDIS_STATUS_SUCCESS;

		try
		{
			pAddrObject->AddressType = pTransportAddress->AddressType;
			pAddrObject->AddressLength = pTransportAddress->AddressLength;
			pAddrObject->pAddress = (PVOID)((PUCHAR)pAddrObject + sizeof(RWAN_TDI_ADDRESS));

			RWAN_COPY_MEM(pAddrObject->pAddress,
 						pTransportAddress->Address,
 						pTransportAddress->AddressLength);
 		}
 		except (EXCEPTION_EXECUTE_HANDLER)
 		{
 			Status = NDIS_STATUS_FAILURE;
 		}

 		if (Status != NDIS_STATUS_SUCCESS)
 		{
 			RWAN_FREE_MEM(pAddrObject);
 			pAddrObject = NULL;
 		}
 		else
 		{
			RWAN_INIT_LIST(&pAddrObject->IdleConnList);
			RWAN_INIT_LIST(&pAddrObject->ListenConnList);
			RWAN_INIT_LIST(&pAddrObject->ActiveConnList);
			RWAN_INIT_LIST(&pAddrObject->SapList);

			RWAN_INIT_EVENT_STRUCT(&pAddrObject->Event);
		}

	}

	return (pAddrObject);
}




VOID
RWanReferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	)
/*++

Routine Description:

	Add a reference to the specified Address Object.

Arguments:

	pAddrObject		- Pointer to the TDI Address Object.

Locks on Entry:

	pAddrObject

Locks on Exit:

	pAddrObject

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pAddrObject, nta);
	pAddrObject->RefCount++;
}




INT
RWanDereferenceAddressObject(
	IN	PRWAN_TDI_ADDRESS			pAddrObject
	)
/*++

Routine Description:

	Dereference the specified Address Object. If the reference
	count goes down to 0, free it.

Arguments:

	pAddrObject		- Pointer to the TDI Address Object.

Locks on Entry:

	pAddrObject

Locks on Exit:

	pAddrObject, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;

	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	RefCount = --pAddrObject->RefCount;

	if (RefCount == 0)
	{
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->IdleConnList));
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->ActiveConnList));
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->ListenConnList));
		RWAN_ASSERT(RWAN_IS_LIST_EMPTY(&pAddrObject->SapList));

		DeleteNotify = pAddrObject->DeleteNotify;

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		RWANDEBUGP(DL_EXTRA_LOUD, DC_UTIL,
				("Derefed away: pAddrObj x%x, Notify x%x\n",
					pAddrObject, DeleteNotify.pDeleteRtn));

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, (UINT)TDI_ADDR_DELETED, 0);
		}

		RWAN_FREE_MEM(pAddrObject);
	}

	return (RefCount);
}



PRWAN_NDIS_AF
RWanAllocateAf(
	VOID
	)
/*++

Routine Description:

	Allocate an NDIS AF block.

Arguments:

	None

Return Value:

	Pointer to allocated NDIS AF Block, or NULL.

--*/
{
	PRWAN_NDIS_AF		pAf;

	RWAN_ALLOC_MEM(pAf, RWAN_NDIS_AF, sizeof(RWAN_NDIS_AF));

	if (pAf != NULL)
	{
		RWAN_ZERO_MEM(pAf, sizeof(RWAN_NDIS_AF));

		RWAN_SET_SIGNATURE(pAf, naf);

		RWAN_INIT_LOCK(&(pAf->Lock));
		RWAN_INIT_LIST(&(pAf->NdisVcList));
		RWAN_INIT_LIST(&(pAf->NdisSapList));
	}

	RWANDEBUGP(DL_WARN, DC_WILDCARD,
		("Allocated AF x%x\n", pAf));

	return (pAf);
}




VOID
RWanReferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	)
/*++

Routine Description:

	Add a reference to the specified NDIS AF Block.

Arguments:

	pAf		- Pointer to the NDIS AF Block.

Locks on Entry:

	pAf

Locks on Exit:

	pAf

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pAf, naf);
	pAf->RefCount++;
}




INT
RWanDereferenceAf(
	IN	PRWAN_NDIS_AF			pAf
	)
/*++

Routine Description:

	Dereference the specified NDIS AF Block. If the reference
	count goes down to 0, free it. Some additional work if
	freeing this: unlink from the adapter, and check if the
	adapter is unbinding.

Arguments:

	pAf		- Pointer to the NDIS AF Block.

Locks on Entry:

	pAf

Locks on Exit:

	pAf, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;
	PRWAN_NDIS_ADAPTER		pAdapter;

	RWAN_STRUCT_ASSERT(pAf, naf);

	RefCount = --pAf->RefCount;

	if (RefCount == 0)
	{
		DeleteNotify = pAf->DeleteNotify;

		pAdapter = pAf->pAdapter;

		RWAN_RELEASE_AF_LOCK(pAf);

		RWAN_ACQUIRE_GLOBAL_LOCK();

		//
		//  Unlink from list of AF opens for this NDIS AF
		//
		RWAN_DELETE_FROM_LIST(&(pAf->AfInfoLink));

		RWAN_RELEASE_GLOBAL_LOCK();


		RWAN_ACQUIRE_ADAPTER_LOCK(pAdapter);

		//
		//  Unlink from list of AF opens on this adapter.
		//

		if (RWAN_IS_BIT_SET(pAf->Flags, RWANF_AF_IN_ADAPTER_LIST))
		{
			RWAN_DELETE_FROM_LIST(&(pAf->AfLink));
		}

		//
		//  See if we just deleted the last AF on this adapter, and
		//  we are in the process of unbinding from this adapter.
		//
		if (RWAN_IS_LIST_EMPTY(&pAdapter->AfList) &&
			RWAN_IS_BIT_SET(pAdapter->Flags, RWANF_AD_UNBIND_PENDING))
		{
			RWanCloseAdapter(pAdapter);
			//
			//  Adapter lock is released within the above.
			//
		}
		else
		{
			RWAN_RELEASE_ADAPTER_LOCK(pAdapter);
		}

		RWANDEBUGP(DL_EXTRA_LOUD, DC_UTIL,
				("Derefed away: pAf x%x, Notify x%x\n",
					pAf, DeleteNotify.pDeleteRtn));

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, TDI_SUCCESS, 0);
		}

		RWAN_FREE_MEM(pAf);
	}

	return (RefCount);
}



#if 0

VOID
RWanReferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	)
/*++

Routine Description:

	Add a reference to the specified NDIS ADAPTER Block.

Arguments:

	pAdapter		- Pointer to the NDIS ADAPTER Block.

Locks on Entry:

	pAdapter

Locks on Exit:

	pAdapter

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pAdapter, nad);
	pAdapter->RefCount++;
}




INT
RWanDereferenceAdapter(
	IN	PRWAN_NDIS_ADAPTER		pAdapter
	)
/*++

Routine Description:

	Dereference the specified NDIS ADAPTER Block. If the reference
	count goes down to 0, free it.

Arguments:

	pAdapter		- Pointer to the NDIS ADAPTER Block.

Locks on Entry:

	pAdapter

Locks on Exit:

	pAdapter, iff it hasn't been freed.

Return Value:

	INT - The resulting reference count.

--*/
{
	INT						RefCount;
	RWAN_DELETE_NOTIFY		DeleteNotify;

	RWAN_STRUCT_ASSERT(pAdapter, nad);

	RefCount = --pAdapter->RefCount;

	if (RefCount == 0)
	{
		DeleteNotify = pAdapter->DeleteNotify;

		RWAN_RELEASE_ADAPTER_LOCK(pAdapter);

		if (DeleteNotify.pDeleteRtn)
		{
			(*DeleteNotify.pDeleteRtn)(DeleteNotify.DeleteContext, TDI_SUCCESS, 0);
		}

		RWAN_FREE_MEM(pAdapter);
	}

	return (RefCount);
}


#endif // 0

TDI_STATUS
RWanNdisToTdiStatus(
	IN	NDIS_STATUS				Status
	)
/*++

Routine Description:

	Convert an NDIS Status code to an equivalent TDI code.
	TBD: RWanNdisToTdiStatus: support more NDIS status codes.

Arguments:

	Status		- NDIS status code.

Return Value:

	TDI status.

--*/
{
	TDI_STATUS			TdiStatus;

	switch (Status)
	{
		case NDIS_STATUS_SUCCESS:
			TdiStatus = TDI_SUCCESS;
			break;
		
		case NDIS_STATUS_RESOURCES:
		case NDIS_STATUS_VC_NOT_ACTIVATED:
		case NDIS_STATUS_VC_NOT_AVAILABLE:
			TdiStatus = TDI_NO_RESOURCES;
			break;

		case NDIS_STATUS_SAP_IN_USE:
			TdiStatus = TDI_ADDR_IN_USE;
			break;

		default:
			TdiStatus = TDI_NOT_ACCEPTED;
			break;
	}

	return (TdiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\space.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\space.c

Abstract:

	Globals and tunables.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     05-29-97    Created

Notes:

--*/

#define _FILENUMBER 'CAPS'

#include <precomp.h>



ULONG	RWanMaxTdiConnections = 4096;


struct _RWAN_AFSP_MODULE_CHARS	RWanMediaSpecificInfo[] =
								{
									{
										RWanAtmSpInitialize,
										RWanAtmSpShutdown
									},
									{
										(AFSP_INIT_HANDLER)0,
										(AFSP_SHUTDOWN_HANDLER)0
									}
								};


//
//  Receive pools.
//
NDIS_HANDLE						RWanCopyBufferPool;
NDIS_HANDLE						RWanCopyPacketPool;

//
//  Send pools.
//
NDIS_HANDLE						RWanSendPacketPool;


RWAN_GLOBALS					RWanGlobals = { 0 };
PRWAN_GLOBALS					pRWanGlobal;

NDIS_PROTOCOL_CHARACTERISTICS	RWanNdisProtocolCharacteristics;
NDIS_CLIENT_CHARACTERISTICS		RWanNdisClientCharacteristics;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\tdi\atmsp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\nultrans\atm\atmsp.c

Abstract:

	ATM Specific support functions for Null Transport. These routines
	perform operations like converting between TDI and NDIS formats.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-02-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'SMTA'




//
//  Global data structures.
//
ATMSP_GLOBAL_INFO			AtmSpGlobal;
PATMSP_GLOBAL_INFO			pAtmSpGlobal;


RWAN_STATUS
RWanAtmSpInitialize(
	VOID
	)
/*++

Routine Description:

	Initialize our interface with the core Null Transport.

	Step 1: Register all supported NDIS AF+Media combinations.
	Step 2: Register all supported TDI protocols.

Arguments:

	None

Return Value:

	RWAN_STATUS_SUCCESS if we initialized OK, error code otherwise.

--*/
{
	PRWAN_NDIS_AF_CHARS			pAfChars;
	PRWAN_TDI_PROTOCOL_CHARS	pTdiChars;
	RWAN_STATUS					RWanStatus;
	NDIS_STRING					DeviceName = NDIS_STRING_CONST("\\Device\\Atm");

	pAtmSpGlobal = &AtmSpGlobal;

	NdisGetCurrentSystemTime(&pAtmSpGlobal->StartTime);

	//
	//  Allocate space for the device string.
	//
	ATMSP_ALLOC_MEM(pAtmSpGlobal->AtmSpDeviceName.Buffer, WCHAR, DeviceName.MaximumLength);
	if (pAtmSpGlobal->AtmSpDeviceName.Buffer == NULL)
	{
		return RWAN_STATUS_RESOURCES;
	}

	pAtmSpGlobal->AtmSpDeviceName.MaximumLength = DeviceName.MaximumLength;
	RtlCopyUnicodeString(&pAtmSpGlobal->AtmSpDeviceName, &DeviceName);

	ATMSP_INIT_LIST(&pAtmSpGlobal->AfList);

	pAfChars = &(pAtmSpGlobal->AfChars);

	ATMSP_ZERO_MEM(pAfChars, sizeof(RWAN_NDIS_AF_CHARS));

	pAfChars->Medium = NdisMediumAtm;
	pAfChars->AddressFamily.AddressFamily = CO_ADDRESS_FAMILY_Q2931;
	pAfChars->AddressFamily.MajorVersion = ATMSP_AF_MAJOR_VERSION;
	pAfChars->AddressFamily.MinorVersion = ATMSP_AF_MINOR_VERSION;
	pAfChars->MaxAddressLength = sizeof(ATMSP_SOCKADDR_ATM);
	pAfChars->pAfSpOpenAf = RWanAtmSpOpenAf;
	pAfChars->pAfSpCloseAf = RWanAtmSpCloseAf;
#ifndef NO_CONN_CONTEXT
	pAfChars->pAfSpOpenAddress = RWanAtmSpOpenAddressObject;
	pAfChars->pAfSpCloseAddress = RWanAtmSpCloseAddressObject;
	pAfChars->pAfSpAssociateConnection = RWanAtmSpAssociateConnection;
	pAfChars->pAfSpDisassociateConnection = RWanAtmSpDisassociateConnection;
#endif
	pAfChars->pAfSpTdi2NdisOptions = RWanAtmSpTdi2NdisOptions;
	pAfChars->pAfSpUpdateNdisOptions = RWanAtmSpUpdateNdisOptions;
	pAfChars->pAfSpReturnNdisOptions = RWanAtmSpReturnNdisOptions; 
	pAfChars->pAfSpNdis2TdiOptions = RWanAtmSpNdis2TdiOptions;
	pAfChars->pAfSpUpdateTdiOptions = RWanAtmSpUpdateTdiOptions;
	pAfChars->pAfSpReturnTdiOptions = RWanAtmSpReturnTdiOptions;
	pAfChars->pAfSpGetValidTdiAddress = RWanAtmSpGetValidTdiAddress;
	pAfChars->pAfSpIsNullAddress = RWanAtmSpIsNullAddress;
	pAfChars->pAfSpTdi2NdisSap = RWanAtmSpTdi2NdisSap;
	pAfChars->pAfSpReturnNdisSap = RWanAtmSpReturnNdisSap;
	pAfChars->pAfSpDeregNdisAFComplete = RWanAtmSpDeregNdisAFComplete;
	pAfChars->pAfSpAdapterRequestComplete = RWanAtmSpAdapterRequestComplete;
	pAfChars->pAfSpAfRequestComplete = RWanAtmSpAfRequestComplete;
	pAfChars->pAfSpQueryGlobalInfo = RWanAtmSpQueryGlobalInfo;
	pAfChars->pAfSpSetGlobalInfo = RWanAtmSpSetGlobalInfo;
	pAfChars->pAfSpQueryConnInformation = RWanAtmSpQueryConnInfo;
	pAfChars->pAfSpSetAddrInformation = RWanAtmSpSetAddrInfo;

	RWanStatus = RWanAfSpRegisterNdisAF(
					pAfChars,
					(RWAN_HANDLE)&AtmSpGlobal,
					&AtmSpGlobal.RWanSpHandle
					);

	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		//
		//  Inform the core Null transport about the TDI protocols
		//  we support.
		//
		pTdiChars = &(AtmSpGlobal.TdiChars);
		ATMSP_ZERO_MEM(pTdiChars, sizeof(RWAN_TDI_PROTOCOL_CHARS));

		pTdiChars->SockAddressFamily = ATMSP_AF_ATM;
		pTdiChars->TdiProtocol = ATMSP_ATMPROTO_AAL5;
		pTdiChars->SockProtocol = ATMSP_ATMPROTO_AAL5;
		pTdiChars->SockType = ATMSP_SOCK_TYPE;
		pTdiChars->bAllowConnObjects = TRUE;
		pTdiChars->bAllowAddressObjects = TRUE;
		pTdiChars->MaxAddressLength = sizeof(ATM_ADDRESS);
		pTdiChars->pAfSpDeregTdiProtocolComplete = RWanAtmSpDeregTdiProtocolComplete;

		//
		//  TBD: Fill in ProviderInfo
		//
		pTdiChars->ProviderInfo.Version = 0;	// TBD
		pTdiChars->ProviderInfo.MaxSendSize = 65535;
		pTdiChars->ProviderInfo.MaxConnectionUserData = 0;
		pTdiChars->ProviderInfo.MaxDatagramSize = 0;
		pTdiChars->ProviderInfo.ServiceFlags =
									TDI_SERVICE_CONNECTION_MODE |
									TDI_SERVICE_MULTICAST_SUPPORTED |
									TDI_SERVICE_DELAYED_ACCEPTANCE |
									TDI_SERVICE_NO_ZERO_LENGTH |
									TDI_SERVICE_MESSAGE_MODE |
									TDI_SERVICE_FORCE_ACCESS_CHECK
									;
		pTdiChars->ProviderInfo.MinimumLookaheadData = 1;
		pTdiChars->ProviderInfo.MaximumLookaheadData = 65535;
		pTdiChars->ProviderInfo.NumberOfResources = 0;
		pTdiChars->ProviderInfo.StartTime = pAtmSpGlobal->StartTime;

		pTdiChars->pDeviceName = &pAtmSpGlobal->AtmSpDeviceName;

		RWanStatus = RWanAfSpRegisterTdiProtocol(
							AtmSpGlobal.RWanSpHandle,
							pTdiChars,
							&AtmSpGlobal.RWanProtHandle
							);

		ATMSP_ASSERT(RWanStatus != RWAN_STATUS_PENDING);

		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWanStatus = RWanAfSpDeregisterNdisAF(pAtmSpGlobal->RWanSpHandle);

			if (RWanStatus != RWAN_STATUS_PENDING)
			{
				RWanAtmSpDeregNdisAFComplete(
						RWanStatus,
						(RWAN_HANDLE)pAtmSpGlobal
						);
			}

			//
			//  Cook the return value.
			//
			RWanStatus = RWAN_STATUS_FAILURE;
		}
	}

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		//
		//  Clean up.
		//
		ATMSP_FREE_MEM(pAtmSpGlobal->AtmSpDeviceName.Buffer);
		pAtmSpGlobal->AtmSpDeviceName.Buffer = NULL;
	}

	return (RWanStatus);
}




VOID
RWanAtmSpShutdown(
	VOID
	)
/*++

Routine Description:

	This entry point is called by the core Null Transport when it
	wants us to shutdown.

	We deregister the TDI Protocol and NDIS AF that we had registered.

Arguments:

	None

Return Value:

	None

--*/
{
	RWAN_STATUS			RWanStatus;

	if (pAtmSpGlobal->RWanProtHandle != NULL)
	{
		RWanAfSpDeregisterTdiProtocol(pAtmSpGlobal->RWanProtHandle);
	}

	if (pAtmSpGlobal->RWanSpHandle != NULL)
	{
		RWanStatus = RWanAfSpDeregisterNdisAF(pAtmSpGlobal->RWanSpHandle);

		if (RWanStatus != RWAN_STATUS_PENDING)
		{
			RWanAtmSpDeregNdisAFComplete(
					RWanStatus,
					(RWAN_HANDLE)pAtmSpGlobal
					);
		}
	}	

	if (pAtmSpGlobal->AtmSpDeviceName.Buffer)
	{
		ATMSP_FREE_MEM(pAtmSpGlobal->AtmSpDeviceName.Buffer);
		pAtmSpGlobal->AtmSpDeviceName.Buffer = NULL;
	}

	return;
}




RWAN_STATUS
RWanAtmSpOpenAf(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAFHandle,
    OUT	PRWAN_HANDLE				pAfSpAFContext,
    OUT PULONG						pMaxMsgSize
    )
/*++

Routine Description:

	This entry point is called to set up our context for an NDIS AF
	open on a supported adapter. We allocate an AF context block,
	and query the miniport for some basic info about the adapter.

Arguments:

	AfSpContext			- Points to our global context
	RWanAFHandle		- Handle for this Open AF from the core Null Transport
	pAfSpAFContext		- Place to return our context for this AF
	pMaxMsgSize			- Place to return max message size for this AF

Return Value:

	RWAN_STATUS_SUCCESS normally, if we allocated an AF block
	RWAN_STATUS_RESOURCES if allocation failed.

--*/
{
	PATMSP_AF_BLOCK		pAfBlock;
	RWAN_STATUS			RWanStatus;

	UNREFERENCED_PARAMETER(AfSpContext);

	do
	{
		ATMSP_ALLOC_MEM(pAfBlock, ATMSP_AF_BLOCK, sizeof(ATMSP_AF_BLOCK));

		if (pAfBlock == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pAfBlock->RWanAFHandle = RWanAFHandle;

		ATMSP_INSERT_TAIL_LIST(&pAtmSpGlobal->AfList, &pAfBlock->AfBlockLink);
		pAtmSpGlobal->AfListSize++;

		//
		//  Query the Adapter for some information we use to build a default
		//  QOS structure.
		//
		(VOID)AtmSpDoAdapterRequest(
				pAfBlock,
				NdisRequestQueryInformation,
				OID_GEN_CO_LINK_SPEED,
				&(pAfBlock->LineRate),
				sizeof(pAfBlock->LineRate)
				);

		(VOID)AtmSpDoAdapterRequest(
				pAfBlock,
				NdisRequestQueryInformation,
				OID_ATM_MAX_AAL5_PACKET_SIZE,
				&(pAfBlock->MaxPacketSize),
				sizeof(pAfBlock->MaxPacketSize)
				);

		*pMaxMsgSize = pAfBlock->MaxPacketSize;

		//
		//  Prepare default QOS parameters for outgoing calls on this adapter.
		//
		AtmSpPrepareDefaultQoS(pAfBlock);

		*pAfSpAFContext = (RWAN_HANDLE)pAfBlock;
		RWanStatus = RWAN_STATUS_SUCCESS;

		break;
	}
	while (FALSE);

	if (RWanStatus != RWAN_STATUS_SUCCESS)
	{
		//
		//  Clean up.
		//
		if (pAfBlock != NULL)
		{
			ATMSP_FREE_MEM(pAfBlock);
		}
	}

	return (RWanStatus);

}




RWAN_STATUS
RWanAtmSpCloseAf(
    IN	RWAN_HANDLE					AfSpAFContext
    )
/*++

Routine Description:

	This entry point is called just before the core Null Transport
	closes an NDIS AF. We free the context we had allocated for this AF.

Arguments:

	AfSpAFContext		- Pointer to our AF block.

Return Value:

	RWAN_STATUS_SUCCESS always.

--*/
{
	PATMSP_AF_BLOCK		pAfBlock;

	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;

	ATMSP_DELETE_FROM_LIST(&pAfBlock->AfBlockLink);
	pAtmSpGlobal->AfListSize--;

	ATMSP_FREE_MEM(pAfBlock);

	return (RWAN_STATUS_SUCCESS);
}



RWAN_STATUS
RWanAtmSpOpenAddressObject(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAddrHandle,
    OUT	PRWAN_HANDLE				pAfSpAddrContext
    )
/*++

Routine Description:

	We are notified that a new address object is created. We create
	our context for the addr object, store Rawwan's handle for the
	object and return our context.

Arguments:

	AfSpContext			- Points to our global context
	RWanAddrHandle		- Handle for this Address from the core RawWan
	pAfSpAddrContext	- Place to return our context for this addr object

Return Value:

	RWAN_STATUS_SUCCESS normally, if we allocated an Address block
	RWAN_STATUS_RESOURCES if allocation failed.

--*/
{
	PATMSP_ADDR_BLOCK			pAddrBlock;
	RWAN_STATUS					RWanStatus;

	*pAfSpAddrContext = NULL;

	do
	{
		ATMSP_ALLOC_MEM(pAddrBlock, ATMSP_ADDR_BLOCK, sizeof(ATMSP_ADDR_BLOCK));

		if (pAddrBlock == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		ATMSP_ZERO_MEM(pAddrBlock, sizeof(ATMSP_ADDR_BLOCK));
		pAddrBlock->RWanAddrHandle = RWanAddrHandle;
		pAddrBlock->RefCount = 1;	// Creation

		ATMSP_INIT_LIST(&pAddrBlock->ConnList);
		ATMSP_INIT_LOCK(&pAddrBlock->Lock);

		//
		//  Return value.
		//
		*pAfSpAddrContext = (RWAN_HANDLE)pAddrBlock;
		RWanStatus = RWAN_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (RWanStatus);
}


VOID
RWanAtmSpCloseAddressObject(
    IN	RWAN_HANDLE					AfSpAddrContext
    )
/*++

Routine Description:

	Our notification routine called by RawWan when an Address Object
	is destroyed. At this time, no connection objects should be
	associated with it. We simply deallocate our context for the
	address object.

Arguments:

	AfSpAddrContext	- Actually a pointer to our address block

Return Value:

	None

--*/
{
	PATMSP_ADDR_BLOCK			pAddrBlock;
	ULONG						rc;

	pAddrBlock = (PATMSP_ADDR_BLOCK)AfSpAddrContext;

	ATMSP_ACQUIRE_LOCK(&pAddrBlock->Lock);

	rc = --pAddrBlock->RefCount;

	ATMSP_RELEASE_LOCK(&pAddrBlock->Lock);

	if (rc == 0)
	{
		ATMSP_ASSERT(ATMSP_IS_LIST_EMPTY(&pAddrBlock->ConnList));

		ATMSP_FREE_LOCK(&pAddrBlock->Lock);

		ATMSP_FREE_MEM(pAddrBlock);
	}

	return;
}



RWAN_STATUS
RWanAtmSpAssociateConnection(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	RWAN_HANDLE					RWanConnHandle,
    OUT	PRWAN_HANDLE				pAfSpConnContext
    )
/*++

Routine Description:

	Our notification routine that's called by RawWan when a Connection
	Object is associated with an address object.

	We create a Connection Block and link it with the specified
	address block.

Arguments:

	AfSpAddrContext	- Actually a pointer to our address block
	RWanConnHandle	- RawWan's handle for this connection object
	pAfSpConnHandle	- where we're supposed to return our context for the conn object

Return Value:

	RWAN_STATUS_SUCCESS always.

--*/
{
	PATMSP_CONN_BLOCK		pConnBlock;
	PATMSP_ADDR_BLOCK		pAddrBlock;
	RWAN_STATUS				RWanStatus;

	pAddrBlock = (PATMSP_ADDR_BLOCK)AfSpAddrContext;

	do
	{
		ATMSP_ALLOC_MEM(pConnBlock, ATMSP_CONN_BLOCK, sizeof(ATMSP_CONN_BLOCK));
		if (pConnBlock == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pConnBlock->RWanConnHandle = RWanConnHandle;
		pConnBlock->pAddrBlock = pAddrBlock;

		//
		//  Link to address block.
		//
		ATMSP_ACQUIRE_LOCK(&pAddrBlock->Lock);

		ATMSP_INSERT_TAIL_LIST(&pAddrBlock->ConnList, &pConnBlock->ConnLink);

		pAddrBlock->RefCount++;

		ATMSP_RELEASE_LOCK(&pAddrBlock->Lock);

		//
		//  Return values.
		//
		*pAfSpConnContext = (RWAN_HANDLE)pConnBlock;
		RWanStatus = RWAN_STATUS_SUCCESS;
		break;
	}
	while (FALSE);

	return (RWanStatus);
}

VOID
RWanAtmSpDisassociateConnection(
	IN	RWAN_HANDLE					AfSpConnContext
	)
/*++

Routine Description:

	Our notification routine that's called by RawWan when a Connection
	Object is disassociated from its address object.

Arguments:

	AfSpConnContext	- Our Conn context that we returned from the Associate
					  Connection routine.

Return Value:

	None

--*/
{
	PATMSP_CONN_BLOCK			pConnBlock;
	PATMSP_ADDR_BLOCK			pAddrBlock;
	ULONG						rc;

	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;
	pAddrBlock = pConnBlock->pAddrBlock;
	ATMSP_ASSERT(pAddrBlock != NULL);

	//
	//  De-link from address block first.
	//
	ATMSP_ACQUIRE_LOCK(&pAddrBlock->Lock);

	ATMSP_DELETE_FROM_LIST(&pConnBlock->ConnLink);

	rc = --pAddrBlock->RefCount;

	ATMSP_RELEASE_LOCK(&pAddrBlock->Lock);

	if (rc == 0)
	{
		ATMSP_ASSERT(ATMSP_IS_LIST_EMPTY(&pAddrBlock->ConnList));

		ATMSP_FREE_MEM(pAddrBlock);
	}

	ATMSP_FREE_MEM(pConnBlock);

	return;
}


RWAN_STATUS
RWanAtmSpTdi2NdisOptions(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
    IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
    IN	PVOID						pTdiQoS,
    IN	ULONG						TdiQoSLength,
    OUT	PRWAN_HANDLE				pRWanAfHandle	OPTIONAL,
    OUT	PCO_CALL_PARAMETERS *		ppCallParameters
    )
/*++

Routine Description:

	This is called to convert Call parameters from TDI form to
	NDIS format. We allocate space for NDIS parameters, fill it
	and return it.

	We also return the AFHandle for the AFBlock on which the call
	should be placed.

	For ATM, the call parameters are presented as follows:
	pTdiInfo->RemoteAddress - Calling/Called ATM Address, BLLI and BHLI
	pTdiQoS - Send and receive Flowspec, and optionally, other info elements.

Arguments:

	AfSpConnContext		- Points to our Conn block
	CallFlags			- Call direction and other info
	pTdiInfo			- Points to generic TDI Connection Information
	pTdiQoS				- Points to Winsock 2 style QoS structure
	TdiQoSLength		- Length of the above
	pRWanAfHandle		- Place to return AF Handle
	ppCallParameters 	- Place to return pointer to NDIS call parameters

Return Value:

	RWAN_STATUS_SUCCESS if we did the conversion successfully, RWAN_STATUS_XXX
	error code otherwise.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATMSP_AF_BLOCK					pAfBlock;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATMSP_ADDR_BLOCK				pAddrBlock;
	PCO_CALL_PARAMETERS				pCallParameters;
	Q2931_CALLMGR_PARAMETERS UNALIGNED *	pAtmCallParameters;
	CO_CALL_MANAGER_PARAMETERS UNALIGNED *	pCallMgrParameters;
	PATM_MEDIA_PARAMETERS			pAtmMediaParameters;
	ULONG							ParametersLength;
	Q2931_IE UNALIGNED *			pIe;
	Q2931_IE UNALIGNED *			pFirstIe;
	Q2931_IE UNALIGNED *			pDstIe;
	ULONG							IeLength;
	ATMSP_QOS *						pQoS;
	ATMSP_SOCKADDR_ATM UNALIGNED *	pRemoteAddr;
	BOOLEAN							IsBhliPresent; // part of Remote addr
	BOOLEAN							IsBlliPresent; // part of Remote addr
	INT								TotalIeLength; // explicitly passed to us by user
	ULONG							InfoElementCount; // explicit IE count
    BOOLEAN							IsOutgoingCall;
    BOOLEAN							IsPMPCall;
    BOOLEAN							IsPVC;


	//
	//  Initialize.
	//
	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
#ifndef NO_CONN_CONTEXT
		pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;
		ATMSP_ASSERT(pConnBlock != NULL);

		pAddrBlock = pConnBlock->pAddrBlock;
		ATMSP_ASSERT(pAddrBlock != NULL);

		IsPVC =	(ATMSP_IS_BIT_SET(pAddrBlock->Flags, ATMSPF_ADDR_PVC_ID_SET));
#else
		IsPVC = FALSE;
#endif

		IsOutgoingCall = ((CallFlags & RWAN_CALLF_CALL_DIRECTION_MASK) == RWAN_CALLF_OUTGOING_CALL);
		IsPMPCall = ((CallFlags & RWAN_CALLF_CALL_TYPE_MASK) == RWAN_CALLF_POINT_TO_MULTIPOINT);

		if (IsPVC)
		{
			//
			//  Locate the AF block corresponding to the device
			//  number.
			//
			pAfBlock = AtmSpDeviceNumberToAfBlock(pAddrBlock->ConnectionId.DeviceNumber);

			if (pAfBlock == NULL)
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}
		}
		else
		{
			if (ATMSP_IS_LIST_EMPTY(&pAtmSpGlobal->AfList))
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}
			
			pAfBlock = CONTAINING_RECORD(pAtmSpGlobal->AfList.Flink, ATMSP_AF_BLOCK, AfBlockLink);
		}

		//
		//  Validate.
		//
		if (IsOutgoingCall)
		{
			pRemoteAddr = AtmSpGetSockAtmAddress(pTdiInfo->RemoteAddress, pTdiInfo->RemoteAddressLength);

			if (pRemoteAddr == NULL)
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}

			RWANDEBUGPATMADDR(DL_LOUD, DC_CONNECT,
					"AtmSpTdi2NdisOptions: remote addr: ", &pRemoteAddr->satm_number);
		}
		else
		{
			pRemoteAddr = NULL;
		}

		if (pTdiQoS == NULL)
		{
		    RWANDEBUGP(DL_FATAL, DC_WILDCARD,
		        ("AtmSpTdi2NdisOptions: NULL TDIQOS\n"));

			pQoS = &(pAfBlock->DefaultQoS);
			TdiQoSLength = pAfBlock->DefaultQoSLength;
			TotalIeLength = 0;
			InfoElementCount = 0;
		}
		else
		{
			if (TdiQoSLength < sizeof(ATMSP_QOS))
			{
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
			}

			pQoS = (ATMSP_QOS *)pTdiQoS;

		    RWANDEBUGP(DL_FATAL, DC_WILDCARD,
		        ("AtmSpTdi2NdisOptions: Send: ServiceType %d, Peak %d, Recv %d, %d\n",
		            pQoS->SendingFlowSpec.ServiceType,
		            pQoS->SendingFlowSpec.PeakBandwidth,
		            pQoS->ReceivingFlowSpec.ServiceType,
		            pQoS->ReceivingFlowSpec.PeakBandwidth));


			//
			//  The provider-specific part is a list of Info Elements.
			//  Get the total length of this list.
			//
			TotalIeLength = (INT)pQoS->ProviderSpecific.len;

			//
			//  Get at the first Info element in the list.
			//
			pIe = (PQ2931_IE)((ULONG_PTR)pQoS + (ULONG_PTR)pQoS->ProviderSpecific.buf);
			pFirstIe = pIe;

#if 0
			if (((pIe == NULL) && (TotalIeLength != 0)) ||
				((pIe != NULL) && (TotalIeLength < sizeof(Q2931_IE))))
			{
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
			}
#endif // 0

			//
			//  Count the total number of Info Elements present.
			//  XXX: should we check IE types?
			//
			InfoElementCount = 0;

			while (TotalIeLength >= sizeof(Q2931_IE))
			{
				ATMSP_AAL_PARAMETERS_IE UNALIGNED *pAalParamsIe;
				ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *pBbcIe;

				if ((pIe->IELength == 0) ||
					(pIe->IELength > (ULONG)TotalIeLength))
				{
					RWanStatus = RWAN_STATUS_BAD_PARAMETER;
					break;
				}

				switch (pIe->IEType)
				{
					case IE_AALParameters:
						//
						//  Map AAL Type.
						//
						pAalParamsIe = (ATMSP_AAL_PARAMETERS_IE UNALIGNED *)&pIe->IE[0];
						if (pIe->IELength >= sizeof(*pAalParamsIe))
						{
							switch (pAalParamsIe->AALType)
							{
								case ATMSP_AALTYPE_5:
									pAalParamsIe->AALType = AAL_TYPE_AAL5;
									break;
								case ATMSP_AALTYPE_USER:
									pAalParamsIe->AALType = AAL_TYPE_AAL0;
									break;
								default:
									break;
							}
						}
						break;

					case IE_BroadbandBearerCapability:
						//
						//  Map BearerClass.
						//
						pBbcIe = (ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *)&pIe->IE[0];
						if (pIe->IELength >= sizeof(*pBbcIe))
						{
							switch (pBbcIe->BearerClass)
							{
								case ATMSP_BCOB_A:
									pBbcIe->BearerClass = BCOB_A;
									break;
								case ATMSP_BCOB_C:
									pBbcIe->BearerClass = BCOB_C;
									break;
								case ATMSP_BCOB_X:
									pBbcIe->BearerClass = BCOB_X;
									break;
								default:
									break;
							}
						}
						break;

					default:
						break;
				}

				TotalIeLength -= (INT)pIe->IELength;
				pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);

				InfoElementCount++;
			}

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				break;
			}

			TotalIeLength = (INT)pQoS->ProviderSpecific.len;
			pIe = pFirstIe;
		}

		//
		//  Calculate the total length requirements.
		//
		ParametersLength = sizeof(CO_CALL_PARAMETERS) +
						   sizeof(CO_CALL_MANAGER_PARAMETERS) +
						   sizeof(Q2931_CALLMGR_PARAMETERS) +
						   TotalIeLength;

		IsBlliPresent = (pRemoteAddr? ATMSP_BLLI_PRESENT(&pRemoteAddr->satm_blli): FALSE);

		if (IsBlliPresent)
		{
			ParametersLength += sizeof(ATM_BLLI_IE);
		}

		IsBhliPresent =  (pRemoteAddr? ATMSP_BHLI_PRESENT(&pRemoteAddr->satm_bhli): FALSE);
		if (IsBhliPresent)
		{
			ParametersLength += sizeof(ATM_BHLI_IE);
		}

#ifndef NO_CONN_CONTEXT
		//
		//  If this is a PVC, we'll fill in the Media parameters too.
		//
		if (IsPVC)
		{
			ParametersLength += sizeof(CO_MEDIA_PARAMETERS) +
								sizeof(ATM_MEDIA_PARAMETERS);
		}
#endif

		RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
				("AtmSpTdi2NdisOptions: BlliPresent %d, BhliPresent %d, TotalIeLen %d, ParamsLength %d\n",
					IsBlliPresent,
					IsBhliPresent,
					TotalIeLength,
					ParametersLength
					));

		ATMSP_ALLOC_MEM(pCallParameters, CO_CALL_PARAMETERS, ParametersLength);

		if (pCallParameters == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		ATMSP_ZERO_MEM(pCallParameters, ParametersLength);

		pCallParameters->Flags = 0;

		if (IsPMPCall)
		{
			pCallParameters->Flags |= MULTIPOINT_VC;
		}

		if (IsPVC)
		{
			pCallParameters->Flags |= PERMANENT_VC;

			//
			//  Start off with Media parameters, and then Call Mgr parameters.
			//
			pCallParameters->MediaParameters =
						(PCO_MEDIA_PARAMETERS)((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
			pCallParameters->MediaParameters->MediaSpecific.ParamType = ATM_MEDIA_SPECIFIC;
			pCallParameters->MediaParameters->MediaSpecific.Length = sizeof(ATM_MEDIA_PARAMETERS);

			pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)&pCallParameters->MediaParameters->MediaSpecific.Parameters[0];

			//
			//  Get the VPI/VCI values.
			//
			pAtmMediaParameters->ConnectionId.Vpi = pAddrBlock->ConnectionId.Vpi;
			pAtmMediaParameters->ConnectionId.Vci = pAddrBlock->ConnectionId.Vci;

			//
			//  Force the Call Manager to compute the rest of the ATM media
			//  parameters from the generic QoS parameters or IEs.
			//
			pAtmMediaParameters->AALType = QOS_NOT_SPECIFIED;

			//
			//  Allocate Call manager parameters space following the
			//  media parameters.
			//
			pCallMgrParameters =
			pCallParameters->CallMgrParameters =
						(PCO_CALL_MANAGER_PARAMETERS)((PUCHAR)pCallParameters +
									sizeof(CO_MEDIA_PARAMETERS) +
									sizeof(ATM_MEDIA_PARAMETERS) +
									sizeof(CO_CALL_PARAMETERS));
		}
		else
		{
			pCallParameters->MediaParameters = NULL;

			pCallMgrParameters =
			pCallParameters->CallMgrParameters =
						(PCO_CALL_MANAGER_PARAMETERS)((PUCHAR)pCallParameters +
									sizeof(CO_CALL_PARAMETERS));
		}

		if (IsOutgoingCall)
		{
			pCallMgrParameters->Transmit = pQoS->SendingFlowSpec;
			pCallMgrParameters->Receive = pQoS->ReceivingFlowSpec;

			if (IsPMPCall)
			{
				pCallMgrParameters->Receive.ServiceType = SERVICETYPE_NOTRAFFIC;
				pCallMgrParameters->Receive.PeakBandwidth = 0;
			}
		}
		else
		{
			pCallMgrParameters->Transmit = pQoS->ReceivingFlowSpec;
			pCallMgrParameters->Receive = pQoS->SendingFlowSpec;

			if (IsPMPCall)
			{
				pCallMgrParameters->Transmit.ServiceType = SERVICETYPE_NOTRAFFIC;
				pCallMgrParameters->Transmit.PeakBandwidth = 0;
			}
		}

		pCallMgrParameters->CallMgrSpecific.ParamType = 0;	// XXX?

		pAtmCallParameters = (PQ2931_CALLMGR_PARAMETERS)
									&(pCallMgrParameters->CallMgrSpecific.Parameters[0]);
		if (IsOutgoingCall)
		{
			ATMSP_ZERO_MEM(&pAtmCallParameters->CallingParty, sizeof(ATM_ADDRESS));
			pAtmCallParameters->CalledParty = pRemoteAddr->satm_number;
			if ((pRemoteAddr->satm_number.AddressType != SOCKATM_E164) &&
				(pRemoteAddr->satm_number.AddressType != SOCKATM_NSAP))
			{
				RWanStatus = RWAN_STATUS_BAD_ADDRESS;
				break;
			}

			pAtmCallParameters->CalledParty.AddressType =
					((pRemoteAddr->satm_number.AddressType == SOCKATM_E164)?
						ATM_E164: ATM_NSAP);
		}
		else
		{
			ATMSP_ZERO_MEM(&pAtmCallParameters->CalledParty, sizeof(ATM_ADDRESS));

			if (pRemoteAddr != NULL)
			{
				pAtmCallParameters->CallingParty = pRemoteAddr->satm_number;
				pAtmCallParameters->CallingParty.AddressType =
					((pRemoteAddr->satm_number.AddressType == SOCKATM_E164)?
						ATM_E164: ATM_NSAP);
			}
		}

		pAtmCallParameters->InfoElementCount = 0;
		pDstIe = (PQ2931_IE) &pAtmCallParameters->InfoElements[0];

		//
		//  Copy in the BHLI and BLLI IEs.
		//
		if (IsBhliPresent)
		{
			ATM_BHLI_IE UNALIGNED *	pBhliIe;

			pDstIe->IEType = IE_BHLI;
			pDstIe->IELength = ROUND_UP(sizeof(Q2931_IE) + sizeof(ATM_BHLI_IE));
			pBhliIe = (ATM_BHLI_IE UNALIGNED *)pDstIe->IE;

			pBhliIe->HighLayerInfoType = pRemoteAddr->satm_bhli.HighLayerInfoType;
			pBhliIe->HighLayerInfoLength = pRemoteAddr->satm_bhli.HighLayerInfoLength;
			ATMSP_COPY_MEM(pBhliIe->HighLayerInfo,
						   pRemoteAddr->satm_bhli.HighLayerInfo,
						   8);

			pDstIe = (PQ2931_IE)((PUCHAR)pDstIe + pDstIe->IELength);
			pAtmCallParameters->InfoElementCount++;
		}

		if (IsBlliPresent)
		{
			ATM_BLLI_IE UNALIGNED *	pBlliIe;

			pDstIe->IEType = IE_BLLI;
			pDstIe->IELength = ROUND_UP(sizeof(Q2931_IE) + sizeof(ATM_BLLI_IE));

			pBlliIe = (ATM_BLLI_IE UNALIGNED *)pDstIe->IE;

			pBlliIe->Layer2Protocol = pRemoteAddr->satm_blli.Layer2Protocol;
			pBlliIe->Layer2Mode = pBlliIe->Layer2WindowSize = 0;
			pBlliIe->Layer2UserSpecifiedProtocol = pRemoteAddr->satm_blli.Layer2UserSpecifiedProtocol;
			pBlliIe->Layer3Protocol = pRemoteAddr->satm_blli.Layer3Protocol;
			pBlliIe->Layer3Mode = 0;
			pBlliIe->Layer3DefaultPacketSize = 0;
			pBlliIe->Layer3PacketWindowSize = 0;
			pBlliIe->Layer3UserSpecifiedProtocol = pRemoteAddr->satm_blli.Layer3UserSpecifiedProtocol;
			pBlliIe->Layer3IPI = pRemoteAddr->satm_blli.Layer3IPI;
			ATMSP_COPY_MEM(pBlliIe->SnapId, pRemoteAddr->satm_blli.SnapId, 5);

			pDstIe = (PQ2931_IE)((PUCHAR)pDstIe + pDstIe->IELength);
			pAtmCallParameters->InfoElementCount++;

			RWANDEBUGP(DL_INFO, DC_CONNECT,
						("AtmSpTdi2NdisOptions: BLLI: Layer2Prot x%x, Layer3Prot x%x\n",
							pBlliIe->Layer2Protocol, pBlliIe->Layer3Protocol));
		}


		//
		//  Copy in the rest of the IEs.
		//
		if (InfoElementCount != 0)
		{
			pAtmCallParameters->InfoElementCount += InfoElementCount;
			ATMSP_COPY_MEM(pDstIe, pIe, TotalIeLength);

			pDstIe = (PQ2931_IE)((PUCHAR)pDstIe + TotalIeLength);
		}

		//
		//  Compute the length of the Call manager specific part.
		//
		pCallMgrParameters->CallMgrSpecific.Length =
						(ULONG)((ULONG_PTR)pDstIe - (ULONG_PTR)pAtmCallParameters);

		//
		//  We are done. Prepare return values.
		//
		*ppCallParameters = pCallParameters;
		if (pRWanAfHandle != NULL)
		{
			*pRWanAfHandle = pAfBlock->RWanAFHandle;
		}

		break;
	}
	while (FALSE);


	return (RWanStatus);
}




RWAN_STATUS
RWanAtmSpUpdateNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpConnContext,
	IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	IN OUT PCO_CALL_PARAMETERS *	ppCallParameters
	)
/*++

Routine Description:

	This entry point is called in order to update NDIS Call parameters
	with values from TDI-style QoS and options. The most common case
	where this is called is when a called user negotiates parameters
	for an incoming call.

	For now, we simply note down the VPI/VCI values for the connection,
	in order to support SIO_GET_ATM_CONNECTION_ID

Arguments:

	AfSpAFContext		- Points to our AF block
	AfSpConnContext		- Points to our Conn block
	CallFlags			- Call direction and other info
	pTdiInfo			- Generic TDI Connection information block
	pTdiQoS				- Points to TDI-style QOS structure
	TdiQoSLength		- Length of the above
	ppCallParameters	- Points to pointer to NDIS Call Parameters to be updated

Return Value:

	RWAN_STATUS_SUCCESS if we successfully updated NDIS parameters.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATMSP_AF_BLOCK					pAfBlock;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATM_MEDIA_PARAMETERS			pAtmMediaParameters;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;
	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;

	ATMSP_ASSERT(pAfBlock != NULL);
	ATMSP_ASSERT(pConnBlock != NULL);
	ATMSP_ASSERT(ppCallParameters != NULL);
	ATMSP_ASSERT(*ppCallParameters != NULL);

	do
	{
		pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
			&((*ppCallParameters)->MediaParameters->MediaSpecific.Parameters[0]);

		pConnBlock->ConnectionId.DeviceNumber = AtmSpAfBlockToDeviceNumber(pAfBlock);
		pConnBlock->ConnectionId.Vpi = pAtmMediaParameters->ConnectionId.Vpi;
		pConnBlock->ConnectionId.Vci = pAtmMediaParameters->ConnectionId.Vci;

		RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
			("AtmSP: UpdateNdis: VPI %d, VCI %d\n",
				pConnBlock->ConnectionId.Vpi,
				pConnBlock->ConnectionId.Vci));

		break;
	}
	while (FALSE);
		
	return (RWanStatus);
}




VOID
RWanAtmSpReturnNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	)
/*++

Routine Description:

	This entry point is called when core Null Transport is done with
	an NDIS options structure we'd given it via RWanAtmSpTdi2NdisOptions.
	We simply free the memory used for the structure.

Arguments:

	AfSpAFContext		- Points to our AF block
	pCallParameters		- Points to NDIS options

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(AfSpAFContext);

	ATMSP_FREE_MEM(pCallParameters);
}




RWAN_STATUS
RWanAtmSpNdis2TdiOptions(
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						CallFlags,
    IN	PCO_CALL_PARAMETERS			pCallParameters,
    OUT	PTDI_CONNECTION_INFORMATION *ppTdiInfo,
    OUT	PVOID *						ppTdiQoS,
    OUT	PULONG 						pTdiQoSLength,
    OUT	RWAN_HANDLE *				pAfSpTdiOptionsContext
    )
/*++

Routine Description:

	Convert NDIS Call parameters to TDI options and QoS. We allocate space
	for the latter, fill them and return them.

Arguments:

	AfSpAFContext		- Points to our AF block
	CallFlags			- Call direction and other flags
	pCallParameters		- Pointer to NDIS Call Parameters
	ppTdiInfo			- Place to return pointer to allocated TDI Connection info
	ppTdiQoS			- Place to return pointer to allocated TDI QoS structure
	pTdiQoSLength		- Place to return length of the above
	pAfSpTdiOptionsContext - Place to put our context for this allocated structure.

Return Value:

	RWAN_STATUS_SUCCESS if we successfully converted NDIS to TDI parameters,
	RWAN_STATUS_XXX error otherwise.

--*/
{
	Q2931_CALLMGR_PARAMETERS UNALIGNED *	pAtmCallParameters;
	CO_CALL_MANAGER_PARAMETERS UNALIGNED *	pCallMgrParameters;
	Q2931_IE UNALIGNED *			pIe;
	ATM_BLLI_IE UNALIGNED *			pBlli;
	ATM_BHLI_IE UNALIGNED *			pBhli;
	AAL_PARAMETERS_IE UNALIGNED *	pAalIe;
	AAL5_PARAMETERS UNALIGNED *		pAal5Params;
	ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *pBbcIe;
	ULONG							TotalLength;
	ULONG							TotalIeLength;
	ULONG							i;

	PATMSP_AF_BLOCK					pAfBlock;
	PTDI_CONNECTION_INFORMATION		pTdiInfo;
	PTRANSPORT_ADDRESS 				pTransportAddress;
	PTA_ADDRESS 					pAddress;
	ATMSP_SOCKADDR_ATM UNALIGNED *	pSockAddrAtm;
	ATM_ADDRESS UNALIGNED *			pAtmAddress;
	PVOID							pTdiQoS;
	ATMSP_QOS UNALIGNED *			pQoS;
	RWAN_STATUS						RWanStatus;
    BOOLEAN							IsOutgoingCall;


	pBlli = NULL;
	pBhli = NULL;
	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;

	IsOutgoingCall = ((CallFlags & RWAN_CALLF_CALL_DIRECTION_MASK) == RWAN_CALLF_OUTGOING_CALL);

	pCallMgrParameters = pCallParameters->CallMgrParameters;
	pAtmCallParameters = (PQ2931_CALLMGR_PARAMETERS)
								&(pCallMgrParameters->CallMgrSpecific.Parameters[0]);

	//
	//  Compute space required:
	//  1. TDI Connection Information
	//  2. Remote address
	//  3. Generic QoS
	//  4. Provider-specific buffer containing IEs
	//
	TotalLength = sizeof(TDI_CONNECTION_INFORMATION)
				  + TA_HEADER_LENGTH + TA_ATM_ADDRESS_LENGTH
				  + sizeof(ATMSP_QOS)
					;

	//
	//  Add space for IE list, and note down positions of BHLI and BLLI
	//  info elements - we need these for the SOCKADDR_ATM.
	//
	pIe = (PQ2931_IE)&(pAtmCallParameters->InfoElements[0]);

	TotalIeLength = 0;
	for (i = 0; i < pAtmCallParameters->InfoElementCount; i++)
	{
		TotalIeLength += pIe->IELength;

		switch (pIe->IEType)
		{
			case IE_BLLI:
				if (pBlli == NULL)
				{
					pBlli = (PATM_BLLI_IE) &(pIe->IE[0]);
				}
				break;

			case IE_BHLI:
				if (pBhli == NULL)
				{
					pBhli = (PATM_BHLI_IE) &(pIe->IE[0]);
				}
				break;

			case IE_AALParameters:
				pAalIe = (AAL_PARAMETERS_IE UNALIGNED *)&pIe->IE[0];

				switch (pAalIe->AALType)
				{
					case AAL_TYPE_AAL5:
						pAalIe->AALType = ATMSP_AALTYPE_5;
						pAal5Params = &pAalIe->AALSpecificParameters.AAL5Parameters;
						if (pAal5Params->ForwardMaxCPCSSDUSize > pAfBlock->MaxPacketSize)
						{
							pAal5Params->ForwardMaxCPCSSDUSize = pAfBlock->MaxPacketSize;
						}
						if (pAal5Params->BackwardMaxCPCSSDUSize > pAfBlock->MaxPacketSize)
						{
							pAal5Params->BackwardMaxCPCSSDUSize = pAfBlock->MaxPacketSize;
						}
						break;
					case AAL_TYPE_AAL0:
						pAalIe->AALType = ATMSP_AALTYPE_USER;
						break;
					default:
						ATMSP_ASSERT(FALSE);
						break;
				}
				break;

			case IE_BroadbandBearerCapability:

				pBbcIe = (ATM_BROADBAND_BEARER_CAPABILITY_IE UNALIGNED *)&pIe->IE[0];

				switch (pBbcIe->BearerClass)
				{
					case BCOB_A:
						pBbcIe->BearerClass = ATMSP_BCOB_A;
						break;
					case BCOB_C:
						pBbcIe->BearerClass = ATMSP_BCOB_C;
						break;
					case BCOB_X:
						pBbcIe->BearerClass = ATMSP_BCOB_X;
						break;
					default:
						break;
				}

				break;

			default:
				break;

		}

		pIe = (PQ2931_IE)((PUCHAR)pIe + pIe->IELength);
	}

	TotalLength += TotalIeLength;

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		ATMSP_ALLOC_MEM(pTdiInfo, TDI_CONNECTION_INFORMATION, TotalLength);

		if (pTdiInfo == NULL)
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pTdiInfo->UserDataLength = 0;
		pTdiInfo->UserData = NULL;
		pTdiInfo->OptionsLength = 0;
		pTdiInfo->Options = 0;
		pTdiInfo->RemoteAddressLength = TA_HEADER_LENGTH + TA_ATM_ADDRESS_LENGTH;

		pTdiInfo->RemoteAddress =
				(PVOID) ((PUCHAR)pTdiInfo + sizeof(TDI_CONNECTION_INFORMATION));

		pTdiQoS = (PVOID) ((PUCHAR)pTdiInfo->RemoteAddress + pTdiInfo->RemoteAddressLength);

		//
		//  Fill in the Remote address.
		//
		ATMSP_ZERO_MEM(pTdiInfo->RemoteAddress, pTdiInfo->RemoteAddressLength);

		pTransportAddress = (PTRANSPORT_ADDRESS)pTdiInfo->RemoteAddress;
		pTransportAddress->TAAddressCount = 1;

		pAddress = (PTA_ADDRESS)&(pTransportAddress->Address[0]);

		pAddress->AddressLength = TA_ATM_ADDRESS_LENGTH; // sizeof(ATMSP_SOCKADDR_ATM);
		pAddress->AddressType = TDI_ADDRESS_TYPE_ATM;

#if 0
		pSockAddrAtm = (ATMSP_SOCKADDR_ATM *)&(pAddress->Address[0]);
#else
		pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pAddress->Address);
#endif
		pAtmAddress = &(pSockAddrAtm->satm_number);
		
		if (IsOutgoingCall)
		{
			*pAtmAddress = pAtmCallParameters->CalledParty;
			pAtmAddress->AddressType =
				((pAtmCallParameters->CalledParty.AddressType == ATM_E164)?
					SOCKATM_E164: SOCKATM_NSAP);
		}
		else
		{
			*pAtmAddress = pAtmCallParameters->CallingParty;
			pAtmAddress->AddressType =
				((pAtmCallParameters->CallingParty.AddressType == ATM_E164)?
					SOCKATM_E164: SOCKATM_NSAP);
		}

		RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
				("AtmSpNdis2TdiOptions: pAddress %x, pSockAddrAtm %x, pAtmAddress %x, pAddress dump:\n",
							pAddress, pSockAddrAtm, pAtmAddress));

		RWANDEBUGPDUMP(DL_VERY_LOUD, DC_CONNECT, (PUCHAR)pAddress, sizeof(TA_ADDRESS) + sizeof(*pSockAddrAtm));

		RWANDEBUGPATMADDR(DL_LOUD, DC_CONNECT,
				"AtmSpNdis2TdiOptions: remote addr: ", pAtmAddress);

		//
		//  Fill in BHLI and BLLI elements.
		//
		if (pBhli == NULL)
		{
			pSockAddrAtm->satm_bhli.HighLayerInfoType = SAP_FIELD_ABSENT;
		}
		else
		{
			pSockAddrAtm->satm_bhli.HighLayerInfoType = pBhli->HighLayerInfoType;
			pSockAddrAtm->satm_bhli.HighLayerInfoLength = pBhli->HighLayerInfoLength;
			ATMSP_COPY_MEM(pSockAddrAtm->satm_bhli.HighLayerInfo,
						   pBhli->HighLayerInfo,
						   8);
		}

		if (pBlli == NULL)
		{
			pSockAddrAtm->satm_blli.Layer2Protocol = SAP_FIELD_ABSENT;
			pSockAddrAtm->satm_blli.Layer3Protocol = SAP_FIELD_ABSENT;
		}
		else
		{
			pSockAddrAtm->satm_blli.Layer2Protocol = pBlli->Layer2Protocol;
			pSockAddrAtm->satm_blli.Layer2UserSpecifiedProtocol = pBlli->Layer2UserSpecifiedProtocol;
			pSockAddrAtm->satm_blli.Layer3Protocol = pBlli->Layer3Protocol;
			pSockAddrAtm->satm_blli.Layer3UserSpecifiedProtocol = pBlli->Layer3UserSpecifiedProtocol;
			pSockAddrAtm->satm_blli.Layer3IPI = pBlli->Layer3IPI;
			ATMSP_COPY_MEM(pSockAddrAtm->satm_blli.SnapId,
						   pBlli->SnapId,
						   5);
		}

		//
		//  Fill in generic QoS.
		//
		pQoS = (ATMSP_QOS *)pTdiQoS;

		if (IsOutgoingCall)
		{
			pQoS->SendingFlowSpec = pCallMgrParameters->Transmit;
			pQoS->ReceivingFlowSpec = pCallMgrParameters->Receive;
		}
		else
		{
			pQoS->SendingFlowSpec = pCallMgrParameters->Transmit;
			pQoS->ReceivingFlowSpec = pCallMgrParameters->Receive;
		}

		//
		//  Fill in the provider-specific part with other Info Elements.
		//
		pQoS->ProviderSpecific.buf = (CHAR *)((PUCHAR)pQoS + sizeof(ATMSP_QOS));
		pQoS->ProviderSpecific.len = TotalIeLength;

		ATMSP_COPY_MEM(pQoS->ProviderSpecific.buf, &(pAtmCallParameters->InfoElements[0]), TotalIeLength);

		//
		//  All done. Fill in return values.
		//
		*ppTdiInfo = pTdiInfo;
		*ppTdiQoS = pTdiQoS;
		*pTdiQoSLength = sizeof(ATMSP_QOS) + TotalIeLength;
		*pAfSpTdiOptionsContext = pTdiInfo;

		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("pCallMgrParams %x, TotalIeLength %d\n", pCallMgrParameters, TotalIeLength));
		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("Transmit: SvcType %d, MaxSdu %d, Peak %d, TokenRt %d\n",
				pQoS->SendingFlowSpec.ServiceType,
				pQoS->SendingFlowSpec.MaxSduSize,
				pQoS->SendingFlowSpec.PeakBandwidth,
				pQoS->SendingFlowSpec.TokenRate));
		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("Receive: SvcType %d, MaxSdu %d, Peak %d, TokenRt %d\n",
				pQoS->ReceivingFlowSpec.ServiceType,
				pQoS->ReceivingFlowSpec.MaxSduSize,
				pQoS->ReceivingFlowSpec.PeakBandwidth,
				pQoS->ReceivingFlowSpec.TokenRate));

		break;
	}
	while (FALSE);

	return (RWanStatus);
}




RWAN_STATUS
RWanAtmSpUpdateTdiOptions(
    IN	RWAN_HANDLE						AfSpAFContext,
    IN	RWAN_HANDLE						AfSpConnContext,
    IN	ULONG							CallFlags,
    IN	PCO_CALL_PARAMETERS				pCallParameters,
    IN OUT	PTDI_CONNECTION_INFORMATION *	ppTdiInfo,
    IN OUT	PUCHAR						pTdiQoS,
    IN OUT	PULONG						pTdiQoSLength
    )
/*++

Routine Description:

	Entry point called to update TDI call parameters from NDIS parameters.
	This is typically on completion of an outgoing call.

	Right now, all we do is save the VPI/VCI for the connection to support
	SIO_GET_ATM_CONNECTION_ID.

Arguments:

	AfSpAFContext		- Points to our AF block
	AfSpConnContext		- Points to our CONN block
	CallFlags			- Call direction and other info
	pCallParameters		- Points to NDIS style Call parameters
	ppTdiInfo			- Points to pointer to generic TDI Connection Information
	pTdiQoS				- Points to generic TDI QOS structure
	pTdiQoSLength		- length of the above

Return Value:

	RWAN_STATUS_SUCCESS if the update was successful, RWAN_STATUS_XXX
	error code otherwise.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATMSP_AF_BLOCK					pAfBlock;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATM_MEDIA_PARAMETERS			pAtmMediaParameters;
	ATMSP_QOS *						pQoS;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAfBlock = (PATMSP_AF_BLOCK)AfSpAFContext;
	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;

	ATMSP_ASSERT(pAfBlock != NULL);
	ATMSP_ASSERT(pConnBlock != NULL);
	ATMSP_ASSERT(pCallParameters != NULL);

	do
	{
		if (pCallParameters->MediaParameters)
		{
			pAtmMediaParameters = (PATM_MEDIA_PARAMETERS)
				&(pCallParameters->MediaParameters->MediaSpecific.Parameters[0]);

			pConnBlock->ConnectionId.DeviceNumber = AtmSpAfBlockToDeviceNumber(pAfBlock);
			pConnBlock->ConnectionId.Vpi = pAtmMediaParameters->ConnectionId.Vpi;
			pConnBlock->ConnectionId.Vci = pAtmMediaParameters->ConnectionId.Vci;

			RWANDEBUGP(DL_VERY_LOUD, DC_CONNECT,
				("AtmSP: UpdateTdi: VPI %d, VCI %d\n",
					pConnBlock->ConnectionId.Vpi,
					pConnBlock->ConnectionId.Vci));
		}

		if (pTdiQoS && (*pTdiQoSLength >= sizeof(ATMSP_QOS)))
		{
			pQoS = (PATMSP_QOS)pTdiQoS;
			pQoS->SendingFlowSpec = pCallParameters->CallMgrParameters->Transmit;
			pQoS->ReceivingFlowSpec = pCallParameters->CallMgrParameters->Receive;
			pQoS->ProviderSpecific.len = 0;	// for now
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}




VOID
RWanAtmSpReturnTdiOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpTdiOptionsContext
	)
/*++

Routine Description:

	This entry point is called when core Null Transport is done with
	a TDI QOS structure we'd given it via RWanAtmSpNdis2TdiOptions.
	We simply free the memory used for the structure.

Arguments:

	AfSpAFContext		- Points to our AF block
	AfSpTdiOptionsContext - Points to the structure we had allocated

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(AfSpAFContext);

	ATMSP_FREE_MEM(AfSpTdiOptionsContext);
}



TA_ADDRESS *
RWanAtmSpGetValidTdiAddress(
    IN	RWAN_HANDLE								AfSpContext,
    IN	TRANSPORT_ADDRESS UNALIGNED *			pAddressList,
    IN	ULONG									AddrListLength
    )
/*++

Routine Description:

	Go through the list of transport addresses given, and return the
	first valid address found.

Arguments:


Return Value:

	Pointer to the first valid address if found, else NULL.

--*/
{
	TA_ADDRESS *	        pTransportAddress;
	INT						i;
	BOOLEAN					Found;
	ULONG_PTR				EndOfAddrList;

	Found = FALSE;
	EndOfAddrList = (ULONG_PTR)pAddressList + AddrListLength;

	RWANDEBUGP(DL_LOUD, DC_WILDCARD,
		("AtmSpGetValidAddr: pAddrList x%x, Length %d\n",
					pAddressList, AddrListLength));
	
	do
	{
		if (AddrListLength < sizeof(*pAddressList))
		{
			break;
		}

		pTransportAddress = (TA_ADDRESS *) pAddressList->Address;

		for (i = 0; i < pAddressList->TAAddressCount; i++)
		{
			ULONG_PTR	EndOfAddress;

			//
			//  Check that we aren't falling off the end of the supplied
			//  buffer.
			//
			if ((ULONG_PTR)pTransportAddress < (ULONG_PTR)pAddressList ||
				(ULONG_PTR)pTransportAddress >= EndOfAddrList)
			{
				break;
			}

			EndOfAddress = (ULONG_PTR)pTransportAddress +
											sizeof(TA_ADDRESS) - 1 +
											sizeof(ATMSP_SOCKADDR_ATM);
			if (EndOfAddress < (ULONG_PTR)pAddressList ||
				EndOfAddress >= EndOfAddrList)
			{
				RWANDEBUGP(DL_ERROR, DC_WILDCARD,
							("AtmSpGetValidAddr: EndOfAddr x%x, EndOfAddrList x%x\n",
									EndOfAddress, EndOfAddrList));
				break;
			}

			if (pTransportAddress->AddressType == TDI_ADDRESS_TYPE_ATM)
			{
				if (pTransportAddress->AddressLength >= sizeof(ATMSP_SOCKADDR_ATM))
				{
					Found = TRUE;
					break;
				}
			}

			pTransportAddress = (TA_ADDRESS *)
									((PUCHAR)pTransportAddress + 
										sizeof(TA_ADDRESS) - 1 +
										pTransportAddress->AddressLength);
		}
	}
	while (FALSE);


	if (!Found)
	{
		pTransportAddress = NULL;
	}

	RWANDEBUGP(DL_LOUD, DC_WILDCARD,
		("AtmSpGetValidAddr returning x%x\n", pTransportAddress));

	return (pTransportAddress);
}




BOOLEAN
RWanAtmSpIsNullAddress(
    IN	RWAN_HANDLE					AfSpContext,
    IN	TA_ADDRESS *		        pTransportAddress
    )
/*++

Routine Description:

	Check if the given transport address contains a NULL ATM address.
	A NULL ATM address is one that cannot be used in an NDIS SAP.

Arguments:

	AfSpContext			- Points to our Global context
	pTransportAddress	- Points to a TDI transport address

Return Value:

	TRUE if the given address is a NULL ATM address, FALSE otherwise.

--*/
{
	ATMSP_SOCKADDR_ATM UNALIGNED *	pSockAddrAtm;
	ATM_ADDRESS UNALIGNED *			pAtmAddress;
	BOOLEAN							IsNullAddress;

	UNREFERENCED_PARAMETER(AfSpContext);

	ATMSP_ASSERT(pTransportAddress->AddressLength >= sizeof(ATMSP_SOCKADDR_ATM));

	pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pTransportAddress->Address);

	pAtmAddress = &pSockAddrAtm->satm_number;

	return (pAtmAddress->AddressType == SAP_FIELD_ABSENT);
}




RWAN_STATUS
RWanAtmSpTdi2NdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	USHORT						TdiAddressType,
    IN	USHORT						TdiAddressLength,
    IN	PVOID						pTdiAddress,
    OUT	PCO_SAP *					ppCoSap
    )
/*++

Routine Description:

	Convert an ATM SAP in TDI format to NDIS format.

Arguments:

	AfSpContext			- Points to our Global context
	TdiAddressType		- Should be TDI_ADDRESS_TYPE_ATM
	TdiAddressLength	- Should be enough to hold SOCKADDR_ATM
	pTdiAddress			- Points to TDI address.
	ppCoSap				- Place to return pointer to allocated CO_SAP structure.

Return Value:

	RWAN_STATUS_SUCCESS if an NDIS ATM SAP was filled in successfully,
	RWAN_STATUS_XXX error code otherwise.

--*/
{
	RWAN_STATUS				RWanStatus;
	PCO_SAP					pCoSap;
	PATM_SAP				pAtmSap;
	ATMSP_SOCKADDR_ATM UNALIGNED *pSockAddrAtm;
	ATM_ADDRESS UNALIGNED *	pTdiAtmAddress;
	ULONG					SapSize;

	UNREFERENCED_PARAMETER(AfSpContext);

	ATMSP_ASSERT(TdiAddressType == TDI_ADDRESS_TYPE_ATM);
	ATMSP_ASSERT(TdiAddressLength >= sizeof(ATMSP_SOCKADDR_ATM));

	pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pTdiAddress);
	pTdiAtmAddress = &(pSockAddrAtm->satm_number);

	RWANDEBUGPATMADDR(DL_LOUD, DC_CONNECT,
				"AtmSpTdi2NdisSap: remote addr: ", pTdiAtmAddress);

	SapSize = sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);

	ATMSP_ALLOC_MEM(pCoSap, CO_SAP, sizeof(CO_SAP) + sizeof(ATM_SAP) + sizeof(ATM_ADDRESS));

	if (pCoSap != NULL)
	{
		ATMSP_ZERO_MEM(pCoSap, SapSize);

		pCoSap->SapType = SAP_TYPE_NSAP;

		pCoSap->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
		pAtmSap = (PATM_SAP)&(pCoSap->Sap[0]);
		
		//
		//  Copy in the BLLI part. We can't use a simple mem copy because
		//  the Winsock 2 definition of BLLI in sockaddr_atm is different
		//  from the complete BLLI IE.
		//
		pAtmSap->Blli.Layer2Protocol = pSockAddrAtm->satm_blli.Layer2Protocol;
		pAtmSap->Blli.Layer2UserSpecifiedProtocol = pSockAddrAtm->satm_blli.Layer2UserSpecifiedProtocol;
		pAtmSap->Blli.Layer3Protocol = pSockAddrAtm->satm_blli.Layer3Protocol;
		pAtmSap->Blli.Layer3UserSpecifiedProtocol = pSockAddrAtm->satm_blli.Layer3UserSpecifiedProtocol;
		pAtmSap->Blli.Layer3IPI = pSockAddrAtm->satm_blli.Layer3IPI;
		ATMSP_COPY_MEM(pAtmSap->Blli.SnapId,
					   pSockAddrAtm->satm_blli.SnapId,
					   5);

		//
		//  Copy in the BHLI part.
		//
		pAtmSap->Bhli.HighLayerInfoType = pSockAddrAtm->satm_bhli.HighLayerInfoType;
		pAtmSap->Bhli.HighLayerInfoLength = pSockAddrAtm->satm_bhli.HighLayerInfoLength;
		ATMSP_COPY_MEM(pAtmSap->Bhli.HighLayerInfo,
					   pSockAddrAtm->satm_bhli.HighLayerInfo,
					   8);

		pAtmSap->NumberOfAddresses = 1;
		ATMSP_COPY_MEM(pAtmSap->Addresses, pTdiAtmAddress, sizeof(ATM_ADDRESS));

		//
		//  Convert the Address type from Winsock 2 definition to NDIS definitions
		//
		{
			ATM_ADDRESS UNALIGNED *	pNdisAtmAddress;

			pNdisAtmAddress = (ATM_ADDRESS UNALIGNED *)pAtmSap->Addresses;

			switch (pTdiAtmAddress->AddressType)
			{
				case SOCKATM_E164:
					pNdisAtmAddress->AddressType = ATM_E164;
					break;
				
				case SOCKATM_NSAP:
					pNdisAtmAddress->AddressType = ATM_NSAP;
					break;
				
				default:
					//
					// Possibly SAP_FIELD_XXX; leave it as it is.
					//
					break;
			}
		}

		RWanStatus = RWAN_STATUS_SUCCESS;
	}
	else
	{
		RWanStatus = RWAN_STATUS_RESOURCES;
	}

	*ppCoSap = pCoSap;

	return (RWanStatus);
}




VOID
RWanAtmSpReturnNdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PCO_SAP						pCoSap
    )
/*++

Routine Description:

	This entry point is called to return an NDIS SAP structure we'd
	allocated in RWanAtmSpTdi2NdisSap

Arguments:

	AfSpContext			- Points to our Global context
	pCoSap				- Points to CO_SAP structure to be freed.

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(AfSpContext);
	ATMSP_FREE_MEM(pCoSap);

	return;
}




VOID
RWanAtmSpDeregNdisAFComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    )
/*++

Routine Description:

	Entry point to complete a previous call we had made to
	RWanAfSpDeregisterNdisAF that had pended.

Arguments:

	RWanStatus			- Completion status
	AfSpContext			- Points to our Global context

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(RWanStatus);
	UNREFERENCED_PARAMETER(AfSpContext);

	// XXX: Do more
	return;
}




VOID
RWanAtmSpDeregTdiProtoComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    )
/*++

Routine Description:

	Entry point to complete a previous call we had made to
	RWanAfSpDeregisterTdiProtocol that had pended.

Arguments:

	RWanStatus			- Completion status
	AfSpContext			- Points to our Global context

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(RWanStatus);
	UNREFERENCED_PARAMETER(AfSpContext);

	ATMSP_ASSERT(FALSE);	// XXX: Do more
	return;
}



PATMSP_AF_BLOCK
AtmSpDeviceNumberToAfBlock(
	IN	UINT						DeviceNumber
	)
/*++

Routine Description:

	Return the AF Block corresponding to the given Device Number.
	The AF blocks are assumed to be numbered 0, 1, 2 ...

Arguments:

	DeviceNumber	- what we are looking for

Return Value:

	Pointer to AF Block if found, else NULL.

--*/
{
	PATMSP_AF_BLOCK		pAfBlock;
	PLIST_ENTRY			pAfEntry;

	pAfBlock = NULL;

	for (pAfEntry = pAtmSpGlobal->AfList.Flink;
		 pAfEntry != &(pAtmSpGlobal->AfList);
		 pAfEntry = pAfEntry->Flink)
	{
		if (DeviceNumber == 0)
		{
			pAfBlock = CONTAINING_RECORD(pAfEntry, ATMSP_AF_BLOCK, AfBlockLink);
			break;
		}

		DeviceNumber--;
	}

	return (pAfBlock);
}


UINT
AtmSpAfBlockToDeviceNumber(
	IN	PATMSP_AF_BLOCK				pAfBlock
	)
/*++

Routine Description:

	Return the device number corresponding to the specified AF block.

Arguments:

	pAfBlock	- Pointer to AF block

Return Value:

	0-based device number.

--*/
{
	PLIST_ENTRY			pAfEntry;
	PATMSP_AF_BLOCK		pAfBlockEntry;
	UINT				DeviceNumber = (UINT)-1;

	for (pAfEntry = pAtmSpGlobal->AfList.Flink;
		 pAfEntry != &(pAtmSpGlobal->AfList);
		 pAfEntry = pAfEntry->Flink)
	{
		DeviceNumber++;

		pAfBlockEntry = CONTAINING_RECORD(pAfEntry, ATMSP_AF_BLOCK, AfBlockLink);
		if (pAfBlockEntry == pAfBlock)
		{
			break;
		}
	}

	return (DeviceNumber);
}


RWAN_STATUS
AtmSpDoAdapterRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request to the adapter and wait till it completes.

Arguments:

	pAfBlock			- Points to our NDIS AF open context block
	RequestType			- Set/Query
	Oid					- Object under question
	pBuffer				- Pointer to buffer that contains/is to contain info.
	BufferLength		- Length of above

Return Value:

	RWAN_STATUS - RWAN_STATUS_SUCCESS if we succeeded, RWAN_STATUS_FAILURE if not.

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	ATMSP_ALLOC_MEM(pEvent, ATMSP_EVENT, sizeof(ATMSP_EVENT));

	if (pEvent == NULL)
	{
		return (RWAN_STATUS_RESOURCES);
	}

	ATMSP_INIT_EVENT_STRUCT(pEvent);

	RWanStatus = RWanAfSpSendAdapterRequest(
					pAfBlock->RWanAFHandle,
					(RWAN_HANDLE)pEvent,
					RequestType,
					Oid,
					pBuffer,
					BufferLength
					);

	if (RWanStatus == RWAN_STATUS_PENDING)
	{
		RWanStatus = ATMSP_WAIT_ON_EVENT_STRUCT(pEvent);
	}

	ATMSP_FREE_MEM(pEvent);

	return (RWanStatus);
}




RWAN_STATUS
AtmSpDoCallManagerRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	Send an NDIS Request to the Call Manager and wait till it completes.

Arguments:

	pAfBlock			- Points to our NDIS AF open context block
	RequestType			- Set/Query
	Oid					- Object under question
	pBuffer				- Pointer to buffer that contains/is to contain info.
	BufferLength		- Length of above

Return Value:

	RWAN_STATUS - RWAN_STATUS_SUCCESS if we succeeded, RWAN_STATUS_FAILURE if not.

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	ATMSP_ALLOC_MEM(pEvent, ATMSP_EVENT, sizeof(ATMSP_EVENT));

	if (pEvent == NULL)
	{
		return (RWAN_STATUS_RESOURCES);
	}

	ATMSP_INIT_EVENT_STRUCT(pEvent);

	RWanStatus = RWanAfSpSendAfRequest(
					pAfBlock->RWanAFHandle,
					(RWAN_HANDLE)pEvent,
					RequestType,
					Oid,
					pBuffer,
					BufferLength
					);

	if (RWanStatus == RWAN_STATUS_PENDING)
	{
		RWanStatus = ATMSP_WAIT_ON_EVENT_STRUCT(pEvent);
	}

	ATMSP_FREE_MEM(pEvent);

	return (RWanStatus);
}



ATMSP_SOCKADDR_ATM UNALIGNED *
AtmSpGetSockAtmAddress(
	IN	PVOID						pTdiAddressList,
	IN	ULONG						AddrListLength
	)
/*++

Routine Description:

	Look for a valid SOCKADDR_ATM address in the given TDI address list.

Arguments:

	pTdiAddressList		- Points to list of TDI addresses.
	AddrListLength		- Length of list

Return Value:

	Pointer to valid address if it exists, else NULL.

--*/
{
	TA_ADDRESS *		            pTransportAddress;
	ATMSP_SOCKADDR_ATM UNALIGNED *	pSockAddrAtm;

	pTransportAddress = RWanAtmSpGetValidTdiAddress(
								(RWAN_HANDLE)&AtmSpGlobal,
								pTdiAddressList,
								AddrListLength
								);

	if (pTransportAddress != NULL)
	{
		pSockAddrAtm = TA_POINTER_TO_ATM_ADDR_POINTER(pTransportAddress->Address);
	}
	else
	{
		pSockAddrAtm = NULL;
	}

	return (pSockAddrAtm);
}




VOID
RWanAtmSpAdapterRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	This entry point is called to signify completion of a previous
	NDIS request we'd sent to the miniport by calling RWanAfSpSendAdapterRequest.

Arguments:

	Status				- Status of the query
	AfSpAFContext		- Points to our NDIS AF open context block
	AfSpReqContext		- Points to Event structure
	RequestType			- Query/Set
	Oid					- Object that we were querying/setting
	pBuffer				- Pointer to object value
	BufferLength		- Length of the above


Return Value:

	None

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	pEvent = (PATMSP_EVENT) AfSpReqContext;

	RWanStatus = ((Status == NDIS_STATUS_SUCCESS)? RWAN_STATUS_SUCCESS: RWAN_STATUS_FAILURE);

	ATMSP_SIGNAL_EVENT_STRUCT(pEvent, RWanStatus);

	return;
}




VOID
RWanAtmSpAfRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    )
/*++

Routine Description:

	This entry point is called to signify completion of a previous
	NDIS request we'd sent to the Call Mgr by calling RWanAfSpSendAfRequest.

Arguments:

	Status				- Status of the query
	AfSpAFContext		- Points to our NDIS AF open context block
	AfSpReqContext		- Points to Event structure
	RequestType			- Query/Set
	Oid					- Object that we were querying/setting
	pBuffer				- Pointer to object value
	BufferLength		- Length of the above


Return Value:

	None

--*/
{
	PATMSP_EVENT		pEvent;
	RWAN_STATUS			RWanStatus;

	pEvent = (PATMSP_EVENT) AfSpReqContext;

	RWanStatus = ((Status == NDIS_STATUS_SUCCESS)? RWAN_STATUS_SUCCESS: RWAN_STATUS_FAILURE);

	ATMSP_SIGNAL_EVENT_STRUCT(pEvent, RWanStatus);

	return;
}



VOID
RWanAtmSpDeregTdiProtocolComplete(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpTdiProtocolContext
	)
/*++

Routine Description:

	Completion of our pended call to RWanAfSpDeregisterTdiProtocol.
	Not expected because we don't call this.

Arguments:

	RWanStatus		- Final status of deregistering the TDI protocol.
	AfSpTdiProtocolContext - Points to our global struct.

Return Value:

	None

--*/
{
	ATMSP_ASSERT(FALSE);

	return;
}




VOID
AtmSpPrepareDefaultQoS(
    IN	PATMSP_AF_BLOCK				pAfBlock
)
/*++

Routine Description:

	Prepare the default QOS structure to be used for outgoing calls
	on this AF.

Arguments:

	pAfBlock			- Points to our NDIS AF open context block

Return Value:

	None

--*/
{
	ATMSP_QOS *		pQoS;
	FLOWSPEC *		pSendFlowSpec;
	FLOWSPEC *		pRecvFlowSpec;

	pQoS = &pAfBlock->DefaultQoS;

	ATMSP_ZERO_MEM(pQoS, sizeof(ATMSP_QOS));

	pSendFlowSpec = &pQoS->SendingFlowSpec;
	pRecvFlowSpec = &pQoS->ReceivingFlowSpec;
	
	pRecvFlowSpec->ServiceType =
	pSendFlowSpec->ServiceType = SERVICETYPE_BESTEFFORT;

	//
	//  The line rates are in units of 100s of bits/second.
	//  Convert to bytes/second.
	//
	pRecvFlowSpec->TokenRate = (pAfBlock->LineRate.Inbound * 100) / 8;
	pSendFlowSpec->TokenRate = (pAfBlock->LineRate.Outbound * 100) / 8;

	pRecvFlowSpec->PeakBandwidth = pRecvFlowSpec->TokenRate;
	pSendFlowSpec->PeakBandwidth = pSendFlowSpec->TokenRate;

	pRecvFlowSpec->MaxSduSize =
	pSendFlowSpec->MaxSduSize = pAfBlock->MaxPacketSize;

	pAfBlock->DefaultQoSLength = sizeof(ATMSP_QOS);
	return;
}


RWAN_STATUS
RWanAtmSpQueryGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    IN	PVOID						pOutputBuffer,
    IN OUT	PULONG					pOutputBufferLength
    )
/*++

Routine Description:

	Process a media-specific IOCTL to query information from the helper DLL.

Arguments:

	AfSpContext			- Points to our Global context
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above
	pOutputBuffer		- Points to buffer for output
	pOutputBufferLength	- On entry, contains size of output buffer. On return,
						  we fill this with the actual bytes returned.

Return Value:

	RWAN_STATUS_SUCCESS if we processed the IOCTL successfully
	RWAN_STATUS_XXX to indicate any failure.

--*/
{
	PATM_QUERY_INFORMATION_EX		pQueryInfo;
	RWAN_STATUS						RWanStatus;
	ULONG							Info;
	PUCHAR							pSrcBuffer = (PUCHAR)&Info;
	ULONG							BufferLength;
	PATMSP_AF_BLOCK					pAfBlock;
	UINT							DeviceNumber;
	PCO_ADDRESS_LIST				pAddrList = NULL;

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("AtmSpQueryInfo: InBuf x%x/%d, OutBuf x%x/%d\n",
					pInputBuffer,
					InputBufferLength,
					pOutputBuffer,
					*pOutputBufferLength));

	RWanStatus = RWAN_STATUS_SUCCESS;

	do
	{
		//
		//  See if the input buffer is big enough.
		//
		if (InputBufferLength < sizeof(ATM_QUERY_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}

		pQueryInfo = (PATM_QUERY_INFORMATION_EX)pInputBuffer;

		switch (pQueryInfo->ObjectId)
		{
			case ATMSP_OID_NUMBER_OF_DEVICES:

				BufferLength = sizeof(ULONG);
				Info = pAtmSpGlobal->AfListSize;
				break;
			
			case ATMSP_OID_ATM_ADDRESS:

				//
				//  Get the device number being queried.
				//
				if (pQueryInfo->ContextLength < sizeof(UINT))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				DeviceNumber = *((PUINT)&pQueryInfo->Context[0]);

				//
				//  Get the AF block for the device # being queried.
				//
				pAfBlock = AtmSpDeviceNumberToAfBlock(DeviceNumber);

				if (pAfBlock == NULL)
				{
					RWanStatus = RWAN_STATUS_BAD_ADDRESS;
					break;
				}

				ATMSP_ALLOC_MEM(pAddrList,
								CO_ADDRESS_LIST,
								sizeof(CO_ADDRESS_LIST)+sizeof(CO_ADDRESS)+sizeof(ATM_ADDRESS));
				if (pAddrList == NULL)
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				RWanStatus = AtmSpDoCallManagerRequest(
								pAfBlock,
								NdisRequestQueryInformation,
								OID_CO_GET_ADDRESSES,
								pAddrList,
								sizeof(CO_ADDRESS_LIST)+sizeof(CO_ADDRESS)+sizeof(ATM_ADDRESS)
								);
				
				if ((RWanStatus == RWAN_STATUS_SUCCESS) &&
					(pAddrList->NumberOfAddresses > 0))
				{
					ATM_ADDRESS UNALIGNED *	pAtmAddress;

					pSrcBuffer = (PUCHAR)&pAddrList->AddressList.Address[0];

					//
					//  Fix the address type for Winsock2.
					//
					pAtmAddress = (ATM_ADDRESS UNALIGNED *)pSrcBuffer;
					pAtmAddress->AddressType = ((pAtmAddress->AddressType == ATM_E164)?
												SOCKATM_E164: SOCKATM_NSAP);

					BufferLength = sizeof(ATM_ADDRESS);
				}
				else
				{
					if (RWanStatus == RWAN_STATUS_SUCCESS)
					{
						RWanStatus = RWAN_STATUS_FAILURE;
					}
				}

				RWANDEBUGP(DL_LOUD, DC_DISPATCH,
							("AtmSpQueryInfo: GetAddr: Status %x, pSrc %x, BufLen %d\n",
								RWanStatus, pSrcBuffer, BufferLength));
				break;

			default:
				//
				//  Unknown OID
				//
				RWANDEBUGP(DL_ERROR, DC_DISPATCH,
							("AtmSpQueryInfo: Unknown OID x%x\n", pQueryInfo->ObjectId));
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	//
	//  Fill in the output buffer now.
	//
	if (RWanStatus == RWAN_STATUS_SUCCESS)
	{
		if (BufferLength <= *pOutputBufferLength)
		{
			RWANDEBUGP(DL_LOUD, DC_DISPATCH,
						("AtmSpQueryInfo: Copying %d bytes from %x to %x\n",
							BufferLength, pSrcBuffer, pOutputBuffer));
			ATMSP_COPY_MEM(pOutputBuffer, pSrcBuffer, BufferLength);
		}
		else
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
		}
		*pOutputBufferLength = BufferLength;
	}

	if (pAddrList != NULL)
	{
		ATMSP_FREE_MEM(pAddrList);
	}

	RWANDEBUGP(DL_LOUD, DC_DISPATCH,
				("AtmSpQueryInfo: returning x%x\n", RWanStatus));

	return (RWanStatus);
}


RWAN_STATUS
RWanAtmSpSetGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Process a media-specific IOCTL to set information from the helper DLL.

Arguments:

	AfSpContext			- Points to our Global context
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if we processed the IOCTL successfully
	RWAN_STATUS_XXX to indicate any failure.

--*/
{
	RWANDEBUGP(DL_LOUD, DC_CONNECT,
				("AtmSpSetInfo: InBuf x%x/%d\n",
					pInputBuffer,
					InputBufferLength));

	return (RWAN_STATUS_FAILURE);
}


#ifndef NO_CONN_CONTEXT


RWAN_STATUS
RWanAtmSpSetAddrInfo(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    )
/*++

Routine Description:

	Process a media-specific IOCTL to set information on an address object
	from the helper DLL.

Arguments:

	AfSpAddrContext		- Points to our Address Block
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above

Return Value:

	RWAN_STATUS_SUCCESS if we processed the IOCTL successfully
	RWAN_STATUS_XXX to indicate any failure.
--*/
{
	RWAN_STATUS						RWanStatus;
	PATM_SET_INFORMATION_EX			pSetInfo;
	PATMSP_ADDR_BLOCK				pAddrBlock;
	PATMSP_CONNECTION_ID			pConnectionId;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pAddrBlock = (PATMSP_ADDR_BLOCK)AfSpAddrContext;
	ATMSP_ASSERT(pAddrBlock != NULL);

	do
	{
		//
		//  See if the input buffer is big enough.
		//
		if (InputBufferLength < sizeof(ATM_SET_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}


		pSetInfo = (PATM_SET_INFORMATION_EX)pInputBuffer;

		switch (pSetInfo->ObjectId)
		{
			case ATMSP_OID_PVC_ID:

				if (pSetInfo->BufferSize < sizeof(ATMSP_CONNECTION_ID))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				//
				//  Copy in the connection Id.
				//
				try
				{
					pConnectionId = (PATMSP_CONNECTION_ID)&(pSetInfo->Buffer[0]);
					pAddrBlock->ConnectionId = *pConnectionId;
				}
				except (EXCEPTION_EXECUTE_HANDLER)
					{
						RWanStatus = RWAN_STATUS_FAILURE;
					}

				if (RWanStatus != RWAN_STATUS_SUCCESS)
				{
					break;
				}

				//
				//  Mark this address object.
				//
				ATMSP_SET_BIT(pAddrBlock->Flags, ATMSPF_ADDR_PVC_ID_SET);

				RWANDEBUGP(DL_LOUD, DC_BIND,
							("AtmSpSetAddrInfo: Set PVC Id: AddrBlock x%x, Vpi %d, Vci %d\n",
								pAddrBlock,
								pAddrBlock->ConnectionId.Vpi,
								pAddrBlock->ConnectionId.Vci));

				break;
			
			default:
				//
				//  Unknown OID
				//
				RWANDEBUGP(DL_ERROR, DC_DISPATCH,
							("AtmSpSetAddrInfo: Unknown OID x%x\n", pSetInfo->ObjectId));
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);
				
	return (RWanStatus);
}


RWAN_STATUS
RWanAtmSpQueryConnInfo(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT PULONG					pOutputBufferLength
    )
/*++

Routine Description:

	Handle a request to query information for a connection.

Arguments:

	AfSpConnContext		- Points to our Connection Block
	pInputBuffer		- Input information
	InputBufferLength	- Length of the above
	pOutputBuffer		- Place to return information
	pOutputBufferLength	- where we return bytes-written

Return Value:

	RWAN_STATUS_SUCCESS if we processed the query successfully,
	RWAN_STATUS_XXX error code otherwise.

--*/
{
	RWAN_STATUS						RWanStatus;
	PATM_QUERY_INFORMATION_EX		pQueryInfo;
	PATMSP_CONN_BLOCK				pConnBlock;
	PATMSP_CONNECTION_ID			pConnectionId;

	RWanStatus = RWAN_STATUS_SUCCESS;
	pConnBlock = (PATMSP_CONN_BLOCK)AfSpConnContext;
	ATMSP_ASSERT(pConnBlock != NULL);

	do
	{
		//
		//  See if the input buffer is big enough.
		//
		if (InputBufferLength < sizeof(ATM_QUERY_INFORMATION_EX))
		{
			RWanStatus = RWAN_STATUS_RESOURCES;
			break;
		}


		pQueryInfo = (PATM_QUERY_INFORMATION_EX)pInputBuffer;

		switch (pQueryInfo->ObjectId)
		{
			case ATMSP_OID_CONNECTION_ID:

				if (*pOutputBufferLength < sizeof(ATMSP_CONNECTION_ID))
				{
					RWanStatus = RWAN_STATUS_RESOURCES;
					break;
				}

				//
				//  Copy in the connection Id.
				//
				pConnectionId = pOutputBuffer;
				*pConnectionId = pConnBlock->ConnectionId;
				*pOutputBufferLength = sizeof(pConnBlock->ConnectionId);
				break;

			default:
				//
				//  Unknown OID
				//
				RWANDEBUGP(DL_ERROR, DC_DISPATCH,
							("AtmSpQueryConnInfo: Unknown OID x%x\n", pQueryInfo->ObjectId));
				RWanStatus = RWAN_STATUS_BAD_PARAMETER;
				break;
		}

		break;
	}
	while (FALSE);

	return (RWanStatus);
}
#endif // NO_CONN_CONTEXT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\sys\tdiconn.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\core\tdiconn.c

Abstract:

	TDI Entry points and support routines for Connection Objects.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     04-30-97    Created

Notes:

--*/

#include <precomp.h>

#define _FILENUMBER 'NCDT'


//
//  Private macros and definitions for the Connection Table. Copied from TCP.
//
#define RWAN_GET_SLOT_FROM_CONN_ID(_Id)		((_Id) & 0xffffff)

#define RWAN_GET_INSTANCE_FROM_CONN_ID(_Id)	((UCHAR)((_Id) >> 24))

#define RWAN_MAKE_CONN_ID(_Inst, _Slot)		((((RWAN_CONN_ID)(_Inst)) << 24) | ((RWAN_CONN_ID)(_Slot)))

#define RWAN_INVALID_CONN_ID				RWAN_MAKE_CONN_ID(0xff, 0xffffff)

#define CONN_TABLE_GROW_DELTA				16



TDI_STATUS
RWanTdiOpenConnection(
    IN OUT	PTDI_REQUEST			pTdiRequest,
    IN		PVOID					ConnectionHandle
    )
/*++

Routine Description:

	This is the TDI entry point for opening (creating) a Connection Object.
	We allocate a new Connection object and return an index to it in the
	request itself.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	ConnectionHandle- This is how we refer to this connection in up-calls

Return Value:

	TDI_SUCCESS if a connection object was successfully created, TDI_XXX
	failure code otherwise.

--*/
{
	TDI_STATUS						Status;
	PRWAN_TDI_CONNECTION				pConnObject;
	RWAN_CONN_ID						ConnId;

	//
	//  Initialize.
	//
	pConnObject = NULL_PRWAN_TDI_CONNECTION;

	do
	{
		pConnObject = RWanAllocateConnObject();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		//
		//  Prepare a context to be returned. We don't return a pointer
		//  to our Connection object as our context, because, seemingly,
		//  there is a chance that we might get invalid connection
		//  contexts in other TDI requests. So we need a way to validate
		//  a received connection context. This indirection (of using a
		//  Connection Index) helps us do so.
		//
		ConnId = RWanGetConnId(pConnObject);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (ConnId == RWAN_INVALID_CONN_ID)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		RWanReferenceConnObject(pConnObject);	// TdiOpenConnection ref

		pConnObject->ConnectionHandle = ConnectionHandle;

		//
		//  Return our context for this connection object.
		//
		pTdiRequest->Handle.ConnectionContext = (CONNECTION_CONTEXT)UlongToPtr(ConnId);
		Status = TDI_SUCCESS;

		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
			("RWanTdiOpenConnection: pConnObj x%p, Handle x%p, Status x%x\n",
					pConnObject,
					ConnectionHandle,
					Status));

	if (Status != TDI_SUCCESS)
	{
		//
		//  Clean up before returning.
		//
		if (pConnObject != NULL_PRWAN_TDI_CONNECTION)
		{
			RWAN_FREE_MEM(pConnObject);
		}
	}

	return (Status);
}


#if DBG

PVOID
RWanTdiDbgGetConnObject(
	IN	HANDLE						ConnectionContext
	)
/*++

Routine Description:

	DEBUGGING ONLY: Return our internal context for a connection

Arguments:

	ConnectionContext	- TDI context

Return Value:

	Pointer to our Connection structure if found, else NULL.

--*/
{
	PRWAN_TDI_CONNECTION	pConnObject;

	RWAN_ACQUIRE_CONN_TABLE_LOCK();

	pConnObject = RWanGetConnFromId((RWAN_CONN_ID)PtrToUlong(ConnectionContext));

	RWAN_RELEASE_CONN_TABLE_LOCK();

	return ((PVOID)pConnObject);
}

#endif


TDI_STATUS
RWanTdiCloseConnection(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI entry point to close a Connection Object.
	If the connection object is participating in a connection, we
	initiate teardown. If it is associated with an address object, we
	handle disassociation.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_STATUS - this is TDI_PENDING if we started off CloseConnection
	successfully, TDI_SUCCESS if we are done with CloseConnection in here,
	TDI_INVALID_CONNECTION if the connection context is invalid.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_NDIS_VC					pVc;
	TDI_STATUS						Status;
	RWAN_CONN_ID					ConnId;
	PRWAN_CONN_REQUEST				pConnReq;
	NDIS_HANDLE						NdisVcHandle;
	INT								rc;
	BOOLEAN							bIsLockAcquired;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

	Status = TDI_PENDING;
	bIsLockAcquired = FALSE;	// Do we hold the Conn Object locked?

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			RWAN_RELEASE_CONN_TABLE_LOCK();
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		//
		//  Remove this Connection Object from the Conn Table.
		//  This effectively invalidates this ConnId.
		//
		RWanFreeConnId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		RWANDEBUGP(DL_LOUD, DC_DISCON,
				("TdiCloseConnection: pConnObj x%p, State/Flags/Ref x%x/x%x/%d, pAddrObj x%p\n",
					pConnObject,
					pConnObject->State,
					pConnObject->Flags,
					pConnObject->RefCount,
					pConnObject->pAddrObject));

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

#if DBG
		pConnObject->OldState = pConnObject->State;
		pConnObject->OldFlags = pConnObject->Flags;
#endif

		//
		//  Mark this Connection Object as closing, and set Delete
		//  Notification info: this will be called when the Connection
		//  is dereferenced to death.
		//
		RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_CLOSING);

		pConnObject->DeleteNotify.pDeleteRtn = pTdiRequest->RequestNotifyObject;
		pConnObject->DeleteNotify.DeleteContext = pTdiRequest->RequestContext;

		//
		//  Discard any pending operation.
		//
		pConnReq = pConnObject->pConnReq;
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
			pConnObject->pConnReq = NULL;
		}

		//
		//  Remove the TdiOpenConnection reference.
		//
		rc = RWanDereferenceConnObject(pConnObject);	// deref: TdiCloseConn

		if (rc == 0)
		{
			//
			//  The Connection object is gone. CloseConnection completion
			//  would have been called.
			//
			break;
		}

		pAddrObject = pConnObject->pAddrObject;

		//
		//  Force Disassociate Address if associated.
		//
		if (pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{
			//
			//  Add a temp reference to keep this Conn Object alive while we
			//  reacquire locks in the right order.
			//
			RWanReferenceConnObject(pConnObject);	// temp ref: CloseConn

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);
			RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

			//
			//  Remove from list on Address Object.
			//
			RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));

			pConnObject->pAddrObject = NULL_PRWAN_TDI_ADDRESS;

			rc = RWanDereferenceConnObject(pConnObject);	// Force disassoc deref: CloseConn
			RWAN_ASSERT(rc != 0);

			RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

			rc = RWanDereferenceAddressObject(pAddrObject);	// Force Disassoc: CloseConn

			if (rc != 0)
			{
				RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
			}

			//
			//  Reacquire ConnObject lock: we still have the temp reference on it.
			//
			RWAN_ACQUIRE_CONN_LOCK(pConnObject);

			rc = RWanDereferenceConnObject(pConnObject);	// remove temp ref: CloseConn

			if (rc == 0)
			{
				RWAN_ASSERT(Status == TDI_PENDING);
				break;
			}
		}

		bIsLockAcquired = TRUE;

		//
		//  If this is a root connection object, abort the connection.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_ROOT))
		{
			RWANDEBUGP(DL_FATAL, DC_DISCON,
				("TdiCloseConn: found root Conn Obj x%p\n", pConnObject));

			RWanReferenceConnObject(pConnObject);	// temp ref: CloseConn (root)

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWanDoAbortConnection(pConnObject);

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
			rc = RWanDereferenceConnObject(pConnObject); 	// temp ref: CloseConn (root)

			if (rc == 0)
			{
				bIsLockAcquired = FALSE;
			}

			break;
		}

		//
		//  If the connection is active, tear it down.
		//

		switch (pConnObject->State)
		{
			case RWANS_CO_OUT_CALL_INITIATED:
			case RWANS_CO_DISCON_REQUESTED:
			case RWANS_CO_IN_CALL_ACCEPTING:

				//
				//  An NDIS operation is in progress. When it completes,
				//  the flag (CLOSING) we set earlier will cause the
				//  CloseConnection to continue.
				//
				break;

			case RWANS_CO_CONNECTED:

				RWanDoTdiDisconnect(
					pConnObject,
					NULL,		// pTdiRequest
					NULL,		// pTimeout
					0,			// Flags
					NULL,		// pDisconnInfo
					NULL		// pReturnInfo
					);
				//
				//  ConnObject Lock is released within the above.
				//
				bIsLockAcquired = FALSE;
				break;

			case RWANS_CO_DISCON_INDICATED:
			case RWANS_CO_DISCON_HELD:
			case RWANS_CO_ABORTING:

				//
				//  We would have started off an NDIS CloseCall/DropParty
				//  operation.
				//
				break;

			case RWANS_CO_IN_CALL_INDICATED:

				//
				//  Reject the incoming call.
				//
				RWanNdisRejectIncomingCall(pConnObject, NDIS_STATUS_FAILURE);

				//
				//  ConnObject Lock is released within the above.
				//
				bIsLockAcquired = FALSE;

				break;

			case RWANS_CO_CREATED:
			case RWANS_CO_ASSOCIATED:
			case RWANS_CO_LISTENING:
			default:

				//
				//  We should have broken out of the outer do..while
				//  earlier.
				//
				RWANDEBUGP(DL_FATAL, DC_WILDCARD,
					("TdiCloseConn: pConnObj x%p/x%x, bad state %d\n",
							pConnObject, pConnObject->Flags, pConnObject->State));

				RWAN_ASSERT(FALSE);
				break;

		}

		break;
	}
	while (FALSE);

	if (bIsLockAcquired)
	{
		RWAN_RELEASE_CONN_LOCK(pConnObject);
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWANDEBUGP(DL_VERY_LOUD, DC_DISCON,
			("TdiCloseConn: pConnObject x%p, returning x%x\n", pConnObject, Status));

	return (Status);

}



TDI_STATUS
RWanTdiAssociateAddress(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						AddressContext
    )
/*++

Routine Description:

	This is the TDI entry point to associate a connection object
	with an address object. The connection object is identified
	by its context buried in the TDI Request, and AddressContext
	is our context for an address object.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	AddressContext	- Actually a pointer to our TDI Address object.

Return Value:

	TDI_SUCCESS if the association was successful, TDI_ALREADY_ASSOCIATED
	if the connection object is already associated with an address object,
	TDI_INVALID_CONNECTION if the specified connection context is invalid.

--*/
{
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	TDI_STATUS						Status;
	RWAN_STATUS						RWanStatus;

	pAddrObject = (PRWAN_TDI_ADDRESS)AddressContext;
	RWAN_STRUCT_ASSERT(pAddrObject, nta);

	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();


		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		if (pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS)
		{
			Status = TDI_ALREADY_ASSOCIATED;
			break;
		}

		//
		//  Get a context for this associated connection object
		//  from the media-specific module.
		//
		if (pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpAssociateConnection)
		{
			RWanStatus = (*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpAssociateConnection)(
							pAddrObject->AfSpAddrContext,
							(RWAN_HANDLE)pConnObject,
							&(pConnObject->AfSpConnContext));

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				Status = RWanToTdiStatus(RWanStatus);
				break;
			}

			RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_AFSP_CONTEXT_VALID);

			RWANDEBUGP(DL_LOUD, DC_WILDCARD,
				("Associate: AddrObj %p, ConnObj %p, AfSpAddrCont %x, AfSpConnCont %x\n",
						pAddrObject,
						pConnObject,
						pAddrObject->AfSpAddrContext,
						pConnObject->AfSpConnContext));
		}

		//
		//  Acquire locks in the right order.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_ACQUIRE_CONN_LOCK_DPC(pConnObject);

		RWAN_ASSERT(pConnObject->State == RWANS_CO_CREATED);

		pConnObject->State = RWANS_CO_ASSOCIATED;

		//
		//  Attach this Connection Object to this Address Object.
		//
		pConnObject->pAddrObject = pAddrObject;

		RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
							 &(pConnObject->ConnLink));

		RWanReferenceConnObject(pConnObject);	// Associate ref

		//
		//  Check if this is a Leaf connection object.
		//
		if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_PMP_ROOT))
		{
			RWAN_ASSERT(pAddrObject->pRootConnObject != NULL);

			RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_LEAF);
			pConnObject->pRootConnObject = pAddrObject->pRootConnObject;
		}

		RWAN_RELEASE_CONN_LOCK_DPC(pConnObject);

		RWanReferenceAddressObject(pAddrObject);	// New Connection object associated

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		Status = TDI_SUCCESS;
		break;
	}
	while (FALSE);


	RWANDEBUGP(DL_EXTRA_LOUD, DC_CONNECT,
			("RWanTdiAssociate: pAddrObject x%p, ConnId x%x, pConnObj x%p, Status x%x\n",
				pAddrObject, ConnId, pConnObject, Status));

	return (Status);
}




TDI_STATUS
RWanTdiDisassociateAddress(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI entry point for disassociating a connection object
	from the address object it is currently associated with. The connection
	object is identified by its handle buried within the TDI request.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_SUCCESS if successful, TDI_NOT_ASSOCIATED if the connection object
	isn't associated with an address object, TDI_INVALID_CONNECTION if the
	given connection context is invalid, TDI_CONNECTION_ACTIVE if the
	connection is active.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	TDI_STATUS						Status;
	INT								rc;

	ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
	pAddrObject = NULL_PRWAN_TDI_ADDRESS;

	do
	{
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		//
		//  See if the connection is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
		{
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  Tell the media-specific module about this disassociation.
		//  This invalidates the module's context for this connection
		//  object.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_AFSP_CONTEXT_VALID) &&
			pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpDisassociateConnection)
		{
			(*pAddrObject->pProtocol->pAfInfo->AfChars.pAfSpDisassociateConnection)(
							pConnObject->AfSpConnContext);

			RWAN_RESET_BIT(pConnObject->Flags, RWANF_CO_AFSP_CONTEXT_VALID);
		}

		//
		//  Unlink this from the address object.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));

		rc = RWanDereferenceAddressObject(pAddrObject); // Disassoc conn

		if (rc != 0)
		{
			RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		pConnObject->pAddrObject = NULL_PRWAN_TDI_ADDRESS;

		rc = RWanDereferenceConnObject(pConnObject);	// Disassoc deref

		if (rc != 0)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		Status = TDI_SUCCESS;
		break;
	}
	while (FALSE);

	RWANDEBUGP(DL_LOUD, DC_DISCON,
			("RWanTdiDisassociate: pAddrObject x%p, pConnObj x%p, Status x%x\n",
				pAddrObject, pConnObject, Status));

	return (Status);
}




TDI_STATUS
RWanTdiConnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout 		OPTIONAL,
    IN	PTDI_CONNECTION_INFORMATION	pRequestInfo,
    IN	PTDI_CONNECTION_INFORMATION	pReturnInfo
    )
/*++

Routine Description:

	This is the TDI Entry point for setting up a connection.
	The connection object is identified by its handle buried within
	the TDI request.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pTimeout		- Optional connect timeout
	pRequestInfo	- Points to information for making the connection
	pReturnInfo		- Place where we return final connection information

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully fired off
	a Connect Request, TDI_NO_RESOURCES if we failed because of some
	allocation problem, TDI_BAD_ADDR if the destination address isn't
	valid, TDI_INVALID_CONNECTION if the specified Connection Object
	isn't valid, TDI_NOT_ASSOCIATED if the connection object isn't
	associated with an Address Object.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_NDIS_AF_CHARS				pAfChars;
	PRWAN_NDIS_AF_INFO				pAfInfo;
	PRWAN_NDIS_AF					pAf;
	PRWAN_NDIS_VC					pVc;
	PRWAN_CONN_REQUEST				pConnReq;
	TDI_STATUS						Status;
	RWAN_STATUS						RWanStatus;

	ULONG							CallFlags;

	PCO_CALL_PARAMETERS				pCallParameters;
	NDIS_HANDLE						NdisVcHandle;
	NDIS_STATUS						NdisStatus;

	BOOLEAN							bIsLockAcquired;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	//
	//  Initialize
	//
	pConnReq = NULL;
	pCallParameters = NULL;
	bIsLockAcquired = FALSE;
	pVc = NULL;

#if DBG
	pConnObject = NULL;
	pAddrObject = NULL;
#endif

	do
	{
		//
		//  See if the destination address is present.
		//
		if ((pRequestInfo == NULL) ||
			(pRequestInfo->RemoteAddress == NULL))
		{
			Status = TDI_BAD_ADDR;
			break;
		}

		//
		//  Allocate a Connection Request structure to keep track
		//  of this request.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
		pConnReq->pConnInfo = pReturnInfo;

		//
		//  Get the Connection Object.
		//
		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		bIsLockAcquired = TRUE;
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if it is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL_PRWAN_TDI_ADDRESS)
		{
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  Check its state.
		//
		if (pConnObject->State != RWANS_CO_ASSOCIATED)
		{
			Status = TDI_INVALID_STATE;
			break;
		}

		//
		//  Do we have atleast one NDIS AF for this protocol?
		//
		pAfInfo = pAddrObject->pProtocol->pAfInfo;
		if (RWAN_IS_LIST_EMPTY(&(pAfInfo->NdisAfList)))
		{
			Status = TDI_BAD_ADDR;
			break;
		}

		pAfChars = &(pAfInfo->AfChars);

		CallFlags = RWAN_CALLF_OUTGOING_CALL;

		if (RWAN_IS_BIT_SET(pAddrObject->Flags, RWANF_AO_PMP_ROOT))
		{
			CallFlags |= RWAN_CALLF_POINT_TO_MULTIPOINT;

			pConnObject->pRootConnObject = pAddrObject->pRootConnObject;
			if (pAddrObject->pRootConnObject->NdisConnection.pNdisVc == NULL)
			{
				CallFlags |= RWAN_CALLF_PMP_FIRST_LEAF;
				RWANDEBUGP(DL_INFO, DC_CONNECT,
						("TdiConnect PMP: First Leaf: ConnObj %p, RootConn %p, AddrObj %p\n",
								pConnObject,
								pConnObject->pRootConnObject,
								pAddrObject));
			}
			else
			{
				CallFlags |= RWAN_CALLF_PMP_ADDNL_LEAF;
				RWANDEBUGP(DL_INFO, DC_CONNECT,
						("TdiConnect PMP: Subseq Leaf: ConnObj %p, RootConn %p, AddrObj %p, Vc %p\n",
								pConnObject,
								pConnObject->pRootConnObject,
								pAddrObject,
								pConnObject->pRootConnObject->NdisConnection.pNdisVc
						));
			}
		}
		else
		{
			CallFlags |= RWAN_CALLF_POINT_TO_POINT;
		}

		//
		//  We get the AF from the media specific module.
		//
		pAf = NULL;

		//
		//  Validate and convert call parameters. Also get the AF (aka port) on
		//  which the call should be made.
		//
		RWanStatus = (*pAfChars->pAfSpTdi2NdisOptions)(
							pConnObject->AfSpConnContext,
							CallFlags,
							pRequestInfo,
							pRequestInfo->Options,
							pRequestInfo->OptionsLength,
							&pAf,
							&pCallParameters
							);

		if (RWanStatus != RWAN_STATUS_SUCCESS)
		{
			RWANDEBUGP(DL_WARN, DC_CONNECT,
				("TdiConnect: pConnObj x%p, Tdi2NdisOptions ret x%x\n", pConnObject, RWanStatus));

			Status = RWanToTdiStatus(RWanStatus);
			break;
		}

		if (pAf == NULL)
		{
			//
			//  Get at the first NDIS AF block for this TDI protocol.
			//
			pAf = CONTAINING_RECORD(pAfInfo->NdisAfList.Flink, RWAN_NDIS_AF, AfInfoLink);
		}

		RWAN_ASSERT(pAf != NULL);
		RWAN_STRUCT_ASSERT(pAf, naf);

		RWAN_ASSERT(pCallParameters != NULL);

		if (CallFlags & RWAN_CALLF_POINT_TO_MULTIPOINT)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			bIsLockAcquired = FALSE;

			Status = RWanTdiPMPConnect(
							pAfInfo,
							pAddrObject,
							pConnObject,
							pCallParameters,
							CallFlags,
							pConnReq
							);
			break;
		}

		//
		//  Allocate an NDIS VC. To avoid deadlocks, we must relinquish
		//  the Conn Object lock temporarily.
		//
		RWAN_RELEASE_CONN_LOCK(pConnObject);

		pVc = RWanAllocateVc(pAf, TRUE);

		if (pVc == NULL)
		{
			Status = TDI_NO_RESOURCES;
			bIsLockAcquired = FALSE;
			break;
		}

		RWAN_SET_VC_CALL_PARAMS(pVc, pCallParameters);

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		RWAN_SET_BIT(pVc->Flags, RWANF_VC_OUTGOING);

		//
		//  We have completed all "immediate failure" checks.
		//

		//
		//  Link the VC to this Connection Object.
		//
		RWAN_LINK_CONNECTION_TO_VC(pConnObject, pVc);

		RWanReferenceConnObject(pConnObject);	// VC ref

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		//
		//  Save the NDIS Call Parameters
		//
		pVc->pCallParameters = pCallParameters;

		pConnObject->State = RWANS_CO_OUT_CALL_INITIATED;

		RWAN_RELEASE_CONN_LOCK(pConnObject);
		bIsLockAcquired = FALSE;

		//
		//  Move this connection object from the Idle list to the
		//  Active list on the address object.
		//

		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->ActiveConnList),
							 &(pConnObject->ConnLink));

		pAddrObject->pRootConnObject = pConnObject;

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Place the call.
		//
		NdisStatus = NdisClMakeCall(
						NdisVcHandle,
						pCallParameters,
						NULL,			// ProtocolPartyContext
						NULL			// pNdisPartyHandle
						);

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		if (NdisStatus != NDIS_STATUS_PENDING)
		{
			RWanNdisMakeCallComplete(
						NdisStatus,
						(NDIS_HANDLE)pVc,
						NULL,			// NdisPartyHandle
						pCallParameters
						);
		}

		RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);


	if (Status != TDI_PENDING)
	{
		//
		//  Clean up.
		//
		if (bIsLockAcquired)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}
			
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}

		if (pCallParameters != NULL)
		{
			(*pAfChars->pAfSpReturnNdisOptions)(
								pAf->AfSpAFContext,
								pCallParameters
								);
		}

		if (pVc != NULL)
		{
			RWanFreeVc(pVc);
		}
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
		("TdiConnect: pTdiReq x%p, pConnObj x%p, pAddrObj x%p, Status x%x\n",
			pTdiRequest, pConnObject, pAddrObject, Status));

	return (Status);
}


TDI_STATUS
RWanTdiPMPConnect(
	IN	PRWAN_NDIS_AF_INFO			pAfInfo,
	IN	PRWAN_TDI_ADDRESS			pAddrObject,
	IN	PRWAN_TDI_CONNECTION		pConnObject,
	IN	PCO_CALL_PARAMETERS			pCallParameters,
	IN	ULONG						CallFlags,
	IN	PRWAN_CONN_REQUEST			pConnReq
	)
/*++

Routine Description:

	Handle a TDI Connect for a point-to-multipoint call.

Arguments:

	pAfInfo			- Pointer to AF Info structure
	pAddrObject		- Address Object on which this PMP call is made
	pConnObject		- Connection object representing a node of the PMP call
	pCallParameters	- NDIS call parameters
	CallFlags		- Flags indicating type of call
	pConnReq		- Information about the TDI request

Return Value:

	TDI_PENDING if a PMP call was launched successfully, TDI_XXX error code
	otherwise.

--*/
{
	PRWAN_TDI_CONNECTION	pRootConnObject;
	PRWAN_NDIS_AF			pAf;
	PRWAN_NDIS_VC			pVc;
	PRWAN_NDIS_PARTY		pParty;
	NDIS_HANDLE				NdisVcHandle;
	NDIS_STATUS				NdisStatus;
	TDI_STATUS				Status;
	BOOLEAN					bIsFirstLeaf;
#if DBG
	RWAN_IRQL				EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	bIsFirstLeaf = ((CallFlags & RWAN_CALLF_PMP_LEAF_TYPE_MASK) == RWAN_CALLF_PMP_FIRST_LEAF);
	Status = TDI_PENDING;
	pParty = NULL;
	pVc = NULL;
	pRootConnObject = NULL;

	RWANDEBUGP(DL_LOUD, DC_CONNECT,
		("TdiPMPConnect: pAddrObj x%p/x%x, pConnObj x%p/x%x, CallFlags x%x\n",
			pAddrObject, pAddrObject->Flags,
			pConnObject, pConnObject->Flags,
			CallFlags));

	do
	{
		//
		//  Allocate party object.
		//
		RWAN_ALLOC_MEM(pParty, RWAN_NDIS_PARTY, sizeof(RWAN_NDIS_PARTY));

		if (pParty == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		RWAN_ZERO_MEM(pParty, sizeof(RWAN_NDIS_PARTY));
		RWAN_SET_SIGNATURE(pParty, npy);

		//
		//  Get at the root Connection object.
		//
		pRootConnObject = pAddrObject->pRootConnObject;
		RWAN_ASSERT(pRootConnObject != NULL);

		if (bIsFirstLeaf)
		{
			//
			//  Get at the first NDIS AF block for this TDI protocol.
			//
			pAf = CONTAINING_RECORD(pAfInfo->NdisAfList.Flink, RWAN_NDIS_AF, AfInfoLink);

			pVc = RWanAllocateVc(pAf, TRUE);

			if (pVc == NULL)
			{
				Status = TDI_NO_RESOURCES;
				break;
			}

			RWAN_SET_BIT(pVc->Flags, RWANF_VC_OUTGOING);
			RWAN_SET_BIT(pVc->Flags, RWANF_VC_PMP);

			RWAN_SET_VC_CALL_PARAMS(pVc, pCallParameters);

			//
			//  Link the VC to the Root Connection Object.
			//

			RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

			RWAN_LINK_CONNECTION_TO_VC(pRootConnObject, pVc);

			//
			//  Save pointer to this first party, for use in MakeCallComplete.
			//
			pVc->pPartyMakeCall = pParty;

			RWanReferenceConnObject(pRootConnObject);	// VC ref: TDI Conn PMP

			RWAN_RELEASE_CONN_LOCK(pRootConnObject);
		}
		else
		{
			pVc = pRootConnObject->NdisConnection.pNdisVc;

		}

		//
		//  We have finished all local checks. Fill in more of the Party structure.
		//
		pParty->pVc = pVc;
		pParty->pConnObject = pConnObject;
		pParty->pCallParameters = pCallParameters;

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		RWanReferenceConnObject(pConnObject);	// Party ref

		pConnObject->State = RWANS_CO_OUT_CALL_INITIATED;

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		//
		//  Link the Party to this Connection Object.
		//
		RWAN_ASSERT(pConnObject->NdisConnection.pNdisParty == NULL);
		pConnObject->NdisConnection.pNdisParty = pParty;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		//
		//  Link the Party and VC structures.
		//

		RWAN_ACQUIRE_CONN_LOCK(pRootConnObject);

		RWAN_INSERT_TAIL_LIST(&(pVc->NdisPartyList), &(pParty->PartyLink));

		pVc->AddingPartyCount ++;

		NdisVcHandle = pVc->NdisVcHandle;

		RWAN_RELEASE_CONN_LOCK(pRootConnObject);

		//
		//  Move this connection object from the Idle list to the
		//  Active list on the address object.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->ActiveConnList),
							 &(pConnObject->ConnLink));

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);


		RWANDEBUGP(DL_LOUD, DC_CONNECT,
			("RWanTdiPMPConnect: AddrObj x%p, ConnObj x%p, RootConn x%p, VC %p, Pty %p, FirstLeaf %d\n",
					pAddrObject, pConnObject, pRootConnObject, pVc, pParty, bIsFirstLeaf));

		if (bIsFirstLeaf)
		{
			//
			//  Place the call.
			//
			NdisStatus = NdisClMakeCall(
							NdisVcHandle,
							pCallParameters,
							(NDIS_HANDLE)pParty,		// ProtocolPartyContext
							&pParty->NdisPartyHandle	// pNdisPartyHandle
							);

			RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

			if (NdisStatus != NDIS_STATUS_PENDING)
			{
				RWanNdisMakeCallComplete(
							NdisStatus,
							(NDIS_HANDLE)pVc,
							pParty->NdisPartyHandle,			// NdisPartyHandle
							pCallParameters
							);
			}
		}
		else
		{
			//
			//  Add the new party.
			//
			NdisStatus = NdisClAddParty(
							NdisVcHandle,
							(NDIS_HANDLE)pParty,
							pCallParameters,
							&pParty->NdisPartyHandle
							);
			
			if (NdisStatus != NDIS_STATUS_PENDING)
			{
				RWanNdisAddPartyComplete(
							NdisStatus,
							(NDIS_HANDLE)pParty,
							pParty->NdisPartyHandle,
							pCallParameters
							);
			}
		}
	
		RWAN_ASSERT(Status == TDI_PENDING);

		break;
	}
	while (FALSE);


	if (Status != TDI_PENDING)
	{
		//
		//  Failure - clean up.
		//
		RWAN_ASSERT(Status == TDI_NO_RESOURCES);

		if (pParty != NULL)
		{
			RWAN_FREE_MEM(pParty);
		}
			
		if (pVc != NULL)
		{
			RWanFreeVc(pVc);
		}
	}

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	return (Status);
}


TDI_STATUS
RWanTdiListen(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptableAddr,
    IN	PTDI_CONNECTION_INFORMATION	pConnectedAddr
    )
/*++

Routine Description:

	This is the TDI Entry point for posting a Listen. The Connection
	Object is identified by its context buried within the TDI request.
	We save off information about this request, and move the connection
	from the idle list to the listen list.

	For now, we ignore any given remote address information.
	TBD: Support remote address information in TdiListen().

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	Flags			- Listen flags
	pAcceptableAddr	- List of acceptable remote addresses
	pConnectedAddr	- Place to return connected remote address

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully queued a Listen,
	TDI_NO_RESOURCES if we ran into a resource failure, TDI_NOT_ASSOCIATED
	if the given Connection object isn't associated with an address,
	TDI_INVALID_CONNECTION if the specified connection object is invalid.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_CONN_REQUEST				pConnReq;
	TDI_STATUS						Status;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	//
	//  Initialize
	//
	pConnReq = NULL;

	do
	{
		//
		//  XXX: Ignore Acceptable address(es) for now.
		//

		//
		//  Allocate a Connection Request structure to keep track
		//  of this request.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
		pConnReq->pConnInfo = pConnectedAddr;
		pConnReq->Flags = Flags;

		//
		//  Get the Connection Object.
		//

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}


		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if it is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  We can move this Connection Object to the listen list
		//  only if there isn't any active connection on this.
		//
		if (pConnObject->State != RWANS_CO_ASSOCIATED)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_INVALID_STATE;
			break;
		}

		pConnObject->State = RWANS_CO_LISTENING;

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		RWAN_RELEASE_CONN_LOCK(pConnObject);


		RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
				("Listen: pConnObject x%p, pAddrObject x%p\n", pConnObject, pAddrObject));

		//
		//  Move this connection object from the Idle list to the
		//  Listen list.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->ListenConnList),
							 &(pConnObject->ConnLink));

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);

	RWAN_CHECK_EXIT_IRQL(EntryIrq, ExitIrq);

	if (Status != TDI_PENDING)
	{
		//
		//  Cleanup
		//
		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}
	}

	return (Status);

}




TDI_STATUS
RWanTdiUnListen(
    IN	PTDI_REQUEST				pTdiRequest
    )
/*++

Routine Description:

	This is the TDI Entry point for terminating a Listen. The Connection
	Object is identified by its context buried within the TDI request.
	We move the connection from the listen list to the idle list.

Arguments:

	pTdiRequest		- Pointer to the TDI Request

Return Value:

	TDI_SUCCESS if successful.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	PRWAN_CONN_REQUEST				pConnReq;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	TDI_STATUS						Status;
#if DBG
	RWAN_IRQL						EntryIrq, ExitIrq;
#endif // DBG

	RWAN_GET_ENTRY_IRQL(EntryIrq);

	do
	{
		//
		//  Get the Connection Object.
		//

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  See if it is associated.
		//
		pAddrObject = pConnObject->pAddrObject;

		if (pAddrObject == NULL)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_NOT_ASSOCIATED;
			break;
		}

		//
		//  We can move this Connection Object to the idle list
		//  only if there isn't any active connection on this.
		//
		if (pConnObject->State != RWANS_CO_LISTENING)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			Status = TDI_INVALID_STATE;
			break;
		}

		pConnObject->State = RWANS_CO_ASSOCIATED;

		pConnReq = pConnObject->pConnReq;
		pConnObject->pConnReq = NULL;

		RWAN_RELEASE_CONN_LOCK(pConnObject);


		RWANDEBUGP(DL_VERY_LOUD, DC_BIND,
				("UnListen: pConnObject x%p, pAddrObject x%p\n", pConnObject, pAddrObject));

		//
		//  Move this connection object from the Listen list to the
		//  Idle list.
		//
		RWAN_ACQUIRE_ADDRESS_LOCK(pAddrObject);

		RWAN_DELETE_FROM_LIST(&(pConnObject->ConnLink));
		RWAN_INSERT_TAIL_LIST(&(pAddrObject->IdleConnList),
							 &(pConnObject->ConnLink));

		RWAN_RELEASE_ADDRESS_LOCK(pAddrObject);

		RWanCompleteConnReq(		// InCall: Listen OK
					NULL,
					pConnReq,
					FALSE,
					NULL,
					NULL,
					TDI_CANCELLED
					);

		Status = TDI_SUCCESS;
		break;
	}
	while (FALSE);

	return (Status);
}




TDI_STATUS
RWanTdiAccept(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PTDI_CONNECTION_INFORMATION	pAcceptInfo,
    IN	PTDI_CONNECTION_INFORMATION	pConnectInfo
    )
/*++

Routine Description:

	This is the TDI entry point for accepting an incoming connection.
	The Connection Object is identified by its context buried within
	the TDI request.

	We translate this to a call to NdisClIncomingCallComplete, and
	pend this request. If all goes well, this request is completed
	when we receive a CallConnected primitive from NDIS.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pAcceptInfo		- Contains options for the connection accept
	pConnectInfo	- Place to return final connection information

Return Value:

	TDI_STATUS - this is TDI_PENDING if we successfully processed
	the Accept, TDI_INVALID_CONNECTION if the given Connection Object
	isn't valid, TDI_NOT_ASSOCIATED if the connection object isn't
	associated with an address object.

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	PRWAN_NDIS_VC					pVc;
	RWAN_CONN_ID					ConnId;
	PRWAN_TDI_ADDRESS				pAddrObject;
	PRWAN_CONN_REQUEST				pConnReq;
	PRWAN_NDIS_AF_CHARS				pAfChars;
	TDI_STATUS						Status;
	NDIS_HANDLE						NdisVcHandle;
	PCO_CALL_PARAMETERS				pCallParameters;

	BOOLEAN							bIsLockAcquired;	// Have we locked the Conn Object?

	//
	//  Initialize
	//
	pConnReq = NULL;
	bIsLockAcquired = FALSE;

	do
	{
		//
		//  XXX: Ignore Acceptable address(es) for now.
		//

		//
		//  Allocate a Connection Request structure to keep track
		//  of this request.
		//
		pConnReq = RWanAllocateConnReq();
		if (pConnReq == NULL)
		{
			Status = TDI_NO_RESOURCES;
			break;
		}

		pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
		pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
		pConnReq->pConnInfo = pConnectInfo;

		//
		//  Copy from Accept Info to Connect Info.
		//
		if ((pAcceptInfo != NULL) &&
			(pAcceptInfo->Options != NULL) &&
			(pConnectInfo != NULL) &&
			(pConnectInfo->Options != NULL) &&
			(pConnectInfo->OptionsLength >= pAcceptInfo->OptionsLength))
		{
			RWAN_COPY_MEM(pConnectInfo->Options,
						 pAcceptInfo->Options,
						 pAcceptInfo->OptionsLength);
		}

		//
		//  Get the Connection Object.
		//
		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);

		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		bIsLockAcquired = TRUE;
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Make sure that the Connection is in the right state.
		//
		if (pConnObject->State != RWANS_CO_IN_CALL_INDICATED)
		{
			Status = TDI_INVALID_STATE;
			break;
		}

		pVc = pConnObject->NdisConnection.pNdisVc;

		if (pVc == NULL)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		pCallParameters = pVc->pCallParameters;
		pVc->pCallParameters = NULL;

		//
		//  Update NDIS Call Parameters if Accept Options are present.
		//
		pAfChars = &(pVc->pNdisAf->pAfInfo->AfChars);

		if (pAfChars->pAfSpUpdateNdisOptions)
		{
			RWAN_STATUS			RWanStatus;
			ULONG				CallFlags = RWAN_CALLF_INCOMING_CALL|RWAN_CALLF_POINT_TO_POINT;
			PVOID				pTdiQoS;
			ULONG				TdiQoSLength;

			if (pAcceptInfo)
			{
				pTdiQoS = pAcceptInfo->Options;
				TdiQoSLength = pAcceptInfo->OptionsLength;
			}
			else
			{
				pTdiQoS = NULL;
				TdiQoSLength = 0;
			}

			RWanStatus = (*pAfChars->pAfSpUpdateNdisOptions)(
								pVc->pNdisAf->AfSpAFContext,
								pConnObject->AfSpConnContext,
								CallFlags,
								pAcceptInfo,
								pTdiQoS,
								TdiQoSLength,
								&pCallParameters
								);

			if (RWanStatus != RWAN_STATUS_SUCCESS)
			{
				Status = RWanToTdiStatus(RWanStatus);
				break;
			}
		}

		NdisVcHandle = pVc->NdisVcHandle;

		//
		//  Update Connection Object state.
		//
		pConnObject->State = RWANS_CO_IN_CALL_ACCEPTING;

		//
		//  Save the Connection Request
		//
		pConnObject->pConnReq = pConnReq;

		RWAN_RELEASE_CONN_LOCK(pConnObject);

		//
		//  Accept the call now.
		//
		NdisClIncomingCallComplete(
				NDIS_STATUS_SUCCESS,
				NdisVcHandle,
				pCallParameters
				);

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);

	if (Status != TDI_PENDING)
	{
		//
		//  Cleanup
		//
		if (bIsLockAcquired)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		if (pConnReq != NULL)
		{
			RWanFreeConnReq(pConnReq);
		}
	}

	return (Status);

}




TDI_STATUS
RWanTdiDisconnect(
    IN	PTDI_REQUEST				pTdiRequest,
    IN	PVOID						pTimeout,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo
    )
/*++

Routine Description:

	This is the TDI Disconnect entry point. If this is an incoming
	call waiting to be accepted, we call NdisClIncomingCallComplete
	with a rejection status. Otherwise, we call NdisClCloseCall.

	The Connection Object is identified by its context buried within
	the TDI request.

	Note that this is never called for point-to-multipoint calls.
	Those are disconnected within TdiCloseConnection.

Arguments:

	pTdiRequest		- Pointer to the TDI Request
	pTimeout		- Points to timeout. Ignored.
	Flags			- Type of disconnect. Only Abortive is supported for now.
	pDisconnInfo	- Information for the disconnect. Ignored for now.
	pReturnInfo		- Return information about the disconnect. Ignored for now.

Return Value:

	TDI_STATUS - this is TDI_SUCCESS if we just rejected an incoming
	call, TDI_PENDING if we initiated NDIS CloseCall, TDI_INVALID_CONNECTION
	if the Connection Object context is invalid,

--*/
{
	PRWAN_TDI_CONNECTION			pConnObject;
	RWAN_CONN_ID					ConnId;
	TDI_STATUS						Status;

	do
	{
		//
		//  Get the Connection Object.
		//
		RWAN_ACQUIRE_CONN_TABLE_LOCK();

		ConnId = (RWAN_CONN_ID) PtrToUlong(pTdiRequest->Handle.ConnectionContext);
		pConnObject = RWanGetConnFromId(ConnId);

		RWAN_RELEASE_CONN_TABLE_LOCK();

		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			Status = TDI_INVALID_CONNECTION;
			break;
		}

		RWANDEBUGP(DL_LOUD, DC_DISCON,
				("RWanTdiDiscon: pConnObj x%p, State/Flags x%x/x%x, pAddrObj x%p\n",
					pConnObject,
					pConnObject->State,
					pConnObject->Flags,
					pConnObject->pAddrObject));

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Make sure that the Connection is in the right state for TdiDisconnect.
		//
		if ((pConnObject->State != RWANS_CO_CONNECTED) &&
			(pConnObject->State != RWANS_CO_DISCON_INDICATED) &&
			(pConnObject->State != RWANS_CO_IN_CALL_INDICATED) &&
			(pConnObject->State != RWANS_CO_IN_CALL_ACCEPTING) &&
			(pConnObject->State != RWANS_CO_OUT_CALL_INITIATED) &&
			(pConnObject->State != RWANS_CO_DISCON_HELD))
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWANDEBUGP(DL_INFO, DC_DISCON,
					("RWanTdiDiscon: pConnObj x%p/x%x, bad state x%x for TdiDiscon\n",
						pConnObject,
						pConnObject->Flags,
						pConnObject->State));

			Status = TDI_INVALID_STATE;
			break;
		}

		if ((pConnObject->State == RWANS_CO_DISCON_INDICATED) ||
			(pConnObject->State == RWANS_CO_DISCON_HELD))
		{
			//
			//  We would have initiated an NDIS CloseCall/DropParty already.
			//  Simply succeed this TDI Disconnect.
			//

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			RWANDEBUGP(DL_INFO, DC_DISCON,
					("RWanTdiDiscon: pConnObj x%p/x%x, Discon recvd state %d\n",
						pConnObject,
						pConnObject->Flags,
						pConnObject->State));

			Status = TDI_SUCCESS;
			break;
		}

		Status = RWanDoTdiDisconnect(
					pConnObject,
					pTdiRequest,
					pTimeout,
					Flags,
					pDisconnInfo,
					pReturnInfo);

		//
		//  Conn Object lock is released within the above.
		//
		break;
	}
	while (FALSE);


	return (Status);
}



TDI_STATUS
RWanDoTdiDisconnect(
    IN	PRWAN_TDI_CONNECTION		pConnObject,
    IN	PTDI_REQUEST				pTdiRequest		OPTIONAL,
    IN	PVOID						pTimeout		OPTIONAL,
    IN	USHORT						Flags,
    IN	PTDI_CONNECTION_INFORMATION	pDisconnInfo	OPTIONAL,
    OUT	PTDI_CONNECTION_INFORMATION	pReturnInfo		OPTIONAL
	)
/*++

Routine Description:

	Perform a TDI Disconnect on the connection endpoint.
	Separated out from the main TdiDisconnect routine
	so that it can be reused by TdiCloseConnection.

	NOTE: This is called with the connection object lock held. This
	lock is released here.

Arguments:

	pConnObject		- Represents the TDI Connection being disconnected.
	pTdiRequest		- Pointer to the TDI Request.
	pTimeout		- Points to timeout. Ignored.
	Flags			- Type of disconnect. Only Abortive is supported for now.
	pDisconnInfo	- Information for the disconnect. Ignored for now.
	pReturnInfo		- Return information about the disconnect. Ignored for now.

Return Value:

	TDI_STATUS - this is TDI_SUCCESS if we just rejected an incoming
	call, TDI_PENDING if we initiated NDIS CloseCall or DropParty.

--*/
{
	TDI_STATUS						Status;
	INT								rc;
	PRWAN_NDIS_VC					pVc;
	PRWAN_NDIS_PARTY				pParty;
	PRWAN_CONN_REQUEST				pConnReq;
	PRWAN_NDIS_AF					pAf;
	PCO_CALL_PARAMETERS				pCallParameters;
	NDIS_STATUS						NdisStatus;
	NDIS_HANDLE						NdisPartyHandle;
	BOOLEAN							bIncomingCall;
	BOOLEAN							bIsPMPRoot;
	BOOLEAN							bIsLastLeaf;
	RWAN_HANDLE						AfSpConnContext;

	UNREFERENCED_PARAMETER(pTimeout);
	UNREFERENCED_PARAMETER(Flags);
	UNREFERENCED_PARAMETER(pDisconnInfo);
	UNREFERENCED_PARAMETER(pReturnInfo);

	//
	//  Initialize
	//
	pConnReq = NULL;
	Status = TDI_SUCCESS;

	do
	{
		bIsPMPRoot = (pConnObject->pRootConnObject != NULL);

		if (bIsPMPRoot)
		{
			pVc = pConnObject->pRootConnObject->NdisConnection.pNdisVc;

			if (pVc == NULL)
			{
				//
				//  Can happen if DoAbort has run on this connection.
				//  Bail out.
				//
				RWANDEBUGP(DL_INFO, DC_WILDCARD,
					("DoTdiDiscon(Root): pConnObj %p/%x: VC is null, bailing out\n",
							pConnObject, pConnObject->Flags));

				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			}

			RWAN_STRUCT_ASSERT(pVc, nvc);
			RWAN_ASSERT(pVc->AddingPartyCount + pVc->ActivePartyCount > 0);

			bIsLastLeaf = ((pVc->AddingPartyCount + pVc->ActivePartyCount) == 1);

			pParty = pConnObject->NdisConnection.pNdisParty;

			RWAN_ASSERT(pParty != NULL);
			RWAN_STRUCT_ASSERT(pParty, npy);

			if (RWAN_IS_BIT_SET(pParty->Flags, RWANF_PARTY_DROPPING))
			{
				RWANDEBUGP(DL_FATAL, DC_DISCON,
					("DoTdiDiscon (Root): pConnObj x%x, Party x%x already dropping\n",
						pConnObject, pParty));
				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			}

			NdisPartyHandle = pParty->NdisPartyHandle;

			RWANDEBUGP(DL_VERY_LOUD, DC_DISCON,
				("DoTdiDiscon (Root): pConnObj x%x, pVc x%x, pParty x%x, Adding %d, Active %d\n",
						pConnObject,
						pVc,
						pParty,
						pVc->AddingPartyCount,
						pVc->ActivePartyCount));
		}
		else
		{
			pVc = pConnObject->NdisConnection.pNdisVc;
			if (pVc == NULL)
			{
				//
				//  Can happen if DoAbort has run on this connection.
				//  Bail out.
				//
				RWANDEBUGP(DL_INFO, DC_WILDCARD,
					("DoTdiDiscon: pConnObj %p/%x: VC is null, bailing out\n",
							pConnObject, pConnObject->Flags));

				RWAN_RELEASE_CONN_LOCK(pConnObject);
				break;
			}

			RWAN_STRUCT_ASSERT(pVc, nvc);

			//
			//  Set last-leaf to TRUE to simplify processing later.
			//
			bIsLastLeaf = TRUE;
		}

		RWAN_ASSERT(pVc != NULL);
		pAf = pVc->pNdisAf;

		//
		//  If an outgoing call is in progress, we complete the
		//  pended TDI_CONNECT with a cancel status, mark this
		//  Connection Object as Disconnecting and exit. When the
		//  outgoing call completes, we will clear it if it was
		//  successful.
		//

		if (pConnObject->State == RWANS_CO_OUT_CALL_INITIATED)
		{
			pConnObject->State = RWANS_CO_DISCON_REQUESTED;

			//
			//  Take out the pending TDI_CONNECT.
			//
			pConnReq = pConnObject->pConnReq;
			RWAN_ASSERT(pConnReq != NULL);

			pConnObject->pConnReq = NULL;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			//
			//  Complete the TDI_CONNECT with a cancelled status.
			//
			RWanCompleteConnReq(
					pAf,
					pConnReq,
					TRUE,			// Is an outgoing call
					NULL,			// No call params
					AfSpConnContext,
					TDI_CANCELLED
					);
			
			//
			//  We will succeed this TDI_DISCONNECT.
			//
			pConnReq = NULL;
			Status = TDI_SUCCESS;
			break;
		}


		//
		//  If this connection is in the process of being accepted,
		//  then complete the pending TDI_ACCEPT with a cancel
		//  status and reject the incoming call.
		//
		if (pConnObject->State == RWANS_CO_IN_CALL_ACCEPTING)
		{
			RWANDEBUGP(DL_FATAL, DC_DISCON,
				("DoTdiDiscon: ConnObj %x/%x, in call accepting, VC %x\n",
						pConnObject,
						pConnObject->Flags,
						pVc));

			//
			//  Take out the pending TDI_CONNECT.
			//
			pConnReq = pConnObject->pConnReq;
			RWAN_ASSERT(pConnReq != NULL);

			pConnObject->pConnReq = NULL;

			AfSpConnContext = pConnObject->AfSpConnContext;

			RWAN_RELEASE_CONN_LOCK(pConnObject);

			//
			//  Complete the TDI_ACCEPT with a cancelled status.
			//
			RWanCompleteConnReq(
					pAf,
					pConnReq,
					FALSE,			// Is an incoming call
					NULL,			// No call params
					AfSpConnContext,
					TDI_CANCELLED
					);

			//
			//  We will succeed this TDI_DISCONNECT.
			//
			pConnReq = NULL;
			Status = TDI_SUCCESS;
			break;
		}

#if DBG
		if (pConnObject->pConnReq != NULL)
		{
			RWANDEBUGP(DL_FATAL, DC_WILDCARD,
				("DoTdiDiscon: pConnObj %x/%x, State %x, non-NULL ConnReq %x\n",
						pConnObject, pConnObject->Flags, pConnObject->State,
						pConnObject->pConnReq));
		}
#endif // DBG

		RWAN_ASSERT(pConnObject->pConnReq == NULL);
		if (pTdiRequest != NULL)
		{
			//
			//  Allocate a Connection Request structure to keep track
			//  of this Disconnect request.
			//
			pConnReq = RWanAllocateConnReq();
			if (pConnReq == NULL)
			{
				RWAN_RELEASE_CONN_LOCK(pConnObject);
				Status = TDI_NO_RESOURCES;
				break;
			}

			pConnReq->Request.pReqComplete = pTdiRequest->RequestNotifyObject;
			pConnReq->Request.ReqContext = pTdiRequest->RequestContext;
			pConnReq->pConnInfo = NULL;
			pConnReq->Flags = 0;

			//
			//  Save info about the TDI Disconnect request.
			//
			pConnObject->pConnReq = pConnReq;
		}
		else
		{
			pConnReq = NULL;
		}

		bIncomingCall = (pConnObject->State == RWANS_CO_IN_CALL_INDICATED);

		if (bIncomingCall)
		{
			pCallParameters = pVc->pCallParameters;
			pVc->pCallParameters = NULL;
		}

		pConnObject->State = RWANS_CO_DISCON_REQUESTED;

		if (bIncomingCall)
		{
			//
			//  Reject the incoming call.
			//
			RWanNdisRejectIncomingCall(pConnObject, NDIS_STATUS_FAILURE);
		}
		else
		{
			//
			//  Closing an existing call.
			//  TBD: we don't support Close data yet.
			//
			if (bIsLastLeaf)
			{
				RWanStartCloseCall(pConnObject, pVc);

				//
				//  ConnObject lock is released within the above.
				//
			}
			else
			{
				pVc->DroppingPartyCount ++;	// DoTdiDiscon: not last leaf (DropParty)
				pVc->ActivePartyCount --;	// DoTdiDiscon: will DropParty

				RWAN_ASSERT(pParty != NULL);
				RWAN_STRUCT_ASSERT(pParty, npy);

				RWAN_SET_BIT(pParty->Flags, RWANF_PARTY_DROPPING);

				RWAN_RELEASE_CONN_LOCK(pConnObject);

				//
				//  Dropping a leaf of a PMP call.
				//
				NdisStatus = NdisClDropParty(
								NdisPartyHandle,
								NULL,		// No Drop data
								0			// Length of drop data
								);

				if (NdisStatus != NDIS_STATUS_PENDING)
				{
					RWanNdisDropPartyComplete(
								NdisStatus,
								(NDIS_HANDLE)pParty
								);
				}
			}
		}

		Status = TDI_PENDING;
		break;
	}
	while (FALSE);


	if (Status != TDI_PENDING)
	{
		//
		//  Cleanup.
		//
		if (pConnReq)
		{
			RWanFreeConnReq(pConnReq);
		}
	}

	return (Status);

}



RWAN_CONN_ID
RWanGetConnId(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Get a free Connection ID to assign to the Connection Object.
	This Connection ID is used as our context for the Connection
	object.

	It is assumed that the caller holds a lock to the Connection Table.

	Validation scheme courtesy TCP source.

Arguments:

	pConnObject		- Pointer to the TDI Connection Object

Return Value:

	RWAN_CONN_ID: this is RWAN_INVALID_CONN_ID iff we cannot allocate
	a Connection Id.

--*/
{
	ULONG			Slot;
	ULONG			i;
	BOOLEAN			bFound;
	RWAN_CONN_ID	ConnId;

	for (;;)
	{
		//
		//  Look for a free slot in the Connection Index table.
		//  Start from where we left off the last time we were called.
		//
		Slot = pRWanGlobal->NextConnIndex;

		for (i = 0; i < pRWanGlobal->ConnTableSize; i++)
		{
			if (Slot == pRWanGlobal->ConnTableSize)
			{
				Slot = 0;	// wrap around
			}

			if (pRWanGlobal->pConnTable[Slot] == NULL)
			{
				// Found free slot
				break;
			}

			++Slot;
		}

		if (i < pRWanGlobal->ConnTableSize)
		{
			bFound = TRUE;
			break;
		}

		//
		//  Grow the Connection Index table, if we can.
		//
		if (pRWanGlobal->ConnTableSize != pRWanGlobal->MaxConnections)
		{
			ULONG						NewTableSize;
			PRWAN_TDI_CONNECTION *		pNewConnTable;
			PRWAN_TDI_CONNECTION *		pOldConnTable;

			NewTableSize = MIN(pRWanGlobal->ConnTableSize + CONN_TABLE_GROW_DELTA,
								pRWanGlobal->MaxConnections);

			RWAN_ALLOC_MEM(pNewConnTable,
						  PRWAN_TDI_CONNECTION,
						  NewTableSize * sizeof(PRWAN_TDI_CONNECTION));

			if (pNewConnTable != NULL)
			{
				RWAN_ZERO_MEM(pNewConnTable, NewTableSize * sizeof(PRWAN_TDI_CONNECTION));

				pOldConnTable = pRWanGlobal->pConnTable;
				pRWanGlobal->pConnTable = pNewConnTable;

				if (pOldConnTable != NULL)
				{
					//
					//  Copy in the contents of the old table.
					//
					RWAN_COPY_MEM(pNewConnTable,
								 pOldConnTable,
								 pRWanGlobal->ConnTableSize * sizeof(PRWAN_TDI_CONNECTION));

					RWAN_FREE_MEM(pOldConnTable);
				}

				pRWanGlobal->ConnTableSize = NewTableSize;

				//
				//  Continue search.
				//
			}
			else
			{
				//
				//  Resource failure.
				//
				bFound = FALSE;
				break;
			}
		}
		else
		{
			//
			//  ConnTable is full, and we aren't permitted to grow it any further.
			//
			bFound = FALSE;
			break;
		}
	}

	if (bFound)
	{
		//
		//  Use the slot that we found.
		//
		pRWanGlobal->pConnTable[Slot] = pConnObject;
		pRWanGlobal->NextConnIndex = Slot + 1;

		//
		//  Assign an instance value for this. This is used to validate
		//  a given ConnId.
		//
		pRWanGlobal->ConnInstance++;
		pConnObject->ConnInstance = pRWanGlobal->ConnInstance;

		ConnId = RWAN_MAKE_CONN_ID(pConnObject->ConnInstance, Slot);
	}
	else
	{
		ConnId = RWAN_INVALID_CONN_ID;
	}

	return (ConnId);
}




PRWAN_TDI_CONNECTION
RWanGetConnFromId(
	IN	RWAN_CONN_ID					ConnId
	)
/*++

Routine Description:

	Given a Connection ID, validate it. If found OK, return a pointer
	to the TDI Connection that it represents.

	It is assumed that the caller holds a lock to the Connection Table.

	Validation scheme courtesy TCP source.

Arguments:

	ConnId			- Connection Id.

Return Value:

	PRWAN_TDI_CONNECTION - pointer to a TDI Connection structure that
	matches the given ConnId, if valid. Otherwise, NULL.

--*/
{
	ULONG					Slot;
	RWAN_CONN_INSTANCE		ConnInstance;
	PRWAN_TDI_CONNECTION	pConnObject;

	Slot = RWAN_GET_SLOT_FROM_CONN_ID(ConnId);

	if (Slot < pRWanGlobal->ConnTableSize)
	{
		pConnObject = pRWanGlobal->pConnTable[Slot];
		if (pConnObject != NULL_PRWAN_TDI_CONNECTION)
		{
			RWAN_STRUCT_ASSERT(pConnObject, ntc);
			ConnInstance = RWAN_GET_INSTANCE_FROM_CONN_ID(ConnId);
			if (pConnObject->ConnInstance != ConnInstance)
			{
				pConnObject = NULL_PRWAN_TDI_CONNECTION;
			}
		}
	}
	else
	{
		pConnObject = NULL_PRWAN_TDI_CONNECTION;
	}

	return (pConnObject);
}




VOID
RWanFreeConnId(
	IN	RWAN_CONN_ID					ConnId
	)
/*++

Routine Description:

	Free a Connection ID.

Arguments:

	ConnId		- ID to be freed.

Return Value:

	None

--*/
{
	ULONG					Slot;

	Slot = RWAN_GET_SLOT_FROM_CONN_ID(ConnId);

	RWAN_ASSERT(Slot < pRWanGlobal->ConnTableSize);

	pRWanGlobal->pConnTable[Slot] = NULL;

	return;
}




TDI_STATUS
RWanToTdiStatus(
	IN	RWAN_STATUS					RWanStatus
	)
/*++

Routine Description:

	Map the given local status code to an equivalent TDI status code.

Arguments:

	RWanStatus		- Local status code

Return Value:

	TDI Status code.

--*/
{
	TDI_STATUS		TdiStatus;

	switch (RWanStatus)
	{
		case RWAN_STATUS_SUCCESS:
				TdiStatus = TDI_SUCCESS;
				break;
		case RWAN_STATUS_BAD_ADDRESS:
				TdiStatus = TDI_BAD_ADDR;
				break;
		case RWAN_STATUS_BAD_PARAMETER:
				TdiStatus = TDI_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_MISSING_PARAMETER:
				TdiStatus = TDI_INVALID_PARAMETER;
				break;
		case RWAN_STATUS_FAILURE:
		default:
				TdiStatus = TDI_INVALID_STATE;	// XXX: find a better one?
				break;
	}

	return (TdiStatus);
}



PRWAN_CONN_REQUEST
RWanAllocateConnReq(
	VOID
	)
/*++

Routine Description:

	Allocate a structure to hold context about a TDI Connection Request.
	This includes TDI_CONNECT, TDI_DISCONNECT, TDI_LISTEN and TDI_ACCEPT.

Arguments:

	None

Return Value:

	Pointer to allocate structure if successful, else NULL.

--*/
{
	PRWAN_CONN_REQUEST		pConnReq;

	RWAN_ALLOC_MEM(pConnReq, RWAN_CONN_REQUEST, sizeof(RWAN_CONN_REQUEST));

	if (pConnReq != NULL)
	{
		RWAN_SET_SIGNATURE(pConnReq, nrc);
	}

	return (pConnReq);
}




VOID
RWanFreeConnReq(
	IN	PRWAN_CONN_REQUEST			pConnReq
	)
/*++

Routine Description:

	Free a connect request context structure.

Arguments:

	pConnReq		- Points to structure to be freed.

Return Value:

	None

--*/
{
	RWAN_STRUCT_ASSERT(pConnReq, nrc);

	RWAN_FREE_MEM(pConnReq);
}



VOID
RWanAbortConnection(
	IN	CONNECTION_CONTEXT			ConnectionContext
	)
/*++

Routine Description:

	Abortively closes a connection and issues a Disconnect Indication
	to the user. This is called when a send or receive is cancelled,
	implying that an NDIS connection is in place.

Arguments:

	ConnectionContext- Our context for a TDI Connection object.

Return Value:

	None

--*/
{
	RWAN_CONN_ID						ConnId;
	PRWAN_TDI_CONNECTION				pConnObject;

	ConnId = (RWAN_CONN_ID)PtrToUlong(ConnectionContext);

	RWAN_ACQUIRE_CONN_TABLE_LOCK();

	pConnObject = RWanGetConnFromId(ConnId);

	RWAN_RELEASE_CONN_TABLE_LOCK();

	RWanDoAbortConnection(pConnObject);
}




VOID
RWanDoAbortConnection(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Does the actual connection abort. Split out from RWanAbortConnection
	just so that this can be called from elsewhere.

	See comments under RWanAbortConnection.

Arguments:

	pConnObject	- Points to TDI Connection to be aborted.

Return Value:

	None

--*/
{
	PRWAN_NDIS_VC					pVc;
	PRWAN_NDIS_PARTY				pParty;
	PRWAN_TDI_CONNECTION			pLeafConnObject;
	INT								rc;
	BOOLEAN							bIsLockReleased = TRUE;
	ULONG							OldState;
	ULONG							OldLeafState;
	PLIST_ENTRY						pPartyEntry;
	PLIST_ENTRY						pNextPartyEntry;

	RWANDEBUGP(DL_INFO, DC_DISCON,
			("DoAbortConnection: pConnObject x%x/%x, pAddrObject x%x\n",
				pConnObject, (pConnObject? pConnObject->Flags: 0), (pConnObject? pConnObject->pAddrObject: 0)));

	do
	{
		if (pConnObject == NULL_PRWAN_TDI_CONNECTION)
		{
			break;
		}

		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		//
		//  Make sure we don't do this more than once on a Connection.
		//
		if (pConnObject->State == RWANS_CO_ABORTING)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
			break;
		}

		//
		//  Make sure the Conn Object doesn't go away during the time we
		//  need it.
		//
		RWanReferenceConnObject(pConnObject);	// temp ref: RWanAbortConnection

		OldState = pConnObject->State;
		pConnObject->State = RWANS_CO_ABORTING;

		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_ROOT))
		{
			bIsLockReleased = FALSE;

			//
			//  This is a Root Connection object.
			//  Indicate disconnect and schedule Closing each leaf.
			//
			pVc = pConnObject->NdisConnection.pNdisVc;

			if (pVc != NULL)
			{
				for (pPartyEntry = pVc->NdisPartyList.Flink;
					 pPartyEntry != &(pVc->NdisPartyList);
					 pPartyEntry = pNextPartyEntry)
				{
					pParty = CONTAINING_RECORD(pPartyEntry, RWAN_NDIS_PARTY, PartyLink);
					pNextPartyEntry = pParty->PartyLink.Flink;

					pLeafConnObject = pParty->pConnObject;
					RWAN_ASSERT(pLeafConnObject);
					RWAN_STRUCT_ASSERT(pLeafConnObject, ntc);

					RWAN_ACQUIRE_CONN_LOCK(pLeafConnObject);

					if (pLeafConnObject->State == RWANS_CO_ABORTING)
					{
						RWAN_RELEASE_CONN_LOCK(pLeafConnObject);
						continue;
					}
		
#if DBG
					pLeafConnObject->OldState = pLeafConnObject->State;
					pLeafConnObject->OldFlags = pLeafConnObject->Flags;
#endif // DBG
					OldLeafState = pLeafConnObject->State;
					pLeafConnObject->State = RWANS_CO_ABORTING;

					if ((OldLeafState == RWANS_CO_CONNECTED) &&
						(pLeafConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS))
					{
						PDisconnectEvent			pDisconInd;
						PVOID						IndContext;
						PVOID						ConnectionHandle;
	
						pDisconInd = pLeafConnObject->pAddrObject->pDisconInd;
						IndContext = pLeafConnObject->pAddrObject->DisconIndContext;
	
						if (pDisconInd != NULL)
						{
							pLeafConnObject->State = RWANS_CO_DISCON_INDICATED;
							ConnectionHandle = pLeafConnObject->ConnectionHandle;
	
							RWAN_RELEASE_CONN_LOCK(pLeafConnObject);
							RWAN_RELEASE_CONN_LOCK(pConnObject);
	
							RWANDEBUGP(DL_FATAL, DC_DISCON,
								("DoAbort[Leaf]: will indicate Discon, pConnObj x%x, pAddrObj x%x\n",
									pLeafConnObject, pLeafConnObject->pAddrObject));
	
							(*pDisconInd)(
								IndContext,
								ConnectionHandle,
								0,			// Disconnect Data Length
								NULL,		// Disconnect Data
								0,			// Disconnect Info Length
								NULL,		// Disconnect Info
								TDI_DISCONNECT_ABORT
								);
	
							RWAN_ACQUIRE_CONN_LOCK(pConnObject);
							RWAN_ACQUIRE_CONN_LOCK(pLeafConnObject);
						}
					}
		
					RWanScheduleDisconnect(pLeafConnObject);
					//
					//  Leaf Conn Object lock is freed within the above.
					//
				}
				//
				//  end For all parties
				//
			}
			//
			//  else Root Conn object has no associated VC.
			//
			rc = RWanDereferenceConnObject(pConnObject);	// temp ref: RWanAbortConnection
			if (rc == 0)
			{
				bIsLockReleased = TRUE;
				break;	// The Conn Object has been deref'ed away.
			}
		}
		else
		{
			//
			//  Not PMP connection.
			//
			pVc = pConnObject->NdisConnection.pNdisVc;

//	157217: this prevents CoSendComplete for pended packets from
//  continuing on to do StartCloseCall.
//			RWAN_UNLINK_CONNECTION_AND_VC(pConnObject, pVc);

			//
			//  First, initiate a network call close.
			//
			RWanStartCloseCall(pConnObject, pVc);

			//
			//  The lock is freed within the above. Reacquire it.
			//
			bIsLockReleased = FALSE;

			RWAN_ACQUIRE_CONN_LOCK(pConnObject);
	
			rc = RWanDereferenceConnObject(pConnObject);	// temp ref: RWanAbortConnection

			if (rc == 0)
			{
				bIsLockReleased = TRUE;
				break;	// The Conn Object has been deref'ed away.
			}

			//
			//  Now, indicate a disconnect to the user, if required & possible.
			//
			if ((OldState == RWANS_CO_CONNECTED) &&
				(pConnObject->pAddrObject != NULL_PRWAN_TDI_ADDRESS))
			{
				PDisconnectEvent			pDisconInd;
				PVOID						IndContext;
				PVOID						ConnectionHandle;

				pDisconInd = pConnObject->pAddrObject->pDisconInd;
				IndContext = pConnObject->pAddrObject->DisconIndContext;

				if (pDisconInd != NULL)
				{
					ConnectionHandle = pConnObject->ConnectionHandle;

					RWAN_RELEASE_CONN_LOCK(pConnObject);

					(*pDisconInd)(
						IndContext,
						ConnectionHandle,
						0,			// Disconnect Data Length
						NULL,		// Disconnect Data
						0,			// Disconnect Info Length
						NULL,		// Disconnect Info
						TDI_DISCONNECT_ABORT
						);

					bIsLockReleased = TRUE;
				}
			}

		}

		if (!bIsLockReleased)
		{
			RWAN_RELEASE_CONN_LOCK(pConnObject);
		}

		break;
	}
	while (FALSE);


	return;
}



VOID
RWanScheduleDisconnect(
	IN	PRWAN_TDI_CONNECTION			pConnObject
	)
/*++

Routine Description:

	Schedule a call to RWanDoTdiDisconnect on the specified connection
	object, as a work item.

	NOTE: The Connection object is locked by the caller.

Arguments:

	pConnObject	- Points to TDI Connection to be aborted.

Return Value:

	None

--*/
{
	NDIS_STATUS			Status;

	RWANDEBUGP(DL_LOUD, DC_DISCON,
		("ScheduleDiscon: pConnObj x%x/x%x, state %d\n",
			pConnObject, pConnObject->Flags, pConnObject->State));

	do
	{
		//
		//  Check if we've already done this.
		//
		if (RWAN_IS_BIT_SET(pConnObject->Flags, RWANF_CO_CLOSE_SCHEDULED))
		{
			break;
		}

		RWAN_SET_BIT(pConnObject->Flags, RWANF_CO_CLOSE_SCHEDULED);

		//
		//  Make sure the connection doesn't go away till the
		//  work item is handled.
		//
		RWanReferenceConnObject(pConnObject);	// Schedule Discon ref

		NdisInitializeWorkItem(
			&pConnObject->CloseWorkItem,
			RWanDelayedDisconnectHandler,
			(PVOID)pConnObject);
		
		Status = NdisScheduleWorkItem(&pConnObject->CloseWorkItem);

		RWAN_ASSERT(Status == NDIS_STATUS_SUCCESS);
	}
	while (FALSE);

	RWAN_RELEASE_CONN_LOCK(pConnObject);

	return;
}




VOID
RWanDelayedDisconnectHandler(
	IN	PNDIS_WORK_ITEM					pCloseWorkItem,
	IN	PVOID							Context
	)
/*++

Routine Description:

	Work item routine to initiate a connection teardown.

Arguments:

	pCloseWorkItem	- Points to work item structure embedded in the
					  Connection object.
	Context			- Actually a pointer to the Connection object.

Return Value:

	None

--*/
{
	PRWAN_TDI_CONNECTION	pConnObject;
	ULONG					rc;

	pConnObject = (PRWAN_TDI_CONNECTION)Context;
	RWAN_STRUCT_ASSERT(pConnObject, ntc);

	RWANDEBUGP(DL_LOUD, DC_DISCON,
		("DelayedDiscon handler: pConnObj x%x/x%x, state %d\n",
			pConnObject, pConnObject->Flags, pConnObject->State));

	do
	{
		RWAN_ACQUIRE_CONN_LOCK(pConnObject);

		rc = RWanDereferenceConnObject(pConnObject);	// Delayed (scheduled) Discon deref

		if (rc == 0)
		{
			//
			//  The Conn Object is gone.
			//
			break;
		}

		//
		//  Do the Disconnect now.
		//
		RWanDoTdiDisconnect(
			pConnObject,
			NULL,		// pTdiRequest
			NULL,		// pTimeout
			0,			// Flags
			NULL,		// pDisconnInfo
			NULL		// pReturnInfo
			);
		
		//
		//  Conn object lock is released within the above.
		//
		break;
	}
	while (FALSE);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\tdi\precomp.h ===
#include <ndis.h>
#include <atm.h>
#include <ntddndis.h>

#include <tdikrnl.h>
#include <tdistat.h>

#include "debug.h"

#include "rwanpub.h"
#include "rwanatm.h"
#include "atmsp.h"

#include "ws2atmsp.h"

#include "macros.h"

#include "externs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\tdi\rwanatm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\atm\rwanatm.h

Abstract:

	Winsock 2 ATM definitions.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-18-97    Created

Notes:

--*/


#ifndef __TDI_ATM_RWANATM__H
#define __TDI_ATM_RWANATM__H


typedef struct _ATMSP_WSABUF
{
	ULONG							len;
	PCHAR							buf;

} ATMSP_WSABUF, *PATMSP_WSABUF;


typedef struct _ATMSP_QUALITY_OF_SERVICE
{
	FLOWSPEC						SendingFlowSpec;
	FLOWSPEC						ReceivingFlowSpec;
	ATMSP_WSABUF					ProviderSpecific;

} ATMSP_QOS, *PATMSP_QOS;


typedef struct _ATMSP_BLLI
{
	ULONG							Layer2Protocol;
	ULONG							Layer2UserSpecifiedProtocol;
	ULONG							Layer3Protocol;
	ULONG							Layer3UserSpecifiedProtocol;
	ULONG							Layer3IPI;
	UCHAR							SnapId[5];

} ATMSP_BLLI, *PATMSP_BLLI;


typedef struct _ATMSP_BHLI
{
	ULONG							HighLayerInfoType;
	ULONG							HighLayerInfoLength;
	UCHAR							HighLayerInfo[8];

} ATMSP_BHLI, *PATMSP_BHLI;


typedef struct _atmsp_sockaddr_atm
{
	ATM_ADDRESS						satm_number;
	ATMSP_BLLI						satm_blli;
	ATMSP_BHLI						satm_bhli;

} ATMSP_SOCKADDR_ATM, *LPATMSP_SOCKADDR_ATM;

#define ATMSP_AF_ATM				22
#define TDI_ADDRESS_TYPE_ATM		ATMSP_AF_ATM
#define ATMSP_ATMPROTO_AAL5			0x05
#define ATMSP_SOCK_TYPE				1

#define SOCKATM_E164				1
#define SOCKATM_NSAP				2


typedef struct _atmsp_connection_id
{
	ULONG							DeviceNumber;
	ULONG							Vpi;
	ULONG							Vci;

} ATMSP_CONNECTION_ID, *PATMSP_CONNECTION_ID;


//
//  Winsock2/ATM AAL parameter definition:
//
typedef enum {
	ATMSP_AALTYPE_5			= 5,
	ATMSP_AALTYPE_USER		= 16

} ATMSP_AAL_TYPE, *PATMSP_AAL_TYPE;

typedef struct
{
	ULONG							ForwardMaxCPCSSDUSize;
	ULONG							BackwardMaxCPCSSDUSize;
	UCHAR							Mode;
	UCHAR							SSCSType;

} ATMSP_AAL5_PARAMETERS, *PATMSP_AAL5_PARAMETERS;


typedef struct {
	ULONG							UserDefined;

} ATMSP_AALUSER_PARAMETERS, *PATMSP_AALUSER_PARAMETERS;

typedef struct _atmsp_aal_parameters_ie
{
	ATMSP_AAL_TYPE					AALType;
	union {
		ATMSP_AAL5_PARAMETERS			AAL5Parameters;
		ATMSP_AALUSER_PARAMETERS		AALUserParameters;
	}								AALSpecificParameters;

} ATMSP_AAL_PARAMETERS_IE, *PATMSP_AAL_PARAMETERS_IE;



//
//  Winsock2/ATM Broadband bearer capability code definitions.
//  The BearerClass codes are different.
//
#define ATMSP_BCOB_A				0x01
#define ATMSP_BCOB_C				0x03
#define ATMSP_BCOB_X				0x10

#endif // __TDI_ATM_RWANATM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\tdi\macros.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    D:\nt\private\ntos\tdi\rawwan\atm\macros.h

Abstract:

	Macros for the ATM-Specific Raw WAN module.

Revision History:

    Who         When        What
    --------    --------    ----
    arvindm     06-18-97    created

Notes:


--*/
#ifndef __ATMSP_MACROS_H_INCLUDED
#define __ATMSP_MACROS_H_INCLUDED




#define ATMSP_SET_FLAG(Flags, Mask, Val)	\
			(Flags) = ((Flags) & ~(Mask)) | (Val)

#define ATMSP_IS_FLAG_SET(Flags, Mask, Val)	\
			(((Flags) & (Mask)) == (Val))

#define ATMSP_SET_BIT(_Flags, _Bit)			\
			(_Flags) = (_Flags) | (_Bit);

#define ATMSP_RESET_BIT(_Flags, _Bit)			\
			(_Flags) &= ~(_Bit);

#define ATMSP_IS_BIT_SET(_Flags, _Bit)		\
			(((_Flags) & (_Bit)) != 0)


/*++
VOID
ATMSP_INIT_EVENT_STRUCT(
	IN	ATMSP_EVENT	*pEvent
)
--*/
#define ATMSP_INIT_EVENT_STRUCT(pEvent)		NdisInitializeEvent(&((pEvent)->Event))


/*++
NDIS_STATUS
ATMSP_WAIT_ON_EVENT_STRUCT(
	IN	ATMSP_EVENT	*pEvent
)
--*/
#define ATMSP_WAIT_ON_EVENT_STRUCT(pEvent)		\
			(NdisWaitEvent(&((pEvent)->Event), 0), (pEvent)->Status)


/*++
VOID
ATMSP_SIGNAL_EVENT_STRUCT(
	IN	ATMSP_EVENT	*pEvent,
	IN	UINT			Status
)
--*/
#define ATMSP_SIGNAL_EVENT_STRUCT(pEvent, _Status)	\
			{ (pEvent)->Status = _Status; NdisSetEvent(&((pEvent)->Event)); }



/*++
VOID
ATMSP_ALLOC_MEM(
	IN	POPAQUE		pVar,
	IN	OPAQUE		StructureType,
	IN	ULONG		SizeOfStructure
)
--*/
#if DBG
extern
PVOID
RWanAuditAllocMem(
	PVOID			pPointer,
	ULONG			Size,
	ULONG			FileNumber,
	ULONG			LineNumber
);

#define ATMSP_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			pVar = (StructureType *)RWanAuditAllocMem(				\
										(PVOID)(&(pVar)),			\
										(ULONG)(SizeOfStructure),	\
										_FILENUMBER,				\
										__LINE__					\
									);
#else
#define ATMSP_ALLOC_MEM(pVar, StructureType, SizeOfStructure)	\
			NdisAllocateMemoryWithTag((PVOID *)(&pVar), (ULONG)(SizeOfStructure), (ULONG)'naWR');
#endif // DBG


/*++
VOID
ATMSP_FREE_MEM(
	IN	POPAQUE		pMem
)
--*/
#if DBG
extern VOID RWanAuditFreeMem(PVOID	Pointer);

#define ATMSP_FREE_MEM(pMem)	RWanAuditFreeMem((PVOID)(pMem));
#else
#define ATMSP_FREE_MEM(pMem)	NdisFreeMemory((PVOID)(pMem), 0, 0);
#endif // DBG


#define ATMSP_SET_MEM(pMem, bValue, NumberOfBytes)	\
			RtlFillMemory((PVOID)(pMem), (ULONG)(NumberOfBytes), (UCHAR)(bValue));


#define ATMSP_ZERO_MEM(pMem, NumberOfBytes)	\
			RtlZeroMemory((PVOID)pMem, (ULONG)(NumberOfBytes));


#define ATMSP_COPY_MEM(pDst, pSrc, NumberOfBytes)	\
			NdisMoveMemory((PVOID)(pDst), (PVOID)(pSrc), NumberOfBytes);


#define ATMSP_EQUAL_MEM(_pMem1, _pMem2, _Length)	\
			(RtlCompareMemory((PVOID)(_pMem1), (PVOID)(_pMem2), (ULONG)(_Length)) == (_Length))



//
//  Spinlock macros.
//
#define ATMSP_INIT_LOCK(_pLock)		NdisAllocateSpinLock(_pLock)
#define ATMSP_ACQUIRE_LOCK(_pLock)	NdisAcquireSpinLock(_pLock)
#define ATMSP_RELEASE_LOCK(_pLock)	NdisReleaseSpinLock(_pLock)
#define ATMSP_FREE_LOCK(_pLock)		NdisFreeSpinLock(_pLock)

//
//  Doubly linked list manipulation definitions and macros.
//
#define ATMSP_INIT_LIST(_pListHead)					\
			InitializeListHead(_pListHead)

#define ATMSP_IS_LIST_EMPTY(_pListHead)				\
			IsListEmpty(_pListHead)

#define ATMSP_INSERT_HEAD_LIST(_pListHead, _pEntry)	\
			InsertHeadList((_pListHead), (_pEntry))

#define ATMSP_INSERT_TAIL_LIST(_pListHead, _pEntry)	\
			InsertTailList((_pListHead), (_pEntry))

#define ATMSP_DELETE_FROM_LIST(_pEntry)				\
			RemoveEntryList(_pEntry)


#define ATMSP_BLLI_PRESENT(_pBlli)		\
			( (((_pBlli)->Layer2Protocol != SAP_FIELD_ABSENT) &&	\
			   ((_pBlli)->Layer2Protocol != SAP_FIELD_ANY))			\
					 ||												\
			  (((_pBlli)->Layer3Protocol != SAP_FIELD_ABSENT) && 	\
			   ((_pBlli)->Layer3Protocol != SAP_FIELD_ANY))		\
			)


#define ATMSP_BHLI_PRESENT(_pBhli)		\
			(((_pBhli)->HighLayerInfoType != SAP_FIELD_ABSENT) &&	\
			 ((_pBhli)->HighLayerInfoType != SAP_FIELD_ANY))

/*++
ULONG
ROUND_UP(
	IN	ULONG	Val
)
Round up a value so that it becomes a multiple of 4.
--*/
#define ROUND_UP(Val)	(((Val) + 3) & ~0x3)



#if DBG

#define ATMSP_ASSERT(exp)	\
		{																\
			if (!(exp))													\
			{															\
				DbgPrint("NulT: assert " #exp " failed in file %s, line %d\n", __FILE__, __LINE__);	\
				DbgBreakPoint();										\
			}															\
		}

#else

#define ATMSP_ASSERT(exp)		// Nothing

#endif // DBG

#endif // __ATMSP_MACROS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\tdi\externs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\atm\externs.h

Abstract:

	All external declarations for ATM-specific Raw WAN (functions, globals)
	are here.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-13-97    Created

Notes:

--*/


#ifndef __TDI_ATMSP_EXTERNS__H
#define __TDI_ATMSP_EXTERNS__H


#ifndef EXTERN
#define EXTERN	extern
#endif // EXTERN

EXTERN
RWAN_STATUS
RWanAtmSpInitialize(
	VOID
	);

EXTERN
VOID
RWanAtmSpShutdown(
	VOID
	);

EXTERN
RWAN_STATUS
RWanAtmSpOpenAf(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAFHandle,
    OUT	PRWAN_HANDLE				pAfSpAFContext,
    OUT PULONG						pMaxMsgSize
    );

EXTERN
RWAN_STATUS
RWanAtmSpCloseAf(
    IN	RWAN_HANDLE					AfSpAFContext
    );

EXTERN
RWAN_STATUS
RWanAtmSpOpenAddressObject(
    IN	RWAN_HANDLE					AfSpContext,
    IN	RWAN_HANDLE					RWanAddrHandle,
    OUT	PRWAN_HANDLE				pAfSpAddrContext
    );

EXTERN
VOID
RWanAtmSpCloseAddressObject(
    IN	RWAN_HANDLE					AfSpAddrContext
    );

EXTERN
RWAN_STATUS
RWanAtmSpAssociateConnection(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	RWAN_HANDLE					RWanConnHandle,
    OUT	PRWAN_HANDLE				pAfSpConnContext
    );

EXTERN
VOID
RWanAtmSpDisassociateConnection(
	IN	RWAN_HANDLE					AfSpConnContext
	);

EXTERN
RWAN_STATUS
RWanAtmSpTdi2NdisOptions(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
    IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
    IN	PVOID						pTdiQoS,
    IN	ULONG						TdiQoSLength,
    OUT	PRWAN_HANDLE				pRWanAfHandle,
    OUT	PCO_CALL_PARAMETERS *		ppCallParameters
    );

EXTERN
RWAN_STATUS
RWanAtmSpUpdateNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
	IN	PTDI_CONNECTION_INFORMATION	pTdiInfo,
	IN	PVOID						pTdiQoS,
	IN	ULONG						TdiQoSLength,
	IN OUT PCO_CALL_PARAMETERS *	ppCallParameters
	);

EXTERN
VOID
RWanAtmSpReturnNdisOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	PCO_CALL_PARAMETERS			pCallParameters
	);

EXTERN
RWAN_STATUS
RWanAtmSpNdis2TdiOptions(
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	ULONG						CallFlags,
    IN	PCO_CALL_PARAMETERS			pCallParameters,
    OUT	PTDI_CONNECTION_INFORMATION *ppTdiInfo,
    OUT	PVOID *						ppTdiQoS,
    OUT	PULONG 						pTdiQoSLength,
    OUT	RWAN_HANDLE *				pAfSpTdiOptionsContext
    );

EXTERN
RWAN_STATUS
RWanAtmSpUpdateTdiOptions(
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	ULONG						CallFlags,
    IN	PCO_CALL_PARAMETERS			pCallParameters,
    IN OUT	PTDI_CONNECTION_INFORMATION *	ppTdiInfo,
    IN OUT	PUCHAR						pTdiQoS,
    IN OUT	PULONG						pTdiQoSLength
    );

EXTERN
VOID
RWanAtmSpReturnTdiOptions(
	IN	RWAN_HANDLE					AfSpAFContext,
	IN	RWAN_HANDLE					AfSpTdiOptionsContext
	);

EXTERN
TA_ADDRESS *
RWanAtmSpGetValidTdiAddress(
    IN	RWAN_HANDLE					AfSpContext,
    IN	TRANSPORT_ADDRESS UNALIGNED *pAddressList,
    IN	ULONG						AddrListLength
    );

EXTERN
BOOLEAN
RWanAtmSpIsNullAddress(
    IN	RWAN_HANDLE					AfSpContext,
    IN	TA_ADDRESS *		        pTransportAddress
    );

EXTERN
RWAN_STATUS
RWanAtmSpTdi2NdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	USHORT						TdiAddressType,
    IN	USHORT						TdiAddressLength,
    IN	PVOID						pTdiAddress,
    OUT	PCO_SAP *					ppCoSap
    );

EXTERN
VOID
RWanAtmSpReturnNdisSap(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PCO_SAP						pCoSap
    );

EXTERN
VOID
RWanAtmSpDeregNdisAFComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    );

EXTERN
VOID
RWanAtmSpDeregTdiProtoComplete(
    IN	RWAN_STATUS					RWanStatus,
    IN	RWAN_HANDLE					AfSpContext
    );

EXTERN
PATMSP_AF_BLOCK
AtmSpDeviceNumberToAfBlock(
	IN	UINT						DeviceNumber
	);

EXTERN
UINT
AtmSpAfBlockToDeviceNumber(
	IN	PATMSP_AF_BLOCK				pAfBlock
	);

EXTERN
RWAN_STATUS
AtmSpDoAdapterRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
RWAN_STATUS
AtmSpDoCallManagerRequest(
    IN	PATMSP_AF_BLOCK				pAfBlock,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
ATMSP_SOCKADDR_ATM UNALIGNED *
AtmSpGetSockAtmAddress(
	IN	PVOID						pTdiAddressList,
	IN	ULONG						AddrListLength
	);

EXTERN
VOID
RWanAtmSpAdapterRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
VOID
RWanAtmSpAfRequestComplete(
    IN	NDIS_STATUS					Status,
    IN	RWAN_HANDLE					AfSpAFContext,
    IN	RWAN_HANDLE					AfSpReqContext,
    IN	NDIS_REQUEST_TYPE			RequestType,
    IN	NDIS_OID					Oid,
    IN	PVOID						pBuffer,
    IN	ULONG						BufferLength
    );

EXTERN
VOID
RWanAtmSpDeregTdiProtocolComplete(
	IN	RWAN_STATUS					RWanStatus,
	IN	RWAN_HANDLE					AfSpTdiProtocolContext
	);

EXTERN
VOID
AtmSpPrepareDefaultQoS(
    IN	PATMSP_AF_BLOCK				pAfBlock
);

EXTERN
RWAN_STATUS
RWanAtmSpQueryGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    IN	PVOID						pOutputBuffer,
    IN OUT	PULONG					pOutputBufferLength
    );

EXTERN
RWAN_STATUS
RWanAtmSpSetGlobalInfo(
    IN	RWAN_HANDLE					AfSpContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanAtmSpSetAddrInfo(
    IN	RWAN_HANDLE					AfSpAddrContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength
    );

EXTERN
RWAN_STATUS
RWanAtmSpQueryConnInfo(
    IN	RWAN_HANDLE					AfSpConnContext,
    IN	PVOID						pInputBuffer,
    IN	ULONG						InputBufferLength,
    OUT	PVOID						pOutputBuffer,
    IN OUT PULONG					pOutputBufferLength
    );

#endif // __TDI_ATMSP_EXTERNS__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\rawwan\tdi\atmsp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	D:\nt\private\ntos\tdi\rawwan\atm\atmsp.h

Abstract:

	Private data structure definitions for ATM-specific functions
	for Raw WAN.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	arvindm     06-03-97    Created

Notes:

--*/


#ifndef __TDI_ATM_ATMSP__H
#define __TDI_ATM_ATMSP__H


//
//  ATM-specific module's context for an NDIS AF open.
//
typedef struct _ATMSP_AF_BLOCK
{
	RWAN_HANDLE						RWanAFHandle;
	LIST_ENTRY						AfBlockLink;		// To list of AF Blocks
	NDIS_CO_LINK_SPEED				LineRate;			// supported by adapter
	ULONG							MaxPacketSize;		// supported by adapter
	ATMSP_QOS						DefaultQoS;
	ULONG							DefaultQoSLength;

} ATMSP_AF_BLOCK, *PATMSP_AF_BLOCK;


//
//  ATM-specific module's context for a TDI Address Object.
//
typedef struct _ATMSP_ADDR_BLOCK
{
	RWAN_HANDLE						RWanAddrHandle;
	ULONG							RefCount;
	ULONG							Flags;
	ATMSP_CONNECTION_ID				ConnectionId;		// Set via SIO_ASSOCIATE_PVC
	LIST_ENTRY						ConnList;			// List of associated conn blocks
	NDIS_SPIN_LOCK					Lock;				// For above list.

} ATMSP_ADDR_BLOCK, *PATMSP_ADDR_BLOCK;

#define ATMSPF_ADDR_PVC_ID_SET		0x00000001


//
//  ATM-specific module's context for a TDI Connection Object that is
//  associated with an address object.
//
typedef struct _ATMSP_CONN_BLOCK
{
	RWAN_HANDLE						RWanConnHandle;
	PATMSP_ADDR_BLOCK				pAddrBlock;
	LIST_ENTRY						ConnLink;			// To List of Conn Blocks
	ATMSP_CONNECTION_ID				ConnectionId;		// Set after conn setup

} ATMSP_CONN_BLOCK, *PATMSP_CONN_BLOCK;


//
//  Global data structure.
//
typedef struct _ATMSP_GLOBAL_INFO
{
	RWAN_HANDLE						RWanSpHandle;
	RWAN_NDIS_AF_CHARS				AfChars;
	RWAN_HANDLE						RWanProtHandle;
	NDIS_STRING						AtmSpDeviceName;
	LARGE_INTEGER					StartTime;
	LIST_ENTRY						AfList;				// List of AF Blocks
	ULONG							AfListSize;			// Size of above
	RWAN_TDI_PROTOCOL_CHARS			TdiChars;

} ATMSP_GLOBAL_INFO, *PATMSP_GLOBAL_INFO;



#define ATMSP_AF_MAJOR_VERSION		3
#define ATMSP_AF_MINOR_VERSION		1


//
//  Overlayed at the AddressType field of struct _TA_ADDRESS is the
//  Sockets ATM address structure, sockaddr_atm, which is defined as
//
//  typedef struct sockaddr_atm {
//		u_short satm_family;
//		ATM_ADDRESS satm_number;
//		ATM_BHLI satm_bhli;
//		ATM_BLLI satm_blli;
//  } sockaddr_atm;
//
//  Ideally we want satm_number to be overlayed with the first byte
//  of Address[] in the _TA_ADDRESS structure, but because of 4-byte
//  packing of sockaddr_atm, there is a hidden u_short just following
//  satm_family.
//
//  The following macro accesses the "true" local version of the ATM
//  socket address given a pointer to the start of Address[i] within
//  struct _TA_ADDRESS.
//
#define TA_POINTER_TO_ATM_ADDR_POINTER(_pTransportAddr)	\
			(ATMSP_SOCKADDR_ATM UNALIGNED *)((PUCHAR)(_pTransportAddr) + sizeof(USHORT))

//
//  The following macro defines the length of an ATM address as required
//  in a TA_ADDRESS Length field.
//
#define TA_ATM_ADDRESS_LENGTH	(sizeof(ATMSP_SOCKADDR_ATM) + sizeof(USHORT))


//
//  Header length of a Transport Address.
//
#define TA_HEADER_LENGTH	(FIELD_OFFSET(TRANSPORT_ADDRESS, Address->Address))

typedef struct _ATMSP_EVENT
{
	NDIS_EVENT			Event;
	NDIS_STATUS			Status;

} ATMSP_EVENT, *PATMSP_EVENT;

#endif // __TDI_ATM_ATMSP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\atm\winsock\wshatm.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    D:\nt\private\net\sockets\wshatm\wshatm.c

Abstract:

    This module contains necessary routines for the ATM Windows Sockets
    Helper DLL.  This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use ATM as a transport.

Revision History:

    arvindm              20-May-1997    Created based on TCP/IP's helper DLL, wshtcpip

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <tdi.h>

#include <winsock2.h>
#include <mswsock.h>
#include <ws2atm.h>
#include <wsahelp.h>

#include <tdistat.h>
#include <tdiinfo.h>

#include <rwanuser.h>

typedef unsigned long   ulong;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned char   uchar;
#define TL_INSTANCE 0

#include <ws2atmsp.h>

#define NT // temporarily needed by tdiinfo.h...

#include <tdiinfo.h>

#include <basetyps.h>
#include <nspapi.h>

#define ATM_NAME L"ATM"
#define RWAN_NAME L"RawWan"

#define ATM_ADDR_SIZE                           20
#define ATM_ADDR_BLANK_CHAR                     L' '
#define ATM_ADDR_PUNCTUATION_CHAR       L'.'
#define ATM_ADDR_E164_START_CHAR        '+'

#define ATM_AAL5_SOCK_TYPE                      SOCK_RAW


#define ATM_WSA_MULTIPOINT_FLAGS        (WSA_FLAG_MULTIPOINT_C_ROOT |   \
                                                                         WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                                                         WSA_FLAG_MULTIPOINT_D_ROOT |   \
                                                                         WSA_FLAG_MULTIPOINT_D_LEAF)

//
// Define valid flags for WSHOpenSocket2().
//
#define VALID_ATM_FLAGS                         (WSA_FLAG_OVERLAPPED |                  \
                                                                         ATM_WSA_MULTIPOINT_FLAGS)

//
// Maximum expected size of ATM Connection Options: this includes the
// base QOS structure, plus all possible IEs.
//
#if 0
#define MAX_ATM_OPTIONS_LENGTH          \
                                        sizeof(QOS) + \
                                        sizeof(Q2931_IE) + sizeof(AAL_PARAMETERS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_TRAFFIC_DESCRIPTOR_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_BROADBAND_BEARER_CAPABILITY_IE) + \
                                        (3 * (sizeof(Q2931_IE) + sizeof(ATM_BLLI_IE))) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CALLED_PARTY_NUMBER_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CALLED_PARTY_SUBADDRESS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CALLING_PARTY_SUBADDRESS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_CAUSE_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_QOS_CLASS_IE) + \
                                        sizeof(Q2931_IE) + sizeof(ATM_TRANSIT_NETWORK_SELECTION_IE)

#else
//
//  Need much more with ATMUNI 4.0...
//
#define MAX_ATM_OPTIONS_LENGTH  1024
#endif

#if DBG1
#define DBGPRINT(stmt)          { DbgPrint ("WSHATM: "); DbgPrint stmt; }
#else
#define DBGPRINT(stmt)
#endif // DBG1

#if DBG
extern
PVOID
MyRtlAllocateHeap(
        IN      PVOID   HeapHandle,
        IN      ULONG   Flags,
        IN      ULONG   Size,
        IN      ULONG   LineNumber
        );
extern
VOID
MyRtlFreeHeap(
        IN PVOID        HeapHandle,
        IN ULONG        Flags,
        IN PVOID        MemPtr,
        IN ULONG        LineNumber
        );
#define RTL_ALLOCATE_HEAP(_Handle, _Flags, _Size)       MyRtlAllocateHeap(_Handle, _Flags, _Size, __LINE__)
#define RTL_FREE_HEAP(_Handle, _Flags, _Memptr) MyRtlFreeHeap(_Handle, _Flags, _Memptr, __LINE__)
#else
#define RTL_ALLOCATE_HEAP(_Handle, _Flags, _Size)       RtlAllocateHeap(_Handle, _Flags, _Size)
#define RTL_FREE_HEAP(_Handle, _Flags, _Memptr) RtlFreeHeap(_Handle, _Flags, _Memptr)
#endif

#define ATM_AAL5_PACKET_SIZE            65535

//
// Structure and variables to define the triples supported by ATM. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE AtmMappingTriples[] = {
                                       AF_ATM,    ATM_AAL5_SOCK_TYPE, ATMPROTO_AAL5,
                                       AF_ATM,    ATM_AAL5_SOCK_TYPE, 0,
                                                                           AF_ATM,    SOCK_RAW,       ATMPROTO_AAL5,
                                       AF_ATM,    SOCK_RAW,       0,
                                       AF_ATM,    0,              ATMPROTO_AAL5,
                                       AF_UNSPEC, 0,              ATMPROTO_AAL5,
                                       AF_UNSPEC, ATM_AAL5_SOCK_TYPE, ATMPROTO_AAL5,
                                       AF_UNSPEC, SOCK_RAW,       ATMPROTO_AAL5
                                                                         };


//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define ATM_UNI_VERSION                 0x00030001      // For UNI 3.1

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // ATM AAL5
        //

        {
            XP1_GUARANTEED_ORDER                    // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                // | XP1_PARTIAL_MESSAGE
                | XP1_IFS_HANDLES
                | XP1_SUPPORT_MULTIPOINT
                | XP1_MULTIPOINT_DATA_PLANE
                | XP1_MULTIPOINT_CONTROL_PLANE
                | XP1_QOS_SUPPORTED,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            ATM_UNI_VERSION,                        // iVersion
            AF_ATM,                                 // iAddressFamily
            sizeof(sockaddr_atm),                   // iMaxSockAddr
            sizeof(sockaddr_atm),                   // iMinSockAddr
            ATM_AAL5_SOCK_TYPE,                     // iSocketType
            ATMPROTO_AAL5,                          // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            ATM_AAL5_PACKET_SIZE,                   // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD ATM AAL5"                       // szProtocol
        }
    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID AtmProviderGuid = { /* {C3656046-3AAF-11d1-A8C3-00C04FC99C9C} */
    0xC3656046,
    0x3AAF,
    0x11D1,
    {0xA8, 0xC3, 0x00, 0xC0, 0x4F, 0xC9, 0x9C, 0x9C}
    };

//
// Given a digit (0-9) represented in ANSI, return its WCHAR representation
//
#define ANSI_TO_WCHAR(_AnsiDigit)       \
                        (L'0' + (WCHAR)((_AnsiDigit) - '0'))


//
// Given a hex digit value (0-15), return its WCHAR representation
// (i.e. 0 -> L'0', 12 -> L'C')
//
#define DIGIT_TO_WCHAR(_Value)          \
                        (((_Value) > 9)? (L'A' + (WCHAR)((_Value) - 10)) :      \
                                                         (L'0' + (WCHAR)((_Value) - 0 )))

//
// The socket context structure for this DLL.  Each open ATM socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHATM_SOCKET_CONTEXT {
    INT                         AddressFamily;
    INT                         SocketType;
    INT                         Protocol;
    INT                         ReceiveBufferSize;
    SOCKET                              SocketHandle;
    DWORD                       Flags;
    DWORD                       LocalFlags;
    ATM_CONNECTION_ID   ConnectionId;

} WSHATM_SOCKET_CONTEXT, *PWSHATM_SOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE ATM_AAL5_PACKET_SIZE

//
// LocalFlags in WSHATM_SOCKET_CONTEXT:
//
#define WSHATM_SOCK_IS_BOUND                            0x00000001
#define WSHATM_SOCK_IS_PVC                                      0x00000004
#define WSHATM_SOCK_ASSOCIATE_PVC_PENDING       0x00000008


//
// Forward declarations of internal routines.
//

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

INT
WSHAtmSetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength
    );

INT
WSHAtmGetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    );

INT
AtmQueryAtmGlobalInformation(
        IN ATM_OBJECT_ID ObjectId,
        IN LPVOID pContext,
        IN DWORD ContextLength,
        IN LPVOID OutputBuffer,
        IN DWORD OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
        );

INT
AtmSetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

INT
AtmGetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    );

INT
AtmSetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

INT
AtmGetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    );

INT
AtmAssociatePVC(
    IN SOCKET SocketHandle,
        IN PVOID HelperDllSocketContext,
        IN HANDLE TdiAddressObjectHandle,
        IN HANDLE TdiConnectionObjectHandle,
        IN LPVOID InputBuffer,
        IN DWORD InputBufferLength
        );

INT
AtmDoAssociatePVC(
        IN PWSHATM_SOCKET_CONTEXT Context,
        IN HANDLE TdiAddressObjectHandle
        );



BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    DBGPRINT(("DllInitialize, Reason %d\n", Reason));

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_ATM *sockaddr = (PSOCKADDR_ATM)Sockaddr;
    ULONG i;

        DBGPRINT(("GetSockaddrType: SockaddrLength %d, satm_family %d, AddrType x%x\n",
                                        SockaddrLength, sockaddr->satm_family, sockaddr->satm_number.AddressType));

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->satm_family != AF_ATM ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_ATM) ) {
        return WSAEFAULT;
    }

#if 0
    //
    // The ATM address part cannot be "absent".
    //
    if ( sockaddr->satm_number.AddressType == SAP_FIELD_ABSENT ) {
        return WSAEINVAL;
    }
#endif

    if ( sockaddr->satm_number.NumofDigits > ATM_ADDR_SIZE ) {
        return WSAEINVAL;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address and endpoint portions
        // of the sockaddr.
    //

    if ( sockaddr->satm_number.AddressType == SAP_FIELD_ANY &&
                 sockaddr->satm_blli.Layer2Protocol == SAP_FIELD_ANY &&
                 sockaddr->satm_blli.Layer3Protocol == SAP_FIELD_ANY &&
                 sockaddr->satm_bhli.HighLayerInfoType == SAP_FIELD_ANY ) {

        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;

    } else if ( sockaddr->satm_number.AddressType == SAP_FIELD_ABSENT ) {

        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;

        } else {

        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;

    }

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL. Currently there are none
    supported.

    This is called by the winsock DLL when a level/option name
        combination is passed to getsockopt() that the winsock DLL does
        not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

        DBGPRINT(("GetSocketInformation: Level %d, OptionName %d, OptionLength %d\n",
                        Level, OptionName, *OptionLength));

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        err = NO_ERROR;

    } else {

        switch ( OptionName ) {

        case SO_MAX_MSG_SIZE:

                        if ( TdiConnectionObjectHandle == NULL ) {

                                DbgPrint("wshatm: SO_MAX_MSG_SIZE: immed return\n");
                                if ( *OptionLength >= sizeof(DWORD) ) {
                                
                                        *(LPDWORD)OptionValue = DEFAULT_RECEIVE_BUFFER_SIZE;
                                        *OptionLength = sizeof(DWORD);
                                        
                                        err = NO_ERROR;
                                
                                } else {

                                        err = WSAEFAULT;
                                
                                }

                        } else {

                                DbgPrint("wshatm: SO_MAX_MSG_SIZE: querying driver\n");
                                err = AtmGetGenericObjectInformation(
                                                TdiConnectionObjectHandle,
                                                IOCTL_RWAN_GENERIC_CONN_HANDLE_QUERY,
                                                RWAN_OID_CONN_OBJECT_MAX_MSG_SIZE,
                                                NULL,   // No Input buffer
                                                0,              // Input Buffer length
                                                OptionValue,    // Output buffer
                                                *OptionLength,  // Output buffer length
                                                OptionLength    // NumberOfBytesReturned
                                                );

                        }
                        break;
                
                default:

                        err = WSAENOPROTOOPT;
                        break;

                }
        }

        return err;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For ATM, a wildcard address has AddressType and BHLI and
    BLLI Type fields set to SAP_FIELD_ANY.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
        PSOCKADDR_ATM   sockaddr;

        DBGPRINT(("GetWildcardAddress\n"));

        sockaddr = (PSOCKADDR_ATM)Sockaddr;

    if ( *SockaddrLength < sizeof(SOCKADDR_ATM) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_ATM);


        //
        // Prepare the ATM wild card address.
        //
    RtlZeroMemory( sockaddr, sizeof(SOCKADDR_ATM) );

    sockaddr->satm_family = AF_ATM;
    sockaddr->satm_number.AddressType = SAP_FIELD_ABSENT;
        sockaddr->satm_blli.Layer2Protocol = SAP_FIELD_ANY;
        sockaddr->satm_blli.Layer3Protocol = SAP_FIELD_ANY;
        sockaddr->satm_bhli.HighLayerInfoType = SAP_FIELD_ANY;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

        DBGPRINT(("GetWinsockMapping\n"));

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(AtmMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(AtmMappingTriples) / sizeof(AtmMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    RtlMoveMemory(
        Mapping->Mapping,
        AtmMappingTriples,
        sizeof(AtmMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{
    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context;
    DWORD multipointFlags;
    UNICODE_STRING atmDeviceName;

    //
    // Determine whether this is an ATM socket.
    //

    DBGPRINT(("WSHOpenSocket2: AF %d, Type %d, Proto %d\n",
                        *AddressFamily, *SocketType, *Protocol));

    if ( IsTripleInList(
             AtmMappingTriples,
             sizeof(AtmMappingTriples) / sizeof(AtmMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's an ATM socket. Check the flags.
        //

        if ( ( Flags & ~VALID_ATM_FLAGS ) != 0 ) {

            DBGPRINT(("WSHOpenSocket2: Bad flags x%x\n", Flags));
            return WSAEINVAL;

        }

        if ( ( Flags & ATM_WSA_MULTIPOINT_FLAGS ) != 0 ) {

                //
                //  The only multipoint combinations allowed are:
                //
                //  1. C_ROOT|D_ROOT
                //  2. C_LEAF|D_LEAF
                //

                multipointFlags = ( Flags & ATM_WSA_MULTIPOINT_FLAGS );

                if ( ( multipointFlags != (WSA_FLAG_MULTIPOINT_C_ROOT | WSA_FLAG_MULTIPOINT_D_ROOT) ) &&
                         ( multipointFlags != (WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF) ) ) {

                    DBGPRINT(("WSHOpenSocket2: Bad multipoint flags x%x\n",
                                        Flags));
                        
                        return WSAEINVAL;

                } else {

                        DBGPRINT(("WSHOpenSocket2: Good multipoint flags x%x\n", Flags));

                }
        }

        //
        // Return the canonical form of a ATM socket triple.
        //

        *AddressFamily = AtmMappingTriples[0].AddressFamily;
        *SocketType = AtmMappingTriples[0].SocketType;
        *Protocol = AtmMappingTriples[0].Protocol;

        //
        // Prepare the name of the TDI device.
        //

        RtlInitUnicodeString( &atmDeviceName, DD_ATM_DEVICE_NAME );

        TransportDeviceName->Buffer = RTL_ALLOCATE_HEAP( RtlProcessHeap( ), 0, atmDeviceName.MaximumLength );

        if ( TransportDeviceName->Buffer == NULL ) {
                
                return WSAEFAULT;

        }

        TransportDeviceName->MaximumLength = atmDeviceName.MaximumLength;
        TransportDeviceName->Length = 0;

        RtlCopyUnicodeString(TransportDeviceName, &atmDeviceName);

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        DBGPRINT(("WSHOpenSocket2: Triple not found!\n"));

        if ( *Protocol != ATMPROTO_AAL5 ) {
        
                return WSAEPROTONOSUPPORT;
        
        }

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RTL_ALLOCATE_HEAP( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->LocalFlags = 0;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.
    //

    *NotificationEvents =
            WSH_NOTIFY_BIND | WSH_NOTIFY_LISTEN | WSH_NOTIFY_CLOSE;

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;

    DBGPRINT(("WSHOpenSocket2 success: AF %d, Type %d, Proto %d\n",
                        *AddressFamily, *SocketType, *Protocol));

    return NO_ERROR;

} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

    If we see a LISTEN event, we call setsockopt() to force AFD to
    allocate data buffers (for options) for incoming connection requests
    on this socket.

    If we see a BIND event for a socket to be used for multipoint
    activity, we tell RAWWAN that the associated address object is
    of multipoint type.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;
    INT Option;
    INT OptionLength = sizeof(Option);
    PCHAR pOption = (PCHAR)&Option;

        DBGPRINT(("Notify: Event = %d\n", NotifyEvent));

        err = NO_ERROR;

        switch (NotifyEvent)
        {
                case WSH_NOTIFY_BIND:

                        DBGPRINT(("NotifyBind: context %x, Flags %x, LocalFlags %x\n",
                                        context, context->Flags, context->LocalFlags));

                        //
                        //  Request the Winsock DLL to set the options.
                        //
                        Option = MAX_ATM_OPTIONS_LENGTH;

                        err = setsockopt(
                                        SocketHandle,
                                        SOL_SOCKET,
                                        SO_CONNOPTLEN,
                                        pOption,
                                        OptionLength
                                        );

                        if ( err != NO_ERROR ) {

                                DBGPRINT(("WSHATM: NotifyBind: setsockopt SO_CONNOPTLEN err %x\n", err));
                                break;
                        }

                        context->LocalFlags |= WSHATM_SOCK_IS_BOUND;

                        if ( ( context->Flags & ATM_WSA_MULTIPOINT_FLAGS ) != 0 ) {
                                
                                //
                                //  Prepare flags for RAWWAN.
                                //
                                Option = 0;

                                if ( context->Flags & WSA_FLAG_MULTIPOINT_C_ROOT ) {

                                        Option |= RWAN_AOFLAG_C_ROOT;
                                
                                }
                        
                                if ( context->Flags & WSA_FLAG_MULTIPOINT_C_LEAF ) {

                                        Option |= RWAN_AOFLAG_C_LEAF;
                                
                                }

                                if ( context->Flags & WSA_FLAG_MULTIPOINT_D_ROOT ) {

                                        Option |= RWAN_AOFLAG_D_ROOT;
                                
                                }

                                if ( context->Flags & WSA_FLAG_MULTIPOINT_D_LEAF ) {

                                        Option |= RWAN_AOFLAG_D_LEAF;
                                
                                }

                                //
                                //  Inform RAWWAN about the Multipoint nature of this
                                //  Address Object.
                                //
                                err = AtmSetGenericObjectInformation(
                                                TdiAddressObjectHandle,
                                                IOCTL_RWAN_GENERIC_ADDR_HANDLE_SET,
                                                RWAN_OID_ADDRESS_OBJECT_FLAGS,
                                                &Option,
                                                sizeof(Option)
                                                );

                                DBGPRINT(("Notify: Bind Notify on PMP endpoint, Option x%x, ret = %d\n",
                                                Option, err));
                        }
                        else if ( ( context->LocalFlags & WSHATM_SOCK_ASSOCIATE_PVC_PENDING ) ) {

                                DBGPRINT(("Notify: Bind Notify will Associate PVC\n"));
                                err = AtmDoAssociatePVC(
                                                context,
                                                TdiAddressObjectHandle
                                                );
                        }

                        break;
                                
                case WSH_NOTIFY_CLOSE:

                        RTL_FREE_HEAP( RtlProcessHeap( ), 0, context );
                        break;
                
                case WSH_NOTIFY_LISTEN:
                        //
                        //  Request the Winsock DLL to set the options.
                        //
                        Option = MAX_ATM_OPTIONS_LENGTH;

                        err = setsockopt(
                                        SocketHandle,
                                        SOL_SOCKET,
                                        SO_CONNOPTLEN,
                                        pOption,
                                        OptionLength
                                        );
                        break;

                default:
                        err = WSAEINVAL;
                        break;
        
        }

    return err;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  We don't support any
    options at present.

    This routine is called by the winsock DLL when a level/option
        name combination is passed to setsockopt() that the winsock DLL
        does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATM_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

        DBGPRINT(("SetSocketInformation: Level %d, Option x%x\n", Level, OptionName));

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RTL_ALLOCATE_HEAP( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );
            context->SocketHandle = SocketHandle;

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHATM_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHATM_SOCKET_CONTEXT parentContext;
            INT one = 1;
            INT zero = 0;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHATM_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );


            return NO_ERROR;
        }
    }


        return WSAENOPROTOOPT;

#if 0
    //
    // Handle socket-level options.
    //
    optionValue = *OptionValue;

    switch ( OptionName ) {

    case SO_RCVBUF:

        context->ReceiveBufferSize = optionValue;

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;
#endif

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO atmProtocolInfo;
    PPROTOCOL_INFO udpProtocolInfo;
    BOOL useAtm = FALSE;
    DWORD i;

    lpTransportKeyName;         // Avoid compiler warnings.

        DBGPRINT(("EnumProtocols\n"));

    //
    // Make sure that the caller cares about ATM.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == ATMPROTO_AAL5 ) {
                useAtm = TRUE;
            }
        }

    } else {

        useAtm = TRUE;
    }

    if ( !useAtm ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 1) +
                        ( (wcslen( ATM_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in ATM info, if requested.
    //

    if ( useAtm ) {

        atmProtocolInfo = lpProtocolBuffer;

        atmProtocolInfo->dwServiceFlags = XP_GUARANTEED_ORDER |
                                              XP_MESSAGE_ORIENTED |
                                              XP_SUPPORTS_MULTICAST |
                                              XP_BANDWIDTH_ALLOCATION ;
        atmProtocolInfo->iAddressFamily = AF_ATM;
        atmProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_ATM);
        atmProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_ATM);
        atmProtocolInfo->iSocketType = ATM_AAL5_SOCK_TYPE;
        atmProtocolInfo->iProtocol = ATMPROTO_AAL5;
        atmProtocolInfo->dwMessageSize = 1;
        atmProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( ATM_NAME ) + 1) * sizeof(WCHAR) ) );
        wcscpy( atmProtocolInfo->lpProtocol, ATM_NAME );

        DBGPRINT(("EnumProtocols: lpProtocolBuffer %x, lpProtocol %x, BufLen %d\n",
                                lpProtocolBuffer,
                                atmProtocolInfo->lpProtocol,
                                *lpdwBufferLength));

        }

    *lpdwBufferLength = bytesRequired;

    return (1);

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             Protocol == List[i].Protocol
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList



INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

    TBD: Needs a Lot Of Work!

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{

        INT err;

        if( Flags != JL_SENDER_ONLY ) {

                return WSAEINVAL;
        
        }

        if (SocketQOS)
        {
                err = WSHAtmSetQoS(
                                        LeafHelperDllSocketContext,
                                        LeafSocketHandle,
                                        SocketQOS,
                                        sizeof(*SocketQOS)
                                        );
        }

        return NO_ERROR;

} // WSHJoinLeaf


INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
#if 1
        return WSAEINVAL;
#else

    LPSOCKADDR_ATM addr;

    if( *SockaddrLength < sizeof(SOCKADDR_ATM) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_ATM);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_ATM)Sockaddr;

    RtlZeroMemory(
        addr,
        sizeof(*addr)
        );

    addr->satm_family = AF_ATM;
    addr->satm_number.s_addr = htonl( INADDR_BROADCAST );

    return NO_ERROR;
#endif // 1

} // WSAGetBroadcastSockaddr


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "RawWan".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

        DBGPRINT(("WSHGetWSAProtocolInfo: Provider Name: %ws\n", ProviderName));

    if( _wcsicmp( ProviderName, L"RawWan" ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR string[64];
    PWCHAR pstring;
    INT length; // Number of WCHARs filled into string
    UINT        i;
    LPSOCKADDR_ATM addr;
    UCHAR Val;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_ATM) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_ATM)Address;

    if( addr->satm_family != AF_ATM ) {

        return WSAEINVAL;

    }

    if ( addr->satm_number.NumofDigits > ATM_ADDR_SIZE ) {
        return WSAEINVAL;
    }

    //
    // Do the conversion.
    //
    length = 0;
    pstring = string;

    //
    // If this is an E.164 address, prepend a '+'.
    // Each entry in the array in satm_number consists of one
        // digit coded in IA5 (ANSI).
    //
    if ( addr->satm_number.AddressType == ATM_E164 ) {

        *pstring++ = L'+';
        length++;

        for ( i = 0; i < addr->satm_number.NumofDigits; i++ ) {

                if ( !iswdigit(addr->satm_number.Addr[i]) ) {
                        return WSAEINVAL;
                    }

                *pstring++ = ANSI_TO_WCHAR(addr->satm_number.Addr[i]);
        }

        length += addr->satm_number.NumofDigits;

    } else {

        //
        // This must be NSAP format. Each entry in the array
                // is a full hex byte (two BCD digits). We'll unpack
                // each array entry into two characters.
        //
        for ( i = 0; i < addr->satm_number.NumofDigits; i++ ) {

                Val = (addr->satm_number.Addr[i] >> 4);
                        *pstring++ = DIGIT_TO_WCHAR(Val);

                Val = (addr->satm_number.Addr[i] & 0xf);
                        *pstring++ = DIGIT_TO_WCHAR(Val);
                }

                length += (2 * addr->satm_number.NumofDigits);
        }

        //
        // Terminate the string.
        //
        *pstring = L'\0';

    length++;   // account for terminator

    if( *AddressStringLength < (DWORD)length ) {

        return WSAEFAULT;

    }

    *AddressStringLength = (DWORD)length;

    RtlCopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    WCHAR string[2*ATM_ADDR_SIZE+1];
    UNICODE_STRING unistring;
    CHAR ansistring[2*ATM_ADDR_SIZE+1];
    ANSI_STRING ansstring;
    PCHAR src;
    PCHAR dst;
    LPWSTR terminator;
    LPSOCKADDR_ATM addr;
    PWCHAR s, d;
    INT numDigits, i;
    NTSTATUS status;

    //
    // Quick sanity checks.
    //

    if( AddressString == NULL ||
        Address == NULL ||
        AddressLength == NULL ||
        *AddressLength < sizeof(SOCKADDR_ATM) ) {

        return WSAEFAULT;

    }

    if( AddressFamily != AF_ATM ) {

        DBGPRINT(("StrToAddr: invalid addrfam %d\n", AddressFamily));
        return WSAEINVAL;

    }


    addr = (LPSOCKADDR_ATM)Address;
    RtlZeroMemory(
        Address,
        sizeof(SOCKADDR_ATM)
        );

    //
    // Strip off all punctuation characters (spaces and periods).
    //
    for ( numDigits = 0, s = AddressString, d = string;
          (numDigits <= sizeof(WCHAR)*ATM_ADDR_SIZE) && (*s != L'\0');
          s++ ) {

                if ( *s == ATM_ADDR_BLANK_CHAR ||
                         *s == ATM_ADDR_PUNCTUATION_CHAR ) {
                         continue;
                }

                *d++ = *s;
                numDigits ++;
        }

        if ( numDigits == 0 ) {

        DBGPRINT(("StrToAddr[%ws]: numdigits after stripping is 0!\n",
                        AddressString));
                return WSAEINVAL;
        }

        //
        // Terminate it and convert into Unicode string.
        //
        *d = L'\0';

        RtlInitUnicodeString(&unistring, string);

        //
        // Convert it into an ANSI string.
        //
        ansstring.Buffer = ansistring;
        ansstring.MaximumLength = 2*ATM_ADDR_SIZE + 1;
        ansstring.Length = 0;

        status = RtlUnicodeStringToAnsiString(&ansstring, &unistring, FALSE);

        if ( status != STATUS_SUCCESS ) {
                DBGPRINT(("StrToAddr[%ws]: RtlUnicodeToAnsi failed (%x)\n",
                                string, status));
                return WSAEINVAL;
        }

        addr->satm_family = AF_ATM;

        src = ansistring;

        if ( *src == ATM_ADDR_E164_START_CHAR ) {

                src ++;
                numDigits --;

                if ( numDigits == 0 ) {
                        DBGPRINT(("StrToAddr[%ws]: AnsiString:[%s], numDigits is 0!\n",
                                                string, ansistring));
                        return WSAEINVAL;
                }

                addr->satm_number.AddressType = ATM_E164;
                addr->satm_number.NumofDigits = numDigits;

                RtlCopyMemory(addr->satm_number.Addr, src, numDigits);

        } else {

                UCHAR           hexString[3];
                ULONG           Val;

                hexString[2] = 0;

                if ( numDigits != 2 * ATM_ADDR_SIZE ) {
                        return WSAEINVAL;
                }

                addr->satm_number.AddressType = ATM_NSAP;
                addr->satm_number.NumofDigits = numDigits/2;

                for ( i = 0; i < ATM_ADDR_SIZE; i++ ) {

                        hexString[0] = *src++;
                        hexString[1] = *src++;

                        status = RtlCharToInteger(hexString, 16, &Val);

                        if ( status != STATUS_SUCCESS ) {
                                DBGPRINT(("StrToAtm[%ws]: index %d, hexString: %s, CharToInt %x\n",
                                                string, hexString, status));
                                return WSAEINVAL;
                        }

                        addr->satm_number.Addr[i] = (UCHAR)Val;
                }

        }

        addr->satm_blli.Layer2Protocol = SAP_FIELD_ABSENT;
        addr->satm_blli.Layer3Protocol = SAP_FIELD_ABSENT;
        addr->satm_bhli.HighLayerInfoType = SAP_FIELD_ABSENT;

    *AddressLength = sizeof(SOCKADDR_ATM);

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "RawWan".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, RWAN_NAME ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &AtmProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid


INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    INT err;
    PWSHATM_SOCKET_CONTEXT context;

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

        context = (PWSHATM_SOCKET_CONTEXT)HelperDllSocketContext;
    *NeedsCompletion = TRUE;

        DBGPRINT(("WSHIoctl: IoControlCode x%x, InBuf: x%x/%d, OutBuf: x%x/%d\n",
                                        IoControlCode,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength));

        switch (IoControlCode) {
        
        case SIO_ASSOCIATE_PVC:

                context->SocketHandle = SocketHandle;
                err = AtmAssociatePVC(
                                        SocketHandle,
                                        HelperDllSocketContext,
                                        TdiAddressObjectHandle,
                                        TdiConnectionObjectHandle,
                                        InputBuffer,
                                        InputBufferLength
                                        );

                DBGPRINT(("WSHIoctl: ASSOCIATE_PVC: context %x, LocalFlags %x, err %d\n",
                                        context, context->LocalFlags, err));

                if ( (err == NO_ERROR) && 
                         (( context->LocalFlags & WSHATM_SOCK_IS_BOUND ) == 0 )) { 

                        SOCKADDR_ATM    addr;
                        INT                             len = sizeof(addr);

                        (VOID) WSHGetWildcardSockaddr (
                                        HelperDllSocketContext,
                                        (struct sockaddr *)&addr,
                                        &len);

                        DBGPRINT(("WSHIoctl: ASSOCIATE_PVC: will bind\n"));
                        err = bind(SocketHandle, (struct sockaddr *)&addr, len);

#if DBG
                        if ( err != NO_ERROR ) {

                                DbgPrint("WSHATM: bind err %d, context %x, LocalFlags %x\n",
                                                        err, context, context->LocalFlags);
                        
                        }
#endif
                
                }

                if ( err == NO_ERROR ) {

                        SOCKADDR_ATM    addr;
                        INT                             len = sizeof(addr);

                        (VOID) WSHGetWildcardSockaddr (
                                        HelperDllSocketContext,
                                        (struct sockaddr *)&addr,
                                        &len);

                        addr.satm_family = AF_ATM;
                        addr.satm_number.AddressType = ATM_NSAP;
                        addr.satm_number.NumofDigits = ATM_ADDR_SIZE;

                        err = WSAConnect(
                                        SocketHandle,
                                        (struct sockaddr *)&addr,
                                        len,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);


                        if ( err != NO_ERROR ) {
                                DBGPRINT(("WSHIoctl: connect (%d) returned %d\n",
                                                SocketHandle, err));

                                if ( err == SOCKET_ERROR ) {
                                        err = WSAGetLastError();
                                }
                        }
                }

                break;

        case SIO_SET_QOS:
                err = WSHAtmSetQoS(
                                        HelperDllSocketContext,
                                        SocketHandle,
                                        InputBuffer,
                                        InputBufferLength
                                        );
                break;

        case SIO_GET_QOS:
                err = WSHAtmGetQoS(
                                        HelperDllSocketContext,
                                        SocketHandle,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        NumberOfBytesReturned
                                        );
                break;

        case SIO_GET_GROUP_QOS:
                *NumberOfBytesReturned = 0;
                err = NO_ERROR;
                break;

        case SIO_SET_GROUP_QOS:
                *NumberOfBytesReturned = 0;
                err = WSAEOPNOTSUPP;
                break;

        case SIO_GET_NUMBER_OF_ATM_DEVICES:
                err = AtmQueryAtmGlobalInformation(
                                ATMSP_OID_NUMBER_OF_DEVICES,
                                NULL,
                                0,
                                OutputBuffer,
                                OutputBufferLength,
                                NumberOfBytesReturned
                                );
                break;
        
        case SIO_GET_ATM_ADDRESS:
                err = AtmQueryAtmGlobalInformation(
                                ATMSP_OID_ATM_ADDRESS,
                                InputBuffer,
                                InputBufferLength,
                                OutputBuffer,
                                OutputBufferLength,
                                NumberOfBytesReturned
                                );
                break;
        
        case SIO_GET_ATM_CONNECTION_ID:

                if ( TdiConnectionObjectHandle == NULL ) {

                        //
                        //  Check if this is a PVC. If so, the Connection ID is
                        //  available locally.
                        //
                        if ( context && ( context->LocalFlags & WSHATM_SOCK_IS_PVC )) {

                                if ( ( OutputBuffer != NULL ) &&
                                         ( OutputBufferLength >= sizeof(ATM_CONNECTION_ID) ) ) {
                                
                                        ATM_CONNECTION_ID * pConnId = OutputBuffer;

                                        *pConnId = context->ConnectionId;

                                        err = NO_ERROR;

                                } else {

                                        err = WSAEFAULT;
                                
                                }

                        } else {

                                err = WSAENOTCONN;
                        
                        }
                
                } else {

                        err = AtmGetAtmObjectInformation(
                                        TdiConnectionObjectHandle,
                                        IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_QUERY,
                                        ATMSP_OID_CONNECTION_ID,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        NumberOfBytesReturned
                                        );
                }
                break;
                                        
        case SIO_ENABLE_CIRCULAR_QUEUEING:
                err = NO_ERROR;
                break;

        default:
                err = WSAEINVAL;
                break;
        }

    DBGPRINT(("WSHIoctl: IoControlCode x%x, returning %d\n",
                        IoControlCode, err));

    return err;

}   // WSHIoctl



INT
WSHAtmSetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength
    )
/*++

Routine Description:

        This routine is called to process a SIO_SET_QOS Ioctl. The QoS is represented
        by a basic QOS structure, and an optional provider-specific part. We first
        copy this two-part structure into a single flat buffer, and then call
        setsockopt(SO_CONNOPT) to get MSAFD to copy this down to AFD. Later, if/when
        a WSAConnect() is made, AFD will pass these "connection options" in the TDI
        connect to the transport.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

Return Value:

    INT - The completion status.

--*/
{
        INT                     err;
        LPQOS           lpQOS;

        PUCHAR          pQoSBuffer;                     // Flat buffer for use in SO_CONNOPT
        INT                     QoSBufferLength;
        LPQOS           lpOutputQOS;

        err = NO_ERROR;
        lpQOS = (LPQOS)InputBuffer;

        DBGPRINT(("SetQoS: Context x%x, Handle x%x, InBuf x%x, InBufLen %d\n",
                                HelperDllSocketContext,
                                SocketHandle,
                                InputBuffer,
                                InputBufferLength));
        do
        {
                if (lpQOS == NULL)
                {
                        err = WSAEINVAL;
                        break;
                }

                //
                //  Expect atleast the base QOS structure to be present.
                //
                if (InputBufferLength < sizeof(*lpQOS))
                {
                        err = WSAENOBUFS;
                        break;
                }

                //
                //  Sanity check the provider-specific part.
                //
                if (((lpQOS->ProviderSpecific.buf != NULL) &&
                         (lpQOS->ProviderSpecific.len == 0))
                                ||
                        ((lpQOS->ProviderSpecific.buf == NULL) &&
                         (lpQOS->ProviderSpecific.len != 0)))
                {
                        DBGPRINT(("lpQOS %x, buf %x, len %x, not consistent\n",
                                        lpQOS, lpQOS->ProviderSpecific.buf,
                                        lpQOS->ProviderSpecific.len));

                        err = WSAEINVAL;
                        break;
                }

                //
                //  Compute the total length we need.
                //
                QoSBufferLength = sizeof(QOS) + lpQOS->ProviderSpecific.len;

                pQoSBuffer = RTL_ALLOCATE_HEAP(RtlProcessHeap(), 0, QoSBufferLength);

                if (pQoSBuffer == NULL)
                {
                        err = WSAENOBUFS;
                        break;
                }

                lpOutputQOS = (LPQOS)pQoSBuffer;

                //
                //  Copy in the generic QOS part.
                //
                RtlCopyMemory(
                        lpOutputQOS,
                        lpQOS,
                        sizeof(QOS)
                        );

                //
                //  Copy in the provider-specific QOS just after the generic part.
                //
                if (lpQOS->ProviderSpecific.len != 0)
                {
                        RtlCopyMemory(
                                (PCHAR)pQoSBuffer+sizeof(QOS),
                                lpQOS->ProviderSpecific.buf,
                                lpQOS->ProviderSpecific.len
                                );
                        
                        //
                        //  Set up the offset to provider-specific part. Note that we
                        //  use the "buf" to mean the offset from the beginning of the
                        //  flat QOS buffer and not a pointer.
                        //
                        lpOutputQOS->ProviderSpecific.buf = (char FAR *)sizeof(QOS);
                }
                else
                {
                        lpOutputQOS->ProviderSpecific.buf = NULL;
                }


                //
                //  Request the Winsock DLL to set the options.
                //
                err = setsockopt(
                                SocketHandle,
                                SOL_SOCKET,
                                SO_CONNOPT,
                                pQoSBuffer,
                                QoSBufferLength
                                );

                RTL_FREE_HEAP(
                                RtlProcessHeap(),
                                0,
                                pQoSBuffer
                                );

                break;
        }
        while (FALSE);

        DBGPRINT(("SetQoS: returning err %d\n", err));
        return (err);
}



INT
WSHAtmGetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    )
/*++

Routine Description:

        This routine is called to process a SIO_GET_QOS Ioctl. We translate
        this to a "Get Connect Options" and ask MSAFD to get them for us.
        The connect options for ATM will contain the base QoS structure and
        optionally a provider-specific part that contains additional information
        elements.

        One of the places this might be called is when processing a WSAAccept
        with a condition function specified. MSAFD calls us to get the QoS,
        and we in turn request MSAFD to get SO_CONNOPT.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    OutputBuffer - Address of the Output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - where we return the number of bytes we filled into
        OutputBuffer.

Return Value:

    INT - The completion status.

--*/
{
        INT                     err;
        DWORD           BytesReturned;
        LPQOS           lpQOS;

        err = NO_ERROR;

        DBGPRINT(("GetQoS: Context x%x, Handle x%x, OutBuf x%x, OutBufLen %d\n",
                                HelperDllSocketContext,
                                SocketHandle,
                                OutputBuffer,
                                OutputBufferLength));

        do
        {
                //
                //  Expect atleast enough space to fit in the base QoS structure.
                //
                if (OutputBufferLength < sizeof(QOS))
                {
                        *NumberOfBytesReturned = MAX_ATM_OPTIONS_LENGTH;
                        err = WSAEFAULT;
                        break;
                }

                //
                //  Request the Winsock DLL to get the options.
                //
                BytesReturned = OutputBufferLength;
                err = getsockopt(
                                SocketHandle,
                                SOL_SOCKET,
                                SO_CONNOPT,
                                OutputBuffer,
                                &BytesReturned
                                );
        
                if ((err == NO_ERROR) && (BytesReturned != 0))
                {
                        *NumberOfBytesReturned = BytesReturned;

                        lpQOS = (LPQOS)OutputBuffer;

                        //
                        //  Fix up the provider-specific part, if any.
                        //
                        if (BytesReturned > sizeof(QOS))
                        {
                                lpQOS->ProviderSpecific.buf = (PCHAR)((PCHAR)lpQOS + sizeof(QOS));
                        }
                        else
                        {
                                lpQOS->ProviderSpecific.buf = NULL;
                                lpQOS->ProviderSpecific.len = 0;
                        }
                        DBGPRINT(("GetQoS: lpQOS %x, ProvSpec buf %x, len %d\n",
                                                lpQOS, lpQOS->ProviderSpecific.buf, lpQOS->ProviderSpecific.len));
                }
                else
                {
                        if (BytesReturned == 0)
                        {
                                //
                                //  Probably because we aren't connected yet? Let's return
                                //  all "NOT_SPECIFIED" values:
                                //
                                *NumberOfBytesReturned = sizeof(QOS);

                                lpQOS = (LPQOS)OutputBuffer;
                                lpQOS->ProviderSpecific.buf = NULL;
                                lpQOS->ProviderSpecific.len = 0;

                                lpQOS->SendingFlowspec.TokenRate =
                                lpQOS->SendingFlowspec.TokenBucketSize =
                                lpQOS->SendingFlowspec.PeakBandwidth =
                                lpQOS->SendingFlowspec.Latency =
                                lpQOS->SendingFlowspec.DelayVariation =
                                lpQOS->SendingFlowspec.ServiceType =
                                lpQOS->SendingFlowspec.MaxSduSize =
                                lpQOS->SendingFlowspec.MinimumPolicedSize = QOS_NOT_SPECIFIED;
                                lpQOS->ReceivingFlowspec = lpQOS->SendingFlowspec;

                        } else {

                                err = WSAGetLastError();
                        }
                }

                break;
        }
        while (FALSE);


        return (err);
}


INT
AtmAssociatePVC(
    IN SOCKET SocketHandle,
        IN PVOID HelperDllSocketContext,
        IN HANDLE TdiAddressObjectHandle,
        IN HANDLE TdiConnectionObjectHandle,
        IN LPVOID InputBuffer,
        IN DWORD InputBufferLength
        )
{
        INT err;
    PWSHATM_SOCKET_CONTEXT context;
    ATM_PVC_PARAMS * pInPvcParams;

        context = (PWSHATM_SOCKET_CONTEXT)HelperDllSocketContext;

        DBGPRINT(("AssociatePVC: InputBuffer %x, Length %d, sizeof(ATM_PVC_PARAMS) %d\n",
                        InputBuffer, InputBufferLength, sizeof(ATM_PVC_PARAMS)));

        do {

                if ( InputBuffer == NULL ||
                         InputBufferLength < sizeof(ATM_PVC_PARAMS) ) {
                        
                        err = WSAEFAULT;
                        break;
                }

                if ( context == NULL ) {

                        err = WSAEINVAL;
                        break;
                }

                //
                //  We want to allow the user to change the PVC info any number of times
                //  before connecting, but not after the fact.
                //
                if ( TdiConnectionObjectHandle != NULL ) {

                        err = WSAEISCONN;
                        break;
                }

                if ( context->LocalFlags & WSHATM_SOCK_IS_PVC ) {
                        //
                        //  Already associated. Fail this.
                        //

                        err = WSAEISCONN;
                        break;
                }


                //
                //  Use the standard QoS mechanism to associate the QOS info
                //  with this socket.
                //
                pInPvcParams = InputBuffer;

                err = setsockopt(
                                SocketHandle,
                                SOL_SOCKET,
                                SO_CONNOPT,
                                (PCHAR)&pInPvcParams->PvcQos,
                                InputBufferLength - (DWORD)((PUCHAR)&pInPvcParams->PvcQos - (PUCHAR)pInPvcParams)
                                );


                DBGPRINT(("AssociatePVC: setsockopt, ptr %x, length %d, ret %d\n",
                                &pInPvcParams->PvcQos,
                                InputBufferLength - (DWORD)((PUCHAR)&pInPvcParams->PvcQos - (PUCHAR)pInPvcParams),
                                err));
                                
                if ( err != NO_ERROR ) {

                        break;
                }

                //
                //  Store the Connection Id.
                //
                context->ConnectionId = pInPvcParams->PvcConnectionId;
                context->LocalFlags |= WSHATM_SOCK_IS_PVC;

                if ( TdiAddressObjectHandle == NULL ) {
                
                        //
                        // We've got an ASSOCIATE_PVC before this socket has been
                        // bound. Just remember this, so that we do the rest when
                        // the bind actually happens.
                        //
                        context->LocalFlags |= WSHATM_SOCK_ASSOCIATE_PVC_PENDING;
                        err = NO_ERROR;
                        break;
                }

                //
                //  The socket is bound, so send info about the PVC Connection
                //  ID to the transport.
                //
                err = AtmDoAssociatePVC(
                                context,
                                TdiAddressObjectHandle
                                );
                DBGPRINT(("AssociatePVC: DoAssociatePVC ret %d\n", err));

                break;
        }
        while (FALSE);

        DBGPRINT(("AssociatePVC: context Flags %x, LocalFlags %x, returning %d\n",
                        context? context->Flags: 0,
                        context? context->LocalFlags: 0,
                        err));

        return err;
}


INT
AtmDoAssociatePVC(
        IN PWSHATM_SOCKET_CONTEXT Context,
        IN HANDLE TdiAddressObjectHandle
        )
{
        INT err;

        DBGPRINT(("DoAssociatePVC: Context %x, LocalFlags %x\n",
                                Context, LocalFlags));

        Context->LocalFlags &= ~WSHATM_SOCK_ASSOCIATE_PVC_PENDING;

        err = AtmSetAtmObjectInformation(
                        TdiAddressObjectHandle,
                        IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_SET,
                        ATMSP_OID_PVC_ID,
                        &Context->ConnectionId,
                        sizeof(ATM_CONNECTION_ID)
                        );

        return err;
}


INT
AtmQueryAtmGlobalInformation(
        IN ATM_OBJECT_ID ObjectId,
        IN LPVOID pContext,
        IN DWORD ContextLength,
        IN LPVOID OutputBuffer,
        IN DWORD OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
        )
{
        INT err;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING deviceName;
    HANDLE deviceHandle = NULL;
    PIO_STATUS_BLOCK ioStatusBlock;
    PATM_QUERY_INFORMATION_EX pQueryInfo;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(ATM_QUERY_INFORMATION_EX) + ContextLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }


                //
                // Open a handle to the ATM device.
                //

                RtlInitUnicodeString(
                        &deviceName,
                        DD_ATM_DEVICE_NAME
                        );

                InitializeObjectAttributes(
                        &objectAttributes,
                        &deviceName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

                status = NtCreateFile(
                                        &deviceHandle,
                                        SYNCHRONIZE | GENERIC_EXECUTE,
                                        &objectAttributes,
                                        ioStatusBlock,
                                        NULL,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        FILE_OPEN_IF,
                                        FILE_SYNCHRONOUS_IO_NONALERT,
                                        NULL,
                                        0
                                        );

                if( !NT_SUCCESS(status) ) {

                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }

                        break;

                }

                pQueryInfo = (PATM_QUERY_INFORMATION_EX)(ioStatusBlock + 1);
                pQueryInfo->ObjectId = ObjectId;
                pQueryInfo->ContextLength = ContextLength;

                if ( pQueryInfo->ContextLength > 0 ) {

                        RtlCopyMemory(
                                pQueryInfo->Context,
                                pContext,
                                pQueryInfo->ContextLength
                                );

                }

                status = NtDeviceIoControlFile(
                                        deviceHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_QUERY,
                                        pQueryInfo,
                                        sizeof(ATM_QUERY_INFORMATION_EX) + ContextLength,
                                        OutputBuffer,
                                        OutputBufferLength
                                        );

                DBGPRINT(("DevIoControl (Oid %x) returned x%x, Info %d\n",
                                                pQueryInfo->ObjectId, status, ioStatusBlock->Information));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                        *NumberOfBytesReturned = (ULONG)ioStatusBlock->Information;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

    if( deviceHandle != NULL ) {

        NtClose( deviceHandle );

    }

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}


INT
AtmSetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

        Performs a RWAN Set Information action to the Raw Wan driver. This operation
        is directed to either an Address Object or to a Connection object, according
        to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_GENERIC_XXXSET

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing value for the Object.

        InputBufferLength - Length of the above.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PRWAN_SET_INFORMATION_EX pSetInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(RWAN_SET_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pSetInfo = (PRWAN_SET_INFORMATION_EX)(ioStatusBlock + 1);
                pSetInfo->ObjectId = ObjectId;
                pSetInfo->BufferSize = InputBufferLength;

                if ( pSetInfo->BufferSize > 0 ) {

                        RtlCopyMemory(
                                pSetInfo->Buffer,
                                InputBuffer,
                                pSetInfo->BufferSize
                                );

                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pSetInfo,
                                        sizeof(RWAN_SET_INFORMATION_EX) + InputBufferLength,
                                        NULL,   // No output buffer
                                        0               // output buffer length
                                        );

                DBGPRINT(("AtmSetInfo: IOCTL (Oid %x) returned x%x\n", pSetInfo->ObjectId, status));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}


INT
AtmGetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

        Performs a RWAN Get Information action to the Raw Wan driver. This operation
        is directed to either an Address Object or to a Connection object, according
        to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_GENERIC_XXXGET

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing context for the Object.

        InputBufferLength - Length of the above.

        OutputBuffer - place to return value

        OutputBufferLength - bytes available in OutputBuffer

        NumberOfBytesReturned - place to return bytes written

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PRWAN_QUERY_INFORMATION_EX pQueryInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(RWAN_QUERY_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pQueryInfo = (PRWAN_QUERY_INFORMATION_EX)(ioStatusBlock + 1);
                pQueryInfo->ObjectId = ObjectId;
                pQueryInfo->ContextLength = InputBufferLength;

                if ( pQueryInfo->ContextLength > 0 ) {

                        RtlCopyMemory(
                                pQueryInfo->Context,
                                InputBuffer,
                                pQueryInfo->ContextLength
                                );
                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pQueryInfo,
                                        sizeof(RWAN_QUERY_INFORMATION_EX) + InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength              // output buffer length
                                        );

                DBGPRINT(("AtmGetGenericInfo: IOCTL (Oid %x) returned x%x\n", pQueryInfo->ObjectId, status));
                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                        *NumberOfBytesReturned = (ULONG)ioStatusBlock->Information;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }

                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}



INT
AtmSetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

        Performs a Media-specific Set Information action to the Raw Wan driver.
        This operation is directed to either an Address Object or to a Connection
        object, according to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_MEDIA_SPECIFIC_XXX

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing value for the Object.

        InputBufferLength - Length of the above.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PATM_SET_INFORMATION_EX pSetInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(ATM_SET_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pSetInfo = (PATM_SET_INFORMATION_EX)(ioStatusBlock + 1);
                pSetInfo->ObjectId = ObjectId;
                pSetInfo->BufferSize = InputBufferLength;

                if ( pSetInfo->BufferSize > 0 ) {

                        RtlCopyMemory(
                                pSetInfo->Buffer,
                                InputBuffer,
                                pSetInfo->BufferSize
                                );

                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pSetInfo,
                                        sizeof(ATM_SET_INFORMATION_EX) + InputBufferLength,
                                        NULL,   // No output buffer
                                        0               // output buffer length
                                        );

                DBGPRINT(("AtmSetInfo: IOCTL (Oid %x) returned x%x\n", pSetInfo->ObjectId, status));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}


INT
AtmGetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

        Performs a Media-specific Get Information action to the Raw Wan driver.
        This operation is directed to either an Address Object or to a Connection
        object, according to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_MEDIA_SPECIFIC_XXX

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing context for the Object.

        InputBufferLength - Length of the above.

        OutputBuffer - place to return value

        OutputBufferLength - bytes available in OutputBuffer

        NumberOfBytesReturned - place to return bytes written

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PATM_QUERY_INFORMATION_EX pQueryInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {

                *NumberOfBytesReturned = 0;

                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(ATM_QUERY_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pQueryInfo = (PATM_QUERY_INFORMATION_EX)(ioStatusBlock + 1);
                pQueryInfo->ObjectId = ObjectId;
                pQueryInfo->ContextLength = InputBufferLength;

                if ( pQueryInfo->ContextLength > 0 ) {

                        RtlCopyMemory(
                                pQueryInfo->Context,
                                InputBuffer,
                                pQueryInfo->ContextLength
                                );
                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pQueryInfo,
                                        sizeof(ATM_QUERY_INFORMATION_EX) + InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength
                                        );

                DBGPRINT(("AtmGetAtmObjInfo: IOCTL (Oid %x) returned x%x\n",
                                        pQueryInfo->ObjectId, status));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                        *NumberOfBytesReturned = (ULONG)ioStatusBlock->Information;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}

#if DBG
PVOID
MyRtlAllocateHeap(
        IN      PVOID   HeapHandle,
        IN      ULONG   Flags,
        IN      ULONG   Size,
        IN      ULONG   LineNumber
        )
{
        PVOID   pRetValue;

        pRetValue = RtlAllocateHeap(HeapHandle, Flags, Size);

#if DBG2
        DbgPrint("WSHATM: AllocHeap size %d at line %d, ret x%x\n",
                        Size, LineNumber, pRetValue);
#endif
        return (pRetValue);
}


VOID
MyRtlFreeHeap(
        IN PVOID        HeapHandle,
        IN ULONG        Flags,
        IN PVOID        MemPtr,
        IN ULONG        LineNumber
        )
{
#if DBG2
        DbgPrint("WSHATM: FreeHeap x%x, line %d\n", MemPtr, LineNumber);
#endif
        RtlFreeHeap(HeapHandle, Flags, MemPtr);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\makefile.inc ===
TARGETPATH=obj$(BUILD_ALT_DIR)

C_DEFINES=$(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE -D_NTSDK=1
C_DEFINES=$(C_DEFINES) -DUSE_HEAP_ALLOC=1 -DMPR50=1 -DENABLE_1394
C_DEFINES=$(C_DEFINES) -DUSE_CUSTOM_STL_ALLOCATOR 

!IFDEF COMPILE_WITH_TYPESAFE_PRINTF
C_DEFINES=$(C_DEFINES) -DCOMPILE_WITH_TYPESAFE_PRINTF
!ENDIF

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DENABLETRACE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

!IF defined(_NCIBUILD_) && $(IA64)
MSC_OPTIMIZATION=/Odi
!ENDIF

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(PROJDIR)\inc\pch.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj

RCOPTIONS=-N
UMTYPE=windows
USE_STATIC_ATL=1
USE_MAKEFILE=1

USELIB_CMT=1
USE_NATIVE_EH=1
USE_STL=1

!IF "$(TARGETTYPE)" == "PROGRAM"
UMLIBS=$(PROJDIR)\lib\$(O)\ncbase.lib
!ELSE
LINKLIBS=$(PROJDIR)\lib\$(O)\ncbase.lib
!ENDIF

!IF $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\nccfgmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C F G M G R . C P P
//
//  Contents:   Common code useful when using the Configuration Manager APIs.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   6 May 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nccfgmgr.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrFromConfigManagerError
//
//  Purpose:    Convert a CONFIGRET into an HRESULT.
//
//  Arguments:
//      cr        [in] CONFIGRET to convert.
//      hrDefault [in] Default HRESULT to use if mapping not found.
//
//  Returns:    HRESULT
//
//  Author:     shaunco   6 May 1998
//
//  Notes:
//
NOTHROW
HRESULT
HrFromConfigManagerError (
    CONFIGRET   cr,
    HRESULT     hrDefault)
{
    switch (cr)
    {
        case CR_SUCCESS:
            return NO_ERROR;

        case CR_OUT_OF_MEMORY:
            return E_OUTOFMEMORY;

        case CR_INVALID_POINTER:
            return E_POINTER;

        case CR_INVALID_DEVINST:
            return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_DEVINST);

        case CR_ALREADY_SUCH_DEVINST:
            return HRESULT_FROM_WIN32 (ERROR_DEVINST_ALREADY_EXISTS);

        case CR_INVALID_DEVICE_ID:
            return HRESULT_FROM_WIN32 (ERROR_INVALID_DEVINST_NAME);

        case CR_INVALID_MACHINENAME:
            return HRESULT_FROM_WIN32 (ERROR_INVALID_MACHINENAME);

        case CR_REMOTE_COMM_FAILURE:
            return HRESULT_FROM_WIN32 (ERROR_REMOTE_COMM_FAILURE);

        case CR_MACHINE_UNAVAILABLE:
            return HRESULT_FROM_WIN32 (ERROR_MACHINE_UNAVAILABLE);

        case CR_NO_CM_SERVICES:
            return HRESULT_FROM_WIN32 (ERROR_NO_CONFIGMGR_SERVICES);

        case CR_ACCESS_DENIED:
            return E_ACCESSDENIED;

        case CR_CALL_NOT_IMPLEMENTED:
            return E_NOTIMPL;

        case CR_INVALID_REFERENCE_STRING :
            return HRESULT_FROM_WIN32 (ERROR_INVALID_REFERENCE_STRING);

        default:
            return hrDefault;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncatlui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L U I . C P P
//
//  Contents:   UI common code relying on ATL.
//
//  Notes:
//
//  Author:     shaunco   13 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include "ncatlui.h"
#include "ncatl.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be LPCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
NOTHROW
int
WINAPIV
NcMsgBox (
        HWND    hwnd,
        UINT    unIdCaption,
        UINT    unIdFormat,
        UINT    unStyle,
        ...)
{
    PCWSTR pszCaption = SzLoadIds(unIdCaption);
    PCWSTR pszFormat  = SzLoadIds(unIdFormat);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    if(!pszText)
    {
        // This is what MessageBox returns if it fails.
        return 0;
    }

    int nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncbase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C B A S E . C P P
//
//  Contents:   Basic common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"
#include "ncperms.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddRefObj
//
//  Purpose:    AddRef's the object pointed to by punk by calling
//              punk->AddRef();
//
//  Arguments:
//      punk [in]   Object to be AddRef'd. Can be NULL.
//
//  Returns:    Result of AddRef call.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Using this function to AddRef an object will reduce
//              our code size.
//
NOTHROW
ULONG
AddRefObj (
    IUnknown* punk)
{
    return (punk) ? punk->AddRef () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseObj
//
//  Purpose:    Releases the object pointed to by punk by calling
//              punk->Release();
//
//  Arguments:
//      punk [in]   Object to be released. Can be NULL.
//
//  Returns:    Result of Release call.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Using this function to release a (possibly NULL) object will
//              reduce our code size.
//
NOTHROW
ULONG
ReleaseObj (
    IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}

//+--------------------------------------------------------------------------
//
//  Function:   DwWin32ErrorFromHr
//
//  Purpose:    Converts the HRESULT to a Win32 error or SetupApi error.
//
//  Arguments:
//      hr [in] The HRESULT to convert
//
//  Returns:    Converted DWORD value.
//
//  Author:     billbe   22 Apr 1997
//
//  Notes:
//
NOTHROW
DWORD
DwWin32ErrorFromHr (
    HRESULT hr)
{
    DWORD dw = ERROR_SUCCESS;

    // All success codes convert to ERROR_SUCCESS so we only need to handle
    // failures.
    if (FAILED(hr))
    {
        DWORD dwFacility = HRESULT_FACILITY(hr);

        if (FACILITY_SETUPAPI == dwFacility)
        {
            // reconstruct the SetupApi error using the correct masks
            dw = HRESULT_CODE(hr) | APPLICATION_ERROR_MASK |
                    ERROR_SEVERITY_ERROR;

            // Check to make sure dw maps to a known SetupApi error
            AssertSz(FDwordWithinRange(ERROR_EXPECTED_SECTION_NAME,
                            dw, ERROR_GENERAL_SYNTAX) ||
                     FDwordWithinRange(ERROR_WRONG_INF_STYLE,
                            dw, ERROR_NO_BACKUP) ||
                     FDwordWithinRange(ERROR_NO_ASSOCIATED_CLASS,
                            dw, ERROR_SET_SYSTEM_RESTORE_POINT),
                    "The mapped SetupApi error is not known "
                    "(or is new)!!!");
        }
        else if (FACILITY_WIN32 == dwFacility)
        {
            dw = HRESULT_CODE(hr);
        }
        else if (FACILITY_ITF == dwFacility)
        {
            dw = ERROR_GEN_FAILURE;
        }
        else
        {
            // cannot convert it
            AssertSz(FALSE, "Facility was not SETUP or WIN32!");
            dw = hr;
        }
    }

    return dw;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCoTaskMemAlloc
//
//  Purpose:    Call CoTaskMemAlloc but return an HRESULT.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Returned pointer to bytes.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   31 May 1997
//
//  Notes:
//
HRESULT
HrCoTaskMemAlloc (
    ULONG   cb,
    VOID**  ppv)
{
    HRESULT hr = S_OK;
    *ppv = CoTaskMemAlloc (cb);
    if (!*ppv)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceError ("HrCoTaskMemAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCoTaskMemAllocAndDupSzLen
//
//  Purpose:    Allocate memory using CoTaskMemAlloc and copy a string
//              into it.  This is used by the implementation of COM interfaces
//              that return strings.
//
//  Arguments:
//      pszSrc  [in]  Pointer to source string.
//      cchSrc  [in]  Number of characters to copy from source string.
//      ppszDst [out] Address of pointer to destination string.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   14 Jan 1999
//
//  Notes:      NULL input pointers are allocated as empty strings
//              deliberately.
//              The returned string is guaranteed to be NULL terminated.
//
HRESULT
HrCoTaskMemAllocAndDupSzLen (
    IN PCWSTR pszSrc,
    IN ULONG cchSrc,
    OUT PWSTR* ppszDst, 
    IN ULONG cchMaxDest)
{
    Assert (ppszDst);

    HRESULT hr;

    DWORD cbCopy = min(cchSrc, cchMaxDest);
    DWORD cb = cbCopy * sizeof(WCHAR);

    hr = E_OUTOFMEMORY;
    *ppszDst = (PWSTR)CoTaskMemAlloc (cb + sizeof(WCHAR));
    if (*ppszDst)
    {
        hr = S_OK;
        wcsncpy (*ppszDst, pszSrc, cbCopy);
        (*ppszDst)[cbCopy] = 0;
    }

    TraceError ("HrCoTaskMemAllocAndDupSz", hr);
    return hr;
}


HRESULT
HrCoTaskMemAllocAndDupSz (
    IN PCWSTR pszSrc,
    OUT PWSTR* ppszDst,
    IN ULONG cchMaxDest)
{
    return HrCoTaskMemAllocAndDupSzLen (
            pszSrc,
            CchOfSzSafe(pszSrc),
            ppszDst,
            cchMaxDest);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFromLastWin32Error
//
//  Purpose:    Converts the GetLastError() Win32 call into a proper HRESULT.
//
//  Arguments:
//      (none)
//
//  Returns:    Converted HRESULT value.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      This is not inline as it actually generates quite a bit of
//              code.
//              If GetLastError returns an error that looks like a SetupApi
//              error, this function will convert the error to an HRESULT
//              with FACILITY_SETUP instead of FACILITY_WIN32
//
NOTHROW
HRESULT
HrFromLastWin32Error ()
{
    DWORD dwError = GetLastError();
    HRESULT hr;

    // This test is testing SetupApi errors only (this is
    // temporary because the new HRESULT_FROM_SETUPAPI macro will
    // do the entire conversion)
    if (dwError & (APPLICATION_ERROR_MASK | ERROR_SEVERITY_ERROR))
    {
        hr = HRESULT_FROM_SETUPAPI(dwError);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetProcAddress
//
//  Purpose:    Loads a libray and returns the address of a procedure within
//                  the library
//
//  Arguments:
//      hModule      [in] The handle to the library module instance
//      pszaFunction [in]  Function to retrieve
//      ppfn         [out] Address of szFunction
//
//  Returns:    S_OK if successful, Win32 converted error if failure.
//
//  Author:     billbe   10 June 1997
//
//  Notes:
//
HRESULT
HrGetProcAddress (
    HMODULE     hModule,
    PCSTR       pszaFunction,
    FARPROC*    ppfn)
{
    Assert(hModule);
    Assert(pszaFunction);
    Assert(ppfn);

    HRESULT hr = S_OK;
    *ppfn = GetProcAddress(hModule, pszaFunction);
    if (!*ppfn)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidError, "HrGetProcAddress failed: szFunction: %s",
                 pszaFunction);
    }

    TraceError("HrGetProcAddress", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadLibAndGetProcs
//
//  Purpose:    Load a dynamic link library and the addresses of one or
//              more procedures within that library.
//
//  Arguments:
//      pszLibPath         [in]  Path to the DLL to load.
//      cFunctions         [in]  Number of procedures to load.
//      apszaFunctionNames [in]  Array of function names.  (Must be 'cFunctions'
//                               of them.)
//      phmod              [out] Returned handle to the loaded module.
//      apfn               [out] Array of returned pointers to the procedures
//                               loaded.  (Must be 'cFunctions' of them.)
//
//  Returns:    S_OK if all procedures were loaded, S_FALSE if only
//              some of them were, or a Win32 error code.  If only
//              one procedure is to be loaded and it is not, S_FALSE will
//              not be returned, rather, the reason for why the single
//              procedure could not be loaded will be returned.  This allows
//              HrLoadLibAndGetProc to be implemented using this function.
//
//  Author:     shaunco   19 Jan 1998
//
//  Notes:      phmod should be freed by the caller using FreeLibrary if
//              the return value is S_OK.
//
HRESULT
HrLoadLibAndGetProcs (
    PCWSTR          pszLibPath,
    UINT            cFunctions,
    const PCSTR*    apszaFunctionNames,
    HMODULE*        phmod,
    FARPROC*        apfn)
{
    Assert (pszLibPath);
    Assert (cFunctions);
    Assert (apszaFunctionNames);
    Assert (phmod);
    Assert (apfn);

    HRESULT hr = S_OK;

    // Load the module and initialize the output parameters.
    //
    HMODULE hmod = LoadLibrary (pszLibPath);
    *phmod = hmod;
    ZeroMemory (apfn, cFunctions * sizeof(FARPROC));

    if (hmod)
    {
        // Get the proc address of each function.
        //
        for (UINT i = 0; i < cFunctions; i++)
        {
            apfn[i] = GetProcAddress (hmod, apszaFunctionNames[i]);

            if (!apfn[i])
            {
                // Couldn't load all functions.  We'll be returning S_FALSE
                // (if their are more than one function.)
                //
                hr = S_FALSE;

                TraceTag (ttidError, "HrLoadLibAndGetProcs: GetProcAddress "
                    "for '%s' failed.",
                    apszaFunctionNames[i]);
            }
        }

        // If we're only loading one function, and it failed,
        // return the failure.
        //
        if ((1 == cFunctions) && !apfn[0])
        {
            hr = HrFromLastWin32Error ();
            FreeLibrary (hmod);
        }
    }
    else
    {
        hr = HrFromLastWin32Error ();
        TraceTag (ttidError, "HrLoadLibAndGetProcs: LoadLibrary (%S) failed.",
            pszLibPath);
    }

    TraceError ("HrLoadLibAndGetProcs", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetProcAddressesVa
//
// Purpose:   Get proc-address of each function-name passed
//
// Arguments:
//    hModule [in]  handle of DLL
//    arglist [in]  list of var-args. the expected format is
//                  "func-name", FARPROC*, ..., NULL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-December-97
//
// Notes:
//
HRESULT
HrGetProcAddressesVa (
    HMODULE hModule,
    va_list arglist)
{
    PCSTR szFunctionName;
    FARPROC* ppfn;
    HRESULT hr = S_OK;
    typedef FARPROC* PFARPROC;

    while (NULL != (szFunctionName = va_arg(arglist, CHAR*)))
    {
        ppfn = va_arg(arglist, PFARPROC);
        *ppfn = GetProcAddress(hModule, szFunctionName);

        if (!*ppfn)
        {
            hr = HrFromLastWin32Error();
            TraceTag(ttidError, "HrGetProcAddressesVa failed: szFunction: %s",
                     szFunctionName);
            break;
        }
    }

    TraceError("HrGetProcAddressesVa", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetProcAddressesV
//
// Purpose:   Get proc-address of each function-name passed
//
// Arguments:
//    hModule [in]  handle of DLL
//    ...     [in]  list of var-args. the expected format is
//                  "func-name", FARPROC*, ..., NULL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-December-97
//
// Notes:
//
HRESULT
HrGetProcAddressesV (
    HMODULE hModule,
    ...)
{
    HRESULT hr=S_OK;
    va_list arglist;

    va_start(arglist, hModule);

    hr = HrGetProcAddressesVa(hModule, arglist);

    va_end(arglist);

    TraceError("HrGetProcAddressesV", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrLoadLibAndGetProcsV
//
// Purpose:   Get proc-address of each function-name passed
//
// Arguments:
//    pszLibPath [in]   DLL to load
//    phModule   [out]  pointer to handle of DLL loaded
//    ...        [in]   list of var-args. the expected format is
//                      "func-name", FARPROC*, ..., NULL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-December-97
//
// Notes:
//
HRESULT
HrLoadLibAndGetProcsV (
    PCWSTR      pszLibPath,
    HMODULE*    phModule,
    ...)
{
    Assert(pszLibPath);
    Assert(phModule);

    HRESULT hr = S_OK;

    // Attempt to load the library
    *phModule = LoadLibrary(pszLibPath);

    if (*phModule)
    {
        va_list arglist;

        va_start(arglist, phModule);

        hr = HrGetProcAddressesVa(*phModule, arglist);

        va_end(arglist);

        if (FAILED(hr))
        {
            // Free the library
            FreeLibrary(*phModule);
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidError, "HrLoadLibAndGetProcsV failed: szLibPath: %S",
                 pszLibPath);
    }

    // if we failed then we should set *phModule to NULL since we might
    // have successfully loaded it and failed getting the proc
    if (FAILED(hr))
    {
        *phModule = NULL;
    }

    TraceError("HrLoadLibAndGetProcsV", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateEventWithWorldAccess
//
//  Purpose:    Creates a event with permissions to allow access to
//              everyone.
//
//  Arguments:
//      pszName         [in]  Name for the event.
//      fManualReset    [in]  See Win32 docs.
//      fInitialState   [in]  See Win32 docs.
//      pfAlreadyExists [out] TRUE if the event already existed.
//                            FALSE otherwise.
//      phEvent         [out] The created event.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     BillBe   16 Nov 1998
//
//  Notes:
//
HRESULT
HrCreateEventWithWorldAccess(PCWSTR pszName, BOOL fManualReset,
        BOOL fInitialState, BOOL* pfAlreadyExists, HANDLE* phEvent)
{
    Assert(pszName);
    Assert(phEvent);

    if (pfAlreadyExists)
    {
        *pfAlreadyExists = FALSE;
    }

    *phEvent = NULL;

    // Create the correct descriptor.
    PSECURITY_DESCRIPTOR pSd;
    HRESULT hr = HrAllocateSecurityDescriptorAllowAccessToWorld(&pSd);
    if (SUCCEEDED(hr))
    {
        SECURITY_ATTRIBUTES sa = {0};
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE;

        // Create Event
        //
        *phEvent = CreateEvent(&sa, fManualReset, fInitialState, pszName);

        hr = HrFromLastWin32Error();
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            if (pfAlreadyExists)
            {
                *pfAlreadyExists = TRUE;
            }
            hr = S_OK;
        }

        MemFree(pSd);
    }

    TraceError("HrCreateEventWithWorldAccess", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateMutexWithWorldAccess
//
//  Purpose:    Creates a mutex with permissions to allow access to
//              everyone.
//
//  Arguments:
//      pszName         [in]  Name for the mutex.
//      fInitialOwner   [in]  See Win32 docs.
//      pfAlreadyExists [out] TRUE if the mutex already existed,
//                            FALSE otherwise.
//      phMutex         [out] The created mutex.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     BillBe   16 Nov 1998
//
//  Notes:
//
HRESULT
HrCreateMutexWithWorldAccess (
    PCWSTR pszName,
    BOOL fInitialOwner,
    BOOL* pfAlreadyExists,
    HANDLE* phMutex)
{
    Assert(pszName);
    Assert(phMutex);

    if (pfAlreadyExists)
    {
        *pfAlreadyExists = FALSE;
    }

    *phMutex = NULL;

    // Create the correct descriptor.
    PSECURITY_DESCRIPTOR pSd;
    HRESULT hr = HrAllocateSecurityDescriptorAllowAccessToWorld(&pSd);
    if (S_OK == hr)
    {
        SECURITY_ATTRIBUTES sa = {0};
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE;

        // Create Mutex
        //
        *phMutex = CreateMutex(&sa, fInitialOwner, pszName);

        hr = HrFromLastWin32Error();
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            if (pfAlreadyExists)
            {
                *pfAlreadyExists = TRUE;
            }
            hr = S_OK;
        }

        MemFree(pSd);
    }

    TraceError("HrCreateMutexWithWorldAccess", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// The standard parameterization of CoSetProxyBlanket.  Call this instead
// of CoSetProxyBlanket so you get the same security and authentication
// settings as everyone else.  This version saves code space at the call-site
// because it pushes only one parameter instead of eight.
// This does not return an error because it does not invalidate the use of
// pUnk after it's called.
//
VOID
NcSetProxyBlanket (
    IN IUnknown* pUnk)
{
    HRESULT hr;

    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr))
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if(SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
            ReleaseObj(pUnkSet);
        }
    }

    TraceHr(ttidError, FAL, hr, (E_NOINTERFACE == hr), "NcSetProxyBlanket");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateInstanceBase
//
//  Purpose:    Creates a COM object and sets default proxy settings.
//
//  Arguments:
//      rclsid          [in]  See documentation for CoCreateInstance.
//      dwClsContext    [in]  ""
//      riid            [in]  ""
//      ppv             [out] ""
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
//  Notes:      Call type safe version HrCreateInstance
//
HRESULT
HrCreateInstanceBase (
    REFCLSID rclsid,
    DWORD dwClsContext,
    REFIID riid,
    LPVOID * ppv)
{
    HRESULT hr = S_OK;

    hr = ::CoCreateInstance(rclsid, NULL, dwClsContext, riid, ppv);

    if(SUCCEEDED(hr) && (dwClsContext & CLSCTX_LOCAL_SERVER))
    {
        NcSetProxyBlanket(reinterpret_cast<IUnknown*>(*ppv));
    }

    TraceError("HrCreateInstanceBase", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQIAndSetProxyBlanketBase
//
//  Purpose:    Performs QueryInterface and sets default proxy settings.
//
//  Arguments:
//      pUnk            [in]  Interface pointer to perform QueryInterface on.
//      riid            [in]  See documentation of QueryInterface
//      ppv             [out] ""
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
//  Notes:      Call type safe version HrQIAndSetProxyBlanket
//
HRESULT
HrQIAndSetProxyBlanketBase(IUnknown * pUnk, REFIID riid, void ** ppv)
{
    HRESULT hr = pUnk->QueryInterface(riid, ppv);
    if(SUCCEEDED(hr))
    {
        NcSetProxyBlanket(reinterpret_cast<IUnknown*>(*ppv));
    }

    TraceError("HrQIAndSetProxyBlanketBase", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncinf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I N F . C P P
//
//  Contents:   ???
//
//  Notes:
//
//  Author:     ???
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncinf.h"
#include "ncsetup.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessInfExtension
//
//  Purpose:    Given the appropriate keywords, returns information about an
//              INF file that contains extended commands to add and remove
//              fixed components such as WinSock or SNMP Agent support.
//
//  Arguments:
//      hinfInstallFile  [in]    The handle to the inf file to install
//                              from
//      pszSectionName   [in]    The Base install section name.
//      pszSuffix        [in]    Suffix to append to base. (i.e. "Winsock")
//      pszAddLabel      [in]    Label for Add command (i.e. "AddSock")
//      pszRemoveLabel   [in]    Label for Remove command (i.e. "DelSock")
//      pfnHrAdd         [in]    Callback function to be called when adding.
//      pfnHrRemove      [in]    Callback function to be called when removing.
//
//  Returns:    HRESULT, S_OK on success
//
//  Author:     danielwe   27 Apr 1997
//
//  Notes:
//
HRESULT
HrProcessInfExtension (
    IN HINF                hinfInstallFile,
    IN PCWSTR              pszSectionName,
    IN PCWSTR              pszSuffix,
    IN PCWSTR              pszAddLabel,
    IN PCWSTR              pszRemoveLabel,
    IN PFNADDCALLBACK      pfnHrAdd,
    IN PFNREMOVECALLBACK   pfnHrRemove)
{
    Assert(IsValidHandle(hinfInstallFile));

    BOOL        fAdd;
    HRESULT     hr = S_OK;
    tstring     strSectionName;
    INFCONTEXT  infContext;
    WCHAR       szCmd[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256

    // Construct the section name for which we're looking
    // (ie.  "Inst_Section.Winsock")
    strSectionName = pszSectionName;
    strSectionName += L".";
    strSectionName += pszSuffix;

    // Loop over the elements of the section and process the
    // appropriate AddSock/DelSock sections found
    hr = HrSetupFindFirstLine(hinfInstallFile, strSectionName.c_str(),
                              NULL, &infContext);
    if (S_OK == hr)
    {
        tstring strName;

        do
        {
            // Retrieve a line from the section, hopefully in the format:
            // AddSock=section_name   or   DelSock=section_name
            hr = HrSetupGetStringField(infContext, 0, szCmd, celems(szCmd),
                                       NULL);
            if (FAILED(hr))
            {
                goto Done;
            }

            // Check for the <add> or <remove> command
            szCmd[celems(szCmd)-1] = L'\0';
            if (!lstrcmpiW(szCmd, pszAddLabel))
            {
                fAdd = TRUE;
            }
            else if (!lstrcmpiW(szCmd, pszRemoveLabel))
            {
                fAdd = FALSE;
            }
            else
            {
                continue;   // Other things are in this install section
            }

            // Query the Add/Remove value from the .inf
            hr = HrSetupGetStringField(infContext, 1, &strName);
            if (S_OK == hr)
            {
                if (fAdd)
                {
                    // Call Add callback
                    hr = pfnHrAdd(hinfInstallFile, strName.c_str());
                }
                else
                {
                    // Call remove callback
                    hr = pfnHrRemove(hinfInstallFile, strName.c_str());
                }

                if (FAILED(hr))
                {
                    goto Done;
                }
            }
            else
            {
                goto Done;
            }
        }
        while (S_OK == (hr = HrSetupFindNextLine(infContext, &infContext)));
    }

    if (hr == S_FALSE)
    {
        // S_FALSE will terminate the loop successfully, so convert it to S_OK
        // here.
        hr = S_OK;
    }

Done:
    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessInfExtension");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\naming.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N A M I N G . C P P
//
//  Contents:   Generates Connection Names Automatically
//
//  Notes:
//
//  Author:     deonb    27 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include "netcon.h"
#include "netconp.h"
#include <ntddndis.h>
#include <ndisprv.h>
#include <devioctl.h>
#include <ndispnp.h>
#include "naming.h"
#include <rasapip.h>
#include "wzcsapi.h"

extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szInfId_MS_AtmElan[];
const WCHAR        c_szDevice[] = L"\\DEVICE\\";

#define MAX_TYPE_NAME_LEN 45
//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::CIntelliName
//
//  Purpose:    Constructor
//
//  Arguments:
//      hInstance [in]  Resource instance of binary with naming.rc included
//
//      pFNDuplicateNameCheck [in]   Callback function of duplicate check. Can be NULL \
//                                   or otherwise of the following callback type:
//         + typedef BOOL FNDuplicateNameCheck
//         +              pIntelliName  [in]  CIntelliName this pointer (for HrGetPseudoMediaTypes callback)
//         +              szName        [in]  Name to check for
//         +              pncm          [out] NetCon Media Type of conflicting connection
//         +              pncms         [out] NetCon SubMedia Type of conflicting connection
//         +        return TRUE - if conflicting found or FALSE if no conflicting connection found
//
//  Returns: None        
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:      
//
CIntelliName::CIntelliName(IN HINSTANCE hInstance, IN FNDuplicateNameCheck *pFNDuplicateNameCheck)
{
    m_pFNDuplicateNameCheck = pFNDuplicateNameCheck;
    m_hInstance = hInstance;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::NameExists
//
//  Purpose:    Check if a name already exists
//
//  Arguments:
//      szName [in]  Name to check for
//      pncm   [out] NetCon Media Type of conflicting connection
//      pncms  [out] NetCon SubMedia Type of conflicting connection
//
//  Returns: TRUE if exists, FALSE if not        
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:      
//
BOOL CIntelliName::NameExists(IN LPCWSTR szName, OUT NETCON_MEDIATYPE *pncm, OUT NETCON_SUBMEDIATYPE *pncms) const
{
    if (m_pFNDuplicateNameCheck)
    {
        Assert(pncm);
        Assert(pncms);

        if (IsReservedName(szName))
        {
            return TRUE;
        }

        return (*m_pFNDuplicateNameCheck)(this, szName, pncm, pncms);
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::IsReservedName
//
//  Purpose:    Check if a name is a reserved name
//
//  Arguments:
//      szName [in]  Name to check for
//
//  Returns: TRUE if reserved, FALSE if not
//
//  Author:     deonb   12 Mar 2001
//
//  Notes:      
//
BOOL CIntelliName::IsReservedName(IN LPCWSTR szName) const
{
    UINT  uiReservedNames[] = {IDS_RESERVED_INCOMING, 
                               IDS_RESERVED_NCW, 
                               IDS_RESERVED_HNW};

    for (int x = 0; x < celems(uiReservedNames); x++)
    {
        WCHAR szReservedName[MAX_PATH];
        int nSiz = LoadString (m_hInstance, uiReservedNames[x], szReservedName, MAX_PATH);
        if (nSiz)
        {
            if (0 == lstrcmpi(szName, szReservedName))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateNameRenameOnConflict
//
//  Purpose:    Generate a name, rename if it conflicts with an existing name
//
//  Arguments:
//      guid              [in]  GUID of connection
//      ncm               [in]  NetCon Media Type of Connection 
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szHintName        [in]  Hint of name (will use as is if not conflicting)
//      szHintType        [in]  String of NetCon Media Type
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::GenerateNameRenameOnConflict(IN  REFGUID          guid, 
                                                   IN  NETCON_MEDIATYPE ncm, 
                                                   IN  DWORD            dwCharacteristics, 
                                                   IN  LPCWSTR          szHintName, 
                                                   IN  LPCWSTR          szHintType, 
                                                   OUT LPWSTR*          szName) const
{
    HRESULT hr = S_OK;

    WCHAR szTemp[NETCON_MAX_NAME_LEN];
    WCHAR szBaseName[NETCON_MAX_NAME_LEN];

    Assert(szName)
    *szName = NULL;

    lstrcpynW(szTemp, szHintName, celems(szTemp) - MAX_TYPE_NAME_LEN); // reserve bytes at end to include specialized info.

    DWORD dwInstance = 2;
    lstrcpynW(szBaseName, szTemp, celems(szBaseName) );

    NETCON_MEDIATYPE ncmdup; 
    NETCON_SUBMEDIATYPE ncmsdup;
    if (NameExists(szTemp, &ncmdup, &ncmsdup))
    {
        BOOL fHasTypeAlready = FALSE;
        if ( (ncmdup == ncm) || (NCM_LAN == ncm) )
        {
            fHasTypeAlready = TRUE;
        }

        if (!fHasTypeAlready)
        {
            if (DwFormatString(L"%1!s! (%2!s!)", szTemp, celems(szTemp), szBaseName, szHintType))
            {
                lstrcpynW(szBaseName, szTemp, celems(szBaseName));
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        else
        {
            if (!DwFormatString(L"%1!s! %2!d!", szTemp, celems(szTemp), szBaseName, dwInstance))
            {
                hr = HrFromLastWin32Error();
            }

            dwInstance++;
        }

        while ( SUCCEEDED(hr) && NameExists(szTemp, &ncmdup, &ncmsdup) && (dwInstance < 65535) )
        {
            if (!DwFormatString(L"%1!s! %2!d!", szTemp, celems(szTemp), szBaseName, dwInstance))
            {
                hr = HrFromLastWin32Error();
            }

            dwInstance++;
        }

        if ( SUCCEEDED(hr) && (dwInstance >= 65535) && NameExists(szTemp, &ncmdup, &ncmsdup) )
        {
            hr = E_FAIL;
        }
    }

    if (S_OK == hr)
    {
        hr = HrCoTaskMemAllocAndDupSz(szTemp, szName, NETCON_MAX_NAME_LEN);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateNameFromResource
//
//  Purpose:    Generate a name, rename if it conflicts with an existing name
//
//  Arguments:
//      guid              [in]  GUID of connection
//      ncm               [in]  NetCon Media Type of Connection 
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szHintName        [in]  Hint of name (will use as is if not conflicting)
//      uiNameID          [in]  Resource id of default name
//      uiTypeId          [in]  Resource id of default type
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::GenerateNameFromResource(IN  REFGUID          guid, 
                                               IN  NETCON_MEDIATYPE ncm, 
                                               IN  DWORD            dwCharacteristics, 
                                               IN  LPCWSTR          szHint, 
                                               IN  UINT             uiNameID, 
                                               IN  UINT             uiTypeId, 
                                               OUT LPWSTR*          szName) const
{
    Assert(szName);
    *szName = NULL;

    WCHAR szHintName[NETCON_MAX_NAME_LEN];
    WCHAR szTypeName[MAX_TYPE_NAME_LEN - 3]; // - 3 as this is put later into a MAX_TYPE_NAME_LEN character 
                                             // buffer with ' (%s)' at the end

    if (!szHint || *szHint == L'\0')
    {
        int nSiz = LoadString (m_hInstance, uiNameID, szHintName, celems(szHintName) );
        AssertSz(nSiz, "Resource string not found");
    }
    else
    {
        lstrcpynW(szHintName, szHint, celems(szHintName) );
    }

    int nSiz = LoadString (m_hInstance, uiTypeId, szTypeName, celems(szTypeName) );
    AssertSz(nSiz, "Resource string not found");
    
    return GenerateNameRenameOnConflict(guid, ncm, dwCharacteristics, szHintName, szTypeName, szName);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::HrGetPseudoMediaTypes
//
//  Purpose:    Generate a name, rename if it conflicts with an existing name
//
//  Arguments:
//      guid     [in]  GUID of connection
//      pncm     [out] Pseudo-NetCon Media Type of Connection (Only NCM_PHONE or NCM_LAN)
//      pncms    [out] SubMedia Type for LAN connections
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::HrGetPseudoMediaTypes(IN  REFGUID              guid, 
                                            OUT NETCON_MEDIATYPE*    pncm, 
                                            OUT NETCON_SUBMEDIATYPE* pncms) const
{
    Assert(pncms);
    Assert(pncm);
    Assert(guid != GUID_NULL);

    HRESULT hr;

    *pncms = NCSM_NONE;

    INetCfg* pNetCfg;
    hr = CoCreateInstance(
            CLSID_CNetCfg,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_INetCfg,
            reinterpret_cast<LPVOID *>(&pNetCfg));
    if (SUCCEEDED(hr))
    {
        hr = pNetCfg->Initialize(NULL);
        if (SUCCEEDED(hr))
        {
            CIterNetCfgComponent nccIter(pNetCfg, &GUID_DEVCLASS_NET);
            INetCfgComponent* pnccAdapter = NULL;
            BOOL fFound = FALSE;

            while (!fFound && SUCCEEDED(hr) &&
                   (S_OK == (hr = nccIter.HrNext(&pnccAdapter))))
            {
                GUID guidDev;
                hr = pnccAdapter->GetInstanceGuid(&guidDev);

                if (S_OK == hr)
                {
                    if (guid == guidDev)
                    {
                        hr = HrIsLanCapableAdapter(pnccAdapter);
                        Assert(SUCCEEDED(hr));
                        if (SUCCEEDED(hr))
                        {
                            fFound = TRUE;
                            if (S_FALSE == hr)
                            {
                                *pncm = NCM_PHONE;
                            } 
                            else if (S_OK == hr)
                            {
                                *pncm = NCM_LAN;

                                BOOL            bRet;

                                DWORD dwMediaType;
                                DWORD dwMediaTypeSize = sizeof(DWORD);
                                hr = HrQueryNDISAdapterOID(guid, 
                                                          OID_GEN_PHYSICAL_MEDIUM, 
                                                          &dwMediaTypeSize,
                                                          &dwMediaType);
                                if (S_OK == hr)
                                {
                                    switch (dwMediaType)
                                    {
                                        case NdisPhysicalMedium1394:
                                            *pncms = NCSM_1394;
                                            break;
                                        default:
                                            hr = S_FALSE;
                                            break;
                                    }
                                }

                                if (S_OK != hr) // Couldn't determine the Physical Media type. Try bindings next.
                                {
                                    HRESULT hrPhysicalMedia = hr;

                                    *pncms = NCSM_LAN;

                                    INetCfgComponentBindings* pnccb;
                                    hr = pnccAdapter->QueryInterface(IID_INetCfgComponentBindings,
                                                                       reinterpret_cast<LPVOID *>(&pnccb));
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdisAtm);
                                        if (S_OK == hr)
                                        {
                                            *pncms = NCSM_ATM;
                                        }
                                        pnccb->Release();
                                    }

                                    if (NCSM_ATM != *pncms)
                                    {
                                        // Not ATM
                                        PWSTR pszwCompId;
                                        hr = pnccAdapter->GetId(&pszwCompId);
                                        if (SUCCEEDED(hr))
                                        {
                                            if (0 == lstrcmpiW(c_szInfId_MS_AtmElan, pszwCompId))
                                            {
                                                // ATM Elan
                                                *pncms = NCSM_ELAN;
                                            }

                                            CoTaskMemFree(pszwCompId);
                                        }
                                    }

                                    if ( (FAILED(hrPhysicalMedia)) && 
                                         (NCSM_LAN == *pncms) )
                                    {
                                        // Couldn't determine anything specific from the bindings.
                                        // Return the hr from the Physical Media call if it was an error
                                        hr = hrPhysicalMedia;
                                    }
                                }

                                if (NCSM_LAN == *pncms)
                                {
                                    // Could still be wireless... Check with Zero Config:
                                    if (IsMediaWireless(NCM_LAN, guid))
                                    {
                                        *pncms = NCSM_WIRELESS;
                                    }
                                }
                            } 
                        } // HrIsLanCapableAdapter SUCCEEDED
                    } // guid == guidDev
                } // SUCCEEDED(pnccAdapter->GetInstanceGuid(&guidDev)
                else
                {
                    AssertSz(FALSE, "Could not get instance GUID for Adapter");
                }
                pnccAdapter->Release();
            } // while loop

            HRESULT hrT = pNetCfg->Uninitialize();
            TraceError("INetCfg failed to uninitialize", hrT);
        } // SUCCEEDED(pNetConfig->Initialize(NULL))
        pNetCfg->Release();
    } // SUCCEEDED(CoCreateInstance(pNetCfg))
    else
    {
        AssertSz(FALSE, "Could not create INetCfg");
    }

    TraceErrorOptional("HrGetPseudoMediaTypes", hr, (S_FALSE == hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateName
//
//  Purpose:    Generate a name based on a hint
//
//  Arguments:
//      guid              [in] GUID of connection
//      ncm               [in] NetCon Media Type of Connection
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szHintName        [in]  Hint of name (will use as is if not conflicting)
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::GenerateName(IN  REFGUID          guid, 
                                   IN  NETCON_MEDIATYPE ncm, 
                                   IN  DWORD            dwCharacteristics, 
                                   IN  LPCWSTR          szHint, 
                                   OUT LPWSTR*          szName) const
{
    Assert(szName);
    *szName = NULL;
    
    HRESULT hr = S_OK;

    if (dwCharacteristics & NCCF_INCOMING_ONLY)
    {
        WCHAR szIncomingName[MAX_PATH];
        int nSiz = LoadString(m_hInstance, IDS_DEFAULT_IncomingName, szIncomingName, MAX_PATH);
        AssertSz(nSiz, "Resource string IDS_DEFAULT_IncomingName not found");
        if (nSiz)
        {
            hr = HrCoTaskMemAllocAndDupSz(szIncomingName, szName, NETCON_MAX_NAME_LEN);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        switch (ncm)
        { 
            case NCM_NONE:
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_IncomingName, IDS_DEFAULT_IncomingName_Type, szName);
                break;
            case NCM_ISDN:
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_ISDNName, IDS_DEFAULT_ISDNName_Type, szName);
                break;
            case NCM_DIRECT: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_DIRECTName, IDS_DEFAULT_DIRECTName_Type, szName);
                break;
            case NCM_PHONE: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_PHONEName, IDS_DEFAULT_PHONEName_Type, szName);
                break;
            case NCM_TUNNEL: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_VPNName, IDS_DEFAULT_VPNName_Type, szName);
                break;
            case NCM_PPPOE: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_PPPOEName, IDS_DEFAULT_PPPOEName_Type, szName);
                break;
            case NCM_BRIDGE: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_BRIDGEName, IDS_DEFAULT_BRIDGEName_Type, szName);
                break;
            case NCM_SHAREDACCESSHOST_LAN:
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_SAHLANName, IDS_DEFAULT_SAHLANName_Type, szName);
                break;
            case NCM_SHAREDACCESSHOST_RAS: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_SAHRASName, IDS_DEFAULT_SAHRASName_Type, szName);
                break;
            case NCM_LAN: 
                NETCON_MEDIATYPE ncmCheck;
                NETCON_SUBMEDIATYPE pncms;
                {
                    DWORD dwRetries = 15;
                    HRESULT hrT;
                    do
                    {
                        hrT = HrGetPseudoMediaTypes(guid, &ncmCheck, &pncms);
                        if (FAILED(hrT))
                        {
                            Sleep(500); // This is probably being called during device install, so give the adapter some
                                        // time to get itself enabled first.

                            if (dwRetries > 1)
                            {
                                TraceTag(ttidError, "HrGetPseudoMediaTypes failed during device name initialization. Retrying...");
                            }
                            else
                            {
                                TraceTag(ttidError, "HrGetPseudoMediaTypes failed during device name initialization. Giving up.");
                            }
                                
                        }
                    } while (FAILED(hrT) && --dwRetries);

                    if (SUCCEEDED(hrT))
                    {
                        AssertSz(ncmCheck == NCM_LAN, "This LAN adapter thinks it's something else");
                    }
                    else
                    {
                        pncms = NCSM_LAN; // If we run out of time, just give up and assume LAN.
                        TraceTag(ttidError, "Could not determine the exact Media SubType for this adapter. Assuming LAN (and naming it such).");
                    }

                    switch (pncms)
                    {
                        case NCSM_NONE:
                            AssertSz(FALSE, "LAN Connections should not be NCSM_NONE");
                            hr = E_FAIL;
                            break;
                        case NCSM_LAN:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_LANName, IDS_DEFAULT_LANName_Type, szName);
                            break;
                        case NCSM_ATM:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_ATMName, IDS_DEFAULT_ATMName_Type, szName);
                            break;
                        case NCSM_ELAN:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_ELANName, IDS_DEFAULT_ELANName_Type, szName);
                            break;
                        case NCSM_WIRELESS:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_WirelessName, IDS_DEFAULT_WirelessName_Type, szName);
                            break;
                        case NCSM_1394:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_1394Name, IDS_DEFAULT_1394Name_Type, szName);
                            break;
                            
                        default:
                            AssertSz(FALSE, "Unknown submedia type");
                            hr = E_FAIL;
                            break;
                    }
                }
                break;
            default:
                AssertSz(FALSE, "Unknown media type");
                hr= E_FAIL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenDevice
//
//  Purpose:    Open a Driver
//
//  Arguments:
//      DeviceName [in]   Name of device
//
//  Returns: HANDLE of Device or NULL 
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:  Use GetLastError() for error info
//
HANDLE  OpenDevice(IN	PUNICODE_STRING	DeviceName)
{
	OBJECT_ATTRIBUTES	ObjAttr;
	NTSTATUS			Status;
	IO_STATUS_BLOCK		IoStsBlk;
	HANDLE				Handle;

	InitializeObjectAttributes(&ObjAttr,   // Object
							   DeviceName, // Object Name
							   OBJ_CASE_INSENSITIVE, // Attributes
							   NULL,       // root directory 
							   NULL);      // security descriptor

	Status = NtOpenFile(&Handle,
						FILE_GENERIC_READ | FILE_GENERIC_WRITE,
						&ObjAttr,
						&IoStsBlk,
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						FILE_SYNCHRONOUS_IO_NONALERT);
	if (Status != STATUS_SUCCESS)
	{
		SetLastError(RtlNtStatusToDosError(Status));
	}
	return(Handle);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryDeviceOIDByName
//
//  Purpose:    Query an driver for an IOCTL & OID
//
//  Arguments:
//      szDeviceName      [in]     Name of device
//      dwIoControlCode   [in]     Device IO Control code
//      Oid               [in]     OID to query for
//      pnSize            [in out] pnSize - size of buffer, returns size filled into buffer
//      pBuffer           [out]    Buffer
//
//  Returns: HRESULT
//
//  Author:     deonb   4 April 2001
//
//  Notes: 
//
HRESULT HrQueryDeviceOIDByName(IN     LPCWSTR         szDeviceName,
                               IN     DWORD           dwIoControlCode,
                               IN     ULONG           Oid,
                               IN OUT LPDWORD         pnSize,
                               OUT    LPVOID          pbValue)
{
    HRESULT hr = S_OK;
    NDIS_STATISTICS_VALUE StatsBuf;
    HANDLE  hDevice;
    BOOL    fResult = FALSE;

    UNICODE_STRING  ustrDevice;
    ::RtlInitUnicodeString(&ustrDevice, szDeviceName);

    Assert(pbValue);
    ZeroMemory(pbValue, *pnSize);
    
    hDevice = OpenDevice(&ustrDevice);

    if (hDevice != NULL)
    {
        ULONG  cb;

        DWORD dwStatsBufLen = sizeof(NDIS_STATISTICS_VALUE) - sizeof(UCHAR) + *pnSize;
        PNDIS_STATISTICS_VALUE pStatsBuf = reinterpret_cast<PNDIS_STATISTICS_VALUE>(new BYTE[dwStatsBufLen]);
        if (pStatsBuf)
        {
            fResult = DeviceIoControl(hDevice,
                                      dwIoControlCode,                  // IOCTL code
                                      &Oid,                             // input buffer
                                      sizeof(ULONG),                    // input buffer size
                                      pStatsBuf,                        // output buffer
                                      dwStatsBufLen,                    // output buffer size
                                      &cb,                              // bytes returned
                                      NULL);                            // OVERLAPPED structure

            if (fResult)
            {
                *pnSize = cb;
                if (0 == cb)
                {
                    hr = S_FALSE;
                }
                else
                {
                    if (pStatsBuf->DataLength > *pnSize)
                    {
                        AssertSz(FALSE, "Pass a larger buffer for this OID");
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                        *pnSize = 0;
                    }
                    else
                    {
                        memcpy(pbValue, &(pStatsBuf->Data), pStatsBuf->DataLength);
                    }
                }
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
            delete pStatsBuf;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        
        CloseHandle(hDevice);
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, S_FALSE == hr, "HrQueryDeviceOIDByName could not read the device properties for device %S", szDeviceName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryNDISAdapterOID
//
//  Purpose:    Query an NDIS Driver for an OID
//
//  Arguments:
//      guidId      [in]     Guid of device
//      Oid         [in]     OID to query for
//      pnSize      [in out] pnSize - size of buffer, returns size filled into buffer
//      pbValue     [out]    Buffer
//
//  Returns: HRESULT
//
//  Author:     deonb   4 April 2001
//
//  Notes: 
//

HRESULT HrQueryNDISAdapterOID(IN     REFGUID         guidId,
                              IN     NDIS_OID        Oid,
                              IN OUT LPDWORD         pnSize,
                              OUT    LPVOID          pbValue)
{
    WCHAR  szDeviceName[c_cchGuidWithTerm + celems(c_szDevice)];

    lstrcpynW(szDeviceName, c_szDevice, celems(szDeviceName) );
    ::StringFromGUID2(guidId, szDeviceName + (celems(c_szDevice)-1), c_cchGuidWithTerm);
    
    Assert(wcslen(szDeviceName) < c_cchGuidWithTerm + celems(c_szDevice));
    
    return HrQueryDeviceOIDByName(szDeviceName, IOCTL_NDIS_QUERY_SELECTED_STATS, Oid, pnSize, pbValue);
}
                         
//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::IsMediaWireless
//
//  Purpose:    Queries a LAN Card to see if it's 802.1x
//
//  Arguments:
//      ncm      [in] Media type (if not NCM_LAN) function will return false
//      gdDevice [in] GUID of Network Card
//  
//  Returns:    TRUE if WireLess, FALSE if not or error
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:
//
BOOL IsMediaWireless(IN  NETCON_MEDIATYPE ncm, 
                     IN  const GUID &     gdDevice)
{
    BOOL            bRet;

    Assert(gdDevice != GUID_NULL);

    bRet = FALSE;
    // Prime the structure
    
    switch( ncm ) 
    {
        case NCM_LAN:
            INTF_ENTRY intfEntry;
            ZeroMemory(&intfEntry, sizeof(INTF_ENTRY));

            LPOLESTR lpszClsId = NULL;
            HRESULT hr = StringFromCLSID(gdDevice, &lpszClsId);
            if (S_OK == hr)
            {
                intfEntry.wszGuid = lpszClsId;

                DWORD dwErr = WZCQueryInterface(NULL, INTF_OIDSSUPP, &intfEntry, NULL);
                
                hr = HRESULT_FROM_WIN32(dwErr);
                if (S_OK == hr)
                {
                    if (intfEntry.dwCtlFlags & INTFCTL_OIDSSUPP)
                    {
                        bRet = TRUE;
                    }
                }
                CoTaskMemFree(lpszClsId);
            }

            TraceErrorOptional("IsMediaWireless failed with", hr, (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) );
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::IsMedia1394
//
//  Purpose:    Queries a LAN Card to see if it's 1394 (FireWire / iLink)
//
//  Arguments:
//      ncm      [in] Media type (if not NCM_LAN) function will return false
//      gdDevice [in] GUID of Network Card
//
//  Returns:    TRUE if WireLess, FALSE if not or error
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:
//
BOOL IsMedia1394(IN  NETCON_MEDIATYPE ncm, 
                 IN  const GUID &     gdDevice)
{
    BOOL            bRet;

    Assert(gdDevice != GUID_NULL);

    bRet = FALSE;
    // Prime the structure
    
    switch( ncm ) 
    {
        case NCM_LAN:
            // Retrieve the statistics
            DWORD dwMediaType;
            DWORD dwMediaTypeSize = sizeof(DWORD);
            HRESULT hr = HrQueryNDISAdapterOID(gdDevice, 
                                      OID_GEN_PHYSICAL_MEDIUM, 
                                      &dwMediaTypeSize,
                                      &dwMediaType);
            if (SUCCEEDED(hr))
            {
               bRet = (dwMediaType == NdisPhysicalMedium1394);
            }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncatlps.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L P S . C P P
//
//  Contents:   Class implementation for ATL-like property sheet page object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include "ncatlps.h"

CPropSheetPage::~CPropSheetPage ()
{
    // If we are attached to a window, DWL_USER contains a pointer to this.
    // Remove it since we are going away.
    //
    if (m_hWnd)
    {
        const CPropSheetPage* pps;
        pps = (CPropSheetPage *) ::GetWindowLongPtr(m_hWnd, DWLP_USER);
        if (pps)
        {
            AssertSz (pps == this, "Why isn't DWL_USER equal to 'this'?");
            ::SetWindowLongPtr(m_hWnd, DWLP_USER, NULL);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::CreatePage
//
//  Purpose:    Method to quickly create a property page.
//
//  Arguments:
//      unId    [in]    IDD of dialog resource ID
//      dwFlags [in]    Additional flags to use in the dwFlags field of the
//                      PROPSHEETPAGE struct.
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     shaunco   28 Feb 1997
//
//  Notes:
//
HPROPSHEETPAGE CPropSheetPage::CreatePage(UINT unId, DWORD dwFlags,
                                          PCWSTR pszHeaderTitle,
                                          PCWSTR pszHeaderSubTitle,
                                          PCWSTR pszTitle)
{
    Assert(unId);

    PROPSHEETPAGE   psp = {0};

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = dwFlags;
    psp.hInstance   = _Module.GetModuleInstance();
    psp.pszTemplate = MAKEINTRESOURCE(unId);
    psp.pfnDlgProc  = CPropSheetPage::DialogProc;
    psp.pfnCallback = static_cast<LPFNPSPCALLBACK>
            (CPropSheetPage::PropSheetPageProc);
    psp.lParam      = (LPARAM)this;

    psp.pszHeaderTitle = pszHeaderTitle;
    psp.pszHeaderSubTitle = pszHeaderSubTitle;

    psp.pszTitle = pszTitle;

    return ::CreatePropertySheetPage(&psp);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::DialogProc
//
//  Purpose:    Dialog proc for ATL property sheet pages.
//
//  Arguments:
//      hWnd   [in]
//      uMsg   [in]     See the ATL documentation.
//      wParam [in]
//      lParam [in]
//
//  Returns:    LRESULT
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
INT_PTR CALLBACK CPropSheetPage::DialogProc(HWND hWnd, UINT uMsg,
                                            WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRes;
    PROPSHEETPAGE*  ppsp;
    CPropSheetPage* pps;
    BOOL            fRes = FALSE;

    if (uMsg == WM_INITDIALOG)
    {
        ppsp = (PROPSHEETPAGE *)lParam;
        pps = (CPropSheetPage *)ppsp->lParam;
        ::SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) pps);
        pps->Attach(hWnd);
    }
    else
    {
        pps = (CPropSheetPage *)::GetWindowLongPtr(hWnd, DWLP_USER);

        // Until we get WM_INITDIALOG, just return FALSE
        if (!pps)
            return FALSE;
    }

    if (pps->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lRes, 0))
    {
        switch (uMsg)
        {
        case WM_COMPAREITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:
        case WM_QUERYDRAGICON:
            return lRes;
            break;
        }

        ::SetWindowLongPtr(hWnd, DWLP_MSGRESULT, lRes);
        fRes = TRUE;
    }

    return fRes;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::PropSheetPageProc
//
//  Purpose:    PropSheetPageProc for ATL property sheet pages.
//
//  Arguments:
//      hWnd   [in]
//      uMsg   [in]     See Win32 documentation.
//      ppsp   [in]
//
//  Returns:    UINT
//
//  Author:     billbe   6 Jul 1997
//
//  Notes:
//
UINT CALLBACK CPropSheetPage::PropSheetPageProc(HWND hWnd, UINT uMsg,
                                                LPPROPSHEETPAGE ppsp)
{
    CPropSheetPage* pps;

    // The this pointer was stored in the structure's lParam
    pps = reinterpret_cast<CPropSheetPage *>(ppsp->lParam);

    // This has to be valid since the CreatePage member fcn sets it
    Assert(pps);

    UINT uRet = TRUE;

    // call the correct handler based on uMsg
    //
    if (PSPCB_CREATE == uMsg)
    {
        uRet = pps->UCreatePageCallbackHandler();
    }
    else if (PSPCB_RELEASE == uMsg)
    {
        pps->DestroyPageCallbackHandler();
    }
    else
    {
        AssertSz(FALSE, "Invalid or new message sent to call back!");
    }

    return (uRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\afilestr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A F I L E S T R . C P P
//
//  Contents:   Strings found in the answer file.
//
//  Notes:
//
//  Author:     kumarp   17 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

// ----------------------------------------------------------------------
// General

CONST_GLOBAL WCHAR c_szAfNone[]                         = L"None";
CONST_GLOBAL WCHAR c_szAfUnknown[]                      = L"Unknown";
CONST_GLOBAL WCHAR c_szAfListDelimiter[]                = L",";

CONST_GLOBAL WCHAR c_szAfDisplay[]                      = L"Display";
CONST_GLOBAL WCHAR c_szAfAllowChanges[]                 = L"AllowChanges";
CONST_GLOBAL WCHAR c_szAfOnlyOnError[]                  = L"OnlyOnError";

CONST_GLOBAL WCHAR c_szAfParams[]                       = L"params.";

CONST_GLOBAL WCHAR c_szAfSectionIdentification[]        = L"Identification";
CONST_GLOBAL WCHAR c_szAfSectionNetAdapters[]           = L"NetAdapters";
CONST_GLOBAL WCHAR c_szAfSectionNetProtocols[]          = L"NetProtocols";
CONST_GLOBAL WCHAR c_szAfSectionNetServices[]           = L"NetServices";
CONST_GLOBAL WCHAR c_szAfSectionNetClients[]            = L"NetClients";
CONST_GLOBAL WCHAR c_szAfSectionNetBindings[]           = L"NetBindings";



CONST_GLOBAL WCHAR c_szAfAdapterSections[]              = L"AdapterSections";
CONST_GLOBAL WCHAR c_szAfSpecificTo[]                   = L"SpecificTo";
CONST_GLOBAL WCHAR c_szAfCleanup[]                      = L"CleanUp";

CONST_GLOBAL WCHAR c_szAfInfid[]                        = L"InfID";
CONST_GLOBAL WCHAR c_szAfInfidReal[]                    = L"InfIDReal";
CONST_GLOBAL WCHAR c_szAfInstance[]                     = L"Instance";

CONST_GLOBAL WCHAR c_szAfInstallDefaultComponents[]     = L"InstallDefaultComponents";

// ----------------------------------------------------------------------
// ZAW related
//
CONST_GLOBAL WCHAR c_szAfNetComponentsToRemove[]        = L"NetComponentsToRemove";

// ----------------------------------------------------------------------
// OEM upgrade related
//
CONST_GLOBAL WCHAR c_szAfOemSection[]                   = L"OemSection";
CONST_GLOBAL WCHAR c_szAfOemDir[]                       = L"OemDir";
CONST_GLOBAL WCHAR c_szAfOemDllToLoad[]                 = L"OemDllToLoad";
CONST_GLOBAL WCHAR c_szAfOemInf[]                       = L"OemInfFile";
CONST_GLOBAL WCHAR c_szAfSkipInstall[]                  = L"SkipInstall";

// ----------------------------------------------------------------------
// Network upgrade related
//
CONST_GLOBAL WCHAR c_szAfSectionNetworking[]            = L"Networking";
CONST_GLOBAL WCHAR c_szAfUpgradeFromProduct[]           = L"UpgradeFromProduct";
CONST_GLOBAL WCHAR c_szAfBuildNumber[]                  = L"BuildNumber";

CONST_GLOBAL WCHAR c_szAfProcessPageSections[]          = L"ProcessPageSections";

CONST_GLOBAL WCHAR c_szAfNtServer[]                     = L"WindowsNTServer";
CONST_GLOBAL WCHAR c_szAfNtSbServer[]                   = L"WindowsNTSBServer";
CONST_GLOBAL WCHAR c_szAfNtWorkstation[]                = L"WindowsNTWorkstation";
CONST_GLOBAL WCHAR c_szAfWin95[]                        = L"Windows95";
CONST_GLOBAL WCHAR c_szAfDisableServices[]              = L"DisableServices";

CONST_GLOBAL CHAR c_szaOemUpgradeFunction[]             = "HrOemUpgrade";

CONST_GLOBAL WCHAR c_szRegKeyAnswerFileMap[]            = L"SYSTEM\\Setup\\AnswerFileMap";

CONST_GLOBAL WCHAR c_szAfPreUpgradeRouter[]             = L"PreUpgradeRouter";
CONST_GLOBAL WCHAR c_szAfNwSapAgentParams[]             = L"Sap.Parameters";
CONST_GLOBAL WCHAR c_szAfIpRipParameters[]              = L"IpRip.Parameters";
CONST_GLOBAL WCHAR c_szAfDhcpRelayAgentParameters[]     = L"RelayAgent.Parameters";
CONST_GLOBAL WCHAR c_szAfRadiusParameters[]             = L"Radius.Parameters";


CONST_GLOBAL WCHAR c_szAfMiscUpgradeData[]              = L"MiscUpgradeData";
CONST_GLOBAL WCHAR c_szAfSapAgentUpgrade[]              = L"SapAgentUpgrade";

CONST_GLOBAL WCHAR c_szAfServiceStartTypes[]            = L"ServiceStartTypes";
CONST_GLOBAL WCHAR c_szAfTapiSrvRunInSeparateInstance[] = L"TapiServerRunInSeparateInstance";

// ----------------------------------------------------------------------
// Net card related

//Hardware Bus-Types

CONST_GLOBAL WCHAR c_szAfInfIdWildCard[]                = L"*";

CONST_GLOBAL WCHAR c_szAfNetCardAddr[]                  = L"NetCardAddress";

CONST_GLOBAL WCHAR c_szAfBusType[]                      = L"BusType";

CONST_GLOBAL WCHAR c_szAfBusInternal[]                  = L"Internal";
CONST_GLOBAL WCHAR c_szAfBusIsa[]                       = L"ISA";
CONST_GLOBAL WCHAR c_szAfBusEisa[]                      = L"EISA";
CONST_GLOBAL WCHAR c_szAfBusMicrochannel[]              = L"MCA";
CONST_GLOBAL WCHAR c_szAfBusTurbochannel[]              = L"TurboChannel";
CONST_GLOBAL WCHAR c_szAfBusPci[]                       = L"PCI";
CONST_GLOBAL WCHAR c_szAfBusVme[]                       = L"VME";
CONST_GLOBAL WCHAR c_szAfBusNu[]                        = L"Nu";
CONST_GLOBAL WCHAR c_szAfBusPcmcia[]                    = L"PCMCIA";
CONST_GLOBAL WCHAR c_szAfBusC[]                         = L"C";
CONST_GLOBAL WCHAR c_szAfBusMpi[]                       = L"MPI";
CONST_GLOBAL WCHAR c_szAfBusMpsa[]                      = L"MPSA";
CONST_GLOBAL WCHAR c_szAfBusProcessorinternal[]         = L"ProcessorInternal";
CONST_GLOBAL WCHAR c_szAfBusInternalpower[]             = L"InternalPower";
CONST_GLOBAL WCHAR c_szAfBusPnpisa[]                    = L"PNPISA";

//Net card parameters
CONST_GLOBAL WCHAR c_szAfAdditionalParams[]             = L"AdditionalParams";
CONST_GLOBAL WCHAR c_szAfPseudoAdapter[]                = L"PseudoAdapter";
CONST_GLOBAL WCHAR c_szAfDetect[]                       = L"Detect";
CONST_GLOBAL WCHAR c_szAfIoAddr[]                       = L"IOAddr";
CONST_GLOBAL WCHAR c_szAfIrq[]                          = L"IRQ";
CONST_GLOBAL WCHAR c_szAfDma[]                          = L"DMA";
CONST_GLOBAL WCHAR c_szAfMem[]                          = L"MEM";
CONST_GLOBAL WCHAR c_szAfTransceiverType[]              = L"TransceiverType";
CONST_GLOBAL WCHAR c_szAfSlotNumber[]                   = L"SlotNumber";
CONST_GLOBAL WCHAR c_szAfConnectionName[]               = L"ConnectionName";

//Transceiver Types
CONST_GLOBAL WCHAR c_szAfThicknet[]                     = L"ThickNet";
CONST_GLOBAL WCHAR c_szAfThinnet[]                      = L"ThinNet";
CONST_GLOBAL WCHAR c_szAfTp[]                           = L"TP";
CONST_GLOBAL WCHAR c_szAfAuto[]                         = L"Auto";

// Netcard upgrade specific
CONST_GLOBAL WCHAR c_szAfPreUpgradeInstance[]           = L"PreUpgradeInstance";


// ----------------------------------------------------------------------
// Identification Page related

CONST_GLOBAL WCHAR c_szAfComputerName[]                 = L"ComputerName";
CONST_GLOBAL WCHAR c_szAfJoinWorkgroup[]                = L"JoinWorkgroup";
CONST_GLOBAL WCHAR c_szAfJoinDomain[]                   = L"JoinDomain";

CONST_GLOBAL WCHAR c_szAfDomainAdmin[]                  = L"DomainAdmin";
CONST_GLOBAL WCHAR c_szAfDomainAdminPassword[]          = L"DomainAdminPassword";
CONST_GLOBAL WCHAR c_szAfMachineObjectOU[]              = L"MachineObjectOU";
CONST_GLOBAL WCHAR c_szAfUnsecureJoin[]                 = L"DoOldStyleDomainJoin";

// For Secure Domain Join Support, the computer account password
CONST_GLOBAL WCHAR c_szAfComputerPassword[]             = L"ComputerPassword";


// ----------------------------------------------------------------------
// Protocols related

//TCPIP
CONST_GLOBAL WCHAR c_szAfEnableSecurity[]               = L"EnableSecurity";
CONST_GLOBAL WCHAR c_szAfEnableICMPRedirect[]           = L"EnableICMPRedirect";
CONST_GLOBAL WCHAR c_szAfDeadGWDetectDefault[]          = L"DeadGWDetectDefault";
CONST_GLOBAL WCHAR c_szAfDontAddDefaultGatewayDefault[] = L"DontAddDefaultGatewayDefault";

CONST_GLOBAL WCHAR c_szAfIpAllowedProtocols[]           = L"IpAllowedProtocols";
CONST_GLOBAL WCHAR c_szAfTcpAllowedPorts[]              = L"TcpAllowedPorts";
CONST_GLOBAL WCHAR c_szAfUdpAllowedPorts[]              = L"UdpAllowedPorts";

CONST_GLOBAL WCHAR c_szDatabasePath[]                   = L"DatabasePath";
CONST_GLOBAL WCHAR c_szAfForwardBroadcasts[]            = L"ForwardBroadcasts";
CONST_GLOBAL WCHAR c_szAfPPTPTcpMaxDataRetransmissions[]= L"PPTPTcpMaxDataRetransmissions";
CONST_GLOBAL WCHAR c_szAfUseZeroBroadcast[]             = L"UseZeroBroadcast";
CONST_GLOBAL WCHAR c_szAfArpAlwaysSourceRoute[]         = L"ArpAlwaysSourceRoute";
CONST_GLOBAL WCHAR c_szAfArpCacheLife[]                 = L"ArpCacheLife";
CONST_GLOBAL WCHAR c_szAfArpTRSingleRoute[]             = L"ArpTRSingleRoute";
CONST_GLOBAL WCHAR c_szAfArpUseEtherSNAP[]              = L"ArpUseEtherSNAP";
CONST_GLOBAL WCHAR c_szAfDefaultTOS[]                   = L"DefaultTOS";
CONST_GLOBAL WCHAR c_szDefaultTTL[]                     = L"DefaultTTL";
CONST_GLOBAL WCHAR c_szEnableDeadGWDetect[]             = L"EnableDeadGWDetect";
CONST_GLOBAL WCHAR c_szEnablePMTUBHDetect[]             = L"EnablePMTUBHDetect";
CONST_GLOBAL WCHAR c_szEnablePMTUDiscovery[]            = L"EnablePMTUDiscovery";
CONST_GLOBAL WCHAR c_szForwardBufferMemory[]            = L"ForwardBufferMemory";
CONST_GLOBAL WCHAR c_szHostname[]                       = L"HostName";
CONST_GLOBAL WCHAR c_szIGMPLevel[]                      = L"IGMPLevel";
CONST_GLOBAL WCHAR c_szKeepAliveInterval[]              = L"KeepAliveInterval";
CONST_GLOBAL WCHAR c_szKeepAliveTime[]                  = L"KeepAliveTime";
CONST_GLOBAL WCHAR c_szMaxForwardBufferMemory[]         = L"MaxForwardBufferMemory";
CONST_GLOBAL WCHAR c_szMaxForwardPending[]              = L"MaxForwardPending";
CONST_GLOBAL WCHAR c_szMaxNumForwardPackets[]           = L"MaxNumForwardPackets";
CONST_GLOBAL WCHAR c_szMaxUserPort[]                    = L"MaxUserPort";
CONST_GLOBAL WCHAR c_szMTU[]                            = L"MTU";
CONST_GLOBAL WCHAR c_szNumForwardPackets[]              = L"NumForwardPackets";
CONST_GLOBAL WCHAR c_szTcpMaxConnectRetransmissions[]   = L"TcpMaxConnectRetransmissions";
CONST_GLOBAL WCHAR c_szTcpMaxDataRetransmissions[]      = L"TcpMaxDataRetransmissions";
CONST_GLOBAL WCHAR c_szTcpNumConnections[]              = L"TcpNumConnections";
CONST_GLOBAL WCHAR c_szTcpTimedWaitDelay []             = L"TcpTimedWaitDelay";
CONST_GLOBAL WCHAR c_szTcpUseRFC1122UrgentPointer[]     = L"TcpUseRFC1122UrgentPointer";
CONST_GLOBAL WCHAR c_szDefaultGateway[]                 = L"DefaultGateway";
CONST_GLOBAL WCHAR c_szDomain[]                         = L"Domain";
CONST_GLOBAL WCHAR c_szEnableSecurityFilters[]          = L"EnableSecurityFilters";
CONST_GLOBAL WCHAR c_szNameServer[]                     = L"NameServer";
CONST_GLOBAL WCHAR c_szMaxFreeTcbs[]                    = L"MaxFreeTcbs";
CONST_GLOBAL WCHAR c_szMaxHashTableSize[]               = L"MaxHashTableSize";
CONST_GLOBAL WCHAR c_szEnableAddrMaskReply[]            = L"EnableAddrMaskReply";
CONST_GLOBAL WCHAR c_szPersistentRoutes[]               = L"PersistentRoutes";
CONST_GLOBAL WCHAR c_szArpCacheMinReferencedLife[]      = L"ArpCacheMinReferencedLife";
CONST_GLOBAL WCHAR c_szArpRetryCount[]                  = L"ArpRetryCount";
CONST_GLOBAL WCHAR c_szTcpMaxConnectresponseRetransmissions[] = L"TcpMaxConnectresponseRetransmissions";
CONST_GLOBAL WCHAR c_szTcpMaxDupAcks[]                  = L"TcpMaxDupAcks";
CONST_GLOBAL WCHAR c_szSynAttackProtect[]               = L"SynAttackProtect";
CONST_GLOBAL WCHAR c_szTCPMaxPortsExhausted[]           = L"TCPMaxPortsExhausted";
CONST_GLOBAL WCHAR c_szTCPMaxHalfOpen[]                 = L"TCPMaxHalfOpen";
CONST_GLOBAL WCHAR c_szTCPMaxHalfOpenRetried[]          = L"TCPMaxHalfOpenRetried";
CONST_GLOBAL WCHAR c_szDontAddDefaultGateway[]          = L"DontAddDefaultGateway";
CONST_GLOBAL WCHAR c_szPPTPFiltering[]                  = L"PPTPFiltering";
CONST_GLOBAL WCHAR c_szDhcpClassId[]                    = L"DhcpClassId";
CONST_GLOBAL WCHAR c_szSyncDomainWithMembership[]       = L"SyncDomainWithMembership";

CONST_GLOBAL WCHAR c_szAfSectionWinsock[]               = L"Winsock";
CONST_GLOBAL WCHAR c_szAfKeyWinsockOrder[]              = L"ProviderOrder";

//NetBt
CONST_GLOBAL WCHAR c_szBcastNameQueryCount[]            = L"BcastNameQueryCount";
CONST_GLOBAL WCHAR c_szBcastQueryTimeout[]              = L"BcastQueryTimeout";
CONST_GLOBAL WCHAR c_szCacheTimeout[]                   = L"CacheTimeout";
CONST_GLOBAL WCHAR c_szNameServerPort[]                 = L"NameServerPort";
CONST_GLOBAL WCHAR c_szNameSrvQueryCount[]              = L"NameSrvQueryCount";
CONST_GLOBAL WCHAR c_szNameSrvQueryTimeout[]            = L"NameSrvQueryTimeout";
CONST_GLOBAL WCHAR c_szSessionKeepAlive[]               = L"SessionKeepAlive";
CONST_GLOBAL WCHAR c_szSizeSmallMediumLarge[]           = L"Size/Small/Medium/Large";
CONST_GLOBAL WCHAR c_szBroadcastAddress[]               = L"BroadcastAddress";
CONST_GLOBAL WCHAR c_szEnableProxyRegCheck[]            = L"EnableProxyRegCheck";
CONST_GLOBAL WCHAR c_szInitialRefreshTimeout[]          = L"InitialRefreshTimeout";
CONST_GLOBAL WCHAR c_szLmhostsTimeout[]                 = L"LmhostsTimeout";
CONST_GLOBAL WCHAR c_szMaxDgramBuffering[]              = L"MaxDgramBuffering";
CONST_GLOBAL WCHAR c_szNodeType[]                       = L"NodeType";
CONST_GLOBAL WCHAR c_szRandomAdapter[]                  = L"RandomAdapter";
CONST_GLOBAL WCHAR c_szRefreshOpCode[]                  = L"RefreshOpCode";
CONST_GLOBAL WCHAR c_szSingleResponse[]                 = L"SingleResponse";
CONST_GLOBAL WCHAR c_szWinsDownTimeout[]                = L"WinsDownTimeout";
CONST_GLOBAL WCHAR c_szEnableProxy[]                    = L"EnableProxy";

//DNS
CONST_GLOBAL WCHAR c_szAfDns[]                          = L"DNS";
CONST_GLOBAL WCHAR c_szAfDnsHostname[]                  = L"DNSHostName";
CONST_GLOBAL WCHAR c_szAfDnsDomain[]                    = L"DNSDomain";
CONST_GLOBAL WCHAR c_szAfDnsServerSearchOrder[]         = L"DNSServerSearchOrder";
CONST_GLOBAL WCHAR c_szAfDnsSuffixSearchOrder[]         = L"DNSSuffixSearchOrder";
CONST_GLOBAL WCHAR c_szAfUseDomainNameDevolution[]      = L"UseDomainNameDevolution";
CONST_GLOBAL WCHAR c_szAfDisableDynamicUpdate[]         = L"DisableDynamicUpdate";
CONST_GLOBAL WCHAR c_szAfEnableAdapterDomainNameRegistration[]      
                                                        = L"EnableAdapterDomainNameRegistration";

//DHCP
CONST_GLOBAL WCHAR c_szAfDhcp[]                         = L"DHCP";
CONST_GLOBAL WCHAR c_szAfIpaddress[]                    = L"IPAddress";
CONST_GLOBAL WCHAR c_szAfSubnetmask[]                   = L"SubnetMask";
CONST_GLOBAL WCHAR c_szAfDefaultGateway[]               = L"DefaultGateway";
CONST_GLOBAL WCHAR c_szAfBindToDhcpServer[]             = L"BindToDhcpServer";

//WINS
CONST_GLOBAL WCHAR c_szAfWins[]                         = L"WINS";
CONST_GLOBAL WCHAR c_szAfWinsServerList[]               = L"WINSServerList";
CONST_GLOBAL WCHAR c_szAfScopeid[]                      = L"ScopeID";
CONST_GLOBAL WCHAR c_szAfEnableLmhosts[]                = L"EnableLMHosts";
CONST_GLOBAL WCHAR c_szAfImportLmhostsFile[]            = L"ImportLMHostsFile";
CONST_GLOBAL WCHAR c_szAfNetBIOSOptions[]               = L"NetBIOSOptions";

//IPX
CONST_GLOBAL WCHAR c_szAfInternalNetworkNumber[]        = L"VirtualNetworkNumber";
CONST_GLOBAL WCHAR c_szAfFrameType[]                    = L"FrameType";

// ----------------------------------------------------------------------
// Services

//MS_NetClient
CONST_GLOBAL WCHAR c_szAfMsNetClient[]                  = L"MS_NetClient";
CONST_GLOBAL WCHAR c_szAfComputerBrowser[]              = L"ComputerBrowser";
CONST_GLOBAL WCHAR c_szAfBrowseDomains[]                = L"BrowseDomains";
CONST_GLOBAL WCHAR c_szAfDefaultProvider[]              = L"DefaultSecurityProvider";
CONST_GLOBAL WCHAR c_szAfNameServiceAddr[]              = L"NameServiceNetworkAddress";
CONST_GLOBAL WCHAR c_szAfNameServiceProtocol[]          = L"NameServiceProtocol";

//LanmanServer
CONST_GLOBAL WCHAR c_szAfBrowserParameters[]            = L"Browser.Parameters";
CONST_GLOBAL WCHAR c_szAfNetLogonParameters[]           = L"NetLogon.Parameters";

CONST_GLOBAL WCHAR c_szAfLmServerShares[]               = L"LanmanServer.Shares";
CONST_GLOBAL WCHAR c_szAfLmServerParameters[]           = L"LanmanServer.Parameters";
CONST_GLOBAL WCHAR c_szAfLmServerAutotunedParameters[]  = L"LanmanServer.AutotunedParameters";

CONST_GLOBAL WCHAR c_szAfLmServerOptimization[]         = L"Optimization";
CONST_GLOBAL WCHAR c_szAfBroadcastToClients[]           = L"BroadcastsToLanman2Clients";

CONST_GLOBAL WCHAR c_szAfMinmemoryused[]                = L"MinMemoryUsed";
CONST_GLOBAL WCHAR c_szAfBalance[]                      = L"Balance";
CONST_GLOBAL WCHAR c_szAfMaxthroughputforfilesharing[]  = L"MaxThroughputForFileSharing";
CONST_GLOBAL WCHAR c_szAfMaxthrouputfornetworkapps[]    = L"MaxThroughputForNetworkApps";



//RAS
CONST_GLOBAL WCHAR c_szAfParamsSection[]                = L"ParamsSection";

CONST_GLOBAL WCHAR c_szAfPortSections[]                 = L"PortSections";
CONST_GLOBAL WCHAR c_szAfPortname[]                     = L"PortName";
CONST_GLOBAL WCHAR c_szAfPortUsage[]                    = L"PortUsage";
CONST_GLOBAL WCHAR c_szAfPortUsageClient[]              = L"Client";
CONST_GLOBAL WCHAR c_szAfPortUsageServer[]              = L"Server";
CONST_GLOBAL WCHAR c_szAfPortUsageRouter[]              = L"Router";

CONST_GLOBAL WCHAR c_szAfSetDialinUsage[]               = L"SetDialInUsage";

CONST_GLOBAL WCHAR c_szAfForceEncryptedPassword[]       = L"ForceEncryptedPassword";
CONST_GLOBAL WCHAR c_szAfForceEncryptedData[]           = L"ForceEncryptedData";
CONST_GLOBAL WCHAR c_szAfForceStrongEncryption[]        = L"ForceStrongEncryption";
CONST_GLOBAL WCHAR c_szAfMultilink[]                    = L"Multilink";
CONST_GLOBAL WCHAR c_szAfRouterType[]                   = L"RouterType";
CONST_GLOBAL WCHAR c_szAfSecureVPN[]                    = L"SecureVPN";

CONST_GLOBAL WCHAR c_szAfDialinProtocols[]              = L"DialinProtocols";

CONST_GLOBAL WCHAR c_szAfDialIn[]                       = L"DialIn";
CONST_GLOBAL WCHAR c_szAfDialOut[]                      = L"DialOut";
CONST_GLOBAL WCHAR c_szAfDialInOut[]                    = L"DialInOut";

CONST_GLOBAL WCHAR c_szAfAppleTalk[]                    = L"APPLETALK";
CONST_GLOBAL WCHAR c_szAfNetbeui[]                      = L"NETBEUI";
CONST_GLOBAL WCHAR c_szAfTcpip[]                        = L"TCP/IP";
CONST_GLOBAL WCHAR c_szAfIpx[]                          = L"IPX";

CONST_GLOBAL WCHAR c_szAfNetbeuiClientAccess[]          = L"NetBEUIClientAccess";
CONST_GLOBAL WCHAR c_szAfTcpipClientAccess[]            = L"TcpIpClientAccess";
CONST_GLOBAL WCHAR c_szAfIpxClientAccess[]              = L"IpxClientAccess";
CONST_GLOBAL WCHAR c_szAfNetwork[]                      = L"Network";
CONST_GLOBAL WCHAR c_szAfThisComputer[]                 = L"ThisComputer";

CONST_GLOBAL WCHAR c_szAfUseDhcp[]                      = L"UseDHCP";
CONST_GLOBAL WCHAR c_szAfIpAddressStart[]               = L"IpAddressStart";
CONST_GLOBAL WCHAR c_szAfIpAddressEnd[]                 = L"IpAddressEnd";
CONST_GLOBAL WCHAR c_szAfExcludeAddress[]               = L"ExcludeAddress";

CONST_GLOBAL WCHAR c_szAfClientCanReqIpaddr[]           = L"ClientCanRequestIPAddress";
CONST_GLOBAL WCHAR c_szAfWanNetPoolSize[]               = L"WanNetpoolSize";
CONST_GLOBAL WCHAR c_szAfAutoNetworkNumbers[]           = L"AutomaticNetworkNumbers";
CONST_GLOBAL WCHAR c_szAfNetNumberFrom[]                = L"NetworkNumberFrom";
CONST_GLOBAL WCHAR c_szAfSameNetworkNumber[]            = L"AssignSameNetworkNumber";
CONST_GLOBAL WCHAR c_szAfClientReqNodeNumber[]          = L"ClientsCanRequestIpxNodeNumber";

//L2TP
CONST_GLOBAL WCHAR c_szAfL2tpMaxVcs[]                   = L"MaxVcs";
CONST_GLOBAL WCHAR c_szAfL2tpEndpoints[]                = L"WanEndpoints";

//PPTP
CONST_GLOBAL WCHAR c_szAfPptpEndpoints[]                = L"NumberLineDevices";

//Bindings
CONST_GLOBAL WCHAR c_szAfDisable[]                      = L"Disable";
CONST_GLOBAL WCHAR c_szAfEnable[]                       = L"Enable";
CONST_GLOBAL WCHAR c_szAfPromote[]                      = L"Promote";
CONST_GLOBAL WCHAR c_szAfDemote[]                       = L"Demote";

CONST_GLOBAL WCHAR c_szAfDhcpServerParameters[]         = L"DhcpServer.Parameters";
CONST_GLOBAL WCHAR c_szAfDhcpServerConfiguration[]      = L"DhcpServer.Configuration";

CONST_GLOBAL WCHAR c_szAfNWCWorkstationParameters[]     = L"NWCWorkstation.Parameters";
CONST_GLOBAL WCHAR c_szAfNWCWorkstationShares[]         = L"NWCWorkstation.Shares";
CONST_GLOBAL WCHAR c_szAfNWCWorkstationDrives[]         = L"NWCWorkstation.Drives";

// ----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncipaddr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I P A D D R . C P P
//
//  Contents:   WCHAR support for Winsock inet_ functions.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncipaddr.h"

VOID
IpHostAddrToPsz(
    IN  DWORD  dwAddr,
    OUT PWSTR  pszBuffer)
{
    BYTE* pb = (BYTE*)&dwAddr;
    static const WCHAR c_szIpAddr [] = L"%d.%d.%d.%d";
    wsprintfW (pszBuffer, c_szIpAddr, pb[3], pb[2], pb[1], pb[0]);
}

DWORD
IpPszToHostAddr(
    IN  PCWSTR cp)
{
    DWORD val, base, n;
    WCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == L'0')
    {
        base = 8, cp++;
    }
    if (*cp == L'x' || *cp == L'X')
    {
        base = 16, cp++;
    }
    while (c = *cp)
    {
        if ((c >= L'0') && (c <= L'9'))
        {
            val = (val * base) + (c - L'0');
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= L'0') && (c <= L'9')) ||
              ((c >= L'A') && (c <= L'F')) ||
              ((c >= L'a') && (c <= L'f')) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= L'a') && (c <= L'f'))
                            ? L'a'
                            : L'A' ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == L'.')
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
        {
            return (DWORD) -1;
        }
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != L' '))
    {
        return 0xffffffff;
    }

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD)(pp - parts);
    switch (n)
    {
        case 1:             // a -- 32 bits
            val = parts[0];
            break;

        case 2:             // a.b -- 8.24 bits
            val = (parts[0] << 24) | (parts[1] & 0xffffff);
            break;

        case 3:             // a.b.c -- 8.8.16 bits
            val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                (parts[2] & 0xffff);
            break;

        case 4:             // a.b.c.d -- 8.8.8.8 bits
            val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                  ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
            break;

        default:
            return 0xffffffff;
    }

    return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncmisc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N C M I S C . C P P
//
//  Contents:   Miscellaneous common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "nceh.h"
#include <eh.h>

//+---------------------------------------------------------------------------
//
//  Function:   FInSystemSetup
//
//  Purpose:    Determines whether the machine is in GUI mode setup or not.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if in GUI mode (system) setup, FALSE if not.
//
//  Author:     danielwe   13 Jun 1997
//
//  Notes:      The state is cached (since it can't change without a reboot)
//              so call as often as you like.  No need to keep you're own
//              cached copy.
//
BOOL
FInSystemSetup ()
{
    enum SETUP_STATE
    {
        SS_UNKNOWN = 0,         // state unknown
        SS_NOTINSETUP,          // not in setup mode
        SS_SYSTEMSETUP          // in GUI mode setup
    };

    static SETUP_STATE s_CachedSetupState = SS_UNKNOWN;

    if (SS_UNKNOWN == s_CachedSetupState)
    {
        s_CachedSetupState = SS_NOTINSETUP;

        // Open the setup key
        //
        HRESULT hr;
        HKEY hkeySetup;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Setup",
                KEY_READ, &hkeySetup);

        if (S_OK == hr)
        {
            // get the value of the setup in progress
            //
            DWORD   dwSysSetup;

            hr = HrRegQueryDword(hkeySetup, L"SystemSetupInProgress",
                    &dwSysSetup);

            if ((S_OK == hr) && dwSysSetup)
            {
                s_CachedSetupState = SS_SYSTEMSETUP;
            }

            RegCloseKey(hkeySetup);
        }
    }

    Assert (SS_UNKNOWN != s_CachedSetupState);

    return (SS_SYSTEMSETUP == s_CachedSetupState);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProductFlavor
//
//  Purpose:    Returns the flavor of NT currenty running on the machine.
//
//  Arguments:
//      pvReserved [in]     Reserved.  Must be NULL.
//      ppf        [out]    Returned flavor.
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
NOTHROW
VOID
GetProductFlavor (
    const void*     pvReserved,
    PRODUCT_FLAVOR* ppf)
{
    NT_PRODUCT_TYPE Type;

    Assert(!pvReserved);
    Assert(ppf);

    // Assume workstation product
    //
    *ppf = PF_WORKSTATION;

    // Even if RtlGetProductType fails, its documented to return
    // NtProductWinNt.
    //
    RtlGetNtProductType (&Type);
    if (NtProductWinNt != Type)
    {
        *ppf = PF_SERVER;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsNetworkingInstalled
//
//  Purpose:    Returns whether networking is installed.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if networking is installed, S_FALSE if not, Win32 error
//              otherwise.
//
//  Author:     danielwe   25 Jun 1997
//
//  Notes:      To determine if networking is installed, the ProviderOrder
//              value of System\CurrentControlSet\Control\NetworkProvider\Order
//              registry key is queried. If any data is present, networking
//              is installed.
//
HRESULT
HrIsNetworkingInstalled ()
{
    HRESULT     hr = S_OK;
    HKEY        hkeyProvider;
    DWORD       cbSize = 0;
    DWORD       dwType;

    extern const WCHAR c_szRegKeyCtlNPOrder[];
    extern const WCHAR c_szProviderOrder[];

    // open the provider key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCtlNPOrder,
            KEY_READ, &hkeyProvider);

    if (S_OK == hr)
    {
        // get the count in bytes of the provider order value
        hr = HrRegQueryValueEx(hkeyProvider, c_szProviderOrder,
                &dwType, (LPBYTE)NULL, &cbSize);

        if (S_OK == hr)
        {
            if (cbSize > 2)
            {
                // if the value was present and it contained information
                // then we have networking of some sorts
                //
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_FALSE;
        }

        RegCloseKey(hkeyProvider);
    }

    TraceError("HrIsNetworkingInstalled", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

#ifdef REMOTEBOOT
//+---------------------------------------------------------------------------
//
//  Function:   HrIsRemoteBootMachine
//
//  Purpose:    Returns whether this is a remote boot client.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if it is remote boot, S_FALSE if not.
//
//  Author:     adamba   27 Mar 1998
//
//  Notes:      Calls GetSystemInfoEx to determine whether this is a
//              remote boot client.
//
HRESULT HrIsRemoteBootMachine()
{
    BOOL        fIsRemoteBoot;
    BOOL        ok;
    DWORD       size = sizeof(fIsRemoteBoot);

    ok = GetSystemInfoEx(SystemInfoRemoteBoot, &fIsRemoteBoot, &size);
    Assert(ok);

    if (fIsRemoteBoot) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}
#endif  // defined(REMOTEBOOT)

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterOrUnregisterComObject
//
//  Purpose:    Handles registration or unregistration of one or more COM
//                  objects contained in a DLL that supports the
//                  DllRegisterServer or DllUnregisterServer entry points.
//
//  Arguments:
//      pszDllPath [in]  Path to DLL that contains COM object(s) to (un)register.
//      rf         [in]  Function to perform
//
//  Returns:    S_OK if successful, Win32 or OLE HRESULT if failure.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT
HrRegisterOrUnregisterComObject (
        PCWSTR              pszDllPath,
        REGISTER_FUNCTION   rf)
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx( NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED  );
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fCoUninitialize =  FALSE;
    }
    if (SUCCEEDED(hr))
    {
        // ANSI only
        const CHAR c_szaRegisterFunction[]   = "DllRegisterServer";
        const CHAR c_szaUnregisterFunction[] = "DllUnregisterServer";

        typedef HRESULT (CALLBACK *HCRET)(void);

        HCRET   pfnRegister;
        HMODULE hModule;

        // Get a pointer the the registration function in the Dll
        hr = HrLoadLibAndGetProc (pszDllPath,
                ((RF_REGISTER == rf) ?
                    c_szaRegisterFunction : c_szaUnregisterFunction),
                &hModule,
                reinterpret_cast<FARPROC*>(&pfnRegister));

        if (S_OK == hr)
        {
            // Call the registration function
            hr = (*pfnRegister)();

            // RAID #160109 (danielwe) 21 Apr 1998: Handle this error and
            // ignore it.
            if (RPC_E_CHANGED_MODE == hr)
            {
                hr = S_OK;
            }

            TraceError ("HrRegisterOrUnregisterComObject - "
                    "Dll(Un)RegisterServer failed!", hr);
            FreeLibrary (hModule);
        }

        // Balances call to CoInitialize() above. Not harmful if CoInitialize()
        // was called more than once before this.
        if (fCoUninitialize)
        {
            CoUninitialize();
        }
    }

    TraceError ("HrRegisterOrUnregisterComObject", hr);
    return hr;
}

//
// Special case handling for Netbios stopping
//

#include <nb30p.h>      // Netbios IOCTLs and netbios name #define

//+---------------------------------------------------------------------------
//
//  Func:   ScStopNetbios
//
//  Desc:   This function checks if the driver being unloaded is NETBIOS.SYS.
//          If so it performs some special case processing for Netbios.
//
//  Args:   none
//
//  Return: STATUS_SUCCESS if successful, or an error status
//
// History: 28-Apr-98   SumitC      got from VRaman
//
//----------------------------------------------------------------------------
DWORD
ScStopNetbios()
{
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      NbDeviceName;
    IO_STATUS_BLOCK     IoStatus, StopStatus;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    HANDLE              NbHandle = NULL;

    do
    {
        //
        // Driver being stopped is netbios
        //

        //
        // 1. Open a handle to the \\Device\Netbios
        //

        RtlInitUnicodeString(&NbDeviceName, NB_DEVICE_NAME);

        InitializeObjectAttributes(
                &ObjAttr,                           // obj attr to initialize
                &NbDeviceName,                      // string to use
                OBJ_CASE_INSENSITIVE,               // Attributes
                NULL,                               // Root directory
                NULL);                              // Security Descriptor

        ntStatus = NtCreateFile(
                        &NbHandle,                  // ptr to handle
                        GENERIC_READ|GENERIC_WRITE, // desired access
                        &ObjAttr,                   // name & attributes
                        &IoStatus,                  // I/O status block.
                        NULL,                       // alloc size.
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_DELETE           // share...
                        | FILE_SHARE_READ
                        | FILE_SHARE_WRITE,         // ...access
                        FILE_OPEN_IF,               // create disposition
                        0,                          // ...options
                        NULL,                       // EA buffer
                        0L                          // Ea buffer len
                        );

        if (!NT_SUCCESS(ntStatus))
        {
            TraceTag(ttidError, "Failed to open file handle to Netbios device (%08lx)",
                     ntStatus);
            break;
        }

        //
        // 2. Send a stop IOCTL to it.
        //

        ntStatus = NtDeviceIoControlFile(
                        NbHandle,                   // Handle to device
                        NULL,                       // Event to be signalled
                        NULL,                       // No post routine
                        NULL,                       // no context for post
                        &StopStatus,                // return status block
                        IOCTL_NB_STOP,              // IOCTL
                        NULL,                       // No input parameters
                        0,
                        NULL,                       // No output paramters
                        0
                        );

        if (!NT_SUCCESS(ntStatus))
        {
            TraceTag(ttidSvcCtl, "Failed to send STOP IOCTL to netbios (%08lx).",
                     "probably means Netbios isn't running... anyway, we can't stop it",
                     ntStatus);
            break;
        }

    } while (FALSE);


    //
    // 4. Close the handle just opened to the driver
    //

    if (NULL != NbHandle)
    {
        NtClose( NbHandle );
    }

    TraceError("ScStopNetbios", HRESULT_FROM_WIN32(ntStatus));

    return ntStatus;
}

// ----------------------------------------------------------------------
//
// Function:  HrEnableAndStartSpooler
//
// Purpose:   Start spooler, enable if necessary
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-May-98
//
// Notes:
//
HRESULT HrEnableAndStartSpooler ()
{
    static const WCHAR c_szSpooler[] = L"Spooler";

    TraceTag(ttidNetcfgBase, "entering ---> HrEnableAndStartSpooler" );

    // Try to start the spooler.  Need to explicitly open the service
    // control manager with all access first, so that in case we need to
    // change the start type, we have the proper permission.
    //
    CServiceManager scm;
    HRESULT hr = scm.HrOpen (NO_LOCK, SC_MANAGER_ALL_ACCESS);
    if (S_OK == hr)
    {
        hr = scm.HrStartServiceAndWait (c_szSpooler);
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) == hr)
        {
            TraceTag(ttidNetcfgBase, "HrEnableAndStartSpooler: spooler is "
                "disabled trying to enable it..." );

            // Have to lock the service controller before changing the
            // configuration of a service.  Do so and unlock before trying to
            // start the service.
            //
            hr = scm.HrLock ();
            if (S_OK == hr)
            {
                CService svc;

                hr = scm.HrOpenService (&svc, c_szSpooler,
                            NO_LOCK,
                            SC_MANAGER_ALL_ACCESS,
                            STANDARD_RIGHTS_REQUIRED
                            | SERVICE_CHANGE_CONFIG);
                if (S_OK == hr)
                {
                    hr = svc.HrSetStartType (SERVICE_DEMAND_START);
                }

                scm.Unlock ();
            }

            if (S_OK == hr)
            {
                TraceTag(ttidNetcfgBase, "HrEnableAndStartSpooler: succeeded "
                    "in enabling spooer.  Now starting..." );

                hr = scm.HrStartServiceAndWait(c_szSpooler);
            }
        }
    }

    TraceError("HrEnableAndStartSpooler", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDirectoryTree
//
//  Purpose:    Creates (or ensures existence of) all directories on the path
//              specified in szPath.
//
//  Arguments:
//      pszPath [in]    Full path of one or more directories to create
//                      (i.e. c:\this\is\a\directory\path)
//      psa     [in]    Security attributes
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     shaunco (copied from RASUI by danielwe)   26 Jun 1998
//
//  Notes:
//
HRESULT HrCreateDirectoryTree(PWSTR pszPath, LPSECURITY_ATTRIBUTES psa)
{
    HRESULT hr = S_OK;

    if (pszPath)
    {
        DWORD   dwErr = ERROR_SUCCESS;

        // Loop through the path.
        //
        PWSTR pch;
        for (pch = pszPath; *pch; pch++)
        {
            // Stop at each backslash and make sure the path
            // is created to that point.  Do this by changing the
            // backslash to a null-terminator, calling CreateDirecotry,
            // and changing it back.
            //
            if (L'\\' == *pch)
            {
                BOOL fOk;

                *pch = 0;
                fOk = CreateDirectory(pszPath, psa);
                *pch = L'\\';

                // Any errors other than path alredy exists and we should
                // bail out.  We also get access denied when trying to
                // create a root drive (i.e. c:) so check for this too.
                //
                if (!fOk)
                {
                    dwErr = GetLastError();
                    if (ERROR_ALREADY_EXISTS == dwErr)
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else if ((ERROR_ACCESS_DENIED == dwErr) &&
                             (pch - 1 > pszPath) && (L':' == *(pch - 1)))
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }

        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    TraceError("HrCreateDirectoryTree", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteFileSpecification
//
//  Purpose:    Delete the files specified with pszFileSpec from the
//              directory given by pszDirectoryPath.
//
//  Arguments:
//      pszFileSpec      [in] File specificaion to delete.  e.g. *.mdb
//      pszDirectoryPath [in] Directory path to delete from
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jun 1998
//
//  Notes:
//
HRESULT
HrDeleteFileSpecification (
    PCWSTR pszFileSpec,
    PCWSTR pszDirectoryPath)
{
    Assert (pszFileSpec && *pszFileSpec);
    Assert (pszDirectoryPath && *pszDirectoryPath);

    HRESULT hr = S_OK;

    INT cchSpec = lstrlenW (pszFileSpec);
    INT cchDir  = lstrlenW (pszDirectoryPath);

    // Make sure the length of the directory and filespec combined is less
    // than MAX_PATH before continuing.  The '+1' is for the backslash
    // that we may add.
    //
    if (cchDir + 1 + cchSpec > MAX_PATH)
    {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_PATHNAME);
    }
    else
    {
        WCHAR szPath[MAX_PATH];

        // Form the path by copying the directory and making sure it
        // is terminated with a backslash if needed.
        //
        lstrcpyW (szPath, pszDirectoryPath);
        if (cchDir &&
            (L':' != pszDirectoryPath[cchDir - 1]) &&
            (L'\\' != pszDirectoryPath[cchDir - 1]))
        {
            lstrcatW (szPath, L"\\");
            cchDir++;
        }

        // Append the filespec to the directory and look for the first
        // file.
        lstrcatW (szPath, pszFileSpec);

        TraceTag (ttidNetcfgBase, "Looking to delete %S (cchDir=%u)",
            szPath, cchDir);

        WIN32_FIND_DATA FindData;
        HANDLE hFind = FindFirstFile (szPath, &FindData);
        if (INVALID_HANDLE_VALUE != hFind)
        {
            PCWSTR  pszFileName;
            INT     cchFileName;

            do
            {
                // Skip files with these attributes.
                //
                if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                                                 FILE_ATTRIBUTE_HIDDEN    |
                                                 FILE_ATTRIBUTE_READONLY  |
                                                 FILE_ATTRIBUTE_SYSTEM))
                {
                    continue;
                }

                // Use the shortname where possible to give us a chance
                // of using a path within MAX_PATH first.
                //
                pszFileName = FindData.cAlternateFileName;
                cchFileName = lstrlenW (pszFileName);
                if (!cchFileName)
                {
                    pszFileName = FindData.cFileName;
                    cchFileName = lstrlenW (pszFileName);
                }

                // If the length of the directory and filename don't exceed
                // MAX_PATH, form the full pathname and delete it.
                //
                if (cchDir + cchFileName < MAX_PATH)
                {
                    lstrcpyW (&szPath[cchDir], pszFileName);

                    TraceTag (ttidNetcfgBase, "Deleting %S", szPath);

                    if (!DeleteFile (szPath))
                    {
                        hr = HrFromLastWin32Error ();
                        TraceError ("DeleteFile failed.  Ignoring.", hr);
                    }
                }
            }
            while (FindNextFile (hFind, &FindData));

            // FindNextFile should set last error to ERROR_NO_MORE_FILES
            // on a succesful termination.
            //
            hr = HrFromLastWin32Error ();
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr)
            {
                hr = S_OK;
            }


            FindClose (hFind);
        }
        else
        {
            // If FindFirstFile didn't find anything, that's okay.
            //
            hr = HrFromLastWin32Error ();
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
        }
    }

    TraceError ("HrDeleteFileSpecification", hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrDeleteDirectory
//
// Purpose:   Recursively delete a directory and its all sub-dirs.
//
// Arguments:
//    pszDir           [in]  full path to a dir
//    fContinueOnError [in]  whether to continue deleting others when we
//                           error when deleting one
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp    19-December-97
//            danielwe  15-December-98 (moved to common and revised)
//
// Notes:
//
HRESULT HrDeleteDirectory(IN PCWSTR pszDir,
                          IN BOOL fContinueOnError)
{
    HRESULT             hr = S_OK;
    WCHAR               szPrefix[MAX_PATH];
    WCHAR               szFileSpec[MAX_PATH];
    WCHAR               szAllFiles[MAX_PATH];
    HANDLE              hFileContext;
    WIN32_FIND_DATA     fd;

    TraceTag(ttidNetcfgBase, "Deleting directory %S", pszDir);
    lstrcpyW(szPrefix, pszDir);
    lstrcatW(szPrefix, L"\\");

    lstrcpyW(szAllFiles, pszDir);
    lstrcatW(szAllFiles, L"\\");
    lstrcatW(szAllFiles, L"*");

    hFileContext = FindFirstFile(szAllFiles, &fd);

    if (hFileContext != INVALID_HANDLE_VALUE)
    {
        do
        {
            lstrcpyW(szFileSpec, szPrefix);
            lstrcatW(szFileSpec, fd.cFileName);

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!(!lstrcmpiW(fd.cFileName, L".") ||
                      !lstrcmpiW(fd.cFileName, L"..")))
                {
                    hr = HrDeleteDirectory(szFileSpec, fContinueOnError);
                    if (FAILED(hr) && fContinueOnError)
                    {
                        hr = S_OK;
                    }
                }
            }
            else
            {
                TraceTag(ttidNetcfgBase, "Deleting file %S", szFileSpec);

                if (DeleteFile(szFileSpec))
                {
                    hr = S_OK;
                }
                else
                {
                    TraceTag(ttidNetcfgBase, "Error deleting file %S",
                             szFileSpec);
                    TraceError("HrDeleteDirectory", hr);
                    hr = fContinueOnError ? S_OK : HrFromLastWin32Error();
                }
            }

            if ((S_OK == hr) && FindNextFile(hFileContext, &fd))
            {
                hr = S_OK;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        while (S_OK == hr);

        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
        {
            hr = S_OK;
        }

        FindClose(hFileContext);

        if (S_OK == hr)
        {
            if (RemoveDirectory(pszDir))
            {
                hr = S_OK;
            }
            else
            {
                TraceTag(ttidNetcfgBase, "Error deleting directory %S", pszDir);
                TraceLastWin32Error("HrDeleteDirectory");
                hr = fContinueOnError ? S_OK : HrFromLastWin32Error();
            }
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrDeleteDirectory", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LowerCaseComputerName
//
//  Purpose:    Utility function to lowercase a name obtained either from
//              the user via an UPPERCASE edit control, or via GetComputerName.
//
//  Arguments:
//      szName [in,out] Computername, which is modified in-place
//
//  Returns:    VOID
//
//  Author:     SumitC  29 Sep 1999
//
//  Notes:      The conversion only fails if CharLowerBuffW fails.  Per the user
//              guys, CharLowerBuff never actually returns any indication of
//              failure, so we can't tell anyway.  I've been assured that the
//              conversion is VERY unlikely to fail.
//
VOID
LowerCaseComputerName(
        IN OUT  PWSTR szName)
{
    // try the conversion
    Assert(szName);
    DWORD dwLen = wcslen(szName);
    DWORD dwConverted = CharLowerBuff(szName, dwLen);
    Assert(dwConverted == dwLen);
}

void __cdecl nc_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp )
{
    throw SE_Exception( uSECode );
}

void EnableCPPExceptionHandling()
{
    _set_se_translator(nc_trans_func);
}

void DisableCPPExceptionHandling()
{
    _set_se_translator(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncmsz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . C P P
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.cpp
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs except for the final terminating
//              NULL.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    ULONG cchTotal = 0;
    ULONG cch;
    while (*pmsz)
    {
        cch = wcslen (pmsz) + 1;
        cchTotal += cch;
        pmsz += cch;
    }

    // Return the count of characters.
    return cchTotal;
}


//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzAndTermSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    // Return the count of characters plus room for the
    // extra null terminator.
    return CchOfMultiSzSafe (pmsz) + 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsSzInMultiSzSafe
//
//  Purpose:    Determine if a given string is present in a Multi-Sz string
//              by doing a case insensitive compare.
//
//  Arguments:
//      psz     [in]  String to search for in pmsz
//      pmsz    [in]  The multi-sz to search
//
//  Returns:    TRUE if the specified string 'psz' was found in 'pmsz'.
//
//  Author:     scottbri   25 Feb 1997
//
//  Notes:      Note that the code can handle Null input values.
//
BOOL
FIsSzInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz)
{
    if (!pmsz || !psz)
    {
        return FALSE;
    }

    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, psz))
        {
            return TRUE;
        }
        pmsz += wcslen (pmsz) + 1;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetSzPositionInMultiSzSafe
//
//  Purpose:    Determine if a given string is present in a Multi-Sz string
//              by doing a case insensitive compare.
//
//  Arguments:
//      psz                [in]  String to search for in pmsz
//      pmsz               [in]  The multi-sz to search
//      pdwIndex           [out] The index of the first matching psz in pmsz
//      pfDuplicatePresent [out] Optional. TRUE if the string is present in
//                               the multi-sz more than once. FALSE otherwise.
//      pcStrings          [out] Optional. The number of strings in pmsz
//
//  Returns:    TRUE if the specified string 'psz' was found in 'pmsz'.
//
//  Author:     BillBe   9 Oct 1998
//
//  Notes:      Note that the code can handle Null input values.
//
BOOL
FGetSzPositionInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings)
{
    // initialize out params.
    //
    *pdwIndex = 0;

    if (pfDuplicatePresent)
    {
        *pfDuplicatePresent = FALSE;
    }

    if (pcStrings)
    {
        *pcStrings = 0;
    }

    if (!pmsz || !psz)
    {
        return FALSE;
    }

    // Need to keep track if duplicates are found
    BOOL fFoundAlready = FALSE;
    DWORD dwIndex = 0;

    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, psz))
        {
            if (!fFoundAlready)
            {
                *pdwIndex = dwIndex;
                fFoundAlready = TRUE;
            }
            else if (pfDuplicatePresent)
            {
                *pfDuplicatePresent = TRUE;
            }
        }
        pmsz += wcslen (pmsz) + 1;
        ++dwIndex;
    }

    if (pcStrings)
    {
        *pcStrings = dwIndex;
    }

    return fFoundAlready;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAddSzToMultiSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      pmszIn          [in]    (OPTIONAL) The original Multi-Sz to add to.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Ensure the string is the first element of
//                                  the list. If the string is present and
//                                  duplicates aren't allowed, move the
//                                  string to the end.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Ensure the string is the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.  If the
//                                  string is present and duplicates aren't
//                                  allowed, move the string to the end.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the multi-sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the multi-sz, the string will be
//                                  placed at the end.
//                              STRING_FLAG_DONT_MODIFY_IF_PRESENT
//                                  If the string already exists in the
//                                  multi-sz then no modication will take
//                                  place.  Note: This takes precedent
//                                  over the presence/non-presence of the
//                                  STRING_FLAG_ALLOW_DUPLICATES flag.
//                                  i.e nothing will be added or removed
//                                  if this flag is set and the string was
//                                  present in the multi-sz
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//      pmszOut         [out]   The new multi-sz.
//      pfChanged       [out]   TRUE if the multi-sz changed in any way,
//                              FALSE otherwise.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      6 Oct 1998
//              (Extracted from HrRegAddStringTo MultiSz and modified)
//
HRESULT
HrAddSzToMultiSz(
    IN PCWSTR pszAddString,
    IN PCWSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppmszOut,
    OUT BOOL* pfChanged)
{
    Assert(pszAddString && *pszAddString);
    Assert(ppmszOut);
    Assert(pfChanged);

    HRESULT hr = S_OK;

    BOOL fEnsureAtFront = dwFlags & STRING_FLAG_ENSURE_AT_FRONT;
    BOOL fEnsureAtEnd = dwFlags & STRING_FLAG_ENSURE_AT_END;
    BOOL fEnsureAtIndex = dwFlags & STRING_FLAG_ENSURE_AT_INDEX;

    // Can't specify more than one of these flags
    if ((fEnsureAtFront && fEnsureAtEnd) ||
        (fEnsureAtFront && fEnsureAtIndex) ||
        (fEnsureAtEnd && fEnsureAtIndex))
    {
        AssertSz(FALSE, "Invalid flags in HrAddSzToMultiSz");
        return E_INVALIDARG;
    }

    // Must specify at least one
    if (!fEnsureAtFront && !fEnsureAtEnd && !fEnsureAtIndex)
    {
        AssertSz(FALSE, "No operation flag specified in HrAddSzToMultiSz");
        return E_INVALIDARG;
    }

    // Initialize the output parameters.
    //
    *ppmszOut = NULL;
    *pfChanged = TRUE;
    DWORD dwIndex;
    BOOL fDupePresent;
    DWORD cItems;

    // If the string to add is not empty...
    //
    if (*pszAddString)
    {
        // Check if the string is already present in the MultiSz
        BOOL fPresent = FGetSzPositionInMultiSzSafe (pszAddString, pmszIn,
                &dwIndex, &fDupePresent, &cItems);

        if (fPresent)
        {
            // If the flag don't modify is present then we aren't changing
            // anything
            //
            if (dwFlags & STRING_FLAG_DONT_MODIFY_IF_PRESENT)
            {
                *pfChanged = FALSE;
            }

            // if there are no duplicates present and we are not allowing
            // duplicates, then we need to determine if the string is already in
            // the correct position
            //
            if (!fDupePresent && !(dwFlags & STRING_FLAG_ALLOW_DUPLICATES))
            {
                // If we are to insert the string at front but it is already
                // there, then we aren't changing anything
                //
                if (fEnsureAtFront && (0 == dwIndex))
                {
                    *pfChanged = FALSE;
                }

                // If we are to insert the string at the end but it is already
                // there, then we aren't changing anything
                //
                if (fEnsureAtEnd && (dwIndex == (cItems - 1)))
                {
                    *pfChanged = FALSE;
                }

                if (fEnsureAtIndex && (dwIndex == dwStringIndex))
                {
                    *pfChanged = FALSE;
                }
            }
        }
    }
    else
    {
        // If string to add was empty so we aren't changing anything
        *pfChanged = FALSE;
    }


    // If we are still going to change things...
    //
    if (*pfChanged)
    {

        DWORD cchDataSize = CchOfMultiSzSafe (pmszIn);

        // Enough space for the old data plus the new string and NULL, and for the
        // second trailing NULL (multi-szs are double-terminated)
        DWORD cchAllocSize = cchDataSize + wcslen (pszAddString) + 1 + 1;

        PWSTR pmszOrderNew = (PWSTR) MemAlloc(cchAllocSize * sizeof(WCHAR));

        if (pmszOrderNew)
        {
            // If we've gotten the "insert at front" flag, do the insert. Otherwise,
            // the default is "insert at end"
            //
            DWORD cchOffsetNew = 0;
            DWORD dwCurrentIndex = 0;
            if (fEnsureAtFront || (fEnsureAtIndex && (0 == dwStringIndex)))
            {
                // Insert our passed-in value at the beginning of the new buffer.
                //
                wcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                cchOffsetNew += wcslen ((PWSTR)pmszOrderNew) + 1;
                ++dwCurrentIndex;
            }

            // Loop through the old buffer, and copy all of the strings that are not
            // identical to our insertion string.
            //
            DWORD cchOffsetOld = 0;
            PWSTR pszCurrent;
            while ((cchOffsetOld + 1) < cchDataSize)
            {
                if (fEnsureAtIndex && (dwCurrentIndex == dwStringIndex))
                {
                    // Insert our passed-in value at the current index of the
                    // new buffer.
                    //
                    wcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                    cchOffsetNew += wcslen (pmszOrderNew + cchOffsetNew) + 1;
                    ++dwCurrentIndex;
                }
                else
                {
                    BOOL    fCopyThisElement    = FALSE;

                    // Get the next string in the list.
                    //
                    pszCurrent = (PWSTR) (pmszIn + cchOffsetOld);

                    // If we allow duplicates, then copy this element, else
                    // check for a match, and if there's no match, then
                    // copy this element.
                    if (dwFlags & STRING_FLAG_ALLOW_DUPLICATES)
                    {
                        fCopyThisElement = TRUE;
                    }
                    else
                    {
                        if (_wcsicmp (pszCurrent, pszAddString) != 0)
                        {
                            fCopyThisElement = TRUE;
                        }
                    }

                    // If we're allowing the copy, then copy!
                    if (fCopyThisElement)
                    {
                        wcscpy (pmszOrderNew + cchOffsetNew, pszCurrent);
                        cchOffsetNew +=
                                wcslen (pmszOrderNew + cchOffsetNew) + 1;
                        ++dwCurrentIndex;
                    }

                    // Update the offset
                    //
                    cchOffsetOld += wcslen (pmszIn + cchOffsetOld) + 1;
                }
            }


            // If we have the ENSURE_AT_END flag set or if the ENSURE_AT_INDEX
            // flag was set and the index was greater than the possible
            // index, this means we want to insert at the end
            //
            if (fEnsureAtEnd ||
                    (fEnsureAtIndex && (dwCurrentIndex <= dwStringIndex)))
            {
                wcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                cchOffsetNew += wcslen (pmszOrderNew + cchOffsetNew) + 1;
            }

            // Put the last of the double-NULL chars on the end.
            //
            pszCurrent = pmszOrderNew + cchOffsetNew;
            pszCurrent[0] = (WCHAR) 0;

            *ppmszOut = pmszOrderNew;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("HrAddSzToMultiSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateArrayOfStringPointersIntoMultiSz
//
//  Purpose:    Allocates and initializes an array of string pointers.
//              The array of pointers is initialized to point to the
//              individual strings in a multi-sz.
//
//  Arguments:
//      pmszSrc   [in]  The multi-sz to index.
//      pcStrings [out] Returned count of string pointers in the array.
//      papsz     [out] Returned array of string pointers.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   20 Jun 1998
//
//  Notes:      It is the callers responsibility to ensure there is at
//              least one string. The restriction is explicitly chosen to
//              reduce confusion about what would be returned if the
//              multi-sz were empty.
//
//              Free the returned array with free.
//
HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCWSTR pmszSrc,
    OUT UINT* pcStrings,
    OUT PCWSTR** papsz)
{
    Assert (pmszSrc && *pmszSrc);
    Assert (papsz);

    // First, count the number of strings in the multi-sz.
    //
    UINT    cStrings = 0;
    PCWSTR pmsz;
    for (pmsz = pmszSrc; *pmsz; pmsz += wcslen(pmsz) + 1)
    {
        cStrings++;
    }

    Assert (cStrings);  // See Notes above.
    *pcStrings = cStrings;

    // Allocate enough memory for the array.
    //
    HRESULT hr = HrMalloc (cStrings * sizeof(PWSTR*),
            reinterpret_cast<VOID**>(papsz));

    if (S_OK == hr)
    {
        // Initialize the returned array. ppsz is a pointer to each
        // element of the array.  It is incremented after each element
        // is initialized.
        //
        PCWSTR* ppsz = *papsz;

        for (pmsz = pmszSrc; *pmsz; pmsz += wcslen(pmsz) + 1)
        {
            *ppsz = pmsz;
            ppsz++;
        }
    }

    TraceError ("HrCreateArrayOfStringPointersIntoMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveSzFromMultiSz
//
//  Purpose:    Remove all occurrences of a string from a multi-sz.  The
//              removals are performed in place.
//
//  Arguments:
//      psz       [in]     The string to remove.
//      pmsz      [in out] The multi-sz to remove psz from.
//      dwFlags   [in]     Can contain one or more of the following
//                         values:
//
//                         STRING_FLAG_REMOVE_SINGLE
//                             Don't remove more than one value, if
//                             multiple are present.
//                         [default] STRING_FLAG_REMOVE_ALL
//                             If multiple matching values are present,
//                             remove them all.
//      pfRemoved [out]    Set to TRUE on return if one or more strings
//                         were removed.
//
//  Returns:    nothing
//
//  Author:     shaunco   8 Jun 1998
//
//  Notes:
//
VOID
RemoveSzFromMultiSz (
    IN PCWSTR psz,
    IN OUT PWSTR pmsz,
    IN DWORD dwFlags,
    OUT BOOL* pfRemoved)
{
    Assert (pfRemoved);

    // Initialize the output parameters.
    //
    *pfRemoved = FALSE;

    if (!pmsz || !psz || !*psz)
    {
        return;
    }

    // Look for all occurrences of psz in pmsz.  When one is found, move
    // the remaining part of the multi-sz over it.
    //
    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, psz))
        {
            PWSTR  pmszRemain = pmsz + (wcslen (pmsz) + 1);
            INT    cchRemain = CchOfMultiSzAndTermSafe (pmszRemain);

            MoveMemory (pmsz, pmszRemain, cchRemain * sizeof(WCHAR));

            *pfRemoved = TRUE;

            if (dwFlags & STRING_FLAG_REMOVE_SINGLE)
            {
                break;
            }
        }
        else
        {
            pmsz += wcslen (pmsz) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SzListToMultiSz
//
//  Purpose:    Converts a comma-separated list into a multi-sz style list.
//
//  Arguments:
//      psz     [in]    String to be converted. It is not modified.
//      pcb     [out]   Number of *bytes* in the resulting string. If NULL,
//                      size is not returned.
//      ppszOut [out]   Resulting string.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Apr 1997
//
//  Notes:      Resulting string must be freed with MemFree.
//
VOID
SzListToMultiSz (
    IN PCWSTR psz,
    OUT DWORD* pcb,
    OUT PWSTR* ppszOut)
{
    Assert(psz);
    Assert(ppszOut);

    PCWSTR      pch;
    INT         cch;
    PWSTR       pszOut;
    const WCHAR c_chSep = L',';

    // Add 2 to the length. One for final NULL, and one for second NULL.
    cch = wcslen (psz) + 2;

    pszOut = (PWSTR)MemAlloc(CchToCb(cch));
    if (pszOut)
    {
        ZeroMemory(pszOut, CchToCb(cch));

        if (pcb)
        {
            *pcb = CchToCb(cch);
        }

        *ppszOut = pszOut;

        // count the number of separator chars and put NULLs there
        //
        for (pch = psz; *pch; pch++)
        {
            if (*pch == c_chSep)
            {
                *pszOut++ = 0;
            }
            else
            {
                *pszOut++ = *pch;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncmem.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . C P P
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//              deonb      2 Jan 2002
//
//
// Our memory allocations rules are:
//   * Most of our memory allocators do NOT throw exceptions but instead return NULL. 
//     This includes MemAlloc, operator new, operator new[], calloc & malloc.
//   * Anything explicitly allocated using: p = new(throwonfail) CClass(), will raise a bad_alloc on failure.
//   * STL:
//     #ifdef (USE_CUSTOM_STL_ALLOCATOR)
//         The STL memory allocator will raise a bad_alloc C++ exception on low memory.
//         (Note, not an SEH exception!). 
//     #else
//         STL will raise an access violation exception after out-of-memory occurred and
//         it tries to use the memory.
//     #endif
//   * Currently USE_CUSTOM_STL_ALLOCATOR is defined in our makefile.inc
// 
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncmem.h"

// Debug limit for single memory allocation (16 MB)
#define MAX_DEBUG_ALLOC 16 * 1048576

// This global heap handle will be set to the process heap when the
// first request to allocate memory through MemAlloc is made.
//
HANDLE g_hHeap = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   MemAlloc
//
//  Purpose:    NetConfig's memory allocator
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//
//  Returns:    Pointer to allocated memory, or NULL if failed.
//
//  Author:     deonb    2 Jan 2002
//
//  Notes:      Free the returned buffer with MemFree.
//              Will ASSERT in debug if attempt to allocate more than MAX_DEBUG_ALLOC (Currently 16 MB)
//
//              We COULD extend this to include a primitive buffer overrun check, but it would require us
//              to put the size of the allocated block in the beginning of the buffer, and would make things like
//              allocating with MemAlloc but freeing it with HeapFree fail. 
//              PageHeap / AVRF is better suited for this purpose since it works directly with the RTL allocator.
//
VOID*
MemAlloc (
    size_t cb) throw()
{
    AssertSz(cb < MAX_DEBUG_ALLOC, "Suspicious request for a lot of memory"); 

    if (!g_hHeap)
    {
        // Don't trace in this part of the function. It will likely recurse.
        g_hHeap = GetProcessHeap();
        if (!g_hHeap)
        {
            AssertSz(FALSE, "MemAlloc could not get the process heap.");
            return NULL;
        }
    }

    LPVOID lpAlloc = HeapAlloc (g_hHeap, 0, cb);
    if (!lpAlloc)
    {
        TraceTag(ttidError, "MemAlloc failed request for %d bytes from:", cb);
        TraceStack(ttidError);
    }
    return lpAlloc;
}

//+---------------------------------------------------------------------------
//
//  Function:   MemFree
//
//  Purpose:    NetConfig's memory de-allocator
//
//  Arguments:
//      pv [in] Pointer to previously allocated memory
//
//  Returns:    none
//
//  Author:     deonb    2 Jan 2002
//
//  Notes:      Free the returned buffer from MemAlloc.
//              Don't trace in this function. It will recurse.
VOID
MemFree (
    VOID*   pv) throw()
{
    if (pv) 
    {
        if (!g_hHeap)
        {
            AssertSz(FALSE, "Suspicious call to MemFree before MemAlloc");

            g_hHeap = GetProcessHeap();
            if (!g_hHeap)
            {
                return;
            }
        }

        HeapFree (g_hHeap, 0, pv);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   HrMalloc
//
//  Purpose:    HRESULT returning version of malloc.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Address of returned allocation.
//
//  Returns:    S_OK or E_OUTOFMEMORY;
//
//  Author:     shaunco   31 Mar 1998
//
//  Notes:      Free the returned buffer with free.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv) throw()
{
    Assert (ppv);

    HRESULT hr = S_OK;
    *ppv = MemAlloc (cb);
    if (!*ppv)
    {
        hr = E_OUTOFMEMORY;
    
        TraceHr (ttidError, FAL, hr, FALSE, "HrMalloc failed request for %d bytes from:", cb);
        TraceStack(ttidError);
    }

    return hr;
}

namespace std
{
    // report a length_error
    void __cdecl _Xlen()
    {
        _THROW(length_error, "string too long"); 
    }

	// report an out_of_range error
    void __cdecl _Xran()
    {
        _THROW(out_of_range, "invalid string position"); 
    }
}

//+---------------------------------------------------------------------------
// CRT memory function overloads
//
const throwonfail_t throwonfail;

VOID*
__cdecl
operator new (
    size_t cb,
    const throwonfail_t&
    ) throw (std::bad_alloc)
{
    LPVOID pv = MemAlloc (cb);
    if (!pv)
    {
        throw std::bad_alloc();
    }
    return pv;
}
VOID
__cdecl
operator delete (
    void* pv,
    const throwonfail_t&) throw ()
{
    MemFree (pv);
}

const extrabytes_t extrabytes;
VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra) throw()
{
    return MemAlloc (cb + cbExtra);
}

VOID
__cdecl
operator delete(
    void* pv,
    const extrabytes_t&,
    size_t cbExtra) throw()
{
    MemFree (pv);
}

VOID*
__cdecl
operator new (
    size_t cb) throw()
{
    return MemAlloc (cb);
}

VOID*
__cdecl
operator new (
    size_t cb, 
    std::nothrow_t const &) throw()
{
    return MemAlloc (cb);
}

VOID*
__cdecl
operator new[] (
    size_t cb) throw()
{
    return MemAlloc (cb);
}

VOID
__cdecl
operator delete (
    VOID* pv) throw()
{
    MemFree (pv);
}

VOID
__cdecl
operator delete[] (
    VOID* pv) throw()
{
    MemFree (pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncreg2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G 2 . C P P
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     CWill   27 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncerror.h"
#include "ncipaddr.h"
#include "ncmem.h"
#include "ncreg.h"
#include "ncstring.h"
#include <regstr.h>

static const WCHAR  c_szSubkeyServices[] = REGSTR_PATH_SERVICES;

const struct REG_TYPE_MAP
{
    DWORD   dwPsuedoType;
    DWORD   dwType;
};

REG_TYPE_MAP    c_rgrtmTypes[] =
{
    {REG_BOOL,  REG_DWORD},
    {REG_IP,    REG_SZ},
};



DWORD DwRealTypeFromPsuedoType(const DWORD dwPsuedoType)
{
    for (UINT cLoop = 0; cLoop < celems(c_rgrtmTypes); cLoop++)
    {
        if (dwPsuedoType == c_rgrtmTypes[cLoop].dwPsuedoType)
        {
            return c_rgrtmTypes[cLoop].dwType;
        }
    }

    return dwPsuedoType;
}

struct SPECIAL_KEY_MAP
{
    HKEY        hkeyPseudo;
    HKEY        hkeyRoot;
    PCWSTR      pszSubKey;
};

static const SPECIAL_KEY_MAP c_rgskmSpec[] =
{
    HKLM_SVCS,      HKEY_LOCAL_MACHINE,     c_szSubkeyServices,
};



//+---------------------------------------------------------------------------
//
//  Member:     HkeyTrueParent
//
//  Purpose:    To get a real handle to a key from a pseudo handle
//
//  Arguments:
//      hkeyIn          The pseudo key name
//      samDesired      The access requested of the key
//      rghkeySpec      An array of the special keys.
//
//  Returns:    The handle to the opened key or NULL
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
HKEY HkeyTrueParent(const HKEY hkeyIn, const REGSAM samDesired,
        HKEY rghkeySpec[])
{
    HKEY    hkeyRet     = hkeyIn;

    for (UINT cKey = 0; cKey < celems(c_rgskmSpec); cKey++)
    {
        // Check arb->hkey for one of "our" well known keys.
        if (c_rgskmSpec[cKey].hkeyPseudo == hkeyIn)
        {
            if (!rghkeySpec[cKey])
            {
                // First time a special key was used.  We need to cache it.
#ifdef DBG
                HRESULT hr =
#endif // DBG
                HrRegOpenKeyEx(
                        c_rgskmSpec[cKey].hkeyRoot,
                        c_rgskmSpec[cKey].pszSubKey,
                        samDesired,
                        &rghkeySpec[cKey]);

                // If we fail to open the key, make sure the output
                // parameter was nulled.  This will allow us to proceed
                // without really handling the error as hkeyParent
                // will be set to null below and the following
                // HrRegOpenKey will fail.  We will then handle the failure
                // of that.
                AssertSz(FImplies(FAILED(hr), !rghkeySpec[cKey]), "Key not NULL");
            }

            hkeyRet = rghkeySpec[cKey];
            break;
        }
    }

    return hkeyRet;
}



VOID RegSafeCloseKeyArray(HKEY rghkey[], UINT cElems)
{
    for (UINT cKey = 0; cKey < cElems; cKey++)
    {
        RegSafeCloseKey(rghkey[cKey]);
    }

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     TranslateFromRegToData
//
//  Purpose:    Translates the data retrieved from the registry to a the user
//              data's storage format
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          Where the data gets stored
//      pbBuf           A buffer that stores the registry data
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID TranslateFromRegToData(DWORD dwType, BYTE* pbData, BYTE* pbBuf)
{
     // Take the data from the registry and happily convert it into
     // usable data
    switch (dwType)
    {

#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the stringized form of the ip address
        // into a DWORD.  (The actual 32-bit IP address.)
        DWORD dwIpAddr = IpPszToHostAddr((WCHAR*)pbBuf);
        *((DWORD*)pbData) = dwIpAddr;
        break;
    }

    case REG_BOOL:
    {
        // Form the boolean as 'TRUE' or 'FALSE' based on
        // whether the data is non-zero or zero respectively.
        DWORD   dwData = *((DWORD*)pbBuf);
        *((BOOL*)pbData) = (!!dwData);
        break;
    }

    case REG_DWORD:
    {
        // DWORDs are direct assignments
        *((DWORD*)pbData) = *((DWORD*)pbBuf);
        break;
    }

    case REG_SZ:
    {
        // Make a copy of the string
        *((PWSTR*) pbData) = SzDupSz((PWSTR)pbBuf);
        break;
    }
    }

    return;
}



inline VOID UseDefaultRegValue(DWORD dwType, BYTE* pbData, BYTE* pbDefault)
{
    AssertSz((pbData && pbDefault), "UseDefaultRegValue : Invalid params");
    AssertSz(pbDefault, "There is no default registry value");

    TranslateFromRegToData(dwType, pbData, pbDefault);

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     CbSizeOfDataToReg
//
//  Purpose:    To determine the size of buffer needed to store the data
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          The data that has to be translated
//
//  Returns:    The size of buffer need to store the data
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
DWORD CbSizeOfDataToReg(DWORD dwType, const BYTE* pbData)
{
    DWORD cbData = 0;

    switch (dwType)
    {
#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the 32-bit IP address to a stringized form.
        DWORD dwIpAddr = *((DWORD*)pbData);

        WCHAR pszIpAddr [32];
        IpHostAddrToPsz(dwIpAddr, pszIpAddr);

        cbData = CbOfSzAndTerm(pszIpAddr);
        break;
    }

    // Boolean values are stored as DWORDs
    case REG_BOOL:
    case REG_DWORD:
    {
        cbData = sizeof(DWORD);
        break;
    }

    case REG_SZ:
    case REG_EXPAND_SZ:
    {
        cbData = CbOfSzAndTerm(*((PCWSTR*)pbData));
        break;
    }
    }

    AssertSz(cbData, "We should have a size");

    return cbData;
}



//+---------------------------------------------------------------------------
//
//  Member:     TranslateFromDataToReg
//
//  Purpose:    Translates user data to a format the can be stored in the
//              registry
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          The data that has to be translated
//      pbBuf           A buffer that stores the registry data
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID
TranslateFromDataToReg(
    IN DWORD dwType,
    IN const BYTE* pbData,
    OUT const BYTE* pbBuf)
{
    switch (dwType)
    {
#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the 32-bit IP address to a stringized form.
        DWORD dwIpAddr = *((DWORD*)pbData);

        WCHAR pszIpAddr [32];
        IpHostAddrToPsz (dwIpAddr, pszIpAddr);

        // Copy the string
        lstrcpyW((PWSTR)pbBuf, pszIpAddr);
        break;
    }

    case REG_BOOL:
    {
        // Form the boolean as 'TRUE' or 'FALSE' based on
        // whether the data is non-zero or zero respectively.
        DWORD   dwData = *((DWORD*)pbData);
        *((BOOL*)pbBuf) = (!!dwData);
        break;
    }

    case REG_DWORD:
    {
        // DWORDs are direct assignments
        *((DWORD*)pbBuf) = *((DWORD*)pbData);
        break;
    }

    case REG_SZ:
    case REG_EXPAND_SZ:
    {
        // Make a copy of the string
        lstrcpyW((PWSTR)pbBuf, *((PCWSTR*)pbData));

        AssertSz(CbOfSzAndTerm(*((PCWSTR*)pbData)), "Zero length string");
        break;
    }
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     RegReadValues
//
//  Purpose:    To read a table of information from the registry into a user
//              defined data structure.
//
//  Arguments:
//      crb             The count of entries in the REGBATCH structure
//      arb             The pointer to the REGBATCH structure
//      pbUserData      The pointer to the source structure that is to retrieve
//                      the data from the registry
//      samDesired      The requested key access mask
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID RegReadValues(
    IN INT crb,
    IN const REGBATCH* arb,
    OUT const BYTE* pbUserData,
    IN REGSAM samDesired)
{
    AssertSz(FImplies(crb, arb), "Count without an array");

    HRESULT                 hr                                  = S_OK;
    const REGBATCH*         prbLast                             = NULL;
    HKEY                    rghkeySpec[celems(c_rgskmSpec)]     = {0};
    HKEY                    hkey                                = NULL;

    while (crb--)
    {
        BYTE*   pbData = (BYTE*)(pbUserData + arb->cbOffset);

        // Open the key if we need to.
        // We don't need to if it was the same as the previous one used.
        if ((!prbLast )
            || (prbLast->hkey != arb->hkey)
            || (prbLast->pszSubkey != arb->pszSubkey))
        {
            HKEY    hkeyParent;

            hkeyParent = HkeyTrueParent (arb->hkey, samDesired, rghkeySpec);

            // Close the previous key we used.
            RegSafeCloseKey (hkey);

            // Open the new key.
#ifdef DBG
            hr =
#endif // DBG
            HrRegOpenKeyEx (hkeyParent, arb->pszSubkey, samDesired, &hkey);
            AssertSz(FImplies(FAILED(hr), !hkey), "HrRegOpenKey not NULLing");
        }

        // Only continue if we have a key.
        if (hkey)
        {
            DWORD   dwType = arb->dwType;

            // We can't read NULL registry values
            if (REG_CREATE != dwType)
            {
                DWORD   cbData      = 0;
                BYTE*   pbStack     = NULL;
                DWORD   dwRealType  = DwRealTypeFromPsuedoType(dwType);

                // Ensure that we fail the first time around so that we can see how
                // big a buffer is needed
                (VOID) HrRegQueryValueEx(hkey, arb->pszValueName, &dwRealType,
                        NULL, &cbData);

                // Allocate memory on the stack to serve as our temporary buffer.
#ifndef STACK_ALLOC_DOESNT_WORK
                pbStack = (BYTE*)MemAlloc (cbData);
#else // !STACK_ALLOC_DOESNT_WORK
                pbStack = (BYTE*)PvAllocOnStack(cbData);
#endif // !STACK_ALLOC_DOESNT_WORK

                if(pbStack) 
                {
                    hr = HrRegQueryValueEx(hkey, arb->pszValueName, &dwRealType,
                                            pbStack, &cbData);
                }
                else 
                {
                    hr = E_OUTOFMEMORY;
                }

                if (S_OK == hr)
                {
                    // Make sure its the type we were expecting.
                    AssertSz((dwRealType == DwRealTypeFromPsuedoType(dwType)),
                            "Value types do no match");

                    TranslateFromRegToData(dwType, pbData, pbStack);
                }
                else
                {
                    UseDefaultRegValue(dwType, pbData, arb->pbDefault);

                    TraceHr (ttidError, FAL, hr,
                        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
                        "RegReadValues: Could not open value %S", arb->pszValueName);
                }
#ifndef STACK_ALLOC_DOESNT_WORK
                MemFree (pbStack);
#endif // STACK_ALLOC_DOESNT_WORK
            }
        }
        else
        {
            TraceTag(ttidError, "RegReadValues: NULL key for %S", arb->pszSubkey);
            UseDefaultRegValue(arb->dwType, pbData, arb->pbDefault);
        }

        // Advance prbLast or set it to the first one if this is the
        // first time through.
        if (prbLast)
        {
            prbLast++;
        }
        else
        {
            prbLast = arb;
        }

        arb++;
    }

    // Clean up
    RegSafeCloseKey(hkey);
    RegSafeCloseKeyArray(rghkeySpec, celems(rghkeySpec));

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrRegWriteValues
//
//  Purpose:    To write a table of information to the registry from a user
//              defined data structure.
//
//  Arguments:
//      crb             The count of entries in the REGBATCH structure
//      arb             The pointer to the REGBATCH structure
//      pbUserData      The pointer to the source structure that provides
//                      the data that is to be written to the registry
//      dwOptions       Options to be used when creating the registry keys
//      samDesired      The requested key access mask
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
HRESULT HrRegWriteValues(
        INT crb,
        const REGBATCH* arb,
        const BYTE* pbUserData,
        DWORD dwOptions,
        REGSAM samDesired)
{
    AssertSz(FImplies(crb, arb), "HrWriteValues : Count with no array");

    HRESULT                 hr                                  = S_OK;
    const REGBATCH*         prbLast                             = NULL;
    HKEY                    hkey                                = NULL;
    HKEY                    rghkeySpec[celems(c_rgskmSpec)]     = {0};

    while (crb--)
    {
        BYTE*   pbData = const_cast<BYTE*>(pbUserData + arb->cbOffset);

        // Open the key if we need to.
        // We don't need to if it was the same as the previous one used.
        if ((!prbLast)
            || (prbLast->hkey != arb->hkey)
            || (prbLast->pszSubkey != arb->pszSubkey))
        {
            HKEY    hkeyParent;

            hkeyParent = HkeyTrueParent(arb->hkey, samDesired, rghkeySpec);

            // Close the previous key we used.
            RegSafeCloseKey(hkey);

            // Open the new key.
            DWORD dwDisposition;
            hr = HrRegCreateKeyEx(hkeyParent, arb->pszSubkey, dwOptions,
                    samDesired, NULL, &hkey, &dwDisposition);

            AssertSz(FImplies(FAILED(hr), !hkey), "HrRegCreateKey not NULLing");

            if (FAILED(hr))
            {
                TraceError("HrRegWriteValues: failed to open parent key", hr);
                break;
            }
        }

        // Should definately have hkey by now.
        AssertSz(hkey, "Why no key?");

        //
        // Format the data to be put into the registry
        //

        DWORD   dwType  = arb->dwType;

        // If all we want to do is create the key, then we are already done.
        if (REG_CREATE != dwType)
        {
            DWORD           dwRealType  = DwRealTypeFromPsuedoType(dwType);
            DWORD           cbReg       = CbSizeOfDataToReg(dwType, pbData);
            BYTE*           pbReg       = NULL;

            AssertSz(cbReg, "We must have some data");

#ifndef STACK_ALLOC_DOESNT_WORK
            pbReg = new BYTE[cbReg];
#else // !STACK_ALLOC_DOESNT_WORK
            pbReg = reinterpret_cast<BYTE*>(PvAllocOnStack(cbReg));
#endif // !STACK_ALLOC_DOESNT_WORK

            if(!pbReg) 
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            TranslateFromDataToReg(dwType, pbData, pbReg);

            // Write the data to the registry.
            hr = HrRegSetValueEx(
                    hkey,
                    arb->pszValueName,
                    dwRealType,
                    pbReg,
                    cbReg);

#ifndef STACK_ALLOC_DOESNT_WORK
            // Must have this call before the break
            delete [] pbReg;
#endif // STACK_ALLOC_DOESNT_WORK

        }

        if (FAILED(hr))
        {
            break;
        }

        // Advance prbLast or set it to the first one if this is the
        // first time through.
        if (prbLast)
        {
            prbLast++;
        }
        else
        {
            prbLast = arb;
        }

        arb++;
    }

    RegSafeCloseKey(hkey);
    RegSafeCloseKeyArray(rghkeySpec, celems(rghkeySpec));

    TraceError("HrWriteValues", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrRegWriteValueTable
//
//  Purpose:    To write a table of values to the registry from a user
//              defined data structure.
//
//  Arguments:
//      hkeyRoot        The key to which the values are written
//      cvt             The count of entries in the VALUETABLE structure
//      avt             The pointer to the VALUETABLE structure
//      pbUserData      The pointer to the source structure that provides
//                      the data that is to be written to the registry
//      dwOptions       Options to be used when creating the registry keys
//      samDesired      The requested key access mask
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill   06/26/97
//
//  Notes:
//
HRESULT HrRegWriteValueTable(
        HKEY hkeyRoot,
        INT cvt,
        const VALUETABLE* avt,
        const BYTE* pbUserData,
        DWORD dwOptions,
        REGSAM samDesired)
{
    HRESULT             hr          = S_OK;

    while (cvt--)
    {
        BYTE*   pbData  = NULL;
        DWORD   dwType  = REG_NONE;

        //
        // Format the data to be put into the registry
        //

        dwType = avt->dwType;
        pbData = const_cast<BYTE*>(pbUserData + avt->cbOffset);

        // If all we want to do is create the key, then we are already done.
        if (REG_CREATE != dwType)
        {
            DWORD           dwRealType  = DwRealTypeFromPsuedoType(dwType);
            DWORD           cbReg       = CbSizeOfDataToReg(dwType, pbData);
            BYTE*           pbReg       = NULL;

            AssertSz(cbReg, "We must have some data");

#ifndef STACK_ALLOC_DOESNT_WORK
            pbReg = new BYTE[cbReg];
#else // !STACK_ALLOC_DOESNT_WORK
            pbReg = reinterpret_cast<BYTE*>(PvAllocOnStack(cbReg));
#endif // !STACK_ALLOC_DOESNT_WORK

            if(!pbReg) 
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            TranslateFromDataToReg(dwType, pbData, pbReg);

            // Write the data to the registry.
            hr = HrRegSetValueEx(
                    hkeyRoot,
                    avt->pszValueName,
                    dwRealType,
                    pbReg,
                    cbReg);

#ifndef STACK_ALLOC_DOESNT_WORK
            // Must have this call before the break
            delete [] pbReg;
#endif // STACK_ALLOC_DOESNT_WORK
        }

        if (FAILED(hr))
        {
            break;
        }

        avt++;
    }

    TraceError("HrRegWriteValueTable", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncperms.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       N C P E R M S . C P P
//
//  Contents:   Common routines for dealing with permissions.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <ntseapi.h>
#include "ncbase.h"
#include "ncdebug.h"
#include "ncperms.h"
#include "netconp.h"
#include "ncreg.h"
#include "lm.h"

CGroupPolicyBase* g_pNetmanGPNLA = NULL;

#define INITGUID
#include <nmclsid.h>



//+---------------------------------------------------------------------------
//
//  Function:   FCheckGroupMembership
//
//  Purpose:    Returns TRUE if the logged on user is a member of the
//              specified group.
//
//  Arguments:
//      dwRID   [in] Group RID to check against.
//
//  Returns:    TRUE if the logged on user is a member of the specified group
//
//  Author:     scottbri   14 Sept 1998
//
//  Notes:
//
BOOL FCheckGroupMembership(IN  DWORD dwRID)
{
    SID_IDENTIFIER_AUTHORITY    SidAuth = SECURITY_NT_AUTHORITY;
    PSID                        psid;
    BOOL                        fIsMember = FALSE;

    // Allocate a SID for the Administrators group and check to see
    // if the user is a member.
    //
    if (AllocateAndInitializeSid (&SidAuth, 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 dwRID,
                 0, 0, 0, 0, 0, 0,
                 &psid))
    {
        if (!CheckTokenMembership (NULL, psid, &fIsMember))
        {
            fIsMember = FALSE;
            TraceLastWin32Error ("FCheckGroupMembership - CheckTokenMemberShip failed.");
        }

        FreeSid (psid);
    }
    else
    {
        TraceLastWin32Error ("FCheckGroupMembership - AllocateAndInitializeSid failed.");
    }

    return fIsMember;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsUserAdmin
//
//  Purpose:    Returns TRUE if the logged on user is a member of the
//              Administrators local group.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if the logged on user is a member of the
//              Administrators local group.  False otherwise.
//
//  Author:     shaunco   19 Mar 1998
//
//  Notes:
//
BOOL
FIsUserAdmin()
{
    BOOL fIsMember;

    // Check the administrators group
    //
    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_ADMINS);

    return fIsMember;
}

//#define ALIGN_DWORD(_size) (((_size) + 3) & ~3)
//#define ALIGN_QWORD(_size) (((_size) + 7) & ~7)
#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))




//+---------------------------------------------------------------------------
//
//  Function:   HrAllocateSecurityDescriptorAllowAccessToWorld
//
//  Purpose:    Allocate a security descriptor and initialize it to
//              allow access to everyone.
//
//  Arguments:
//      ppSd [out] Returned security descriptor.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   10 Nov 1998
//
//  Notes:      Free *ppSd with MemFree.
//
HRESULT
HrAllocateSecurityDescriptorAllowAccessToWorld (
    OUT PSECURITY_DESCRIPTOR*   ppSd)
{
    PSECURITY_DESCRIPTOR    pSd = NULL;
    PSID                    pSid = NULL;
    PACL                    pDacl = NULL;
    DWORD                   dwErr = NOERROR;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignDaclSize;
    DWORD                   dwSidSize;
    PVOID                   pvBuffer = NULL;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<- b ->|<- c ->|
    //   +-------+--------+------+
    //   |      p|      p|       |
    //   | SD   a| DACL a| SID   |
    //   |      d|      d|       |
    //   +-------+-------+-------+
    //   ^       ^       ^
    //   |       |       |
    //   |       |       +--pSid
    //   |       |
    //   |       +--pDacl
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pDacl and pSid are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignDaclSize
    //   c = dwSidSize
    //

    // Initialize output parameter.
    //
    *ppSd = NULL;

    // Compute the size of the SID.  The SID is the well-known SID for World
    // (S-1-1-0).
    //
    dwSidSize = GetSidLengthRequired(1);

    // Compute the size of the DACL.  It has an inherent copy of SID within
    // it so add enough room for it.  It also must sized properly so that
    // a pointer to a SID structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignDaclSize = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACL) + dwSidSize,
                        PSID);

    // Compute the size of the SD.  It must be sized propertly so that a
    // pointer to a DACL structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(SECURITY_DESCRIPTOR),
                        PACL);

    // Allocate the buffer big enough for all.
    //
    dwErr = ERROR_OUTOFMEMORY;
    pvBuffer = MemAlloc(dwSidSize + dwAlignDaclSize + dwAlignSdSize);
    if (pvBuffer)
    {
        SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                                    = SECURITY_WORLD_SID_AUTHORITY;
        PULONG  pSubAuthority;

        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd   = pvBuffer;
        pDacl = (PACL)((PBYTE)pvBuffer + dwAlignSdSize);
        pSid  = (PSID)((PBYTE)pDacl + dwAlignDaclSize);

        // Initialize pSid as S-1-1-0.
        //
        if (!InitializeSid(
                pSid,
                &SidIdentifierWorldAuth,
                1))  // 1 sub-authority
        {
            dwErr = GetLastError();
            goto finish;
        }

        pSubAuthority = GetSidSubAuthority(pSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;

        // Initialize pDacl.
        //
        if (!InitializeAcl(
                pDacl,
                dwAlignDaclSize,
                ACL_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Add an access-allowed ACE for S-1-1-0 to pDacl.
        //
        if (!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION,
                STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                pSid))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Initialize pSd.
        //
        if (!InitializeSecurityDescriptor(
                pSd,
                SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set pSd to use pDacl.
        //
        if (!SetSecurityDescriptorDacl(
                pSd,
                TRUE,
                pDacl,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the owner for pSd.
        //
        if (!SetSecurityDescriptorOwner(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the group for pSd.
        //
        if (!SetSecurityDescriptorGroup(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

finish:
        if (!dwErr)
        {
            *ppSd = pSd;
        }
        else
        {
            MemFree(pvBuffer);
        }
    }

    return HRESULT_FROM_WIN32(dwErr);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrEnablePrivilege
//
//  Purpose:    Enables the specified privilege for the current process
//
//  Arguments:
//      pszPrivilegeName [in] The name of the privilege
//
//  Returns:    HRESULT. S_OK if successful,
//                       a converted Win32 error code otherwise
//
//  Author:     billbe   13 Dec 1997
//
//  Notes:
//
HRESULT
HrEnablePrivilege (
    IN PCWSTR pszPrivilegeName)
{
    HANDLE hToken;

    // Open the thread token in case it is impersonating
    BOOL fWin32Success = OpenThreadToken (GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);

    // If there was no token for the thread, open the process token
    //
    if (!fWin32Success && (ERROR_NO_TOKEN == GetLastError ()))
    {
        // Get token to adjust privileges for this process
        fWin32Success = OpenProcessToken (GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES, &hToken);
    }


    if (fWin32Success)
    {
        // get the luid that represents the privilege name
        LUID luid;
        fWin32Success = LookupPrivilegeValue(NULL, pszPrivilegeName, &luid);

        if (fWin32Success)
        {
            // set up the privilege structure
            TOKEN_PRIVILEGES tpNewPrivileges;
            tpNewPrivileges.PrivilegeCount = 1;
            tpNewPrivileges.Privileges[0].Luid = luid;
            tpNewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // turn on the privilege
            AdjustTokenPrivileges (hToken, FALSE, &tpNewPrivileges, 0,
                    NULL, NULL);

            if (ERROR_SUCCESS != GetLastError())
            {
                fWin32Success = FALSE;
            }
        }

        CloseHandle(hToken);
    }

    HRESULT hr;
    // Convert any errors to an HRESULT
    if (!fWin32Success)
    {
        hr = HrFromLastWin32Error();
    }
    else
    {
        hr = S_OK;
    }

    TraceError ("HrEnablePrivilege", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableAllPrivileges
//
//  Purpose:    Enables all privileges for the current process.
//
//  Arguments:
//      pptpOld  [out]  Returns the previous state of privileges so that they can
//                      be restored.
//
//  Returns:    S_OK if successful, Win32 Error otherwise
//
//  Author:     danielwe   11 Aug 1997
//
//  Notes:      The pptpOld parameter should be freed with delete [].
//
HRESULT
HrEnableAllPrivileges (
    OUT TOKEN_PRIVILEGES**  pptpOld)
{
    Assert(pptpOld);

    HRESULT hr = S_OK;
    HANDLE hTok;
    ULONG cbTok = 4096;
    BOOL fres;

    // Try opening the thread token first in case of impersonation
    fres = OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE, &hTok);

    if (!fres && (ERROR_NO_TOKEN == GetLastError()))
    {
        // If there was no thread token open the process token
        fres = OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hTok);
    }

    if (fres)
    {
        PTOKEN_PRIVILEGES ptpNew;
        hr = E_OUTOFMEMORY;
        ptpNew = (PTOKEN_PRIVILEGES)MemAlloc(cbTok);
        if (ptpNew)
        {
            hr = S_OK;

            fres = GetTokenInformation(hTok, TokenPrivileges,
                        ptpNew, cbTok, &cbTok);
            if (fres)
            {
                //
                // Set the state settings so that all privileges are enabled...
                //

                if (ptpNew->PrivilegeCount > 0)
                {
                    for (ULONG iPriv = 0; iPriv < ptpNew->PrivilegeCount; iPriv++)
                    {
                        ptpNew->Privileges[iPriv].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                *pptpOld = reinterpret_cast<PTOKEN_PRIVILEGES>(new BYTE[cbTok]);

                fres = AdjustTokenPrivileges(hTok, FALSE, ptpNew, cbTok, *pptpOld,
                                             &cbTok);
            }

            MemFree(ptpNew);
        }

        CloseHandle(hTok);
    }

    if (!fres)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrEnableAllPrivileges", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRestorePrivileges
//
//  Purpose:    Restores the privileges for the current process after they have
//              have been modified by HrEnableAllPrivileges().
//
//  Arguments:
//      ptpRestore [in]     Previous state of privileges as returned by
//                          HrEnableAllPrivileges().
//
//  Returns:    S_OK if successful, Win32 Error otherwise
//
//  Author:     danielwe   11 Aug 1997
//
//  Notes:
//
HRESULT
HrRestorePrivileges (
    IN  TOKEN_PRIVILEGES*   ptpRestore)
{
    HRESULT     hr = S_OK;
    HANDLE      hTok = NULL ;
    BOOL        fres = FALSE;

    Assert(ptpRestore);

    if (OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hTok))
    {
        if (AdjustTokenPrivileges(hTok, FALSE, ptpRestore, 0, NULL, NULL))
        {
            fres = TRUE;
        }

        CloseHandle(hTok);
    }

    if (!fres)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrRestorePrivileges", hr);
    return hr;
}

extern const DECLSPEC_SELECTANY WCHAR c_szConnectionsPolicies[] =
        L"Software\\Policies\\Microsoft\\Windows\\Network Connections";

// User types
const DWORD USER_TYPE_ADMIN         = 0x00000001;
const DWORD USER_TYPE_NETCONFIGOPS  = 0x00000002;
const DWORD USER_TYPE_POWERUSER     = 0x00000004;
const DWORD USER_TYPE_USER          = 0x00000008;
const DWORD USER_TYPE_GUEST         = 0x00000010;

typedef struct
{
    DWORD   dwShift;
    PCWSTR  pszValue;
    DWORD   dwApplyMask;
} PERM_MAP_STRUCT;

extern const DECLSPEC_SELECTANY PERM_MAP_STRUCT USER_PERM_MAP[] =
{
    {NCPERM_NewConnectionWizard,        L"NC_NewConnectionWizard", APPLY_TO_ALL_USERS},
    {NCPERM_Statistics,                 L"NC_Statistics", APPLY_TO_ALL_USERS},
    {NCPERM_AddRemoveComponents,        L"NC_AddRemoveComponents", APPLY_TO_ADMIN},
    {NCPERM_RasConnect,                 L"NC_RasConnect", APPLY_TO_ALL_USERS},
    {NCPERM_LanConnect,                 L"NC_LanConnect", APPLY_TO_ALL_USERS},
    {NCPERM_DeleteConnection,           L"NC_DeleteConnection", APPLY_TO_ALL_USERS},
    {NCPERM_DeleteAllUserConnection,    L"NC_DeleteAllUserConnection", APPLY_TO_ALL_USERS},
    {NCPERM_RenameConnection,           L"NC_RenameConnection", APPLY_TO_ALL_USERS},
    {NCPERM_RenameMyRasConnection,      L"NC_RenameMyRasConnection", APPLY_TO_ALL_USERS},
    {NCPERM_ChangeBindState,            L"NC_ChangeBindState", APPLY_TO_ADMIN},
    {NCPERM_AdvancedSettings,           L"NC_AdvancedSettings", APPLY_TO_ADMIN},
    {NCPERM_DialupPrefs,                L"NC_DialupPrefs", APPLY_TO_ALL_USERS},
    {NCPERM_LanChangeProperties,        L"NC_LanChangeProperties", APPLY_TO_OPS_OR_ADMIN},
    {NCPERM_RasChangeProperties,        L"NC_RasChangeProperties", APPLY_TO_ALL_USERS},
    {NCPERM_LanProperties,              L"NC_LanProperties", APPLY_TO_ALL_USERS},
    {NCPERM_RasMyProperties,            L"NC_RasMyProperties", APPLY_TO_ALL_USERS},
    {NCPERM_RasAllUserProperties,       L"NC_RasAllUserProperties", APPLY_TO_ALL_USERS},
    {NCPERM_ShowSharedAccessUi,         L"NC_ShowSharedAccessUi", APPLY_TO_LOCATION},
    {NCPERM_AllowAdvancedTCPIPConfig,   L"NC_AllowAdvancedTCPIPConfig", APPLY_TO_ALL_USERS},
    {NCPERM_PersonalFirewallConfig,     L"NC_PersonalFirewallConfig", APPLY_TO_LOCATION},
    {NCPERM_AllowNetBridge_NLA,         L"NC_AllowNetBridge_NLA", APPLY_TO_LOCATION},
    {NCPERM_ICSClientApp,               L"NC_ICSClientApp", APPLY_TO_LOCATION},
    {NCPERM_EnDisComponentsAllUserRas,  L"NC_EnDisComponentsAllUserRas", APPLY_TO_NON_ADMINS},
    {NCPERM_EnDisComponentsMyRas,       L"NC_EnDisComponentsMyRas", APPLY_TO_NON_ADMINS},
    {NCPERM_ChangeMyRasProperties,      L"NC_ChangeMyRasProperties", APPLY_TO_NON_ADMINS},
    {NCPERM_ChangeAllUserRasProperties, L"NC_ChangeAllUserRasProperties", APPLY_TO_NON_ADMINS},
    {NCPERM_RenameLanConnection,        L"NC_RenameLanConnection", APPLY_TO_NON_ADMINS},
    {NCPERM_RenameAllUserRasConnection, L"NC_RenameAllUserRasConnection", APPLY_TO_NON_ADMINS},
    {NCPERM_IpcfgOperation,             L"NC_IPConfigOperation", APPLY_TO_ALL_USERS},
    {NCPERM_Repair,                     L"NC_Repair", APPLY_TO_ALL_USERS},
};

extern const DECLSPEC_SELECTANY PERM_MAP_STRUCT MACHINE_PERM_MAP[] =
{
    {NCPERM_ShowSharedAccessUi,     L"NC_ShowSharedAccessUi", APPLY_TO_LOCATION},
    {NCPERM_PersonalFirewallConfig, L"NC_PersonalFirewallConfig", APPLY_TO_LOCATION},
    {NCPERM_ICSClientApp,           L"NC_ICSClientApp", APPLY_TO_LOCATION},
    {NCPERM_AllowNetBridge_NLA,     L"NC_AllowNetBridge_NLA", APPLY_TO_LOCATION}
};

extern const LONG NCPERM_Min = NCPERM_NewConnectionWizard;
extern const LONG NCPERM_Max = NCPERM_Repair;

// External policies (for now, only explorer has polices that affect our processing
//
extern const WCHAR c_szExplorerPolicies[] =
        L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer";

extern const WCHAR c_szNCPolicyForAdministrators[] =
        L"NC_EnableAdminProhibits";

extern const WCHAR c_szNoNetworkConnectionPolicy[] =
        L"NoNetworkConnections";


static DWORD g_dwPermMask;
static BOOL  g_fPermsInited = FALSE;

inline
VOID NCPERM_SETBIT(IN DWORD dw, IN DWORD dwVal)
{
    DWORD dwBit = (1 << dw);
    g_dwPermMask = (g_dwPermMask & ~dwBit) | ((0==dwVal) ? 0 : dwBit);
}

inline
BOOL NCPERM_CHECKBIT(IN DWORD dw)
{
    #ifdef DBG
        if (!FIsPolicyConfigured(dw))
        {
            if (0xFFFFFFFF != g_dwDbgPermissionsFail)
            {
                if (FProhibitFromAdmins() || !FIsUserAdmin())
                {
                    if ( (1 << dw) & g_dwDbgPermissionsFail)
                    {
                        TraceTag(ttidDefault, "Failing permissions check due to g_dwDbgPermissionsFail set");
                        return FALSE;
                    }
                }
            }
        }
    #endif  // DBG

    return !!(g_dwPermMask & (1 << dw));
}

inline
BOOL NCPERM_USER_IS_ADMIN(IN DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_ADMIN);
}

inline
BOOL NCPERM_USER_IS_NETCONFIGOPS(IN DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_NETCONFIGOPS);
}

inline
BOOL NCPERM_USER_IS_POWERUSER(IN DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_POWERUSER);
}

inline
BOOL NCPERM_USER_IS_USER(IN DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_USER);
}

inline
BOOL NCPERM_USER_IS_GUEST(IN DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_GUEST);
}

inline
BOOL NCPERM_APPLIES_TO_CURRENT_USER(IN DWORD dwUserType, IN DWORD dwApplyMask)
{
    return (dwUserType & dwApplyMask);
}

inline
int NCPERM_FIND_MAP_ENTRY(IN ULONG ulPerm)
{

    for (int i = 0; i < celems(USER_PERM_MAP); i++)

    {
        if (USER_PERM_MAP[i].dwShift == ulPerm)
        {
            return i;
        }
    }

    return -1;
}

inline
BOOL NCPERM_APPLIES_TO_LOCATION(IN ULONG ulPerm)
{
    BOOL bAppliesToLocation = FALSE;

    int nIdx = NCPERM_FIND_MAP_ENTRY(ulPerm);

    if (nIdx != -1)
    {
        bAppliesToLocation = (USER_PERM_MAP[nIdx].dwApplyMask & APPLY_TO_LOCATION);
    }
    else
    {
        bAppliesToLocation = FALSE;
    }
    return bAppliesToLocation;
}


inline
BOOL NCPERM_APPLY_BASED_ON_LOCATION(IN ULONG ulPerm, IN DWORD dwPermission)
{
    DWORD fSameNetwork = FALSE;

    if (g_pNetmanGPNLA)
    {
        fSameNetwork = g_pNetmanGPNLA->IsSameNetworkAsGroupPolicies();
    }

    if (!fSameNetwork && NCPERM_APPLIES_TO_LOCATION(ulPerm))
    {
        dwPermission = TRUE;
    }
    return dwPermission;
}

inline
DWORD NCPERM_USER_TYPE()
{
    if (FIsUserAdmin())
    {
        return USER_TYPE_ADMIN;
    }
    else if (FIsUserNetworkConfigOps())
    {
        return USER_TYPE_NETCONFIGOPS;
    }
    else if (FIsUserPowerUser())
    {
        return USER_TYPE_POWERUSER;
    }
    else if (FIsUserGuest())
    {
        return USER_TYPE_GUEST;
    }

    return USER_TYPE_USER;
}

inline
BOOL IsOsLikePersonal()
{
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;
    static BOOL fChecked = FALSE;
    static BOOL fOsLikePersonal = FALSE;
    
    // Optimization, since OS can't change on the fly.  Even a domain join requires a reboot.
    // If that ever changes then this logic needs to be revisited.
    // ISSUE: Revisit frequently. This may change.

    if (fChecked)
    {
        return fOsLikePersonal;
    }

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;
    
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);
    
    if(VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask))
    {
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS njs = NetSetupUnknownStatus;
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
        {
            NetApiBufferFree(pszDomain);
        }
        
        if (NetSetupDomainName == njs)
        {
            fOsLikePersonal = FALSE;    // connected to domain
        }
        else
        {
            fOsLikePersonal = TRUE;    // Professional, but not a domain member
        }
    }
    else
    {
        fOsLikePersonal = FALSE;
    }

    fChecked = TRUE;
    
    return fOsLikePersonal;
}


const ULONG c_arrayHomenetPerms[] =
{
    NCPERM_PersonalFirewallConfig,
    NCPERM_ICSClientApp,
    NCPERM_ShowSharedAccessUi
};

#ifdef DBG
ULONG g_dwDbgPermissionsFail = 0xFFFFFFFF;
ULONG g_dwDbgWin2kPoliciesSet = 0xFFFFFFFF;
#endif // DBG

//+---------------------------------------------------------------------------
//
//  Function:   FHasPermission
//
//  Purpose:    Called to determine if the requested permissions are available
//
//  Arguments:
//      ulPerm  [in]     Permission flags (E.g. NCPERM_xxxx)
//      pGPBase [in]     CGroupPolicyBase - the netman Group Policy Engine. In
//                       order to check a location aware policy, this must be 
//                       passed in.
//
//  Returns:    BOOL, TRUE if the requested permission is granted to the user
//
BOOL
FHasPermission(IN ULONG ulPerm, IN CGroupPolicyBase* pGPBase)
{
    TraceFileFunc(ttidDefault);

    DWORD dwCurrentUserType;

    Assert(static_cast<LONG>(ulPerm) >= NCPERM_Min);
    Assert(static_cast<LONG>(ulPerm) <= NCPERM_Max);

    g_pNetmanGPNLA = pGPBase;

    //if we are using DataCenter, Back Office,
    //Small Business Center, or Blade, then don't grant the permission
    
    for (int i = 0; i < celems(c_arrayHomenetPerms); i++)
    {
        if (c_arrayHomenetPerms[i] == ulPerm)
        {
            // On IA64, all homenet technologies are unavailable.
            #ifndef _WIN64
                // Look for the enterprise SKUs
                OSVERSIONINFOEXW verInfo = {0};
                ULONGLONG ConditionMask = 0;

                verInfo.dwOSVersionInfoSize = sizeof(verInfo);
                verInfo.wSuiteMask =    VER_SUITE_DATACENTER | 
                                                    VER_SUITE_BACKOFFICE | 
                                                    VER_SUITE_SMALLBUSINESS_RESTRICTED |
                                                    VER_SUITE_SMALLBUSINESS |
                                                    VER_SUITE_BLADE;

                VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);

                if(VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask))
            #endif
                {
                    return FALSE;
                }
        }
    }

    dwCurrentUserType = NCPERM_USER_TYPE();

    if (NCPERM_USER_IS_ADMIN(dwCurrentUserType) && !FProhibitFromAdmins() && !NCPERM_APPLIES_TO_LOCATION(ulPerm))
    {
        // If user is admin and we're not supposed to revoke
        // anything from admins and this is not a location aware policy
        // then just return TRUE
        return TRUE;
    }

    if (!g_fPermsInited)
    {
        TraceTag(ttidDefault, "Initializing permissions");
        RefreshAllPermission();
        g_fPermsInited = TRUE;
    }
    else
    {
        // update the requested permission only
        HRESULT hr      = S_OK;
        HKEY    hkey    = NULL;
        DWORD   dw      = 0;

        switch(ulPerm)
        {
        case NCPERM_OpenConnectionsFolder:
            TraceTag(ttidDefault, "Reading OpenConnectionsFolder permissions");
            hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szExplorerPolicies,
                                KEY_READ, &hkey);

            if (S_OK == hr)
            {
                TraceTag(ttidDefault, "Opened explorer policies");
                hr = HrRegQueryDword(hkey, c_szNoNetworkConnectionPolicy, &dw);
                if (SUCCEEDED(hr) && dw)
                {
                    TraceTag(ttidDefault,
                        "Explorer 'No open connections folder' policy: %d", dw);
                    NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 0);

                }

                RegCloseKey(hkey);
                hkey = NULL;
            }
            break;

        default:
            hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies,
                                KEY_READ, &hkey);
            if (S_OK == hr)
            {
                DWORD dw;

                // Read the User Policy
                for (UINT nIdx=0; nIdx<celems(USER_PERM_MAP); nIdx++)
                {
                    if (ulPerm == USER_PERM_MAP[nIdx].dwShift && NCPERM_APPLIES_TO_CURRENT_USER(dwCurrentUserType, USER_PERM_MAP[nIdx].dwApplyMask))
                    {
                        hr = HrRegQueryDword(hkey, USER_PERM_MAP[nIdx].pszValue, &dw);
                        if (SUCCEEDED(hr))
                        {
                            NCPERM_SETBIT(USER_PERM_MAP[nIdx].dwShift, dw);
                        }
                    }
                }

                RegCloseKey(hkey);
            }

            // Read the machine policy
            //
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szConnectionsPolicies,
                                KEY_READ, &hkey);
            if (S_OK == hr)
            {
                DWORD dw;

                for (UINT nIdx=0; nIdx<celems(MACHINE_PERM_MAP); nIdx++)
                {
                    if (ulPerm == MACHINE_PERM_MAP[nIdx].dwShift)
                    {
                        hr = HrRegQueryDword(hkey, MACHINE_PERM_MAP[nIdx].pszValue, &dw);
                        if (S_OK == hr)
                        {
                            NCPERM_SETBIT(MACHINE_PERM_MAP[nIdx].dwShift, NCPERM_APPLY_BASED_ON_LOCATION(ulPerm, dw));
                        }
                    }
                }

                RegCloseKey(hkey);
            }
            break;
        }
    }
    return NCPERM_CHECKBIT(ulPerm);
}


//+---------------------------------------------------------------------------
//
//  Function:   FHasPermissionFromCache
//
//  Purpose:    Fast call to determine if the requested permissions are available
//
//  Arguments:
//      ulPerm  [in]     Permission flags (E.g. NCPERM_xxxx)
//
//  Returns:    BOOL, TRUE if the requested permission is granted to the user
//
//  NOTE: Cannot be used to check a location aware policy!
//
BOOL
FHasPermissionFromCache(IN ULONG ulPerm)
{
    Assert(static_cast<LONG>(ulPerm) >= NCPERM_Min);
    Assert(static_cast<LONG>(ulPerm) <= NCPERM_Max);

    if (!g_fPermsInited)
    {
        RefreshAllPermission();
        g_fPermsInited = TRUE;
    }

    return NCPERM_CHECKBIT(ulPerm);
}

//+---------------------------------------------------------------------------
//
//  Function:   FProhibitFromAdmins
//
//  Purpose:    See if group policies should apply to the administrator
//
//  Arguments:
//
//  Returns:    TRUE if it should apply, otherwise false
//
//  Author:     ckotze  11 Aug 2000
//
//  Notes:
//
BOOL FProhibitFromAdmins()
{
    HRESULT hr = S_OK;
    HKEY hKey;
    DWORD dw;
    BOOL bEnabled = FALSE;

#ifdef DBG
    if (0xFFFFFFFF != g_dwDbgWin2kPoliciesSet)
    {
        return g_dwDbgWin2kPoliciesSet;
    }
#endif // DBG

    hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies,
        KEY_READ, &hKey);

    if (S_OK == hr)
    {
        hr = HrRegQueryDword(hKey, c_szNCPolicyForAdministrators, &dw);

        if (SUCCEEDED(hr))
        {
            bEnabled = (dw) ? TRUE : FALSE;
        }
        
        RegCloseKey(hKey);
    }

    TraceErrorOptional("FProhibitFromAdmins", hr, (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr));

    return bEnabled;
}

//+---------------------------------------------------------------------------
//
//  Function:   RefreshAllPermission
//
//  Purpose:    Initializes all permission to the settings from the registry,
//              and the ACL list below. Stores these to be used by
//              FHasPermissionFromCache
//
//  Arguments:
//      none
//
//  Returns:    None
//
VOID RefreshAllPermission()
{
    DWORD dwCurrentUserType;
    HKEY hkey;
    HRESULT hr;
    DWORD dw;

    dwCurrentUserType = NCPERM_USER_TYPE();

    g_dwPermMask = 0;

    // If Admin assume all rights
    //
    if (NCPERM_USER_IS_ADMIN(dwCurrentUserType))
    {
        // Cheat a little by setting all bits to one
        //
        g_dwPermMask = 0xFFFFFFFF;

        // If this policy is not set, then we don't need to worry about reading the regkeys
        // since we can never take anything away from Admins.
    }
    else if (NCPERM_USER_IS_NETCONFIGOPS(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_NewConnectionWizard, 1);
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_RasConnect, 1);
        NCPERM_SETBIT(NCPERM_DeleteConnection, 1);
        NCPERM_SETBIT(NCPERM_DeleteAllUserConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameMyRasConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameAllUserRasConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameLanConnection, 1);
        NCPERM_SETBIT(NCPERM_DialupPrefs, 1);
        NCPERM_SETBIT(NCPERM_RasChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_RasMyProperties, 1);
        NCPERM_SETBIT(NCPERM_RasAllUserProperties, 1);
        NCPERM_SETBIT(NCPERM_ChangeAllUserRasProperties, 1);
        NCPERM_SETBIT(NCPERM_LanProperties, 1);
        NCPERM_SETBIT(NCPERM_LanChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_AllowAdvancedTCPIPConfig, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
        NCPERM_SETBIT(NCPERM_LanConnect, 1);
        NCPERM_SETBIT(NCPERM_EnDisComponentsAllUserRas, 1);
        NCPERM_SETBIT(NCPERM_EnDisComponentsMyRas, 1);
        NCPERM_SETBIT(NCPERM_IpcfgOperation, 1);
        NCPERM_SETBIT(NCPERM_Repair, 1);
    }
    else if (NCPERM_USER_IS_POWERUSER(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_Repair, 1);

        // Rest should be like NCPERM_USER_IS_USER
        NCPERM_SETBIT(NCPERM_NewConnectionWizard, 1);
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_RasConnect, 1);
        NCPERM_SETBIT(NCPERM_DeleteConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameMyRasConnection, 1);
        NCPERM_SETBIT(NCPERM_DialupPrefs, 1);
        NCPERM_SETBIT(NCPERM_RasChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_RasMyProperties, 1);
        NCPERM_SETBIT(NCPERM_AllowAdvancedTCPIPConfig, 1);
        NCPERM_SETBIT(NCPERM_LanProperties, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
        if (IsOsLikePersonal())
        {
            NCPERM_SETBIT(NCPERM_RasAllUserProperties, 1);
            NCPERM_SETBIT(NCPERM_ChangeAllUserRasProperties, 1);
        }
    }
    else if (NCPERM_USER_IS_USER(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_NewConnectionWizard, 1);
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_RasConnect, 1);
        NCPERM_SETBIT(NCPERM_DeleteConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameMyRasConnection, 1);
        NCPERM_SETBIT(NCPERM_DialupPrefs, 1);
        NCPERM_SETBIT(NCPERM_RasChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_RasMyProperties, 1);
        NCPERM_SETBIT(NCPERM_AllowAdvancedTCPIPConfig, 1);
        NCPERM_SETBIT(NCPERM_LanProperties, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
        if (IsOsLikePersonal())
        {
            NCPERM_SETBIT(NCPERM_RasAllUserProperties, 1);
            NCPERM_SETBIT(NCPERM_ChangeAllUserRasProperties, 1);
        }
    }
    else if (NCPERM_USER_IS_GUEST(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
    }

    if (FProhibitFromAdmins() || !NCPERM_USER_IS_ADMIN(dwCurrentUserType))
    {
       // Read folder policy
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szExplorerPolicies,
                            KEY_READ, &hkey);
        if (S_OK == hr)
        {
            TraceTag(ttidDefault, "Opened Explorer Policy reg key");

            hr = HrRegQueryDword(hkey, c_szNoNetworkConnectionPolicy, &dw);
            if (SUCCEEDED(hr) && dw)
            {
                TraceTag(ttidDefault,  "Explorer 'No open connections folder' policy: %d", dw);
                NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 0);
            }

            RegCloseKey(hkey);

            hkey = NULL;
        }

        // Read the user policy
        //
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies,
                            KEY_READ, &hkey);

        if (S_OK == hr)
        {
            for (UINT nIdx=0; nIdx<celems(USER_PERM_MAP); nIdx++)
            {
                if (NCPERM_APPLIES_TO_CURRENT_USER(dwCurrentUserType, USER_PERM_MAP[nIdx].dwApplyMask))
                {
                    hr = HrRegQueryDword(hkey, USER_PERM_MAP[nIdx].pszValue, &dw);

                    if (SUCCEEDED(hr))
                    {
                        NCPERM_SETBIT(USER_PERM_MAP[nIdx].dwShift, dw);
                    }
                }
            }

            RegCloseKey(hkey);

        }
    }

    // Read the machine policy
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szConnectionsPolicies,
                        KEY_READ, &hkey);
    if (S_OK == hr)
    {
        DWORD dw;

        for (UINT nIdx=0; nIdx<celems(MACHINE_PERM_MAP); nIdx++)
        {
            hr = HrRegQueryDword(hkey, MACHINE_PERM_MAP[nIdx].pszValue, &dw);
            if (S_OK == hr)
            {
                NCPERM_SETBIT(MACHINE_PERM_MAP[nIdx].dwShift, NCPERM_APPLY_BASED_ON_LOCATION(MACHINE_PERM_MAP[nIdx].dwShift, dw));
            }
        }

        RegCloseKey(hkey);
    }
}





//+---------------------------------------------------------------------------
//
// Function:    IsHNetAllowed
//
// Purpose:     Verify the permission to use/enable (ICS/Firewall and create bridge network)
//
// Arguments:   dwPerm [in] Group policy check to make for permission checking
//
// Notes: Checks the following:
//
// Does the architecture / SKU permit the use of homenet technologies?
// Does group policy allow the particular technology?
// Is the user an Admin and are admins allowed access to this technology?
//
// Example scenario. The user is a Admin but ITG disables the right to create bridge this function would return FALSE
//
BOOL
IsHNetAllowed(
    IN  DWORD dwPerm
    )
{
#ifndef _WIN64
    BOOL                fPermission = false;
    OSVERSIONINFOEXW    verInfo = {0};
    ULONGLONG           ConditionMask = 0;

    // Look for the enterprise SKUs
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wSuiteMask =    VER_SUITE_DATACENTER | 
                                        VER_SUITE_BACKOFFICE | 
                                        VER_SUITE_SMALLBUSINESS_RESTRICTED |
                                        VER_SUITE_SMALLBUSINESS |
                                        VER_SUITE_BLADE;

    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    if ( VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask) )
    {
        // Homenet technologies are not available on enterprise SKUs
        return FALSE;
    }

    if ( FIsUserAdmin() && !FProhibitFromAdmins() )
    {
        HRESULT hr;
        INetMachinePolicies* pMachinePolicy;

        hr = CoCreateInstance(
            CLSID_NetGroupPolicies,
            NULL,
            CLSCTX_SERVER,
            IID_INetMachinePolicies,
            reinterpret_cast<void **>(&pMachinePolicy)
            );

            if ( SUCCEEDED(hr) )
        {
            hr = pMachinePolicy->VerifyPermission(dwPerm, &fPermission);
            pMachinePolicy->Release();
        }
    }

    return fPermission;

#else   // #ifndef _WIN64

    // On IA64, homenet technologies are not available at all.
    return FALSE;

#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsUserNetworkConfigOps
//
//  Purpose:    Checks to see if the current user is a NetConfig Operator
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     ckotze   12 Jun 2000
//
//  Notes:
//
BOOL FIsUserNetworkConfigOps()
{
    BOOL fIsMember;

    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS);

    return fIsMember;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsUserPowerUser
//
//  Purpose:    Checks to see if the current user is a Power User
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     deonb   9 May 2001
//
//  Notes:
//
BOOL FIsUserPowerUser()
{
    BOOL fIsMember;

    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_POWER_USERS);

    return fIsMember;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsUserGuest
//
//  Purpose:    Checks to see if the current user is a Guest
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     ckotze   12 Jun 2000
//
//  Notes:
//
BOOL FIsUserGuest()
{
    BOOL fIsMember;
    
    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_GUESTS);
    
    return fIsMember;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsPolicyConfigured
//
//  Purpose:    Checks to see if the specific policy is configured
//
//
//  Arguments:  ulPerm  [in] Group policy number from the USER_PERM_MAP
//
//
//  Returns:    BOOL.
//
//  Author:     ckotze   12 Jun 2000
//
//  Notes:
//
BOOL FIsPolicyConfigured(IN  DWORD ulPerm)
{
    HRESULT hr;
    HKEY hkey;
    BOOL bConfigured = FALSE;

    hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies, KEY_READ, &hkey);

    if (S_OK == hr)
    {
        DWORD dw;

        if (ulPerm == USER_PERM_MAP[ulPerm].dwShift)
        {
            DWORD dw;

            hr = HrRegQueryDword(hkey, USER_PERM_MAP[static_cast<DWORD>(ulPerm)].pszValue, &dw);
            if (SUCCEEDED(hr))
            {
                bConfigured = TRUE;
            }
        }

        RegCloseKey(hkey);
    }

    return bConfigured;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSameNetworkAsGroupPolicies
//
//  Purpose:    Checks to see if the current network is the same as where the
//              Group Policies were assigned from.
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL
//
//  Author:     ckotze   05 Jan 2001
//
//  Notes:
//
BOOL IsSameNetworkAsGroupPolicies()
{
    return g_pNetmanGPNLA->IsSameNetworkAsGroupPolicies();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncshell.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N C S H E L L . C P P
//
//  Contents:   Common routines for dealing with shell interfaces.
//
//  Notes:
//
//  Author:     anbrad  08  Jun 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "shlobj.h"
#include <shlobjp.h>

#include "pidlutil.h"

//+---------------------------------------------------------------------------
//
//  Function:   GenerateEvent
//
//  Purpose:    Generate a Shell Notification event.
//
//  Arguments:
//      lEventId   [in]     The event ID to post
//      pidlFolder [in]     Folder pidl
//      pidlIn     [in]     First pidl that we reference
//      pidlNewIn  [in]     If needed, the second pidl.
//
//  Returns:
//
//  Author:     jeffspr   16 Dec 1997
//
//  Notes:
//
VOID GenerateEvent(
    LONG            lEventId,
    LPCITEMIDLIST   pidlFolder,
    LPCITEMIDLIST   pidlIn,
    LPCITEMIDLIST   pidlNewIn)
{
    // Build an absolute pidl from the folder pidl + the object pidl
    //
    LPITEMIDLIST pidl = ILCombine(pidlFolder, pidlIn);
    if (pidl)
    {
        // If we have two pidls, call the notify with both
        //
        if (pidlNewIn)
        {
            // Build the second absolute pidl
            //
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                // Make the notification, and free the new pidl
                //
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                FreeIDL(pidlNew);
            }
        }
        else
        {
            // Make the single-pidl notification
            //
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }

        // Always refresh, then free the newly allocated pidl
        //
        SHChangeNotifyHandleEvents();
        FreeIDL(pidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G . C P P
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncreg.h"
#include "ncstring.h"
#include "ncperms.h"

extern const WCHAR c_szAdapters[];
extern const WCHAR c_szBackslash[];
extern const WCHAR c_szParameters[];
extern const WCHAR c_szRegKeyServices[];

//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToMultiSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Ensure the string is the first element of
//                                  the list. If the string is present and
//                                  duplicates aren't allowed, move the
//                                  string to the end.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Ensure the string is the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.  If the
//                                  string is present and duplicates aren't
//                                  allowed, move the string to the end.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the multi-sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the multi-sz, the string will be
//                                  placed at the end.
//                              STRING_FLAG_DONT_MODIFY_IF_PRESENT
//                                  If the string already exists in the
//                                  multi-sz then no modication will take
//                                  place.  Note: This takes precedent
//                                  over the presence/non-presence of the
//                                  STRING_FLAG_ALLOW_DUPLICATES flag.
//                                  i.e nothing will be added or removed
//                                  if this flag is set and the string was
//                                  present in the multi-sz
//      dwIndex         [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
HRESULT
HrRegAddStringToMultiSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN DWORD   dwFlags,
    IN DWORD   dwIndex)
{
    HRESULT     hr              = S_OK;
    DWORD       dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY        hkeyOpen        = NULL;     // Return value from RegCreateKeyEx
    HKEY        hkeyUse         = NULL;     // The key value that we'll actually use
    LPBYTE      pbOrderOld      = NULL;     // Return buffer for order reg value
    LPBYTE      pbOrderNew      = NULL;     // Build buffer for order swap

    // Check for valid parameters
    if (!pszAddString || !hkeyRoot || !pszValueName)
    {
        Assert(pszAddString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_REMOVE_SINGLE)      ||
        (dwFlags & STRING_FLAG_REMOVE_ALL)         ||
        ((dwFlags & STRING_FLAG_ENSURE_AT_FRONT)   &&
         (dwFlags & STRING_FLAG_ENSURE_AT_END)))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToMultiSz");

        hr = E_INVALIDARG;
        goto Exit;
    }

    // If the user passed in a subkey string, then we should attempt to open
    // the subkey of the passed in root, else we'll just use the
    // pre-opened hkeyRoot
    //
    if (pszKeySubPath)
    {
        // Open the key, creating if necessary
        //
        hr = HrRegCreateKeyEx (
                hkeyRoot,                           // Base hive
                pszKeySubPath,                      // Our reg path
                0,                                  // dwOptions
                KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
                NULL,                               // lpSecurityAttributes
                &hkeyOpen,                          // Our return hkey.
                NULL);
        if (FAILED(hr))
        {
            goto Exit;
        }

        hkeyUse = hkeyOpen;
    }
    else
    {
        // Use the passed in key for the Query.
        //
        hkeyUse = hkeyRoot;
    }

    // Retrieve the existing REG_MULTI_SZ
    //
    hr = HrRegQueryValueWithAlloc (
            hkeyUse,
            pszValueName,
            &dwRegType,
            &pbOrderOld,
            NULL);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value was missing, and we
            // should continue on, and create the value ourselves.
            hr = S_OK;
        }
        else
        {
            // Since there's an error that we didn't expect, drop out,
            // returning this error to the caller.
            //
            goto Exit;
        }
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_MULTI_SZ)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
            goto Exit;
        }
    }

    BOOL fChanged;
    hr = HrAddSzToMultiSz (pszAddString, (PCWSTR)pbOrderOld,
            dwFlags, dwIndex, (PWSTR*)&pbOrderNew, &fChanged);

    if ((S_OK == hr) && fChanged)
    {
        DWORD cbNew = CbOfMultiSzAndTermSafe ((PWSTR)pbOrderNew);

        // Save our string back into the registry
        //
        hr = HrRegSetValueEx (
                hkeyUse,
                pszValueName,
                REG_MULTI_SZ,
                (const BYTE *)pbOrderNew,
                cbNew);
    }

Exit:
    // Close the key, if opened
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pbOrderOld);
    MemFree (pbOrderNew);

    TraceError ("HrRegAddStringToMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '. This will
//                              be used to delimit the value that we add,
//                              as well.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Insert the string as the first element of
//                                  the list.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Insert the string as the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the sz, the string will be
//                                  placed at the end.
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRegAddStringToSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN WCHAR   chDelimiter,
    IN DWORD   dwFlags,
    IN DWORD   dwStringIndex)
{
    HRESULT    hr              = S_OK;
    DWORD      dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY       hkeyOpen        = NULL;     // Open key to open
    PWSTR      pszOrderOld     = NULL;     // Return buffer for order reg value
    PWSTR      pszOrderNew     = NULL;     // Build buffer for order swap

    // Check for all of the required args
    //
    if (!pszAddString || !hkeyRoot || !pszValueName)
    {
        Assert(pszAddString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_REMOVE_SINGLE) ||
        (dwFlags & STRING_FLAG_REMOVE_ALL))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToSz");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Open the key, creating if necessary
    //
    hr = HrRegCreateKeyEx(
            hkeyRoot,                           // Base hive
            pszKeySubPath,                      // Our reg path
            0,                                  // dwOptions
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
            NULL,                               // lpSecurityAttributes
            &hkeyOpen,                          // Our return hkey.
            NULL);
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc(
            hkeyOpen,
            pszValueName,
            &dwRegType,
            (LPBYTE *) &pszOrderOld,
            NULL);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }
        else
        {
            goto Exit;
        }
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Exit;
        }
    }

    hr = HrAddStringToDelimitedSz(pszAddString, pszOrderOld, chDelimiter,
            dwFlags, dwStringIndex, &pszOrderNew);

    if (S_OK == hr)
    {

        // Save our string back into the registry
        //
        hr = HrRegSetSz(hkeyOpen, pszValueName, pszOrderNew);
        if (FAILED(hr))
        {
            goto Exit;
        }
    }

Exit:
    // Close the key, if open
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pszOrderOld);
    MemFree (pszOrderNew);

    TraceError ("HrRegAddStringToSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromSz
//
//  Purpose:    Removes a string from a REG_SZ registry value
//
//  Arguments:
//      pszRemoveString [in]    The string to be removed from the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_REMOVE_SINGLE
//                                  Don't remove more than one value, if
//                                  multiple are present.
//                              STRING_FLAG_REMOVE_ALL
//                                  If multiple matching values are present,
//                                  remove them all.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRegRemoveStringFromSz (
    IN PCWSTR pszRemoveString,
    IN HKEY hkeyRoot,
    IN PCWSTR pszKeySubPath,
    IN PCWSTR pszValueName,
    IN WCHAR chDelimiter,
    IN DWORD dwFlags )
{
    HRESULT     hr              = S_OK;
    DWORD       dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY        hkeyOpen        = NULL;     // Open key to open
    PWSTR       pszOrderOld     = NULL;     // Return buffer for order reg value
    PWSTR       pszOrderNew     = NULL;     // Build buffer for order swap
    DWORD       dwDataSize      = 0;

    // Check for all of the required args
    //
    if (!pszRemoveString || !hkeyRoot || !pszValueName)
    {
        Assert(pszRemoveString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_ENSURE_AT_FRONT)    ||
        (dwFlags & STRING_FLAG_ENSURE_AT_END)      ||
        ((dwFlags & STRING_FLAG_REMOVE_SINGLE)     &&
         (dwFlags & STRING_FLAG_REMOVE_ALL)))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToSz");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Open the key, creating if necessary
    //
    hr = HrRegOpenKeyEx (
            hkeyRoot,                           // Base hive
            pszKeySubPath,                      // Our reg path
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
            &hkeyOpen);                         // Our return hkey
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
        }
        goto Exit;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc (
            hkeyOpen,
            pszValueName,
            &dwRegType,
            (LPBYTE *) &pszOrderOld,
            &dwDataSize);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }
        goto Exit;
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a REG_SZ
        //
        if (dwRegType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Exit;
        }

        if (dwDataSize == 0)
        {
            // This is OK, but we're going to assert here anyway, because this is not
            // a case that I know about
            //
            AssertSz(dwDataSize > 0, "How did we retrieve something from the "
                    "registry with 0 size?");

            hr = S_OK;
            goto Exit;
        }
    }

    hr = HrRemoveStringFromDelimitedSz (pszRemoveString, pszOrderOld,
            chDelimiter, dwFlags, &pszOrderNew);

    if (S_OK == hr)
    {
        // Save our string back into the registry
        //
        hr = HrRegSetSz (hkeyOpen, pszValueName, pszOrderNew);
    }

Exit:
    // Close the key, if open
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pszOrderOld);
    MemFree (pszOrderNew);

    TraceError("HrRegRemoveStringFromSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromMultiSz
//
//  Purpose:    Removes the specified string from a multi-sz, if it is present.
//
//  Arguments:
//      pszRemoveString [in]
//      hkeyRoot        [in]
//      pszKeySubPath   [in]
//      pszValueName    [in]
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_REMOVE_SINGLE
//                                  Don't remove more than one value, if
//                                  multiple are present.
//                              [default] STRING_FLAG_REMOVE_ALL
//                                  If multiple matching values are present,
//                                  remove them all.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     ScottBri 11-Apr-1997
//
//  Notes:
//
HRESULT
HrRegRemoveStringFromMultiSz (
    IN PCWSTR  pszRemoveString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN DWORD   dwFlags)
{
    DWORD   dwDataSize;
    DWORD   dwRegType;
    HKEY    hkey = NULL;
    HKEY    hkeyUse = hkeyRoot;
    HRESULT hr;
    PWSTR   psz = NULL;

    // Valid the input parameters
    if ((NULL == pszRemoveString) || (NULL == pszValueName) ||
        (NULL == hkeyRoot))
    {
        Assert(NULL != pszRemoveString);
        Assert(NULL != pszValueName);
        Assert(NULL != hkeyRoot);
        return E_INVALIDARG;
    }

    if ((STRING_FLAG_REMOVE_SINGLE & dwFlags) &&
        (STRING_FLAG_REMOVE_ALL & dwFlags))
    {
        AssertSz(FALSE, "Can't specify both 'remove all' and 'remove single'");
        return E_INVALIDARG;
    }

    if (NULL != pszKeySubPath)
    {
        hr = HrRegOpenKeyEx (hkeyRoot, pszKeySubPath, KEY_READ_WRITE, &hkey);
        if (S_OK != hr)
        {
            return hr;
        }

        hkeyUse = hkey;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc (hkeyUse, pszValueName, &dwRegType,
                                    (LPBYTE *)&psz, &dwDataSize);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr)
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }

        goto Done;
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_MULTI_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Done;
        }
    }

    // Search for and extract the specified string if present
    Assert(psz);
    BOOL fRemoved;
    RemoveSzFromMultiSz (pszRemoveString, psz, dwFlags, &fRemoved);

    // Rewrite the registry value if it was changed
    if (fRemoved)
    {
        dwDataSize = CbOfMultiSzAndTermSafe (psz);
        hr = HrRegSetValueEx (hkeyUse, pszValueName, REG_MULTI_SZ,
                               (const LPBYTE)psz, dwDataSize);
    }

Done:
    RegSafeCloseKey (hkey);
    MemFree (psz);

    TraceError ("HrRegRemoveStringFromMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegCopyHive
//
//  Purpose:    Copies the contents of one hive to another.  It does this
//              by using RegSaveKey and RegRestoreKey to a temporary file.
//
//  Arguments:
//      hkeySrc [in] The source key to copy from.
//      hkeyDst [in] The destination key to copy to.
//
//  Returns:    S_OK or an error
//
//  Author:     shaunco   12 Jan 1998
//
//  Notes:
//
HRESULT
HrRegCopyHive (
    IN HKEY    hkeySrc,
    IN HKEY    hkeyDst)
{
    HRESULT hr;

    // Enable the needed privileges.
    //
    if ((S_OK == (hr = HrEnablePrivilege(SE_BACKUP_NAME))) &&
        (S_OK == (hr = HrEnablePrivilege(SE_RESTORE_NAME))))
    {
        // Create a temporary file name to save the source hive to.
        //
        static const WCHAR c_szPrefix [] = L"~ch";
        WCHAR szTempPath [MAX_PATH];
        WCHAR szTempFile [MAX_PATH];

        // If GetTempPath fails, we'd like to know about it (via the trace)
        // but it's not fatal as we'll just use the current directory
        // as the path.
        //
        if (!GetTempPath (celems(szTempPath), szTempPath))
        {
            TraceError ("HrRegCopyHive: GetTempPath failed (benign)",
                HrFromLastWin32Error ());

            *szTempFile = 0;
        }

        // Create the temporary filename and delete it because RegSaveKey
        // won't write to an existing file.
        //
        if (GetTempFileName (szTempPath, c_szPrefix, 0, szTempFile))
        {
            DeleteFile (szTempFile);

            // Save the source key to the temp file.
            //
            hr = HrRegSaveKey (hkeySrc, szTempFile, NULL);
            if (S_OK == hr)
            {
                // Restore the temp file to the destination key.
                //
                hr = HrRegRestoreKey (hkeyDst, szTempFile, NULL);
            }

            // We're done with the temp file so we delete it.  We shoudln't
            // have any error doing this, but it will be nice to see it
            // should it occur.
            //
            if (!DeleteFile (szTempFile))
            {
                TraceError ("HrRegCopyHive: DeleteFile failed on the "
                    "temporary file (benign)",
                    HrFromLastWin32Error ());
            }
        }
        else
        {
            hr = HrFromLastWin32Error ();
        }
    }

    TraceError ("HrRegCopyHive", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegCreateKeyEx
//
//  Purpose:    Creates a registry key by calling RegCreateKeyEx.
//
//  Arguments:
//      hkey                 [in]
//      pszSubkey            [in]
//      dwOptions            [in]   See the Win32 documentation for the
//      samDesired           [in]   RegCreateKeyEx function.
//      lpSecurityAttributes [in]
//      phkResult            [out]
//      pdwDisposition       [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegCreateKeyExW (hkey, pszSubkey, 0, NULL, dwOptions, samDesired,
            lpSecurityAttributes, phkResult, pdwDisposition);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceError("HrRegCreateKeyEx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKey
//
//  Purpose:    Delete the specified registry key.
//
//  Arguments:
//      hkey     [in]   See the Win32 documentation for the RegDeleteKey.
//      pszSubkey [in]   function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
HRESULT
HrRegDeleteKey (
    IN HKEY hkey,
    IN PCWSTR pszSubkey)
{
    Assert (hkey);
    Assert (pszSubkey);

    LONG lr = RegDeleteKeyW (hkey, pszSubkey);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceHr (ttidError, FAL, hr, ERROR_FILE_NOT_FOUND == lr,
        "HrRegDeleteKey");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKeyTree
//
//  Purpose:    Deletes an entire registry hive.
//
//  Arguments:
//      hkeyParent  [in]   Handle to open key where the desired key resides.
//      pszRemoveKey [in]   Name of key to delete.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      ckotze Changed to use KEY_READ_WRITE_DELETE as opposed to 
//              KEY_ALL_ACCESS, which is far too much access for what is
//              required.
//
HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey)
{
    Assert (hkeyParent);
    Assert (pszRemoveKey);

    // Open the key we want to remove
    HKEY hkeyRemove;
    HRESULT hr = HrRegOpenKeyEx(hkeyParent, pszRemoveKey, KEY_READ_WRITE_DELETE,
            &hkeyRemove);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    if (S_OK == hr)
    {
        WCHAR       szValueName [MAX_PATH];
        DWORD       cchBuffSize = MAX_PATH;
        FILETIME    ft;
        LONG        lr;

        // Enum the keys children, and remove those sub-trees
        while (ERROR_SUCCESS == (lr = RegEnumKeyExW (hkeyRemove,
                0,
                szValueName,
                &cchBuffSize,
                NULL,
                NULL,
                NULL,
                &ft)))
        {
            HrRegDeleteKeyTree (hkeyRemove, szValueName);
            cchBuffSize = MAX_PATH;
        }
        RegCloseKey (hkeyRemove);

        if ((ERROR_SUCCESS == lr) || (ERROR_NO_MORE_ITEMS == lr))
        {
            lr = RegDeleteKeyW (hkeyParent, pszRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lr);
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrRegDeleteKeyTree");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteValue
//
//  Purpose:    Deletes the given registry value.
//
//  Arguments:
//      hkey        [in]    See the Win32 documentation for the RegDeleteValue
//      pszValueName [in]    function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName)
{
    Assert (hkey);
    Assert (pszValueName);

    LONG lr = RegDeleteValueW (hkey, pszValueName);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceErrorOptional("HrRegDeleteValue", hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKey
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumKey (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN DWORD cchSubkeyName)
{
    Assert (hkey);
    Assert (pszSubkeyName);
    Assert (cchSubkeyName);

    LONG lr = RegEnumKeyW (hkey, dwIndex, pszSubkeyName, cchSubkeyName);

    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceHr (ttidError, FAL, hr, ERROR_NO_MORE_ITEMS == lr,
            "HrRegEnumKey");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKeyEx
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//      pszClass         [out]
//      pcchClass        [inout]
//      pftLastWriteTime [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime)
{
    Assert (hkey);
    Assert (pszSubkeyName);
    Assert (pcchSubkeyName);
    Assert (pftLastWriteTime);

    LONG lr = RegEnumKeyExW (hkey, dwIndex, pszSubkeyName, pcchSubkeyName,
                            NULL, pszClass, pcchClass, pftLastWriteTime);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceHr (ttidError, FAL, hr, ERROR_NO_MORE_ITEMS == lr,
            "HrRegEnumKeyEx");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumValue
//
//  Purpose:    Enumerates the values for the specified open registry key.
//
//  Arguments:
//      hkey          [in]
//      dwIndex       [in]      See the Win32 documentation for the
//      pszValueName  [out]     RegEnumValue function.
//      pcbValueName  [inout]
//      pdwType       [out]
//      pbData        [out]
//      pcbData       [inout]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumValue (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszValueName,
    IN OUT LPDWORD pcbValueName,
    OUT LPDWORD pdwType,
    OUT LPBYTE  pbData,
    IN OUT LPDWORD pcbData)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pcbValueName);
    Assert (FImplies(pbData, pcbData));

    LONG lr = RegEnumValueW (hkey, dwIndex, pszValueName, pcbValueName,
                            NULL, pdwType, pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceErrorOptional("HrRegEnumValue", hr, (ERROR_NO_MORE_ITEMS == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyExW (hkey, pszSubkey, 0, samDesired, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32(lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
        TraceTag(ttidDefault, "Error Opening Key:%s hr: 0x%x", pszSubkey, hr);
    }

    TraceErrorOptional("HrRegOpenKeyEx",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyBestAccess
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx with the highest
//              access possible.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     scottbri    31-Oct-1997
//
//  Notes:
//
HRESULT
HrRegOpenKeyBestAccess (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    OUT PHKEY phkResult)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    TraceTag(ttidDefault, "Why do you call this function?  Either you can write or you can't.");

    LONG lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_ALL_ACCESS, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (E_ACCESSDENIED == hr)
    {
        lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_READ_WRITE_DELETE, phkResult);
        hr = HRESULT_FROM_WIN32 (lr);

        if (E_ACCESSDENIED == hr)
        {
            lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_READ_WRITE, phkResult);
            hr = HRESULT_FROM_WIN32 (lr);
            if (E_ACCESSDENIED == hr)
            {
                lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_READ, phkResult);
                hr = HRESULT_FROM_WIN32 (lr);
                if (E_ACCESSDENIED == hr)
                {
                    lr = RegOpenKeyExW (hkey, pszSubkey, 0, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE, phkResult);
                    hr = HRESULT_FROM_WIN32 (lr);
                }
            }
        }
    }

    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceErrorOptional("HrRegOpenKeyEx",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDuplicateKeyEx
//
//  Purpose:    Duplicates a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   09 Apr 1997
//
//  Notes:
//
HRESULT
HrRegDuplicateKeyEx (
    IN HKEY hkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)

{
    Assert (hkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyExW (hkey, NULL, 0, samDesired, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceError("HrRegDuplicateKeyEx", hr);
    return hr;
}

HRESULT
HrRegSetBool (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN BOOL fValue)
{
    DWORD dwValue = !!fValue;
    return HrRegSetValueEx (hkey, pszValueName,
                REG_DWORD,
                (LPBYTE)&dwValue, sizeof(DWORD));
}

HRESULT
HrRegSetDword (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwValue)
{
    return HrRegSetValueEx (hkey, pszValueName,
                REG_DWORD,
                (LPBYTE)&dwValue, sizeof(DWORD));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetGuidAsSz
//
//  Purpose:    Converts a given guid to a string and sets the given registry
//              value.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      guid         [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     BillBe   21 Feb 1999
//
//  Notes:
//
HRESULT
HrRegSetGuidAsSz (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const GUID& guid)
{
    HRESULT hr;
    INT cch;
    WCHAR szGuid[c_cchGuidWithTerm];

    Assert (hkey);
    Assert (pszValueName && *pszValueName);

    cch = StringFromGUID2 (guid, szGuid, c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);

    hr = HrRegSetSz (hkey, pszValueName, szGuid);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegSetGuidAsSz");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValueEx
//
//  Purpose:    Sets the data for the given registry value by calling the
//              RegSetValueEx function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    Assert (hkey);
    Assert (FImplies (cbData > 0, pbData));

    LONG lr = RegSetValueExW(hkey, pszValueName, 0, dwType, pbData, cbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegSetValue", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSafeCloseKey
//
//  Purpose:    Closes the given registry key if it is non-NULL.
//
//  Arguments:
//      hkey [in]   Key to be closed. Can be NULL.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      If hkey is NULL this function does nothing.
//
VOID
RegSafeCloseKey (
    IN HKEY hkey)
{
    if (hkey)
    {
        RegCloseKey(hkey);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRestoreKey
//
//  Purpose:    Wrapper for RegRestoreKey
//
//  Arguments:
//      hkey        [in]    Parent key to restore into
//      pszFileName [in]    Name of file containing registry info
//      dwFlags     [in]    Flags for restore
//
//  Returns:    Win32 HRESULT if failure, otherwise S_OK
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:      See docs for RegRestoreKey for more info
//
HRESULT
HrRegRestoreKey (
    IN HKEY hkey,
    IN PCWSTR pszFileName,
    IN DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    LONG        lres;

    Assert(hkey);
    Assert(pszFileName);

    lres = RegRestoreKeyW(hkey, pszFileName, dwFlags);
    hr = HRESULT_FROM_WIN32(lres);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegRestoreKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSaveKey
//
//  Purpose:    Wrapper for RegSaveKey
//
//  Arguments:
//      hkey        [in]     Parent key to restore into
//      pszFileName [in]     Name of file containing registry info
//      psa         [in]     Security attributes for the file
//
//  Returns:    Win32 HRESULT if failure, otherwise S_OK
//
//  Author:     BillBe   2 Jan 1998
//
//  Notes:      See docs for RegSaveKey for more info
//
HRESULT
HrRegSaveKey (
    IN HKEY hkey,
    IN PCWSTR pszFileName,
    IN LPSECURITY_ATTRIBUTES psa)
{
    HRESULT     hr;
    LONG        lres;

    Assert(hkey);
    Assert(pszFileName);

    lres = RegSaveKeyW (hkey, pszFileName, psa);
    hr = HRESULT_FROM_WIN32(lres);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegSaveKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegGetKeySecurity
//
//  Purpose:    Retrieves the Security of a Key using RegGetKeySecurity
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     ckotze   06 July 2000
//
//  Notes:
//
HRESULT
HrRegGetKeySecurity(
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    LPDWORD                 lpcbSecurityDescriptor)
{
    Assert (hKey);
    Assert (SecurityInformation);
    Assert (pSecurityDescriptor);

    LONG lr = RegGetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    if (FAILED(hr))
    {
        pSecurityDescriptor = NULL;
    }

    TraceErrorOptional("HrRegGetKeySecurity", hr, (lr != ERROR_INSUFFICIENT_BUFFER));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT HrRegSetKeySecurity (
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    Assert (hKey);
    Assert (SecurityInformation);
    Assert (pSecurityDescriptor);

    LONG lr = RegSetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

     // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegSetKeySecurity", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterKey
//
//  Purpose:    This creates or opens the Adapters subkey to a component
//
//  Arguments:
//      pszComponentName [in]   The name of the component being
//      fCreate [in]            TRUE if the directory is to be created
//      phkey [out]             The handle to the Adapters subkey
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill       06/11/97
//
//  Notes:      The handle has to be release by the calling app on SUCCESS
//
HRESULT
HrRegOpenAdapterKey (
    IN PCWSTR pszComponentName,
    IN BOOL fCreate,
    OUT HKEY* phkey)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    tstring     strKey;

    // Build the registry path
    strKey = c_szRegKeyServices;

    strKey.append(c_szBackslash);
    strKey.append(pszComponentName);

    strKey.append(c_szBackslash);
    strKey.append(c_szParameters);

    strKey.append(c_szBackslash);
    strKey.append(c_szAdapters);

    // Create the key if we are asked
    if (fCreate)
    {
        hr = HrRegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                strKey.c_str(),
                REG_OPTION_NON_VOLATILE,
                KEY_READ_WRITE_DELETE,
                NULL,
                phkey,
                &dwDisposition);
    }
    else
    {
        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                strKey.c_str(),
                KEY_READ,
                phkey);
    }

    TraceError("HrRegOpenAdapterKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryColString
//
//  Purpose:    Allocates strings and appends to collects as read from the registry.
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      pcolstr      [out]   The returned collection of tstrings*. empty collection otherwise.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:      If the function succeeds, you must call DeleteColString on the
//              return parameter.
//              This will empty and delete the collection passed in
//
//---------------------------------------------------------------------------
HRESULT
HrRegQueryColString (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT list<tstring*>* pcolstr )
{
    WCHAR* pmsz;
    HRESULT hr;

    DeleteColString (pcolstr);
    hr = HrRegQueryMultiSzWithAlloc (hkey, pszValueName, &pmsz);

    if (S_OK == hr)
    {
        MultiSzToColString (pmsz, pcolstr);
        MemFree (pmsz);
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr, "HrRegQueryColString");
    return hr;
}

HRESULT
HrRegQueryColString (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT vector<tstring*>* pcolstr )
{
    WCHAR* pmsz;
    HRESULT hr;

    DeleteColString (pcolstr);
    hr = HrRegQueryMultiSzWithAlloc (hkey, pszValueName, &pmsz);

    if (S_OK == hr)
    {
        MultiSzToColString (pmsz, pcolstr);
        MemFree (pmsz);
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr, "HrRegQueryColString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetColString
//
//  Purpose:    Sets a multi-sz in the registry using the collection of strings
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      colstr       [in]    The collection of tstrings to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
//---------------------------------------------------------------------------
HRESULT
HrRegSetColString (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const list<tstring*>& colstr)
{
    WCHAR* pmsz;
    HRESULT hr;

    ColStringToMultiSz (colstr, &pmsz);
    hr = HrRegSetMultiSz (hkey, pszValueName, (pmsz ? pmsz : c_szEmpty));
    MemFree (pmsz);

    TraceError ("HrRegSetColString", hr);
    return hr;
}

HRESULT
HrRegSetColString (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const vector<tstring*>& colstr)
{
    WCHAR* pmsz;
    HRESULT hr;

    ColStringToMultiSz (colstr, &pmsz);
    hr = HrRegSetMultiSz (hkey, pszValueName, (pmsz ? pmsz : c_szEmpty));
    MemFree (pmsz);

    TraceError ("HrRegSetColString", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncregq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G Q . C P P
//
//  Contents:   HrRegQuery functions.
//
//  Notes:
//
//  Author:     shaunco   5 Jun 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncreg.h"

//+---------------------------------------------------------------------------
//
//  Function:   ExpandEnvironmentStringsIntoTstring
//
//  Purpose:    Call ExpandEnvironmentStrings and provide a buffer that
//              is a tstring.
//
//  Arguments:
//      pszSrc  [in]  The string to expand.  Can be empty, but not NULL.
//      pstrDst [out] The expanded version.
//
//  Returns:    nothing
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:
//
VOID
ExpandEnvironmentStringsIntoTstring (
    PCWSTR      pszSrc,
    tstring*    pstrDst)
{
    // Initialize the output parameter.
    //
    pstrDst->erase();

    DWORD cch = lstrlenW (pszSrc);
    if (cch)
    {
        // Start with 64 more characters than are in pszSrc.
        //
        cch += 64;

        // assign will reserve cch characters and set them all to 0.
        // checking capacity afterwards ensures the allocation made
        // internally didn't fail.
        //
        pstrDst->assign (cch, 0);
        if (cch <= pstrDst->capacity ())
        {
            DWORD cchIncludingNull;

            cchIncludingNull = ExpandEnvironmentStringsW (
                                    pszSrc,
                                    (PWSTR)pstrDst->data (),
                                    cch + 1);

            Assert (cchIncludingNull);
            cch = cchIncludingNull - 1;

            // If we didn't have enough room, reserve the required amount.
            //
            if (cch > pstrDst->capacity ())
            {
                pstrDst->assign (cch, 0);
                if (cch <= pstrDst->capacity ())
                {
                    ExpandEnvironmentStringsW (
                            pszSrc,
                            (PWSTR)pstrDst->data (),
                            cch + 1);
                }
            }

            // Make sure the string's inards are correct.
            //
            pstrDst->resize (cch);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeWithAlloc
//
//  Purpose:    Retrieves a type'd value from the registry and returns a
//              pre-allocated buffer with the data and optionally the size of
//              the returned buffer.
//
//  Arguments:
//      hkey         [in]    Handle of parent key
//      pszValueName [in]    Name of value to query
//      ppbValue     [out]   Buffer with binary data
//      pcbValue     [out]   Size of buffer in bytes. If NULL, size is not
//                           returned.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   16 Apr 1997
//
//  Notes:      Free the returned buffer with MemFree.
//
HRESULT
HrRegQueryTypeWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    HRESULT hr;
    DWORD   dwTypeRet;
    LPBYTE  pbData;
    DWORD   cbData;

    Assert(hkey);
    Assert(ppbValue);

    // Get the value.
    //
    hr = HrRegQueryValueWithAlloc(hkey, pszValueName, &dwTypeRet,
                                  &pbData, &cbData);

    // It's type should be REG_BINARY. (duh).
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        MemFree(pbData);
        pbData = NULL;

        TraceTag(ttidError, "Expected a type of REG_BINARY for %S.",
            pszValueName);
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // Assign the output parameters.
    if (S_OK == hr)
    {
        *ppbValue = pbData;
        if (pcbValue)
        {
            *pcbValue = cbData;
        }
    }
    else
    {
        *ppbValue = NULL;
        if (pcbValue)
        {
            *pcbValue = 0;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryTypeWithAlloc");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryDword
//
//  Purpose:    Gets a DWORD from the registry.  Checks that its type and
//              size are correct.  Easier to understand than HrRegQueryValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      pdwValue     [out]   The returned DWORD value if successful.  Zero
//                           if not.
//
//  Returns:    S_OK or HRESULT_FROM_WIN32.
//
//  Author:     shaunco   27 Mar 1997
//
//  Side Effects:   On error, the output DWORD is set to zero to line-up
//                  with the rules of COM in this regard.
//
HRESULT
HrRegQueryDword (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPDWORD pdwValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pdwValue);

    // Get the value.
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwType,
            (LPBYTE)pdwValue, &cbData);

    // It's type should be REG_DWORD. (duh).
    //
    if ((S_OK == hr) && (REG_DWORD != dwType))
    {
        TraceTag (ttidError, "Expected a type of REG_DWORD for %S.",
            pszValueName);
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // It's size should be correct too.
    //
    AssertSz (FImplies(S_OK == hr, sizeof(DWORD) == cbData),
              "Expected sizeof(DWORD) bytes to be returned.");

    // Make sure we initialize the output value on error.
    // (We don't know for sure that RegQueryValueEx does this.)
    //
    if (S_OK != hr)
    {
        *pdwValue = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryDword");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryExpandString
//
//  Purpose:    Query a REG_EXPAND_SZ value from the registry and
//              expand it using ExpandEnvironmentStrings.  Return the
//              result in a tstring.
//
//  Arguments:
//      hkey         [in]  The parent HKEY of szValueName
//      pszValueName [in]  The name of the value to query.
//      pstrValue    [out] The returned (expanded) value.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:
//
HRESULT
HrRegQueryExpandString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    tstring*    pstrValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pstrValue);

    tstring strToExpand;
    HRESULT hr = HrRegQueryTypeString (hkey, pszValueName,
            REG_EXPAND_SZ, &strToExpand);

    if (S_OK == hr)
    {
        ExpandEnvironmentStringsIntoTstring (strToExpand.c_str(), pstrValue);
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr),
        "HrRegQueryExpandString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryInfoKey
//
//  Purpose:    Retrieves information about a registry key by calling
//              RegQueryInfoKey.
//
//  Arguments:
//      hkey                  [in]
//      pszClass              [out]
//      pcbClass              [inout]
//      pcSubKeys             [out]
//      pcbMaxSubKeyLen       [out]    See the Win32 documentation for the
//      pcbMaxClassLen        [out]    RegQueryInfoKey function.
//      pcValues              [out]
//      pcbMaxValueNameLen    [out]
//      pcbMaxValueLen        [out]
//      pcbSecurityDescriptor [out]
//      pftLastWriteTime      [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     BillBe   28 Aug 1998
//
//  Notes:      Note that pcbClass is an *in/out* param. Set this to the size
//              of the buffer pointed to by pszClass *before* calling this
//              function!
//
HRESULT
HrRegQueryInfoKey (
    IN HKEY         hkey,
    OUT PWSTR       pszClass,
    IN OUT LPDWORD  pcbClass,
    OUT LPDWORD     pcSubKeys,
    OUT LPDWORD     pcbMaxSubKeyLen,
    OUT LPDWORD     pcbMaxClassLen,
    OUT LPDWORD     pcValues,
    OUT LPDWORD     pcbMaxValueNameLen,
    OUT LPDWORD     pcbMaxValueLen,
    OUT LPDWORD     pcbSecurityDescriptor,
    OUT PFILETIME   pftLastWriteTime)
{
    Assert(hkey);

    LONG lr = RegQueryInfoKeyW(hkey, pszClass, pcbClass, NULL,pcSubKeys,
            pcbMaxSubKeyLen, pcbMaxClassLen, pcValues, pcbMaxValueNameLen,
            pcbMaxValueLen, pcbSecurityDescriptor, pftLastWriteTime);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegQueryInfoKey");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryStringAsUlong
//
//  Purpose:    Reads a REG_SZ from the registry and converts it to a ulong
//              before returning
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      nBase        [in]    The numeric base to convert to
//      pulValue     [out]   The returned converted string if successful.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     billbe   13 Jun 1997
//
//  Notes:
//
//
HRESULT
HrRegQueryStringAsUlong (
    IN HKEY     hkey,
    IN PCWSTR   pszValueName,
    IN int      nBase,
    OUT ULONG*  pulValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (nBase);
    Assert (pulValue);

    // Get the value.
    //
    tstring strValue;
    HRESULT hr = HrRegQueryString (hkey, pszValueName, &strValue);

    if (S_OK == hr)
    {
        // Convert and assign the output parameters.
        PWSTR pszStopString;
        *pulValue = wcstoul (strValue.c_str(), &pszStopString, nBase);
    }
    else
    {
        *pulValue = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryStringAsUlong");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeString
//
//  Purpose:    Query a REG_SZ or REG_EXPAND_SZ value and returns it
//              in a tstring.
//
//  Arguments:
//      hkey         [in]  The parent HKEY of szValueName
//      pszValueName [in]  The name of the value to query.
//      dwType       [in]  REG_SZ or REG_EXPAND_SZ
//      pstr         [out] The returned value.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:      REG_EXPAND_SZ values ARE NOT expanded using
//              ExpandEnvironentStrings.  Use HrRegQueryExpandString instead.
//
HRESULT
HrRegQueryTypeString (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    IN DWORD      dwType,
    OUT tstring*  pstr)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pstr);

    AssertSz ((REG_SZ == dwType) ||
              (REG_EXPAND_SZ == dwType), "Only REG_SZ or REG_EXPAND_SZ "
              "types accepted.");

    BOOL fErase = TRUE;

    // Get size of the data.
    //
    DWORD  dwTypeRet;
    DWORD  cbData = 0;
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwTypeRet,
            NULL, &cbData);

    // Make sure it has the correct type.
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
    }

    if (S_OK == hr)
    {
        // Compute the number of characters in the data including the
        // NULL terminator.  After dividing the number of bytes by
        // the sizeof a WCHAR, add 1 if there is a remainder.  If we didn't,
        // and the number of bytes was not a multiple of the sizeof a WCHAR,
        // we'd come up short because integer division rounds down.
        // (The only time I can think of cbData would not be a multiple
        // of sizeof(WCHAR) is if the registry data were somehow corrupted.
        // It's not that I think corruption deserves a special case, but
        // we shouldn't AV in light of it.)
        //
        DWORD cchIncludingNull;

        cchIncludingNull  = cbData / sizeof(WCHAR);
        if (cbData % sizeof(WCHAR))
        {
            cchIncludingNull++;
        }

        // If we have more than just the terminator, allocate and
        // get the string.  Otherwise, we want it empty.
        //
        if (cchIncludingNull > 1)
        {
            // Reserve room for the correct number of characters.
            // cch is the count of characters without the terminator
            // since that is what tstring operates with.
            //
            DWORD cch = cchIncludingNull - 1;
            Assert (cch > 0);

            // assign will reserve cch characters and set them all to 0.
            // checking capacity afterwards ensures the allocation made
            // internally didn't fail.
            //
            pstr->assign (cch, 0);
            if (cch <= pstr->capacity ())
            {
                hr = HrRegQueryValueEx (hkey, pszValueName, &dwType,
                        (LPBYTE)pstr->data (), &cbData);

                if (S_OK == hr)
                {
                    // If everything went according to plan, the length
                    // of the string should now match what wcslen
                    // returns on the string itself.  The reason it will
                    // match is because we passed cch to assign.
                    //
                    Assert (pstr->length() == (size_t)wcslen (pstr->c_str()));
                    fErase = FALSE;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Empty the output string on failure or if we think it should be
    // empty.
    //
    if (FAILED(hr) || fErase)
    {
        pstr->erase();
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr),
        "HrRegQueryTypeString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeSzBuffer
//
//  Purpose:    Gets a string from the registry using the given buffer. Checks
//              that its type is correct. Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]        The registry key.
//      pszValueName [in]        The name of the value to get.
//      dwType       [in]        Desired type. (REG_SZ, REG_EXPAND_SZ, etc.)
//      szData       [out]       String buffer to hold the data.
//      pcbData      [in,out]    IN: Number of *bytes* in buffer pointed to by
//                              szData. OUT: Number of bytes actually copied
//                              into the buffer.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   3 Apr 1997
//
//  Notes:      If the function fails, the buffer passed in is guaranteed to
//              be an empty string.
//
HRESULT
HrRegQueryTypeSzBuffer (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    OUT PWSTR pszData,
    OUT DWORD* pcbData)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pcbData);

    DWORD dwTypeRet;
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwTypeRet,
            (LPBYTE)pszData, pcbData);

    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        TraceTag (ttidError, "Expected a type of 0x%x for %S.",
            dwType, pszValueName);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
    }

    if (FAILED(hr) && pszData)
    {
        // Make sure empty string is returned on failure.
        //
        *pszData = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryTypeSzBuffer");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueEx
//
//  Purpose:    Retrieves the data from the given registry value by calling
//              RegQueryValueEx.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      pdwType      [out]   See the Win32 documentation for the
//      pbData       [out]   RegQueryValueEx function.
//      pcbData      [in,out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   25 Feb 1997
//
//  Notes:      Note that pcbData is an *in/out* param. Set this to the size
//              of the buffer pointed to by pbData *before* calling this
//              function!
//
HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData)
{
    Assert (hkey);

    AssertSz (FImplies(pbData && pcbData, pdwType),
              "pdwType not provided to HrRegQueryValueEx.  You should be "
              "retrieving the type as well so you can make sure it is "
              "correct.");

    LONG lr = RegQueryValueExW (hkey, pszValueName, NULL, pdwType,
                    pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr,
        (ERROR_MORE_DATA == lr) || (ERROR_FILE_NOT_FOUND == lr),
        "HrRegQueryValueEx (%S)", pszValueName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueWithAlloc
//
//  Purpose:    Retrieve a registry value in a buffer allocated by this
//              function. This goes through the mess of checking the value
//              size, allocating the buffer, and then calling back to get the
//              actual value. Returns the buffer to the user.
//
//  Arguments:
//      hkey         [in]        An open HKEY (the one that contains the value
//                              to be read)
//      pszValueName [in]        Name of the registry value
//      pdwType      [in/out]    The REG_ type that we plan to be reading
//      ppbBuffer    [out]       Pointer to an LPBYTE buffer that will contain
//                              the registry value
//      pdwSize      [out]       Pointer to a DWORD that will contain the size
//                              of the ppbBuffer.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize)
{
    HRESULT hr;
    BYTE abData [256];
    DWORD cbData;
    BOOL fReQuery = FALSE;

    Assert (hkey);
    Assert (pdwType);
    Assert (ppbBuffer);

    // Initialize the output parameters.
    //
    *ppbBuffer = NULL;
    if (pdwSize)
    {
        *pdwSize = 0;
    }

    // Get the size of the data, and if it will fit, the data too.
    //
    cbData = sizeof(abData);
    hr = HrRegQueryValueEx (
            hkey,
            pszValueName,
            pdwType,
            abData,
            &cbData);
    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
    {
        // The data didn't fit, so we'll have to requery for it after
        // we allocate our buffer.
        //
        fReQuery = TRUE;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        // Allocate the buffer for the required size.
        //
        BYTE* pbBuffer = (BYTE*)MemAlloc (cbData);
        if (pbBuffer)
        {
            if (fReQuery)
            {
                hr = HrRegQueryValueEx (
                        hkey,
                        pszValueName,
                        pdwType,
                        pbBuffer,
                        &cbData);
            }
            else
            {
                CopyMemory (pbBuffer, abData, cbData);
            }

            if (S_OK == hr)
            {
                // Fill in the return values.
                //
                *ppbBuffer = pbBuffer;

                if (pdwSize)
                {
                    *pdwSize = cbData;
                }
            }
            else
            {
                MemFree (pbBuffer);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryValueWithAlloc");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncstring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . C P P
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   CbOfSzSafe, CbOfSzaSafe,
//              CbOfSzAndTermSafe, CbOfSzaAndTermSafe
//
//  Purpose:    Count the bytes required to hold a string.  The string
//              may be NULL in which case zero is returned.
//
//  Arguments:
//      psz [in] String to return count of bytes for.
//
//  Returns:    Count of bytes required to store string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      'AndTerm' variants includes space for the null-terminator.
//
ULONG
CbOfSzSafe (
    IN PCWSTR psz)
{
    return (psz) ? CbOfSz(psz) : 0;
}

ULONG
CbOfSzaSafe (
    IN PCSTR psza)
{
    return (psza) ? CbOfSza(psza) : 0;
}

ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz)
{
    return (psz) ? CbOfSzAndTerm(psz) : 0;
}

ULONG
CbOfSzaAndTermSafe (
    IN PCSTR psza)
{
    return (psza) ? CbOfSzaAndTerm(psza) : 0;
}

ULONG
CchOfSzSafe (
    IN PCWSTR psz)
{
    return (psz) ? wcslen(psz) : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwFormatString
//
//  Purpose:    Uses FormatMessage to format a string from variable arguments.
//              The string is formatted into a fixed-size buffer the caller
//              provides.
//              See the description of FormatMessage in the Win32 API.
//
//  Arguments:
//      pszFmt  [in]    pointer to format string
//      pszBuf  [out]   pointer to formatted output
//      cchBuf  [in]    count of characters in pszBuf
//      ...     [in]    replaceable string parameters
//
//  Returns:    the return value of FormatMessage
//
//  Author:     shaunco   15 Apr 1997
//
//  Notes:      The variable arguments must be strings otherwise
//              FormatMessage will barf.
//
DWORD
WINAPIV
DwFormatString (
    IN PCWSTR pszFmt,
    OUT PWSTR  pszBuf,
    IN DWORD   cchBuf,
    IN ...)
{
    Assert (pszFmt);

    va_list val;
    va_start(val, cchBuf);
    DWORD dwRet = FormatMessage (FORMAT_MESSAGE_FROM_STRING,
            pszFmt, 0, 0, pszBuf, cchBuf, &val);
    va_end(val);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwFormatStringWithLocalAlloc
//
//  Purpose:    Uses FormatMessage to format a string from variable arguments.
//              The string is allocated by FormatMessage using LocalAlloc.
//              See the description of FormatMessage in the Win32 API.
//
//  Arguments:
//      pszFmt  [in]    pointer to format string
//      ppszBuf [out]   the returned formatted string
//      ...     [in]    replaceable string parameters
//
//  Returns:    the return value of FormatMessage
//
//  Author:     shaunco   3 May 1997
//
//  Notes:      The variable arguments must be strings otherwise
//              FormatMessage will barf.
//
DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    IN PCWSTR pszFmt,
    OUT PWSTR* ppszBuf,
    IN ...)
{
    Assert (pszFmt);

    va_list val;
    va_start(val, ppszBuf);
    DWORD dwRet = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_STRING,
                                 pszFmt, 0, 0,
                                 (PWSTR)ppszBuf,
                                 0, &val);
    va_end(val);
    return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   FFindStringInCommaSeparatedList
//
//  Purpose:    Given a comma separated list, pszList, and a search string,
//                  pszSubString, this routine will try to locate pszSubString
//                  in the list,
//
//  Arguments:
//      pszSubString   [in]  The string to search for
//      pszList        [in]  The list to search in
//      eIgnoreSpaces [in]  If NC_IGNORE, skip leading and trailing spaces
//                          when comparing.
//                          If NC_DONT_IGNORE, don't skip leading and
//                          trailing spaces.
//      dwPosition    [out] Optional. If found, the position of the first
//                          occurrence of the substring in the list. The first
//                          position is 0.
//
//  Returns:    BOOL. TRUE if pszSubString is in pszList, FALSE otherwise
//
//  Author:     billbe   09 Sep 1997
//
//  Notes:
//
BOOL
FFindStringInCommaSeparatedList (
    IN PCWSTR pszSubString,
    IN PCWSTR pszList,
    IN NC_IGNORE_SPACES eIgnoreSpaces,
    OUT DWORD* pdwPosition)
{

    Assert(pszSubString);
    Assert(pszList);

    int         cchSubString = lstrlenW (pszSubString);
    int         cchList = lstrlenW (pszList);

    BOOL        fFound = FALSE;
    PCWSTR     pszTemp = pszList;
    int         nIndex;
    const WCHAR c_chDelim = L',';

    // Initialize out param if specified.
    if (pdwPosition)
    {
        *pdwPosition = 0;
    }

    // This routine searches the list for a substring matching pszSubString
    // If found, checks are made to ensure the substring is not part of
    // a larger substring.  We continue until we find the substring or we
    // have searched through the entire list.
    //
    while (!fFound)
    {
        // Search for the next occurence of the substring.
        if (pszTemp = wcsstr (pszTemp, pszSubString))
        {
            // we found an occurrence, so now we make sure it is not part of
            // a larger string.
            //

            fFound = TRUE;
            nIndex = (int)(pszTemp - pszList);

            // If the substring was not found at the beginning of the list
            // we check the previous character to ensure it is the delimiter.
            if (nIndex > 0)
            {
                int cchSubtract = 1;

                // If we are to ignore leading spaces, find the first
                // non-space character if there is one.
                //
                if (NC_IGNORE == eIgnoreSpaces)
                {
                    // Keep skipping leading spaces until we either find a
                    // non-space or pass the beginning of the list.
                    while ((L' ' == *(pszTemp - cchSubtract)) &&
                            cchSubtract <= nIndex)
                    {
                        cchSubtract--;
                    }
                }

                // If we haven't passed the beginning of the list, compare the
                // character.
                if (cchSubtract <= nIndex)
                {
                    fFound = (*(pszTemp - cchSubtract) == c_chDelim);
                }
            }

            // If the end of the substring is not the end of the list
            // we check the character after the substring to ensure
            // it is a delimiter.
            if (fFound && ((nIndex + cchSubString) < cchList))
            {
                int cchAdd = cchSubString;

                // If we are ignoring white spaces, we have to check the next
                // available non-space character
                //
                if (NC_IGNORE == eIgnoreSpaces)
                {
                    // Search for a non-space until we find one or pass
                    // the end of the list
                    while ((L' ' == *(pszTemp + cchAdd)) &&
                            (cchAdd + nIndex) < cchList)
                    {
                        cchAdd++;
                    }
                }

                // If we haven't passed the end of the list, check the
                // character
                if (nIndex + cchAdd < cchList)
                {
                    fFound = (*(pszTemp + cchSubString) == c_chDelim);
                }


                if (NC_IGNORE == eIgnoreSpaces)
                {
                    // advance pointer the number of white spaces we skipped
                    // so we won't check those characters on the next pass
                    Assert(cchAdd >= cchSubString);
                    pszTemp += (cchAdd - cchSubString);
                }
            }

            // At this point, if the checks worked out, we found our string
            // and will be exiting the loop
            //

            // Advance the temp pointer the length of the sub string we are
            // searching for so we can search the rest of the list
            // if we need to
            pszTemp += cchSubString;
        }
        else
        {
            // Search string wasn't found
            break;
        }
    }

    // If we found the string and the out param exists,
    // then we need to return the strings position in the list.
    //
    if (fFound && pdwPosition)
    {
        // We will use the number of delimters found before the string
        // as an indicator of the strings position.
        //

        // Start at the beginning
        pszTemp = pszList;
        PWSTR pszDelim;

        // The string is nIndex characters in the list so lets get
        // its correct address.
        PCWSTR pszFoundString = pszList + nIndex;

        // As long as we keep finding a delimiter in the list...
        while (pszDelim = wcschr(pszTemp, c_chDelim))
        {
            // If the delimiter we just found is before our string...
            if (pszDelim < pszFoundString)
            {
                // Increase our position indicator
                ++(*pdwPosition);

                // Move the temp pointer to the next string
                pszTemp = pszDelim + 1;

                continue;
            }

            // The delimiter we just found is located after our
            // found string so get out of the loop.
            break;
        }
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsSubstr
//
//  Purpose:    Case *insensitive* substring search.
//
//  Arguments:
//      pszSubString [in]    Substring to look for.
//      pszString    [in]    String to search in.
//
//  Returns:    TRUE if substring was found, FALSE otherwise.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Allocates temp buffers on stack so they do not need to be
//              freed.
//
BOOL
FIsSubstr (
    IN PCWSTR pszSubString,
    IN PCWSTR pszString)
{
    PWSTR      pszStringUpper;
    PWSTR      pszSubStringUpper;

    Assert(pszString);
    Assert(pszSubString);

#ifndef STACK_ALLOC_DOESNT_WORK
    pszStringUpper = (PWSTR)
        (PvAllocOnStack (CbOfSzAndTerm(pszString)));

    pszSubStringUpper = (PWSTR)
        (PvAllocOnStack (CbOfSzAndTerm(pszSubString)));
#else
    pszStringUpper    = MemAlloc(CbOfSzAndTerm(pszString));
    pszSubStringUpper = MemAlloc(CbOfSzAndTerm(pszSubString));
#endif

    lstrcpyW (pszStringUpper, pszString);
    lstrcpyW (pszSubStringUpper, pszSubString);

    // Convert both strings to uppercase before calling strstr
    CharUpper (pszStringUpper);
    CharUpper (pszSubStringUpper);

#ifndef STACK_ALLOC_DOESNT_WORK
    return NULL != wcsstr(pszStringUpper, pszSubStringUpper);
#else
    BOOL fRet = (NULL != wcsstr (pszStringUpper, pszSubStringUpper));
    MemFree(pszStringUpper);
    MemFree(pszSubStringUpper);

    return fRet;
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToDelimitedSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value.
//
//  Arguments:
//      pszAddString    [in]    The string to add to the delimited psz.
//      pszIn           [in]    The delimited psz list.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '. This will
//                              be used to delimit the value that we add,
//                              as well.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Insert the string as the first element of
//                                  the list.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Insert the string as the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the psz.  If the index specified
//                                  is greater than the number of strings
//                                  in the psz, the string will be
//                                  placed at the end.
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//      pmszOut         [out]   The new delimited psz.
//
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      9 Nov 1998
//              (Extracted from HrRegAddStringToSz and modified)
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrAddStringToDelimitedSz (
    IN PCWSTR pszAddString,
    IN PCWSTR pszIn,
    IN WCHAR chDelimiter,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppszOut)
{
    Assert(pszAddString);
    Assert(ppszOut);

    HRESULT hr = S_OK;

    // Don't continue if the pointers are NULL
    if (!pszAddString || !ppszOut)
    {
        hr =  E_POINTER;
    }

    if (S_OK == hr)
    {
        // Initialize out param
        *ppszOut = NULL;
    }

    BOOL fEnsureAtFront = dwFlags & STRING_FLAG_ENSURE_AT_FRONT;
    BOOL fEnsureAtEnd = dwFlags & STRING_FLAG_ENSURE_AT_END;
    BOOL fEnsureAtIndex = dwFlags & STRING_FLAG_ENSURE_AT_INDEX;

    // Can't specify more than one of these flags
    if ((fEnsureAtFront && fEnsureAtEnd) ||
        (fEnsureAtFront && fEnsureAtIndex) ||
        (fEnsureAtEnd && fEnsureAtIndex))
    {
        AssertSz(FALSE, "Invalid flags in HrAddStringToSz");
        hr = E_INVALIDARG;
    }

    // Have to specify at least one of these
    if (!fEnsureAtFront && !fEnsureAtEnd && !fEnsureAtIndex)
    {
        AssertSz(FALSE, "Must specify a STRING_FLAG_ENSURE flag");
        hr = E_INVALIDARG;
    }


    if (S_OK == hr)
    {
        // Alloc the new blob, including enough space for the trailing comma
        //
        *ppszOut = (PWSTR) MemAlloc (CbOfSzAndTermSafe(pszIn) +
                CbOfSzSafe(pszAddString) + sizeof(WCHAR));

        if (!*ppszOut)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        DWORD dwCurrentIndex = 0; // Current index in the new buffer

        // Prime the new string
        //
        (*ppszOut)[0] = L'\0';

        // If we have the "ensure at front" flag, do so with the passed in
        // value. We also do this if we have the ensure at index flag
        // set with index of 0 or if the ensure at index is set but
        // the input string is null or empty
        //
        if (fEnsureAtFront || (fEnsureAtIndex && (0 == dwStringIndex)) ||
                (fEnsureAtIndex && (!pszIn || !*pszIn)))
        {
            lstrcpyW (*ppszOut, pszAddString);
            ++dwCurrentIndex;
        }

        // If there was a previous value, walk through it and copy as needed.
        // If not, then we're done.
        if (pszIn && *pszIn)
        {
            PCWSTR pszCurrent = pszIn;

            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //

            // Find the first string's end (at the delimiter).
            PCWSTR pszEnd = wcschr (pszCurrent, chDelimiter);

            while (*pszCurrent)
            {
                // If the delimiter didn't exist, set the end to the end of the
                // entire string
                //
                if (!pszEnd)
                {
                    pszEnd = pszCurrent + lstrlenW (pszCurrent);
                }

                LONG lLength = lstrlenW (*ppszOut);
                if (fEnsureAtIndex && (dwCurrentIndex == dwStringIndex))
                {
                    // We know we are not at the first item since
                    // this would mean dwStringIndex is 0 and we would
                    // have copied the string before this point
                    //
                    (*ppszOut)[lLength++] = chDelimiter;
                    (*ppszOut)[lLength++] = L'\0';

                    // Append the string.
                    lstrcatW (*ppszOut, pszAddString);
                    ++dwCurrentIndex;
                }
                else
                {
                    DWORD cch = (DWORD)(pszEnd - pszCurrent);
                    // If we are allowing duplicates or the current string
                    // doesn't match the string we want to add, then we will
                    // copy it.
                    //
                    if ((dwFlags & STRING_FLAG_ALLOW_DUPLICATES) ||
                            (_wcsnicmp (pszCurrent, pszAddString, cch) != 0))
                    {
                        // If we're not the first item, then add the delimiter.
                        //
                        if (lLength > 0)
                        {
                            (*ppszOut)[lLength++] = chDelimiter;
                            (*ppszOut)[lLength++] = L'\0';
                        }

                        // Append the string.
                        wcsncat (*ppszOut, pszCurrent, cch);
                        ++dwCurrentIndex;
                    }

                    // Advance the pointer to one past the end of the current
                    // string unless, the end is not the delimiter but NULL.
                    // In that case, set the current point to equal the end
                    // pointer
                    //
                    pszCurrent = pszEnd + (*pszEnd ? 1 : 0);

                    // If the current pointer is not at the end of the input
                    // string, then find the next delimiter
                    //
                    if (*pszCurrent)
                    {
                        pszEnd = wcschr (pszCurrent, chDelimiter);
                    }
                }
            }
        }

        // If we don't have the "insert at front" flag, then we should insert
        // at the end (this is the same as having the
        // STRING_FLAG_ENSURE_AT_END flag set)
        //
        if (fEnsureAtEnd ||
                (fEnsureAtIndex && (dwCurrentIndex <= dwStringIndex)))
        {
            LONG lLength = lstrlenW (*ppszOut);

            // If we're not the first item, add the delimiter.
            //
            if (lstrlenW (*ppszOut) > 0)
            {
                (*ppszOut)[lLength++] = chDelimiter;
                (*ppszOut)[lLength++] = L'\0';
            }

            // Append the string.
            //
            lstrcatW (*ppszOut, pszAddString);
        }
    }

    TraceError ("HrAddStringToDelimitedSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromDelimitedSz
//
//  Purpose:    Removes a string from a delimited string value
//
//  Arguments:
//      pszRemove  [in] The string to be removed from the multi-sz
//      pszIn      [in] The delimited list to scan for pszRemove
//      cDelimiter [in] The character to be used to delimit the
//                      values. Most multi-valued REG_SZ strings are
//                      delimited with either ',' or ' '.
//      dwFlags    [in] Can contain one or more of the following
//                      values:
//
//                      STRING_FLAG_REMOVE_SINGLE
//                          Don't remove more than one value, if
//                          multiple are present.
//                      STRING_FLAG_REMOVE_ALL
//                          If multiple matching values are present,
//                          remove them all.
//      ppszOut   [out] The string with pszRemove removed. Note
//                      that the output parameter is always set even
//                      if pszRemove did not exist in the list.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      10 Nov 1998
//              (Extracted from HrRegAddStringToSz and modified)
//
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRemoveStringFromDelimitedSz(
    IN PCWSTR pszRemove,
    IN PCWSTR pszIn,
    IN WCHAR chDelimiter,
    IN DWORD dwFlags,
    OUT PWSTR* ppszOut)
{

    Assert(pszIn && *pszIn);
    Assert(ppszOut);

    HRESULT hr = S_OK;

    // If the out param is not specified, get out
    if (!ppszOut)
    {
        return E_INVALIDARG;
    }

    // Alloc the new blob
    //
    hr = E_OUTOFMEMORY;
    *ppszOut = (PWSTR) MemAlloc (CbOfSzAndTermSafe (pszIn));

    if (*ppszOut)
    {
        hr = S_OK;
        // Prime the new string
        //
        (*ppszOut)[0] = L'\0';

        // If there was a previous value, walk through it and copy as needed.
        // If not, then we're done
        //
        if (pszIn)
        {
            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //
            PCWSTR pszCurrent = pszIn;

            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //

            // Find the first string's end (at the delimiter).
            PCWSTR pszEnd = wcschr (pszCurrent, chDelimiter);

            // Keep track of how many instances have been removed.
            DWORD   dwNumRemoved    = 0;

            while (*pszCurrent)
            {
                // If the delimiter didn't exist, set the end to the end of
                // the entire string.
                //
                if (!pszEnd)
                {
                    pszEnd = pszCurrent + lstrlenW (pszCurrent);
                }

                DWORD cch = (DWORD)(pszEnd - pszCurrent);
                INT iCompare;
                // If we have a match, and we want to remove it (meaning that
                // if we have the remove-single set, that we haven't removed
                // one already).

                iCompare = _wcsnicmp (pszCurrent, pszRemove, cch);

                if ((iCompare) ||
                    ((dwFlags & STRING_FLAG_REMOVE_SINGLE) &&
                     (dwNumRemoved > 0)))
                {
                    LONG lLength = lstrlenW (*ppszOut);

                    // If we're not the first item, then add the delimiter.
                    //
                    if (lLength > 0)
                    {
                        (*ppszOut)[lLength++] = chDelimiter;
                        (*ppszOut)[lLength++] = L'\0';
                    }

                    // Append the string.
                    wcsncat (*ppszOut, pszCurrent, cch);
                }
                else
                {
                    dwNumRemoved++;
                }

                // Advance the pointer to one past the end of the current
                // string unless, the end is not the delimiter but NULL.
                // In that case, set the current point to equal the end
                // pointer
                //
                pszCurrent = pszEnd + (*pszEnd ? 1 : 0);

                // If the current pointer is not at the end of the input
                // string, then find the next delimiter
                //
                if (*pszCurrent)
                {
                    pszEnd = wcschr (pszCurrent, chDelimiter);
                }
            }
        }
    }

    TraceError("HrRemoveStringFromDelimitedSz", hr);
    return hr;
}

PWSTR
PszAllocateAndCopyPsz (
    IN PCWSTR pszSrc)
{
    if (!pszSrc)
    {
        return NULL;
    }

    ULONG cb = (wcslen (pszSrc) + 1) * sizeof(WCHAR);
    PWSTR psz = (PWSTR)MemAlloc (cb);
    if (psz)
    {
        CopyMemory (psz, pszSrc, cb);
    }

    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadStringPcch
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//      pcch  [out] Pointer to returned character length.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      The loaded string is pointer directly into the read-only
//              resource section.  Any attempt to write through this pointer
//              will generate an access violation.
//
//              The implementations is referenced from "Win32 Binary Resource
//              Formats" (MSDN) 4.8 String Table Resources
//
//              User must have RCOPTIONS = -N turned on in your sources file.
//
PCWSTR
SzLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch)
{
    Assert(hinst);
    Assert(unId);
    Assert(pcch);

    static const WCHAR c_szSpace[] = L" ";

    PCWSTR psz = c_szSpace;
    int    cch = 1;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    HRSRC hrsrcInfo = FindResource (hinst,
                        (PWSTR)ULongToPtr( ((LONG)(((USHORT)unId >> 4) + 1)) ),
                        RT_STRING);
    if (hrsrcInfo)
    {
        // Page the resource segment into memory.
        HGLOBAL hglbSeg = LoadResource (hinst, hrsrcInfo);
        if (hglbSeg)
        {
            // Lock the resource.
            psz = (PCWSTR)LockResource(hglbSeg);
            if (psz)
            {
                // Move past the other strings in this segment.
                // (16 strings in a segment -> & 0x0F)
                unId &= 0x0F;

                cch = 0;
                do
                {
                    psz += cch;                // Step to start of next string
                    cch = *((WCHAR*)psz++);    // PASCAL like string count
                }
                while (unId--);

                // If we have a non-zero count, it includes the
                // null-terminiator.  Subtract this off for the return value.
                //
                if (cch)
                {
                    cch--;
                }
                else
                {
                    AssertSz(0, "String resource not found");
                    psz = c_szSpace;
                    cch = 1;
                }
            }
            else
            {
                psz = c_szSpace;
                cch = 1;
                TraceLastWin32Error("SzLoadStringPcch: LockResource failed.");
            }
        }
        else
            TraceLastWin32Error("SzLoadStringPcch: LoadResource failed.");
    }
    else
        TraceLastWin32Error("SzLoadStringPcch: FindResource failed.");

    *pcch = cch;
    Assert(*pcch);
    Assert(psz);
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzaDupSza
//
//  Purpose:    Duplicates a string
//
//  Arguments:
//      pszaSrc [in]  string to be duplicated
//
//  Returns:    Pointer to the new copy of the string
//
//  Author:     CWill   25 Mar 1997
//
//  Notes:      The string return must be freed (MemFree).
//
PSTR
SzaDupSza (
        PCSTR pszaSrc)
{
    AssertSz(pszaSrc, "Invalid source string");

    PSTR  pszaDst;
    pszaDst = (PSTR) MemAlloc (CbOfSzaAndTerm(pszaSrc));

    if(pszaDst) lstrcpyA(pszaDst, pszaSrc);

    return pszaDst;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzDupSz
//
//  Purpose:    Duplicates a string
//
//  Arguments:
//      pszSrc [in]  string to be duplicated
//
//  Returns:    Pointer to the new copy of the string
//
//  Author:     CWill   25 Mar 1997
//
//  Notes:      The string return must be freed.
//
PWSTR
SzDupSz (
    IN PCWSTR pszSrc)
{
    AssertSz(pszSrc, "Invalid source string");

    PWSTR   pszDst;
    pszDst = (PWSTR) MemAlloc (CbOfSzAndTerm(pszSrc));
    if(pszDst) lstrcpyW (pszDst, pszSrc);

    return pszDst;
}

BOOL
FSubstringMatch (
    PCTSTR          pStr1,
    PCTSTR          pStr2,
    const WCHAR**   ppStart,
    ULONG*          pcch)
{
    const WCHAR*    p1Start;
    const WCHAR*    p1End;
    const WCHAR*    p2Start;
    const WCHAR*    p2End;
    ULONG           cch1;
    ULONG           cch2;

    if (ppStart)
    {
        *ppStart = NULL;
    }
    if (pcch)
    {
        *pcch = NULL;
    }

    p1End = pStr1;
    while (1)
    {
        GetNextCommaSeparatedToken(p1Start, p1End, cch1);
        if (!cch1)
        {
            break;
        }

        p2End = pStr2;
        while (1)
        {
            GetNextCommaSeparatedToken(p2Start, p2End, cch2);
            if (!cch2)
            {
                break;
            }

            if (cch1 == cch2)
            {
                if (0 == memcmp(p1Start, p2Start, cch1 * sizeof(WCHAR)))
                {
                    if (ppStart)
                    {
                        *ppStart = p1Start;
                    }
                    if (pcch)
                    {
                        *pcch = cch1;
                    }

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

VOID
DeleteColString (
     list<tstring*>* pcolstr)
{
    Assert( pcolstr );

    list<tstring*>::const_iterator iter;
    tstring* pstr;

    for (iter = pcolstr->begin(); iter != pcolstr->end(); iter++)
    {
        pstr = *iter;
        delete pstr;
    }
    pcolstr->erase( pcolstr->begin(), pcolstr->end() );
}

VOID
DeleteColString (
     vector<tstring*>* pcolstr)
{
    Assert( pcolstr );

    vector<tstring*>::const_iterator iter;
    tstring* pstr;

    for (iter = pcolstr->begin(); iter != pcolstr->end(); iter++)
    {
        pstr = *iter;
        delete pstr;
    }
    pcolstr->erase( pcolstr->begin(), pcolstr->end() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncsetup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S E T U P . C P P
//
//  Contents:   HRESULT wrappers for the Setup Api.
//
//  Notes:
//
//  Author:     shaunco   16 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncsetup.h"
#include "ncbase.h"
#include "ncmem.h"
#include "ncstring.h"
#include "ncperms.h"
#include "ncmisc.h"
#include <swenum.h>

extern const WCHAR c_szNo[];
extern const WCHAR c_szYes[];

// dwFieldIndex parameter for the first field.  Fields indexes are 1 based
// in Setup Api.
//
const DWORD c_dwFirstField = 1;

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupCommitFileQueue
//
//  Purpose:    Initializes the context used by the default queue callback
//                  routine included with the Setup API in the same manner
//                  as SetupInitDefaultQueueCallback, except that an
//                  additional window is provided to the callback function
//                  to accept progress messages.
//
//  Arguments:
//      hwndOwner   [in] See SetupApi for information
//      hfq         [in]
//      pfc         [in]
//      pvCtx       [in]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:
//
HRESULT HrSetupCommitFileQueue(HWND hwndOwner, HSPFILEQ hfq,
                               PSP_FILE_CALLBACK pfc, PVOID pvCtx)
{
    Assert(hfq);
    Assert(INVALID_HANDLE_VALUE != hfq);
    Assert(pfc);
    Assert(pvCtx);

    HRESULT hr = S_OK;

    // Try to commit the queue
    if (!SetupCommitFileQueue(hwndOwner, hfq, pfc, pvCtx))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError ("HrSetupCommitFileQueue", (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupInitDefaultQueueCallbackEx
//
//  Purpose:    Initializes the context used by the default queue callback
//                  routine included with the Setup API in the same manner
//                  as SetupInitDefaultQueueCallback, except that an
//                  additional window is provided to the callback function
//                  to accept progress messages.
//
//  Arguments:
//      hwndOwner       [in] See SetupApi for information
//      hwndAlternate   [in]
//      uMsg            [in]
//      dwReserved1     [in]
//      dwReserved2     [in]
//      ppvCtx          [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:
//
HRESULT HrSetupInitDefaultQueueCallbackEx(HWND hwndOwner, HWND hwndAlternate,
                                          UINT uMsg, DWORD dwReserved1,
                                          PVOID pvReserved2, PVOID* ppvCtx)
{
    Assert(ppvCtx);

    // Try to init default queue callback.
    //
    HRESULT hr;
    PVOID pvCtx = SetupInitDefaultQueueCallbackEx(hwndOwner, hwndAlternate,
            uMsg, dwReserved1, pvReserved2);


    if (pvCtx)
    {
        hr = S_OK;
        *ppvCtx = pvCtx;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *ppvCtx = NULL;
    }

    TraceError ("HrSetupInitDefaultQueueCallbackEx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupOpenFileQueue
//
//  Purpose:    Creates a setup file queue.
//
//  Arguments:
//      phfq [out] See SetupApi for information
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:
//
HRESULT HrSetupOpenFileQueue(HSPFILEQ* phfq)
{
    Assert(phfq);
    // Try to open the file queue.
    //
    HRESULT hr;
    HSPFILEQ hfq = SetupOpenFileQueue();
    if (INVALID_HANDLE_VALUE != hfq)
    {
        hr = S_OK;
        *phfq = hfq;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *phfq = NULL;
    }
    TraceError ("HrSetupOpenFileQueue", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupOpenInfFile
//
//  Purpose:    Open an INF file.
//
//  Arguments:
//      pszFileName  [in]   See the Setup API documentation.
//      pszInfClass  [in]
//      dwInfStyle   [in]
//      punErrorLine [out]
//      phinf        [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupOpenInfFile (
    PCWSTR pszFileName,
    PCWSTR pszInfClass,
    DWORD dwInfStyle,
    UINT* punErrorLine,
    HINF* phinf)
{
    HRESULT hr;
    HINF hinf;

    Assert (pszFileName);
    Assert (phinf);

    // Try to open the file.
    //
    hinf = SetupOpenInfFile (pszFileName, pszInfClass,
                                  dwInfStyle, punErrorLine);
    if (INVALID_HANDLE_VALUE != hinf)
    {
        hr = S_OK;
        *phinf = hinf;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *phinf = NULL;
        if (punErrorLine)
        {
            *punErrorLine = 0;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrSetupOpenInfFile (%S)", pszFileName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindFirstLine
//
//  Purpose:    Find the first line in an INF file with a matching section
//              and key.
//
//  Arguments:
//      hinf       [in]     See the Setup API documentation.
//      pszSection [in]
//      pszKey     [in]
//      pctx       [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupFindFirstLine (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT INFCONTEXT* pctx)
{
    Assert (hinf);
    Assert (pszSection);
    Assert (pctx);

    HRESULT hr;
    if (SetupFindFirstLine (hinf, pszSection, pszKey, pctx))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
    }
    TraceErrorOptional ("HrSetupFindFirstLine", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindNextLine
//
//  Purpose:    Find the next line in an INF file relative to ctxIn.
//
//  Arguments:
//      ctxIn   [in]    See the Setup API documentation.
//      pctxOut [out]
//
//  Returns:    S_OK if successful, S_FALSE if there are no more lines, or a
//              Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupFindNextLine (const INFCONTEXT& ctxIn, INFCONTEXT* pctxOut)
{
    Assert (pctxOut);

    HRESULT hr;
    if (SetupFindNextLine (const_cast<PINFCONTEXT>(&ctxIn), pctxOut))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // Translate ERROR_LINE_NOT_FOUND into S_FALSE
            hr = S_FALSE;
        }
    }
    TraceError ("HrSetupFindNextLine", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindNextMatchLine
//
//  Purpose:    Find the next line in an INF file relative to ctxIn and
//              matching an optional key.
//
//  Arguments:
//      ctxIn   [in]    See the Setup API documentation.
//      pszKey  [in]
//      pctxOut [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupFindNextMatchLine (
    IN const INFCONTEXT& ctxIn,
    IN PCWSTR pszKey,
    OUT INFCONTEXT* pctxOut)
{
    Assert (pctxOut);

    HRESULT hr;
    if (SetupFindNextMatchLine ((PINFCONTEXT)&ctxIn, pszKey, pctxOut))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error();
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // Translate ERROR_LINE_NOT_FOUND into S_FALSE
            hr = S_FALSE;
        }
    }
    TraceError ("HrSetupFindNextMatchLine", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetLineByIndex
//
//  Purpose:    Locates a line in an INF file by its index value in the
//              specified section.
//
//  Arguments:
//      hinf       [in]     See the Setup API documentation.
//      pszSection [in]
//      dwIndex    [in]
//      pctx       [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetLineByIndex (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN DWORD dwIndex,
    OUT INFCONTEXT* pctx)
{
    Assert (pszSection);
    Assert (pctx);

    HRESULT hr;
    if (SetupGetLineByIndex (hinf, pszSection, dwIndex, pctx))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
    }
    TraceError ("HrSetupGetLineByIndex", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetLineCount
//
//  Purpose:    Get the number of lines in the specified section on an
//              INF file.
//
//  Arguments:
//      hinf       [in]     See the Setup API documentation.
//      pszSection [in]
//      pulCount   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetLineCount (
    IN HINF hinf,
    IN PCWSTR pszSection,
    OUT ULONG* pulCount)
{
    Assert (pszSection);
    Assert (pulCount);

    HRESULT hr;
    LONG lCount = SetupGetLineCount (hinf, pszSection);
    if (-1 != lCount)
    {
        *pulCount = lCount;
        hr = S_OK;
    }
    else
    {
        *pulCount = 0;
        hr = HrFromLastWin32Error ();
    }
    TraceError ("HrSetupGetLineCount", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetBinaryField
//
//  Purpose:    Gets a binary value from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pbBuf        [out]
//      cbBuf        [in]
//      pbRequired   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetBinaryField (
    IN const INFCONTEXT& ctx,
    IN DWORD dwFieldIndex,
    OUT BYTE* pbBuf,
    IN DWORD cbBuf,
    OUT DWORD* pbRequired)
{
    HRESULT hr;
    if (SetupGetBinaryField ((PINFCONTEXT)&ctx, dwFieldIndex, pbBuf,
            cbBuf, pbRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (pbBuf)
        {
            *pbBuf = 0;
        }
        if (pbRequired)
        {
            *pbRequired = 0;
        }
    }
    TraceError ("HrSetupGetBinaryField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetIntField
//
//  Purpose:    Gets an integer value from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pnValue      [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetIntField (
    IN const INFCONTEXT& ctx,
    IN DWORD dwFieldIndex,
    OUT INT* pnValue)
{
    Assert (pnValue);

    HRESULT hr;
    if (SetupGetIntField (const_cast<PINFCONTEXT>(&ctx),
                            dwFieldIndex, pnValue))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *pnValue = 0;
    }
    TraceError ("HrSetupGetIntField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetMultiSzField
//
//  Purpose:    Gets a multi-sz value from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pszBuf       [out]
//      cchBuf       [in]
//      pcchRequired [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetMultiSzField (
    const INFCONTEXT& ctx,
    DWORD dwFieldIndex,
    PWSTR pszBuf,
    DWORD cchBuf,
    DWORD* pcchRequired)
{
    HRESULT hr;
    if (SetupGetMultiSzField (const_cast<PINFCONTEXT>(&ctx),
                                dwFieldIndex, pszBuf, cchBuf, pcchRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (pszBuf)
        {
            *pszBuf = 0;
        }
        if (pcchRequired)
        {
            *pcchRequired = 0;
        }
    }
    TraceError ("HrSetupGetMultiSzField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetMultiSzFieldWithAlloc
//
//  Purpose:    Gets a multi-sz value from an INF field.  Allocates space for
//              it automatically.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      ppszBuf      [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:      Free the returned multi-sz with MemFree.
//
HRESULT HrSetupGetMultiSzFieldWithAlloc (
    const INFCONTEXT& ctx,
    DWORD dwFieldIndex,
    PWSTR* ppszBuf)
{
    Assert (ppszBuf);

    // Initialize the output parameter.
    *ppszBuf = NULL;

    // First, get the size required.
    //
    HRESULT hr;
    DWORD cchRequired;

    hr = HrSetupGetMultiSzField (ctx, dwFieldIndex, NULL, 0, &cchRequired);
    if (S_OK == hr)
    {
        // Allocate the buffer.
        //
        PWSTR pszBuf = (PWSTR)MemAlloc(cchRequired * sizeof(WCHAR));
        if (pszBuf)
        {
            // Now fill the buffer.
            //
            hr = HrSetupGetMultiSzField (ctx, dwFieldIndex, pszBuf,
                    cchRequired, NULL);
            if (S_OK == hr)
            {
                *ppszBuf = pszBuf;
            }
            else
            {
                MemFree (pszBuf);
            }
        }
    }
    TraceError ("HrSetupGetMultiSzFieldWithAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringField
//
//  Purpose:    Gets a string from an INF field.  Returns it as a tstring.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pstr         [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupGetStringField (const INFCONTEXT& ctx,
                               DWORD dwFieldIndex,
                               tstring* pstr)
{
    Assert (pstr);

    // First, get the size required.
    //
    DWORD cchRequired = 0;
    HRESULT hr = HrSetupGetStringField (ctx, dwFieldIndex, NULL, 0, &cchRequired);

    // 412390: workaround for bug in NT4 SETUPAPI.dll 
    //
    if ((S_OK == hr) && (0 == cchRequired))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if (S_OK == hr)
    {
        // Allocate a buffer on the stack.
        //
        PWSTR pszBuf;
        pszBuf = (PWSTR)PvAllocOnStack(cchRequired * sizeof(WCHAR));

        // Now fill the buffer.
        //
        hr = HrSetupGetStringField (ctx, dwFieldIndex, pszBuf, cchRequired, NULL);
        if (S_OK == hr)
        {
            *pstr = pszBuf;
        }
    }
    // If we failed for any reason, initialize the output parameter.
    //
    if (FAILED(hr))
    {
        pstr->erase ();
    }
    TraceError ("HrSetupGetStringField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringField
//
//  Purpose:    Gets a string from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pszBuf       [out]
//      cchBuf       [in]
//      pcchRequired [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupGetStringField (
    IN const INFCONTEXT& ctx,
    IN DWORD dwFieldIndex,
    OUT PWSTR pszBuf,
    IN DWORD cchBuf,
    OUT DWORD* pcchRequired)
{
    HRESULT hr;
    if (SetupGetStringField ((PINFCONTEXT)&ctx, dwFieldIndex, pszBuf,
            cchBuf, pcchRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();

        if (pszBuf)
        {
            *pszBuf = 0;
        }
        if (pcchRequired)
        {
            *pcchRequired = 0;
        }
    }
    TraceError ("HrSetupGetStringField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupScanFileQueueWithNoCallback
//
//  Purpose:    Scans a setup file queue, performing an operation on each node
//                  in its copy list. The operation is specified by a set of
//                  flags. This function can be called either before or after
//                  the queue has been committed.
//
//  Arguments:
//      hfq         [in] See SetupApi for information
//      dwFlags     [in]
//      hwnd        [in]
//      pdwResult   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:      This differs from the SetupApi version in that no callback
//                  can be specified through this wrapper.  This is because
//                  errors from the callback cannot not be reliably mapped
//                  to an HRESULT.  If a user defined callback is needed,
//                  the original SetupApi function must be used.
//
HRESULT HrSetupScanFileQueueWithNoCallback(HSPFILEQ hfq, DWORD dwFlags,
                                           HWND hwnd, PDWORD pdwResult)
{
    Assert(hfq);
    Assert(INVALID_HANDLE_VALUE != hfq);
    Assert(pdwResult);

    HRESULT hr = S_OK;

    // Scan the given queue
    if (!SetupScanFileQueue(hfq, dwFlags, hwnd, NULL, NULL, pdwResult))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError ("HrSetupScanFileQueueWithNoCallback", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetMultiSzFieldMapToDword
//
//  Purpose:    Gets the values represented as mult-sz in an INF
//              and returns the value as a DWORD of bit flags.
//              The mapping is specified by the caller through an array of
//              pointers to string values and their associated DWORD values.
//
//              Example: The value in the INF might be "Ip,Ipx,Nbf".
//              This function can map these values to the DWORD
//              representation of FLAG_IP | FLAG_IPX | FLAG_NBF.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:      _wcsicmp is used to make the string comparisons.
//
HRESULT HrSetupGetMultiSzFieldMapToDword (const INFCONTEXT& ctx,
                                          DWORD dwFieldIndex,
                                          const MAP_SZ_DWORD* aMapSzDword,
                                          UINT cMapSzDword,
                                          DWORD* pdwValue)
{
    Assert (aMapSzDword);
    Assert (cMapSzDword);
    Assert (pdwValue);

    // Initialize the output parameter.
    *pdwValue = 0;

    // Get the multi-sz value.
    //
    HRESULT hr;
    PWSTR pszBuf;

    hr = HrSetupGetMultiSzFieldWithAlloc (ctx, dwFieldIndex, &pszBuf);
    if (S_OK == hr)
    {
        DWORD dwValue = 0;

        // Map each value in the multi-sz to a DWORD and OR it into
        // the result.
        for (PCWSTR pszValue = pszBuf;  *pszValue;
             pszValue += lstrlenW (pszValue) + 1)
        {
            // Search the map for a matching value.  When found, update
            // dwValue.
            for (UINT i = 0; i < cMapSzDword; i++)
            {
                if (0 == lstrcmpiW (aMapSzDword[i].pszValue, pszValue))
                {
                    dwValue |= aMapSzDword[i].dwValue;
                    break;
                }
            }
        }

        // Assign the output parameter.
        *pdwValue = dwValue;

        MemFree (pszBuf);
    }
    TraceError ("HrSetupGetMultiSzFieldMapToDword", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringFieldMapToDword
//
//  Purpose:    Gets a value represented as multiple strings in an INF
//              and returns it as a DWORD.  The mapping is specified
//              by the caller through an array of pointers to string
//              values and their associated DWORD values.
//
//              Example: Values in the INF might be "Yes" or "No".
//              This function can map these values to DWORD representations
//              of "1" and "0" respectively.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK if a match was found.  If a match wasn't found,
//              HRESULT_FROM_WIN32(ERROR_INVALID_DATA) is returned.
//              Other Win32 error codes.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:      lstrcmpiW is used to make the string comparisons.
//
HRESULT HrSetupGetStringFieldMapToDword  (const INFCONTEXT& ctx,
                                          DWORD dwFieldIndex,
                                          const MAP_SZ_DWORD* aMapSzDword,
                                          UINT cMapSzDword,
                                          DWORD* pdwValue)
{
    Assert (aMapSzDword);
    Assert (cMapSzDword);
    Assert (pdwValue);

    // Initialize the output parameter.
    *pdwValue = 0;

    // Get the string value.
    //
    tstring strValue;
    HRESULT hr = HrSetupGetStringField (ctx, dwFieldIndex, &strValue);
    if (SUCCEEDED(hr))
    {
        // Search the map for a matching value.  When found, pass
        // the DWORD value out.
        // If the none of the strings matched, we'll return
        // an invalid data error code.
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATA);
        while (cMapSzDword--)
        {
            if (0 == lstrcmpiW (aMapSzDword->pszValue, strValue.c_str()))
            {
                *pdwValue = aMapSzDword->dwValue;
                hr = S_OK;
                break;
            }
            aMapSzDword++;
        }
    }
    TraceError ("HrSetupGetStringFieldMapToDword", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringFieldAsBool
//
//  Purpose:    Gets the value of a boolean field represented as the
//              strings "Yes" and "No" in an INF file.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pfValue      [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupGetStringFieldAsBool (const INFCONTEXT& ctx,
                                     DWORD dwFieldIndex,
                                     BOOL* pfValue)
{
    Assert (pfValue);

    // Initialize the output parameter.
    *pfValue = FALSE;

    static const MAP_SZ_DWORD aMapYesNo [] =
    {
        { c_szYes, TRUE  },
        { c_szNo,  FALSE },
    };
    DWORD dwValue;
    HRESULT hr = HrSetupGetStringFieldMapToDword (ctx, dwFieldIndex,
                                                  aMapYesNo, celems(aMapYesNo),
                                                  &dwValue);
    if (SUCCEEDED(hr))
    {
        *pfValue = !!dwValue;
    }
    TraceError ("HrSetupGetStringFieldAsBool", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstDword
//
//  Purpose:    Get a DWORD value from a section in the INF file.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pdwValue   [out]    the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetFirstDword (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT DWORD* pdwValue)
{
    Assert (pszSection);
    Assert (pszKey);

    // Initialize the output parameter.
    *pdwValue = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        INT nValue;
        hr = HrSetupGetIntField (ctx, c_dwFirstField, &nValue);
        if (S_OK == hr)
        {
            *pdwValue = nValue;
        }
    }
    TraceErrorOptional ("HrSetupGetFirstDword", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstString
//
//  Purpose:    Get a string value from a section in the INF file.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pdwValue   [out]    the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetFirstString (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT tstring* pstr)
{
    Assert (pszSection);
    Assert (pszKey);

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringField (ctx, c_dwFirstField, pstr);
    }
    // If we failed for any reason, initialize the output parameter.
    //
    if (FAILED(hr))
    {
        pstr->erase ();
    }
    TraceErrorOptional ("HrSetupGetFirstString", hr,
                        (SPAPI_E_SECTION_NOT_FOUND == hr) ||
                        (SPAPI_E_LINE_NOT_FOUND    == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstMultiSzFieldWithAlloc
//
//  Purpose:    Retrieves the first occurrance of the given key in the given
//              section of an INF file, allocates memory for it, and returns
//              it in the parameter pszOut.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pszOut     [out]    Returns multi-sz field.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     danielwe   7 May 1997
//
//  Notes:      Free the resulting string with MemFree.
//
HRESULT
HrSetupGetFirstMultiSzFieldWithAlloc (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT PWSTR* ppszOut)
{
    Assert(pszSection);
    Assert(pszKey);
    Assert(ppszOut);

    // Initialize the output parameter.
    *ppszOut = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetMultiSzFieldWithAlloc(ctx, c_dwFirstField, ppszOut);
    }

    TraceErrorOptional("HrSetupGetFirstMultiSzFieldWithAlloc", hr,
                       (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstMultiSzMapToDword
//
//  Purpose:    Get a DWORD value from a section in the INF file.
//              The value is represented in the INF file as a multi-sz, but
//              it is mapped to a DWORD value based on a caller-specified
//              mapping.  The string values in the map are compared using
//              a case insensitive compare.
//
//              Use this when the INF value can be one or more of a fixed
//              set of values represented as strings.
//
//  Example:    [MySection]             with a map of:
//              MyKey = Ip,Nbf            { "Ip",   0x01 }
//                                        { "Ipx",  0x02 }
//                                        { "Nbf",  0x04 }
//
//                  yields *pdwValue returned as 0x01 | 0x04 = 0x05.
//
//  Arguments:
//      hinf         [in]   handle to an open INF file.
//      pszSection   [in]   specifies the section that contains the value.
//      pszKey       [in]   specifies the key that contains the value.
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:      HrOpen must have been called before this call.
//
HRESULT
HrSetupGetFirstMultiSzMapToDword (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    IN const MAP_SZ_DWORD* aMapSzDword,
    IN UINT cMapSzDword,
    OUT DWORD* pdwValue)
{
    Assert (pszSection);
    Assert (pszKey);

    // Initialize the output parameter.
    *pdwValue = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetMultiSzFieldMapToDword (ctx, c_dwFirstField,
                                               aMapSzDword, cMapSzDword,
                                               pdwValue);
    }
    TraceErrorOptional ("HrSetupGetFirstMultiSzMapToDword", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrSetupGetFirstStringMapToDword
//
//  Purpose:    Get a DWORD value from a section in the INF file.
//              The value is represented in the INF file as a string, but
//              it is mapped to a DWORD value based on a caller-specified
//              mapping.  The string values in the map are compared using
//              a case insensitive compare.
//
//              Use this when the INF value can be one of a fixed set of
//              values represented as strings.
//
//  Example:    [MySection]             with a map of:
//              MyKey = ThisComputer      { "Network",      1 }
//                                        { "ThisComputer", 2 }
//
//                  yields *pdwValue returned as 2.
//
//  Arguments:
//      hinf         [in]   handle to an open INF file.
//      pszSection   [in]   specifies the section that contains the value.
//      pszKey       [in]   specifies the key that contains the value.
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:      HrOpen must have been called before this call.
//
HRESULT
HrSetupGetFirstStringMapToDword (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    IN const MAP_SZ_DWORD* aMapSzDword,
    IN UINT cMapSzDword,
    OUT DWORD* pdwValue)
{
    Assert (pszSection);
    Assert (pszKey);

    // Initialize the output parameter.
    *pdwValue = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringFieldMapToDword (ctx, c_dwFirstField,
                                              aMapSzDword, cMapSzDword,
                                              pdwValue);
    }
    TraceErrorOptional ("HrSetupGetFirstStringMapToDword", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstStringAsBool
//
//  Purpose:    Get a boolean value from a section in the INF file.
//              The boolean value is represented in the INF file as
//              "Yes" or "No" (case insensitive) but the value is returned
//              as a BOOL type.
//
//  Example:    [MySection]
//              MyKey = yes
//
//                  yields *pfValue returned as TRUE.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pdwValue   [out]    the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetFirstStringAsBool (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT BOOL* pfValue)
{
    Assert (hinf);
    Assert (pszSection);
    Assert (pszKey);
    Assert (pfValue);

    // Initialize the output parameter.
    *pfValue = FALSE;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringFieldAsBool (ctx, c_dwFirstField, pfValue);
    }
    TraceErrorOptional ("HrSetupGetFirstStringAsBool", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetInfInformation
//
//  Purpose:    Returns the SP_INF_INFORMATION structure for the specified
//              INF file to a caller-supplied buffer.
//
//  Arguments:
//      pvInfSpec       [in] See SetupApi documentation for more info
//      dwSearchControl [in]
//      ppinfInfo       [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     BillBe   18 Jan 1998
//
//  Notes:
//
HRESULT
HrSetupGetInfInformation (
    IN LPCVOID pvInfSpec,
    IN DWORD dwSearchControl,
    OUT PSP_INF_INFORMATION* ppinfInfo)
{
    DWORD dwSize;
    BOOL  fSuccess;

    *ppinfInfo = NULL;

    if (fSuccess = SetupGetInfInformation (pvInfSpec, dwSearchControl,
            NULL, 0, &dwSize))
    {
        *ppinfInfo = (PSP_INF_INFORMATION)MemAlloc (dwSize);
        fSuccess = SetupGetInfInformation (pvInfSpec, dwSearchControl,
                *ppinfInfo, dwSize, 0);
    }

    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
        MemFree (*ppinfInfo);
        *ppinfInfo = NULL;
    }

    TraceError("HrSetupGetInfInformation", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupIsValidNt5Inf
//
//  Purpose:    Determines if an inf file is a valid NT5 inf by examining
//              its signature.
//
//  Arguments:
//      hinf [in] Handle to the inf file
//
//  Returns:    S_OK if valid, SPAPI_E_WRONG_INF_STYLE if invalid,
//              or a Win32 error code.
//
//  Author:     BillBe   18 Jan 1998
//
//  Notes:  $WINDOWS 95$ is invalid and $CHICAGO$ is
//              only valid if it has the required Compatible inf key in
//              the version info.
//
HRESULT
HrSetupIsValidNt5Inf (
    IN HINF hinf)
{
    static const WCHAR c_szSignature[] = INFSTR_KEY_SIGNATURE;
    static const WCHAR c_szCompatible[] = L"Compatible";
    static const WCHAR c_szChicagoSig[] = L"$Chicago$";
    static const WCHAR c_szWinntSig[] = L"$Windows NT$";
    static const WCHAR c_szCompatibleValue[] = L"1";

    PSP_INF_INFORMATION pinfInfo;

    // Get the inf's version info
    HRESULT hr = HrSetupGetInfInformation (hinf, INFINFO_INF_SPEC_IS_HINF,
            &pinfInfo);

    if (S_OK == hr)
    {
        PWSTR pszSignature;

        // Get the signature info
        hr = HrSetupQueryInfVersionInformation (pinfInfo, 0,
                c_szSignature, &pszSignature);

        if (S_OK == hr)
        {

            // if the inf signature is not windows nt...
            if (0 != lstrcmpiW (pszSignature, c_szWinntSig))
            {
                // if it isn't Chicago, then we don't support it
                if (0 != lstrcmpiW (pszSignature, c_szChicagoSig))
                {
                    hr = SPAPI_E_WRONG_INF_STYLE;
                }
                else
                {
                    // The signature is Chicago so now we check if
                    // the compatible line exists.
                    //
                    PWSTR pszCompatible;
                    hr = HrSetupQueryInfVersionInformation (pinfInfo, 0,
                            c_szCompatible, &pszCompatible);

                    if (S_OK == hr)
                    {
                        // We found the compatible line, now make sure
                        // it is set to c_szCompatibleValue.
                        //
                        if (0 != lstrcmpiW (pszCompatible, c_szCompatibleValue))
                        {
                            hr = SPAPI_E_WRONG_INF_STYLE;
                        }

                        MemFree (pszCompatible);
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
                    {
                        // The Compatible key didn't exist so this is
                        // considered a windows 95 net inf
                        hr = SPAPI_E_WRONG_INF_STYLE;
                    }
                }
            }
            MemFree (pszSignature);
        }
        MemFree (pinfInfo);
    }

    TraceError("HrSetupIsValidNt5Inf",
            (SPAPI_E_WRONG_INF_STYLE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupQueryInfVersionInformation
//
//  Purpose:    Returns INF file version information from an
//              SP_INF_INFORMATION structure to a caller-supplied buffer.
//
//
//
//  Arguments:
//      pinfInfo   [in] See SetupApi documentation for more info
//      uiIndex    [in]
//      szKey      [in]
//      ppszInfo   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     BillBe   18 Jan 1998
//
//  Notes:
//
HRESULT
HrSetupQueryInfVersionInformation (
    IN  PSP_INF_INFORMATION pinfInfo,
    IN UINT uiIndex,
    IN PCWSTR pszKey,
    OUT PWSTR* ppszInfo)
{
    Assert(pinfInfo);

    *ppszInfo = NULL;

    DWORD dwSize;
    BOOL fSuccess = SetupQueryInfVersionInformation (pinfInfo, uiIndex,
            pszKey, NULL, 0, &dwSize);

    if (fSuccess)
    {
        *ppszInfo = (PWSTR)MemAlloc (dwSize * sizeof (WCHAR));
        fSuccess = SetupQueryInfVersionInformation (pinfInfo, uiIndex, pszKey,
                *ppszInfo, dwSize, NULL);
    }

    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        MemFree (*ppszInfo);
        *ppszInfo = NULL;
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupQueryInfVersionInformation", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSetupInfFile::Close
//
//  Purpose:    Close the INF file.  It must have previously opened with
//              a call to HrOpen().
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
void CSetupInfFile::Close ()
{
    AssertSz (m_hinf, "You shouldn't be closing a file that is already closed.");
    ::SetupCloseInfFile (m_hinf);
    m_hinf = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSetupInfFile::EnsureClosed
//
//  Purpose:    Ensure the INF file represented by this object is closed.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
void CSetupInfFile::EnsureClosed()
{
    if (m_hinf)
    {
        Close ();
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCallClassInstaller
//
//  Purpose:    calls the appropriate class installer with the specified
//                  installation request (DI_FUNCTION).
//
//  Arguments:
//      dif     [in]   See SetupApi for more info
//      hdi     [in]   See SetupApi for more info
//      pdeid   [in]   See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   25 June 1997
//
//  Notes:  SPAPI_E_DI_DO_DEFAULT is mapped to S_OK
//
HRESULT
HrSetupDiCallClassInstaller(
    IN DI_FUNCTION dif,
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(INVALID_HANDLE_VALUE != hdi);
    Assert(hdi);

    HRESULT hr = S_OK;

    // Call the class installer and convert any errors
    if (!SetupDiCallClassInstaller(dif, hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
        if (SPAPI_E_DI_DO_DEFAULT == hr)
        {
            hr = S_OK;
        }
    }

    TraceError("HrSetupDiCallClassInstaller",
               (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ? S_OK : hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupCopyOEMInf
//
//  Purpose:    HRESULT wrapper for SetupCopyOEMInf that returns the
//                  new file path and name as tstrings
//
//  Arguments:
//      szSourceName              [in]  See SetupApi for more info
//      szSourceMediaLocation     [in]
//      dwSourceMediaType         [in]
//      dwCopyStyle               [in]
//      pstrDestFilename          [out]
//      pstrDestFilenameComponent [out]
//
//  Returns:    HRESULT. S_OK if successful, or Win32 converted error code
//
//  Author:     billbe   15 May 1997
//
//  Notes: See SetupCopyOEMInf in SetupApi for more info
//
HRESULT
HrSetupCopyOemInf(
    IN const tstring& strSourceName,
    IN const tstring& strSourceMediaLocation, OPTIONAL
    IN DWORD dwSourceMediaType,
    IN DWORD dwCopyStyle,
    OUT tstring* pstrDestFilename, OPTIONAL
    OUT tstring* pstrDestFilenameComponent OPTIONAL)
{
    Assert(!strSourceName.empty());

    BOOL        fWin32Success = TRUE;
    DWORD       cchRequiredSize;

    // Copy the file and get the size for the new filename in case it is
    // needed
    if (fWin32Success = SetupCopyOEMInf(strSourceName.c_str(),
            strSourceMediaLocation.c_str(), dwSourceMediaType, dwCopyStyle,
            NULL, NULL, &cchRequiredSize, NULL))
    {
        // If any of the out parameters are specified, we need to get the
        // information
        if (pstrDestFilename || pstrDestFilenameComponent)
        {
            PWSTR      pszDestPath = NULL;
            PWSTR      pszDestFilename = NULL;
            // now we allocate space to get the destination file path.
            // We allocate on the stack for automatic clean-up
            // Note: dwRequiredSize includes the terminating NULL
            //
            pszDestPath = (PWSTR)_alloca(cchRequiredSize * sizeof(WCHAR));

            // Get the new file path and filename
            if (fWin32Success = SetupCopyOEMInf(strSourceName.c_str(),
                    strSourceMediaLocation.c_str(), dwSourceMediaType,
                    dwCopyStyle, pszDestPath, cchRequiredSize, NULL,
                    &pszDestFilename))
            {
                // if the file path is needed, assign it
                if (pstrDestFilename)
                {
                    *pstrDestFilename = pszDestPath;
                }

                // If the user wants just the filename, assign it to the
                // string
                if (pstrDestFilenameComponent)
                {
                    *pstrDestFilenameComponent = pszDestFilename;
                }
            }
            else
            {
                // initialize out params on failure
                //
                if (pstrDestFilename)
                {
                    pstrDestFilename->erase();
                }

                if (pstrDestFilenameComponent)
                {
                    pstrDestFilenameComponent->erase();
                }
            }
        }

    }

    HRESULT hr = S_OK;
    if (!fWin32Success)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupCopyOEMInf", hr);
    return hr;

}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupCopyOEMInf
//
//  Purpose:    HRESULT wrapper for SetupCopyOEMInf that returns the
//                  new file path and name as tstrings
//
//  Arguments:
//      pszSourceName             [in]  See SetupApi for more info
//      pszSourceMediaLocation    [in]
//      dwSourceMediaType         [in]
//      dwCopyStyle               [in]
//      pszDestFilename           [out] // must be at least _MAX_PATH chars.
//      ppszDestFilenameComponent [out]
//
//  Returns:    HRESULT. S_OK if successful, or Win32 converted error code
//
//  Author:     billbe   15 May 1997
//
//  Notes: See SetupCopyOEMInf in SetupApi for more info
//
HRESULT
HrSetupCopyOemInfBuffer(
    IN PCWSTR pszSourceName,
    IN PCWSTR pszSourceMediaLocation, OPTIONAL
    IN DWORD SourceMediaType,
    IN DWORD CopyStyle,
    OUT PWSTR pszDestFilename,
    IN DWORD cchDestFilename,
    OUT PWSTR* ppszDestFilenameComponent OPTIONAL)
{
    Assert(pszSourceName);
    Assert(pszDestFilename);

    BOOL        fWin32Success = TRUE;

    if (!(fWin32Success = SetupCopyOEMInf(pszSourceName,
            pszSourceMediaLocation, SourceMediaType,
            CopyStyle, pszDestFilename, cchDestFilename, NULL,
            ppszDestFilenameComponent)))
    {
        // initialize out params on failure
        //
        *pszDestFilename = 0;
        if (*ppszDestFilenameComponent)
        {
            *ppszDestFilenameComponent = NULL;
        }
    }

    HRESULT hr = S_OK;
    if (!fWin32Success)
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSetupCopyOEMInf");
    return hr;

}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiBuildDriverInfoList
//
//  Purpose:    builds a list of drivers associated with a specified device
//                  instance or with the device information set's global
//                  class driver list.
//
//  Arguments:
//      hdi             [in]        See SetupApi for more info
//      pdeid           [in, out]
//      dwDriverType    [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiBuildDriverInfoList(IN HDEVINFO hdi, IN OUT PSP_DEVINFO_DATA pdeid,
                             IN DWORD dwDriverType)
{
    Assert(IsValidHandle(hdi));

    HRESULT hr = S_OK;

    // Build the list
    if (!SetupDiBuildDriverInfoList(hdi, pdeid, dwDriverType))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiBuildDriverInfoList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCreateDeviceInfo
//
//  Purpose:    creates a new device information element and adds it as a
//                  new member to the specified device information set.
//
//  Arguments:
//      hdi             [in]   See SetupApi for more info
//      pszDeviceName   [in]   See SetupApi for more info
//      guidClass       [in]   See SetupApi for more info
//      pszDesc         [in]   See SetupApi for more info
//      hwndParent      [in]   See SetupApi for more info
//      dwFlags         [in]   See SetupApi for more info
//      pdeid           [out]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:  pdeid is initialized and its cbSize field set by this fcn
//
HRESULT
HrSetupDiCreateDeviceInfo(
    IN HDEVINFO hdi,
    IN PCWSTR pszDeviceName,
    IN const GUID& guidClass,
    IN PCWSTR pszDesc, OPTIONAL
    IN HWND hwndParent, OPTIONAL
    IN DWORD dwFlags,
    OUT PSP_DEVINFO_DATA pdeid OPTIONAL)
{
    Assert(IsValidHandle(hdi));
    Assert(pszDeviceName);

    if (pdeid)
    {
        ZeroMemory(pdeid, sizeof(SP_DEVINFO_DATA));
        pdeid->cbSize = sizeof(SP_DEVINFO_DATA);
    }

    HRESULT hr = S_OK;

    // Create the device info node
    if (!SetupDiCreateDeviceInfo (hdi, pszDeviceName, &guidClass, pszDesc,
            hwndParent, dwFlags, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError ("HrSetupDiCreateDeviceInfo", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiEnumDeviceInfo
//
//  Purpose:    Enumerates the members of the specified device information
//                   set.
//
//  Arguments:
//      hdi          [in]   See SetupApi for more info
//      dwIndex      [in]   See SetupApi for more info
//      pdeid        [in]   See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   13 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiEnumDeviceInfo(
    IN HDEVINFO hdi,
    IN DWORD dwIndex,
    OUT PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr;

    ZeroMemory(pdeid, sizeof(SP_DEVINFO_DATA));
    pdeid->cbSize = sizeof(SP_DEVINFO_DATA);

    if (SetupDiEnumDeviceInfo (hdi, dwIndex, pdeid))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiEnumDeviceInfo", hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiEnumDriverInfo
//
//  Purpose:    Enumerates the members of a driver information list.
//
//  Arguments:
//      hdi          [in]   See SetupApi for more info
//      pdeid        [in]
//      dwDriverType [in]
//      dwIndex      [in]
//      pdrid        [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiEnumDriverInfo(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwDriverType,
    IN DWORD dwIndex,
    OUT PSP_DRVINFO_DATA pdrid)
{

    Assert(IsValidHandle(hdi));
    Assert(pdrid);

    HRESULT hr = S_OK;

    // initialize the out param
    ZeroMemory(pdrid, sizeof(SP_DRVINFO_DATA));
    pdrid->cbSize = sizeof(SP_DRVINFO_DATA);

    // call the enum fcn
    if (!SetupDiEnumDriverInfo(hdi, pdeid, dwDriverType, dwIndex, pdrid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiEnumDriverInfo", hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSelectBestCompatDrv
//
//  Purpose:    Finds and selects the best driver for the current device.
//
//  Arguments:
//      hdi          [in]   See SetupApi for more info
//      pdeid        [in][out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//

HRESULT
HrSetupDiSelectBestCompatDrv(
    IN     HDEVINFO         hdi,
    IN OUT PSP_DEVINFO_DATA pdeid)
{

    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr = S_OK;

    // call the SelectBestCompatDrv fcn
    if (!SetupDiSelectBestCompatDrv(hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiSelectBestCompatDrv", hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceInfoListClass
//
//  Purpose:    Retrieves the class GUID associated with a device
//                  information set if it has an associated class.
//
//  Arguments:
//      hdi   [in]  See SetupApi for more info
//      pguid [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceInfoListClass (
    IN HDEVINFO hdi,
    OUT GUID* pguid)
{
    Assert(IsValidHandle(hdi));
    Assert(pguid);

    HRESULT hr = S_OK;

    // Get the guid for the HDEVINFO
    if (!SetupDiGetDeviceInfoListClass (hdi, pguid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDeviceInfoListClass", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetClassDevs
//
//  Purpose:    Returns a device information set that contains all installed
//              devices of a specified class.
//
//  Arguments:
//      pguidClass    [in]   See SetupApi for more info
//      pszEnumerator [in]   See SetupApi for more info
//      hwndParent    [in]   See SetupApi for more info
//      dwFlags       [in]   See SetupApi for more info
//      phdi          [out]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   13 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetClassDevs (
    IN const GUID* pguidClass, OPTIONAL
    IN PCWSTR pszEnumerator, OPTIONAL
    IN HWND hwndParent, OPTIONAL
    IN DWORD dwFlags,
    OUT HDEVINFO* phdi)
{
    Assert(phdi);

    HRESULT hr;

    HDEVINFO hdi = SetupDiGetClassDevsW (pguidClass, pszEnumerator,
            hwndParent, dwFlags);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        hr = S_OK;
        *phdi = hdi;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phdi = NULL;
    }

    TraceError ("HrSetupDiGetClassDevs", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceInstanceId
//
//  Purpose:    HRESULT wrapper for SetupDiGetDeviceInstanceId.
//
//  Arguments:
//      hdi          [in]  See SetupApi for more info.
//      pdeid        [in]  See SetupApi for more info.
//      pszId        [out] The device instance Id for the net card.
//      cchId        [in]  The size of pszId in characters.
//      pcchRequired [out] Optional. The required buffer size in characters.
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   26 Mar 1997
//
//  Notes: See SetupDiGetDeviceInstanceId in Device Installer for more info.
//
HRESULT
HrSetupDiGetDeviceInstanceId(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PWSTR pszId,
    IN DWORD cchId,
    OUT OPTIONAL DWORD* pcchRequired)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    DWORD   cchRequiredSize;
    BOOL    fSuccess = TRUE;
    HRESULT hr = S_OK;

    // Get the buffer length required for the instance Id.
    if (!(fSuccess = SetupDiGetDeviceInstanceIdW(hdi, pdeid, NULL, 0,
            &cchRequiredSize)))
    {
        // If all went well, we should have a buffer error.
        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
        {
            // Since ERROR_INSUFFICIENT_BUFFER is really a success
            // for us, we will reset the success flag.
            fSuccess = TRUE;

            // Set the out param if it was specified.
            if (pcchRequired)
            {
                *pcchRequired = cchRequiredSize;
            }

            // If the buffer sent in was large enough, go ahead and use it.
            if (cchId >= cchRequiredSize)
            {
                fSuccess = SetupDiGetDeviceInstanceIdW(hdi, pdeid,
                        pszId, cchId, NULL);
            }
        }
    }
#ifdef DBG  // Just being safe
    else
    {
        // This should never happen since we sent in no buffer
        AssertSz(FALSE, "SetupDiGetDeviceInstanceId returned success"
                " even though it was given no buffer");
    }
#endif // DBG

    // We used SetupApi so we need to convert any errors
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDeviceInstanceId", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiInstallDevice
//
//  Purpose:    Wrapper for SetupDiInstallDevice
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiInstallDevice (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr = S_OK;

    // Let SetupApi install the specfied device
    if (!SetupDiInstallDevice (hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiInstallDevice", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiOpenDevRegKey
//
//  Purpose: Return an HKEY to the hardware device's driver instance key
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      dwScope                 [in]
//      dwHwProfile             [in]
//      dwKeyType               [in]
//      samDesired              [in]
//      phkey                   [out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   7 May 1997
//
//  Notes:
//
HRESULT
HrSetupDiOpenDevRegKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwScope,
    IN DWORD dwHwProfile,
    IN DWORD dwKeyType,
    IN REGSAM samDesired,
    OUT HKEY* phkey)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(phkey);

    // Try to open the registry key
    //

    HRESULT hr;

    HKEY hkey = SetupDiOpenDevRegKey(hdi, pdeid, dwScope, dwHwProfile,
            dwKeyType, samDesired);

    if (INVALID_HANDLE_VALUE != hkey)
    {
        hr = S_OK;
        *phkey = hkey;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phkey = NULL;
    }

    TraceErrorOptional("HrSetupDiOpenDevRegKey", hr,
            (SPAPI_E_DEVINFO_NOT_REGISTERED == hr) ||
            (SPAPI_E_KEY_DOES_NOT_EXIST == hr));

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetClassInstallParams
//
//  Purpose:    sets or clears class install parameters for a device
//                  information set or a particular device information element.
//
//  Arguments:
//      hdi    [in] See Device Installer API for more info
//      pdeid  [in]
//      pcih   [in]
//      cbSize [in]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetClassInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_CLASSINSTALL_HEADER pcih, OPTIONAL
    IN DWORD cbSize)
{
    Assert(IsValidHandle(hdi));

    HRESULT hr = S_OK;

    // Set or clear the params
    if (!SetupDiSetClassInstallParams(hdi, pdeid, pcih, cbSize))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetClassInstallParams", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetFixedSizeClassInstallParams
//
//  Purpose:    Gets a fixed size of an info list's ot device's class install
//                  parameters for a device.
//
//  Arguments:
//      hdi    [in] See Device Installer for more info
//      pdeid  [in]
//      pcih   [in]
//      cbSize [in]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetFixedSizeClassInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PSP_CLASSINSTALL_HEADER pcih,
    IN INT cbSize)
{
    Assert(IsValidHandle(hdi));
    Assert(pcih);

    HRESULT hr = S_OK;

    ZeroMemory(pcih, cbSize);
    pcih->cbSize = sizeof(SP_CLASSINSTALL_HEADER);

    // Device Installer Api uses an all purpose GetClassInstallParams
    // function. Several structures contain an SP_CLASSINSTALL_HEADER
    // as their first member.
    if (!SetupDiGetClassInstallParams(hdi, pdeid, pcih, cbSize, NULL))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiGetFixedSizeClassInstallParams", hr,
            SPAPI_E_NO_CLASSINSTALL_PARAMS == hr);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetSelectedDriver
//
//  Purpose:    Retrieves the member of a driver list that has been selected
//                  as the controlling driver.
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      pdrid                   [out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetSelectedDriver (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PSP_DRVINFO_DATA pdrid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);

    // initialize and set the cbSize field
    ZeroMemory(pdrid, sizeof(*pdrid));
    pdrid->cbSize = sizeof(*pdrid);

    HRESULT hr = S_OK;

    // Set pdrid as the selected driver
    if (!SetupDiGetSelectedDriver(hdi, pdeid, pdrid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetSelectedDriver",
        (SPAPI_E_NO_DRIVER_SELECTED == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDriverInfoDetail
//
//  Purpose:    Gets details on the driver referenced by the given parameters.
//
//  Arguments:
//      hdi     []
//      pdeid   [] See SetupAPI for more info
//      pdrid   []
//      ppdridd []
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     danielwe   5 May 1998
//
//  Notes:
//
HRESULT
HrSetupDiGetDriverInfoDetail (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINFO_DETAIL_DATA* ppdridd)
{
    HRESULT     hr = S_OK;
    BOOL        fSuccess = TRUE;
    DWORD       dwRequiredSize = 0;

    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(ppdridd);
    Assert(pdrid);

    *ppdridd = NULL;

    // Get the size needed for the driver detail
    if (!(fSuccess = SetupDiGetDriverInfoDetailW (hdi, pdeid, pdrid, NULL,
            0, &dwRequiredSize)))
    {
        // We should have received an insufficient buffer error since we
        // sent no buffer
        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
        {
            // Since this is ERROR_INSUFFICIENT_BUFFER is really a
            // success for us, we will reset the success flag.
            fSuccess = TRUE;

            // Now we allocate our buffer for the driver detail data
            // The size of the buffer is variable but it is a
            // PSP_DEVINFO_DETAIL_DATA.
            *ppdridd = (PSP_DRVINFO_DETAIL_DATA)MemAlloc (dwRequiredSize);

            if (*ppdridd)
            {
                //initialize the variable
                ZeroMemory(*ppdridd, dwRequiredSize);
                (*ppdridd)->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                // Get detailed info
                fSuccess = SetupDiGetDriverInfoDetailW (hdi, pdeid, pdrid,
                        *ppdridd, dwRequiredSize, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        // This should NEVER happen
        AssertSz(FALSE, "HrSetupDiGetDriverInfoDetail succeeded with no "
                 "buffer!");
    }

    // We have been using Device Installer Api so convert any errors
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    // clean up on failure
    if (FAILED(hr))
    {
        MemFree (*ppdridd);
        *ppdridd = NULL;
    }

    TraceError("HrSetupDiGetDriverInfoDetail", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetSelectedDriver
//
//  Purpose:    Sets the specified member of a driver list as the
//                  currently-selected driver. It can also be used to reset
//                  the driver list so that there is no currently-selected
//                  driver.
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      pdrid                   [in, out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetSelectedDriver (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN OUT PSP_DRVINFO_DATA pdrid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);

    HRESULT hr = S_OK;

    // Set pdrid as the selected driver
    if (!SetupDiSetSelectedDriver(hdi, pdeid, pdrid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetSelectedDriver", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCreateDevRegKey
//
//  Purpose: Creates and returns an HKEY to the hardware device's driver
//              instance key
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      dwScope                 [in]
//      dwHwProfile             [in]
//      dwKeyType               [in]
//      hinf                    [in] OPTIONAL
//      pszInfSectionName       [in] OPTIONAL
//      phkey                   [out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   4 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiCreateDevRegKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwScope,
    IN DWORD dwHwProfile,
    IN DWORD dwKeyType,
    IN HINF hinf,
    PCWSTR pszInfSectionName,
    OUT HKEY* phkey)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(phkey);

    // Try to create the registry key and process the inf section, if
    // specified
    //

    HRESULT hr;

    HKEY hkey = SetupDiCreateDevRegKeyW(hdi, pdeid, dwScope, dwHwProfile,
            dwKeyType, hinf, pszInfSectionName);

    if (INVALID_HANDLE_VALUE != hkey)
    {
        hr = S_OK;
        *phkey = hkey;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phkey = NULL;
    }

    TraceError("HrSetupDiCreateDevRegKey", hr);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetActualSectionToInstall
//
//  Purpose: The sections in an inf file may have OS and platform suffixes
//              appended to them.  This function searches for a section that
//              has pszSectionName as its base and has a certain suffix.
//              For example on an x86 NT machine, given a section name of
//              INSTALL, the search would start with INSTALL.NTx86, if that
//              is not found, then INSTALL.NT is searched for.
//              If that is not found INSTALL is returned.
//
//  Arguments:
//      hinf                  [in] SetupApi inf file handle
//      pszSectionName        [in] the section name to base the search on
//      pstrActualSectionName [out] The actual section name with extension
//      pstrExtension         [out] OPTIONAL. The extension part of the
//                                      pstrActualSectionName.
//                                      This includes "."
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 Mar 1997
//
//  Notes: See SetupDiGetActualSectionToInstall in SetupApi documention
//              for more info
//
HRESULT
HrSetupDiGetActualSectionToInstall(
    IN HINF hinf,
    IN PCWSTR pszSectionName,
    OUT tstring* pstrActualSectionName,
    OUT tstring* pstrExtension OPTIONAL)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSectionName);
    Assert(pstrActualSectionName);

    // strSectionName might need to be decorated with OS
    // and Platform specific suffixes.  The next call will return the actual
    // decorated section name or our current section name if the decorated
    // one does not exist.
    //

    BOOL    fSuccess = TRUE;
    DWORD   cchRequiredSize;

    // Get the buffer length required
    if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
            pszSectionName, NULL, 0, &cchRequiredSize, NULL))
    {
        // now we allocate space to get the actual section name
        // we allocate on the stack for automatic clean-up
        // Note: dwRequiredSize includes the terminating NULL
        //
        PWSTR pszActualSection = NULL;
        pszActualSection = (PWSTR)_alloca(cchRequiredSize * sizeof(WCHAR));

        PWSTR pszExtension = NULL;
        // Now fill the temporary and assign it to the OUT parameter
        if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
                pszSectionName, pszActualSection, cchRequiredSize,
                NULL, &pszExtension))
        {
            *pstrActualSectionName = pszActualSection;

            // If the user wants the extension assign it to the string
            // or assign the empty string if no extension was found
            if (pstrExtension)
            {
                *pstrExtension = (pszExtension ? pszExtension : c_szEmpty);
            }
        }
        else
        {
            // initialize out params on failure
            pstrActualSectionName->erase();
            if (pstrExtension)
            {
                pstrExtension->erase();
            }
        }
    }

    // We used SetupApi so errors have to be converted
    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetActualSectionToInstall", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetActualSectionToInstallWithAlloc
//
//  Purpose: The sections in an inf file may have OS and platform suffixes
//              appended to them.  This function searches for a section that
//              has pszSectionName as its base and has a certain suffix.
//              For example on an x86 NT machine, given a section name of
//              INSTALL, the search would start with INSTALL.NTx86, if that
//              is not found, then INSTALL.NT is searched for.
//              If that is not found INSTALL is returned.
//
//  Arguments:
//      hinf              [in] SetupApi inf file handle.
//      pszSection        [in] the section name to base the search on.
//      ppszActualSection [out] The actual section name with extension.
//                              If the actual section is the same as
//                              pszSectionName, *ppszActualSectionName
//                              will be NULL.
//      ppszExtension     [out] OPTIONAL. The extension part of the
//                              *ppszActualSectionName. This includes "."
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 Mar 1997
//
//  Notes: See SetupDiGetActualSectionToInstall in SetupApi documention
//              for more info
//
HRESULT
HrSetupDiGetActualSectionToInstallWithAlloc(
    IN  HINF hinf,
    IN  PWSTR pszSection,
    OUT PWSTR* ppszActualSection,
    OUT PWSTR* ppszExtension OPTIONAL)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);
    Assert(ppszActualSection);

    // pszSectionName might need to be decorated with OS
    // and Platform specific suffixes.  The next call will return the actual
    // decorated section name or our current section name if the decorated
    // one does not exist.
    //
    HRESULT hr = S_OK;
    BOOL    fSuccess = TRUE;
    DWORD   cchRequiredSize;

    *ppszActualSection = NULL;
    if (ppszExtension)
    {
        *ppszExtension = NULL;
    }

    // Get the buffer length required
    if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
            pszSection, NULL, 0, &cchRequiredSize, NULL))
    {
        // We are assuming the section is not changing.  If cchRequired is
        // larger than the current section name buffer than we will allocate
        // and fill the out param.
        //
        // If the section name is teh same, then we will not allocate.  But
        // if ppszExtension is specified then we need to send in the original
        // section name buffer since ppszExtension will point to a location
        // within it.
        //
        PWSTR pszBuffer = pszSection;
        if ((wcslen(pszSection) + 1) < cchRequiredSize)
        {
            hr = E_OUTOFMEMORY;
            *ppszActualSection = new WCHAR[cchRequiredSize * sizeof(WCHAR)];
            pszBuffer = *ppszActualSection;
        }

        // if the section name is different (we allocated) or the
        // extension out param was specified, then we need to call the fcn.
        if (pszBuffer && ((pszBuffer != pszSection) || ppszExtension))
        {
            // Now fill the temporary and assign it to the OUT parameter
            if (!(fSuccess = SetupDiGetActualSectionToInstallW(hinf,
                    pszSection, pszBuffer, cchRequiredSize,
                    NULL, ppszExtension)))
            {
                // initialize out params on failure
                delete [] *ppszActualSection;
                *ppszActualSection = NULL;

                if (ppszExtension)
                {
                    *ppszExtension = NULL;
                }
            }
        }
    }

    // We used SetupApi so errors have to be converted
    if (SUCCEEDED(hr) && !fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetActualSectionToInstallWithAlloc", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetActualSectionToInstallWithBuffer
//
//  Purpose: The sections in an inf file may have OS and platform suffixes
//              appended to them.  This function searches for a section that
//              has pszSectionName as its base and has a certain suffix.
//              For example on an x86 NT machine, given a section name of
//              INSTALL, the search would start with INSTALL.NTx86, if that
//              is not found, then INSTALL.NT is searched for.
//              If that is not found INSTALL is returned.
//
//  Arguments:
//      hinf              [in]  SetupApi inf file handle.
//      pszSection        [in]  The section name to base the search on.
//      pszActualSection  [out] The actual section name with extension
//                              Buffer must be LINE_LEN characters.
//      cchActualSection  [in]  Size of pszActualSection in characters.
//      pcchRequired      [out] OPTIONAL. Reuqired size of buffer in
//                              characters.
//      ppszExtension     [out] OPTIONAL. The extension part of the
//                              pszActualSection. This includes "."
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 Mar 1997
//
//  Notes: See SetupDiGetActualSectionToInstall in SetupApi documention
//              for more info
//
HRESULT
HrSetupDiGetActualSectionToInstallWithBuffer(
    IN  HINF hinf,
    IN  PCWSTR pszSection,
    OUT PWSTR  pszActualSection,
    IN  DWORD  cchActualSection,
    OUT DWORD* pcchRequired,
    OUT PWSTR* ppszExtension OPTIONAL)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);
    Assert(pszActualSection);

    // pszSectionName might need to be decorated with OS
    // and Platform specific suffixes.  The next call will return the actual
    // decorated section name or our current section name if the decorated
    // one does not exist.
    //

    BOOL    fSuccess = TRUE;
    DWORD   cchRequiredSize;
    *pszActualSection = 0;
    if (ppszExtension)
    {
        *ppszExtension = NULL;
    }

    // Get the buffer length required
    if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
            pszSection, NULL, 0, &cchRequiredSize, NULL))
    {
        if (pcchRequired)
        {
            *pcchRequired = cchRequiredSize;
        }

        // If the buffer sent in is large enough, get the section name.
        if (cchActualSection >= cchRequiredSize)
        {
            if (!(fSuccess = SetupDiGetActualSectionToInstallW(hinf,
                    pszSection, pszActualSection, cchActualSection,
                    NULL, ppszExtension)))
            {
                // cleanup on failure.
                *pszActualSection = 0;
            }
        }
    }

    // We used SetupApi so errors have to be converted
    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetActualSectionToInstallWithBuffer", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceInstallParams
//
//  Purpose:    Returns the device install params header of a
//              device info set/data.  Set SetupDiGetDeviceInstallParams
//              in the SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//      pdeip       [out] See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 May 1997
//
//  Notes:  This function will clear the variable pdeip and set its
//              cbSize field.
//
HRESULT
HrSetupDiGetDeviceInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS pdeip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeip);

    HRESULT hr = S_OK;

    // initialize out parameter and set its cbSize field
    //
    ZeroMemory(pdeip, sizeof(SP_DEVINSTALL_PARAMS));
    pdeip->cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // get the header
    if (!SetupDiGetDeviceInstallParams(hdi, pdeid, pdeip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDeviceInstallParams", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDriverInstallParams
//
//  Purpose:    Retrieves install parameters for the specified driver.
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      pdrid       [in]
//      pdrip       [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:  This function will clear the variable pdrip and set its
//              cbSize field.
//
HRESULT
HrSetupDiGetDriverInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINSTALL_PARAMS pdrip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(pdrip);

    HRESULT hr = S_OK;

    // initialize out parameter and set its cbSize field
    //
    ZeroMemory(pdrip, sizeof(SP_DRVINSTALL_PARAMS));
    pdrip->cbSize = sizeof(SP_DRVINSTALL_PARAMS);

    // get the header
    if (!SetupDiGetDriverInstallParams(hdi, pdeid, pdrid, pdrip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDriverInstallParams", hr);
    return hr;
}

VOID
SetupDiSetConfigFlags (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwFlags,
    IN SD_FLAGS_BINARY_OP eOp)
{
    DWORD   dwConfigFlags = 0;

    // Get the current config flags
    (VOID) HrSetupDiGetDeviceRegistryProperty(hdi, pdeid,
            SPDRP_CONFIGFLAGS, NULL, (BYTE*)&dwConfigFlags,
            sizeof(dwConfigFlags), NULL);

    // Perform the requested operation
    switch (eOp)
    {
        case SDFBO_AND:
            dwConfigFlags &= dwFlags;
            break;
        case SDFBO_OR:
            dwConfigFlags |= dwFlags;
            break;
        case SDFBO_XOR:
            dwConfigFlags ^= dwFlags;
            break;
        default:
            AssertSz(FALSE, "Invalid binary op in HrSetupDiSetConfigFlags");
    }

    (VOID) HrSetupDiSetDeviceRegistryProperty(hdi, pdeid, SPDRP_CONFIGFLAGS,
            (BYTE*)&dwConfigFlags, sizeof(dwConfigFlags));
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeviceInstallParams
//
//  Purpose:    Sets the device install params header of a
//              device info set/data.  Set SetupDiSetDeviceInstallParams
//              in the SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//      pdeip       [in] See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 May 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetDeviceInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_DEVINSTALL_PARAMS pdeip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeip);
    Assert(pdeip->cbSize == sizeof(SP_DEVINSTALL_PARAMS));

    HRESULT hr = S_OK;

    // set the header
    if (!SetupDiSetDeviceInstallParams(hdi, pdeid, pdeip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetDeviceInstallParams", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDriverInstallParams
//
//  Purpose:    Establishes install parameters for the specified driver.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      pdrid       [in]
//      pdrip       [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetDriverInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_DRVINFO_DATA pdrid,
    IN PSP_DRVINSTALL_PARAMS pdrip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(pdrip);
    Assert(pdrip->cbSize == sizeof(SP_DRVINSTALL_PARAMS));

    HRESULT hr = S_OK;

    // set the header
    if (!SetupDiSetDriverInstallParams(hdi, pdeid, pdrid, pdrip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetDriverInstallParams", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeipFlags
//
//  Purpose:    This sets given flags in a dev info data
//
//  Arguments:
//      hdi         [in] See Device Installer Api for more info
//      pdeid       [in] See Device Installer Api for more info
//      dwFlags     [in] Flags to set
//      eFlagType   [in] Which flags field to set with dwFlags
//      eClobber    [in] Whether to add to existing flags or relace them
//
//  Returns:    HRESULT. S_OK if successful,
//                       a Win32 converted error otherwise
//
//
//  Author:     billbe   3 Feb 1998
//
//  Notes:
//
HRESULT
HrSetupDiSetDeipFlags (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwFlags, SD_DEID_FLAG_TYPE eFlagType,
    IN SD_FLAGS_BINARY_OP eOp)
{
    Assert(IsValidHandle(hdi));

    SP_DEVINSTALL_PARAMS deip;
    // Get the install params
    HRESULT hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);

    if (S_OK == hr)
    {
        DWORD* pFlags;

        // Set our pointer to the right flag type
        switch (eFlagType)
        {
            case SDDFT_FLAGS:
                pFlags = &deip.Flags;
                break;
            case SDDFT_FLAGSEX:
                pFlags = &deip.FlagsEx;
                break;
            default:
                AssertSz(FALSE, "Invalid Flag type in HrSetupDiSetDeipFlags");
                break;
        }


        // Perform the requested operation
        switch (eOp)
        {
            case SDFBO_AND:
                *pFlags &= dwFlags;
                break;
            case SDFBO_OR:
                *pFlags |= dwFlags;
                break;
            case SDFBO_XOR:
                *pFlags ^= dwFlags;
                break;
            default:
                AssertSz(FALSE, "Invalid binary op in HrSetupDiSetDeipFlags");
        }

        // update the params
        hr = HrSetupDiSetDeviceInstallParams (hdi, pdeid, &deip);
    }

    TraceError ("HrSetupDiSetDeipFlags", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiRemoveDevice
//
//  Purpose:    Calls SetupApi to remove a device. See
//              SetupDiRemoveDevice for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 May 1997
//
//  Notes:  This is used for enumerated Net class components
//
HRESULT
HrSetupDiRemoveDevice(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr = S_OK;

    if (!SetupDiRemoveDevice(hdi,pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiRemoveDevice", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiOpenDeviceInfo
//
//  Purpose:    Retrieves information about an existing device instance and
//              adds it to the specified device information set
//
//  Arguments:
//      hdi              [in]   See SetupApi for more info
//      pszPnpInstanceId [in]   See SetupApi for more info
//      hwndParent       [in]   See SetupApi for more info
//      dwOpenFlags      [in]   See SetupApi for more info
//      pdeid            [out]  See SetupApi for more info OPTIONAL
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 May 1997
//
//  Notes:  This is used for enumerated Net class components
//
HRESULT
HrSetupDiOpenDeviceInfo(
    IN const HDEVINFO hdi,
    IN PCWSTR pszPnpInstanceId,
    IN HWND hwndParent,
    IN DWORD dwOpenFlags,
    OUT PSP_DEVINFO_DATA pdeid OPTIONAL)
{
    Assert(IsValidHandle(hdi));
    Assert(pszPnpInstanceId);

    // If the out param was specified, clear it and set its cbSize field
    //
    if (pdeid)
    {
        ZeroMemory(pdeid, sizeof(*pdeid));
        pdeid->cbSize = sizeof(*pdeid);
    }

    HRESULT hr = S_OK;

    if (!SetupDiOpenDeviceInfo(hdi, pszPnpInstanceId, hwndParent, dwOpenFlags,
            pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, SPAPI_E_NO_SUCH_DEVINST == hr,
            "HrSetupDiOpenDeviceInfo");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCreateDeviceInfoList
//
//  Purpose:    Creates an empty device information set.
//
//  Arguments:
//      pguidClass [in]   See SetupApi for more info
//      hwndParent [in]   See SetupApi for more info
//      phdi       [out]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 May 1997
//
//  Notes:
//
HRESULT
HrSetupDiCreateDeviceInfoList (
    IN const GUID* pguidClass,
    IN HWND hwndParent,
    OUT HDEVINFO* phdi)
{
    Assert(phdi);

    HRESULT hr;

    // Try to create the info set
    //
    HDEVINFO hdi = SetupDiCreateDeviceInfoList (pguidClass, hwndParent);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        hr = S_OK;
        *phdi = hdi;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phdi = NULL;
    }

    TraceError("HrSetupDiCreateDeviceInfoList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceRegistryPropertyWithAlloc
//
//  Purpose:    Returns the requested property of a device
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      dwProperty  [in]
//      pdwRegType  [out]
//      ppbBuffer   [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   1 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceRegistryPropertyWithAlloc(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE** ppbBuffer)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(ppbBuffer);

    *ppbBuffer = NULL;

    DWORD cbReqSize;
    HRESULT hr = S_OK;

    // Get the size needed for the buffer
    BOOL fWin32Success = SetupDiGetDeviceRegistryPropertyW(hdi, pdeid,
            dwProperty, NULL, NULL, 0, &cbReqSize);

    // We expect failure since we want the buffer size and sent in no buffer
    if (!fWin32Success)
    {
        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
        {
            // Not really an error
            fWin32Success = TRUE;
        }

        if (fWin32Success)
        {
            *ppbBuffer = (BYTE*) MemAlloc (cbReqSize);

            if (*ppbBuffer)
            {
                // Now get the actual information
                fWin32Success = SetupDiGetDeviceRegistryPropertyW(hdi, pdeid,
                        dwProperty, pdwRegType, *ppbBuffer, cbReqSize, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        AssertSz(FALSE, "SetupDiGetDeviceRegistryPropertyW should have failed!");
        hr = E_FAIL;
    }

    // All failures are converted to HRESULTS
    if (SUCCEEDED(hr) && !fWin32Success)
    {
        MemFree (*ppbBuffer);
        *ppbBuffer = NULL;
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr ,
             (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) ||
            (SPAPI_E_NO_SUCH_DEVINST == hr),
             "HrSetupDiGetDeviceRegistryPropertyWithAlloc");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceRegistryProperty
//
//  Purpose:    Returns the requested property of a device
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      dwProperty  [in]
//      pdwRegType  [out]
//      ppbBuffer   [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   1 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceRegistryProperty(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE* pbBuffer,
    IN DWORD cbBufferSize,
    OUT DWORD* pcbRequiredSize OPTIONAL)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // Get the size needed for the buffer
    BOOL fWin32Success = SetupDiGetDeviceRegistryPropertyW(hdi, pdeid, dwProperty,
            pdwRegType, pbBuffer, cbBufferSize, pcbRequiredSize);

    HRESULT hr = S_OK;

    // All failures are converted to HRESULTS
    if (!fWin32Success)
    {
        if (pbBuffer)
        {
            *pbBuffer = 0;
        }
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr ,
             (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) ||
            (SPAPI_E_NO_SUCH_DEVINST == hr),
             "HrSetupDiGetDeviceRegistryProperty");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceName
//
//  Purpose:    Helper function to get the name of the device specified in
//              hdi and pdeid. Trys the friendly name first and if not there
//              falls back to driver name which must be there.
//
//  Arguments:
//      hdi      [in]
//      pdeid    [in]      See SetupApi for more info
//      ppszName [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     danielwe   11 Feb 1998
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceName (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PWSTR* ppszName)
{

    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(ppszName);

    DWORD   dwType;
    HRESULT hr = S_OK;

    hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc(
            hdi, pdeid, SPDRP_FRIENDLYNAME, &dwType, (BYTE**)ppszName);
    if (FAILED(hr))
    {
        // Try again with the device desc which MUST be there.
        hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc(
                hdi, pdeid, SPDRP_DEVICEDESC, &dwType, (BYTE**)ppszName);
    }
    AssertSz(FImplies(SUCCEEDED(hr), (dwType == REG_SZ)), "Not a string?!");

    TraceError("HrSetupDiGetDeviceName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeviceName
//
//  Purpose:    Helper function to set the name of the device specified in
//              hdi and pdeid.
//
//  Arguments:
//      hdi       [in]
//      pdeid     [in]      See SetupApi for more info
//      ppbBuffer [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     sumitc     23 apr 1998
//
//  Notes:
//
HRESULT
HrSetupDiSetDeviceName(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszDeviceName)
{

    Assert(IsValidHandle(hdi));
    Assert(pszDeviceName);

    HRESULT hr = S_OK;

    hr = HrSetupDiSetDeviceRegistryProperty(hdi,
                                            pdeid,
                                            SPDRP_FRIENDLYNAME,
                                            (const BYTE*)pszDeviceName,
                                            sizeof(WCHAR) * (wcslen(pszDeviceName) + 1));
    TraceError("HrSetupDiSetDeviceName", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeviceRegistryProperty
//
//  Purpose:    Sets the specified Plug and Play device registry property.
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      dwProperty  [in]
//      pbBuffer    [in]
//      cbSize      [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetDeviceRegistryProperty(IN HDEVINFO hdi,
                                   IN OUT PSP_DEVINFO_DATA pdeid,
                                   IN DWORD dwProperty,
                                   IN const BYTE* pbBuffer,
                                   IN DWORD cbSize)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(pbBuffer);

    HRESULT hr = S_OK;

    // Set the property
    if (!SetupDiSetDeviceRegistryProperty(hdi, pdeid, dwProperty, pbBuffer,
            cbSize))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetDeviceRegistryProperty", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSendPropertyChangeNotification
//
//  Purpose:    This sends a DIF_PROPERTCHANGE notification to the
//                  class installer
//
//  Arguments:
//      hdi             [in] See Device Isntaller Api
//      pdeid           [in]
//      dwStateChange   [in]
//      dwScope         [in]
//      dwProfileId     [in]
//
//  Returns:    HRESULT. S_OK if no error, a Win32 error converted
//                       code otherwise
//
//  Author:     billbe   4 Nov 1997
//
//  Notes:
//
HRESULT
HrSetupDiSendPropertyChangeNotification(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                        DWORD dwStateChange, DWORD dwScope,
                                        DWORD dwProfileId)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // First we create the property change structure and fill out its fields
    //
    SP_PROPCHANGE_PARAMS pcp;
    ZeroMemory(&pcp, sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = dwStateChange;
    pcp.Scope = dwScope;
    pcp.HwProfile = dwProfileId;

    // Now we set the structure as the device info data's
    // class install params
    HRESULT hr = HrSetupDiSetClassInstallParams(hdi, pdeid,
            reinterpret_cast<SP_CLASSINSTALL_HEADER*>(&pcp),
            sizeof(pcp));

    if (SUCCEEDED(hr))
    {
        // Now we need to set the "we have a class install params" flag
        // in the device install params
        //
        SP_DEVINSTALL_PARAMS deip;
        hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
        if (SUCCEEDED(hr))
        {
            deip.Flags |= DI_CLASSINSTALLPARAMS;
            hr = HrSetupDiSetDeviceInstallParams(hdi, pdeid, &deip);

            if (SUCCEEDED(hr))
            {
                // Notify the driver that the state has changed
                hr = HrSetupDiCallClassInstaller(DIF_PROPERTYCHANGE, hdi,
                        pdeid);

                if (SUCCEEDED(hr))
                {
                    // Set the properties change flag in the device info to
                    // let anyone who cares know that their ui might need
                    // updating to reflect any change in the device's status
                    // We can't let any failures here stop us so we ignore
                    // return values
                    //
                    (void) HrSetupDiGetDeviceInstallParams(hdi, pdeid,
                            &deip);
                    deip.Flags |= DI_PROPERTIES_CHANGE;
                    (void) HrSetupDiSetDeviceInstallParams(hdi, pdeid,
                            &deip);
                }
            }
        }
    }

    TraceError("HrSetupDiSendPropertyChangeNotification", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   FSetupDiCheckIfRestartNeeded
//
//  Purpose:    Checks the hdi and pdeid for the presence of the
//                  restart flag in the install params structure.
//                  See Device Installer Api for more info.
//
//  Arguments:
//      hdi     [in] See Device Installer Api
//      pdeid   [in]
//
//  Returns:    BOOL. TRUE if a restart is required, FALSE otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:
//
BOOL
FSetupDiCheckIfRestartNeeded(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    SP_DEVINSTALL_PARAMS    deip;
    BOOL fRestart = FALSE;

    // Get the install params for the device pdeid.
    HRESULT hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    if (SUCCEEDED(hr))
    {
        // Check for the presence of the flag
        if ((deip.Flags & DI_NEEDRESTART) || (deip.Flags & DI_NEEDREBOOT))
        {
            fRestart = TRUE;
        }
    }

    // We don't return any failures from this function since it is just
    // a check but we should trace them
    TraceError("FSetupDiCheckIfRestartNeeded", hr);
    return fRestart;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetClassImageList
//
//  Purpose:    Builds an image list that contains bitmaps for every
//              installed class and returns the list in a data structure
//
//  Arguments:
//      pcild    [out]  See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Nov 1997
//
//  Notes:  The image list will be in the ImageList field of the pcild
//                  structure
//
HRESULT
HrSetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA pcild)
{
    Assert(pcild);

    HRESULT hr = S_OK;

    ZeroMemory(pcild, sizeof(*pcild));
    pcild->cbSize = sizeof(*pcild);

    if (!SetupDiGetClassImageList(pcild))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetClassImageList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiDestroyClassImageList
//
//  Purpose:    Destroys a class image list that was built with
//              (Hr)SetupDiGetClassImageList
//
//  Arguments:
//      pcild    [in]  See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Nov 1997
//
//  Notes:
//
HRESULT
HrSetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA pcild)
{
    Assert(pcild);

    HRESULT hr = S_OK;

    if (!SetupDiDestroyClassImageList(pcild))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiDestroyClassImageList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetClassImageIndex
//
//  Purpose:    Retrieves the index within the class image list of a
//              specified class
//
//  Arguments:
//      pcild     [in]  See Device Installer Api for more info
//      guidClass [in]
//      pnIndex   [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Nov 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA pcild,
                            const GUID* pguidClass, INT* pnIndex)
{
    Assert(pcild);
    Assert(pguidClass);
    Assert(pnIndex);

    HRESULT hr = S_OK;

    if (!SetupDiGetClassImageIndex(pcild, pguidClass, pnIndex))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetClassImageIndex", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetParentWindow
//
//  Purpose:    Returns the window handle found in the install params of a
//              device info set/data.  Set SP_DEVINSTALL_PARAMS in the
//              SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//      phwndParent [out] Pointer to the parent window handle
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   12 May 1997
//
//  Notes:
//
HRESULT HrSetupDiGetParentWindow (HDEVINFO hdi,
                                  PSP_DEVINFO_DATA pdeid, OPTIONAL
                                  HWND* phwndParent)
{
    Assert(IsValidHandle(hdi));
    Assert(phwndParent);

    // Initialize the output parameter.
    *phwndParent = NULL;

    // Get the install params of the device
    SP_DEVINSTALL_PARAMS deip;
    HRESULT hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    if (SUCCEEDED(hr))
    {
        // Only assign the output if we have a valid window handle
        if (IsWindow(deip.hwndParent))
        {
            *phwndParent = deip.hwndParent;
        }
    }

    TraceError("HrSetupDiGetParentWindow", hr);
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   HrSetupInstallFilesFromInfSection
//
//  Purpose:    Queues all the files specified in the Copy Files sections
//                  listed by an Install section for installation.
//
//  Arguments:
//      hinf          [in]  See SetupApi for more info
//      hinfLayout    [in] Optional
//      hfq           [in]
//      pszSection    [in]
//      pszSourcePath [in] Optional
//      ulFlags       [in] Optional
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   21 July 1997
//
//  Notes:
//
HRESULT
HrSetupInstallFilesFromInfSection (
    IN HINF hinf,
    IN HINF hinfLayout,
    IN HSPFILEQ hfq,
    IN PCWSTR pszSection,
    IN PCWSTR pszSourcePath,
    IN UINT ulFlags)
{
    Assert(IsValidHandle(hinf));
    Assert(FImplies(hinfLayout, INVALID_HANDLE_VALUE != hinfLayout));
    Assert(pszSection);

    HRESULT hr = S_OK;

    if (!SetupInstallFilesFromInfSection(hinf, hinfLayout, hfq, pszSection,
            pszSourcePath, ulFlags))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupInstallFilesFromInfSection", hr);
    return hr;

}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupInstallFromInfSection
//
//  Purpose:    Carries out all the directives in an INF file Install section.
//
//  Arguments:
//      hwnd        [in]  See SetupApi for more info
//      hinf        [in]
//      pszSection  [in]
//      ulFlags     [in]
//      hkey        [in]
//      pszSource   [in]
//      ulCopyFlags [in]
//      pfc         [in]
//      pvCtx       [in]
//      hdi         [in]
//      pdeid       [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   5 July 1997
//
//  Notes:
//
HRESULT
HrSetupInstallFromInfSection (
    IN HWND hwnd,
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN UINT ulFlags,
    IN HKEY hkey,
    IN PCWSTR pszSource,
    IN UINT ulCopyFlags,
    IN PSP_FILE_CALLBACK pfc,
    IN PVOID pvCtx,
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);

    HRESULT hr = S_OK;

    if (!SetupInstallFromInfSection(hwnd, hinf, pszSection, ulFlags, hkey,
            pszSource, ulCopyFlags, pfc, pvCtx, hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSetupInstallFromInfSection (%S)",
            pszSection);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupInstallServicesFromInfSection
//
//  Purpose:    Carries out all the service directives in an INF file Install
//                  section.
//
//  Arguments:
//      hinf        [in] See SetupApi for more info
//      pszSection  [in]
//      dwFlags     [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   19 Feb 1998
//
//  Notes:
//
HRESULT
HrSetupInstallServicesFromInfSection (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN DWORD dwFlags)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);

    HRESULT hr = S_OK;

    if (!SetupInstallServicesFromInfSection(hinf, pszSection, dwFlags))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_SECTION_NOT_FOUND == hr),
        "HrSetupInstallServicesFromInfSection (%S)", pszSection);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenSoftwareDeviceEnumerator
//
//  Purpose:    Opens the swenum device driver used to install software-
//              enumerated device drivers.
//
//  Arguments:
//      dwFlagsAndAttributes [in]  See CreateFile.
//      phFile               [out] The returned handle to the swenum device.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   30 Mar 1998
//
//  Notes:
//
HRESULT
HrOpenSoftwareDeviceEnumerator (
    DWORD   dwFlagsAndAttributes,
    HANDLE* phFile)
{
    Assert (phFile);

    // Initialize the output parameter.
    //
    *phFile = INVALID_HANDLE_VALUE;

    // Get the devices in software device enumerator class.  There should
    // only be one.  (Or rather, we're only interested in the first one.)
    //
    HDEVINFO hdi;
    HRESULT hr = HrSetupDiGetClassDevs (&BUSID_SoftwareDeviceEnumerator,
                    NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE,
                    &hdi);
    if (S_OK == hr)
    {
        // Enumerate the first device in this class.  This will
        // initialize did.
        //
        SP_DEVICE_INTERFACE_DATA did;
        ZeroMemory (&did, sizeof(did));
        did.cbSize = sizeof(did);

        if (SetupDiEnumDeviceInterfaces (hdi, NULL,
                const_cast<LPGUID>(&BUSID_SoftwareDeviceEnumerator),
                0, &did))
        {
            // Now get the details so we can open the device.
            //
            const ULONG cbDetail = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                                    (MAX_PATH * sizeof(WCHAR));
            PSP_DEVICE_INTERFACE_DETAIL_DATA pDetail;

            hr = HrMalloc (cbDetail, (PVOID*)&pDetail);
            if (S_OK == hr)
            {
                pDetail->cbSize = sizeof(*pDetail);

                if (SetupDiGetDeviceInterfaceDetail (hdi, &did,
                        pDetail, cbDetail, NULL, NULL))
                {
                    // Now open the device (swenum).
                    //
                    HANDLE hFile = CreateFile (pDetail->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE,
                                        0, NULL, OPEN_EXISTING,
                                        dwFlagsAndAttributes, NULL);
                    if (hFile && (INVALID_HANDLE_VALUE != hFile))
                    {
                        *phFile = hFile;
                    }
                    else
                    {
                        hr = HrFromLastWin32Error ();
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error ();
                }

                MemFree (pDetail);
            }
        }
        else
        {
            hr = HrFromLastWin32Error ();
        }

        SetupDiDestroyDeviceInfoList (hdi);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrOpenSoftwareDeviceEnumerator");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindDeviceOnInterface
//
//  Purpose:    Searches for a specific device on a given interface.
//              It does this by using setup api to return all of the
//              devices in the class given by pguidInterfaceId.  It then
//              gets device path for each of these device interfaces and
//              looks for pguidDeviceId and pszReferenceString as substrings.
//
//  Arguments:
//      pguidDeviceId        [in]  The device id to find.
//      pguidInterfaceId     [in]  The interface on which to look.
//      pszReferenceString  [in]  Optional.  Further match on this ref string.
//      dwFlagsAndAttributes [in]  See CreateFile.  This is how the device is
//                                 opened if it is found.
//      phFile               [out] The returned device handle.
//
//  Returns:    S_OK if found and opened, S_FALSE if not found, or an error.
//
//  Author:     shaunco   30 Mar 1998
//
//  Notes:
//
HRESULT
HrFindDeviceOnInterface (
    IN const GUID* pguidDeviceId,
    IN const GUID* pguidInterfaceId,
    IN PCWSTR      pszReferenceString,
    IN DWORD       dwFlagsAndAttributes,
    OUT HANDLE*    phFile)
{
    Assert (pguidDeviceId);
    Assert (pguidInterfaceId);
    Assert (phFile);

    // Initialize the output parameter.
    //
    *phFile = INVALID_HANDLE_VALUE;

    WCHAR szDeviceId [c_cchGuidWithTerm];
    INT cch = StringFromGUID2 (*pguidDeviceId, szDeviceId,
                c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);
    CharLower (szDeviceId);

    // Get the devices in this class.
    //
    HDEVINFO hdi;
    HRESULT hr = HrSetupDiGetClassDevs (pguidInterfaceId, NULL, NULL,
                    DIGCF_PRESENT | DIGCF_INTERFACEDEVICE, &hdi);
    if (S_OK == hr)
    {
        BOOL fFound = FALSE;

        // abBuffer is a buffer used to get device interface detail for each
        // device interface enumerated below.
        //
        const ULONG cbDetail = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                                (MAX_PATH * sizeof(WCHAR));
        PSP_DEVICE_INTERFACE_DETAIL_DATA pDetail;

        hr = HrMalloc (cbDetail, (PVOID*)&pDetail);
        if (S_OK == hr)
        {
            // Enumerate the device interfaces looking for the one specified.
            //
            SP_DEVICE_INTERFACE_DATA did;
            ZeroMemory (&did, sizeof(did));

            for (DWORD i = 0;
                 did.cbSize = sizeof(did),
                 SetupDiEnumDeviceInterfaces (hdi, NULL,
                        const_cast<LPGUID>(pguidInterfaceId), i, &did);
                 i++)
            {
                // Now get the details so we can compare the device path.
                //
                pDetail->cbSize = sizeof(*pDetail);
                if (SetupDiGetDeviceInterfaceDetailW (hdi, &did,
                        pDetail, cbDetail, NULL, NULL))
                {
                    CharLower (pDetail->DevicePath);

                    // Look for a substring containing szDeviceId.  Also
                    // look for a substring containing pszReferenceString if
                    // it is specified.
                    //
                    if (wcsstr (pDetail->DevicePath, szDeviceId) &&
                        (!pszReferenceString || !*pszReferenceString ||
                         wcsstr (pDetail->DevicePath, pszReferenceString)))
                    {
                        // We found it, so open the device and return it.
                        //
                        HANDLE hFile = CreateFile (pDetail->DevicePath,
                                            GENERIC_READ | GENERIC_WRITE,
                                            0, NULL, OPEN_EXISTING,
                                            dwFlagsAndAttributes, NULL);
                        if (hFile && (INVALID_HANDLE_VALUE != hFile))
                        {
                            TraceTag (ttidNetcfgBase, "Found device id '%S'",
                                szDeviceId);

                            TraceTag (ttidNetcfgBase, "Opening device '%S'",
                                pDetail->DevicePath);

                            *phFile = hFile;
                            fFound = TRUE;
                        }
                        else
                        {
                            hr = HrFromLastWin32Error ();
                        }

                        // Now that we've found it, break out of the loop.
                        //
                        break;
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error ();
                }
            }

            MemFree (pDetail);
        }

        SetupDiDestroyDeviceInfoList (hdi);

        if (SUCCEEDED(hr) && !fFound)
        {
            hr = S_FALSE;
        }
    }

    TraceHr(ttidError, FAL, hr, S_FALSE == hr,
        "HrFindDeviceOnInterface (device=%S)", szDeviceId);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallSoftwareDeviceOnInterface
//
//  Purpose:    Install a software-enumerated device on the given interface.
//
//  Arguments:
//      pguidDeviceId       [in] The device id to install.
//      pguidInterfaceId    [in] The interface to install it on.
//      pszReferenceString [in] The reference string.
//      fForceInstall       [in] Usually specify FALSE.  Specify TRUE to
//                               force installation of the device using
//                               pguidClass and pszHardwareId.
//                               Typically this is used during GUI mode setup
//                               where swenum won't be able to fully install
//                               the device.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   30 Mar 1998
//
//  Notes:
//
HRESULT
HrInstallSoftwareDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    PCWSTR      pszReferenceString,
    BOOL        fForceInstall,
    PCWSTR      pszInfFilename,
    HWND        hwndParent)
{
    Assert (pguidDeviceId);
    Assert (pguidInterfaceId);
    Assert (pszReferenceString && *pszReferenceString);

    // Open the software device enumerator.
    //
    HANDLE hSwenum;
    HRESULT hr = HrOpenSoftwareDeviceEnumerator (
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                    &hSwenum);
    if (S_OK == hr)
    {
        Assert (INVALID_HANDLE_VALUE != hSwenum);

        // Enable the SE_LOAD_DRIVER_NAME privilege, required by swenum for
        // installation of new devices.
        //
        if (S_OK == (hr = HrEnablePrivilege(SE_LOAD_DRIVER_NAME)))
        {

            // Allocate and build the buffer used as the IOCTL parameter.
            //
            const ULONG cbBuf = (ULONG)FIELD_OFFSET (SWENUM_INSTALL_INTERFACE, ReferenceString) +
                                CbOfSzAndTerm (pszReferenceString);
            SWENUM_INSTALL_INTERFACE* pBuf;

            hr = HrMalloc (cbBuf, (PVOID*)&pBuf);
            if (S_OK == hr)
            {
                ZeroMemory (pBuf, cbBuf);
                pBuf->DeviceId    = *pguidDeviceId;
                pBuf->InterfaceId = *pguidInterfaceId;
                lstrcpyW (pBuf->ReferenceString, pszReferenceString);

                // Create an event to be used for the overlapped IO we are about
                // to issue.
                //
                OVERLAPPED ovl;
                ZeroMemory (&ovl, sizeof(ovl));
                ovl.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
                if (ovl.hEvent)
                {
#ifdef ENABLETRACE
                    WCHAR szDeviceId [c_cchGuidWithTerm];
                    INT cch = StringFromGUID2 (pBuf->DeviceId, szDeviceId,
                                c_cchGuidWithTerm);
                    Assert (c_cchGuidWithTerm == cch);

                    WCHAR szInterfaceId [c_cchGuidWithTerm];
                    cch = StringFromGUID2 (pBuf->InterfaceId, szInterfaceId,
                                c_cchGuidWithTerm);
                    Assert (c_cchGuidWithTerm == cch);

                    TraceTag (ttidNetcfgBase, "Installing software enumerated "
                        "device '%S' on interface '%S'",
                        szDeviceId, szInterfaceId);
#endif

                    // Issue the install interface IOCTL.
                    //
                    DWORD cbReturned;
                    BOOL fIoResult = DeviceIoControl (hSwenum,
                                        IOCTL_SWENUM_INSTALL_INTERFACE,
                                        pBuf, cbBuf, NULL, 0,
                                        &cbReturned, &ovl);
                    if (!fIoResult)
                    {
                        hr = HrFromLastWin32Error ();
                        if (HRESULT_FROM_WIN32 (ERROR_IO_PENDING) == hr)
                        {
                            // Wait for the IO to complete if it was returned as
                            // pending.
                            //
                            fIoResult = GetOverlappedResult (hSwenum, &ovl,
                                            &cbReturned, TRUE);
                            if (!fIoResult)
                            {
                                hr = HrFromLastWin32Error ();
                            }
                        }
                    }

                    CloseHandle (ovl.hEvent);
                }

                MemFree (pBuf);
            }
        }

        CloseHandle (hSwenum);
    }

    // Force the device to be installed by enumerating it.
    //
    if ((S_OK == hr) && fForceInstall)
    {
        HANDLE hDevice;

        hr = HrFindDeviceOnInterface (
                pguidDeviceId,
                pguidInterfaceId,
                pszReferenceString,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                &hDevice);

        if (S_OK == hr)
        {
            CloseHandle (hDevice);
        }
        else if (S_FALSE == hr)
        {
            // We just installed this device, why wasn't it found?
            //
            hr = E_UNEXPECTED;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrInstallSoftwareDeviceOnInterface");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrInstallFromInfSectionInFile
//
// Purpose:   Open the given INF file and call Setup API to install
//            from the specified section.
//
// Arguments:
//    hwndParent    [in]  handle of parent window
//    szInfName     [in]  name of INF
//    szSection     [in]  section name
//    hkeyRelative  [in]  handle of reg-key to use
//    fQuietInstall [in]  TRUE if we shouldn't show UI and use
//                        default values, FALSE if we can bother
//                        the user with questions and UI
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT HrInstallFromInfSectionInFile (
    IN HWND    hwndParent,
    IN PCWSTR  pszInfName,
    IN PCWSTR  pszSection,
    IN HKEY    hkeyRelative,
    IN BOOL    fQuietInstall)
{
    AssertValidReadPtr(pszInfName);
    AssertValidReadPtr(pszSection);

    HRESULT hr;
    HINF    hinf;

    hr = HrSetupOpenInfFile(pszInfName, NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL, &hinf);
    if (S_OK == hr)
    {
        hr = HrSetupInstallFromInfSection (hwndParent, hinf, pszSection,
                SPINST_REGISTRY, hkeyRelative, NULL, 0, NULL, NULL,
                NULL, NULL);
    }

    TraceError("HrInstallInfSectionInfFile", hr);
    return hr;
}

#if defined(REMOTE_BOOT)
//+--------------------------------------------------------------------------
//
//  Function:   HrIsRemoteBootAdapter
//
//  Purpose:    This determines whether the adapter is a remote boot adapter
//
//  Arguments:
//      hdi         [in]  See Device Installer Api for more info
//      pdeid       [in]  See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if adapter is a remote boot adapter
//                       S_FALSE if adapter is not a remote boot adapter
//                       a Win32 converted error otherwise
//
//
//  Author:     billbe   31 Jan 1998
//
//  Notes:
//
HRESULT
HrIsRemoteBootAdapter(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    DWORD dwConfigFlags;

    // Get the current config flags
    HRESULT hr = HrSetupDiGetDeviceRegistryProperty(hdi, pdeid,
            SPDRP_CONFIGFLAGS, NULL, (BYTE*)&dwConfigFlags,
            sizeof(dwConfigFlags), NULL);

    if (SUCCEEDED(hr))
    {
        if (dwConfigFlags & CONFIGFLAG_NETBOOT_CARD)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
    {
        // The device had no config flags, so it isn't a remote boot adapter
        hr = S_FALSE;
    }


    TraceError("HrIsRemoteBootAdapter", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}
#endif // defined(REMOTE_BOOT)

VOID
SetupDiDestroyDeviceInfoListSafe(HDEVINFO hdi)
{
    if (IsValidHandle(hdi))
    {
        SetupDiDestroyDeviceInfoList(hdi);
    }
}

VOID
SetupCloseInfFileSafe(HINF hinf)
{
    if (IsValidHandle(hinf))
    {
        SetupCloseInfFile(hinf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncsvc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S V C . C P P
//
//  Contents:   Implementation of non-inline CService and CServiceManager
//              methods.
//
//  Notes:
//
//  Author:     mikemi      6 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncstring.h"
#include "ncsvc.h"
#include "ncmisc.h"
#include "ncperms.h"

struct CSCTX
{
    SC_HANDLE       hScm;
    const CSFLAGS*  pFlags;
    DWORD           dwErr;

    // This just allows us to save some stack space otherwise wasted by
    // recursion.
    //
    SERVICE_STATUS  status;
};

VOID
SvcControlServicesAndWait (
    CSCTX*          pCtx,
    UINT            cServices,
    const PCWSTR*   apszServices);


VOID
StopDependentServices (
    SC_HANDLE   hSvc,
    PCWSTR      pszService,
    CSCTX*      pCtx)
{
    // Try a first guess of 256 bytes for the buffer needed to hold the
    // dependent information.  If that fails, retry with the buffer size
    // returned from EnumDependentServices.
    //
    DWORD                   cbBuf   = 256;
    ENUM_SERVICE_STATUS*    aess    = NULL;
    DWORD                   cess    = 0;
    DWORD                   dwErr   = ERROR_SUCCESS;
    INT                     cLoop   = 0;
    const INT               cLoopMax = 2;
    do
    {
        // Allocate the needed space if we know it.
        //
        if (cbBuf)
        {
            MemFree (aess);
            aess = reinterpret_cast<ENUM_SERVICE_STATUS*>(MemAlloc (cbBuf));
            if (!aess)
            {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }
        }
        dwErr = ERROR_SUCCESS;
        if (!EnumDependentServices (hSvc, SERVICE_ACTIVE, aess, cbBuf,
                &cbBuf, &cess))
        {
            dwErr = GetLastError ();
        }
    }
    while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

    // If we have some services to stop, stop them and wait.
    //
    if ((ERROR_SUCCESS == dwErr) && cess)
    {
        // The array of ENUM_SERVICE_STATUS has the service names but not
        // in a form that can be passed directly to
        // SvcControlServicesAndWait, so we must transform the data into
        // an array of string pointers.
        //
        PCWSTR* apszServices = reinterpret_cast<PCWSTR*>(
                    PvAllocOnStack (cess * sizeof(PCWSTR)));
        for (UINT i = 0; i < cess; i++)
        {
            apszServices[i] = aess[i].lpServiceName;
        }

        Assert (SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl);

        TraceTag (ttidSvcCtl, "Stopping dependents of %S...", pszService);

        SvcControlServicesAndWait (pCtx, cess, apszServices);
    }

    // Otherwise, if we've had an error, but there is no context error yet,
    // propagate our error to the context error for the caller.
    //
    else if ((ERROR_SUCCESS != dwErr) && (ERROR_SUCCESS == pCtx->dwErr))
    {
        pCtx->dwErr = dwErr;
    }

    MemFree (aess);
}

VOID
SvcControlServicesAndWait (
    CSCTX*          pCtx,
    UINT            cServices,
    const PCWSTR*   apszServices)
{
    BOOL  fr = TRUE;
    DWORD dwErr;

    // We only set this to TRUE if we successfuly open and control
    // at least one service in the first phase.
    //
    BOOL fWaitIfNeeded = FALSE;

    // Allocate a buffer (on the stack) to place the opened service
    // handles in and zero it.
    //
    size_t cb = cServices * sizeof(SC_HANDLE);

    SC_HANDLE* ahSvc = reinterpret_cast<SC_HANDLE*>
        (PvAllocOnStack (cb));

    ZeroMemory (ahSvc, cb);

    // For each service, open it and apply the requested control
    // (if requested).  If the control succeeds, add the handle to
    // our array for later use.
    //

    for (UINT i = 0; i < cServices; i++)
    {
        // Open the service.
        //
        SC_HANDLE hSvc = OpenService (pCtx->hScm,
                            apszServices[i],
                            SERVICE_QUERY_CONFIG |
                            SERVICE_QUERY_STATUS |
                            SERVICE_ENUMERATE_DEPENDENTS |
                            SERVICE_START | SERVICE_STOP |
                            SERVICE_USER_DEFINED_CONTROL);
        if (hSvc)
        {
            // If we're to ignore demand-start and disabled services,
            // check for it now and skip if needed.  Remember to close
            // the service handle because we're going to open the next if
            // we skip this one.
            //
            if (pCtx->pFlags->fIgnoreDisabledAndDemandStart)
            {
                BOOL fSkip = FALSE;

                LPQUERY_SERVICE_CONFIG pConfig;
                if (SUCCEEDED(HrQueryServiceConfigWithAlloc (hSvc, &pConfig)))
                {
                    if ((pConfig->dwStartType == SERVICE_DEMAND_START) ||
                        (pConfig->dwStartType == SERVICE_DISABLED))
                    {
                        fSkip = TRUE;

                        TraceTag (ttidSvcCtl, "Skipping %S because its start "
                            "type is %d.",
                            apszServices[i],
                            pConfig->dwStartType);
                    }

                    // Free our memory before we continue.
                    //
                    MemFree (pConfig);

                    if (fSkip)
                    {
                        CloseServiceHandle (hSvc);
                        continue;
                    }
                }
            }

            // Initialize fr and dwErr assuming that something goes wrong.
            // fr and dwErr should always be set to something in the following
            // if,else statement.
            //
            fr = FALSE;
            dwErr = ERROR_INVALID_DATA;

            // Start or Control the service if requested.  (Or do nothing
            // if we just want to wait.
            //
            if (pCtx->pFlags->fStart)
            {
                TraceTag (ttidSvcCtl, "Starting %S", apszServices[i]);

                fr = StartService (hSvc, 0, NULL);
                if (!fr)
                {
                    dwErr = GetLastError ();
                }
            }
            else if (pCtx->pFlags->dwControl)
            {
                // Stop dependent services if we're stopping the service.
                //
                if (SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl)
                {
                    // We don't need to worry about the success or failure
                    // of this call here.  It simply recurses into this
                    // function so pCtx->dwErr will be set however we set
                    // it in this function on the next recursion.
                    //
                    StopDependentServices (hSvc, apszServices[i], pCtx);

                    //
                    //  Now handle any special cases
                    //
                    if (0 == _wcsicmp(L"Netbios", apszServices[i]))
                    {
                        TraceTag (ttidSvcCtl, "Running special-case code to stop NetBIOS");
                        ScStopNetbios();
                    }

                    TraceTag (ttidSvcCtl, "Stopping %S", apszServices[i]);
                }

                fr = ControlService (hSvc, pCtx->pFlags->dwControl,
                            &pCtx->status);
                if (!fr)
                {
                    dwErr = GetLastError ();
                }

                TraceTag(ttidSvcCtl,
                        "Just issued control (0x%x) to %S. ret=%u (dwErr=%u), status.dwCurrentState=0x%x",
                        pCtx->pFlags->dwControl,
                        apszServices[i],
                        fr,
                        (!fr) ? dwErr : ERROR_SUCCESS,
                        pCtx->status.dwCurrentState);

                if (!fr)
                {
                    if ((SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl) &&
                        ((ERROR_INVALID_SERVICE_CONTROL == dwErr) ||
                         (ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dwErr)))
                    {
                        if (SERVICE_STOP_PENDING == pCtx->status.dwCurrentState)
                        {
                            TraceTag(ttidSvcCtl,
                                    "Issued stop to service %S which is pending stop",
                                    apszServices[i]);
                            // This is an okay condition.  We want to wait on
                            // this service below.
                            //
                            fr = TRUE;
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                }
            }

            if (fr)
            {
                // We have at least one handle, indicate we may
                // need to wait below and save the handle so the
                // the wait code will use it.
                //
                fWaitIfNeeded = TRUE;
                ahSvc[i] = hSvc;
            }
            else
            {
                Assert (!ahSvc[i]); // don't want to wait on this index
                Assert (ERROR_SUCCESS != dwErr); // obtained above

                if (SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl)
                {
                    // We can ignore service not running errors.
                    //
                    // the first part of the OR is for the service case,
                    // the 2nd handles the driver and service cases respectively.
                    //
                    if ((ERROR_SERVICE_NOT_ACTIVE == dwErr) ||
                        (((ERROR_INVALID_SERVICE_CONTROL == dwErr) ||
                          (ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dwErr)) &&
                         (SERVICE_STOPPED == pCtx->status.dwCurrentState)))
                    {
                        TraceTag(ttidSvcCtl,
                                "Issued stop to service %S which is already stopped",
                                apszServices[i]);
                        dwErr = ERROR_SUCCESS;
                    }
                }
                else if (pCtx->pFlags->fStart)
                {
                    // We can ignore service already running errors.
                    //
                    if (ERROR_SERVICE_ALREADY_RUNNING == dwErr)
                    {
                        TraceTag(ttidSvcCtl,
                                "Issued start to service %S which is already running",
                                apszServices[i]);
                        dwErr = ERROR_SUCCESS;
                    }
                }

                // If we still have an error, time to remember it and move on.
                //
                if (ERROR_SUCCESS != dwErr)
                {
                    // Keep going, but note that we have an error.
                    //
                    pCtx->dwErr = dwErr;

                    TraceHr (ttidError, FAL,
                        HRESULT_FROM_WIN32 (dwErr), FALSE,
                        "SvcControlServicesAndWait: %s (%S)",
                        (pCtx->pFlags->fStart) ?
                            "StartService" : "ControlService",
                        apszServices[i]);
                }

                CloseServiceHandle (hSvc);
            }
        }
#ifdef ENABLETRACE
        else
        {
            TraceHr (ttidError, FAL, HrFromLastWin32Error (), FALSE,
                "SvcControlServicesAndWait: OpenService (%S)",
                apszServices[i]);
        }
#endif
    }

    // For each service, wait for it to enter the requested state
    // (if requested).
    //
    if (fWaitIfNeeded &&
        pCtx->pFlags->dwMaxWaitMilliseconds && pCtx->pFlags->dwStateToWaitFor)
    {
        // We wait in increments of 100 milliseconds.  Therefore, the
        // total number of checks to perform is dwMaxWaitMilliseconds
        // divided by 100 with a minimum of one check.
        //
        const UINT cmsWait = 100;
        UINT cLoop = pCtx->pFlags->dwMaxWaitMilliseconds / cmsWait;
        if (0 == cLoop)
        {
            cLoop = 1;
        }

        // Wait the request number of times...
        // (Assume we timeout)
        //
        dwErr = ERROR_TIMEOUT;
        for (UINT nLoop = 0; nLoop < cLoop; nLoop++, Sleep (cmsWait))
        {
            // Querying the state of the service to see if its entered
            // the requested state.  We can quit the outer loop early
            // if all services have entered the requested state.
            //
            BOOL fAllDone = TRUE;
            for (i = 0; i < cServices; i++)
            {
                // Skip services that have already entered the state or
                // that we never opened.
                //
                if (!ahSvc[i])
                {
                    continue;
                }

                fr = QueryServiceStatus (ahSvc[i], &pCtx->status);
                if (fr)
                {
                    if (pCtx->status.dwCurrentState !=
                        pCtx->pFlags->dwStateToWaitFor)
                    {
                        // Not there yet.  We'll need to check this
                        // again and we now know we're definately not
                        // all done.
                        //
                        fAllDone = FALSE;
                    }
                    else
                    {
                        // No need to check this service anymore,
                        // its in the right state.
                        //
                        CloseServiceHandle (ahSvc[i]);
                        ahSvc[i] = NULL;
                    }
                }
#ifdef ENABLETRACE
                else
                {
                    TraceHr (ttidError, FAL, HrFromLastWin32Error (), FALSE,
                        "SvcControlServicesAndWait: QueryServiceStatus (%S)",
                        apszServices[i]);
                }
#endif
            }

            if (fAllDone)
            {
                dwErr = ERROR_SUCCESS;
                break;
            }
        }

        // If we had an error in the above wait (like a timeout), and
        // we haven't had any prior errors, remember this new one for the
        // caller.
        //
        if ((ERROR_SUCCESS != dwErr) && (ERROR_SUCCESS == pCtx->dwErr))
        {
            pCtx->dwErr = dwErr;
        }
    }

    // Close the remaining open service handles.
    //
    for (i = 0; i < cServices; i++)
    {
        if (ahSvc[i])
        {
            CloseServiceHandle (ahSvc[i]);

#ifdef ENABLETRACE
            if (fWaitIfNeeded &&
                pCtx->pFlags->dwMaxWaitMilliseconds &&
                pCtx->pFlags->dwStateToWaitFor)
            {
                TraceTag (ttidSvcCtl, "%S did not %s within %i milliseconds",
                    apszServices[i],
                    (SERVICE_RUNNING == pCtx->pFlags->dwStateToWaitFor)
                        ? "start" : "stop",
                    pCtx->pFlags->dwMaxWaitMilliseconds);
            }
#endif
        }
    }
}

HRESULT
HrQueryServiceConfigWithAlloc (
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIG* ppConfig)
{
    // Initial guess for the buffer size is the structure size plus
    // room for 5 strings of 32 characters each.  (since there are
    // 5 strings in the structure.)
    //
    static DWORD cbBufGuess = sizeof (QUERY_SERVICE_CONFIG) +
                              5 * (32 * sizeof(WCHAR));

    DWORD                   cbBuf    = cbBufGuess;
    LPQUERY_SERVICE_CONFIG  pConfig  = NULL;
    DWORD                   dwErr    = ERROR_SUCCESS;
    INT                     cLoop    = 0;
    const INT               cLoopMax = 2;

    do
    {
        // If we require more room, allocate the needed space.
        //
        MemFree (pConfig);
        pConfig = (LPQUERY_SERVICE_CONFIG)MemAlloc (cbBuf);
        if (!pConfig)
        {
            dwErr = ERROR_OUTOFMEMORY;
            break;
        }

        BOOL fr = QueryServiceConfig (hService, pConfig, cbBuf, &cbBuf);
        if (fr)
        {
            dwErr = ERROR_SUCCESS;

            // Update our guess for next time to be what QueryServiceConfig
            // says we needed.  But only do so if we needed more than our
            // guess.
            //
            if (cbBuf > cbBufGuess)
            {
                cbBufGuess = cbBuf;
            }
        }
        else
        {
            dwErr = GetLastError ();

#ifdef ENABLETRACE
            if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
                TraceTag (ttidSvcCtl,
                    "Perf: Guessed buffer size incorrectly calling "
                    "QueryServiceConfig.\nNeeded %d bytes.  "
                    "(Guessed %d bytes.)",
                    cbBuf,
                    cbBufGuess);
            }
#endif
        }
    }
    while ((ERROR_INSUFFICIENT_BUFFER == dwErr) && (++cLoop < cLoopMax));

    AssertSz (cLoop < cLoopMax, "Why can we never allocate a buffer big "
                "enough for QueryServiceConfig when its telling us how big "
                "the buffer should be?");

    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    if (S_OK == hr)
    {
        *ppConfig = pConfig;
    }
    else
    {
        MemFree (pConfig);
        *ppConfig = NULL;
    }

    TraceError ("HrQueryServiceConfigWithAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrChangeServiceStartType
//
//  Purpose:    Changes the start type of the given service to the given type.
//
//  Arguments:
//      pszServiceName [in]  Name of service to change.
//      dwStartType    [in]  New start type for service. See the Win32
//                           documentation on ChangeServiceConfig for the valid
//                           service start type values.
//
//  Returns:    S_OK if succeeded, HRESULT_FROM_WIN32 error code otherwise.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Don't call this function too many times. It is fairly
//              inefficient.
//
HRESULT
HrChangeServiceStartType (
    IN PCWSTR pszServiceName,
    IN DWORD dwStartType)
{
    CServiceManager scm;
    CService        svc;

    HRESULT hr = scm.HrOpenService (&svc, pszServiceName, WITH_LOCK);
    if (S_OK == hr)
    {
        hr = svc.HrSetStartType(dwStartType);
    }

    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr,
        "HrChangeServiceStartType");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrChangeServiceStartTypeOptional
//
//  Purpose:    Changes the start type of the given service to the given type.
//
//  Arguments:
//      pszServiceName [in]  Name of service to change.
//      dwStartType    [in]  New start type for service. See the Win32
//                           documentation on ChangeServiceConfig for the valid
//                           service start type values.
//
//  Returns:    S_OK if succeeded, NETCFG_E_SVC_* error otherwise.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      If the service does not exist, nothing is done.
//
HRESULT
HrChangeServiceStartTypeOptional (
    IN PCWSTR pszServiceName,
    IN DWORD dwStartType)
{
    HRESULT hr = HrChangeServiceStartType (pszServiceName, dwStartType);
    if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr)
    {
        hr = S_OK;
    }
    TraceError ("HrChangeServiceStartTypeOptional", hr);
    return hr;
}

HRESULT
HrSvcQueryStatus (
    IN PCWSTR pszService,
    OUT DWORD* pdwState)
{
    Assert (pszService);
    Assert (pdwState);

    *pdwState = 0;

    CServiceManager scm;
    CService        svc;

    HRESULT hr = scm.HrOpenService (&svc, pszService, NO_LOCK,
                        SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);
    if (S_OK == hr)
    {
        hr = svc.HrQueryState (pdwState);
    }

    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr,
        "HrSvcQueryStatus");
    return hr;
}

VOID
CService::Close ()
{
    if (_schandle)
    {
        BOOL fr = ::CloseServiceHandle( _schandle );
        AssertSz(fr, "CloseServiceHandle failed!");

        _schandle = NULL;
    }
}

HRESULT
CService::HrControl (
    IN DWORD   dwControl)
{
    Assert (_schandle);

    HRESULT hr = S_OK;

    SERVICE_STATUS status;
    if (!::ControlService (_schandle, dwControl, &status))
    {
        hr = HrFromLastWin32Error ();
    }

    TraceError ("CService::HrControl", hr);
    return hr;
}

HRESULT
CService::HrRequestStop ()
{
    Assert (_schandle);

    HRESULT hr = S_OK;

    SERVICE_STATUS status;
    if (!::ControlService (_schandle, SERVICE_CONTROL_STOP, &status))
    {
        hr = HrFromLastWin32Error ();

        // Don't consider it an error if the service is not running.
        //

        if (HRESULT_FROM_WIN32 (ERROR_SERVICE_NOT_ACTIVE) == hr)
        {
            hr = S_OK;
        }

        // (driver case) ERROR_INVALID_SERVICE_CONTROL is returned if the service
        // is not running - which may mean pending_stop.
        // (non-driver case) ERROR_SERVICE_CANNOT_ACCEPT_CTRL is returned if the
        // service is either stop_pending or stopped.
        // ... so in either case we need to query for the state.
        //
        if (((HRESULT_FROM_WIN32 (ERROR_INVALID_SERVICE_CONTROL) == hr) ||
             (HRESULT_FROM_WIN32 (ERROR_SERVICE_CANNOT_ACCEPT_CTRL) == hr)) &&
            (SERVICE_STOPPED == status.dwCurrentState))
        {
            hr = S_OK;
        }
    }
    TraceError ("CService::HrRequestStop", hr);
    return hr;
}

HRESULT
CService::HrQueryState (
    OUT DWORD*  pdwState)
{
    Assert (pdwState);
    Assert (_schandle);

    SERVICE_STATUS sStatus;
    if (!::QueryServiceStatus( _schandle, &sStatus ))
    {
        *pdwState = 0;
        return ::HrFromLastWin32Error();
    }
    *pdwState = sStatus.dwCurrentState;
    return S_OK;
}

HRESULT
CService::HrQueryStartType (
    OUT DWORD*  pdwStartType)
{
    Assert (pdwStartType);

    *pdwStartType = 0;

    LPQUERY_SERVICE_CONFIG pConfig;
    HRESULT hr = HrQueryServiceConfig (&pConfig);
    if (S_OK == hr)
    {
        *pdwStartType = pConfig->dwStartType;

        MemFree (pConfig);
    }

    TraceError ("CService::HrQueryStartType", hr);
    return hr;
}

HRESULT
CService::HrSetServiceRestartRecoveryOption(
    IN SERVICE_FAILURE_ACTIONS *psfa
      )
{
    HRESULT     hr = S_OK;

    if (!ChangeServiceConfig2(_schandle,
                              SERVICE_CONFIG_FAILURE_ACTIONS,
                              (LPVOID)psfa))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("CService::HrSetServiceRestartRecoveryOption", hr);
    return hr;
}

CServiceManager::~CServiceManager ()
{
    if (_sclock)
    {
        Unlock();
    }
    if (_schandle)
    {
        Close();
    }
}

VOID
CServiceManager::Close ()
{
    Assert (_schandle);

    BOOL fr = ::CloseServiceHandle (_schandle);
    AssertSz (fr, "CloseServiceHandle failed!");

    _schandle = NULL;
}

HRESULT
CServiceManager::HrControlServicesAndWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices,
    IN const CSFLAGS* pFlags)
{
    Assert (cServices);
    Assert (apszServices);
    Assert (pFlags);

    // Make sure we have something to do before wasting time.
    //
    Assert (   (pFlags->fStart || pFlags->dwControl)
            || (pFlags->dwMaxWaitMilliseconds && pFlags->dwStateToWaitFor));

    HRESULT hr = S_OK;

    if (!_schandle)
    {
        hr = HrOpen (NO_LOCK, SC_MANAGER_CONNECT);
    }

    if (S_OK == hr)
    {
        Assert (_schandle);

        // Setup the context structure and call the internal routine (which
        // may recurse which is why we use the context structure).
        //
        CSCTX ctx;
        ZeroMemory (&ctx, sizeof(ctx));
        ctx.hScm   = _schandle;
        ctx.pFlags = pFlags;
        SvcControlServicesAndWait (&ctx, cServices, apszServices);

        hr = HRESULT_FROM_WIN32 (ctx.dwErr);
    }

    TraceError ("CServiceManager::HrControlServicesAndWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStartServicesNoWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices)
{
    CSFLAGS flags =
        { TRUE, 0, 0, SERVICE_RUNNING, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStartServicesNoWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStartServicesAndWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices,
    IN DWORD dwWaitMilliseconds /*= 15000*/)
{
    CSFLAGS flags =
        { TRUE, 0, dwWaitMilliseconds, SERVICE_RUNNING, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStartServicesAndWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStopServicesNoWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices)
{
    CSFLAGS flags =
        { FALSE, SERVICE_CONTROL_STOP, 0, SERVICE_STOPPED, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStopServicesNoWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStopServicesAndWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices,
    IN DWORD dwWaitMilliseconds /*= 15000*/)
{
    CSFLAGS flags =
        { FALSE, SERVICE_CONTROL_STOP, dwWaitMilliseconds, SERVICE_STOPPED, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStopServicesAndWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrCreateService (
    IN CService* pcsService,
    IN PCWSTR    pszServiceName,
    IN PCWSTR    pszDisplayName,
    IN DWORD     dwServiceType,
    IN DWORD     dwStartType,
    IN DWORD     dwErrorControl,
    IN PCWSTR    pszBinaryPathName,
    IN PCWSTR    pslzDependencies,
    IN PCWSTR    pszLoadOrderGroup,
    IN PDWORD    pdwTagId,
    IN DWORD     dwDesiredAccess,
    IN PCWSTR    pszServiceStartName,
    IN PCWSTR    pszPassword,
    IN PCWSTR    pszDescription)
{
    HRESULT hr = S_OK;

    // Open the service control manager if needed.
    //
    if (!_schandle)
    {
        hr = HrOpen ();
    }

    if (S_OK == hr)
    {
        // make sure the service is not in use
        //
        if (pcsService->_schandle)
        {
            pcsService->Close();
        }
        pcsService->_schandle = ::CreateService (_schandle,
                                    pszServiceName,
                                    pszDisplayName,
                                    dwDesiredAccess,
                                    dwServiceType,
                                    dwStartType,
                                    dwErrorControl,
                                    pszBinaryPathName,
                                    pszLoadOrderGroup,
                                    pdwTagId,
                                    pslzDependencies,
                                    pszServiceStartName,
                                    pszPassword );

        if (!pcsService->_schandle)
        {
            hr = HrFromLastWin32Error ();
        }
        else
        {
            // Set the description is one is supplied
            //
            if (pszDescription)
            {
                SERVICE_DESCRIPTION sd = {0};

                sd.lpDescription = (PWSTR)pszDescription;
                (VOID)ChangeServiceConfig2(pcsService->_schandle,
                                           SERVICE_CONFIG_DESCRIPTION, &sd);
            }
        }
    }
    TraceError ("CServiceManager::HrCreateService", hr);
    return hr;
}

HRESULT
CServiceManager::HrQueryLocked (
    OUT BOOL*   pfLocked)
{
    LPQUERY_SERVICE_LOCK_STATUS pqslStatus = NULL;
    DWORD   cbNeeded = sizeof( QUERY_SERVICE_LOCK_STATUS );
    DWORD   cbSize;
    BOOL    frt;

    Assert(_schandle != NULL );
    Assert(pfLocked != NULL);

    *pfLocked = FALSE;

    // loop, allocating the needed size
    do
    {
        pqslStatus = (LPQUERY_SERVICE_LOCK_STATUS) MemAlloc (cbNeeded);
        if (pqslStatus == NULL)
        {
            return E_OUTOFMEMORY;
        }
        cbSize = cbNeeded;

        frt = ::QueryServiceLockStatus( _schandle,
                pqslStatus,
                cbSize,
                &cbNeeded );
        *pfLocked = pqslStatus->fIsLocked;
        MemFree (pqslStatus);
        pqslStatus = NULL;
        if (!frt && (cbNeeded == cbSize))
        {
            // if an error, treat this as a lock
            return ::HrFromLastWin32Error();
        }

    } while (!frt && (cbNeeded != cbSize));

    return S_OK;
}

HRESULT
CServiceManager::HrLock ()
{
    INT        cRetries   = 30;
    const INT  c_msecWait = 1000;

    Assert (_schandle != NULL);
    Assert (_sclock == NULL);

    while (cRetries--)
    {
        _sclock = ::LockServiceDatabase( _schandle );
        if (_sclock)
        {
            return S_OK;
        }
        else
        {
            HRESULT hr = HrFromLastWin32Error();

            if ((HRESULT_FROM_WIN32(ERROR_SERVICE_DATABASE_LOCKED) != hr) ||
                (0 == cRetries))
            {
                return hr;
            }

            TraceTag(ttidSvcCtl, "SCM is locked, waiting for %d "
                     "seconds before retrying...", c_msecWait / 1000);

            // wait for a bit to see if the database unlocks in that
            // time.
            Sleep (c_msecWait);
        }
    }

    AssertSz (FALSE, "Lock me Amadeus! I'm not supposed to get here!");
    return S_OK;
}

HRESULT
CServiceManager::HrOpen (
    CSLOCK eLock,              // = NO_LOCK
    DWORD dwDesiredAccess,    // = SC_MANAGER_ALL_ACCESS
    PCWSTR pszMachineName,     // = NULL
    PCWSTR pszDatabaseName     // = NULL
    )
{
    HRESULT hr = S_OK;

    if (_schandle)
    {
        Close();
    }
    _schandle = ::OpenSCManager (pszMachineName, pszDatabaseName,
                    dwDesiredAccess );
    if (_schandle)
    {
        if (WITH_LOCK == eLock)
        {
            hr = HrLock ();
        }
    }
    else
    {
        hr = ::HrFromLastWin32Error();
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CServiceManager::HrOpen failed. eLock=%d dwDesiredAccess=0x%08x",
        eLock, dwDesiredAccess);
    return hr;
}

HRESULT
CServiceManager::HrOpenService (
    CService*   pcsService,
    PCWSTR      pszServiceName,
    CSLOCK      eLock,          // = NO_LOCK
    DWORD       dwScmAccess,    // = SC_MANAGER_ALL_ACCESS
    DWORD       dwSvcAccess     // = SERVICE_ALL_ACCESS
    )
{
    HRESULT hr = S_OK;

    // Open the service control manager if needed.
    //
    if (!_schandle)
    {
        hr = HrOpen (eLock, dwScmAccess);
    }

    if (S_OK == hr)
    {
        // make sure the service is not in use
        //
        if (pcsService->_schandle)
        {
            pcsService->Close();
        }

        pcsService->_schandle = ::OpenService (_schandle,
                                    pszServiceName,
                                    dwSvcAccess);
        if (!pcsService->_schandle)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr),
        "CServiceManager::HrOpenService failed opening '%S'", pszServiceName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceManager::HrAddRemoveServiceDependency
//
//  Purpose:    Add/remove dependency to a service
//
//  Arguments:
//      pszService [in]     Name of service
//      pszDependency [in]  Dependency to add
//      enumFlag [in]       Indicates add or remove
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     tongl   17 Jun 1997
//
//  Notes: this function is not for adding/removing group dependency
//
HRESULT
CServiceManager::HrAddRemoveServiceDependency (
    PCWSTR                  pszServiceName,
    PCWSTR                  pszDependency,
    DEPENDENCY_ADDREMOVE    enumFlag)
{
    HRESULT hr = S_OK;

    Assert(pszServiceName);
    Assert(pszDependency);
    Assert((enumFlag == DEPENDENCY_ADD) || (enumFlag == DEPENDENCY_REMOVE));

    // If either string is empty, do nothing
    if (*pszServiceName && *pszDependency)
    {
        hr = HrLock();
        if (S_OK == hr)
        {
            PCWSTR pszSrv = pszDependency;

            CService    svc;
            // Check if the dependency service exists
            hr = HrOpenService(&svc, pszDependency);

            if (S_OK == hr)
            {
                // Open the service we are changing dependency on
                pszSrv = pszServiceName;
                hr = HrOpenService(&svc, pszServiceName);
                if (S_OK == hr)
                {
                    LPQUERY_SERVICE_CONFIG pConfig;
                    hr = svc.HrQueryServiceConfig (&pConfig);
                    if (S_OK == hr)
                    {
                        BOOL fChanged = FALSE;

                        if (enumFlag == DEPENDENCY_ADD)
                        {
                            PWSTR pmszNewDependencies;

                            hr = HrAddSzToMultiSz(
                                    pszDependency,
                                    pConfig->lpDependencies,
                                    STRING_FLAG_DONT_MODIFY_IF_PRESENT |
                                    STRING_FLAG_ENSURE_AT_END, 0,
                                    &pmszNewDependencies,
                                    &fChanged);
                            if ((S_OK == hr) && fChanged)
                            {
                                Assert (pmszNewDependencies);

                                hr = svc.HrSetDependencies (pmszNewDependencies);
                                MemFree (pmszNewDependencies);
                            }
                        }
                        else if (enumFlag == DEPENDENCY_REMOVE)
                        {
                            RemoveSzFromMultiSz(
                                    pszDependency,
                                    pConfig->lpDependencies,
                                    STRING_FLAG_REMOVE_ALL,
                                    &fChanged);
                            if (fChanged)
                            {
                                hr = svc.HrSetDependencies (pConfig->lpDependencies);
                            }
                        }

                        MemFree (pConfig);
                    }
                }
            }

            if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr) // If either services do not exist
            {
                TraceTag(ttidSvcCtl, "CServiceManager::HrAddServiceDependency, Service %s does not exist.", pszSrv);
                hr = S_OK;
            }

            Unlock();
        }

    } // if szDependency is not empty string

    TraceError("CServiceManager::HrAddRemoveServiceDependency", hr);
    return hr;
}

VOID
CServiceManager::Unlock ()
{
    Assert (_schandle);
    Assert (_sclock);

    BOOL fr = ::UnlockServiceDatabase (_sclock);
    AssertSz (fr, "UnlockServiceDatabase failed!");

    _sclock = NULL;
}
//+---------------------------------------------------------------------------
//
//  Function:   AllocateAndInitializeAcl
//
//  Purpose:    Combine the common operation of allocation and initialization
//              of an ACL.  Similiar to AllocateAndInitializeSid.
//
//  Arguments:
//      cbAcl         [in]  size in bytes of ACL
//      dwAclRevision [in]  ACL_REVISION
//      ppAcl         [out] the returned ACL
//
//  Returns:    TRUE if successful, FALSE if not.
//
//  Author:     shaunco   4 Sep 1997
//
//  Notes:
//
BOOL
AllocateAndInitializeAcl (
    DWORD   cbAcl,
    DWORD   dwAclRevision,
    PACL*   ppAcl)
{
    Assert (ppAcl);
    *ppAcl = reinterpret_cast<PACL>(LocalAlloc (LPTR,
                static_cast<UINT>(cbAcl)));
    if (*ppAcl)
    {
        return InitializeAcl (*ppAcl, cbAcl, dwAclRevision);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncstrs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R S . C P P
//
//  Contents:   Common strings for the various NetCfg projects.
//
//  Notes:
//
//  Author:     danielwe   16 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

CONST_GLOBAL WCHAR c_szRegKeyRefCounts[]        = L"RefCounts";
CONST_GLOBAL WCHAR c_szRegValueComponentId[]    = L"ComponentId";
CONST_GLOBAL WCHAR c_szBusType[]                = L"BusType";

// DLL names and aliases
//
CONST_GLOBAL WCHAR c_szNetCfgDll[]              = L"netcfgx.dll";
CONST_GLOBAL WCHAR c_szNetShellDll[]            = L"netshell.dll";
CONST_GLOBAL WCHAR c_szNetUpgradeDll[]          = L"netupgrd.dll";

// other file names
CONST_GLOBAL WCHAR c_szNetCfgHelpFile[]         = L"netcfg.hlp";

// Delimiters and other globals
CONST_GLOBAL WCHAR c_szEmpty[]                  = L"";
CONST_GLOBAL WCHAR c_szBackslash[]              = L"\\";
CONST_GLOBAL WCHAR c_szSpace[]                  = L" ";
CONST_GLOBAL WCHAR c_szDevice[]                 = L"\\Device\\";
CONST_GLOBAL WCHAR c_szYes[]                    = L"Yes";
CONST_GLOBAL WCHAR c_szNo[]                     = L"No";

// Service names
CONST_GLOBAL WCHAR c_szSvcBrowser[]             = L"Browser";
CONST_GLOBAL WCHAR c_szSvcDhcpRelayAgent[]      = L"RelayAgent";
CONST_GLOBAL WCHAR c_szSvcDhcpServer[]          = L"DHCPServer";
CONST_GLOBAL WCHAR c_szSvcDnscache[]            = L"Dnscache";
CONST_GLOBAL WCHAR c_szSvcLmHosts[]             = L"LmHosts";
CONST_GLOBAL WCHAR c_szSvcLmServer[]            = L"LanmanServer";
CONST_GLOBAL WCHAR c_szSvcMessenger[]           = L"Messenger";
CONST_GLOBAL WCHAR c_szSvcNTLMSsp[]             = L"NtLmSsp";
CONST_GLOBAL WCHAR c_szSvcNWCWorkstation[]      = L"NWCWorkstation";
CONST_GLOBAL WCHAR c_szSvcNwlnkIpx[]            = L"NwlnkIpx";
CONST_GLOBAL WCHAR c_szSvcNetBIOS[]             = L"NetBIOS";
CONST_GLOBAL WCHAR c_szSvcNetLogon[]            = L"NetLogon";
CONST_GLOBAL WCHAR c_szSvcRPCLocator[]          = L"Rpclocator";
CONST_GLOBAL WCHAR c_szSvcRasAuto[]             = L"RasAuto";
CONST_GLOBAL WCHAR c_szSvcRasMan[]              = L"RasMan";
CONST_GLOBAL WCHAR c_szSvcRdbss[]               = L"Rdbss";
CONST_GLOBAL WCHAR c_szSvcRdr[]                 = L"Rdr";
CONST_GLOBAL WCHAR c_szSvcRemoteAccess[]        = L"RemoteAccess";
CONST_GLOBAL WCHAR c_szSvcReplicator[]          = L"Replicator";
CONST_GLOBAL WCHAR c_szSvcRipForIp[]            = L"IpRip";
CONST_GLOBAL WCHAR c_szSvcRipForIpx[]           = L"NwlnkRip";
CONST_GLOBAL WCHAR c_szSvcRouter[]              = L"Router";
CONST_GLOBAL WCHAR c_szSvcSapAgent[]            = L"NwSapAgent";
CONST_GLOBAL WCHAR c_szSvcWinsClient[]          = L"NetBT";
CONST_GLOBAL WCHAR c_szSvcWorkstation[]         = L"LanmanWorkstation";

CONST_GLOBAL WCHAR c_szRegKeyCtlLsa[]           = L"System\\CurrentControlSet\\Control\\Lsa";
CONST_GLOBAL WCHAR c_szRegKeyCtlNPOrder[]       = L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order";
CONST_GLOBAL WCHAR c_szRegKeyCtlNetProvider[]   = L"System\\CurrentControlSet\\Control\\NetworkProvider";
CONST_GLOBAL WCHAR c_szRegKeyServices[]         = L"System\\CurrentControlSet\\Services";
CONST_GLOBAL WCHAR c_szProviderOrder[]          = L"ProviderOrder";

CONST_GLOBAL WCHAR c_szRegValDependOnGroup[]    = L"DependOnGroup";
CONST_GLOBAL WCHAR c_szRegValDependOnService[]  = L"DependOnService";
CONST_GLOBAL WCHAR c_szRegValServiceName[]      = L"ServiceName";
CONST_GLOBAL WCHAR c_szRegValStart[]            = L"Start";

// Binding Interface Names
CONST_GLOBAL WCHAR c_szBiNdis4[]                = L"ndis4";
CONST_GLOBAL WCHAR c_szBiNdis5[]                = L"ndis5";
CONST_GLOBAL WCHAR c_szBiNdis5Ip[]              = L"ndis5_ip";
CONST_GLOBAL WCHAR c_szBiNdisAtm[]              = L"ndisatm";
CONST_GLOBAL WCHAR c_szBiNdisBda[]              = L"ndisbda";
CONST_GLOBAL WCHAR c_szBiNdisCoWan[]            = L"ndiscowan";
CONST_GLOBAL WCHAR c_szBiNdisWan[]              = L"ndiswan";
CONST_GLOBAL WCHAR c_szBiNdisWanAsync[]         = L"ndiswanasync";
CONST_GLOBAL WCHAR c_szBiNdisWanAtalk[]         = L"ndiswanatalk";
CONST_GLOBAL WCHAR c_szBiNdisWanBh[]            = L"ndiswanbh";
CONST_GLOBAL WCHAR c_szBiNdisWanIp[]            = L"ndiswanip";
CONST_GLOBAL WCHAR c_szBiNdisWanIpx[]           = L"ndiswanipx";
CONST_GLOBAL WCHAR c_szBiNdisWanNbf[]           = L"ndiswannbf";
CONST_GLOBAL WCHAR c_szBiNdis1394[]             = L"ndis1394";
CONST_GLOBAL WCHAR c_szBiLocalTalk[]            = L"LocalTalk";    // Yes this is a LOWER interface

// <Protocol>\Parameters\Adapters
CONST_GLOBAL WCHAR c_szParameters[]             = L"Parameters";
CONST_GLOBAL WCHAR c_szAdapters[]               = L"Adapters";

// Used by Netsetup and Component's who's answer file references AdapterSections
CONST_GLOBAL WCHAR c_szAdapterSections[]        = L"AdapterSections";
CONST_GLOBAL WCHAR c_szSpecificTo[]             = L"SpecificTo";

#ifdef DBG
//debugging related
CONST_GLOBAL CHAR  c_szDbgBadReadPtrMsg[]              = "Bad read pointer";
CONST_GLOBAL CHAR  c_szDbgBadWritePtrMsg[]             = "Bad write pointer";
#endif


// Net detect dll and functions
CONST_GLOBAL WCHAR c_szNetDetDll[]                      = L"netdet.dll";
CONST_GLOBAL CHAR  c_szaNetDetectRegister[]             = "NetDetectRegister";
CONST_GLOBAL CHAR  c_szaNetDetectDeregister[]           = "NetDetectDeregister";
CONST_GLOBAL CHAR  c_szaNetDetectFindAdapter[]          = "NetDetectFindAdapter";
CONST_GLOBAL CHAR  c_szaNetDetectFreeAdapterInfo[]      = "NetDetectFreeAdapterInfo";


// tcpras.h
CONST_GLOBAL WCHAR c_szNdisWan[]                        =  L"NdisWan";

// Component registry constants
CONST_GLOBAL WCHAR c_szRegKeyInterfacesFromInstance[]   = L"Ndi\\Interfaces";
CONST_GLOBAL WCHAR c_szRegValueLowerRange[]             = L"LowerRange";
CONST_GLOBAL WCHAR c_szRegValueUpperRange[]             = L"UpperRange";

// Device installer related strings
CONST_GLOBAL WCHAR c_szRegValueNetCfgInstanceId[]       = L"NetCfgInstanceID";
CONST_GLOBAL WCHAR c_szRegValuePnpInstanceId[]          = L"PnpInstanceID";

CONST_GLOBAL WCHAR c_szRegKeyComponentClasses[]         = L"SYSTEM\\CurrentControlSet\\Control\\Network";
CONST_GLOBAL WCHAR c_szRegValueInstallerAction[]        = L"InstallerAction";

// Optional component strings
CONST_GLOBAL WCHAR c_szOcMainSection[]                  = L"NetOptionalComponents";

// NWCWorkstation service subkey names
CONST_GLOBAL WCHAR c_szShares[]                         = L"Shares";
CONST_GLOBAL WCHAR c_szDrives[]                         = L"Drives";

CONST_GLOBAL WCHAR c_szRegKeyNt4Adapters[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\ncui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . C P P
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "ncerror.h"
#include "ncstring.h"
#include "ncui.h"
#include "ncperms.h"
#include "netconp.h"

//+---------------------------------------------------------------------------
//
//  Function:   EnableOrDisableDialogControls
//
//  Purpose:    Enable or disable a group of controls all at once.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      ccid    [in] Count of elements in array pointed to by acid.
//      acid    [in] Array of control ids.
//      fEnable [in] TRUE to enable controls, FALSE to disable.
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    IN HWND        hDlg,
    IN INT         ccid,
    IN const INT*  acid,
    IN BOOL        fEnable)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (ccid, acid));

    while (ccid--)
    {
        EnableWindow (GetDlgItem (hDlg, *acid++), fEnable);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FMapRadioButtonToValue
//
//  Purpose:    Maps the current state of a set of radio buttons to a DWORD
//              value based on a mapping table.
//
//  Arguments:
//      hDlg     [in]  Window handle of parent dialog.
//      crbm     [in]  Count of elements in array pointed to by arbm.
//      arbm     [in]  Array of elements that map a radio button control id to
//                     its associated value.
//      pdwValue [out] The returned value.
//
//  Returns:    TRUE if a radio button was set and the value returned.
//              FALSE otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
BOOL
FMapRadioButtonToValue (
    IN HWND                    hDlg,
    IN INT                     crbm,
    IN const RADIO_BUTTON_MAP* arbm,
    OUT DWORD*                  pdwValue)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (crbm, arbm));
    Assert (pdwValue);

    while (crbm--)
    {
        // If it is set, return the corresponding value.
        if (BST_CHECKED & IsDlgButtonChecked (hDlg, arbm->cid))
        {
            *pdwValue = arbm->dwValue;
            return TRUE;
        }

        arbm++;
    }
    *pdwValue = 0;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FMapValueToRadioButton
//
//  Purpose:    Set the state of a set of radio buttons based on the value of
//              of a DWORD and a mapping table.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      crbm    [in] Count of elements in array pointed to by arbm.
//      arbm    [in] Array of elements that map a radio button control id to
//                   its associated value.
//      dwValue [in] value which gets mapped to set the appropriate radio
//                   button.
//
//  Returns:    TRUE if dwValue was found in the map.  FALSE otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
BOOL
FMapValueToRadioButton (
    IN HWND                    hDlg,
    IN INT                     crbm,
    IN const RADIO_BUTTON_MAP* arbm,
    IN DWORD                   dwValue,
    IN INT*                    pncid)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (crbm, arbm));

    while (crbm--)
    {
        if (dwValue == arbm->dwValue)
        {
            // Set the radio button.
            CheckDlgButton (hDlg, arbm->cid, BST_CHECKED);

            // Return the control id if requested.
            if (pncid)
            {
                *pncid = arbm->cid;
            }

            return TRUE;
        }

        arbm++;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIntegerFormat
//
//  Purpose:    Uses GetNumberFormat to format an integer number.
//
//  Arguments:
//      Locale            [in]  See Win32 API description of GetNumberFormat.
//      pszValue          [in]
//      pszFormattedValue [out]
//      cchFormattedValue [in]
//
//  Returns:    return value from GetNumberFormat
//
//  Author:     shaunco   4 May 1998
//
//  Notes:
//
INT
GetIntegerFormat (
    IN LCID   Locale,
    IN PCWSTR pszValue,
    OUT PWSTR pszFormattedValue,
    IN INT    cchFormattedValue)
{
    // Format the number for the user's locale and preferences.
    //
    WCHAR szGrouping [16];
    GetLocaleInfo (Locale, LOCALE_SGROUPING,
                   szGrouping, celems(szGrouping));

    WCHAR szDecimalSep [16];
    GetLocaleInfo (Locale, LOCALE_SDECIMAL,
                   szDecimalSep, celems(szDecimalSep));

    WCHAR szThousandSep [16];
    GetLocaleInfo (Locale, LOCALE_STHOUSAND,
                   szThousandSep, celems(szThousandSep));

    NUMBERFMT nf;
    ZeroMemory (&nf, sizeof(nf));
    nf.Grouping      = wcstoul (szGrouping, NULL, 10);
    nf.lpDecimalSep  = szDecimalSep;
    nf.lpThousandSep = szThousandSep;

    return GetNumberFormat (
                    Locale,
                    0,
                    pszValue,
                    &nf,
                    pszFormattedValue,
                    cchFormattedValue);
}

INT
Format32bitInteger (
    IN UINT32  unValue,
    IN BOOL    fSigned,
    OUT PWSTR  pszFormattedValue,
    IN INT     cchFormattedValue)
{
    // Convert the number to a string.
    //
    WCHAR szValue [33];

    *szValue = 0;

    if (fSigned)
    {
        _itow ((INT)unValue, szValue, 10);
    }
    else
    {
        _ultow (unValue, szValue, 10);
    }

    // Format the number according to user locale settings.
    //
    INT cch = GetIntegerFormat (
                LOCALE_USER_DEFAULT,
                szValue,
                pszFormattedValue,
                cchFormattedValue);
    if (!cch)
    {
        TraceHr(ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "GetIntegerFormat failed in Format32bitInteger");

        lstrcpynW (pszFormattedValue, szValue, cchFormattedValue);
        cch = lstrlenW (pszFormattedValue);
    }
    return cch;
}

INT
Format64bitInteger (
    IN UINT64  ulValue,
    IN BOOL    fSigned,
    OUT PWSTR  pszFormattedValue,
    IN INT     cchFormattedValue)
{
    // Convert the number to a string.
    //
    WCHAR szValue [32];

    *szValue = 0;

    if (fSigned)
    {
        _i64tow ((INT64)ulValue, szValue, 10);
    }
    else
    {
        _ui64tow (ulValue, szValue, 10);
    }

    // Format the number according to user locale settings.
    //
    INT cch = GetIntegerFormat (
                LOCALE_USER_DEFAULT,
                szValue,
                pszFormattedValue,
                cchFormattedValue);
    if (!cch)
    {
        TraceHr(ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "GetIntegerFormat failed in Format64bitInteger");

        lstrcpynW (pszFormattedValue, szValue, cchFormattedValue);
        cch = lstrlenW (pszFormattedValue);
    }
    return cch;
}


BOOL
SetDlgItemFormatted32bitInteger (
    IN HWND    hDlg,
    IN INT     nIdDlgItem,
    IN UINT32  unValue,
    IN BOOL    fSigned)
{
    // Format the number according to user locale settings.
    //
    WCHAR szFormattedValue[64];

    Format32bitInteger(
        unValue,
        fSigned,
        szFormattedValue,
        celems(szFormattedValue));

    // Display the number.
    //
    return SetDlgItemText (hDlg, nIdDlgItem, szFormattedValue);
}

BOOL
SetDlgItemFormatted64bitInteger (
    IN HWND    hDlg,
    IN INT     nIdDlgItem,
    IN UINT64  ulValue,
    IN BOOL    fSigned)
{
    // Format the number according to user locale settings.
    //
    WCHAR szFormattedValue[64];

    Format64bitInteger(
        ulValue,
        fSigned,
        szFormattedValue,
        celems(szFormattedValue));

    // Display the number.
    //
    return SetDlgItemText (hDlg, nIdDlgItem, szFormattedValue);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNcQueryUserForRebootEx
//
//  Purpose:    Query the user to reboot.  If he/she chooses yes, a reboot
//              is initiated.
//
//  Arguments:
//      hwndParent  [in] Parent window handle.
//      pszCaption  [in] Caption text.
//      pszText     [in] Message text.
//      dwFlags     [in] Control flags (QUFR_PROMPT | QUFR_REBOOT)
//
//  Returns:    S_OK if a reboot was requested, S_FALSE if the user
//              didn't want to, or an error code otherwise.
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
HRESULT
HrNcQueryUserForRebootEx (
    IN HWND       hwndParent,
    IN PCWSTR     pszCaption,
    IN PCWSTR     pszText,
    IN DWORD      dwFlags)
{
    HRESULT hr   = S_FALSE;
    INT     nRet = IDYES;

    if (dwFlags & QUFR_PROMPT)
    {
        nRet = MessageBox (hwndParent, pszText, pszCaption,
                           MB_YESNO | MB_ICONEXCLAMATION);
    }

    if (nRet == IDYES)
    {
        if (dwFlags & QUFR_REBOOT)
        {
            TOKEN_PRIVILEGES* ptpOld;
            hr = HrEnableAllPrivileges (&ptpOld);
            if (S_OK == hr)
            {
                if (!ExitWindowsEx (EWX_REBOOT, 10))
                {
                    hr = HrFromLastWin32Error();
                }

                MemFree (ptpOld);
            }
        }
        else
        {
            hr = S_OK;
        }
    }

    TraceError("HrNcQueryUserForRebootEx", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNcQueryUserForReboot
//
//  Purpose:    Query the user to reboot.  If he/she chooses yes, a reboot
//              is initiated.
//
//  Arguments:
//      hinst       [in] Module instance with string ids.
//      hwndParent  [in] Parent window handle.
//      unIdCaption [in] String id of caption text.
//      unIdText    [in] String id of message text.
//      dwFlags     [in] Control flags (QUFR_PROMPT | QUFR_REBOOT)
//
//  Returns:    S_OK if a reboot is initiated, S_FALSE if the user
//              didn't want to, or an error code otherwise.
//
//  Author:     shaunco   2 Jan 1998
//
//  Notes:
//
HRESULT
HrNcQueryUserForReboot (
    IN HINSTANCE   hinst,
    IN HWND        hwndParent,
    IN UINT        unIdCaption,
    IN UINT        unIdText,
    IN DWORD       dwFlags)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszText    = SzLoadString (hinst, unIdText);

    HRESULT hr = HrNcQueryUserForRebootEx (hwndParent, pszCaption,
                                           pszText, dwFlags);

    TraceError("HrNcQueryUserForReboot", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrShell_NotifyIcon
//
//  Purpose:    HRESULT returning wrapper for Shell_NotifyIcon.
//
//  Arguments:
//      dwMessage [in]
//      pData     [in]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   11 Nov 1998
//
//  Notes:
//
HRESULT
HrShell_NotifyIcon (
    IN DWORD dwMessage,
    IN PNOTIFYICONDATA pData)
{
    HRESULT hr              = E_FAIL; // First time through, this will succeed
    BOOL    fr              = FALSE;
    BOOL    fRetriedAlready = FALSE;
    BOOL    fAttemptRetry   = FALSE;
    INT     iRetries = 0;

    // Attempt the first time, and attempt again after an attempted correction
    //
    while ((hr == E_FAIL) || fAttemptRetry)
    {
        if (fAttemptRetry)
            fRetriedAlready = TRUE;

        fr = Shell_NotifyIcon(dwMessage, pData);
        if (!fr)
        {
            if (dwMessage == NIM_ADD && !fRetriedAlready)
            {
                NOTIFYICONDATA nidDelete;

                ZeroMemory (&nidDelete, sizeof(nidDelete));
                nidDelete.cbSize  = sizeof(NOTIFYICONDATA);
                nidDelete.hWnd    = pData->hWnd;
                nidDelete.uID     = pData->uID;

                Shell_NotifyIcon(NIM_DELETE, &nidDelete);

                fAttemptRetry = TRUE;
                hr = E_FAIL;
            }
            else
            {
                // We should not attempt [a|another] retry
                //
                fAttemptRetry = FALSE;
                hr = S_FALSE;
            }
        }
        else
        {
            fAttemptRetry = FALSE;
            hr = S_OK;
        }
    }

    // At this point, if hr == S_FALSE, it means that we tried to retry, and even that failed
    // We need to convert this to E_FAIL so we still return what we did before
    //
    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }

    // If we successfully swapped an icon, we should assert and figure out why that
    // went wrong.
    //
    if ((S_OK == hr) && fRetriedAlready)
    {
        TraceTag(ttidShellFolder, "We should debug this. We worked around a duplicate icon by removing "
            "the old one and putting the new one in place");
    }

    TraceError("HrShell_NotifyIcon", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LresFromHr
//
//  Purpose:    Translates an HRESULT into a valid LRESULT to be returned by
//              a dialog handler function.
//
//  Arguments:
//      hr [in] HRESULT to be translated.
//
//  Returns:    LRESULT
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:
//
LRESULT
LresFromHr (
    IN HRESULT hr)
{
    AssertSz (((LRESULT)hr) != PSNRET_INVALID, "Don't pass PSNRET_INVALID to "
              "LresFromHr! Use equivalent NETCFG_E_* value instead!");
    AssertSz (((LRESULT)hr) != PSNRET_INVALID_NOCHANGEPAGE, "Don't pass "
              "PSNRET_INVALID_NOCHANGEPAGE to "
              "LresFromHr! Use equivalent NETCFG_E_* value instead!");

    if (NETCFG_E_PSNRET_INVALID == hr)
    {
        return PSNRET_INVALID;
    }

    if (NETCFG_E_PSNRET_INVALID_NCPAGE == hr)
    {
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : (LRESULT)hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hinst       [in] hinstance for resource strings
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszFormat  = SzLoadString (hinst, unIdFormat);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    INT nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBoxWithVarCaption
//
//  Purpose:    Same as NcMsgBox, but allows a string parameter to be used
//              for the caption.
//
//  Arguments:
//      hinst           [in] hinstance for resource strings
//      hwnd            [in] parent window handle
//      unIdCaption     [in] resource id of caption string
//      pszCaptionParam [in] string parameter to use for caption
//      unIdFormat      [in] resource id of text string (with %1, %2, etc.)
//      unStyle         [in] standard message box styles
//      ...             [in] replaceable parameters (optional)
//                              (these must be PCWSTRs as that is all
//                              FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBoxWithVarCaption (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    PCWSTR      pszCaptionParam,
    UINT        unIdFormat,
    UINT        unStyle,
    ...)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszFormat  = SzLoadString (hinst, unIdFormat);

    PWSTR  pszNewCaption = NULL;
    DwFormatStringWithLocalAlloc (pszCaption, &pszNewCaption, pszCaptionParam);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    INT nRet = MessageBox (hwnd, pszText, pszNewCaption, unStyle);
    LocalFree (pszText);
    LocalFree (pszNewCaption);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBoxWithWin32ErrorText
//
//  Purpose:    Displays a message box using a Win32 error code, resource
//              strings and replaceable parameters.
//              The output text is a combination of the user's format
//              string (with parameter's replaced) and the Win32 error
//              text as returned from FormatMessage.  These two strings
//              are combined using the IDS_TEXT_WITH_WIN32_ERROR resource.
//
//  Arguments:
//      dwError     [in] Win32 error code
//      hinst       [in] Module instance where string resources live.
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdCombineFormat [in] resource id of format string to combine
//                              error text with unIdFormat text.
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   3 May 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
NOTHROW
INT
WINAPIV
NcMsgBoxWithWin32ErrorText (
    IN DWORD       dwError,
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdCombineFormat,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    // Get the user's text with parameter's replaced.
    //
    PCWSTR pszFormat = SzLoadString (hinst, unIdFormat);
    PWSTR  pszText;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end(val);

    // Get the error text for the Win32 error.
    //
    PWSTR pszError;
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                   (PWSTR)&pszError, 0, NULL);

    // Combine the user's text with the error text using IDS_TEXT_WITH_WIN32_ERROR.
    //
    PCWSTR pszTextWithErrorFmt = SzLoadString (hinst, unIdCombineFormat);
    PWSTR  pszTextWithError;
    DwFormatStringWithLocalAlloc (pszTextWithErrorFmt, &pszTextWithError,
                                  pszText, pszError);

    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    INT nRet = MessageBox (hwnd, pszTextWithError, pszCaption, unStyle);

    LocalFree (pszTextWithError);
    LocalFree (pszError);
    LocalFree (pszText);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   SendDlgItemsMessage
//
//  Purpose:    Send a group of dialog items the same message.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      ccid    [in] Count of elements in array pointed to by acid.
//      acid    [in] Array of control ids.
//      unMsg   [in] Message to send
//      wParam  [in] First message parameter
//      lParam  [in] Second message parameter
//
//  Returns:    nothing
//
//  Author:     shaunco   11 Jun 1997
//
//  Notes:
//
VOID
SendDlgItemsMessage (
    IN HWND        hDlg,
    IN INT         ccid,
    IN const INT*  acid,
    IN UINT        unMsg,
    IN WPARAM      wParam,
    IN LPARAM      lParam)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (ccid, acid));

    while (ccid--)
    {
        Assert (IsWindow (GetDlgItem (hDlg, *acid)));

        SendDlgItemMessage (hDlg, *acid++, unMsg, wParam, lParam);
    }
}

//
// Function:    SetDefaultButton
//
// Purpose:     Set the new default pushbutton on a dialog
//
// Params:      hdlg  [in] - Dialog HWND
//              iddef [in] - Id of new default pushbutton
//
// Returns:     nothing
//
VOID
SetDefaultButton(
    IN HWND hdlg,
    IN INT iddef)
{
    HWND hwnd;
    DWORD dwData;

    Assert(hdlg);

    dwData = (DWORD)SendMessage (hdlg, DM_GETDEFID, 0, 0L);
    if ((HIWORD(dwData) == DC_HASDEFID) && LOWORD(dwData))
    {
        hwnd = GetDlgItem (hdlg, (INT)LOWORD(dwData));
        if ((LOWORD(dwData) != iddef) && (hwnd))
        {
            SendMessage (hwnd, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE);
        }
    }

    SendMessage (hdlg, DM_SETDEFID,(WPARAM)iddef, 0L);
    if (iddef)
    {
        hwnd = GetDlgItem (hdlg, iddef);
        Assert(hwnd);
        SendMessage (hwnd, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE);
    }
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDOK,                   IDH_OK,     IDH_OK  },
    { IDCANCEL,               IDH_CANCEL, IDH_CANCEL },
    { 0,                      0,          0 },      // end marker
};

//+---------------------------------------------------------------------------
//
//  Function:   DwContextIdFromIdc
//
//  Purpose:    Converts the given control ID to a context help ID
//
//  Arguments:
//      idControl [in]  Control ID to convert
//
//  Returns:    Context help ID for that control (mapping comes from help
//              authors)
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
DWORD DwContextIdFromIdc(
    PCCONTEXTIDMAP lpContextIdMap,
    BOOL bJpn,
    INT idControl)
{
    DWORD   idw;

    Assert(lpContextIdMap);

    for (idw = 0; lpContextIdMap[idw].idControl; idw++)
    {
        if (idControl == lpContextIdMap[idw].idControl)
        {
            if (!bJpn)
            {
                return lpContextIdMap[idw].dwContextId;
            }
            else
            {
                return lpContextIdMap[idw].dwContextIdJapan;
            }
        }
    }

    // Not found, just return 0
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnHelpGeneric
//
//  Purpose:    Handles help generically
//
//  Arguments:
//      hwnd   [in]     HWND of parent window
//      lParam [in]     lParam of the WM_HELP message
//
//  Returns:    Nothing
//
//  Author:     danielwe   27 May 1998
//              anbrad     18 May 1999 moved to common.  common control id's added.
//
//  Notes:
//
VOID OnHelpGeneric(
    HWND hwnd,
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn,
    PCWSTR pszHelpFile)
{
    static const TCHAR c_szWindowsHelpFile[] = TEXT("windows.hlp");

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
        switch(lphi->iCtrlId)
        {
        case -1:        // IDC_STATIC
            break;
        case IDOK:
        case IDCANCEL:
        case IDABORT:
        case IDRETRY:
        case IDIGNORE:
        case IDYES:
        case IDNO:
        case IDCLOSE:
        case IDHELP:
            WinHelp(hwnd, c_szWindowsHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(c_adwContextIdMap, bJpn, lphi->iCtrlId));
            break;
        default:
            WinHelp(hwnd, pszHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(pContextMap, bJpn, lphi->iCtrlId));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\dbgflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . C P P
//
//  Contents:   DebugFlag list for the NetCfg Project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//
#if defined(DBG) || defined(ENABLETRACE)

#include "ncdebug.h"
#include "ncbase.h"

// This is the DebugFlag list that everyone should be modifying.
//
DEBUGFLAGELEMENT g_DebugFlags[] =
{
//      :-----------    DebugFlagId dfid
//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           DWORD       dwValue ------------------------------------------------------------:
//      | | |                                                                                           |
//      | | |                                                                                           |
//      | | :-------------------------------------------:                                               |
//      | :----------------------:                      |                                               |
//      |                        |                      |                                               |
//      v                        v                      v                                               v
//
    { dfidBreakOnAlloc,             "BreakOnAlloc",             "Break on Specified Alloc",             0 },
    { dfidBreakOnDoUnattend,        "BreakOnDoUnattend",        "Break during HrDoUnattend",            0 },
    { dfidBreakOnError,             "BreakOnError",             "Break on TraceError",                  0 },
    { dfidBreakOnHr,                "BreakOnHr",                "Break when hr is specific value",      0 },
    { dfidBreakOnHrIteration,       "BreakOnHrInteration",      "Break when hr is hit N times",         0 },
    { dfidBreakOnIteration,         "BreakOnIteration",         "Break on Nth call to TraceError",      0 },
    { dfidBreakOnNetInstall,        "BreakOnNetInstall",        "Break during HrNetClassInstaller",     0 },
    { dfidBreakOnNotifySinkRelease, "BreakOnNotifySinkRelease", "Break when the NotifySink is released",0 },
    { dfidBreakOnPrematureDllUnload,"BreakOnPrematureDllUnload","Break when DLL unloaded with open references",     0 },
    { dfidBreakOnWizard,            "BreakOnWizard",            "Break on Wizard",                      0 },
    { dfidBreakOnStartOfUpgrade,    "BreakOnStartOfUpgrade",    "Break at the beginning of InstallUpgradeWorkThread", 0 },
    { dfidBreakOnEndOfUpgrade,      "BreakOnEndOfUpgrade",      "Break after all calls to HrDoUnattend have been completed", 0 },
    { dfidCheckLegacyMenusAtRuntime,"CheckLegacyMenusAtRuntime","Assert legacy menus during runtime",   0 },
    { dfidCheckLegacyMenusOnStartup,"CheckLegacyMenusOnStartup","Assert all legacy menus on startup",   0 },
    { dfidDisableShellThreading,    "DisableShellThreading",    "Disable shell thread pool usage",      0 },
    { dfidDisableTray,              "DisableTray",              "Disable Tray",                         0 },
    { dfidDontCacheShellIcons,      "DontCacheShellIcons",      "Don't ever use shell icon caching",    0 },
    { dfidExtremeTracing,           "ExtremeTracing",           "Output all traces, even on success",   0 },
    { dfidNetShellBreakOnInit,      "NetShellBreakOnInit",      "Break on Initialization of NetShell",  0 },
    { dfidNoErrorText,              "NoErrorText",              "Don't show wimpy error strings.",      0 },
    { dfidShowIgnoredErrors,        "ShowIgnoredErrors",        "Displays errors that would otherwise be ignored", 0 },
    { dfidShowProcessAndThreadIds,  "ShowProcessAndThreadIds",  "Displays process and thread id",       0 },
    { dfidSkipLanEnum,              "SkipLanEnum",              "Skip LAN Enumeration",                 0 },
    { dfidTraceCallStackOnError,    "TraceCallStackOnError",    "Dump the call stack for all errors",   0 },
    { dfidTraceFileFunc,            "TraceFileFunc",            "Trace Function names & params for every call", 0 },
    { dfidTraceMultiLevel,          "TraceMultiLevel",          "Trace multiple levels",                0 },       
    { dfidTraceSource,              "TraceSource",              "Trace source information",             0 },
    { dfidTracingTimeStamps,        "TracingTimeStamps",        "Add time stamps to tracing output",    0 },
    { dfidTrackObjectLeaks,         "TrackObjectLeaks",         "Track object leaks",                   0 }
};

const INT g_nDebugFlagCount = celems(g_DebugFlags);


//+---------------------------------------------------------------------------
//
//  Function:   FIsDebugFlagSet
//
//  Purpose:    Return the state of a debug flag to the caller.
//
//  Arguments:
//      dfid [] Debug Flag ID
//
//  Returns:    TRUE if set, FALSE otherwise.
//
//  Author:     jeffspr   28 May 1997
//
//  Notes:
//
BOOL FIsDebugFlagSet( DEBUGFLAGID   dfid )
{
    return (g_DebugFlags[dfid].dwValue > 0);
}

DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid )
{
    return (g_DebugFlags[dfid].dwValue);
}


#endif //! DBG || ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
//#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncstl.h"

#include "list"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSERVICE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>

#include <objbase.h>

#include <stdio.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\benchmrk.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . C P P
//
//  Contents:   Benchmarking class
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "benchmrk.h"

CBenchmark::CBenchmark()
: m_i64Frequency(1000),
  m_sznDescription(NULL),
  m_i64TotalTime(0),
  m_fStarted(FALSE)
{
    LARGE_INTEGER li1;

    // Check if QueryPerformanceCounter is supported
    if (QueryPerformanceCounter(&li1))
    {
        // Now get # of ticks per second
        QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64Frequency));

        m_fSupported = TRUE;
    }
    else
    {
        TraceTag(ttidBenchmark, "High performance counter is not supported.");
        m_fSupported = FALSE;
    }
}

CBenchmark::~CBenchmark()
{
    delete [] m_sznDescription;
}


void
CBenchmark::Start(PCSTR sznDescription)
{
    // If QueryPerformanceCounter is supported
    if (m_fSupported)
    {
        // delete the old description
        delete [] m_sznDescription;

        // replace with new one if specified
        if (sznDescription)
        {
            m_sznDescription = new CHAR[strlen(sznDescription) + 1];
            if (m_sznDescription)
            {
                strcpy(m_sznDescription, sznDescription);
            }
        }
        else
        {
            // no description specified clear the member variable
            m_sznDescription = NULL;
        }
        m_fStarted = TRUE;
        m_i64TotalTime = 0;

        // Record our start time
        QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64StartTime));
    }
}

void
CBenchmark::Stop()
{
    __int64 i64Stop;
    // Record our stop time
    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&i64Stop));

    // If start was called prior to stop, then record the total time and
    // reset our m_fStarted flag
    //
    if (m_fStarted)
    {
        m_fStarted = FALSE;
        m_i64TotalTime = i64Stop - m_i64StartTime;
    }
    else
    {
        // invalidate previous benchmark since stop was called before start
        m_i64TotalTime = 0;
    }
}

PCSTR
CBenchmark::SznBenchmarkSeconds(unsigned short usPrecision)
{
    CHAR sznFmt[10];
    sprintf(sznFmt, "%%.%df", usPrecision);
    sprintf(m_sznSeconds, sznFmt, DblBenchmarkSeconds());
    return m_sznSeconds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\diagctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I A G C T X . C P P
//
//  Contents:   Implements the optional diagnostic context used by
//              CNetConfig.
//
//  Notes:
//
//  Author:     shaunco   10 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "diagctx.h"


CDiagContext* g_pDiagCtx;


DWORD
CDiagContext::Flags () const
{
    return (this) ? m_dwFlags : 0;
}

VOID
CDiagContext::SetFlags (
    DWORD dwFlags /* DIAG_FLAGS */)
{
    Assert (this);

    m_dwFlags = dwFlags;

    if ((dwFlags & DF_SHOW_CONSOLE_OUTPUT) && !m_pCtx)
    {
        m_pCtx = (DIAG_CONTEXT*) MemAlloc (sizeof(DIAG_CONTEXT));
    }
}

#ifndef COMPILE_WITH_TYPESAFE_PRINTF
VOID
CDiagContext::Printf (
    TRACETAGID ttid,
    PCSTR pszFormat,
    ...
    )
{
    va_list argList;
    DWORD cch;
    CHAR* pszPrintBuffer = NULL;
    INT cchPrintBuffer;

    Assert (pszFormat);

    if (this && (m_dwFlags & DF_SHOW_CONSOLE_OUTPUT) && m_pCtx)
    {
        pszPrintBuffer = m_pCtx->szPrintBuffer;
        cchPrintBuffer = sizeof(m_pCtx->szPrintBuffer);
    }
    else
    {
#ifdef ENABLETRACE
        if (!g_TraceTags[ttid].fOutputDebugString)
        {
            return;
        }

        static CHAR szPrintfBuffer [2048];

        pszPrintBuffer = szPrintfBuffer;
        cchPrintBuffer = sizeof(szPrintfBuffer);
#else
        return;
#endif
    }

    Assert (pszPrintBuffer);

    // Do the standard variable argument stuff
    va_start (argList, pszFormat);

    cch = _vsnprintf (pszPrintBuffer, cchPrintBuffer, pszFormat, argList);

    va_end(argList);

    TraceTag (ttid, pszPrintBuffer);

    if (this && (m_dwFlags & DF_SHOW_CONSOLE_OUTPUT))
    {
        HANDLE hStdOut;

        hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

        if (INVALID_HANDLE_VALUE != hStdOut)
        {
            DWORD cbWritten;

            if (WriteFile(hStdOut, pszPrintBuffer, cch * sizeof(CHAR), &cbWritten, NULL) == FALSE)
            {
                return;
            }
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncbase\pidlutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L . C P P
//
//  Contents:   PIDL utility routines. This stuff is mainly copied from the
//              existing Namespace extension samples and real code, since
//              everyone and their gramma uses this stuff.
//
//  Notes:
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "shlobj.h"
#include "shlobjp.h"

#include "pidlutil.h"

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   ILNext
//
//  Purpose:    Return the next PIDL in the list
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILNext(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        pidl = (LPITEMIDLIST) ((BYTE *)pidl + pidl->mkid.cb);
    }

    return (LPITEMIDLIST)pidl;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILIsEmpty
//
//  Purpose:    Is this PIDL empty
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
BOOL ILIsEmpty(LPCITEMIDLIST pidl)
{
   return (!pidl || !pidl->mkid.cb);

}
#endif // #if DBG

//+---------------------------------------------------------------------------
//
//  Function:   ILCreate
//
//  Purpose:    Create a PIDL
//
//  Arguments:
//      cbSize []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILCreate(DWORD dwSize)
{
   LPITEMIDLIST pidl = (LPITEMIDLIST) SHAlloc(dwSize);

   return pidl;
}

VOID FreeIDL(LPITEMIDLIST pidl)
{
    Assert(pidl);

    SHFree(pidl);
}


//+---------------------------------------------------------------------------
//
//  Function:   ILIsSingleID
//
//  Purpose:    Returns TRUE if the idlist has just one ID in it.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
BOOL ILIsSingleID(LPCITEMIDLIST pidl)
{
    if (pidl == NULL)
        return FALSE;

    return (pidl->mkid.cb == 0 || ILNext(pidl)->mkid.cb == 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   ILGetCID
//
//  Purpose:    Returns the number of ID's in the list.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetCID(LPCITEMIDLIST pidl)
{
    UINT cid = 0;

    while (!ILIsEmpty(pidl))
    {
        ++ cid;
        pidl = ILNext(pidl);
    }

    return cid;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILGetSizeCID
//
//  Purpose:    Get the length of the first cid items in a pidl.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetSizeCID(LPCITEMIDLIST pidl, UINT cid)
{
    UINT cbTotal = 0;

    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator

        while (cid && !ILIsEmpty(pidl))
        {
            cbTotal += pidl->mkid.cb;
            pidl = ILNext(pidl);
            -- cid;
        }
    }

    return cbTotal;
}


//+---------------------------------------------------------------------------
//
//  Function:   CloneIDLFirstCID
//
//  Purpose:    Make a new list consisting of only the first cid items on
//              an existing list.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST CloneIDLFirstCID(LPCITEMIDLIST pidl, UINT cid)
{
    Assert((INT)cid >= 0);

    UINT            cb      = ILGetSizeCID(pidl, cid);
    LPITEMIDLIST    pidlRet = (LPITEMIDLIST) SHAlloc(cb);

    if (pidlRet)
    {
        // Notes: no need to zero-init.
        // Also, do not copy the NULL terminator.
        memcpy (pidlRet, pidl, cb - sizeof(pidl->mkid.cb));

        LPITEMIDLIST pidlTerm = pidlRet;

        // Cannot test for NULL terminator, we have not terminated
        // the list yet.
        //
        while (cid)
        {
            pidlTerm = ILNext(pidlTerm);
            -- cid;
        }

        pidlTerm->mkid.cb = 0;
    }

    return pidlRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILSkipCID
//
//  Purpose:    Skips the first cid items in a pidl.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILSkipCID(LPCITEMIDLIST pidl, UINT cid)
{
    Assert((INT)cid >= 0);

    while (cid && !ILIsEmpty(pidl))
    {
        pidl = ILNext(pidl);
        -- cid;
    }

    return (LPITEMIDLIST)pidl;
}


#if 0
BOOL ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (FSetupGlobalShellFolders())
    {
        LPSHELLFOLDER psfDesktop = (LPSHELLFOLDER) PvGlobGet (ipsfDesktop);
        if (psfDesktop)
        {
            VERIFYPTR(pidl1, FALSE);
            VERIFYPTR(pidl2, FALSE);

            return psfDesktop->CompareIDs(0, pidl1, pidl2) == ResultFromShort(0);
        }
    }
    return FALSE;
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   CloneIDL
//
//  Purpose:    Clone an IDL (return a duplicate)
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST CloneIDL(LPCITEMIDLIST pidl)
{
    UINT            cb      = 0;
    LPITEMIDLIST    pidlRet = NULL;

    if (pidl)
    {
        cb = ILGetSize(pidl);

        pidlRet = (LPITEMIDLIST) SHAlloc(cb);
        if (pidlRet)
        {
            memcpy(pidlRet, pidl, cb);
        }
    }

    return pidlRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   CloneRgIDL
//
//  Purpose:    Clone a pidl array
//
//  Arguments:
//      rgpidl              [in]    PIDL array to clone
//      cidl                [in]    Count of the pidl array
//      fUseCache           [in]    If TRUE, generate the returned IDL from the cache
//      fAllowNonCacheItems [in]    Use old version of pidl if cached version non available
//      pppidl              [out]   Return pointer for pidl array
//
//  Returns:
//
//  Author:     jeffspr   22 Oct 1997
//
//  Notes:
//
/*
HRESULT HrCloneRgIDL(
    LPCITEMIDLIST * rgpidl,
    ULONG           cidl,
    BOOL            fUseCache,
    BOOL            fAllowNonCacheItems,
    LPITEMIDLIST ** pppidl,
    ULONG *         pcidl)
{
    HRESULT         hr              = NOERROR;
    LPITEMIDLIST *  rgpidlReturn    = NULL;
    ULONG           irg             = 0;
    ULONG           cidlCopied      = 0;

    Assert(pppidl);
    Assert(pcidl);
    Assert(rgpidl);

    if (!rgpidl || !cidl)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    else
    {
        // Alloc the return buffer
        //
        rgpidlReturn = (LPITEMIDLIST *) SHAlloc(cidl * sizeof(LPITEMIDLIST));
        if (!rgpidlReturn)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        else
        {
            // Clone all elements within the passed in PIDL array
            //
            for (irg = 0; irg < cidl; irg++)
            {
                if (rgpidl[irg])
                {
                    if (fUseCache)
                    {
                        PCONNLISTENTRY  pcle    = NULL;
                        PCONFOLDPIDL    pcfp    = (PCONFOLDPIDL) rgpidl[irg];

                        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), &pcle);
                        if (hr == S_OK)
                        {
                            Assert(pcle);
                            Assert(pcle->pccfe);

                            // Copy to the return pidl array.
                            hr = HrConFoldEntryToPidl(pcle->pccfe, &(rgpidlReturn[cidlCopied++]));
                            if (FAILED(hr))
                                goto Exit;
                        }
                        else
                        {
                            TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection find returned: 0x%08x", hr);

                            if (hr == S_FALSE)
                            {
                                if (fAllowNonCacheItems)
                                {
                                    TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache, "
                                             "using non-cache item");

                                    rgpidlReturn[cidlCopied++] = CloneIDL((LPITEMIDLIST)rgpidl[irg]);
                                    if (!rgpidlReturn[irg])
                                    {
                                        hr = E_OUTOFMEMORY;
                                        goto Exit;
                                    }
                                }
                                else
                                {
                                    TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache. "
                                             "Dropping item from array");
                                }
                            }
                            else
                            {
                                AssertSz(FALSE, "HrCloneRgIDL: Connection find HR_FAILED");
                            }
                        }
                    }
                    else
                    {
                        // Clone this element in the PIDL array
                        //
                                    rgpidlReturn[cidlCopied++] = CloneIDL ((LPITEMIDLIST) rgpidl[irg]);
                                    if (!rgpidlReturn[irg])
                                    {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                                    }
                    }
                }
                else
                {
                    // Make sure that we don't try to delete bogus data later.
                    //
                    rgpidlReturn[cidlCopied++] = NULL;

                    AssertSz(FALSE, "Bogus element in the rgpidl in HrCloneRgIDL");
                    hr = E_INVALIDARG;
                    goto Exit;
                }
            }
        }
    }

Exit:
    if (FAILED(hr))
    {
        // Free the already-allocated IDLISTs
        //
        ULONG irgT = 0;

        for (irgT = 0; irgT < irg; irgT++)
        {
            if (rgpidlReturn[irgT])
            {
                FreeIDL(rgpidlReturn[irgT]);
            }
        }

        SHFree(rgpidlReturn);
        *pppidl = NULL;
    }
    else
    {
        // Fill in the return var.
        //
        *pppidl = rgpidlReturn;
        *pcidl = cidlCopied;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL");
    return hr;

}       //  CloneRgIDL
*/


//+---------------------------------------------------------------------------
//
//  Function:   FreeRgIDL
//
//  Purpose:    Free a PIDL array
//
//  Arguments:
//      cidl  [in]  Size of PIDL array
//      apidl [in]  Pointer to the array itself.
//
//  Returns:
//
//  Author:     jeffspr   27 Oct 1997
//
//  Notes:
//
VOID FreeRgIDL(
    UINT            cidl,
    LPITEMIDLIST  * apidl)
{
    if (apidl)
    {
        for (UINT i = 0; i < cidl; i++)
        {
            FreeIDL(apidl[i]);
        }

        SHFree(apidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\diagcmn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A G C M N . C P P
//
//  Contents:   Common functions for netcfg diagnostics
//
//  Notes:
//
//  Author:     danielwe   23 Mar 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "diag.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   SzFromCharacteristics
//
//  Purpose:    Converts a DWORD characteristics value into a string listing
//              the flags that are turned on.
//
//  Arguments:
//      dwChars   [in]  DWORD of netcfg characteristics (i.e. NCF_HIDDEN)
//      pstrChars [out] tstring of flags that are turned on, separated by a
//                      space.
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
VOID SzFromCharacteristics(DWORD dwChars, tstring *pstrChars) throw(std::bad_alloc)
{
    INT     i;

    const PCWSTR chars[] =
    {
        L"NCF_VIRTUAL ",
        L"NCF_SOFTWARE_ENUMERATED ",
        L"NCF_PHYSICAL ",
        L"NCF_HIDDEN ",
        L"NCF_NO_SERVICE ",
        L"NCF_NOT_USER_REMOVABLE ",
        L"NCF_MULTIPORT_INSTANCED_ADAPTER ",
        L"NCF_HAS_UI ",
        L"NCF_MODEM ",
        L"NCF_FILTER_DEVICE ",
        L"NCF_FILTER ",
        L"NCF_DONTEXPOSELOWER ",
        L"NCF_HIDE_BINDING ",
        L"0x4000 ",
        L"0x8000 ",
        L"NCF_FORCE_SCM_NOTIFY ",
        L"NCF_FIXED_BINDING ",
    };

    for (i = 0; i < celems(chars); i++)
    {
        if (dwChars & (1 << i) )
        {
            pstrChars->append(chars[i]);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SzFromNetconStatus
//
//  Purpose:    Converts a NETCON_STATUS value into a string
//
//  Arguments:
//      Status [in]     Status value to convert
//
//  Returns:    The string
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
PCWSTR SzFromNetconStatus(NETCON_STATUS Status) throw()
{
    switch (Status)
    {
    case NCS_DISCONNECTED:
        return L"NCS_DISCONNECTED";

    case NCS_CONNECTING:
        return L"NCS_CONNECTING";

    case NCS_CONNECTED:
        return L"NCS_CONNECTED";

    case NCS_DISCONNECTING:
        return L"NCS_DISCONNECTING";

    case NCS_HARDWARE_NOT_PRESENT:
        return L"NCS_HARDWARE_NOT_PRESENT";

    case NCS_HARDWARE_DISABLED:
        return L"NCS_HARDWARE_DISABLED";

    case NCS_HARDWARE_MALFUNCTION:
        return L"NCS_HARDWARE_MALFUNCTION";
    }

    return L"Unknown";
}

//+---------------------------------------------------------------------------
//
//  Function:   SzFromCmProb
//
//  Purpose:    Converts a config manager (CM) problem value into a string
//
//  Arguments:
//      ulProb [in]     Problem value
//
//  Returns:    String version of value
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
PCWSTR SzFromCmProb(ULONG ulProb) throw()
{
    const PCWSTR a_szProbs[] =
    {
        L"<no problem>",
        L"CM_PROB_NOT_CONFIGURED",
        L"CM_PROB_DEVLOADER_FAILED",
        L"CM_PROB_OUT_OF_MEMORY",
        L"CM_PROB_ENTRY_IS_WRONG_TYPE",
        L"CM_PROB_LACKED_ARBITRATOR",
        L"CM_PROB_BOOT_CONFIG_CONFLICT",
        L"CM_PROB_FAILED_FILTER",
        L"CM_PROB_DEVLOADER_NOT_FOUND",
        L"CM_PROB_INVALID_DATA",
        L"CM_PROB_FAILED_START",
        L"CM_PROB_LIAR",
        L"CM_PROB_NORMAL_CONFLICT",
        L"CM_PROB_NOT_VERIFIED",
        L"CM_PROB_NEED_RESTART",
        L"CM_PROB_REENUMERATION",
        L"CM_PROB_PARTIAL_LOG_CONF",
        L"CM_PROB_UNKNOWN_RESOURCE",
        L"CM_PROB_REINSTALL",
        L"CM_PROB_REGISTRY",
        L"CM_PROB_VXDLDR",
        L"CM_PROB_WILL_BE_REMOVED",
        L"CM_PROB_DISABLED",
        L"CM_PROB_DEVLOADER_NOT_READY",
        L"CM_PROB_DEVICE_NOT_THERE",
        L"CM_PROB_MOVED",
        L"CM_PROB_TOO_EARLY",
        L"CM_PROB_NO_VALID_LOG_CONF",
        L"CM_PROB_FAILED_INSTALL",
        L"CM_PROB_HARDWARE_DISABLED",
        L"CM_PROB_CANT_SHARE_IRQ",
        L"CM_PROB_FAILED_ADD",
    };

    return a_szProbs[ulProb];
}

//+---------------------------------------------------------------------------
//
//  Function:   SzFromCmStatus
//
//  Purpose:    Converts a config manager (CM) status value into a string
//              containing all flags that are turned on.
//
//  Arguments:
//      ulStatus   [in]     CM status value
//      pstrStatus [out]    Returns string of flags that are on
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
VOID SzFromCmStatus(ULONG ulStatus, tstring *pstrStatus) throw(std::bad_alloc)
{
    INT     i;

    const PCWSTR a_szStatus[] =
    {
        L"DN_ROOT_ENUMERATED ",
        L"DN_DRIVER_LOADED ",
        L"DN_ENUM_LOADED ",
        L"DN_STARTED ",
        L"DN_MANUAL ",
        L"DN_NEED_TO_ENUM ",
        L"DN_NOT_FIRST_TIME ",
        L"DN_HARDWARE_ENUM ",
        L"DN_LIAR/DN_NEED_RESTART ",
        L"DN_HAS_MARK ",
        L"DN_HAS_PROBLEM ",
        L"DN_FILTERED ",
        L"DN_MOVED ",
        L"DN_DISABLEABLE ",
        L"DN_REMOVABLE ",
        L"DN_PRIVATE_PROBLEM ",
        L"DN_MF_PARENT ",
        L"DN_MF_CHILD ",
        L"DN_WILL_BE_REMOVED ",
        L"DN_NOT_FIRST_TIMEE ",
        L"DN_STOP_FREE_RES ",
        L"DN_REBAL_CANDIDATE ",
        L"DN_BAD_PARTIAL ",
        L"DN_NT_ENUMERATOR ",
        L"DN_NT_DRIVER ",
        L"DN_NEEDS_LOCKING ",
        L"DN_ARM_WAKEUP ",
        L"DN_APM_ENUMERATOR ",
        L"DN_APM_DRIVER ",
        L"DN_SILENT_INSTALL ",
        L"DN_NO_SHOW_IN_DM ",
        L"DN_BOOT_LOG_PROB ",
    };

    for (i = 0; i < celems(a_szStatus); i++)
    {
        if (ulStatus & (1 << i) )
        {
            pstrStatus->append(a_szStatus[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\ncdebug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D E B U G X . C P P
//
//  Contents:   Implementation of debug support routines.
//
//  Notes:
//
//  Author:     danielwe   16 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef DBG

#include "ncdebug.h"
#include "ncdefine.h"

static int  nAssertLevel = 0;
static PFNASSERTHOOK pfnAssertHook = DefAssertSzFn;

#define MAX_ASSERT_TEXT_SIZE 4096
//
// We can only do memory tracking if we've included crtdbg.h and
// _DEBUG is defined.
//
#if defined(_INC_CRTDBG) && defined(_DEBUG)
struct DBG_SHARED_MEM
{
    _CrtMemState    crtState;
    DWORD           cRef;
};

DBG_SHARED_MEM *    g_pMem = NULL;
HANDLE              g_hMap = NULL;

static const WCHAR  c_szSharedMem[] = L"DBG_NetCfgSharedMemory";

//+---------------------------------------------------------------------------
//
//  Function:   InitDbgState
//
//  Purpose:    Initializes the memory leak detection code.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   13 May 1997
//
//  Notes:
//
VOID InitDbgState()
{
    g_hMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                             0, sizeof(DBG_SHARED_MEM), c_szSharedMem);
    if (g_hMap)
    {
        LPVOID  pvMem;
        BOOL    fExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

        pvMem = MapViewOfFile(g_hMap, FILE_MAP_WRITE, 0, 0, 0);
        g_pMem = reinterpret_cast<DBG_SHARED_MEM *>(pvMem);

        if (!fExisted)
        {
            // First time creating the file mapping. Initialize things.

            g_pMem->cRef = 0;

            // start looking for leaks now
            _CrtMemCheckpoint(&g_pMem->crtState);
        }

        g_pMem->cRef++;
        TraceTag(ttidDefault, "DBGMEM: Init Refcount on shared mem is now %d",
                 g_pMem->cRef);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UnInitDbgState
//
//  Purpose:    Uninitializes the memory leak detection code.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   13 May 1997
//
//  Notes:
//
VOID UnInitDbgState()
{
    if (g_pMem)
    {
        g_pMem->cRef--;
        TraceTag(ttidDefault, "DBGMEM: Uninit Refcount on shared mem is now %d",
                 g_pMem->cRef);

        if (!g_pMem->cRef)
        {
            // manually force dump of leaks when refcount goes to 0
            _CrtMemDumpAllObjectsSince(&g_pMem->crtState);
        }

        UnmapViewOfFile(reinterpret_cast<LPVOID>(g_pMem));
        CloseHandle(g_hMap);
    }
}
#endif


BOOL WINAPI FInAssert(VOID)
{
    return nAssertLevel > 0;
}

VOID WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    if (!fExp)
    {
        va_list     valMarker;

        va_start(valMarker, pszaFmt);
        wvsprintfA(rgch, pszaFmt, valMarker);
        va_end(valMarker);

        AssertSzFn(rgch, pszaFile, nLine);
    }
}

VOID WINAPI AssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    ++nAssertLevel;

    if (pszaFile)
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d:\r\n %s\r\n",
                      pszaFile, nLine, pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d.\r\n",
                      pszaFile, nLine);
        }
    }
    else
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n:\r\n %s\r\n",
                      pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure\r\n");
        }
    }

    OutputDebugStringA(rgch);

    if (pfnAssertHook)
    {
        (*pfnAssertHook)(pszaMsg, pszaFile, nLine);
    }

    --nAssertLevel;
}

VOID WINAPI AssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine, PCSTR pszaFunc)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    ++nAssertLevel;

    if (pszaFile)
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d, Func: %s:\r\n %s\r\n",
                      pszaFile, nLine, pszaFunc, pszaMsg );
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d, Func: %s:.\r\n",
                      pszaFile, nLine, pszaFunc ) ;
        }
    }
    else
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n:\r\n %s\r\n",
                      pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure\r\n");
        }
    }

    OutputDebugStringA(rgch);

    if (pfnAssertHook)
    {
        (*pfnAssertHook)(pszaMsg, pszaFile, nLine);
    }

    --nAssertLevel;
}

VOID WINAPI AssertSzFnWithDbgPrompt(BOOL fPromptIgnore, PCSTR pszaMsg, PCSTR pszaFile, INT nLine, PCSTR pszaFunc)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    DWORD dwProcId = GetCurrentProcessId();
    if (fPromptIgnore)
    {
        wsprintfA(rgch, "%s.\r\nPlease attach a kernel mode debugger, or (if you have local access to symbols) a user mode debugger to process id %d (decimal) and hit IGNORE to debug the problem\r\nE.g. use ntsd -Gg -p %d, (or ntsd -d -Gg -p %d) and then hit IGNORE.", pszaMsg, dwProcId, dwProcId, dwProcId);
    }
    else
    {
        wsprintfA(rgch, "%s.\r\nPlease attach a user mode debugger to process id %d (decimal) and hit RETRY to debug the problem\r\nE.g. use ntsd -Gg -p %d, (or ntsd -d -Gg -p %d) and then hit RETRY.", pszaMsg, dwProcId, dwProcId, dwProcId);
    }
    AssertSzFn(rgch, pszaFile, nLine, pszaFunc);
};

VOID CALLBACK DefAssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine)
{
    CHAR    rgch[2048];
    INT     nID;
    int     cch;
    PSTR    pch;
    BOOL    fNYIWarning = FALSE;
    CHAR    szaNYI[]     = "NYI:";

    if (pszaFile)
    {
        wsprintfA(rgch, "File %s, line %d\r\n\r\n", pszaFile, nLine);
    }
    else
    {
        rgch[0] = 0;
    }

    if (pszaMsg)
    {
        // Check to see if this is an NYI alert. If so, then we'll want
        // to use a different MessageBox title
        if (strncmp(pszaMsg, szaNYI, strlen(szaNYI)) == 0)
        {
            fNYIWarning = TRUE;
        }

        lstrcatA(rgch, pszaMsg);
    }


    cch = lstrlenA(rgch);
    pch = &rgch[cch];

    if (cch < celems(rgch))
    {
        lstrcpynA(pch, "\n\nPress Abort to crash, Retry to debug, or Ignore to ignore."
                       "\nHold down Shift to copy the assert text to the "
                       "clipboard before the action is taken.", celems(rgch) - cch - 1);
    }

    MessageBeep(MB_ICONHAND);

    nID = MessageBoxA(NULL, rgch,
            fNYIWarning ? "Net Config -- Not Yet Implemented" : "Net Config Assert Failure",
            MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 | MB_ICONHAND |
            MB_SETFOREGROUND | MB_TASKMODAL | MB_SERVICE_NOTIFICATION);

    if (nID == IDRETRY)
    {
        DebugBreak();
    }

    // if cancelling, force a hard exit w/ a GP-fault so that Dr. Watson
    // generates a nice stack trace log.
    if (nID == IDABORT)
    {
        *(BYTE *) 0 = 1;    // write to address 0 causes GP-fault
    }
}

VOID WINAPI SetAssertFn(PFNASSERTHOOK pfn)
{
    pfnAssertHook = pfn;
}

//+---------------------------------------------------------------------------
// To be called during DLL_PROCESS_DETACH for a DLL which implements COM
// objects or hands out references to objects which can be tracked.
// Call this function with the name of the DLL (so that it can be traced
// to the debugger) and the lock count of the DLL.  If the lock count is
// non-zero, it means the DLL is being unloaded prematurley.  When this
// condition is detected, a message is printed to the debugger and a
// DebugBreak will be invoked if the debug flag dfidBreakOnPrematureDllUnload
// is set.
//
// Assumptions:
//  Trace and debugging features have not been uninitialized.
//
//
VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount)
{
    if (0 != ModuleLockCount)
    {
        TraceTag(ttidNetcfgBase, "ModuleLockCount == %d.  "
            "%s is being unloaded with clients still holding references!",
            ModuleLockCount,
            pszaDllName);

        if (FIsDebugFlagSet(dfidBreakOnPrematureDllUnload))
        {
            DebugBreak ();
        }
    }
}

#endif //! DBG

//+---------------------------------------------------------------------------
//
//  Function:   InitializeDebugging
//
//  Purpose:    Called by every DLL or EXE to initialize the debugging
//              objects (Trace and DebugFlag tables)
//
//  Arguments:
//      bDisableFaultInjection [in] Disable App Verifier Fault injection for tracing
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
NOTHROW void InitializeDebugging(BOOL bDisableFaultInjection)
{
    // For debug builds or if we have retail tracing enabled we need to
    // include the tracing code.
    // Ignore the error return, since we don't return it here anyway.
    //
#ifdef ENABLETRACE
    (void) HrInitTracing(bDisableFaultInjection);
#endif

#if defined(DBG) && defined(_INC_CRTDBG) && defined(_DEBUG)
    if (FIsDebugFlagSet (dfidDumpLeaks))
    {
        InitDbgState();
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   UnInitializeDebugging
//
//  Purpose:    Uninitialize the debugging objects (Tracing and DbgFlags)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
NOTHROW void UnInitializeDebugging()
{
    // For debug builds or if we have retail tracing enabled we will have
    // included the tracing code.  We now need to uninitialize it.
    // Ignore the error return, since we don't return it here anyway.
    //
#ifdef ENABLETRACE

    (void) HrUnInitTracing();

#endif

#if defined(DBG) && defined(_INC_CRTDBG) && defined(_DEBUG)
    if (FIsDebugFlagSet (dfidDumpLeaks))
    {
        UnInitDbgState();
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\tracetag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . C P P
//
//  Contents:   TraceTag list for the NetCfg Project
//
//  Notes:
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include "tracetag.h"


// This is the TraceTag list that everyone should be modifying.
//
TraceTagElement g_TraceTags[] =
{
//      :-----------    TraceTagId  ttid
//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:
//      | | |                                                                       |   |   |
//      | | |                                                                       |   |   |
//      | | :-----------------------------------------:                             |   |   |
//      | :-------------------:                       |                             |   |   |
//      |                     |                       |                             |   |   |
//      v                     v                       v                             v   v   v
//
    { ttidDefault,          "Default",              "Default",                      0,  0,  0 },
    { ttidAdvCfg,           "AdvCfg",               "Advanced Config",              0,  0,  0 },
    { ttidAllocations,      "Allocations",          "All object allocations",       0,  0,  0 },
    { ttidAtmArps,          "AtmArps",              "ATM ARP Server",               0,  0,  0 },
    { ttidAtmLane,          "AtmLane",              "ATM LAN Emulator",             0,  0,  0 },
    { ttidAtmUni,           "AtmUni",               "ATM UNI Call Manager",         0,  0,  0 },
    { ttidBeDiag,           "BeDiag",               "Binding Engine Diagnostics",   0,  0,  0 },
    { ttidBenchmark,        "Benchmarks",           "Benchmarks",                   0,  0,  0 },
    { ttidBrdgCfg,          "Bridge",               "MAC Bridge",                   0,  0,  0 },
    { ttidClassInst,        "ClassInstaller",       "Class Installer",              0,  0,  0 },
    { ttidConFoldEntry,     "ConFoldEntry",         "Connection Folder Entries",    0,  0,  0 },
    { ttidConman,           "Conman",               "Connection Manager",           0,  0,  0 },
    { ttidConnectionList,   "ConnectionList",       "Connection List",              0,  0,  0 },
    { ttidDHCPServer,       "DHCPServer",           "DHCP Server Config",           0,  0,  0 },
    { ttidDun,              "Win9xDunFile",         "Windows9x .dun file handling", 0,  0,  0 },
    { ttidError,            "Errors",               "Errors",                       1,  0,  0 },
    { ttidEsLock,           "EsLocks",              "Exception safe locks",         0,  0,  0 },
    { ttidEvents,           "Events",               "Netman Event Handler",         0,  0,  0 },
    { ttidGPNLA,            "GPNLA",                "Group Policies for NLA",       0,  0,  0 },   // NLA = Network Location Awareness.
    { ttidGuiModeSetup,     "GuiModeSetup",         "Gui Mode Setup Wizard",        0,  0,  0 },
    { ttidIcons,            "Icons",                "Shell Icons",                  0,  0,  0 },
    { ttidInfExt,           "InfExtensions",        "INF Extension processing",     0,  0,  0 },
    { ttidInstallQueue,     "InstallQueue",         "Install Queue",                0,  0,  0 },
    { ttidISDNCfg,          "ISDNCfg",              "ISDN Wizard/PropSheets",       0,  0,  0 },
    { ttidLana,             "LanaMap",              "LANA map munging",             0,  0,  0 },
    { ttidLanCon,           "LanCon",               "LAN Connections",              0,  0,  0 },
    { ttidLanUi,            "LanUi",                "Lan property & wizard UI",     0,  0,  0 },
    { ttidMenus,            "Menus",                "Context menus",                0,  0,  0 },
    { ttidMSCliCfg,         "MSCliCfg",             "MS Client",                    0,  0,  0 },
    { ttidNcDiag,           "NcDiag",               "Net Config Diagnostics",       0,  0,  0 },
    { ttidNetComm,          "NetComm",              "Common Property Pages",        0,  0,  0 },
    { ttidNetOc,            "NetOc",                "Network Optional Components",  0,  0,  0 },
    { ttidNetSetup,         "NetSetup",             "Netsetup",                     0,  0,  0 },
    { ttidNetUpgrade,       "NetUpgrd",             "NetUpgrd",                     0,  0,  0 },
    { ttidNetcfgBase,       "NetcfgBase",           "NetCfg Base Object",           0,  0,  0 },
    { ttidNetCfgBind,       "Bind",                 "NetCfg Bindings (VERBOSE)",    0,  0,  1 },
    { ttidNetCfgPnp,        "Pnp",                  "NetCfg PnP notifications",     0,  0,  0 },
    { ttidNotifySink,       "NotifySink",           "Notify Sink",                  0,  0,  0 },
    { ttidNWClientCfg,      "NWClientCfg",          "NetWare Client Config",        0,  0,  0 },
    { ttidNWClientCfgFn,    "NWClientCfgFn",        "NetWare Client Config Fn",     0,  0,  0 },
    { ttidRasCfg,           "RasCfg",               "RAS Configuration",            0,  0,  0 },
    { ttidShellFolder,      "ShellFolder",          "Shell Folder",                 0,  0,  0 },
    { ttidShellFolderIface, "ShellFolderIface",     "Shell Folder COM Interfaces",  0,  0,  1 },
    { ttidShellViewMsgs,    "ShellViewMsgs",        "Shell View Callback Messages", 0,  0,  1 },
    { ttidSrvrCfg,          "SrvrCfg",              "Server",                       0,  0,  0 },
    { ttidStatMon,          "StatMon",              "StatMon",                      0,  0,  0 },
    { ttidSvcCtl,           "ServiceControl",       "Service control activities",   0,  0,  0 },
    { ttidSystray,          "SysTray",              "Taskbar Notification Area",    0,  0,  0 },
    { ttidTcpip,            "Tcpip",                "Tcpip Config",                 0,  0,  0 },
    { ttidWanCon,           "WanCon",               "WAN Connections",              0,  0,  0 },
    { ttidWizard,           "Wizard",               "Connections Wizard",           0,  0,  0 },
    { ttidWlbs,             "WLBS",                 "WLBS Config",                  0,  0,  0 }, /* maiken 5.25.00 */
};

const INT g_nTraceTagCount = celems(g_TraceTags);

#endif //! ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncdebug\trace.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . C P P
//
//  Contents:   The actual tracing code (loading from ini, calling the
//              trace routines, etc.
//
//  Notes:
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <crtdbg.h>
#include "ncdebug.h"
#include "ncmisc.h"

#include <ntrtl.h>

#include <avrf.h>

DWORD g_dwTlsTracing = 0;
LPCRITICAL_SECTION g_csTracing = NULL;

#define MAX_TRACE_LEN 4096

EXTERN_C
IMAGE_DOS_HEADER __ImageBase;

//---[ CTracing class ]-------------------------------------------------------
//
// Don't give this class a constructor or destructor.  We declare a global
// (static to this module) instance of this class and, by definition, static
// variables are automatically initialized to zero.
//
class CTracing 
{
public:
    CTracing();
    ~CTracing();
    // Initialize/Deinitialize this class
    //
private:
    HRESULT HrInit();
    HRESULT HrUnInit();

public:
    VOID Trace( TraceTagId    ttid,
                PCSTR         pszaTrace );

private:
    BOOL    m_fInitialized;                 // Has the object been initialized
    BOOL    m_fAttemptedLogFileOpen;        // Already attempted to open log
    BOOL    m_fDisableLogFile;              // Disable use of file logging?
    UINT    m_uiAllocOnWhichToBreak;        // For _CrtSetBreakAlloc
    HANDLE  m_hLogFile;                     // Handle for debug output file
    CHAR    m_szLogFilePath[MAX_PATH+1];    // File for debug output
    BOOL    m_fDebugFlagsLoaded;            // Have these been loaded yet.

    VOID    CorruptionCheck();              // Validate the tracetag structure

    HRESULT HrLoadOptionsFromIniFile();
    HRESULT HrLoadSectionsFromIniFile();
    HRESULT HrLoadDebugFlagsFromIniFile();
    HRESULT HrWriteDebugFlagsToIniFile();
    HRESULT HrOpenLogFile();

    HRESULT HrProcessTagSection(TraceTagElement *   ptte);
    HRESULT HrGetPrivateProfileString(  PCSTR   lpAppName,
                                        PCSTR   lpKeyName,
                                        PCSTR   lpDefault,
                                        PSTR    lpReturnedString,
                                        DWORD   nSize,
                                        PCSTR   lpFileName,
                                        DWORD * pcchReturn );
    HRESULT FIniFileInit(); // Returns S_OK if the file exist
};


//---[ Static Variables ]-----------------------------------------------------

#pragma warning(disable:4073) // warning about the following init_seg statement
#pragma init_seg(lib)
static CTracing g_Tracing;                      // Our global tracing object

//---[ Constants ]------------------------------------------------------------

static const WCHAR  c_szDebugIniFileName[]  = L"netcfg.ini"; // .INI file
             CHAR   c_szDebugIniFileNameA[MAX_PATH];       // .INI file
static const CHAR   c_szTraceLogFileNameA[] = "nctrace.log";      // .LOG file

// constants for the INI file labels
static const CHAR   c_szaOptions[]          = "Options";
static const CHAR   c_szaLogFilePath[]      = "LogFilePath";
static const CHAR   c_szaDisableLogFile[]   = "DisableLogFile";

const INT   c_iDefaultDisableLogFile    = 0;

static CHAR   c_szLowMemory[]         = "<low on memory>";

//+---------------------------------------------------------------------------
//
//  Function:   HrInitTracing
//
//  Purpose:    Initialize the Tracing object and other random data.
//
//  Arguments:
//      bDisableFaultInjection [in] Disable App Verifier Fault injection for tracing
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   9 Apr 1997
//
//  Notes:
//
HRESULT HrInitTracing(BOOL bDisableFaultInjection)
{
    HMODULE hVrfLib;
    VERIFIER_ENABLE_FAULT_INJECTION_EXCLUSION_RANGE_FUNCTION pfnVrfEnable;
    ULONG Index;

    if (bDisableFaultInjection)
    {
        if (NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) 
        {
            hVrfLib = LoadLibrary (L"verifier.dll");
            if (hVrfLib)
            {
                // If appverifier is not enabled on this process, the LoadLibrary will fail.

                pfnVrfEnable = (VERIFIER_ENABLE_FAULT_INJECTION_EXCLUSION_RANGE_FUNCTION)GetProcAddress(hVrfLib, "VerifierEnableFaultInjectionExclusionRange");

                if (pfnVrfEnable)
                {
                    Index = pfnVrfEnable(HrInitTracing, HrUnInitTracing);
            
                    WCHAR szTmp[MAX_PATH * 2];
                    DWORD dwProcessId = GetCurrentProcessId();

                    WCHAR szModuleName[MAX_PATH];
                    ZeroMemory(szModuleName, MAX_PATH);
                    if (!GetModuleFileName(reinterpret_cast<HMODULE>(&__ImageBase), szModuleName, MAX_PATH))
                    {
                        if (!GetModuleFileName(reinterpret_cast<HMODULE>(::GetModuleHandle(NULL)), szModuleName, MAX_PATH))
                        {
                            wsprintfW(szModuleName, L"<unknown>");
                        }
                    }

                    if (0 == Index)
                    {
                        wsprintfW(szTmp, L"NETCFG: %s (%x) Tracing initialized. Problem disabling AVRF fault injection.\n", szModuleName, dwProcessId);
                    }
                    else
                    {
                        wsprintfW(szTmp, L"NETCFG: %s (%x) Tracing initialized. Disabled AVRF fault injection for tracing. Index = %x\n", szModuleName, dwProcessId, Index);
                    }

                    OutputDebugString(szTmp);
                }
            }
        }
    }

    return S_OK;
}

extern HANDLE g_hHeap;
//+---------------------------------------------------------------------------
//
//  Function:   HrMallocNoFI
//
//  Purpose:    HRESULT returning version of malloc. This version is immune 
//              against AVRF fault injection due to the 
//              VerifierEnableFaultInjectionExclusionRange call in 
//              HrInitTracing above.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Address of returned allocation.
//
//  Returns:    S_OK or E_OUTOFMEMORY;
//
//  Author:     deonb    6/24/02
//
//  Notes:      Free the returned buffer with MemFree.
//
HRESULT HrMallocNoFI(size_t cb, PVOID* ppv) throw()
{
    Assert(ppv);
    *ppv = NULL;

    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
        if (!g_hHeap)
        {
            return E_UNEXPECTED;
        }
    }

    *ppv = HeapAlloc (g_hHeap, 0, cb);
    if (!*ppv)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

class CNoFaultInject {} NO_FI;
class CThrowOnFail   {} THROW_ON_FAIL;

NOTHROW VOID* __cdecl operator new (
    size_t cb,
    CNoFaultInject &NoFi
    ) throw()
{
    LPVOID lpv = NULL;
    HRESULT hr = HrMallocNoFI (cb, &lpv);

    if (SUCCEEDED(hr))
    {
        return lpv;
    }
    else
    {
        return NULL;
    }
}

NOTHROW VOID __cdecl operator delete (
    void* pv,
    CNoFaultInject &NoFi
    ) throw()
{
    LPVOID lpv = NULL;
    MemFree(pv);
}

VOID*
__cdecl
operator new (
    size_t cb,
    CNoFaultInject &NoFault,
    CThrowOnFail &
    )
{
    LPVOID lpv = NULL;
    HRESULT hr = HrMallocNoFI (cb, &lpv);

    if (SUCCEEDED(hr))
    {
        return lpv;
    }
    else
    {
        throw std::bad_alloc();
    }
}

namespace NOFAULT_ALLOC
{
    template<class T> inline
        T _FARQ *_NoFaultAllocate(_PDFT nCount, T _FARQ *)
    {
        if (nCount < 0)
        {
            nCount = 0;
        }

        // Call our throwing form of operator new. This will throw a bad_alloc on failure.
        return ((T _FARQ *)operator new((_SIZT)nCount * sizeof (T), NO_FI, THROW_ON_FAIL)); 
    }

    // TEMPLATE FUNCTION _Construct
    // See comments for _Allocate
    template<class T1, class T2> inline
        void _NoFaultConstruct(T1 _FARQ *p, const T2& v)
    {
        // Placement new only. No memory allocation, hence no need to throw.
        new ((void _FARQ *)p) T1(v); 
    }

    // TEMPLATE FUNCTION _Destroy
    // See comments for _Allocate
    template<class T> 
        inline void _NoFaultDestroy(T _FARQ *p)
    {
        (p)->~T(); // call the destructor
    }

    // FUNCTION _Destroy
    // See comments for _Allocate
    inline void _NoFaultDestroy(char _FARQ *p)
    {
        (void *)p;
    }

    // FUNCTION _Destroy
    // See comments for _Allocate
    inline void _NoFaultDestroy(wchar_t _FARQ *p)
    {
        (void *)p;
    }

        
    template<class T>
        class nofault_allocator
    {
        public:
            typedef _SIZT size_type;
            typedef _PDFT difference_type;
            typedef T _FARQ *pointer;
            typedef const T _FARQ *const_pointer;
            typedef T _FARQ& reference;
            typedef const T _FARQ& const_reference;
            typedef T value_type;

            pointer address(reference x) const
            {
                return (&x); 
            }

            const_pointer address(const_reference x) const
            {
                return (&x); 
            }
        
            pointer allocate(size_type nCount, const void *)
            {
                return (_NoFaultAllocate((difference_type)nCount, (pointer)0)); 
            }
        
            char _FARQ *_Charalloc(size_type nCount)
            {
                return (_NoFaultAllocate((difference_type)nCount, (char _FARQ *)0)); 
            }
        
            void deallocate(void _FARQ *p, size_type)
            {
                operator delete(p); 
            }
        
            void construct(pointer p, const T& v)
            {
                _NoFaultConstruct(p, v); 
            }
        
            void destroy(pointer p)
            {
                _NoFaultDestroy(p); 
            }
        
            _SIZT max_size() const
            {
                _SIZT nCount = (_SIZT)(-1) / sizeof (T);
                return (0 < nCount ? nCount : 1); 
            }
    };

    template<class T, class U>
        bool operator ==(const nofault_allocator<T>&, const nofault_allocator<U>&)
    {
        return (true); 
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   HrUnInitTracing
//
//  Purpose:    Uninitialize the tracing object.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or a valid Win32 HRESULT
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
HRESULT HrUnInitTracing()
{
    return S_OK;
}

const DWORD TI_HRESULT      = 0x00000001;
const DWORD TI_WIN32        = 0x00000002;
const DWORD TI_IGNORABLE    = 0x00000004;

//+---------------------------------------------------------------------------
//
//  Function:   TraceInternal
//
//  Purpose:    The one and only place that a string to be traced is formed
//              and traced.
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   13 Mar 1998
//
//  Notes:      Restructured from lots of other code that was added to this
//              module over the past year.
//
VOID
TraceInternal (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    DWORD       dwFlags,
    PCSTR       pszaCallerText,
    DWORD       dwErrorCode,
    BOOL        bTraceStackOnError)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    BOOL fError     = dwFlags & (TI_HRESULT | TI_WIN32);
    BOOL fIgnorable = dwFlags & TI_IGNORABLE;

    HRESULT hr           = (dwFlags & TI_HRESULT) ? dwErrorCode : S_OK;
    DWORD   dwWin32Error = (dwFlags & TI_WIN32)   ? dwErrorCode : ERROR_SUCCESS;

    // Ignore if told and we're not set to trace ignored errors or warnings.
    //
    if (fError && fIgnorable &&
        !FIsDebugFlagSet (dfidShowIgnoredErrors) &&
        !FIsDebugFlagSet (dfidExtremeTracing))
    {
        return;
    }

    // Don't do anything if we're tracing for an error and we don't have one,
    // unless the "Extreme Tracing" flag is on, in which case we trace
    // everything in the world (for debugger use only, really)
    // This is the path taken by TraceError ("...", S_OK) or
    // TraceLastWin32Error when there is no last Win32 error.
    //
    if (fError && !dwErrorCode && !FIsDebugFlagSet(dfidExtremeTracing))
    {
        return;
    }

    CHAR *pszaBuf = new(NO_FI) CHAR[MAX_TRACE_LEN * 2];
    PSTR pcha = pszaBuf;

    // Form the prefix, process id and thread id.
    //
    static const CHAR c_szaFmtPrefix [] = "NETCFG";
    lstrcpyA (pcha, c_szaFmtPrefix);
    pcha += lstrlenA (c_szaFmtPrefix);

    // Add process and thread ids if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidShowProcessAndThreadIds))
    {
        static const CHAR c_szaFmtPidAndTid [] = " %03x.%03x";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtPidAndTid,
                    GetCurrentProcessId (),
                    GetCurrentThreadId ());
    }

    // Add a time stamp if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidTracingTimeStamps))
    {
        static const CHAR c_szaFmtTime [] = " [%02dh%02d:%02d.%03d]";

        SYSTEMTIME stLocal;
        GetLocalTime (&stLocal);
        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTime,
                    stLocal.wHour,
                    stLocal.wMinute,
                    stLocal.wSecond,
                    stLocal.wMilliseconds);
    }

    // Add a severity indicator if this trace is for an error or warning.
    //
    if (fError || (ttidError == ttid))
    {
        static const CHAR c_szaSevIgnored [] = " Ignored:";
        static const CHAR c_szaSevError   [] = " *ERROR*:";
        static const CHAR c_szaSevWarning [] = " Warning:";

        PCSTR pszaSev = NULL;

        if (fError && SUCCEEDED(hr) && !dwWin32Error && !fIgnorable)
        {
            pszaSev = c_szaSevWarning;
        }
        else
        {
            if (fIgnorable && FIsDebugFlagSet (dfidShowIgnoredErrors))
            {
                pszaSev = c_szaSevIgnored;
            }
            else
            {
                pszaSev = c_szaSevError;
            }
        }
        Assert (pszaSev);

        lstrcatA (pcha, pszaSev);
        pcha += lstrlenA (pszaSev);
    }

    // Add the tracetag short name.  Don't do this for ttidError if
    // we already have the severity indicator from above.
    //
    if (ttid && (ttid < g_nTraceTagCount) && (ttid != ttidError))
    {
        if (FIsDebugFlagSet(dfidTraceMultiLevel))
        {
            static const CHAR c_szaFmtTraceTag [] = " (%-16s)";
            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTraceTag,
                        g_TraceTags[ttid].szShortName);
        }
        else
        {
            static const CHAR c_szaFmtTraceTag [] = " (%s)";
            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTraceTag,
                        g_TraceTags[ttid].szShortName);
        }
    
        *pcha = ' ';
        pcha++;
        
        if (FIsDebugFlagSet(dfidTraceMultiLevel))
        {
            // Add the indentation text.

            DWORD dwNumSpaces = CTracingIndent::getspaces();
            Assert(dwNumSpaces >= 2);
            
            pcha += _snprintf(pcha, MAX_TRACE_LEN, "%1x", dwNumSpaces - 2);
            
            memset(pcha, '-', dwNumSpaces-1 );
            pcha += dwNumSpaces-1;
        }
    }
    else
    {
        *pcha = ' ';
        pcha++;
    }

    // Add the caller's text.
    //
    if (pszaCallerText)
    {
        static const CHAR c_szaFmtCallerText [] = "%s";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtCallerText,
                    pszaCallerText);

        Assert (pcha > pszaBuf);
        if ('\n' == *(pcha-1))
        {
            pcha--;
            *pcha = 0;
        }
    }

    // Add descriptive error text if this is an error and we can get some.
    //
    if (FAILED(hr) || dwWin32Error)
    {
        BOOL fFacilityWin32 = (FACILITY_WIN32 == HRESULT_FACILITY(hr));

        // dwError will be the error code we pass to FormatMessage.  It may
        // come from hr or dwWin32Error.  Give preference to hr.
        //
        DWORD dwError = 0;

        if (fFacilityWin32)
        {
            dwError = HRESULT_CODE(hr);
        }
        else if (FAILED(hr))
        {
            dwError = hr;
        }
        else
        {
            dwError = dwWin32Error;
        }
        Assert (dwError);

        if (!FIsDebugFlagSet (dfidNoErrorText))
        {
            PSTR pszaErrorText = NULL;
            FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, dwError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                           (PSTR)&pszaErrorText, 0, NULL);

            if (pszaErrorText)
            {
                // Strip off newline characters.
                //
                PSTR pchText = pszaErrorText;
                while (*pchText && (*pchText != '\r') && (*pchText != '\n'))
                {
                    pchText++;
                }
                *pchText = 0;

                // Add the error text.
                //
                static const CHAR c_szaFmtErrorText [] = " [%s]";

                pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtErrorText,
                            pszaErrorText);

                LocalFree (pszaErrorText);
            }
        }

        // Add the Win32 error code.
        //
        if (fFacilityWin32 || dwWin32Error)
        {
            static const CHAR c_szaFmtWin32Error [] = " Win32=%d,0x%08X";

            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtWin32Error,
                        dwError, dwError);
        }
    }

    // Add the HRESULT.
    //
    if (S_OK != hr)
    {
        static const CHAR c_szaFmtHresult [] = " hr=0x%08X";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtHresult,
                    hr);
    }

    // Add the file and line.
    //
    if (pszaFile)
    {
        static const CHAR c_szaFmtFileAndLine [] = " File:%s,%d";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtFileAndLine,
                    pszaFile, nLine);
    }

    // Add the newline.
    //
    lstrcatA (pcha, "\n");

    g_Tracing.Trace (ttid, pszaBuf);

    // Now that the message is on the debugger, break if we have an error
    // and the debug flag to break on error is set.
    //
    if ((FAILED(hr) || dwWin32Error || (ttidError == ttid)) &&
        !fIgnorable && FIsDebugFlagSet(dfidBreakOnError))
    {
        DebugBreak();
    }

    if ( (bTraceStackOnError) && FIsDebugFlagSet(dfidTraceCallStackOnError) && (ttid == ttidError) )
    {
        CTracingIndent::TraceStackFn(ttidError);
    }

    delete[] pszaBuf;
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceInternal
//
//  Purpose:    The one and only place that a string to be traced is formed
//              and traced.
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   13 Mar 1998
//
//  Notes:      Restructured from lots of other code that was added to this
//              module over the past year.
//
VOID
TraceInternal (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    DWORD       dwFlags,
    PCSTR       pszaCallerText,
    DWORD       dwErrorCode,
    BOOL        bTraceStackOnError)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    BOOL fError     = dwFlags & (TI_HRESULT | TI_WIN32);
    BOOL fIgnorable = dwFlags & TI_IGNORABLE;

    HRESULT hr           = (dwFlags & TI_HRESULT) ? dwErrorCode : S_OK;
    DWORD   dwWin32Error = (dwFlags & TI_WIN32)   ? dwErrorCode : ERROR_SUCCESS;

    // Ignore if told and we're not set to trace ignored errors or warnings.
    //
    if (fError && fIgnorable &&
        !FIsDebugFlagSet (dfidShowIgnoredErrors) &&
        !FIsDebugFlagSet (dfidExtremeTracing))
    {
        return;
    }

    // Don't do anything if we're tracing for an error and we don't have one,
    // unless the "Extreme Tracing" flag is on, in which case we trace
    // everything in the world (for debugger use only, really)
    // This is the path taken by TraceError ("...", S_OK) or
    // TraceLastWin32Error when there is no last Win32 error.
    //
    if (fError && !dwErrorCode && !FIsDebugFlagSet(dfidExtremeTracing))
    {
        return;
    }

    CHAR *pszaBuf = new(NO_FI) CHAR[MAX_TRACE_LEN * 2];
    PSTR pcha = pszaBuf;

    // Form the prefix, process id and thread id.
    //
    static const CHAR c_szaFmtPrefix [] = "NETCFG";
    lstrcpyA (pcha, c_szaFmtPrefix);
    pcha += lstrlenA (c_szaFmtPrefix);

    // Add process and thread ids if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidShowProcessAndThreadIds))
    {
        static const CHAR c_szaFmtPidAndTid [] = " %03d.%03d";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtPidAndTid,
                    GetCurrentProcessId (),
                    GetCurrentThreadId ());
    }

    // Add a time stamp if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidTracingTimeStamps))
    {
        static const CHAR c_szaFmtTime [] = " [%02d:%02d:%02d.%03d]";

        SYSTEMTIME stLocal;
        GetLocalTime (&stLocal);
        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTime,
                    stLocal.wHour,
                    stLocal.wMinute,
                    stLocal.wSecond,
                    stLocal.wMilliseconds);
    }

    // Add a severity indicator if this trace is for an error or warning.
    //
    if (fError || (ttidError == ttid))
    {
        static const CHAR c_szaSevIgnored [] = " Ignored:";
        static const CHAR c_szaSevError   [] = " *ERROR*:";
        static const CHAR c_szaSevWarning [] = " Warning:";

        PCSTR pszaSev = NULL;

        if (fError && SUCCEEDED(hr) && !dwWin32Error && !fIgnorable)
        {
            pszaSev = c_szaSevWarning;
        }
        else
        {
            if (fIgnorable && FIsDebugFlagSet (dfidShowIgnoredErrors))
            {
                pszaSev = c_szaSevIgnored;
            }
            else
            {
                pszaSev = c_szaSevError;
            }
        }
        Assert (pszaSev);

        lstrcatA (pcha, pszaSev);
        pcha += lstrlenA (pszaSev);
    }

    // Add the tracetag short name.  Don't do this for ttidError if
    // we already have the severity indicator from above.
    //
    if (ttid && (ttid < g_nTraceTagCount) && (ttid != ttidError))
    {
        static const CHAR c_szaFmtTraceTag [] = " (%s)";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTraceTag,
                    g_TraceTags[ttid].szShortName);
    }

    // Add the caller's text.
    //
    if (pszaCallerText)
    {
        static const CHAR c_szaFmtCallerText [] = " %s";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtCallerText,
                    pszaCallerText);

        Assert (pcha > pszaBuf);
        if ('\n' == *(pcha-1))
        {
            pcha--;
            *pcha = 0;
        }
    }

    // Add descriptive error text if this is an error and we can get some.
    //
    if (FAILED(hr) || dwWin32Error)
    {
        BOOL fFacilityWin32 = (FACILITY_WIN32 == HRESULT_FACILITY(hr));

        // dwError will be the error code we pass to FormatMessage.  It may
        // come from hr or dwWin32Error.  Give preference to hr.
        //
        DWORD dwError = 0;

        if (fFacilityWin32)
        {
            dwError = HRESULT_CODE(hr);
        }
        else if (FAILED(hr))
        {
            dwError = hr;
        }
        else
        {
            dwError = dwWin32Error;
        }
        Assert (dwError);

        if (!FIsDebugFlagSet (dfidNoErrorText))
        {
            PSTR pszaErrorText = NULL;
            FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, dwError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                           (PSTR)&pszaErrorText, 0, NULL);

            if (pszaErrorText)
            {
                // Strip off newline characters.
                //
                PSTR pchText = pszaErrorText;
                while (*pchText && (*pchText != '\r') && (*pchText != '\n'))
                {
                    pchText++;
                }
                *pchText = 0;

                // Add the error text.
                //
                static const CHAR c_szaFmtErrorText [] = " [%s]";

                pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtErrorText,
                            pszaErrorText);

                LocalFree (pszaErrorText);
            }
        }

        // Add the Win32 error code.
        //
        if (fFacilityWin32 || dwWin32Error)
        {
            static const CHAR c_szaFmtWin32Error [] = " Win32=%d,0x%08X";

            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtWin32Error,
                        dwError, dwError);
        }
    }

    // Add the HRESULT.
    //
    if (S_OK != hr)
    {
        static const CHAR c_szaFmtHresult [] = " hr=0x%08X";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtHresult,
                    hr);
    }

    // Add the file and line.
    //
    if (pszaFile)
    {
        static const CHAR c_szaFmtFileAndLine [] = " File:%s,%d";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtFileAndLine,
                    pszaFile, nLine);
    }

    // Add the function name
    //
    if (pszaFunc)
    {
        static const CHAR c_szaFmtFunc[] = ":";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtFunc, pszaFunc);
    }
    
    // Add the newline.
    //
    lstrcatA (pcha, "\n");

    g_Tracing.Trace (ttid, pszaBuf);

    // Now that the message is on the debugger, break if we have an error
    // and the debug flag to break on error is set.
    //
    if ((FAILED(hr) || dwWin32Error || (ttidError == ttid)) &&
        !fIgnorable && FIsDebugFlagSet(dfidBreakOnError))
    {
        DebugBreak();
    }

    if ( (bTraceStackOnError) && FIsDebugFlagSet(dfidTraceCallStackOnError) && (ttid == ttidError) )
    {
        CTracingIndent::TraceStackFn(ttidError);
    }

    delete[] pszaBuf;
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorFn
//
//  Purpose:    Output debug trace of an HRESULT, allowing an additional
//              caller-defined error string.
//
//  Arguments:
//      sz          []  Caller-defined additional error text
//      hr          []  The error HRESULT.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPI
TraceErrorFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr)
{   
    DWORD dwFlags = TI_HRESULT;
    if (S_FALSE == hr)
    {
        dwFlags |= TI_IGNORABLE;
    }

    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorOptionalFn
//
//  Purpose:    Implements TraceErrorOptional macro
//
//  Arguments:
//      pszaFile [in]     __FILE__ value
//      nLine    [in]     __LINE__ value
//      psza     [in]     String to trace.
//      hr       [in]     HRESULT value to trace.
//      fOpt     [in]     TRUE if error should be treated as optional, FALSE if
//                        ERROR is not optional and should be reported thru
//                        TraceError().
//
//  Returns:    Nothing.
//
//  Author:     danielwe   12 May 1997
//
//  Notes:
//
VOID
WINAPI
TraceErrorOptionalFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr,
    BOOL    fIgnorable)
{
    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }

    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr, TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorSkipFn
//
//  Purpose:    Implements TraceErrorOptional macro
//
//  Arguments:
//      pszaFile [in]     __FILE__ value
//      nLine    [in]     __LINE__ value
//      psza     [in]     String to trace.
//      hr       [in]     HRESULT value to trace.
//      c        [in]     count of pass-through Hresults.  if hr is any of these
//                        the error is treated as optional.
//      ...      [in]     list of hresults.
//
//  Returns:    Nothing.
//
//  Author:     sumitc      08 Jan 1998
//
//  Notes:
//
VOID WINAPI
TraceErrorSkipFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr,
    UINT    c, ...)
{
    va_list valMarker;
    BOOL fIgnorable = FALSE;

    va_start(valMarker, c);
    for (UINT i = 0; i < c; ++i)
    {
        fIgnorable = (va_arg(valMarker, HRESULT) == hr);
        if (fIgnorable)
        {
            break;
        }
    }
    va_end(valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceLastWin32ErrorFn
//
//  Purpose:    Trace the last Win32 error, which we get with GetLastError().
//              Not a whole lot to it.
//
//  Arguments:
//      sz []   Additional error text.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPIV
TraceLastWin32ErrorFn (
    PCSTR  pszaFile,
    INT    nLine,
    PCSTR  psza)
{
    TraceInternal (ttidError, pszaFile, nLine, TI_WIN32, psza, GetLastError(), TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceHrFn
//
//  Purpose:    Generic replacement for the TraceErrorOptional, TraceError,
//              and a couple other random functions.
//
//  Arguments:
//      ttid       [] TraceTag to use for the debug output
//      pszaFile   [] Source file to log
//      nLine      [] Line number to log
//      hr         [] Error to log
//      fIgnorable [] Ignore this error? (The optional bit)
//      pszaFmt    [] Format of the vargs
//
//  Returns:
//
//  Author:     jeffspr   10 Oct 1997
//
//  Notes:
//
VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnorable,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR *pszaBuf = new(NO_FI) CHAR[MAX_TRACE_LEN];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);
    vsprintf (pszaBuf, pszaFmt, valMarker);
    va_end (valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttid, pszaFile, nLine, dwFlags, pszaBuf, hr, TRUE);

    delete[] pszaBuf;
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceHrFn
//
//  Purpose:    Generic replacement for the TraceErrorOptional, TraceError,
//              and a couple other random functions.
//
//  Arguments:
//      ttid       [] TraceTag to use for the debug output
//      pszaFile   [] Source file to log
//      nLine      [] Line number to log
//      hr         [] Error to log
//      fIgnorable [] Ignore this error? (The optional bit)
//      pszaFmt    [] Format of the vargs
//
//  Returns:
//
//  Author:     jeffspr   10 Oct 1997
//
//  Notes:
//
VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    HRESULT     hr,
    BOOL        fIgnorable,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR *pszaBuf = new(NO_FI) CHAR[MAX_TRACE_LEN];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);
    _vsnprintf (pszaBuf, MAX_TRACE_LEN, pszaFmt, valMarker);
    va_end (valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttid, pszaFile, nLine, pszaFunc, dwFlags, pszaBuf, hr, TRUE);
    
    delete[] pszaBuf;
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceTagFn
//
//  Purpose:    Output a debug trace to one or more trace targets (ODS,
//              File, COM port, etc.). This function determines the targets
//              and performs the actual trace.
//
//  Arguments:
//      ttid    []  TraceTag to use for the debug output
//      pszaFmt []  Format of the vargs.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPIV
TraceTagFn (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR *pszaBuf = new(NO_FI) CHAR[MAX_TRACE_LEN];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);
    _vsnprintf (pszaBuf, MAX_TRACE_LEN, pszaFmt, valMarker);
    va_end (valMarker);

    TraceInternal (ttid, NULL, 0, 0, pszaBuf, 0, TRUE);

    delete[] pszaBuf;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::CTracing
//
//  Purpose:    Constructor for CTracing. Initialize all vars.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Jan 1999
//
//  Notes:
//
CTracing::CTracing()
{
    m_fInitialized          = FALSE;    // Has the object been initialized
    m_fAttemptedLogFileOpen = FALSE;    // Already attempted to open log
    m_fDisableLogFile       = FALSE;    // Disable use of file logging?
    m_uiAllocOnWhichToBreak = 0;        // For _CrtSetBreakAlloc
    m_hLogFile              = NULL;     // Handle for debug output file
    m_szLogFilePath[0]      = '\0';     // File for debug output
    m_fDebugFlagsLoaded     = FALSE;    // Have these been loaded yet.

    g_dwTlsTracing          = NULL;
    HrInit();
}

CTracing::~CTracing()
{
    HrUnInit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrInit
//
//  Purpose:    Initialize the CTracing object.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   9 Apr 1997
//
//  Notes:      This should get called from some standard exe initialization
//              point. And make sure to call HrDeinit when you're done, eh?
//
HRESULT CTracing::HrInit()
{
    HRESULT hr  = S_OK;

    AssertSz(!m_fInitialized,
            "CTracing::HrInit -- Let's not go overboard. Already initialized");

    g_csTracing = new(NO_FI) CRITICAL_SECTION;
    Assert(g_csTracing);
    InitializeCriticalSection(g_csTracing);

    g_dwTlsTracing = TlsAlloc();
    AssertSz(g_dwTlsTracing, "g_dwTlsTracing could not aquire a TLS slot");

    hr = FIniFileInit();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Temporarily set this so the called functions don't believe that we're
    // uninitialized. At Exit, if we fail, we'll set it back so no-one tries
    // to call these functions when uninitialized.
    //
    m_fInitialized = TRUE;

    // Check for corruptions in the tracing structure. This can't fail, but
    // it will send up asserts all over the place if something is amiss.
    //
    CorruptionCheck();

    // Load the "options" section from the ini file
    //
    hr = HrLoadOptionsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Load the DebugFlags section from the ini file.
    //
    hr = HrLoadDebugFlagsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Load the tracetag sections from the ini file.
    // Make sure this is called after HrLoadDebugFlagsFromIniFile(),
    // as those options will affect the tracetag sections (we also
    // assert on this)
    //
    hr = HrLoadSectionsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // If certain tracetags are on, we want others to be off because some
    // encompase the functionality of others.
    //
    if (g_TraceTags[ttidBeDiag].fOutputDebugString)
    {
        g_TraceTags[ttidNetCfgPnp].fOutputDebugString = FALSE;
    }


#ifdef ENABLELEAKDETECTION
    if (FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        g_pObjectLeakTrack = new(NO_FI) CObjectLeakTrack;
        Assert(g_pObjectLeakTrack);
    }
#endif

Exit:
    if (FAILED(hr))
    {
        m_fInitialized = FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrUnInit
//
//  Purpose:    Uninitialize the Tracing object
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrUnInit()
{
    HRESULT hr  = S_OK;

#ifdef ENABLELEAKDETECTION
    if (FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        BOOL fAsserted = g_pObjectLeakTrack->AssertIfObjectsStillAllocated(NULL);
        if (fAsserted)
        {
//            AssertSz(FALSE, "Spew is completed - press RETRY to look at spew and map ReturnAddr values to symbols");
        }
        delete g_pObjectLeakTrack;
    }
#endif
    
    if (g_dwTlsTracing)
    {
        TlsFree(g_dwTlsTracing);
        g_dwTlsTracing = 0;
    }

    if (g_csTracing)
    {
        {
            __try
            {
                EnterCriticalSection(g_csTracing);
            }
            __finally
            {
                LeaveCriticalSection(g_csTracing);
            }
        }
        
        DeleteCriticalSection(g_csTracing);
        delete g_csTracing;
        g_csTracing = NULL;
    }
    
    // Don't assert on m_fInitialized here, because we allow this to
    // be called even if initialization failed.
    //
    if (m_fInitialized)
    {
        hr = HrWriteDebugFlagsToIniFile();
        if (FAILED(hr))
        {
            // continue on, but I want to know why this is failing.
            AssertSz(FALSE, "Whoa, why can't we write the debug flags?");
        }

        // Close the log file, if there's one open
        //
        if (m_hLogFile)
        {
            CloseHandle(m_hLogFile);
            m_hLogFile = NULL;
        }

        // Mark us as being uninitialized.
        //
        m_fInitialized = FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrGetPrivateProfileString
//
//  Purpose:
//
//  Arguments:
//      lpAppName        [] points to section name
//      lpKeyName        [] points to key name
//      lpDefault        [] points to default string
//      lpReturnedString [] points to destination buffer
//      nSize            [] size of destination buffer
//      lpFileName       [] points to initialization filename
//      pcchReturn          return buffer for the old Win32 API return code
//
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrGetPrivateProfileString(    PCSTR  lpAppName,
                                                PCSTR  lpKeyName,
                                                PCSTR  lpDefault,
                                                PSTR   lpReturnedString,
                                                DWORD  nSize,
                                                PCSTR  lpFileName,
                                                DWORD* pcchReturn
)
{
    HRESULT hr              = S_OK;

    Assert(m_fInitialized);

    // Assert on the known conditions required for this API call
    //
    Assert(lpDefault);
    Assert(lpFileName);

    // Call the Win32 API
    //
    DWORD dwGPPSResult = GetPrivateProfileStringA(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName);

    // Check to see if we've gotten a string-size error
    if (lpAppName && lpKeyName)
    {
        // If we get back (nSize - 1), then our string buffer wasn't
        // large enough
        //
        if (dwGPPSResult == (nSize - 1))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
    }
    else
    {
        // Since either of the app name or key name are NULL, then
        // we're supposed to be receiving a doubly-NULL terminated
        // list of strings. If we're at (nSize - 2), that means
        // our buffer was too small.
        //
        if (dwGPPSResult == (nSize - 2))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
    }

Exit:
    *pcchReturn = dwGPPSResult;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadOptionsFromIniFile
//
//  Purpose:    Load the options section from the ini file, and set our
//              state accordingly
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadOptionsFromIniFile()
{
    HRESULT hr                          = S_OK;
    DWORD   cchReturnBufferSize         = 0;
    WCHAR   szLogFilePath[MAX_PATH+1]   = { 0 };
    DWORD   dwTempPathLength            = 0;

    // Get the explicit log file path, if any. If it doesn't exist, then
    // use the default path, which is the temp file path plus the default
    // trace file name
    //

    // Get the location of the "temporary files" path
    dwTempPathLength = GetTempPath(MAX_PATH, szLogFilePath);
    if ((dwTempPathLength == 0) ||
        (dwTempPathLength > MAX_PATH))
    {
        TraceLastWin32Error("GetTempPath failure");

        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Tack the log file name onto the end.
    //
    _snprintf(m_szLogFilePath, MAX_TRACE_LEN, "%s%s", szLogFilePath, c_szTraceLogFileNameA);

    // This will overwrite the log file path if one exists in the INI file
    //
    hr = HrGetPrivateProfileString(
            c_szaOptions,           // "Options"
            c_szaLogFilePath,       // "LogFilePath
            m_szLogFilePath,        // Default string, already filled
            m_szLogFilePath,        // Return string (same string)
            MAX_PATH+1,
            c_szDebugIniFileNameA,
            &cchReturnBufferSize);
    if (FAILED(hr))
    {
        // This should not cause problems with recursive failure, since
        // Traces will work regardless of the state of trace initialization.
        //
        TraceError(
                "GetPrivateProfileString failed on Options::LogFilePath", hr);
        goto Exit;
    }

    // Get the "disable log file option". No return code here.
    m_fDisableLogFile = GetPrivateProfileIntA(
            c_szaOptions,               // "Options"
            c_szaDisableLogFile,        // "DisableLogFile"
            c_iDefaultDisableLogFile,
            c_szDebugIniFileNameA);
    if (FAILED(hr))
    {
        TraceError(
                "GetPrivateProfileInt failed on Options::DisableLogFile", hr);
        goto Exit;
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadSectionsFromIniFile
//
//  Purpose:    Load the individual tracetag sections from the ini file, and
//              set our array elements accordingly, defaulting if necessary.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadSectionsFromIniFile()
{
    HRESULT hr = S_OK;

    // Make sure that we've loaded the debug flags first, as they can
    // affect each tracetag section
    //
    Assert(m_fDebugFlagsLoaded);

    // Loop through the array and load the data.
    //
    for (INT nLoop = 0; nLoop < g_nTraceTagCount; nLoop++ )
    {
        // Process the individual lines from the section
        hr = HrProcessTagSection(&(g_TraceTags[nLoop]));
        if (FAILED(hr))
        {
            break;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadDebugFlagsFromIniFile
//
//  Purpose:    Load the individual debugflag values from the ini file, and
//              set our array elements accordingly, defaulting if necessary.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadDebugFlagsFromIniFile()
{
    HRESULT hr                  = S_OK;
    INT     nLoop;

    // Loop through the array and load the data.
    //
    for (nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
    {
        switch(nLoop)
        {
            case dfidBreakOnAlloc:
                // Get the "break on alloc" alloc count.
                //
                m_uiAllocOnWhichToBreak = GetPrivateProfileIntA(
                    "DebugFlags",
                    g_DebugFlags[nLoop].szShortName,
                    FALSE,
                    c_szDebugIniFileNameA);
                g_DebugFlags[nLoop].dwValue = (m_uiAllocOnWhichToBreak > 0);

                // If there was a value set, set the break..
                //
                if (m_uiAllocOnWhichToBreak != 0)
                    _CrtSetBreakAlloc(m_uiAllocOnWhichToBreak);

                break;

            default:
                // Get the enabled file param
                //
                g_DebugFlags[nLoop].dwValue = GetPrivateProfileIntA(
                        "DebugFlags",
                        g_DebugFlags[nLoop].szShortName,
                        FALSE,
                        c_szDebugIniFileNameA);
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_fDebugFlagsLoaded = TRUE;
    }

    return hr;
}

HRESULT CTracing::FIniFileInit()
{
    HRESULT hr = E_FAIL;
    WCHAR   szWindowsPath[MAX_PATH+1]  = L"";
    WCHAR   szPath[MAX_PATH+1]  = L"";
    UINT    uiCharsReturned     = 0;
    HANDLE  hFile               = INVALID_HANDLE_VALUE;

    uiCharsReturned = GetWindowsDirectory(szWindowsPath, MAX_PATH);
    if ((uiCharsReturned == 0) || (uiCharsReturned > MAX_PATH))
    {
        AssertSz(FALSE, "GetWindowsDirectory failed in CTracing::FIniFileInit");

        hr = E_UNEXPECTED;
        goto Exit;
    }

    wcscpy (szPath, szWindowsPath);
    wcscat (szPath, L"\\");
    wcscat (szPath, c_szDebugIniFileName);

    hFile = CreateFile(
            szPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            AssertSz(FALSE, "FIniFileInit failed for some reason other than FILE_NOT_FOUND");
            hr = HRESULT_FROM_WIN32(dwLastError);
            goto Exit;
        }
    }
    else
    {
        hr = S_OK;
        wcstombs(c_szDebugIniFileNameA, szPath, MAX_PATH);
        goto Exit;
    }
    
    _wsplitpath(szWindowsPath, szPath, NULL, NULL, NULL);
    wcscat (szPath, L"\\");
    wcscat (szPath, c_szDebugIniFileName);

    hFile = CreateFile(
            szPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();

        hr = HRESULT_FROM_WIN32(dwLastError);
        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            AssertSz(FALSE, "FIniFileInit failed for some reason other than FILE_NOT_FOUND");
        }
    }
    else
    {
        wcstombs(c_szDebugIniFileNameA, szPath, MAX_PATH);
        hr = S_OK;
    }
    
Exit:
    if (hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return hr;
}

HRESULT CTracing::HrWriteDebugFlagsToIniFile()
{
    HRESULT hr = S_OK;

    // First, check to see if the file exists. If it doesn't, then we don't want
    // to write the entries.
    //
    if (FIniFileInit())
    {
        // Loop through the array and write the data.
        //
        for (INT nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
        {
            CHAR   szInt[16];      // Sure, it's arbitrary, but it's also OK.

            switch(nLoop)
            {
                // BreakOnAlloc is special case -- no associated flag entry
                //
                case dfidBreakOnAlloc:
                    _snprintf(szInt, MAX_TRACE_LEN, "%d", m_uiAllocOnWhichToBreak);
                    break;

                // These store a DWORD in its standard form
                //
                case dfidBreakOnHr:
                case dfidBreakOnHrIteration:
                case dfidBreakOnIteration:
                    _snprintf( szInt, MAX_TRACE_LEN, "%d", g_DebugFlags[nLoop].dwValue);
                    break;

                // default are treated as boolean, and stored that way
                //
                default:
                    // !! means it will always be 1 or 0.
                    _snprintf( szInt, MAX_TRACE_LEN, "%d", (!!g_DebugFlags[nLoop].dwValue));
                    break;
            }

            // Write the param to the ini file
            WritePrivateProfileStringA(
                    "DebugFlags",
                    g_DebugFlags[nLoop].szShortName,
                    szInt,
                    c_szDebugIniFileNameA);
        }
    }

    // For now, this is always S_OK, since there's nothing above that can
    // fail.
    //
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrProcessTagSection
//
//  Purpose:    Grab the parameters from the ini file. If they're not
//              available, then use the settings in default. Note - this
//              will always work because ttidDefault will always be the first
//              element. If a [default] section wasn't present, then it will
//              be using the settings that were in the struct initialization,
//              which is also fine.
//
//  Arguments:
//      ptte []     TraceTag element to load
//
//  Returns:
//
//  Author:     jeffspr   15 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrProcessTagSection(  TraceTagElement *   ptte )
{
    HRESULT hr                      = S_OK;

    AssertSz(m_fInitialized,
            "CTracing::HrProcessTagSection. Class not initialized");

    AssertSz(ptte, "CTracing::HrProcessTagSection -- invalid ptte");

    // Get the output to file param
    //
    ptte->fOutputToFile = GetPrivateProfileIntA(
            ptte->szShortName,
            "OutputToFile",
            ptte->fVerboseOnly ?
                FALSE : g_TraceTags[ttidDefault].fOutputToFile,
            c_szDebugIniFileNameA);

    // Get the OutputDebugString param. Require that the error tag
    // always has at least output debug string on.
    //
    if (ptte->ttid == ttidError)
    {
        ptte->fOutputDebugString = TRUE;
    }
    else
    {
        // Load the OutputToDebug
        ptte->fOutputDebugString = GetPrivateProfileIntA(
                ptte->szShortName,
                "OutputToDebug",
                ptte->fVerboseOnly ?
                    FALSE : g_TraceTags[ttidDefault].fOutputDebugString,
                c_szDebugIniFileNameA);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::CorruptionCheck
//
//  Purpose:    Validate the tracetag array. Check to see that the
//              shortnames are valid, that the descriptions are valid,
//              and that the tracetag elements are not out of order.
//              Also verify that the correct number of tracetag elements
//              exist.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   15 Apr 1997
//
//  Notes:
//      (shaunco) 16 Jul 1997: This is #if'defd out until JVert
//      gives us a fix for the alpha compiler.  It blows up compiling this
//      function in retail.
//
//      (jeffspr) Tough noogies for JVert - I need this code. Hopefully
//      this has been fixed by now.
//
VOID CTracing::CorruptionCheck()
{
    INT nLoop = 0;

    // Validate the tracetag structure
    //
    for (nLoop = 0; nLoop < g_nTraceTagCount; nLoop++)
    {
        // Verify that we're not out of order or missing ttids
        //
        AssertSz(g_TraceTags[nLoop].ttid == nLoop,
                "Invalid ttid in the tracetag structure. Out of order. " \
                "CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].ttid < g_nTraceTagCount,
                "Invalid ttid (out of range) in CTracing::CorruptionCheck");

        // Validate the shortname (verify not NULL or empty strings)
        //
        AssertSz(g_TraceTags[nLoop].szShortName,
                "Invalid tracetag short name (NULL) in CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].szShortName[0] != 0,
                "Invalid tracetagshort name (empty) in CTracing::CorruptionCheck");

        // Validate the descriptions (verify not NULL or empty strings)
        //
        AssertSz(g_TraceTags[nLoop].szDescription,
                "Invalid tracetagdescription in CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].szDescription[0] != 0,
                "Invalid tracetagdescription (empty) in CTracing::CorruptionCheck");
    }

    // Validate the debug flags structure
    //
    for (nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
    {
        // Verify that we're not out of order or missing dfids
        //
        AssertSz(g_DebugFlags[nLoop].dfid == nLoop,
                "Invalid dfid in the debugflag structure. Out of order. " \
                "CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].dfid < g_nDebugFlagCount,
                "Invalid dfid (out of range) in CTracing::CorruptionCheck");

        // Validate the shortname (verify not NULL or empty strings)
        //
        AssertSz(g_DebugFlags[nLoop].szShortName,
                "Invalid debug flag short name (NULL) in CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].szShortName[0] != 0,
                "Invalid debug flag short name (empty) in CTracing::CorruptionCheck");

        // Validate the descriptions (verify not NULL or empty strings)
        //
        AssertSz(g_DebugFlags[nLoop].szDescription,
                "Invalid debug flag description in CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].szDescription[0] != 0,
                "Invalid debug flag description (empty) in CTracing::CorruptionCheck");
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::Trace
//
//  Purpose:    The actual trace call that takes care of doing the output
//              to each trace target (file, OutputDebugString, etc.)
//
//  Arguments:
//      ttid      []     The tracetag to use for output
//      pszaTrace []     The trace string itself.
//
//  Returns:
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
VOID CTracing::Trace( TraceTagId    ttid,
                      PCSTR         pszaTrace )
{
    // HrInit should have called a corruption checker for the entire trace
    // block, but we'll check again just to make sure.
    //
    AssertSz(g_nTraceTagCount > ttid, "ttid out of range in CTracing::Trace");
    AssertSz(g_TraceTags[ttid].ttid == ttid,
            "TraceTag structure is corrupt in CTracing::Trace");

    // If they want debug string output
    //
    if (g_TraceTags[ttid].fOutputDebugString)
    {
        // Then output the string
        //
        OutputDebugStringA(pszaTrace);
    }

    // If they want file output
    if (g_TraceTags[ttid].fOutputToFile)
    {
        if (!m_hLogFile)
        {
            // Assuming that we haven't already tried to open the file
            // and failed, open it.
            if (!m_fAttemptedLogFileOpen)
            {
                HRESULT hr = HrOpenLogFile();
                if (FAILED(hr))
                {
                    AssertSz(FALSE, "Failed to open log file for tracing. No, "
                             "this isn't a coding error, but hey, figured that "
                             "you'd want to know...");
                }
            }
        }

        // If we were already open, or the open has now succeeded, do the
        // trace
        //
        if (m_hLogFile)
        {
            Assert(pszaTrace);

            // Since pszTrace is guaranteed to be a single-byte trace, we
            // don't need to do the WCHAR multiply on the length, just
            // a char multiply.
            //
            DWORD   dwBytesToWrite  = lstrlenA(pszaTrace) * sizeof(CHAR);
            DWORD   dwBytesWritten  = 0;
            BOOL    fWriteResult    = FALSE;

            fWriteResult = WriteFile(
                    m_hLogFile,         // handle to file to write to
                    pszaTrace,           // pointer to data to write to file
                    dwBytesToWrite,     // size of trace
                    &dwBytesWritten,    // Bytes actually written.
                    NULL );             // No overlapped

            if (!fWriteResult || (dwBytesToWrite != dwBytesWritten))
            {
                AssertSz(FALSE, "CTracing failure: Can't write to log file."
                         " Can't trace or we'll be recursing on this failure.");
            }
        }
    }
}

HRESULT CTracing::HrOpenLogFile()
{
    HRESULT hr  = S_OK;

    AssertSz(m_fInitialized,
            "CTracing not initialized in HrOpenLogFile()");
    AssertSz(!m_hLogFile,
            "File already open before call to HrOpenLogFile()");

    // Mark us as having attempted to open the file, so we don't call this
    // function everytime we log, if we can't open it.
    //
    m_fAttemptedLogFileOpen = TRUE;

    // $$TODO (jeffspr) - Allow flags in the Options section of the ini
    // file specify the create flags and attributes, which would allow
    // us to control the overwriting of log files and/or the write-through
    // properties.
    //

    // Actually open the file, creating if necessary.
    //
    m_hLogFile = CreateFileA(
            m_szLogFilePath,        // Pointer to name of file
            GENERIC_WRITE,          // access (read-write) mode
            FILE_SHARE_READ,        // share mode (allow read access)
            NULL,                   // pointer to security attributes
            CREATE_ALWAYS,          // how to create
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
            NULL);
    if (INVALID_HANDLE_VALUE == m_hLogFile)
    {
        m_hLogFile = NULL;

        hr = HrFromLastWin32Error();
        goto Exit;
    }

Exit:
    return hr;
}

using namespace std;
typedef deque<CTracingFuncCall, NOFAULT_ALLOC::nofault_allocator<CTracingFuncCall> > TRACING_FUNCTIONSTACK;

CTracingFuncCall::CTracingFuncCall(const CTracingFuncCall& TracingFuncCall)
{
    Assert(g_csTracing);

    m_szFunctionName = new(NO_FI) CHAR[strlen(TracingFuncCall.m_szFunctionName)+1];
    if (m_szFunctionName)
    {
        strcpy(m_szFunctionName, TracingFuncCall.m_szFunctionName);
    }
    else
    {
        m_szFunctionName = c_szLowMemory;
    }
    
    m_szFunctionDName = new(NO_FI) CHAR[strlen(TracingFuncCall.m_szFunctionDName)+1];
    if (m_szFunctionDName)
    {
        strcpy(m_szFunctionDName, TracingFuncCall.m_szFunctionDName);
    }
    else
    {
        m_szFunctionDName = c_szLowMemory;
    }
    
    m_szFile = new(NO_FI) CHAR[strlen(TracingFuncCall.m_szFile)+1];
    if (m_szFile)
    {
        strcpy(m_szFile, TracingFuncCall.m_szFile);
    }
    else
    {
        m_szFile = c_szLowMemory;
    }
    
    m_dwLine = TracingFuncCall.m_dwLine;
    m_dwFramePointer = TracingFuncCall.m_dwFramePointer;
    m_dwThreadId = TracingFuncCall.m_dwThreadId;
    m_ReturnAddress = TracingFuncCall.m_ReturnAddress;
    
#if defined(_X86_) || defined(_AMD64_)
    m_arguments[0] = TracingFuncCall.m_arguments[0];
    m_arguments[1] = TracingFuncCall.m_arguments[1];
    m_arguments[2] = TracingFuncCall.m_arguments[2];
#elif defined (_IA64_) 
    m_arguments[0] = TracingFuncCall.m_arguments[0];
    m_arguments[1] = TracingFuncCall.m_arguments[1];
    m_arguments[2] = TracingFuncCall.m_arguments[2];
#else 
    // add other processors here
#endif
}

#if defined (_X86_) || defined (_AMD64_)
CTracingFuncCall::CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, DWORD_PTR dwpReturnAddress, const DWORD_PTR dwFramePointer)
#elif defined (_IA64_) 
CTracingFuncCall::CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, DWORD_PTR dwpReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3)
#else
CTracingFuncCall::CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine)
#endif
{
    Assert(g_csTracing);

    m_szFunctionName = new(NO_FI) CHAR[strlen(szFunctionName)+1];
    if (m_szFunctionName)
    {
        strcpy(m_szFunctionName, szFunctionName);
    }
    else
    {
        m_szFunctionName = c_szLowMemory;
    }

    m_szFunctionDName = new(NO_FI) CHAR[strlen(szFunctionDName)+1];
    if (m_szFunctionDName)
    {
        strcpy(m_szFunctionDName, szFunctionDName);
    }
    else
    {
        m_szFunctionDName = c_szLowMemory;
    }

    m_szFile = new(NO_FI) CHAR[strlen(szFile)+1];
    if (m_szFile)
    {
        strcpy(m_szFile, szFile);
    }
    else
    {
        m_szFile = c_szLowMemory;
    }

    m_dwLine = dwLine;
    m_ReturnAddress = dwpReturnAddress;
    
#if defined (_X86_) || defined (_AMD64_)
    m_dwFramePointer = dwFramePointer;
    
    if (dwFramePointer)
    {
        PDWORD_PTR pdwEbp = reinterpret_cast<PDWORD_PTR>(dwFramePointer);
        pdwEbp++; // advance pass BaseEBP
        pdwEbp++; // advance pass ReturnIP
    
        m_arguments[0] = *pdwEbp; pdwEbp++;
        m_arguments[1] = *pdwEbp; pdwEbp++;
        m_arguments[2] = *pdwEbp;
    }
    else
    {
        m_arguments[0] = 0;
        m_arguments[1] = 0;
        m_arguments[2] = 0;
    }
#elif defined (_IA64_) 
    m_dwFramePointer = 0;

    m_arguments[0] = Args1;
    m_arguments[1] = Args2;
    m_arguments[2] = Args3;
#else
    m_dwFramePointer = 0;
#endif

    m_dwThreadId = GetCurrentThreadId();
}

CTracingFuncCall::~CTracingFuncCall()
{
    Assert(g_csTracing);
    
    if (c_szLowMemory != m_szFile)
    {
        delete[] m_szFile;
    }

    if (c_szLowMemory != m_szFunctionDName)
    {
        delete[] m_szFunctionDName;
    }

    if (c_szLowMemory != m_szFunctionName)
    {
        delete[] m_szFunctionName;
    }
}

CTracingThreadInfo::CTracingThreadInfo()
{
    Assert(g_csTracing);

    m_dwLevel = 1;
    m_dwThreadId = GetCurrentThreadId();
    m_pfnStack = new(NO_FI) TRACING_FUNCTIONSTACK;
}

CTracingThreadInfo::~CTracingThreadInfo()
{
    Assert(g_csTracing);

    TRACING_FUNCTIONSTACK *pfnStack = reinterpret_cast<TRACING_FUNCTIONSTACK *>(m_pfnStack);
    delete pfnStack;
}

CTracingThreadInfo* CTracingIndent::GetThreadInfo()
{
    CTracingThreadInfo *pThreadInfo = NULL;

    AssertSz(g_dwTlsTracing, "Tracing not initialized... Did RawDllMain run?");
    AssertSz(g_csTracing, "Tracing not initialized... Did RawDllMain run?");

    pThreadInfo = reinterpret_cast<CTracingThreadInfo *>(TlsGetValue(g_dwTlsTracing));
    if (!pThreadInfo)
    {
        pThreadInfo = new(NO_FI) CTracingThreadInfo;
        TlsSetValue(g_dwTlsTracing, pThreadInfo);

        Assert(pThreadInfo == reinterpret_cast<CTracingThreadInfo *>(TlsGetValue(g_dwTlsTracing)));
    }

    Assert(pThreadInfo);
    return pThreadInfo;
}

void CTracingIndent::FreeThreadInfo()
{
    CTracingThreadInfo *pThreadInfo = NULL;

    pThreadInfo = reinterpret_cast<CTracingThreadInfo *>(TlsGetValue(g_dwTlsTracing));
    if (pThreadInfo)
    {
        TraceStackFn(ttidError);
        AssertSz(pThreadInfo->m_dwLevel == 1, "Thread is being terminated that didn't complete (ignore will spew remaining stack if you attach a debugger)");
        
        TraceStackFn(ttidError);
        AssertSz(pThreadInfo->m_dwLevel == 1, "Thread is being terminated that didn't complete");

        delete pThreadInfo;
        TlsSetValue(g_dwTlsTracing, reinterpret_cast<LPVOID>(-1));
    }
}

CTracingIndent::CTracingIndent()
{
    bFirstTrace = TRUE;
    m_szFunctionDName = NULL;
    m_dwFramePointer  = NULL;
}

#if defined (_X86_) || defined (_AMD64_)
void CTracingIndent::AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const DWORD_PTR dwFramePointer)
#elif defined (_IA64_) 
void CTracingIndent::AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3)
#else
void CTracingIndent::AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine)
#endif
{
    Assert(szFunctionName);
    Assert(szFunctionDName);
    Assert(szFile);

    if (!bFirstTrace)
    {
#if defined (_X86_)  || defined (_AMD64_)
        RemoveTrace(szFunctionDName, dwFramePointer);
#elif defined (_IA64_) 
        RemoveTrace(szFunctionDName, 0);
#else 
        RemoveTrace(szFunctionDName, 0);
#endif
    }
    else
    {
        bFirstTrace = FALSE;
    }
    
    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);

    Assert(g_csTracing);
    
    try
    {
        EnterCriticalSection(g_csTracing);

#if defined (_X86_)  || defined (_AMD64_)
        CTracingFuncCall fnCall(szFunctionName, szFunctionDName, szFile, dwLine, reinterpret_cast<DWORD_PTR>(pReturnAddress), dwFramePointer);
#elif defined (_IA64_) 
        CTracingFuncCall fnCall(szFunctionName, szFunctionDName, szFile, dwLine, reinterpret_cast<DWORD_PTR>(pReturnAddress), Args1, Args2, Args3);
#else
        CTracingFuncCall fnCall(szFunctionName, szFunctionDName, szFile, dwLine);
#endif

        if (fnStack.size() == 0)
        {
            pThreadInfo->m_dwLevel++;
        }
        else
        {
            const CTracingFuncCall& fnTopOfStack = fnStack.front();
            if ( (fnCall.m_dwFramePointer != fnTopOfStack.m_dwFramePointer) || 
                 strcmp(fnCall.m_szFunctionDName, fnTopOfStack.m_szFunctionDName))
            {
                pThreadInfo->m_dwLevel++;
            }
        }
    
        m_szFunctionDName = new(NO_FI) CHAR[strlen(fnCall.m_szFunctionDName)+1];
        if (m_szFunctionDName)
        {
            strcpy(m_szFunctionDName, fnCall.m_szFunctionDName);
        }
        else
        {
            m_szFunctionDName = c_szLowMemory;
        }

        m_dwFramePointer  = fnCall.m_dwFramePointer;
    
        fnStack.push_front(fnCall);
    }
    catch (bad_alloc)
    {
    }
    LeaveCriticalSection(g_csTracing);
}

CTracingIndent::~CTracingIndent()
{
    AssertSz(g_csTracing, "Tracing not initialized");

    RemoveTrace(m_szFunctionDName, m_dwFramePointer);
}

void CTracingIndent::RemoveTrace(LPCSTR szFunctionDName, const DWORD_PTR dwFramePointer)
{
    __try
    {
        EnterCriticalSection(g_csTracing);

        volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
        TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);

        Assert(szFunctionDName);
        Assert(m_szFunctionDName);
        Assert(g_csTracing);
    
        if  ( 
                (fnStack.size() == 0) 
                ||
                ( 
                    (   
                        strcmp(m_szFunctionDName, szFunctionDName) 
                        || 
                        strcmp(m_szFunctionDName, fnStack.front().m_szFunctionDName)
                    ) 
                    &&
                    ( 
                        (c_szLowMemory != m_szFunctionDName)  
                        &&
                        (c_szLowMemory != fnStack.front().m_szFunctionDName) 
                        && 
                        (c_szLowMemory != szFunctionDName) 
                    ) 
                ) 
                ||
                (m_dwFramePointer  != fnStack.front().m_dwFramePointer)  
                ||
                (dwFramePointer    != m_dwFramePointer) 
            )
        {
            // Make sure to leave the critical section during the assert, so that it does not cause a deadlock.
            LeaveCriticalSection(g_csTracing);

            // This will trace the stack:
            if (IsDebuggerPresent())
            {
                TraceTagFn(ttidError, "Tracing self-inconsistent - either a stack over/underwrite occurred or an exception was thrown in faulting stack:");
                TraceStackFn(ttidError);
            }
            else
            {
                AssertSz(FALSE,     "Tracing self-inconsistent - either a stack over/underwrite occurred or an exception was thrown.\r\nPlease attach a debugger and hit Ignore on this assert to spew info to the debugger (it will assert again).");
                TraceTagFn(ttidError, "Tracing self-inconsistent - either a stack over/underwrite occurred or an exception was thrown in faulting stack:");
                TraceStackFn(ttidError);
            }
            TraceTagFn(ttidError, "1) For complete stack info, .frame down to CTracingIndent__RemoveTrace, dv and find dwFramePointer (2nd parameter to CTracingIndent__RemoveTrace)");
            TraceTagFn(ttidError, "   Then do a kb=(value of dwFramePointer)");
            TraceTagFn(ttidError, "2) For even more complete stack info, .frame down to CTracingIndent__RemoveTrace, dv and then dt -r on fnStack");
            TraceTagFn(ttidError, "   Then find the _Next, where m_szFunctionName == 'CTracingIndent::RemoveTrace'");
            TraceTagFn(ttidError, "   If it exists, find the value of m_dwFramePointer under _Next");
            TraceTagFn(ttidError, "   Then do a kb=(value of m_dwFramePointer)");

            DebugBreak();

            // Try to recover.
            if (fnStack.size() > 0)
            {
                fnStack.pop_front();
            }

            EnterCriticalSection(g_csTracing);
        }
        else
        {
            DWORD_PTR dwOldFramePointer = fnStack.front().m_dwFramePointer;
            fnStack.pop_front();
    
            if ( (fnStack.size() == 0) || 
                (dwOldFramePointer != fnStack.front().m_dwFramePointer) || 
                strcmp(m_szFunctionDName, fnStack.front().m_szFunctionDName) )
            {
                pThreadInfo->m_dwLevel--;
                Assert(pThreadInfo->m_dwLevel);
            }
        }

        if (c_szLowMemory != m_szFunctionDName)
        {
            delete [] m_szFunctionDName;
        }
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

DWORD CTracingIndent::getspaces()
{
    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    return pThreadInfo->m_dwLevel;
}

void CTracingIndent::TraceStackFn(TRACETAGID TraceTagId)
{
    if (!g_TraceTags[TraceTagId].fOutputDebugString &&
        !g_TraceTags[TraceTagId].fOutputToFile)
    {
        return;
    }

    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);
    Assert(g_csTracing);
    
    __try
    {
        EnterCriticalSection(g_csTracing);

        if (fnStack.size() == 0)
        {
            return;
        }
    
    #if defined (_X86_) || defined (_AMD64_)
        TraceInternal(TraceTagId, NULL, 0, 0, "ChildEBP RetAddr  Args to Child (reconstructed - ChildEBP is invalid now)", 0, FALSE);
    #elif defined (_IA64_) 
        TraceInternal(TraceTagId, NULL, 0, 0, "RetAddr          Args to Child (reconstructed)", 0, FALSE);
    #else
        TraceInternal(TraceTagId, NULL, 0, 0, "Function stack", 0, FALSE);
    #endif
    
        for (TRACING_FUNCTIONSTACK::const_iterator i = fnStack.begin(); i != fnStack.end(); i++)
        {
            CHAR szBuffer[MAX_TRACE_LEN];
    #if defined (_X86_) || defined (_AMD64_)
            _snprintf(szBuffer, MAX_TRACE_LEN, "%08x %08x %08x %08x %08x %s [%s @ %d]", i->m_dwFramePointer, i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #elif defined (_IA64_) 
            _snprintf(szBuffer, MAX_TRACE_LEN, "%016I64x %016I64x 0x%016I64x 0x%016I64x %s [%s @ %d]", i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #else
            _snprintf(szBuffer, MAX_TRACE_LEN, "%s", i->m_szFunctionName);
    #endif
            TraceInternal (TraceTagId, NULL, 0, 0, szBuffer, 0, FALSE);
        }
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

void CTracingIndent::TraceStackFn(IN OUT LPSTR szString, IN OUT LPDWORD pdwSize)
{
    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);
    Assert(g_csTracing);
    
    __try
    {
        EnterCriticalSection(g_csTracing);
        ZeroMemory(szString, *pdwSize);

        if (fnStack.size() == 0)
        {
            return;
        }

        Assert(*pdwSize > MAX_TRACE_LEN);
        LPSTR pszString = szString;

    #if defined (_X86_) || defined (_AMD64_)
        pszString += _snprintf(pszString, MAX_TRACE_LEN, " ChildEBP RetAddr  Args to Child (reconstructed - ChildEBP is invalid now)\r\n");
    #elif defined (_IA64_) 
        pszString += _snprintf(pszString, MAX_TRACE_LEN, " RetAddr          Args to Child (reconstructed)\r\n");
    #else
        pszString += _snprintf(pszString, MAX_TRACE_LEN, " Function stack\r\n");
    #endif
    
        DWORD dwSizeIn = *pdwSize;

        for (TRACING_FUNCTIONSTACK::const_iterator i = fnStack.begin(); i != fnStack.end(); i++)
        {
            CHAR szBuffer[1024];
    #if defined (_X86_) || defined (_AMD64_)
            _snprintf(szBuffer, MAX_TRACE_LEN, " %08x %08x %08x %08x %08x %s [%s @ %d]", i->m_dwFramePointer, i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #elif defined (_IA64_) 
            _snprintf(szBuffer, MAX_TRACE_LEN, " %016I64x %016I64x 0x%016I64x 0x%016I64x %s [%s @ %d]", i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #else
            _snprintf(szBuffer, MAX_TRACE_LEN, " %s", i->m_szFunctionName);
    #endif
            pszString += _snprintf(pszString, MAX_TRACE_LEN, "%s\r\n", szBuffer);
            if (pszString > (szString + (*pdwSize - celems(szBuffer))) ) // Can't use strlen since I need to know the length of the
                                                                         // next element - not this one. Hence just take the maximum size.
            {
                pszString += _snprintf(pszString, MAX_TRACE_LEN, "...", szBuffer);
                *pdwSize = dwSizeIn * 2; // Tell the caller to allocate more memory and call us back if they want more info.
                break;
            }
        }

        if (*pdwSize < dwSizeIn)
        {
            *pdwSize = (DWORD)(pszString - szString);
        }
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

VOID
WINAPIV
TraceFileFuncFn (TRACETAGID  ttid)
{
    if (FIsDebugFlagSet (dfidTraceFileFunc))
    {
        CHAR szBuffer[MAX_TRACE_LEN];

        volatile CTracingThreadInfo *pThreadInfo = CTracingIndent::GetThreadInfo();
        TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);   
        
        Assert(g_csTracing);
        __try 
        {
            EnterCriticalSection(g_csTracing);

            const CTracingFuncCall& fnCall = fnStack.front();

            if (fnStack.size() != 0)
            {
                if (FIsDebugFlagSet (dfidTraceSource))
                {
    #if defined (_X86_) || defined (_AMD64_)
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%08x 0x%08x 0x%08x] %s:%d", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2], fnCall.m_szFile, fnCall.m_dwLine);
    #elif defined (_IA64_) 
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%016I64x 0x%016I64x 0x%016I64x] %s:%d", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2], fnCall.m_szFile, fnCall.m_dwLine);
    #else
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s %s:%d", fnCall.m_szFunctionName, fnCall.m_szFile, fnCall.m_dwLine);
    #endif
                }
                else
                {
    #if defined (_X86_) || defined (_AMD64_)
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%08x 0x%08x 0x%08x]", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2]);
    #elif defined (_IA64_) 
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%016I64x 0x%016I64x 0x%016I64x]", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2]);
    #else
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s", fnCall.m_szFunctionName);
    #endif

                }

                TraceTagFn(ttid, szBuffer);
            }
            else
            {
                AssertSz(FALSE, "Trace failure");
            }
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
}

LPCSTR DBG_EMNAMES[] =
{
    "INVALID_EVENTMGR",
    "EVENTMGR_CONMAN",
    "EVENTMGR_EAPOLMAN"
};

LPCSTR DBG_CMENAMES[] =
{
    "INVALID_TYPE",
    "CONNECTION_ADDED",
    "CONNECTION_BANDWIDTH_CHANGE",
    "CONNECTION_DELETED",
    "CONNECTION_MODIFIED",
    "CONNECTION_RENAMED",
    "CONNECTION_STATUS_CHANGE",
    "REFRESH_ALL",
    "CONNECTION_ADDRESS_CHANGE"
};

LPCSTR DBG_NCMNAMES[] =
{
    "NCM_NONE",
    "NCM_DIRECT",
    "NCM_ISDN",
    "NCM_LAN",
    "NCM_PHONE",
    "NCM_TUNNEL",
    "NCM_PPPOE",
    "NCM_BRIDGE",
    "NCM_SHAREDACCESSHOST_LAN",
    "NCM_SHAREDACCESSHOST_RAS"
};

LPCSTR DBG_NCSMNAMES[] =
{
    "NCSM_NONE",
    "NCSM_LAN",
    "NCSM_WIRELESS",
    "NCSM_ATM",
    "NCSM_ELAN",
    "NCSM_1394",
    "NCSM_DIRECT",
    "NCSM_IRDA",
    "NCSM_CM",
};

LPCSTR DBG_NCSNAMES[] =
{
    "NCS_DISCONNECTED",
    "NCS_CONNECTING",
    "NCS_CONNECTED",
    "NCS_DISCONNECTING",
    "NCS_HARDWARE_NOT_PRESENT",
    "NCS_HARDWARE_DISABLED",
    "NCS_HARDWARE_MALFUNCTION",
    "NCS_MEDIA_DISCONNECTED",
    "NCS_AUTHENTICATING",
    "NCS_AUTHENTICATION_SUCCEEDED",
    "NCS_AUTHENTICATION_FAILED",
    "NCS_INVALID_ADDRESS",
    "NCS_CREDENTIALS_REQUIRED"
};

// Shorten these to fit more in.
LPCSTR DBG_NCCSFLAGS[] =
{
    "_NONE",
    "_ALL_USERS",
    "_ALLOW_DUPLICATION",
    "_ALLOW_REMOVAL",
    "_ALLOW_RENAME",
    "_SHOW_ICON",
    "_INCOMING_ONLY",
    "_OUTGOING_ONLY",
    "_BRANDED",
    "_SHARED",
    "_BRIDGED",
    "_FIREWALLED",
    "_DEFAULT"
};

LPCSTR DbgEvents(DWORD Event)
{
    if (Event < celems(DBG_CMENAMES))
    {
        return DBG_CMENAMES[Event];
    }
    else
    {
        return "UNKNOWN Event: Update DBG_CMENAMES table.";
    }
}

LPCSTR DbgEventManager(DWORD EventManager)
{
    if (EventManager < celems(DBG_EMNAMES))
    {
        return DBG_EMNAMES[EventManager];
    }
    else
    {
        return "UNKNOWN Event: Update DBG_EMNAMES table.";
    }
}

LPCSTR DbgNcm(DWORD ncm)
{
    if (ncm < celems(DBG_NCMNAMES))
    {
        return DBG_NCMNAMES[ncm];
    }
    else
    {
        return "UNKNOWN NCM: Update DBG_NCMNAMES table.";
    }
}

LPCSTR DbgNcsm(DWORD ncsm)
{
    if (ncsm < celems(DBG_NCSMNAMES))
    {
        return DBG_NCSMNAMES[ncsm];
    }
    else
    {
        return "UNKNOWN NCM: Update DBG_NCSMNAMES table.";
    }
}

LPCSTR DbgNcs(DWORD ncs)
{
    if (ncs < celems(DBG_NCSNAMES))
    {
        return DBG_NCSNAMES[ncs];
    }
    else
    {
        return "UNKNOWN NCS: Update DBG_NCSNAMES table.";
    }
}

LPCSTR DbgNccf(DWORD nccf)
{
    static CHAR szName[MAX_PATH];

    if (nccf >= (1 << celems(DBG_NCCSFLAGS)) )
    {
        return "UNKNOWN NCCF: Update DBG_NCCSFLAGS table.";
    }

    if (0 == nccf)
    {
        strcpy(szName, DBG_NCCSFLAGS[0]);
    }
    else
    {
        szName[0] = '\0';
        LPSTR szTemp = szName;
        BOOL bFirst = TRUE;
        for (DWORD x = 0; x < celems(DBG_NCCSFLAGS); x++)
        {
            if (nccf & (1 << x))
            {
                if (!bFirst)
                {
                    szTemp += _snprintf(szTemp, MAX_TRACE_LEN, "+");
                }
                else
                {
                    szTemp += _snprintf(szTemp, MAX_TRACE_LEN, "NCCF:");
                }
                bFirst = FALSE;
                szTemp += _snprintf(szTemp, MAX_TRACE_LEN, "%s", DBG_NCCSFLAGS[x+1]);
            }
        }
    }

    return szName;
}

#ifdef ENABLELEAKDETECTION

CObjectLeakTrack *g_pObjectLeakTrack = NULL;

// First LPSTR is classname
// Second LPSTR is stack trace
class CObjectAllocationInfo
{
private:
    void InitializeFromClass(const CObjectAllocationInfo & ObjectAllocationInfo);

public:
    CObjectAllocationInfo & operator =(const CObjectAllocationInfo & ObjectAllocationInfo);
    CObjectAllocationInfo();
    CObjectAllocationInfo(LPCSTR szClassName, LPCSTR szStackInfo);
    CObjectAllocationInfo(const CObjectAllocationInfo & ObjectAllocationInfo);
    
    ~CObjectAllocationInfo();

    LPSTR m_szClassName;
    LPSTR m_szStackInfo;
    LPVOID m_ppvStackTrace[32];
};

CObjectAllocationInfo::CObjectAllocationInfo()
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));

    m_szClassName = NULL;
    m_szStackInfo = NULL;

    ZeroMemory(m_ppvStackTrace, sizeof(m_ppvStackTrace));
}

CObjectAllocationInfo & CObjectAllocationInfo::operator =(const CObjectAllocationInfo & ObjectAllocationInfo)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));

    if (m_szClassName)
    {
        delete[] m_szClassName;
        m_szClassName = NULL;
    }
    if (m_szStackInfo)
    {
        delete[] m_szStackInfo;
        m_szStackInfo = NULL;
    }
    ZeroMemory(m_ppvStackTrace, sizeof(m_ppvStackTrace));
    InitializeFromClass(ObjectAllocationInfo);
    return *this;
}

CObjectAllocationInfo::CObjectAllocationInfo(LPCSTR szClassName, LPCSTR szStackInfo)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));

    if (szClassName)
    {
        DWORD dwLen = strlen(szClassName) + 1;
        m_szClassName = new(NO_FI) CHAR[dwLen];
        if (szClassName)
        {
            strncpy(m_szClassName, szClassName, dwLen);
        }
    }

    if (szStackInfo)
    {
        DWORD dwLen = strlen(szStackInfo) + 1;
        m_szStackInfo = new(NO_FI) CHAR[dwLen];
        if (m_szStackInfo)
        {
            strncpy(m_szStackInfo, szStackInfo, dwLen);
        }
    }

    ZeroMemory(m_ppvStackTrace, sizeof(m_ppvStackTrace));
}

void CObjectAllocationInfo::InitializeFromClass(const CObjectAllocationInfo & ObjectAllocationInfo)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));

    m_szClassName = NULL;
    m_szStackInfo = NULL;
    
    if (ObjectAllocationInfo.m_szClassName)
    {
        DWORD dwLen = strlen(ObjectAllocationInfo.m_szClassName) + 1;
        m_szClassName = new(NO_FI) CHAR[dwLen];
        if (m_szClassName)
        {
            strncpy(m_szClassName, ObjectAllocationInfo.m_szClassName, dwLen);
        }
    }

    if (ObjectAllocationInfo.m_szStackInfo)
    {
        DWORD dwLen = strlen(ObjectAllocationInfo.m_szStackInfo) + 1;
        m_szStackInfo = new(NO_FI) CHAR[dwLen];
        if (m_szStackInfo)
        {
            strncpy(m_szStackInfo, ObjectAllocationInfo.m_szStackInfo, dwLen);
        }
    }
    memcpy(m_ppvStackTrace, ObjectAllocationInfo.m_ppvStackTrace, sizeof(m_ppvStackTrace));
}

CObjectAllocationInfo::CObjectAllocationInfo(const CObjectAllocationInfo & ObjectAllocationInfo)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));

    InitializeFromClass(ObjectAllocationInfo);
}

CObjectAllocationInfo::~CObjectAllocationInfo()
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));

    if (m_szStackInfo)
    {
        delete[] m_szStackInfo;
        m_szStackInfo = NULL;
    }

    if (m_szClassName)
    {
        delete[] m_szClassName;
        m_szClassName = NULL;
    }
}

typedef map<LPCVOID, CObjectAllocationInfo, NOFAULT_ALLOC::nofault_allocator<CTracingFuncCall> > MAPOBJLEAK;

//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::CObjectLeakTrack
//
//  Purpose:    Constructor
//
//  Arguments:
//
//  Returns:
//
//  Author:     deonb  7 July 2001
//
//  Notes:      We are allocating our g_mapObjLeak here
//
CObjectLeakTrack::CObjectLeakTrack()
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    g_mapObjLeak = new(NO_FI) MAPOBJLEAK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::CObjectLeakTrack
//
//  Purpose:    Destructor
//
//  Arguments:
//
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      We are deleting our g_mapObjLeak here. We have to typecast it
//              first since the data types exported by trace.h to the world is
//              LPVOID, to minimize dependencies in order to include tracing.
//
CObjectLeakTrack::~CObjectLeakTrack()
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    delete reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::Insert
//
//  Purpose:    Insert an object instance in the list
//
//  Arguments:  [in] pThis                    - This pointer of the object instance. This must
//                                              be the same as the this pointer of the ::Remove
//              [in] szdbgClassName           - The classname of the object
//              [in own] pszConstructionStack - The stacktrace of the object constructor.
//                                              (or any other information that is useful to describe
//                                               the origin of the object).
//                                              This must be allocated with the global new operator
//                                              since we will take ownership and free this
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      
//
void CObjectLeakTrack::Insert(IN LPCVOID pThis, IN LPCSTR szdbgClassName, IN TAKEOWNERSHIP LPSTR pszConstructionStack)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    if (g_mapObjLeak)
    {
        MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);

        CObjectAllocationInfo ObjectAllocationInfo(szdbgClassName, pszConstructionStack);
        delete[] pszConstructionStack;

        
        RtlWalkFrameChain(ObjectAllocationInfo.m_ppvStackTrace, celems(ObjectAllocationInfo.m_ppvStackTrace), 0);

        rmapObjLeak[pThis] = ObjectAllocationInfo;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::Remove
//
//  Purpose:    Remove an object instance from the list
//
//  Arguments:  [in] pThis                    - This pointer of the object instance. This must
//                                              be the same as the this pointer of the ::Insert
//
//  Returns:
//
//  Author:     deonb  7 July 2001
//
//  Notes:      
//
void CObjectLeakTrack::Remove(IN LPCVOID pThis)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    if (g_mapObjLeak)
    {
        MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);

        MAPOBJLEAK::iterator iter = rmapObjLeak.find(pThis);
        if (iter != rmapObjLeak.end())
        {
            rmapObjLeak.erase(iter);
        }
    }
}

void RemoveKnownleakFn(LPCVOID pThis)
{
    if (FIsDebugFlagSet(dfidTrackObjectLeaks) && g_pObjectLeakTrack)
    {
        __try
        {
            EnterCriticalSection(g_csTracing);
            TraceTag(ttidAllocations, "An object at '0x%08x' was marked as a known leak", pThis);
        
            g_pObjectLeakTrack->Remove(pThis);
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::AssertIfObjectsStillAllocated
//
//  Purpose:    Assert if the the list of allocated objects in the process is not NULL.
//              and call DumpAllocatedObjects to dump out this list.
//
//  Arguments:  [in] szClassName.   The classname of the objects to assert that there are nothing of.
//                                  This classname can be obtained by calling typeid(CLASS).name() 
//                                  on your class. (E.g. typeid(CConnectionManager).name() )
//
//                                  Can also be NULL to ensure that there are NO objects allocated
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      Don't call this from outside tracing - rather call AssertNoAllocatedInstances
//              which is safe to call in CHK and FRE.
BOOL CObjectLeakTrack::AssertIfObjectsStillAllocated(IN LPCSTR szClassName)
{
    if (!FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        return FALSE;
    }

    if (g_mapObjLeak)
    {
        __try
        {
            EnterCriticalSection(g_csTracing);

            MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);
            BOOL fFoundObjectOfType = FALSE;

            for (MAPOBJLEAK::const_iterator iter = rmapObjLeak.begin(); iter != rmapObjLeak.end(); iter++)
            {
               if (szClassName)
               {
                   if (0 == strcmp(iter->second.m_szClassName, szClassName) )
                   {
                       fFoundObjectOfType = TRUE;
                       break;
                   }
               }
               else
               {
                   fFoundObjectOfType = TRUE;
                   break;
               }
            }

            WCHAR szModuleName[MAX_PATH];
            ZeroMemory(szModuleName, MAX_PATH);
            if (!GetModuleFileName(reinterpret_cast<HMODULE>(&__ImageBase), szModuleName, MAX_PATH))
            {
                if (GetModuleFileName(reinterpret_cast<HMODULE>(::GetModuleHandle(NULL)), szModuleName, MAX_PATH))
                {
                    WCHAR szTemp[MAX_PATH];
                    wcscpy(szTemp, szModuleName);
                    wsprintf(szModuleName, L"at address 0x%08x inside %s", __ImageBase, szTemp);
                }
                else
                {
                    wsprintf(szModuleName, L"at address 0x%08x", __ImageBase);
                }
            }

            if (fFoundObjectOfType)
            {
                if (!IsDebuggerPresent())
                {
                    CHAR szDescription[MAX_PATH];
                    sprintf(szDescription,
                            "An object leak has been detected in %S. Please attach a user or kernel mode debugger to process id %d (0x%04x) and hit IGNORE to dump the offending stacks.\r\nE.g. ntsd -Gg -p %d",
                            szModuleName,
                            GetCurrentProces
                            GetCurrentProcessId(),
                            GetCurrentProcessId(),
                            GetCurrentProcessId());
                    AssertSz(FALSE, szDescription);
                }
                DumpAllocatedObjects(ttidError, szClassName);
                
                AssertSz(FALSE, "An object leak has been detected. This leak has been spewed to the debugger - press RETRY to look at spew and map ReturnAddr values to symbols.");
                return TRUE;
            }
            else
            {
                CHAR szSpewText[MAX_PATH];
                
                TraceTag(ttidError, "No leaks were detected inside module %S", szModuleName);

//                sprintf(szSpewText, "No leaks were detected inside module %S", szModuleName);
//                AssertSz(NULL, szSpewText);
            }
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
    return FALSE;
}   


//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::DumpAllocatedObjects
//
//  Purpose:    Dump the list of the objects and their construction stacks
//              for the objects that were allocated but not deleted yet. Dumps
//              to the debugger.
//
//  Arguments:  [in] TraceTagId.    The TraceTag to trace it to.
//              [in] szClassName.   The classname of the objects to dump out.
//                                  This classname can be obtained by calling typeid(CLASS).name() 
//                                  on your class. (E.g. typeid(CConnectionManager).name() )
//              
//                                  Can also be NULL to dump out objects of ALL types.
//
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      Don't call this from outside - rather call TraceAllocatedObjects 
//              which is safe to call in CHK and FRE.
//
void CObjectLeakTrack::DumpAllocatedObjects(IN TRACETAGID TraceTagId, IN LPCSTR szClassName)
{
    if (!FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        return;
    }

    if (g_mapObjLeak)
    {
        __try 
        {
            EnterCriticalSection(g_csTracing);

            MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);

            for (MAPOBJLEAK::const_iterator iter = rmapObjLeak.begin(); iter != rmapObjLeak.end(); iter++)
            {
               BOOL fMustSpew = TRUE;
               if (szClassName)
               {
                   if (0 != strcmp(iter->second.m_szClassName, szClassName) )
                   {
                       fMustSpew = FALSE;
                   }
               }

               if (fMustSpew)
               {
                    TraceTag(TraceTagId, "The object of type '%s' allocated at 0x%08x has not been freed:", 
                                iter->second.m_szClassName, iter->first);

                    BOOL bHasDetailedStack = FALSE;
#if defined (_X86_)
                    if (iter->second.m_ppvStackTrace[0] != NULL)
                    {
                        bHasDetailedStack = TRUE;
                    }
#endif

                    if (*iter->second.m_szStackInfo)
                    {
                        TraceTag (TraceTagId, "Callstack below:\r\n%s", iter->second.m_szStackInfo);
                    }
                    else
                    {
                        if (!bHasDetailedStack)
                        {
                            TraceTag(TraceTagId, "    <call stack information not available. See comments inside trace.h on how to increase your call stack information>.\r\n");
                        }
                    }

                    if (bHasDetailedStack)
                    {
                        DWORD dwCount = 0;
                        while ( (dwCount < celems(iter->second.m_ppvStackTrace)) &&
                                (iter->second.m_ppvStackTrace[dwCount]) )
                        {
                            dwCount++;
                        }

                        TraceTag (TraceTagId, "Detailed callstack information is available through the debugger. Execute the folowing command:");
                        TraceTag (TraceTagId, "dds 0x%08x L 0x%02x\r\n", iter->second.m_ppvStackTrace, dwCount);
                    }
               }
            }
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
}   

#endif // ENABLELEAKDETECTION

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nclan\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSERVICE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\kkenet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K E N E T . C P P
//
//  Contents:   Ethernet address function
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkutils.h"
#include "ndispnp.h"
#include "ntddndis.h"        // This defines the IOCTL constants.

extern const WCHAR c_szDevice[];

HRESULT HrGetNetCardAddr(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr)
{
    AssertValidReadPtr(pszDriver);
    AssertValidWritePtr(pqwNetCardAddr);

    DefineFunctionName("HrGetNetCardAddr");

    HRESULT hr = S_OK;

    // Form the device name in form "\Device\{GUID}"
    tstring strDeviceName = c_szDevice;
    strDeviceName.append(pszDriver);

    UNICODE_STRING ustrDevice;
    ::RtlInitUnicodeString(&ustrDevice, strDeviceName.c_str());

    UINT uiRet;
    UCHAR MacAddr[6];
    UCHAR PMacAddr[6];
    UCHAR VendorId[3];
    ULONGLONG qw = 0;

    uiRet = NdisQueryHwAddress(&ustrDevice, MacAddr, PMacAddr, VendorId);

    if (uiRet)
    {
        for (int i=0; i<=4; i++)
        {
            qw |= MacAddr[i];
            qw <<= 8;
        }
        qw |= MacAddr[i];
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    *pqwNetCardAddr = qw;

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNetCardAddrOld
//
// Purpose:   Get mac address of a netcard without using NdisQueryHwAddress
//
// Arguments:
//    pszDriver      [in]  name (on NT3.51/4) or guid (on NT5) of driver
//    pqwNetCardAddr [out] pointer to result
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 11-February-99
//
// Notes:
//
#define DEVICE_PREFIX   L"\\\\.\\"

HRESULT HrGetNetCardAddrOld(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr)
{
    DefineFunctionName("HrGetNetCardAddrOld");

    AssertValidReadPtr(pszDriver);

    *pqwNetCardAddr = 0;

    WCHAR       LinkName[512];
    WCHAR       DeviceName[80];
    WCHAR       szMACFileName[80];
    WCHAR       OidData[4096];
    BOOL        fCreatedDevice = FALSE;
    DWORD       ReturnedCount;
    HANDLE      hMAC;
    HRESULT     hr = S_OK;

    NDIS_OID OidCode[] =
    {
        OID_802_3_PERMANENT_ADDRESS,  // Ethernet
        OID_802_5_PERMANENT_ADDRESS,  // TokenRing
        OID_FDDI_LONG_PERMANENT_ADDR, // FDDI
    };

    //
    // Check to see if the DOS name for the MAC driver already exists.
    // Its not created automatically in version 3.1 but may be later.
    //

    TraceTag (ttidDefault, "Attempting to get address of %S", pszDriver);
    if (QueryDosDevice(pszDriver, LinkName, celems(LinkName)) == 0)
    {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
        {
            wcscpy(DeviceName, L"\\Device\\");
            wcscat(DeviceName, pszDriver);

            //
            // It doesn't exist so create it.
            //
            if (DefineDosDevice( DDD_RAW_TARGET_PATH, pszDriver, DeviceName))
            {
                fCreatedDevice = TRUE;
            }
            else
            {
                TraceLastWin32Error("DefineDosDevice returned an error creating the device");
                hr = HrFromLastWin32Error();
            }
        }
        else
        {
            TraceLastWin32Error("QueryDosDevice returned an error");
            hr = HrFromLastWin32Error();
        }
    }

    if (S_OK == hr)
    {
        //
        // Construct a device name to pass to CreateFile
        //
        wcscpy(szMACFileName, DEVICE_PREFIX);
        wcscat(szMACFileName, pszDriver);

        hMAC = CreateFile(
                    szMACFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    INVALID_HANDLE_VALUE
                    );

        if (hMAC != INVALID_HANDLE_VALUE)
        {
            DWORD count = 0;
            DWORD ReturnedCount = 0;
            //
            // We successfully opened the driver, format the IOCTL to pass the
            // driver.
            //

            while ((0 == ReturnedCount) && (count < celems (OidCode)))
            {
                if (DeviceIoControl(
                        hMAC,
                        IOCTL_NDIS_QUERY_GLOBAL_STATS,
                        &OidCode[count],
                        sizeof(OidCode[count]),
                        OidData,
                        sizeof(OidData),
                        &ReturnedCount,
                        NULL
                        ))
                {
                    TraceTag (ttidDefault, "OID %lX succeeded", OidCode[count]);
                    if (ReturnedCount == 6)
                    {
                        *pqwNetCardAddr = (ULONGLONG) 0;
                        WORD wAddrLen=6;
                        for (int i=0; i<wAddrLen; i++)
                        {
                            *(((BYTE*) pqwNetCardAddr)+i) = *(((BYTE*) OidData)+(wAddrLen-i-1));
                        }
                        hr = S_OK;
                    }
                    else
                    {
                        TraceLastWin32Error("DeviceIoControl returned an invalid count");
                        hr = HrFromLastWin32Error();
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error();
                }
                count++;
            }
        }
        else
        {
            TraceLastWin32Error("CreateFile returned an error");
            hr = HrFromLastWin32Error();
        }
    }


    if (fCreatedDevice)
    {
        //
        // The MAC driver wasn't visible in the Win32 name space so we created
        // a link.  Now we have to delete it.
        //
        if (!DefineDosDevice(
                DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION |
                    DDD_EXACT_MATCH_ON_REMOVE,
                pszDriver,
                DeviceName)
                )
        {
            TraceLastWin32Error("DefineDosDevice returned an error removing the device");
        }
    }

    TraceFunctionError(hr);
    return hr;
}

#ifdef DBG

void PrintNetCardAddr(IN PCWSTR pszDriver)
{
    ULONGLONG qwNetCardAddr=0;
    HRESULT hr = HrGetNetCardAddr(pszDriver, &qwNetCardAddr);
    wprintf(L"Netcard address for %s: 0x%012.12I64x", pszDriver, qwNetCardAddr);
    TraceError("dafile.main", hr);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nclan\lancmn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N C M N . C P P
//
//  Contents:   Implementation of LAN Connection related functions common
//              to the shell and netman.
//
//  Notes:
//
//  Author:     danielwe   7 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <winsock2.h>
#include <mswsock.h>
#include <iphlpapi.h>
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "ncstring.h"
#include "netconp.h"
#include "ndispnp.h"
#include "naming.h"
extern const DECLSPEC_SELECTANY WCHAR c_szConnName[]                 = L"Name";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyConFmt[]             = L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%s\\Connection";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyIrdaFmt[]            = L"System\\CurrentControlSet\\Control\\Network\\{6BDD1FC5-810F-11D0-BEC7-08002BE2092F}\\%s\\Connection";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyHwConFmt[]           = L"System\\CurrentControlSet\\Control\\Network\\Connections\\%s";
extern const DECLSPEC_SELECTANY WCHAR c_szRegValuePnpInstanceId[]    = L"PnpInstanceID";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyNetworkAdapters[]    = L"System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002bE10318}";
extern const DECLSPEC_SELECTANY WCHAR c_szRegValueNetCfgInstanceId[] = L"NetCfgInstanceId";
extern const DECLSPEC_SELECTANY WCHAR c_szRegValueMediaSubType[]     = L"MediaSubType";

//
// Helper functions
//

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenConnectionKey
//
//  Purpose:    Opens the "Connection" subkey under the gievn connection
//              GUID.
//
//  Arguments:
//      pguid    [in]       GUID of net card in use by the connection
//      pszGuid  [in]       String version of GUID of net card in use by
//                          the connection
//      sam      [in]       SAM desired
//      occFlags [in]       Flags determining how to open the key
//      pszPnpId [in]       The Pnp id of the net card in use by the
//                          connection. This is used if the key is created.
//      phkey    [out]      Returns hkey of connection subkey
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise.
//
//  Author:     danielwe   7 Oct 1997
//
//  Notes:  Only pguid or pszGuid should be specified, not both.  Specifying
//          both will result in an E_INVALIDARG error
//
//
HRESULT
HrOpenConnectionKey (
    IN const GUID* pguid,
    IN PCWSTR pszGuid,
    IN REGSAM sam,
    IN OCC_FLAGS occFlags,
    IN PCWSTR pszPnpId,
    OUT HKEY *phkey)
{
    HRESULT     hr = S_OK;
    WCHAR       szRegPath[256];
    WCHAR       szGuid[c_cchGuidWithTerm];

    Assert(phkey);
    Assert(pguid || (pszGuid && *pszGuid));
    Assert(!(pguid && pszGuid));
    Assert (FImplies (OCCF_CREATE_IF_NOT_EXIST == occFlags, pszPnpId && *pszPnpId));

    *phkey = NULL;

    if (pguid)
    {
        StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);
        pszGuid = szGuid;
    }

    wsprintfW(szRegPath, c_szRegKeyConFmt, pszGuid);

    if (occFlags & OCCF_CREATE_IF_NOT_EXIST)
    {
        DWORD   dwDisp;

        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0,
                              sam, NULL, phkey, &dwDisp);

        
        if ((S_OK == hr))
        {
            DWORD dwMediaSubType;
            // Store the pnp instance id as our back pointer to the pnp tree.
            //
            hr = HrRegSetSz (*phkey, c_szRegValuePnpInstanceId, pszPnpId);

            TraceError("HrRegSetSz in HrOpenConnectionKey failed.", hr);
            
            HRESULT hrT = HrRegQueryDword(*phkey, c_szRegValueMediaSubType, &dwMediaSubType);
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrT)
            {   
                CIntelliName inName(NULL, NULL);
                NETCON_MEDIATYPE ncMediaType = NCM_NONE;
                NETCON_SUBMEDIATYPE ncMediaSubType = NCSM_NONE;
                hrT = inName.HrGetPseudoMediaTypes(*pguid, &ncMediaType, &ncMediaSubType);
                if (SUCCEEDED(hrT) && (NCSM_LAN != ncMediaSubType) )
                {
                    hrT = HrRegSetDword(*phkey, c_szRegValueMediaSubType, ncMediaSubType);
                }
            }
            TraceError("Could not set media subtype for adapter", hrT);
        }
    }
    else if (occFlags & OCCF_DELETE_IF_EXIST)
    {
        if (wcslen(szGuid) > 0)
        {
            wcscpy(szRegPath, c_szRegKeyNetworkAdapters);
            wcscat(szRegPath, L"\\");
            wcscat(szRegPath, szGuid);
            hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, szRegPath);
        }
    }
    else
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, sam, phkey);
    }

    TraceErrorOptional("HrOpenConnectionKey", hr,
                       HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenHwConnectionKey
//
//  Purpose:    Opens the per-hardware profile registry key for this connection
//
//  Arguments:
//      refGuid  [in]       GUID of net card in use by the connection
//      sam      [in]       SAM desired
//      occFlags [in]       Flags determining how to open the key
//      phkey    [out]      Returns hkey of connection subkey
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise.
//
//  Author:     danielwe   9 Oct 1997
//
//  Notes:
//
HRESULT
HrOpenHwConnectionKey(
    REFGUID refGuid,
    REGSAM sam,
    OCC_FLAGS occFlags,
    HKEY *phkey)
{
    HRESULT     hr = S_OK;
    WCHAR       szRegPath[256];
    WCHAR       szGuid[c_cchGuidWithTerm];

    Assert(phkey);

    *phkey = NULL;

    StringFromGUID2(refGuid, szGuid, c_cchGuidWithTerm);
    wsprintfW(szRegPath, c_szRegKeyHwConFmt, szGuid);

    if (occFlags & OCCF_CREATE_IF_NOT_EXIST)
    {
        DWORD   dwDisp;

        hr = HrRegCreateKeyEx(HKEY_CURRENT_CONFIG, szRegPath, 0,
                              sam, NULL, phkey, &dwDisp);
    }
    else
    {
        hr = HrRegOpenKeyEx(HKEY_CURRENT_CONFIG, szRegPath, sam, phkey);
    }

    TraceError("HrOpenHwConnectionKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionNameUnique
//
//  Purpose:    Returns whether or not the given connection name is unique.
//
//  Arguments:
//      guidExclude  [in,ref]   Device GUID of Connection to exclude from
//                              consideration (can be {0})
//      pszName      [in] Name to verify for uniqueness
//
//  Returns:    S_OK if name is unique, S_FALSE if it is a duplicate, or OLE
//              or Win32 error otherwise
//
//  Author:     danielwe   14 Nov 1997
//
//  Notes:
//
HRESULT
HrIsConnectionNameUnique(
    REFGUID guidExclude,
    PCWSTR  pszName)
{
    Assert(pszName);

    BOOL    fDupe = FALSE;

    // Iterate all LAN connections
    //
    INetConnectionManager * pconMan;
    HRESULT hr = HrCreateInstance(CLSID_LanConnectionManager, 
                    CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, &pconMan);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
        INetConnection *    pconn;
        while (SUCCEEDED(hr) && !fDupe &&
               (S_OK == (ncIter.HrNext(&pconn))))
        {
            // Exclude if GUID passed in matches this connection's GUID.
            //
            if (!FPconnEqualGuid(pconn, guidExclude))
            {
                NETCON_PROPERTIES* pProps;
                hr = pconn->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    AssertSz(pProps->pszwName, "NULL pszwName!");

                    if (!lstrcmpiW(pProps->pszwName, pszName))
                    {
                        // Names match.. This is a dupe.
                        fDupe = TRUE;
                    }

                    FreeNetconProperties(pProps);
                }
            }

            ReleaseObj(pconn);
        }
        ReleaseObj(pconMan);
    }

    if (SUCCEEDED(hr))
    {
        hr = fDupe ? S_FALSE : S_OK;
    }

    TraceErrorOptional("HrIsConnectionNameUnique", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLanConnectionNameFromGuidOrPath
//
//  Purpose:    Retrieves the display-name of a LAN connection given its GUID.
//
//  Arguments:
//      guid        [in]       GUID of net card in question
//      pszPath     [in]       Bind path that contains the GUID of the net
//                             card in question
//      pszName    [out]      receives the retrieved name
//      pcchMax     [inout]    indicates the capacity of 'pszName' on input,
//                             contains the required capacity on output.
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise.
//
//  Author:     aboladeg    30 May 1998
//
//  Notes:  Only pguid or pszGuidPath should be specified, not both.
//          Specifying both will result in an E_INVALIDARG error
//
EXTERN_C
HRESULT
WINAPI
HrLanConnectionNameFromGuidOrPath(
    const GUID* pguid,
    PCWSTR pszPath,
    PWSTR pszName,
    LPDWORD pcchMax)
{
    HRESULT hr = S_OK;

    Assert(pcchMax);

    // If neither a guid nor a path was specified then return an error.
    //
    if (!pguid && (!pszPath || !*pszPath))
    {
        hr = E_INVALIDARG;
    }
    // If both pguid and a path were specified then return an error.
    //
    else if (pguid && (pszPath && *pszPath))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR szGuid [c_cchGuidWithTerm];
        PCWSTR pszGuid = NULL;

        // If we don't have pguid, it means we are to parset if from
        // pszPath.
        //
        if (!pguid)
        {
            Assert(pszPath && *pszPath);

            // Search for the beginning brace of the supposed GUID and
            // copy the remaining characters into szGuid.
            // If no guid is found, return file not found since
            // there will be no connection name found.
            //
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            for (const WCHAR* pch = pszPath; *pch; pch++)
            {
                if (*pch == L'{')
                {
                    wcsncpy (szGuid, pch, celems(szGuid)-1);
                    szGuid[celems(szGuid)-1] = 0;
                    pszGuid = szGuid;
                    hr = S_OK;
                    break;
                }
            }
        }

        if (S_OK == hr)
        {
            HKEY hkey;

            hr = HrOpenConnectionKey(pguid, pszGuid, KEY_READ,
                    OCCF_NONE, NULL, &hkey);
            if (S_OK == hr)
            {
                DWORD dwType;

                *pcchMax *= sizeof(WCHAR);
                hr = HrRegQueryValueEx(hkey, c_szConnName, &dwType,
                                (LPBYTE)pszName, pcchMax);
                *pcchMax /= sizeof(WCHAR);

                RegCloseKey(hkey);
            }
        }
    }

    TraceError("HrLanConnectionNameFromGuid",
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrPnccFromGuid
//
//  Purpose:    Given a GUID of an adapter, returns the INetCfgComponent
//              that corresponds to it.
//
//  Arguments:
//      pnc     [in]        INetCfg to work with
//      refGuid [in]        GUID of adapter to look for
//      ppncc   [out]       Returns INetCfgComponent already AddRef'd
//
//  Returns:    S_OK if found, S_FALSE if not (out param will be NULL), or
//              OLE or Win32 error otherwise
//
//  Author:     danielwe   6 Nov 1997
//
//  Notes:      Caller should ReleaseObj the returned pointer
//
HRESULT HrPnccFromGuid(INetCfg *pnc, const GUID &refGuid,
                       INetCfgComponent **ppncc)
{
    HRESULT     hr = S_OK;

    Assert(pnc);

    if (!ppncc)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppncc = NULL;

        BOOL                    fFound = FALSE;
        CIterNetCfgComponent    nccIter(pnc, &GUID_DEVCLASS_NET);
        INetCfgComponent *      pncc;

        while (!fFound && SUCCEEDED(hr) &&
               S_OK == (hr = nccIter.HrNext(&pncc)))
        {
            GUID    guidTest;

            hr = pncc->GetInstanceGuid(&guidTest);
            if (S_OK == hr)
            {
                if (guidTest == refGuid)
                {
                    // Found our adapter
                    fFound = TRUE;

                    // Give another reference so it's not released down below
                    AddRefObj(pncc);
                    *ppncc = pncc;
                    Assert (S_OK == hr);
                }
            }

            ReleaseObj(pncc);
        }

        if (SUCCEEDED(hr) && !fFound)
        {
            hr = S_FALSE;
        }
    }

    TraceErrorOptional("HrPnccFromGuid", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnection
//
//  Purpose:    Determines whether the given component has an associated
//              LAN connection.
//
//  Arguments:
//      pncc [in]   Component to test
//
//  Returns:    S_OK if it does, S_FALSE if not, otherwise a Win32 error code
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
HRESULT HrIsConnection(INetCfgComponent *pncc)
{
    HRESULT     hr = S_FALSE;
    GUID        guid;

    Assert(pncc);

    // Get the component instance GUID
    //
    hr = pncc->GetInstanceGuid(&guid);
    if (SUCCEEDED(hr))
    {
        HKEY    hkey;

        // Check for the existence of the connection sub-key
        hr = HrOpenConnectionKey(&guid, NULL, KEY_READ,
                OCCF_NONE, NULL, &hkey);
        if (SUCCEEDED(hr))
        {
            RegCloseKey(hkey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // Key not there, return FALSE
            hr = S_FALSE;
        }
    }

    TraceErrorOptional("HrIsConnection", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDeviceGuid
//
//  Purpose:    Given a LAN connection object, returns the device GUID
//              associated with it.
//
//  Arguments:
//      pconn [in]      LAN connection object
//      pguid [out]     Returns device GUID
//
//  Returns:    S_OK if success, OLE or Win32 error if failed
//
//  Author:     danielwe   23 Dec 1997
//
//  Notes:
//
HRESULT HrGetDeviceGuid(INetConnection *pconn, GUID *pguid)
{
    HRESULT             hr = S_OK;
    INetLanConnection * plan = NULL;

    Assert(pguid);

    hr = HrQIAndSetProxyBlanket(pconn, &plan);

    if (SUCCEEDED(hr))
    {
        hr = plan->GetDeviceGuid(pguid);

        ReleaseObj(plan);
    }

    TraceError("HrGetDeviceGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FPconnEqualGuid
//
//  Purpose:    Determines if the given connection's device GUID matches the
//              guid passed in.
//
//  Arguments:
//      pconn [in]      Connection object to examine (must be a LAN connection)
//      guid  [in,ref]  Guid to compare with
//
//  Returns:    TRUE if connection's device guid matches passed in guid, FALSE
//              if not.
//
//  Author:     danielwe   23 Dec 1997
//
//  Notes:
//
BOOL FPconnEqualGuid(INetConnection *pconn, REFGUID guid)
{
    HRESULT     hr = S_OK;
    GUID        guidDev;
    BOOL        fRet = FALSE;

    hr = HrGetDeviceGuid(pconn, &guidDev);
    if (SUCCEEDED(hr))
    {
        fRet = (guidDev == guid);
    }

    TraceError("FPconnEqualGuid", hr);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrPnpInstanceIdFromGuid
//
//  Purpose:    Given a GUID of a network device, returns its PnP Instance ID
//
//  Arguments:
//      pguid       [in]    NetCfg instance GUID of device
//      pszInstance [out]   PnP instance ID (string)
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrPnpInstanceIdFromGuid(
    const GUID* pguid,
    PWSTR pszInstance,
    UINT cchInstance)
{
    HRESULT     hr = S_OK;
    WCHAR       szRegPath[MAX_PATH];
    HKEY        hkey;
    DWORD       cb;
    WCHAR       szGuid[c_cchGuidWithTerm];

    StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);

    wsprintfW(szRegPath, c_szRegKeyConFmt, szGuid);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, KEY_READ, &hkey);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        wsprintfW(szRegPath, c_szRegKeyIrdaFmt, szGuid);
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, KEY_READ, &hkey);
    }

    if (S_OK == hr)
    {
        cb = cchInstance * sizeof(WCHAR);

        hr = HrRegQuerySzBuffer(hkey, c_szRegValuePnpInstanceId,
                                pszInstance, &cb);
        RegCloseKey(hkey);
    }
#ifdef ENABLETRACE
    if (FAILED(hr))
    {
        TraceHr (ttidError, FAL, hr, IsEqualGUID(*pguid, GUID_NULL), "HrPnpInstanceIdFromGuid "
                 "failed getting id for %S", szGuid);
    }
#endif

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrPnpInstanceIdFromGuid");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPnpDeviceStatus
//
//  Purpose:    Given a network device GUID, returns its status
//
//  Arguments:
//      pguid   [in]    NetCfg instance GUID of network device
//      pStatus [out]   Status of device
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrGetPnpDeviceStatus(
    const GUID* pguid,
    NETCON_STATUS *pStatus)
{
    HRESULT     hr = S_OK;

    if (!pStatus || !pguid)
    {
        hr = E_POINTER;
        goto err;
    }

    WCHAR   szInstance[MAX_PATH];

    hr = HrPnpInstanceIdFromGuid(pguid, szInstance, celems(szInstance));
    if (SUCCEEDED(hr))
    {
        DEVINST     devinst;
        CONFIGRET   cr;

        cr = CM_Locate_DevNode(&devinst, szInstance,
                               CM_LOCATE_DEVNODE_NORMAL);
        if (CR_SUCCESS == cr)
        {
            hr = HrGetDevInstStatus(devinst, pguid, pStatus);
        }
        else if (CR_NO_SUCH_DEVNODE == cr)
        {
            // If the devnode doesn't exist, the hardware is not physically
            // present
            //
            *pStatus = NCS_HARDWARE_NOT_PRESENT;
        }
    }

err:
    TraceError("HrGetPnpDeviceStatus", hr);
    return hr;
}

extern const WCHAR c_szDevice[];

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryLanMediaState
//
//  Purpose:    Determines as best as can be basically whether the cable is
//              plugged in to the network card.
//
//  Arguments:
//      pguid     [in]  GUID of device to tes
//      pfEnabled [out] Returns TRUE if media is connected, FALSE if not
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1998
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrQueryLanMediaState(
    const GUID* pguid,
    BOOL* pfEnabled)
{
    HRESULT         hr = S_OK;

    if (!pfEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        UINT            uiRet = 0;
        NIC_STATISTICS  nsNewLanStats = {0};
        tstring         strDevice;
        UNICODE_STRING  ustrDevice;
        WCHAR           szGuid[c_cchGuidWithTerm];

        // Initialize to TRUE
        //
        *pfEnabled = TRUE;

        StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);

        strDevice = c_szDevice;
        strDevice.append(szGuid);

        RtlInitUnicodeString(&ustrDevice, strDevice.c_str());

        nsNewLanStats.Size = sizeof(NIC_STATISTICS);
        uiRet = NdisQueryStatistics(&ustrDevice, &nsNewLanStats);
        if (uiRet)
        {
            *pfEnabled = (nsNewLanStats.MediaState == MEDIA_STATE_CONNECTED);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrQueryLanMediaState");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsMediaPresent
//
//  Purpose:    Determines as best as can be basically whether the cable is
//              plugged in to the network card.
//
//  Arguments:
//      pGuid [in]    GUID of device to test
//
//  Returns:    TRUE if media is connected, FALSE otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
BOOL
FIsMediaPresent(
    const GUID *pguid)
{
    BOOL    fEnabled;

    if (SUCCEEDED(HrQueryLanMediaState(pguid, &fEnabled)))
    {
        return fEnabled;
    }

    // Assume media is connected on failure
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDevInstStatus
//
//  Purpose:    Determines status of the given Pnp device instance
//
//  Arguments:
//      devinst [in]    PnP device instance
//      pGuid   [in]    GUID of said device
//      pStatus [out]   Status of device
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrGetDevInstStatus(
    DEVINST devinst,
    const GUID* pguid,
    NETCON_STATUS* pStatus)
{
    HRESULT     hr = S_OK;
    ULONG       ulStatus;
    ULONG       ulProblem;
    CONFIGRET   cfgRet;

    if (!pguid)
    {
        return E_INVALIDARG;
    }

    if (!pStatus)
    {
        return E_POINTER;
    }

    cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                      devinst, 0, NULL);

    if (CR_SUCCESS == cfgRet)
    {
        TraceTag(ttidLanCon, "CM_Get_DevNode_Status_Ex: ulProblem "
                 "= 0x%08X, ulStatus = 0x%08X.",
                 ulProblem, ulStatus);

        switch (ulProblem)
        {
        case 0:
            // No problem, we're connected
            *pStatus = NCS_CONNECTED;
            break;

        case CM_PROB_DEVICE_NOT_THERE:
        case CM_PROB_MOVED:
            // Device not present
            *pStatus = NCS_HARDWARE_NOT_PRESENT;
             break;

        case CM_PROB_HARDWARE_DISABLED:
            // Device was disabled via Device Manager
            *pStatus = NCS_HARDWARE_DISABLED;
            break;

        case CM_PROB_DISABLED:
            // Device was disconnected
            *pStatus = NCS_DISCONNECTED;
            break;

        default:
            // All other problems
            *pStatus = NCS_HARDWARE_MALFUNCTION;
            break;
        }

        if (*pStatus == NCS_CONNECTED)
        {
            // Check DeviceState and MediaState from NdisQueryStatistics
            UINT            uiRet = 0;
            NIC_STATISTICS  nsNewLanStats = {0};
            tstring         strDevice;
            UNICODE_STRING  ustrDevice;
            WCHAR           szGuid[c_cchGuidWithTerm];

            StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);

            strDevice = c_szDevice;
            strDevice.append(szGuid);

            RtlInitUnicodeString(&ustrDevice, strDevice.c_str());

            nsNewLanStats.Size = sizeof(NIC_STATISTICS);
            uiRet = NdisQueryStatistics(&ustrDevice, &nsNewLanStats);

            if (uiRet)
            {
                // Check MediaState
                if (nsNewLanStats.MediaState == MEDIA_STATE_DISCONNECTED)
                {
                    TraceTag(ttidLanCon, "NdisQueryStatistics reports MediaState of "
                                         "device %S is disconnected.", szGuid);

                    *pStatus = NCS_MEDIA_DISCONNECTED;
                }
                else 
                {
                    HRESULT hrTmp;

                    BOOL fValidAddress = TRUE;

                    hrTmp = HrGetAddressStatusForAdapter(pguid, &fValidAddress);
                    if (SUCCEEDED(hrTmp))
                    {
                        if (!fValidAddress)
                        {
                            *pStatus = NCS_INVALID_ADDRESS;

                            INetCfg *pNetCfg  = NULL;
                            BOOL     fInitCom = TRUE;

                            HRESULT hrT = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED);
                            if (RPC_E_CHANGED_MODE == hrT)
                            {
                                hrT      = S_OK;
                                fInitCom = FALSE;
                            }

                            if (SUCCEEDED(hrT))
                            {
                                HRESULT hrT = HrCreateAndInitializeINetCfg(NULL, &pNetCfg, FALSE, 0,  NULL,  NULL);
                                if (SUCCEEDED(hrT))
                                {
                                    INetCfgComponent *pNetCfgComponent = NULL;
                                    hrT = HrPnccFromGuid(pNetCfg, *pguid, &pNetCfgComponent);
                                    if (S_OK == hrT)
                                    {
                                        DWORD dwCharacteristics = 0;
                                        pNetCfgComponent->GetCharacteristics(&dwCharacteristics);

                                        if (NCF_VIRTUAL & dwCharacteristics)
                                        {
                                            *pStatus = NCS_CONNECTED;

                                            TraceTag(ttidLanCon, "NCS_INVALID_ADDRESS status ignored for NCF_VIRTUAL device: %S", szGuid);
                                        }

                                        pNetCfgComponent->Release();
                                    }

                                    HrUninitializeAndReleaseINetCfg(FALSE, pNetCfg, FALSE);
                                }
                                
                                if (fInitCom)
                                {
                                    CoUninitialize();
                                }
                            }
                            TraceError("Error retrieving adapter Characteristics", hrT);
                        }
                    }
                    
                }
            }
            else
            {
                // $REVIEW(tongl 11/25/98): This is added to display proper state
                // for ATM ELAN virtual miniports (Raid #253972, 256355).
                //
                // If we get here for a physical adapter, this means NdisQueryStatistics
                // returned different device state from CM_Get_DevNode_Status_Ex, we may
                // have a problem.

                hr = HrFromLastWin32Error();

                if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) &&
                    (nsNewLanStats.DeviceState == DEVICE_STATE_DISCONNECTED))
                {
                    Assert(nsNewLanStats.MediaState == MEDIA_STATE_UNKNOWN);

                    TraceTag(ttidLanCon, "NdisQueryStatistics reports DeviceState of "
                                         "device %S is disconnected.", szGuid);

                    *pStatus = NCS_DISCONNECTED;
                    hr = S_OK;
                }
                else if (HRESULT_FROM_WIN32(ERROR_NOT_READY) == hr)
                {
                    // This error means that the device went into power
                    // management induced sleep and so we should report this
                    // case as media disconnected, not connection disconnected
                    TraceTag(ttidLanCon, "NdisQueryStatistics reports device"
                             " %S is asleep. Returning status of media "
                             "disconnected.", szGuid);

                    *pStatus = NCS_MEDIA_DISCONNECTED;
                    hr = S_OK;
                }
                else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                {
                    TraceTag(ttidLanCon, "NdisQueryStatistics reports device %S is still connecting.",
                                          szGuid);

                    *pStatus = NCS_CONNECTING;
                    hr = S_OK;
                }
                else
                {
                    // Treat as disconected, if we return failure the folder will
                    // not display this connection at all.
                    TraceHr (ttidLanCon, FAL, hr, FALSE, "NdisQueryStatistics reports error on device %S",
                             szGuid);

                    *pStatus = NCS_DISCONNECTED;
                    hr = S_OK;
                }
            }
        }
    }

    TraceError("HrGetDevInstStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HasValidAddress
//
//  Purpose:    Verifies that the given adapter has a valid address
//
//  Arguments:
//              IN PIP_ADAPTER_INFO pAdapterInfo  - Adapter Info structure
//                                                  containing addresses
//
//  Returns:    True if Valid address, False otherwise
//
//  Author:     ckotze   11 Jan 2001
//
//  Notes:      
//              
//  
//              
BOOL HasValidAddress(IN PIP_ADAPTER_INFO pAdapterInfo)
{
    PIP_ADDR_STRING pAddrString;
	unsigned int addr;

    TraceFileFunc(ttidConman);

    for(pAddrString = &pAdapterInfo->IpAddressList; pAddrString != NULL; pAddrString = pAddrString->Next) 
    {
        TraceTag(ttidConman, "IP Address: %s", pAddrString->IpAddress.String);

        addr = inet_addr(pAddrString->IpAddress.String);
        if(!addr)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetAddressStatusForAdapter
//
//  Purpose:    Verifies that the given adapter has a valid address
//
//  Arguments:
//              IN LPCGUID pguidAdapter     - Guid for the adapter
//              OUT BOOL* pbValidAddress    - BOOL indicating if it has
//                                            has Valid Address 
//
//  Returns:    True if Valid address, False otherwise
//
//  Author:     ckotze   11 Jan 2001
//
//  Notes:      
//              
//  
//              
HRESULT HrGetAddressStatusForAdapter(IN LPCGUID pguidAdapter, OUT BOOL* pbValidAddress)
{   
    HRESULT hr = E_FAIL;
    GUID guidId = GUID_NULL;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    PIP_ADAPTER_INFO pAdapters = NULL;
    ULONG ulSize = 0;
    PIP_ADAPTER_INFO p = NULL;
    WCHAR lpszInstanceId[50];
    WCHAR szAdapterGUID[MAX_PATH];
    WCHAR szAdapterID[MAX_PATH];

    if (!pguidAdapter)
    {
        return E_INVALIDARG;
    }
    if (!pbValidAddress)
    {
        return E_POINTER;
    }

    ZeroMemory(szAdapterGUID, sizeof(WCHAR)*MAX_PATH);
    ZeroMemory(szAdapterID, sizeof(WCHAR)*MAX_PATH);

    StringFromGUID2(*pguidAdapter, szAdapterGUID, MAX_PATH);

    // GetAdaptersInfo returns ERROR_BUFFER_OVERFLOW when it is filling in the size
    if ( ERROR_BUFFER_OVERFLOW == GetAdaptersInfo(NULL, &ulSize) )
    {
        pAdapters = reinterpret_cast<PIP_ADAPTER_INFO>(new BYTE[ulSize]);
    
        if (pAdapters)
        {
            if(ERROR_SUCCESS == GetAdaptersInfo(pAdapters, &ulSize))
            {
                for (p = pAdapters; p != NULL; p = p->Next)
                {
                    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, p->AdapterName, strlen(p->AdapterName), szAdapterID, MAX_PATH);
                    if (wcscmp(szAdapterGUID, szAdapterID) == 0)
                    {
                        TraceTag(ttidConman, "Found Adapter: %s", p->AdapterName);
                        pAdapterInfo = p;

                        *pbValidAddress = HasValidAddress(pAdapterInfo);

                        hr = S_OK;

                        TraceTag(ttidConman, "Valid Address: %s", (*pbValidAddress) ? "Yes" : "No");
                        TraceTag(ttidConman, "DHCP: %s", (pAdapterInfo->DhcpEnabled) ? "Yes" : "No");
                    }                
                }
            }
            delete[] reinterpret_cast<BYTE*>(pAdapters);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT HrGetPseudoMediaTypeFromConnection(IN REFGUID guidConn, OUT NETCON_SUBMEDIATYPE *pncsm)
{
    HRESULT hr = S_OK;
    HKEY hkeyConnection;

    hr = HrOpenConnectionKey(&guidConn, NULL, KEY_READ, OCCF_NONE, NULL, &hkeyConnection);

    if (SUCCEEDED(hr))
    {
        DWORD dwMediaSubType;

        hr = HrRegQueryDword(hkeyConnection, c_szRegValueMediaSubType, &dwMediaSubType);
        if (SUCCEEDED(hr))
        {
            *pncsm = static_cast<NETCON_SUBMEDIATYPE>(dwMediaSubType);
        }
        else
        {
            *pncsm = NCSM_LAN;
        }
        RegCloseKey(hkeyConnection);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\kkcwinf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C W I N F . C P P
//
//  Contents:   Definition of class CWInfFile and other related classes
//
//  Notes:
//
//  Author:     kumarp    12 April 97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkcwinf.h"
#include "kkutils.h"
#include <stdio.h>

#define TC_COMMENT_CHAR L';'
const WCHAR c_szCommentPrefix[] = L"; ";


extern const WCHAR c_szYes[];
extern const WCHAR c_szNo[];

void EraseAndDeleteAll(IN WifLinePtrList* ppl)
{
    WifLinePtrListIter i=ppl->begin();
    while (i != ppl->end())
    {
        delete *i++;
    }

    ppl->erase(ppl->begin(), ppl->end());
}
inline void EraseAll(IN WifLinePtrList* ppl)
{
    ppl->erase(ppl->begin(), ppl->end());
}

inline WifLinePtrListIter GetIterAtBack(IN const WifLinePtrList* ppl)
{
    WifLinePtrListIter pliRet = ppl->end();
    pliRet--;
    return pliRet;
}

inline WifLinePtrListIter AddAtEndOfPtrList(IN WifLinePtrList& pl, IN PCWInfLine pwifLine)
{
    return pl.insert(pl.end(), pwifLine);
}

// ======================================================================
// Class CWInfFile
// ======================================================================

// ----------------------------------------------------------------------
// CWInfFile public functions
// ----------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::CWInfFile
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      We keep the read-context and write-context separate. This allows us
//      to simultaneously read and write from the file

CWInfFile::CWInfFile()
{
    m_fp          = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::~CWInfFile
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfFile::~CWInfFile()
{
    EraseAndDeleteAll(m_plLines);
    EraseAll(m_plSections);

    CWInfKey::UnInit();

    delete m_plLines;
    delete m_plSections;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Init
//
//  Purpose:    initialization of alloc'd member variables
//
//  Arguments:  none
//
//  Author:     davea    17 Feb 2000
//
//
BOOL CWInfFile::Init()
{
    m_plLines       = new WifLinePtrList(); // lines in this file
    m_plSections    = new WifLinePtrList(); // lines that represent sections
                                      // this allows us to quickly locate a section
	if ((m_plLines != NULL) &&
		(m_plSections != NULL))
	{
		m_ReadContext.posSection = m_plSections->end();
		m_ReadContext.posLine    = m_plLines->end();
		m_WriteContext.posSection = m_plSections->end();
		m_WriteContext.posLine    = m_plLines->end();
	}
	else
	{
		return(FALSE);
	}

    CWInfKey::Init();
	return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Open
//
//  Purpose:    Opens an INF file
//
//  Arguments:
//      pszFileName  [in]   name of the file to open
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not keep the physical file handle open. We just open the file
//      read the contents and close it. After this, one can freely read from or
//      write to the file. This is done to the memory image of the file. To write
//      this file back, one must call Close() or SaveAs() member functions
BOOL CWInfFile::Open(IN PCWSTR pszFileName)
{
    DefineFunctionName("CWInfFile::Open");

    BOOL status = FALSE;

    m_strFileName = pszFileName;
    FILE *fp = _wfopen(pszFileName, L"r");
    if (fp)
    {
        status = Open(fp);
        fclose(fp);
    }
    else
    {
        TraceTag(ttidError, "%s: could not open file: %S",
                 __FUNCNAME__, pszFileName);
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Open
//
//  Purpose:    Opens an INF file
//
//  Arguments:
//      fp  [in]   FILE* of the file to read from
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not physically close the file handle
BOOL CWInfFile::Open(IN FILE *fp)
{
    PWSTR pszLineRoot = (PWSTR) MemAlloc ((MAX_INF_STRING_LENGTH + 1) *
            sizeof (WCHAR));

    if (!pszLineRoot)
    {
        return FALSE;
    }

    PWSTR pszNewLinePos;
    while (!feof(fp))
    {
        PWSTR pszLine = pszLineRoot;

        *pszLine = 0;
        if (fgetws(pszLine, MAX_INF_STRING_LENGTH, fp))
        {
            // Trim leading spaces
            //
            while (iswctype(*pszLine, _SPACE))
            {
                pszLine++;
            }

            if (pszNewLinePos = wcschr(pszLine, L'\n'))
            {
                *pszNewLinePos = 0;
            }
            if (!wcslen(pszLine))
            {
                continue;
            }
            ParseLine(pszLine);
        }
    }

    MemFree (pszLineRoot);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::ParseLine
//
//  Purpose:    Parse the given line and update internal structures
//
//  Arguments:
//      pszLine  [in]   line text to parse
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Parse the line and add a CWInfKey / CWInfSection / CWInfComment
//      as appropriate in the current write context
//      The logic:
//        add CWInfComment if line begins with ';'
//        add CWInfKey     if line is of the form key=value
//        add CWInfSection if line begins with '[' and has ']' at the end
//        ignore anything else i.e. dont add anything

void CWInfFile::ParseLine(IN PCWSTR pszLine)
{
    tstring strTemp;
    PWSTR  pszTemp, pszTemp2;

    if (!CurrentWriteSection() && (pszLine[0] != L'['))
    {
        return;
    }

    if (pszLine[0] == TC_COMMENT_CHAR)
    {
        //it is a comment
        AddComment(pszLine + 1);
    }
    else if (pszLine[0] == L'[')
    {
        //it is a section
        pszTemp = wcschr(pszLine, L']');
        if (!pszTemp)
        {
            return;
        }
        tstring strSectionName(pszLine+1, pszTemp-pszLine-1);
        AddSection(strSectionName.c_str());
    }
    else if ((pszTemp = wcschr(pszLine, L'=')) != NULL)
    {
        if (pszLine == pszTemp)
        {
            return;
        }

        //it is a key
        pszTemp2 = pszTemp;     // pszTemp2 points at '='
        pszTemp2--;
        while (iswctype(*pszTemp2, _SPACE) && (pszTemp2 != pszLine))
        {
            pszTemp2--;
        }

        pszTemp++;              // skip '='
        while (*pszTemp && iswctype(*pszTemp, _SPACE))
        {
            pszTemp++;
        }

        if ((*pszTemp == L'"') && !wcschr(pszTemp, L','))
        {
            pszTemp++;
            DWORD dwLen = wcslen(pszTemp);
            if (pszTemp[dwLen-1] == L'"')
            {
                pszTemp[dwLen-1] = 0;
            }
        }

        tstring strKeyName(pszLine, pszTemp2-pszLine+1);
        tstring strKeyValue(pszTemp);
        AddKey(strKeyName.c_str(), strKeyValue.c_str());
    }
    else
    {
        // we cannot interpret the line, just add it
        AddRawLine(pszLine);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Create
//
//  Purpose:    Create a blank INF file in memory
//
//  Arguments:
//      pszFileName  [in]   name of the file to create
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not write anything to disk
BOOL CWInfFile::Create(IN PCWSTR pszFileName)
{
    m_strFileName = pszFileName;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Create
//
//  Purpose:    Create a blank INF file in memory
//
//  Arguments:
//      fp  [in]   FILE* of the file to create
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not write anything to disk
BOOL CWInfFile::Create(IN FILE *fp)
{
    m_fp = fp;

    return fp != NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Close
//
//  Purpose:    Close the file, flushing data to disk.
//
//  Arguments:  none
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This just calls CWInfFile::flush() which will actually write the file back
BOOL CWInfFile::Close()
{
    return Flush();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Flush
//
//  Purpose:    Close the file, flushing data to disk.
//
//  Arguments:  none
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This just calls CWInfFile::flush() which will actually write the file back
BOOL CWInfFile::Flush()
{
    WifLinePtrListIter pos;
    CWInfLine *line;
    tstring line_text;
    BOOL fStatus = TRUE;

    //if a filename was specified then open it for writing
    //
    if (!m_strFileName.empty())
    {
        m_fp = _wfopen(m_strFileName.c_str(), L"w");
    }

    if (!m_fp)
        return FALSE;

    // get text of each line and dump it to the file
    for( pos = m_plLines->begin(); pos != m_plLines->end(); )
    {
        line = (CWInfLine *) *pos++;
        line->GetText(line_text);
        if (line->Type() == INF_SECTION)
            fwprintf(m_fp, L"\n");

        fwprintf(m_fp, L"%s", line_text.c_str());
        fwprintf(m_fp, L"\n");
    }

    if (!m_strFileName.empty())
    {
        fStatus = fclose(m_fp) == 0;
        m_fp = NULL;
    }

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FlushEx
//
//  Purpose:    Close the file, flushing data to disk.
//
//  Arguments:  none
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     frankli    4 May 2000
//
//  Notes:
//      This is used by SysPrep to enclose value of a key with quotes except 
//      for multi-sz value.
BOOL CWInfFile::FlushEx()
{
    WifLinePtrListIter pos;
    CWInfLine *line;
    tstring line_text;
    BOOL fStatus = TRUE;

    //if a filename was specified then open it for writing
    //
    if (!m_strFileName.empty())
    {
        m_fp = _wfopen(m_strFileName.c_str(), L"w");
    }

    if (!m_fp)
        return FALSE;

    // get text of each line and dump it to the file
    for( pos = m_plLines->begin(); pos != m_plLines->end(); )
    {
        line = (CWInfLine *) *pos++;
        line->GetTextEx(line_text);
        if (line->Type() == INF_SECTION)
            fwprintf(m_fp, L"\n");

        fwprintf(m_fp, L"%s", line_text.c_str());
        fwprintf(m_fp, L"\n");
    }

    if (!m_strFileName.empty())
    {
        fStatus = fclose(m_fp) == 0;
        m_fp = NULL;
    }

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::SaveAs
//
//  Purpose:    Save current image to the given file
//
//  Arguments:
//      pszFileName  [in]   name of the file to save as
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This is not same as Close()!, Close() will still write to
//      the original file.
BOOL CWInfFile::SaveAs(IN PCWSTR pszFileName)
{
    BOOL fStatus;

    tstring strTemp = m_strFileName;
    m_strFileName = pszFileName;
    fStatus = Flush();
    m_strFileName = strTemp;

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::SaveAsEx
//
//  Purpose:    Save current image to the given file
//
//  Arguments:
//      pszFileName  [in]   name of the file to save as
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     frankli    4 May 2000
//
//  Notes:
//      This is not same as Close()!, Close() will still write to
//      the original file. Save SysPrep prepared data, 
//      value of a key will be enclosed with quotes except for multi-sz
//      value.
BOOL CWInfFile::SaveAsEx(IN PCWSTR pszFileName)
{
    BOOL fStatus;

    tstring strTemp = m_strFileName;
    m_strFileName = pszFileName;
    fStatus = FlushEx();
    m_strFileName = strTemp;

    return fStatus;
}


// ---------------------------------------------------------------------------
// Functions for reading
// ---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::SetCurrentReadSection
//
//  Purpose:    Set read-context so that subsequent reads
//              will be from this section
//
//  Arguments:
//      pwisSection  [in]   Section to set context to
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::SetCurrentReadSection(IN PCWInfSection pwisSection)
{
    if ((CurrentReadSection() != pwisSection) && pwisSection)
    {
        m_ReadContext.posSection = pwisSection->m_posSection;
        m_ReadContext.posLine = pwisSection->m_posLine;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FindSection
//
//  Purpose:    Find the given section in current file
//
//
//  Arguments:
//      pszSectionName  [in]   Section to find
//      wsmMode         [in]   Search mode
//                             (search from beginning-of-file / current-position)
//  Returns:    Pointer to section if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets the current read-context to the section found
//
PCWInfSection CWInfFile::FindSection(IN PCWSTR pszSectionName,
                                     IN WInfSearchMode wsmMode)
{
    PCWInfSection pwisRet=NULL, pwisTemp;
    WifLinePtrListIter pos, old_pos;
    if (wsmMode == ISM_FromBeginning)
    {
        pos = m_plSections->begin();
    }
    else
    {
        pos = m_ReadContext.posSection;
        if (pos == m_plSections->end())
            pos = m_plSections->begin();
    }

    while (pos != m_plSections->end())
    {
        old_pos = pos;
        pwisTemp = (PCWInfSection) *pos++;
        if (!lstrcmpiW(pwisTemp->m_Name.c_str(), pszSectionName))
        {
            pwisRet = pwisTemp;
            SetCurrentReadSection(pwisRet);
            /*
            //            m_ReadContext.posSection = old_pos;
            m_ReadContext.posSection = pwisRet->m_posSection;
            m_ReadContext.posLine    = pwisRet->m_posLine;
            */
            break;
        }
    }

    return pwisRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FindKey
//
//  Purpose:    Find a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      wsmMode         [in]   Search mode
//                             (search from beginning-of-section / current-position)
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfKey CWInfFile::FindKey(IN PCWSTR pszKeyName, IN WInfSearchMode wsmMode)
{
    WifLinePtrListIter pos, old_pos;
    PCWInfKey pwikRet=NULL;
    PCWInfLine pwilTemp;

    PCWInfSection pwisCurrentReadSection = CurrentReadSection();
    ReturnNULLIf(!pwisCurrentReadSection);

    if (wsmMode == ISM_FromCurrentPosition)
    {
        pos = m_ReadContext.posLine;
    }
    else
    {
        pos = pwisCurrentReadSection->m_posLine;
    }

    pos++;  // start from next line

    while(pos != m_plLines->end())
    {
        old_pos = pos;
        pwilTemp = (PCWInfLine) *pos++;
        if (pwilTemp->Type() != INF_KEY)
        {
            if (pwilTemp->Type() == INF_SECTION)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        if (!lstrcmpiW(((PCWInfKey) pwilTemp)->m_Name.c_str(), pszKeyName))
        {
            pwikRet = (PCWInfKey) pwilTemp;
            m_ReadContext.posLine = old_pos;
            break;
        }
    }

    ReturnNULLIf(!pwikRet);

    return pwikRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FirstKey
//
//  Purpose:    Return the first  key in the current section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfFile::FirstKey()
{
    WifLinePtrListIter pos, old_pos;
    PCWInfKey pwikRet=NULL;
    PCWInfLine pwilTemp;

    PCWInfSection pwisCurrentReadSection = CurrentReadSection();

    if (!pwisCurrentReadSection)
    {
        return NULL;
    }

    pos = pwisCurrentReadSection->m_posLine;

    pos++;  // start from next line

    while(pos != m_plLines->end())
    {
        old_pos = pos;
        pwilTemp = (PCWInfLine) *pos++;
        if (pwilTemp->Type() != INF_KEY)
        {
            if (pwilTemp->Type() == INF_SECTION)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        pwikRet = (PCWInfKey) pwilTemp;
        m_ReadContext.posLine = old_pos;
        break;
    }

    return pwikRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::NextKey
//
//  Purpose:    Return the next key in the current section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfFile::NextKey()
{
    WifLinePtrListIter pos, old_pos;
    PCWInfKey pwikRet=NULL;
    PCWInfLine pwilTemp;

    PCWInfSection pwisCurrentReadSection = CurrentReadSection();

    if (!pwisCurrentReadSection)
    {
        return NULL;
    }

    pos = m_ReadContext.posLine;

    pos++;  // start from next line

    while(pos != m_plLines->end())
    {
        old_pos = pos;
        pwilTemp = (PCWInfLine) *pos++;
        if (pwilTemp->Type() != INF_KEY)
        {
            if (pwilTemp->Type() == INF_SECTION)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        pwikRet = (PCWInfKey) pwilTemp;
        m_ReadContext.posLine = old_pos;
        break;
    }

    return pwikRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringListValue
//
//  Purpose:    Return the value of the given key as a string-list
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pslList         [out]  List value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringList
//     otherwise returns a TStringList with a single element
//
BOOL CWInfFile::GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &pslList)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetStringListValue(pslList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringArrayValue
//
//  Purpose:    Return the value of the given key as a string-Array
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      saStrings       [out]  Array value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12-November-97
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringArray
//     otherwise returns a TStringArray with a single element
//
BOOL CWInfFile::GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);

    if (key)
    {
        return key->GetStringArrayValue(saStrings);
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      strValue        [out]  string value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetStringValue(strValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pdwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetIntValue(pdwValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pqwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetQwordValue(pqwValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pfValue         [out]  BOOL value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     converts:
//       "True"  / "Yes" / 1 to TRUE
//       "False" / "No"  / 0 to FALSE
//
BOOL CWInfFile::GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetBoolValue(pfValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pszDefault      [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWSTR CWInfFile::GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return pszDefault;
    }

    return key->GetStringValue(pszDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      dwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
DWORD CWInfFile::GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return dwDefault;
    }

    return key->GetIntValue(dwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      qwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
QWORD CWInfFile::GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return qwDefault;
    }

    return key->GetQwordValue(qwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      fDefault        [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return fDefault;
    }

    return key->GetBoolValue(fDefault);
}


// ---------------------------------------------------------------------------
// Functions for writing
// ---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddSection
//
//  Purpose:    Adds the given section to the current file
//
//
//  Arguments:
//      pszSectionName  [in]   Section to add
//
//  Returns:    Pointer to section added, NULL in case of error
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets the current write-context to the section added
//
PCWInfSection CWInfFile::AddSection(IN PCWSTR pszSectionName)
{
    WifLinePtrListIter tpos, section_pos, line_pos;
    CWInfSection *current_section;

    if ((current_section = CurrentWriteSection()) != NULL)
        GotoEndOfSection(current_section);

    CWInfSection *section = new CWInfSection(pszSectionName, this);
    if (m_plSections->empty())
    {
        m_plSections->push_back(section);
        section_pos = GetIterAtBack(m_plSections);

        line_pos = m_plLines->end();
    }
    else
    {
        section_pos = m_WriteContext.posSection;
        section_pos++;
        section_pos = m_plSections->insert(section_pos, section);
    }

    if (line_pos == m_plLines->end())
    {
        line_pos = AddAtEndOfPtrList(*m_plLines, section);
    }
    else
    {
        line_pos = m_WriteContext.posLine;
        line_pos++;
        line_pos = m_plLines->insert(line_pos, section);
        //        line_pos = AddAtEndOfPtrList(*m_plLines, section);
    }

    m_WriteContext.posSection = section_pos;
    m_WriteContext.posLine    = line_pos;

    section->m_posLine    = line_pos;
    section->m_posSection = section_pos;

    return section;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddSectionIfNotPresent
//
//  Purpose:    Adds the given section to the current file if it is not
//              present. if present, returns pointer to the section
//
//
//  Arguments:
//      pszSectionName  [in]   Section to add/find
//
//  Returns:    Pointer to section added/found, NULL in case of error
//
//  Author:     kumarp    kumarp    11-September-97 (06:09:06 pm)
//
//  Notes:
//      Sets the current write-context to the section added
//
PCWInfSection CWInfFile::AddSectionIfNotPresent(IN PCWSTR szSectionName)
{
    CWInfSection* pwis;

    pwis = FindSection(szSectionName);
    if (!pwis)
    {
        pwis = AddSection(szSectionName);
    }

    return pwis;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GotoEndOfSection
//
//  Purpose:    Sets write context to the end of a given section
//              (so that more keys can be added to the end)
//
//
//  Arguments:
//      pwisSection  [in]   the given Section
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets the current write-context to the end of pwisSection
//
void CWInfFile::GotoEndOfSection(PCWInfSection pwisSection)
{
    // line corresponding to the end of current section is the line
    // prior to the next section
    WifLinePtrListIter posEndOfSection, posNextSection;

    posNextSection = pwisSection->m_posSection;
    posNextSection++;

    if (posNextSection == m_plSections->end())
    {
        posEndOfSection = GetIterAtBack(m_plLines);
    }
    else
    {
        PCWInfSection pwisNextSection;

        pwisNextSection = (PCWInfSection) *posNextSection;
        posEndOfSection = pwisNextSection->m_posLine;
        --posEndOfSection;
    }

    m_WriteContext.posSection = pwisSection->m_posSection;
    m_WriteContext.posLine    = posEndOfSection;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GotoEnd
//
//  Purpose:    Sets write context to the end of the file
//
//
//  Arguments:
//      pwisSection  [in]   the given Section
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::GotoEnd()
{
    m_WriteContext.posSection = GetIterAtBack(m_plSections);
    m_WriteContext.posLine    = GetIterAtBack(m_plLines);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszValue        [in]   value to assign
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN PCWSTR pszValue)
{
    AddKey(pszKeyName)->SetValue(pszValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//
//  Returns:    pointer to the key just added, NULL in case of error
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      No value is assigned
//
PCWInfKey CWInfFile::AddKey(IN PCWSTR pszKeyName)
{
    CWInfKey *key;
    key = new CWInfKey(pszKeyName);
    AddLine(key);
    return key;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN DWORD dwValue)
{
    AddKey(pszKeyName)->SetValue(dwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddQwordKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      qwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue)
{
    AddKey(pszKeyName)->SetQwordValue(qwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddHexKey
//
//  Purpose:    Adds a key in the current section, stores value in hex.
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddHexKey(IN PCWSTR pszKeyName, IN DWORD dwValue)
{
    AddKey(pszKeyName)->SetHexValue(dwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddBoolKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      fValue          [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     TRUE  is stored as "Yes"
//     FALSE is stored as "No"
//
void CWInfFile::AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value)
{
    AddKey(pszKeyName)->SetBoolValue(Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKeyV
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszFormat       [in]   format string (printf style)
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...)
{
    va_list arglist;

    va_start (arglist, Format);
    AddKey(pszKeyName)->SetValues(Format, arglist);
    va_end(arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszFormat       [in]   format string (printf style)
//      arglist         [in]   argument list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN PCWSTR Format, IN va_list arglist)
{
    AddKey(pszKeyName)->SetValues(Format, arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      slValues        [in]   values in the form of a string list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     The string-list is converted to a comma-delimited list before
//     the value is assigned to the key
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues)
{
    AddKey(pszKeyName)->SetValue(slValues);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddComment
//
//  Purpose:    Adds a comment in the current section
//
//
//  Arguments:
//      pszComment      [in]   text of the comment
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     A "; " is prefixed to pszComment before it is inserted into the section.
//
void CWInfFile::AddComment(IN PCWSTR pszComment)
{
    CWInfComment *Comment;
    Comment = new CWInfComment(pszComment);
    AddLine(Comment);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddRawLine
//
//  Purpose:    Adds a raw line in the current section
//
//
//  Arguments:
//      szText      [in]   text to add
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
void CWInfFile::AddRawLine(IN PCWSTR szText)
{
    CWInfRaw *pwir;
    pwir = new CWInfRaw(szText);
    AddLine(pwir);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddRawLines
//
//  Purpose:    Adds a raw line in the current section
//
//
//  Arguments:
//      szText      [in]   text to add
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
void CWInfFile::AddRawLines(IN PCWSTR* pszLines, IN DWORD cLines)
{
    AssertValidReadPtr(pszLines);
    AssertSz(cLines, "CWInfFile::AddRawLines: dont add 0 lines");

    CWInfRaw *pwir;
    for (DWORD i=0; i<cLines; i++)
    {
        AssertSz(pszLines[i], "CWInfRaw::AddRawLines: One of the lines is bad");

        pwir = new CWInfRaw(pszLines[i]);
        AddLine(pwir);
    }
}

// ----------------------------------------------------------------------
// CWInfFile protected functions
// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::CurrentWriteSection
//
//  Purpose:    Get a pointer to the section selected for writing
//
//
//  Arguments:  none
//
//  Returns:    pointer to the section if exists, NULL if file has no sections
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfSection CWInfFile::CurrentWriteSection() const
{
    WifLinePtrListIter pos = m_WriteContext.posSection;

    if (pos == m_plSections->end())
    {
        return NULL;
    }
    else
    {
        return (PCWInfSection) *pos;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::CurrentReadSection
//
//  Purpose:    Get a pointer to the section selected for reading
//
//
//  Arguments:  none
//
//  Returns:    pointer to the section if exists, NULL if file has no sections
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfSection CWInfFile::CurrentReadSection() const
{
    PCWInfSection pwisCurrent;

    WifLinePtrListIter pos = m_ReadContext.posSection;

    if (pos == m_plSections->end())
    {
        return NULL;
    }
    else
    {
        pwisCurrent = (PCWInfSection) *pos;
        return pwisCurrent;
    }
}


//+---------------------------------------------------------------------------
//
// Function:  CWInfFile::RemoveSection
//
// Purpose:   Remove a section and its contents
//
// Arguments:
//    szSectionName [in]  name of Section to remove
//
// Returns:   None
//
// Author:    kumarp 09-December-98
//
// Notes:
//
void CWInfFile::RemoveSection(IN PCWSTR szSectionName)
{
    CWInfSection* pwis;

    if (pwis = FindSection(szSectionName))
    {
        m_plSections->erase(pwis->m_posSection);
        WifLinePtrListIter pos = pwis->m_posLine;
        WifLinePtrListIter posTemp;

        do
        {
            posTemp = pos;
            pos++;
            m_plLines->erase(posTemp);
        }
        while (pos != m_plLines->end() &&
               ((CWInfLine*) *pos)->Type() != INF_SECTION);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  CWInfFile::RemoveSections
//
// Purpose:   Remove the specified sections
//
// Arguments:
//    slSections [in]  list of sections to remove
//
// Returns:   None
//
// Author:    kumarp 09-December-98
//
// Notes:
//
void CWInfFile::RemoveSections(IN TStringList& slSections)
{
    PCWSTR szSectionName;
    TStringListIter pos;

    pos = slSections.begin();
    while (pos != slSections.end())
    {
        szSectionName = (*pos)->c_str();
        pos++;
        RemoveSection(szSectionName);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddLine
//
//  Purpose:    Add a CWInfLine in the current section, adjust write context.
//
//  Arguments:
//      ilLine      [in]   pointer to a CWInfLine
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::AddLine(IN const PCWInfLine ilLine)
{
    CWInfSection *section = CurrentWriteSection();
    if (!section)
        return FALSE;

    WifLinePtrListIter pos;
    pos = m_WriteContext.posLine;
    pos++;
    pos = m_plLines->insert(pos, ilLine);
    m_WriteContext.posLine = pos;

    return TRUE;
}

// ======================================================================
// Class CWInfSection
// ======================================================================

// ----------------------------------------------------------------------
// CWInfSection public functions
// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetText
//
//  Purpose:    Get text representation of this section.
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::GetText(OUT tstring &text) const
{
    text = L"[" + m_Name + L"]";
}

// used by SysPrep
void CWInfSection::GetTextEx(OUT tstring &text) const
{
    text = L"[" + m_Name + L"]";
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::FindKey
//
//  Purpose:    Find a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      wsmMode         [in]   Search mode
//                             (search from beginning-of-section / current-position)
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfKey CWInfSection::FindKey(IN PCWSTR pszKeyName,
                                IN WInfSearchMode wsmMode)
{
    m_Parent->SetCurrentReadSection(this);
    return m_Parent->FindKey(pszKeyName, wsmMode);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::FirstKey
//
//  Purpose:    Return the first  key in this section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfSection::FirstKey()
{
    m_Parent->SetCurrentReadSection(this);
    return m_Parent->FirstKey();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::NextKey
//
//  Purpose:    Return the next key in this section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfSection::NextKey()
{
    m_Parent->SetCurrentReadSection(this);
    return m_Parent->NextKey();
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringArrayValue
//
//  Purpose:    Return the value of the given key as a string-Array
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      saStrings       [out]  Array value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12-November-97
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringArray
//     otherwise returns a TStringArray with a single element
//
BOOL CWInfSection::GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);

    if (key)
    {
        return key->GetStringArrayValue(saStrings);
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringListValue
//
//  Purpose:    Return the value of the given key as a string-list
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pslList         [out]  List value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringList
//     otherwise returns a TStringList with a single element
//
BOOL CWInfSection::GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &pslList)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetStringListValue(pslList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      strValue        [out]  string value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetStringValue(strValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetIntValue
//
//  Purpose:    Return the value of the given key as an integer
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pdwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetIntValue(pdwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pqwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetQwordValue(pqwValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pfValue         [out]  BOOL value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     converts:
//       "True"  / "Yes" / 1 to TRUE
//       "False" / "No"  / 0 to FALSE
//
BOOL CWInfSection::GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetBoolValue(pfValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pszDefault      [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWSTR CWInfSection::GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
    {
        return pszDefault;
    }

    return key->GetStringValue(pszDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      dwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
DWORD CWInfSection::GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
    {
        return dwDefault;
    }

    return key->GetIntValue(dwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      qwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
QWORD CWInfSection::GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return qwDefault;
    }

    return key->GetQwordValue(qwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      fDefault        [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
    {
        return fDefault;
    }

    return key->GetBoolValue(fDefault);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GotoEnd
//
//  Purpose:    Sets write context to the end of this section
//              (so that more keys can be added to the end)
//
//  Arguments:  none
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets this write-context to the end of pwisSection
//
void CWInfSection::GotoEnd()
{
    m_Parent->GotoEndOfSection(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//
//  Returns:    pointer to the key just added, NULL in case of error
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      No value is assigned
//
PCWInfKey CWInfSection::AddKey(IN PCWSTR pszKeyName)
{
    GotoEnd();
    return m_Parent->AddKey(pszKeyName);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszValue        [in]   value to assign
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddKey(IN PCWSTR pszKeyName, IN PCWSTR pszValue)
{
    GotoEnd();
    m_Parent->AddKey(pszKeyName, pszValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddKey(IN PCWSTR pszKeyName, IN DWORD Value)
{
    GotoEnd();
    m_Parent->AddKey(pszKeyName, Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddQwordKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      qwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue)
{
    AddKey(pszKeyName)->SetQwordValue(qwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddHexKey
//
//  Purpose:    Adds a key in this section, stores value in hex.
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddHexKey(IN PCWSTR pszKeyName, IN DWORD Value)
{
    GotoEnd();
    m_Parent->AddHexKey(pszKeyName, Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      slValues        [in]   values in the form of a string list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     The string-list is converted to a comma-delimited list before
//     the value is assigned to the key
//
void CWInfSection::AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues)
{
    GotoEnd();
    m_Parent->AddKey(pszKeyName, slValues);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddBoolKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      fValue          [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     TRUE  is stored as "Yes"
//     FALSE is stored as "No"
//
void CWInfSection::AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value)
{
    GotoEnd();
    m_Parent->AddBoolKey(pszKeyName, Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKeyV
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszFormat       [in]   format string (printf style)
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...)
{
    GotoEnd();
    va_list arglist;

    va_start (arglist, Format);
    m_Parent->AddKey(pszKeyName, Format, arglist);
    va_end(arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddComment
//
//  Purpose:    Adds a comment in this section
//
//
//  Arguments:
//      pszComment      [in]   text of the comment
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     A "; " is prefixed to pszComment before it is inserted into the section.
//
void CWInfSection::AddComment(IN PCWSTR pszComment)
{
    GotoEnd();
    m_Parent->AddComment(pszComment);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddComment
//
//  Purpose:    Adds a comment in this section
//
//
//  Arguments:
//      szLine  [in]   raw line to be inserted
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
void CWInfSection::AddRawLine(IN PCWSTR szLine)
{
    GotoEnd();
    m_Parent->AddRawLine(szLine);
}

// ----------------------------------------------------------------------
// CWInfSection protected functions
// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::CWInfSection
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CWInfSection::CWInfSection(IN PCWSTR SectionName, IN PCWInfFile parent)
    : CWInfLine(INF_SECTION)
{
    m_Name = SectionName;
    m_posLine = 0;
    m_Parent = parent;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::~CWInfSection
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfSection::~CWInfSection()
{
}


// ======================================================================
// Class CWInfKey
// ======================================================================

// ----------------------------------------------------------------------
// CWInfKey public functions
// ----------------------------------------------------------------------

WCHAR *CWInfKey::m_Buffer;

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::CWInfFile
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CWInfKey::CWInfKey(IN PCWSTR pszKeyName)
    : CWInfLine(INF_KEY)
{
    m_Value = c_szEmpty;
    m_Name = pszKeyName;
    m_fIsAListAndAlreadyProcessed = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::~CWInfFile
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfKey::~CWInfKey()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::Init
//
//  Purpose:    allocate internal shared buffer
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
void CWInfKey::Init()
{
    if (NULL == m_Buffer)
    {
        m_Buffer = new WCHAR[MAX_INF_STRING_LENGTH+1];
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::UnInit
//
//  Purpose:    deallocate internal shared buffer
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
void CWInfKey::UnInit()
{
    if (NULL != m_Buffer)
    {
        delete [] m_Buffer;
        m_Buffer = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetText
//
//  Purpose:    Get text representation in the format key=value.
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::GetText(tstring &text) const
{
    // Text mode setup does not like certain special characters in the
    // value of a key. if the value has one of these characters then
    // we need to enclose the entire value in quotes
    //
    static const WCHAR szSpecialChars[] = L" %=][";
    tstring strTemp = m_Value; 
    tstring strTempName = m_Name;

    if (!m_fIsAListAndAlreadyProcessed)
    {
        if (m_Value.empty() ||
            (L'\"' != *(m_Value.c_str()) &&
             wcscspn(m_Value.c_str(), szSpecialChars) < m_Value.size()))
        {
            strTemp = L"\"" + m_Value + L"\"";
        }
    }

    if (m_Name.empty() ||
        (L'\"' != *(m_Name.c_str()) &&
         wcscspn(m_Name.c_str(), szSpecialChars) < m_Name.size()))
    {
        strTempName = L"\"" + m_Name + L"\"";
    }

    text = strTempName + L"=" + strTemp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetTextEx
//
//  Purpose:    Get text representation in the format key=value for multi-sz value
//              Otherwiese, get text representation in the format key="value"
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     frankli    4 May 2000
//
//  Notes: value will be enclosed in quotes except for multi-sz value 
//
void CWInfKey::GetTextEx(tstring &text) const
{
    // we need to enclose the entire value in quotes except for multi-sz value.
    // For example,
    // tcpip adapter specific
    // NameServer registry value is of type REG_SZ and it is a string of
    // comma-delimited dns server name. We need to enclosed it in quotes,
    // otherwise, it will be interpreted as multi-sz value
    
    // Text mode setup does not like certain special characters in the
    // value of a key. if the value has one of these characters then
    // we need to enclose the entire value in quotes
    //
    static const WCHAR szSpecialChars[] = L" %=][";
    tstring strTemp = m_Value;
    tstring strTempName = m_Name;

    if (!m_fIsAListAndAlreadyProcessed)
    {   // we don't do this for multi-sz value
        strTemp = L"\"" + m_Value + L"\"";
    }

    // leave the processing of the key as in CWInfKey::GetText
    if (m_Name.empty() ||
        (L'\"' != *(m_Name.c_str()) &&
         wcscspn(m_Name.c_str(), szSpecialChars) < m_Name.size()))
    {
        strTempName = L"\"" + m_Name + L"\"";
    }

    text = strTempName + L"=" + strTemp;
}


// --------- Read values --------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringArrayValue
//
//  Purpose:    Return the value of the given key as a string-Array
//
//
//  Arguments:
//      saStrings         [out]  Array value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringArray
//     otherwise returns a TStringArray with a single element
//
BOOL CWInfKey::GetStringArrayValue(TStringArray &saStrings) const
{
    ConvertCommaDelimitedListToStringArray(m_Value, saStrings);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringListValue
//
//  Purpose:    Return the value of the given key as a string-list
//
//
//  Arguments:
//      pslList         [out]  List value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringList
//     otherwise returns a TStringList with a single element
//
BOOL CWInfKey::GetStringListValue(TStringList &pslList) const
{
    ConvertCommaDelimitedListToStringList(m_Value, pslList);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      strValue        [out]  string value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetStringValue(OUT tstring& strValue) const
{
    strValue = m_Value;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetIntValue
//
//  Purpose:    Return the value of the given key as an in
//
//
//  Arguments:
//      pdwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetIntValue(OUT DWORD *pdwValue) const
{
    if ((swscanf(m_Value.c_str(), L"0x%x", pdwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%d", pdwValue) == 1))
    {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pqwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetQwordValue(OUT QWORD *pqwValue) const
{
    if ((swscanf(m_Value.c_str(), L"0x%I64x", pqwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%I64d", pqwValue) == 1))
    {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pfValue         [out]  BOOL value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     converts:
//       "True"  / "Yes" / 1 to TRUE
//       "False" / "No"  / 0 to FALSE
//
BOOL CWInfKey::GetBoolValue(OUT BOOL *pfValue) const
{
    return IsBoolString(m_Value.c_str(), pfValue);
}


//+---------------------------------------------------------------------------
//these functions return the default value if value not found
//or if it is in a wrong format
//+---------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszDefault      [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWSTR CWInfKey::GetStringValue(IN PCWSTR pszDefault) const
{
    if (m_Value.empty())
    {
        return pszDefault;
    }
    else
    {
        return m_Value.c_str();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      dwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
DWORD CWInfKey::GetIntValue(IN DWORD dwDefault) const
{
    DWORD dwValue;
    if ((swscanf(m_Value.c_str(), L"0x%lx", &dwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%ld", &dwValue) == 1))
    {
        return dwValue;
    }
    else
    {
        return dwDefault;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetQwordValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      qwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
QWORD CWInfKey::GetQwordValue(IN QWORD qwDefault) const
{
    QWORD qwValue;
    if ((swscanf(m_Value.c_str(), L"0x%I64x", &qwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%I64x", &qwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%I64d", &qwValue) == 1))
    {
        return qwValue;
    }
    else
    {
        return qwDefault;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      fDefault        [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetBoolValue(IN BOOL bDefault) const
{
    BOOL bValue;

    if (IsBoolString(m_Value.c_str(), &bValue))
    {
        return bValue;
    }
    else
    {
        return bDefault;
    }
}

// --------- Write values --------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValues
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      pszFormat       [in]   format string (printf style)
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValues(IN PCWSTR Format, IN ...)
{
    va_list arglist;
    va_start (arglist, Format);
    SetValues(Format, arglist);
    va_end(arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      pszFormat       [in]   format string (printf style)
//      arglist         [in]   argument list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValues(IN PCWSTR Format, va_list arglist)
{
    // we need m_Buffer because tstring does not provide
    // tstring::Format( PCWSTR lpszFormat, va_list );

    _vsnwprintf( m_Buffer, MAX_INF_STRING_LENGTH+1, Format, arglist );

    // in case the formatted string length is MAX_INF_STRING_LENGTH+1 characters or more,
    // not including NULL, _vsnwprintf will not append a NULL. So, we do it.
    
    m_Buffer[MAX_INF_STRING_LENGTH] = L'\0';

    m_Value = m_Buffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      pszValue        [in]   value to assign
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValue(IN PCWSTR Value)
{
    m_Value = Value;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValue(IN DWORD Value)
{
    FormatTString(m_Value, L"%d", Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetQwordValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      qwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetQwordValue(IN QWORD Value)
{
    FormatTString(m_Value, L"0x%I64x", Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetHexValue
//
//  Purpose:    Sets the value of this key to the value passed, stores value in hex.
//
//
//  Arguments:
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetHexValue(IN DWORD Value)
{
    FormatTString(m_Value, L"0x%0lx", Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      slValues        [in]   values in the form of a string list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     The string-list is converted to a comma-delimited list before
//     the value is assigned to the key
//
void CWInfKey::SetValue(IN const TStringList &slValues)
{
    tstring strFlatList;
    ConvertStringListToCommaList(slValues, strFlatList);
    SetValue(strFlatList.c_str());
    m_fIsAListAndAlreadyProcessed = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetBoolValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      fValue          [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     TRUE  is stored as "Yes"
//     FALSE is stored as "No"
//
void CWInfKey::SetBoolValue(IN BOOL Value)
{
    m_Value = Value ? c_szYes : c_szNo;
}

// ======================================================================
// Class CWInfComment
// ======================================================================

// ----------------------------------------------------------------------
// CWInfComment public functions
// ----------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfComment::CWInfComment
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CWInfComment::CWInfComment(IN PCWSTR pszComment)
    : CWInfLine(INF_COMMENT)
{
    m_strCommentText = tstring(c_szCommentPrefix) + pszComment;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfComment::~CWInfComment
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfComment::~CWInfComment()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfComment::GetText
//
//  Purpose:    Get text representation of this comment
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfComment::GetText(tstring &text) const
{
    text = m_strCommentText;
}

// used by SysPrep
void CWInfComment::GetTextEx(tstring &text) const
{
    text = m_strCommentText;
}

// ======================================================================
// Class CWInfRaw
// ======================================================================

// ----------------------------------------------------------------------
// CWInfRaw public functions
// ----------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfRaw::CWInfRaw
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     danielwe    11 Jun 1997
//
//  Notes:
//
CWInfRaw::CWInfRaw(IN PCWSTR szText)
    : CWInfLine(INF_RAW)
{
    m_strText = szText;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfRaw::~CWInfRaw
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     danielwe    11 Jun 1997
//
//
CWInfRaw::~CWInfRaw()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfRaw::GetText
//
//  Purpose:    Get text representation of this raw string
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
//  Notes:
//
void CWInfRaw::GetText(tstring &text) const
{
    text = m_strText;
}

// used by SysPrep
void CWInfRaw::GetTextEx(tstring &text) const
{
    text = m_strText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\kkstl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K S T L . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkstl.h"

void FormatTString(IN OUT tstring& str, IN PCWSTR pszFormat, va_list arglist)
{
    const c_dwMaxFormatBufferLen = 511;
    //since there is no way to determine the size of the string
    //after applying the format, we must assume some arbitrary size
    static WCHAR pszTemp[c_dwMaxFormatBufferLen+1];
    _vsnwprintf(pszTemp, c_dwMaxFormatBufferLen, pszFormat, arglist);

    str = pszTemp;
}

void FormatTString(IN OUT tstring& str, IN PCWSTR pszFormat, ...)
{
    va_list arglist;

    va_start (arglist, pszFormat);
    FormatTString(str, pszFormat, arglist);
    va_end(arglist);
}


BOOL FIsInStringList(IN const TStringList& sl, IN tstring& str,
                     OUT TStringListIter* pos)
{
    return FIsInStringList(sl, str.c_str(), pos);
}

BOOL FIsInStringList(IN const TStringList& sl, IN PCWSTR psz,
                     OUT TStringListIter* pos)
{
    TStringListIter i=sl.begin();
    while (i != sl.end())
    {
        if (!_wcsicmp((*i)->c_str(), psz))
        {
            if (pos != NULL)
                *pos = i;
            return TRUE;
        }
        ++i;
    }

    return FALSE;
}

tstring* GetNthItem(IN TStringList& sl, IN DWORD dwIndex)
{
    TStringListIter sli=sl.begin();
    DWORD i;
    for (i=0; i<dwIndex; ++i, ++sli)
        ;
    return *sli;
}


void EraseAndDeleteAll(IN TPtrList& ppl)
{
    EraseAndDeleteAll(&ppl);
}

void EraseAndDeleteAll(IN TPtrList* ppl)
{
    TPtrListIter i=ppl->begin();
    while (i != ppl->end())
    {
        delete *i++;
    }

    ppl->erase(ppl->begin(), ppl->end());
}


void EraseAndDeleteAll(IN TStringList& ppl)
{
    EraseAndDeleteAll(&ppl);
}

void EraseAndDeleteAll(IN TStringList* ppl)
{
    TStringListIter i=ppl->begin();
    while (i != ppl->end())
    {
        delete *i++;
    }

    ppl->erase(ppl->begin(), ppl->end());
}


void GetDataFromByteArray(IN const TByteArray& ba, OUT BYTE*& pb)
{
    DWORD dwSize = ba.size();

    if (dwSize == 0)
    {
        pb = NULL;
        return;
    }

    if (pb == NULL)
    {
        pb = new BYTE[dwSize];
    }

    if(pb) {
        for (DWORD i=0; i < dwSize; i++)
        {
            pb[i] = ba[i];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\kkreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K R E G . C P P
//
//  Contents:   Windows NT Registry Access Class
//
//  Notes:
//
//  Author:     kumarp    14 April 97 (09:22:00 pm)
//
//  Notes:
//    kumarp   1/16/97   most of the code in this file was originally in
//                       net\ui\rhino\common\classes\common.h
//                       extracted only that portion related to CRegKey & related classes
//    kumarp   3/27/97   the original code used MFC. converted the entire code
//                       to make it use STL
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkreg.h"
#include "kkstl.h"
#include "kkutils.h"
#include "nceh.h"
#include "ncreg.h"

HRESULT HrGetRegErrorForTrace(LONG err)
{
    HRESULT hr = ((err == ERROR_FILE_NOT_FOUND) ||
                  (err == ERROR_NO_MORE_ITEMS))
        ? S_OK : HRESULT_FROM_WIN32(err);

    return hr;
}

#define TraceRegFunctionError(e)  TraceFunctionError(HrGetRegErrorForTrace(e))

//+---------------------------------------------------------------------------
//
//  Member:     CORegKey::CORegKey
//
//  Purpose:    constructor for an existing key
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CORegKey::CORegKey (HKEY hKeyBase,
                    PCWSTR pchSubKey,
                    REGSAM regSam,
                    PCWSTR pchServerName )
    : m_hKey( NULL ),
      m_dwDisposition( 0 ),
      m_fInherit(FALSE)
{
    DefineFunctionName("CORegKey::CORegKey(HKEY hKeyBase, PCWSTR pchSubKey, )");

    HKEY hkBase = NULL ;
    LONG err = 0 ;

    if ( pchServerName )
    {
        // This is a remote connection.
        if ( err = ::RegConnectRegistry( (PWSTR) pchServerName,
                                         hKeyBase, & hkBase ) )
        {
            TraceLastWin32Error("RegConnectRegistry failed");
            hkBase = NULL ;
        }
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if ( err == 0 )
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
            /*
            if (err)
            {
                TraceLastWin32Error("RegOpenKeyEx failed");
            }
            */
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
            m_fInherit = TRUE;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err )
    {
        // ReportError( err ) ;
        m_hKey = NULL ;
    }

    TraceRegFunctionError(err);
}

//+---------------------------------------------------------------------------
//
//  Member:     CORegKey::CORegKey
//
//  Purpose:    constructor for creating a new key
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CORegKey::CORegKey (PCWSTR pchSubKey,
                    HKEY hKeyBase,
                    DWORD dwOptions,
                    REGSAM regSam,
                    LPSECURITY_ATTRIBUTES pSecAttr,
                    PCWSTR pchServerName)
    : m_hKey( NULL ),
      m_dwDisposition( 0 ),
      m_fInherit(FALSE)
{
    DefineFunctionName("CORegKey::CORegKey(PCWSTR pchSubKey, HKEY hKeyBase, )");

    HKEY hkBase = NULL ;
    LONG err = 0;

    if ( pchServerName )
    {
        // This is a remote connection.
        if ( err = ::RegConnectRegistry( (PWSTR) pchServerName,
                                         hKeyBase, & hkBase ) )
        {
            hkBase = NULL ;
            TraceLastWin32Error("RegConnectRegistry failed");
        }

        hkBase = NULL ;

    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == 0)
    {

        PCWSTR szEmpty = L"" ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey,
                                0, (PWSTR) szEmpty,
                                dwOptions, regSam,  pSecAttr,
                                & m_hKey,
                                & m_dwDisposition ) ;

    }
    if ( err )
    {
        TraceLastWin32Error("RegCreateKeyEx failed");
        m_hKey = NULL ;
    }

    TraceRegFunctionError(err);
}


CORegKey::~CORegKey ()
{
    if ( m_hKey && !m_fInherit)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}


    //  Prepare to read a value by finding the value's size.
LONG CORegKey::PrepareValue (PCWSTR pchValueName,
                             DWORD * pdwType,
                             DWORD * pcbSize,
                             BYTE ** ppbData )
{
    DefineFunctionName("CORegKey::PrepareValue");

    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueExW( *this,
                      (PWSTR) pchValueName,
                      0, pdwType,
                      chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 )
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA )
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueExW( *this,
                         (PWSTR) pchValueName,
                     0, pdwType,
                     *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )
    {
        delete [] *ppbData ;
    }

    TraceRegFunctionError(err);

    return err ;
}

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.

LONG CORegKey::QueryValue ( PCWSTR pchValueName, tstring& strResult )
{
    DefineFunctionName("CORegKey::QueryValue(tstring& strResult)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    //  strResult.remove();
    strResult = c_szEmpty;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if (( dwType != REG_SZ ) && (dwType != REG_EXPAND_SZ))
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        NC_TRY
        {
            strResult = (PWSTR) pabData ;
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, TStringList& strList )
{
    DefineFunctionName("CORegKey::QueryValue(TStringList& strList)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    PWSTR pbTemp, pbTempLimit ;

    EraseAndDeleteAll(&strList);
    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (PWSTR) pabData ;
    //kumarp: changed the following because it gives wrong results for UNICODE
    //        pbTempLimit = & pbTemp[cbData] ;
        pbTempLimit = & pbTemp[(cbData / sizeof(WCHAR))-1] ;

        //  Catch exceptions trying to build the list
        NC_TRY
        {

            for ( ; pbTemp < pbTempLimit ; )
            {
                // Raid 237766
                if (pbTemp && wcslen(pbTemp))
                {
                    strList.insert(strList.end(), new tstring(pbTemp) ) ;
                }
                pbTemp += wcslen( pbTemp ) + 1 ;
            }
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, DWORD& dwResult )
{
    DefineFunctionName("CORegKey::QueryValue(DWORD& dwResult)");

    LONG err = 0;

    DWORD dwData;

    if (m_hKey && (S_OK == HrRegQueryDword(m_hKey, pchValueName, &dwData)))
    {
        dwResult = dwData;
    }
    else
    {
        err = ERROR_FILE_NOT_FOUND;
        dwResult = -1;
    }

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, TByteArray& abResult )
{
    DefineFunctionName("CORegKey::QueryValue(TByteArray& abResult)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        NC_TRY
        {
            abResult.reserve( cbData ) ;
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }


        if ( err )
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ )
        {
            //            abResult[i] = pabData[i] ;
            abResult.push_back(pabData[i]) ;
        }
    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, void* pvResult, DWORD cbSize )
{
    DefineFunctionName("CORegKey::QueryValue(void* pvResult, DWORD cbSize)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}


//  Overloaded value setting members.
LONG CORegKey::SetValue ( PCWSTR pchValueName, tstring& strResult )
{
    DefineFunctionName("CORegKey::SetValue(tstring& strResult)");

    LONG err = 0;

    err = ::RegSetValueEx( *this,
                           pchValueName,
                           0,
                           REG_SZ,
                           (const BYTE *) strResult.c_str(),
                           CbOfSzAndTerm (strResult.c_str())) ;

    TraceRegFunctionError(err);

    return err ;
}

//  Overloaded value setting members.
LONG CORegKey::SetValue ( PCWSTR pchValueName, tstring& strResult ,
                           BOOL fRegExpand)
{
    LONG err = 0;
    DWORD dwType = fRegExpand ? REG_EXPAND_SZ : REG_SZ;

    err = ::RegSetValueEx( *this,
                    pchValueName,
                    0,
                    dwType,
                    (const BYTE *) strResult.c_str(),
                    CbOfSzAndTerm (strResult.c_str()));

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, TStringList& strList )
{
    DefineFunctionName("CORegKey::SetValue(TStringList& strList)");


    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_MULTI_SZ,
                       pbData,
                       cbSize ) ;
    }

    delete pbData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, DWORD& dwResult )
{
    DefineFunctionName("CORegKey::SetValue(DWORD& dwResult)");

    LONG err = 0;

    err = ::RegSetValueEx( *this,
                    pchValueName,
                    0,
                    REG_DWORD,
                    (const BYTE *) & dwResult,
                    sizeof dwResult ) ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, TByteArray& abResult )
{
    DefineFunctionName("CORegKey::SetValue(TByteArray& abResult)");


    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_BINARY,
                       pbData,
                       cbSize ) ;
    }

    delete pbData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, void* pvResult, DWORD cbSize )
{
    DefineFunctionName("CORegKey::SetValue(void* pvResult, DWORD cbSize)");


    LONG err = 0;

    err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_BINARY,
                       (const BYTE *)pvResult,
                       cbSize ) ;

    TraceRegFunctionError(err);

    return err ;
}


LONG CORegKey::DeleteValue ( PCWSTR pchValueName )
{
    DefineFunctionName("CORegKey::DeleteValue");

    LONG err = ::RegDeleteValue(m_hKey, pchValueName);

    TraceRegFunctionError(err);

    return err;
}


LONG CORegKey::FlattenValue (TStringList & strList,
                             DWORD * pcbSize,
                             BYTE ** ppbData )
{
    Assert(pcbSize);
    Assert(ppbData);
    DefineFunctionName("CORegKey::FlattenValue(TStringList)");


    LONG err = ERROR_NOT_ENOUGH_MEMORY ;

    TStringListIter pos ;
    tstring* pstr ;
    int cbTotal = 0 ;

    *ppbData = NULL;

    //  Walk the list accumulating sizes
    for ( pos = strList.begin() ;
          pos != strList.end() && (pstr = (tstring *) *pos++); )
    {
        cbTotal += CbOfSzAndTerm (pstr->c_str());
    }

    //  Allocate and fill a temporary buffer
    if (*pcbSize = cbTotal)
    {
        BYTE * pbData = new BYTE[ *pcbSize ] ;
        if(pbData) 
        {
            //  Populate the buffer with the strings.
            for ( pos = strList.begin() ;
                pos != strList.end() && (pstr = (tstring *) *pos++); )
            {
                int cb = CbOfSzAndTerm (pstr->c_str());
                ::memcpy( pbData, pstr->c_str(), cb ) ;
                pbData += cb ;
            }
            err = NOERROR;
            *ppbData = pbData;
        }
    }

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::FlattenValue (TByteArray & abData,
                             DWORD * pcbSize,
                             BYTE ** ppbData )
{
    Assert(pcbSize);
    Assert(ppbData);

    DefineFunctionName("CORegKey::FlattenValue(TByteArray)");

    LONG err = ERROR_NOT_ENOUGH_MEMORY ;

    DWORD i ;

    *ppbData = NULL;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = abData.size())
    {
        *ppbData = new BYTE[*pcbSize] ;

        if(*ppbData) 
        {
            for ( i = 0 ; i < *pcbSize ; i++ )
            {
                (*ppbData)[i] = abData[i] ;
            }
        }

        err = NOERROR;
    }

    TraceRegFunctionError(err);

    return err ;
}


LONG CORegKey::QueryKeyInfo ( CORegKEY_KEY_INFO * pRegKeyInfo )
{
    DefineFunctionName("CORegKey::QueryKeyInfo");

    LONG err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKeyW( *this,
                     pRegKeyInfo->chBuff,
                     & pRegKeyInfo->dwClassNameSize,
                     NULL,
                     & pRegKeyInfo->dwNumSubKeys,
                     & pRegKeyInfo->dwMaxSubKey,
                     & pRegKeyInfo->dwMaxClass,
                     & pRegKeyInfo->dwMaxValues,
                     & pRegKeyInfo->dwMaxValueName,
                     & pRegKeyInfo->dwMaxValueData,
                     & pRegKeyInfo->dwSecDesc,
                     & pRegKeyInfo->ftKey ) ;

    TraceRegFunctionError(err);

    return err ;
}

CORegKeyIter::CORegKeyIter ( CORegKey & regKey )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    DefineFunctionName("CORegKeyIter::CORegKeyIter");

    LONG err = 0 ;

    CORegKey::CORegKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        NC_TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new WCHAR [ m_cb_buffer ] ;
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }

    TraceRegFunctionError(err);
}

CORegKeyIter::~CORegKeyIter ()
{
    delete [] m_p_buffer ;
}


LONG CORegKeyIter::Next ( tstring * pstrName )
{
    DefineFunctionName("CORegKeyIter::Next");

    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter,
                  m_dw_index,
              m_p_buffer,
                  & dwNameSize,
                  NULL,
                  NULL,
                  NULL,
                  & ftDummy ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        NC_TRY
        {
            *pstrName = m_p_buffer ;
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }

    TraceRegFunctionError(err);

    return err ;
}


CORegValueIter::CORegValueIter ( CORegKey & regKey )
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 )
{
    DefineFunctionName("CORegValueIter::CORegValueIter");

    LONG err = 0 ;

    CORegKey::CORegKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        NC_TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
            m_p_buffer = new WCHAR [ m_cb_buffer ] ;
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }

    TraceRegFunctionError(err);
}

CORegValueIter::~CORegValueIter ()
{
    delete [] m_p_buffer ;
}

LONG CORegValueIter::Next ( tstring * pstrName, DWORD * pdwType )
{
    DefineFunctionName("CORegValueIter::Next");

    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue( m_rk_iter,
                  m_dw_index,
                  m_p_buffer,
                  & dwNameLength,
                  NULL,
                  pdwType,
                  NULL,
                  NULL ) ;

    if ( err == 0 )
    {
        m_dw_index++ ;

        NC_TRY
        {
            *pstrName = m_p_buffer ;
        }
        NC_CATCH_BAD_ALLOC
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }

    TraceRegFunctionError(err);
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\kkutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K U T I L S . C P P
//
//  Contents:   Misc. helper functions
//
//  Notes:
//
//  Author:     kumarp   14 Jan 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkutils.h"
#include "ncreg.h"

extern const WCHAR c_szRegKeyServices[];

// ----------------------------------------------------------------------
//
// Function:  AddOnlyOnceToStringList
//
// Purpose:   Add the specified string to the list if it is not present
//            in that list
//
// Arguments:
//    psl       [in]  list of strings
//    pszString [in]  string to add
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void AddOnlyOnceToStringList(IN TStringList* psl, IN PCWSTR pszString)
{
    AssertValidReadPtr(psl);
    AssertValidReadPtr(pszString);

    if (!FIsInStringList(*psl, pszString))
    {
        AddAtEndOfStringList(*psl, pszString);
    }
}

// ----------------------------------------------------------------------
//
// Function:  ConvertDelimitedListToStringList
//
// Purpose:   Convert a delimited list to a TStringList
//
// Arguments:
//    strDelimitedList [in]  delimited list
//    chDelimiter      [in]  delimiter
//    slList           [out] list of string items
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void ConvertDelimitedListToStringList(IN const tstring& strDelimitedList,
                                      IN WCHAR chDelimiter,
                                      OUT TStringList &slList)
{
    PCWSTR pszDelimitedList = strDelimitedList.c_str();
    DWORD i=0, dwStart;

    // should this be EraseAndDeleteAll() ??
    //EraseAll(&slList);
	EraseAndDeleteAll(&slList);
    tstring strTemp;
    DWORD dwNumChars;

    // the two spaces are intentional
    static WCHAR szCharsToSkip[] = L"  \t";
    szCharsToSkip[0] = chDelimiter;

    while (pszDelimitedList[i])
    {
        dwStart = i;
        while (pszDelimitedList[i] &&
               !wcschr(szCharsToSkip, pszDelimitedList[i]))
        {
            ++i;
        }

        // if each item is enclosed in quotes. strip the quotes
        dwNumChars = i - dwStart;
        if (pszDelimitedList[dwStart] == '"')
        {
            dwStart++;
            dwNumChars -= 2;
        }

        strTemp = strDelimitedList.substr(dwStart, dwNumChars);
        slList.insert(slList.end(), new tstring(strTemp));

        // skip spaces and delimiter
        //
        while (pszDelimitedList[i] &&
               wcschr(szCharsToSkip, pszDelimitedList[i]))
        {
            ++i;
        }
    }
}


// ----------------------------------------------------------------------
//
// Function:  ConvertCommaDelimitedListToStringList
//
// Purpose:   Convert a comma delimited list to a TStringList
//
// Arguments:
//    strDelimitedList [in]  comma delimited list
//    slList           [out] list of string items
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void ConvertCommaDelimitedListToStringList(IN const tstring& strDelimitedList, OUT TStringList &slList)
{
    ConvertDelimitedListToStringList(strDelimitedList, (WCHAR) ',', slList);
}

// ----------------------------------------------------------------------
//
// Function:  ConvertSpaceDelimitedListToStringList
//
// Purpose:   Convert a space delimited list to a TStringList
//
// Arguments:
//    strDelimitedList [in]  Space delimited list
//    slList           [out] list of string items
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void ConvertSpaceDelimitedListToStringList(IN const tstring& strDelimitedList,
                                           OUT TStringList &slList)
{
    ConvertDelimitedListToStringList(strDelimitedList, ' ', slList);
}

void ConvertStringListToCommaList(IN const TStringList &slList, OUT tstring &strList)
{
    ConvertStringListToDelimitedList(slList, strList, ',');
}

void ConvertStringListToDelimitedList(IN const TStringList &slList,
                      OUT tstring &strList, IN WCHAR chDelimiter)
{
    TStringListIter pos = slList.begin();
    tstring strTemp;
    WORD i=0;
    static const WCHAR szSpecialChars[] = L" %=";

    while (pos != slList.end())
    {
        strTemp = **pos++;

        //
        //  put quotes around any strings that have chars that setupapi doesn't like.
        //
        if (strTemp.empty() ||
            (L'\"' != *(strTemp.c_str()) &&
             wcscspn(strTemp.c_str(), szSpecialChars) < strTemp.size()))
        {
            strTemp = L'"' + strTemp + L'"';
        }

        if (i)
        {
            strList = strList + chDelimiter + strTemp;
        }
        else
        {
            strList = strTemp;
        }
        ++i;
    }
}


// ----------------------------------------------------------------------
//
// Function:  IsBoolString
//
// Purpose:   Parse a string to decide if it represents a boolean value
//
// Arguments:
//    pszStr  [in]  string
//    pbValue [out] pointer to BOOL value parsed
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 12-February-98
//
// Notes:
//
BOOL IsBoolString(IN PCWSTR pszStr, OUT BOOL *pbValue)
{
    if ((!_wcsicmp(pszStr, L"yes")) ||
    (!_wcsicmp(pszStr, L"true")) ||
    (!_wcsicmp(pszStr, L"1")))
    {
        *pbValue = TRUE;
        return TRUE;
    }
    else if ((!_wcsicmp(pszStr, L"no")) ||
         (!_wcsicmp(pszStr, L"false")) ||
         (!_wcsicmp(pszStr, L"0")))
    {
        *pbValue = FALSE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// ----------------------------------------------------------------------
//
// Function:  FIsInStringArray
//
// Purpose:   Find out if a string exists in an array
//
// Arguments:
//    ppszStrings     [in]  array of strings
//    cNumStrings     [in]  num strings in array
//    pszStringToFind [in]  string to find
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 12-February-98
//
// Notes:
//
BOOL FIsInStringArray(
    IN const PCWSTR* ppszStrings,
    IN DWORD cNumStrings,
    IN PCWSTR pszStringToFind,
    OUT UINT* puIndex)
{
    for (DWORD isz = 0; isz < cNumStrings; isz++)
    {
        if (!lstrcmpiW(ppszStrings[isz], pszStringToFind))
        {
            if (puIndex)
            {
                *puIndex = isz;
            }

            return TRUE;
        }
    }
    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  HrRegOpenServiceKey
//
// Purpose:   Open reg key for the given service
//
// Arguments:
//    szServiceName [in]  name of service
//    samDesired    [in]  SAM required
//    phKey         [out] pointer to handle of reg key
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 12-February-98
//
// Notes:
//
HRESULT HrRegOpenServiceKey(
    IN PCWSTR pszServiceName,
    IN REGSAM samDesired,
    OUT HKEY* phKey)
{
    DefineFunctionName("HrRegOpenServiceKey");

    AssertValidReadPtr(pszServiceName);
    AssertValidWritePtr(phKey);

    *phKey = NULL;

    HRESULT hr;
    tstring strService;

    strService = c_szRegKeyServices;
    strService += L"\\";
    strService += pszServiceName;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strService.c_str(),
                        samDesired, phKey);

    TraceErrorOptional(__FUNCNAME__, hr,
                       (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrRegOpenServiceSubKey
//
// Purpose:   Open sub key of a service key
//
// Arguments:
//    pszServiceName [in]  name of service
//    pszSubKey      [in]  name of sub key
//    samDesired    [in]  SAM required
//    phKey         [out] pointer to handle of key opened
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 12-February-98
//
// Notes:
//
HRESULT HrRegOpenServiceSubKey(
    IN PCWSTR pszServiceName,
    IN PCWSTR pszSubKey,
    IN REGSAM samDesired,
    OUT HKEY* phKey)
{
    AssertValidReadPtr(pszServiceName);
    AssertValidReadPtr(pszSubKey);
    AssertValidWritePtr(phKey);

    DefineFunctionName("HrRegOpenServiceSubKey");

    HRESULT hr = S_OK;

    tstring strKey;
    strKey = pszServiceName;
    strKey += L"\\";
    strKey += pszSubKey;

    hr = HrRegOpenServiceKey(strKey.c_str(), samDesired, phKey);

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  FIsServiceKeyPresent
//
// Purpose:   Check if a service reg key is present
//
// Arguments:
//    pszServiceName [in]  name of service
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 12-February-98
//
// Notes:
//
BOOL FIsServiceKeyPresent(IN PCWSTR pszServiceName)
{
    BOOL fResult = FALSE;

    HKEY hkeyService;
    HRESULT hr;

    hr = HrRegOpenServiceKey(pszServiceName, KEY_READ, &hkeyService);
    if (S_OK == hr)
    {
        // we just wanted to see if service is installed
        RegCloseKey(hkeyService);
        fResult = TRUE;
    }

    return fResult;
}

// ----------------------------------------------------------------------
//
// Function:  EraseAndDeleteAll
//
// Purpose:   Erase each element and then delete string array
//
// Arguments:
//    sa [in]  pointer to array of strings
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void EraseAndDeleteAll(IN TStringArray* sa)
{
    for (size_t i=0; i < sa->size(); i++)
    {
        delete (*sa)[i];
    }
    sa->erase(sa->begin(), sa->end());
}


// ----------------------------------------------------------------------
//
// Function:  AppendToPath
//
// Purpose:   Append a subpath/filename to a path
//
// Arguments:
//    pstrPath [in]  path
//    szItem   [in]  item to append
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void AppendToPath(IN OUT tstring* pstrPath, IN PCWSTR szItem)
{
    if (pstrPath->c_str()[pstrPath->size()-1] != L'\\')
    {
        *pstrPath += L'\\';
    }

    *pstrPath += szItem;
}

// ----------------------------------------------------------------------
//
// Function:  ConvertDelimitedListToStringArray
//
// Purpose:   Convert a delimited list to an array
//
// Arguments:
//    strDelimitedList [in]  delimited list (e.g. "a,b,c")
//    chDelimiter      [in]  delimiter char
//    saStrings        [out] array of strings
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void ConvertDelimitedListToStringArray(
    IN const tstring& strDelimitedList,
    IN WCHAR chDelimiter,
    OUT TStringArray &saStrings)
{
    PCWSTR pszDelimitedList = strDelimitedList.c_str();
    DWORD i=0, dwStart;

    EraseAndDeleteAll(&saStrings);

    tstring strTemp;
    DWORD dwNumChars;
    while (pszDelimitedList[i])
    {
        dwStart = i;
        while (pszDelimitedList[i] && (pszDelimitedList[i] != chDelimiter))
        {
            ++i;
        }

        // if each item is enclosed in quotes. strip the quotes
        dwNumChars = i - dwStart;
        if (pszDelimitedList[dwStart] == L'"')
        {
            dwStart++;
            dwNumChars -= 2;
        }

        strTemp = strDelimitedList.substr(dwStart, dwNumChars);
        saStrings.push_back(new tstring(strTemp));
        if (pszDelimitedList[i])
        {
            ++i;
        }
    }
}

// ----------------------------------------------------------------------
//
// Function:  ConvertCommaDelimitedListToStringList
//
// Purpose:   Convert a comma delimited list to an array
//
// Arguments:
//    strDelimitedList [in]  delimited list (e.g. "a,b,c")
//    saStrings        [out] array of strings
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void ConvertCommaDelimitedListToStringArray(
    IN const tstring& strDelimitedList,
    OUT TStringArray &saStrings)
{
    ConvertDelimitedListToStringArray(strDelimitedList, L',', saStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\ncnetcfg2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C F G . C P P
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"
#include "ncnetcfg.h"
#include "netcfgx.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::AcquireWriteLock
//      pszClientDesc   [in]   See INetCfg::AcquireWriteLock
//      ppszClientDesc  [out]  See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    PCWSTR      pszClientDesc,
    PWSTR*      ppszClientDesc)
{
    Assert (ppnc);

    // Initialize the output parameters.
    *ppnc = NULL;

    if (ppszClientDesc)
    {
        *ppszClientDesc = NULL;
    }

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            *pfInitCom = FALSE;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetCfg,
                reinterpret_cast<void**>(&pnc));

        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, pszClientDesc,
                                               ppszClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize (NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    AddRefObj (pnc);
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);

            ReleaseObj(pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    TraceError("HrCreateAndInitializeINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock)
{
    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    TraceError("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
        }
    }

    TraceError("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsLanCapableAdapter
//
//  Purpose:    Returns whether the given component (adapter) is capable of
//              being associated with a LAN connection
//
//  Arguments:
//      pncc [in]   Component to test
//
//  Returns:    S_OK if it is capable, S_FALSE if not, OLE or Win32 error code
//              otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrIsLanCapableAdapter (
    INetCfgComponent*   pncc)
{
    Assert(pncc);

    INetCfgComponentBindings*  pnccb;
    HRESULT hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                              reinterpret_cast<LPVOID *>(&pnccb));
    if (S_OK == hr)
    {
        // Does it have ndis4?...
        extern const WCHAR c_szBiNdis4[];
        hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdis4);
        if (S_FALSE == hr)
        {
            // ... no.. how about ndisatm?
            extern const WCHAR c_szBiNdisAtm[];
            hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdisAtm);
            if (S_FALSE == hr)
            {
                // .. let's try ndis5 then
                extern const WCHAR c_szBiNdis5[];
                hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdis5);
                if (S_FALSE == hr)
                {
                    // .. let's try ndis5_ip then
                    extern const WCHAR c_szBiNdis5Ip[];
                    hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdis5Ip);
                    if (S_FALSE == hr)
                    {
                        // .. let's try LocalTalk then (this is an adapters lower interface)
                        extern const WCHAR c_szBiLocalTalk[];
                        hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiLocalTalk);

                        // ... no.. how about ndis1394?
                        if (S_FALSE == hr)
                        {
                            extern const WCHAR c_szBiNdis1394[];
                            hr = pnccb->SupportsBindingInterface(NCF_UPPER,
                                                             c_szBiNdis1394);
                        }
                    }
                }
            }
        }

        ReleaseObj(pnccb);
    }

    TraceError("HrIsLanCapableAdapter", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsLanCapableProtocol
//
//  Purpose:    Returns whether the given component (protocol) is capable of
//              being associated with a LAN connection
//
//  Arguments:
//      pncc [in]   Component to test
//
//  Returns:    S_OK if it is capable, S_FALSE if not, OLE or Win32 error code
//              otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrIsLanCapableProtocol (
    INetCfgComponent*   pncc)
{
    Assert(pncc);

    INetCfgComponentBindings*  pnccb;
    HRESULT hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                              reinterpret_cast<LPVOID *>(&pnccb));
    if (S_OK == hr)
    {
        // Does it have ndis4?...
        extern const WCHAR c_szBiNdis4[];
        hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdis4);
        if (S_FALSE == hr)
        {
            // ... no.. how about ndisatm?
            extern const WCHAR c_szBiNdisAtm[];
            hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdisAtm);
            if (S_FALSE == hr)
            {
                // .. let's try ndis5 then
                extern const WCHAR c_szBiNdis5[];
                hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdis5);
                if (S_FALSE == hr)
                {
                    // .. let's try ndis5_ip then
                    extern const WCHAR c_szBiNdis5Ip[];
                    hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdis5Ip);

                }
            }
        }

        ReleaseObj(pnccb);
    }

    // Raid 147474 : NDISUIO: No warning when you uninstall all the protocols.
    // mbend 7/20/2000
    //
    // Don't consider a hidden protocol a valid Lanui protocol.
    if(S_OK == hr)
    {
        DWORD dwChar = 0;
        hr = pncc->GetCharacteristics(&dwChar);
        if(SUCCEEDED(hr))
        {
            if(NCF_HIDDEN & dwChar)
            {
                hr = S_FALSE;
            }
        }
    }

    TraceError("HrIsLanCapableAdapter", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\ncnetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C F G . C P P
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "netcfgx.h"
#include "netcfgn.h"
#include "netcfgp.h"
#include "ncdebug.h"
#include "ncbase.h"
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncvalid.h"

extern const WCHAR c_szRegKeyAnswerFileMap[];
extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_AtmArps[];
extern const WCHAR c_szInfId_MS_AtmElan[];
extern const WCHAR c_szInfId_MS_AtmLane[];
extern const WCHAR c_szInfId_MS_AtmUni[];
extern const WCHAR c_szInfId_MS_DHCPServer[];
extern const WCHAR c_szInfId_MS_GPC[];
extern const WCHAR c_szInfId_MS_IrDA[];
extern const WCHAR c_szInfId_MS_IrdaMiniport[];
extern const WCHAR c_szInfId_MS_IrModemMiniport[];
extern const WCHAR c_szInfId_MS_Isotpsys[];
extern const WCHAR c_szInfId_MS_L2TP[];
extern const WCHAR c_szInfId_MS_L2tpMiniport[];
extern const WCHAR c_szInfId_MS_MSClient[];
extern const WCHAR c_szInfId_MS_NdisWan[];
extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szInfId_MS_NdisWanBh[];
extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanIpx[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NetBIOS[];
extern const WCHAR c_szInfId_MS_NetBT[];
extern const WCHAR c_szInfId_MS_NetBT_SMB[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_NWClient[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NWNB[];
extern const WCHAR c_szInfId_MS_NwSapAgent[];
extern const WCHAR c_szInfId_MS_NWSPX[];
extern const WCHAR c_szInfId_MS_PPPOE[];
extern const WCHAR c_szInfId_MS_PppoeMiniport[];
extern const WCHAR c_szInfId_MS_PPTP[];
extern const WCHAR c_szInfId_MS_PptpMiniport[];
extern const WCHAR c_szInfId_MS_PSched[];
extern const WCHAR c_szInfId_MS_PSchedMP[];
extern const WCHAR c_szInfId_MS_PSchedPC[];
extern const WCHAR c_szInfId_MS_PtiMiniport[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasMan[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_RawWan[];
extern const WCHAR c_szInfId_MS_Server[];
extern const WCHAR c_szInfId_MS_Steelhead[];
extern const WCHAR c_szInfId_MS_Streams[];
extern const WCHAR c_szInfId_MS_TCPIP[];


#pragma BEGIN_CONST_SECTION

// Warning: This must stay sorted on component id!
// Hint: With VSlick, use 'sort_on_selection AI' to resort this.
//
extern const __declspec(selectany) COMPONENT_INFO  c_mapComponents [] =
{
    { c_szInfId_MS_AppleTalk,       &GUID_DEVCLASS_NETTRANS,    L"netatlk.inf" },
    { c_szInfId_MS_AtmArps,         &GUID_DEVCLASS_NETTRANS,    L"netaarps.inf"},
    { c_szInfId_MS_AtmElan,         &GUID_DEVCLASS_NET,         L"netlanem.inf"},
    { c_szInfId_MS_AtmLane,         &GUID_DEVCLASS_NETTRANS,    L"netlanep.inf"},
    { c_szInfId_MS_AtmUni,          &GUID_DEVCLASS_NETTRANS,    L"netauni.inf"},
    { c_szInfId_MS_DHCPServer,      &GUID_DEVCLASS_NETSERVICE,  L"netdhcps.inf" },
    { c_szInfId_MS_IrDA,            &GUID_DEVCLASS_NETTRANS,    L"netirda.inf" },
    { c_szInfId_MS_IrdaMiniport,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_IrModemMiniport, &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_Isotpsys,        &GUID_DEVCLASS_NETTRANS,    L"nettp4.inf" },
    { c_szInfId_MS_L2TP,            &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_L2tpMiniport,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_MSClient,        &GUID_DEVCLASS_NETCLIENT,   L"netmscli.inf" },
    { c_szInfId_MS_NdisWan,         &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_NdisWanAtalk,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanBh,       &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanIp,       &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanIpx,      &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanNbfIn,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanNbfOut,   &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NetBIOS,         &GUID_DEVCLASS_NETSERVICE,  L"netnb.inf" },
    { c_szInfId_MS_NetBT,           &GUID_DEVCLASS_NETTRANS,    L"nettcpip.inf" },
    { c_szInfId_MS_NetBT_SMB,       &GUID_DEVCLASS_NETTRANS,    L"nettcpip.inf" },
    { c_szInfId_MS_NetMon,          &GUID_DEVCLASS_NETTRANS,    L"netnm.inf" },
    { c_szInfId_MS_NWClient,        &GUID_DEVCLASS_NETCLIENT,   L"netnwcli.inf" },
    { c_szInfId_MS_NWIPX,           &GUID_DEVCLASS_NETTRANS,    L"netnwlnk.inf" },
    { c_szInfId_MS_NWNB,            &GUID_DEVCLASS_NETTRANS,    L"netnwlnk.inf" },
    { c_szInfId_MS_NwSapAgent,      &GUID_DEVCLASS_NETSERVICE,  L"netsap.inf" },
    { c_szInfId_MS_NWSPX,           &GUID_DEVCLASS_NETTRANS,    L"netnwlnk.inf" },
    { c_szInfId_MS_PPPOE,           &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_PppoeMiniport,   &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_PPTP,            &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_PptpMiniport,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_PSched,          &GUID_DEVCLASS_NETSERVICE,  L"netpschd.inf" },
    { c_szInfId_MS_PSchedMP,        &GUID_DEVCLASS_NET,         L"netpsa.inf" },
    { c_szInfId_MS_PSchedPC,        &GUID_DEVCLASS_NETSERVICE,  L"netpschd.inf" },
    { c_szInfId_MS_PtiMiniport,     &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_RasCli,          &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_RasMan,          &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_RasSrv,          &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_RawWan,          &GUID_DEVCLASS_NETTRANS,    L"netrwan.inf" },
    { c_szInfId_MS_Server,          &GUID_DEVCLASS_NETSERVICE,  L"netserv.inf" },
    { c_szInfId_MS_Steelhead,       &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_Streams,         &GUID_DEVCLASS_NETTRANS,    L"netstrm.inf" },
    { c_szInfId_MS_TCPIP,           &GUID_DEVCLASS_NETTRANS,    L"nettcpip.inf" },
    { L"ms_wanarp",                 &GUID_DEVCLASS_NET,         L"netrast.inf" },
};

#pragma END_CONST_SECTION


//+---------------------------------------------------------------------------
//
//  Function:   NCompareComponentIds
//
//  Purpose:    Compare function for bsearch.
//
//  Arguments:
//      ppszComp1 [in] pointer to pointer to a component id
//      ppszComp2 [in] pointer to pointer to a component id
//
//  Returns:    < 0 if pvComp1 is less than pvComp2
//                0 if they are equal
//              > 0 if pvComp1 is greater than pvComp2
//
//  Author:     shaunco   27 Jul 1997
//
//  Notes:
//
int __cdecl
NCompareComponentIds (
    IN  const PCWSTR* ppszComp1,
    IN  const PCWSTR* ppszComp2)
{
    return lstrcmpiW (*ppszComp1, *ppszComp2);
}

//+---------------------------------------------------------------------------
//
//  Function:   PComponentInfoFromComponentId
//
//  Purpose:    Return the COMPONENT_INFO record within c_mapComponents
//              having the specified component id.
//
//  Arguments:
//      pszComponentId [in] The requested component id.
//
//  Returns:    NULL if not found.
//
//  Author:     shaunco   27 Jul 1997
//
//  Notes:
//
inline
const COMPONENT_INFO*
PComponentInfoFromComponentId (
    PCWSTR pszComponentId)
{
    // For debug builds, check that c_mapComponents is sorted properley.
    // If it isn't, bsearch (called below) won't work.  Only perform this
    // check once because the map doesn't change.
    //
#ifdef DBG
    static BOOL fCheckedSorted = FALSE;

    if (!fCheckedSorted)
    {
        fCheckedSorted = TRUE;

        for (UINT i = 1; i < celems (c_mapComponents); i++)
        {
            PCWSTR pszComp1 = c_mapComponents [i-1].pszComponentId;
            PCWSTR pszComp2 = c_mapComponents [i]  .pszComponentId;
            if (NCompareComponentIds (&pszComp1, &pszComp2) >= 0)
            {
                AssertFmt (FALSE, FAL,
                           "'%S' in c_mapComponents is out of order!  "
                           "Component installation may fail in bizarre ways!",
                           pszComp2);
            }
        }
    }
#endif

    typedef int (__cdecl *PFNCOMPARE)(const void *, const void *);

    PFNCOMPARE pfn = reinterpret_cast<PFNCOMPARE>(NCompareComponentIds);

    return static_cast<const COMPONENT_INFO*>
                (bsearch (&pszComponentId,
                          &c_mapComponents->pszComponentId,
                          celems (c_mapComponents),
                          sizeof (c_mapComponents[0]),
                          pfn));
}

//+---------------------------------------------------------------------------
//
//  Function:   FClassGuidFromComponentId
//
//  Purpose:    Given a component id, returns the class guid associated with
//              it.
//
//  Arguments:
//      pszComponentId  [in]  Component id to look up.
//      pguidClass      [out] Class guid to be returned.
//
//  Returns:    TRUE if component was found, FALSE if not.
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:
//
BOOL
FClassGuidFromComponentId (
    PCWSTR          pszComponentId,
    const GUID**    ppguidClass)
{
    Assert(ppguidClass);

    // Initialize output parameter.
    //
    *ppguidClass = NULL;

    const COMPONENT_INFO* pComponentInfo =
            PComponentInfoFromComponentId (pszComponentId);
    if (pComponentInfo)
    {
        *ppguidClass = pComponentInfo->pguidClass;
        return TRUE;
    }
    TraceTag (ttidNetcfgBase,
              "Found no match for %S in FClassGuidFromComponentId.",
              pszComponentId);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FInfFileFromComponentId
//
//  Purpose:    Given a component ID, returns the INF file name it lives in.
//
//  Arguments:
//      pszComponentId [in]  Component id to look up.
//      pszInfFile     [out] INF file name to be returned.
//                           (must be _MAX_PATH long).
//
//  Returns:    TRUE if component was found, FALSE if not.
//
//  Author:     shaunco   27 Jul 1997
//
//  Notes:
//
BOOL
FInfFileFromComponentId (
    PCWSTR  pszComponentId,
    PWSTR   pszInfFile)
{
    Assert(pszComponentId);
    Assert(pszInfFile);

    // Initialize output parameter.
    //
    *pszInfFile = 0;

    const COMPONENT_INFO* pComponentInfo =
            PComponentInfoFromComponentId (pszComponentId);
    if (pComponentInfo)
    {
        wcsncpy (pszInfFile, pComponentInfo->pszInfFile, _MAX_PATH);
        pszInfFile [_MAX_PATH - 1] = 0;
        return TRUE;
    }
    TraceTag (ttidNetcfgBase,
              "Found no match for %S in FInfFileFromComponentId.",
              pszComponentId);
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   FGetInstanceGuidOfComponentFromAnswerFileMap
//
//  Purpose:    Maps a component instance in the answer file to
//              its instance guid.
//
//  Arguments:
//      pszComponentId   [in]       Name of component to get guid of.
//      pguid            [out]      Returns instance GUID of that component.
//
//  Returns:    TRUE if successful, FALSE if the component was not located.
//
BOOL
FGetInstanceGuidOfComponentFromAnswerFileMap (
    IN  PCWSTR  pszComponentId,
    OUT GUID*   pguid)
{

    HRESULT hr;
    BOOL fFound = FALSE;

    // Component not found as already installed. Need to examine the
    // AnswerFileMap in the registry.
    //
    HKEY hkey;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAnswerFileMap,
                        KEY_QUERY_VALUE, &hkey);
    if (S_OK == hr)
    {
        WCHAR szGuid [c_cchGuidWithTerm];
        DWORD cbData = sizeof (szGuid);
        hr = HrRegQuerySzBuffer(hkey, pszComponentId, szGuid, &cbData);
        if (S_OK == hr)
        {
            hr = IIDFromString(szGuid, pguid);
            fFound = (S_OK == hr);
        }

        RegCloseKey(hkey);
    }

#ifdef ENABLETRACE
    if (FAILED(hr))
    {
        TraceTag(ttidNetcfgBase, "FGetInstanceGuidOfComponentInAnswerFile: "
                "could not locate instance GUID of %S", pszComponentId);
    }
#endif

    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetInstanceGuidOfComponentInAnswerFile
//
//  Purpose:    Maps a component instance in the answer file to
//              its instance guid.
//
//  Arguments:
//      pszComponentId   [in]       Name of component to get guid of.
//      pnc              [in]       INetCfg interface
//      pguid            [out]      Returns instance GUID of that component.
//
//  Returns:    TRUE if successful, FALSE if the component was not located.
//
BOOL
FGetInstanceGuidOfComponentInAnswerFile(
    IN  PCWSTR      pszComponentId,
    IN  INetCfg*    pnc,
    OUT LPGUID      pguid)
{
    static char __FUNCNAME__[] = "FGetInstanceGuidOfComponentInAnswerFile";

    Assert (pszComponentId);
    AssertValidReadPtr(pnc);
    AssertValidWritePtr(pguid);

    // Search for the component.
    //
    INetCfgComponent* pncc;
    HRESULT hr = pnc->FindComponent (pszComponentId, &pncc);
    if (S_OK == hr)
    {
        hr = pncc->GetInstanceGuid (pguid);
        ReleaseObj(pncc);
    }
    else
    {
        // Component not found as already installed. Need to examine the
        // AnswerFileMap in the registry.
        //
        HKEY hkey;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAnswerFileMap,
                            KEY_QUERY_VALUE, &hkey);
        if (S_OK == hr)
        {
            WCHAR szGuid [c_cchGuidWithTerm];
            DWORD cbData = sizeof (szGuid);
            hr = HrRegQuerySzBuffer(hkey, pszComponentId, szGuid, &cbData);
            if (S_OK == hr)
            {
                hr = IIDFromString(szGuid, pguid);
            }

            RegCloseKey(hkey);
        }

#ifdef ENABLETRACE
        if (FAILED(hr))
        {
            TraceTag(ttidNetcfgBase, "%s: could not locate instance GUID of %S",
                     __FUNCNAME__, pszComponentId);
        }
#endif
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), __FUNCNAME__);
    return (SUCCEEDED(hr)) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsBindingName
//
//  Purpose:    Returns TRUE if a binding interface is of the specified name.
//
//  Arguments:
//      pszName  [in] Name of the binding interface to check for.
//      dwFlags  [in] FIBN_ flags
//      pncbi    [in] Binding interface pointer.
//
//  Returns:    TRUE if the binding interface is of the specified name.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
BOOL
FIsBindingName (
    PCWSTR                      pszName,
    DWORD                       dwFlags,
    INetCfgBindingInterface*    pncbi)
{
    Assert (pszName);
    Assert (pncbi);

    BOOL fRet = FALSE;
    PWSTR pszInterfaceName;
    if (SUCCEEDED(pncbi->GetName (&pszInterfaceName)))
    {
        INT c_cchPrefix = (FIBN_PREFIX & dwFlags) ? lstrlenW (pszName) : -1;

        fRet = (2 == CompareStringW (LOCALE_SYSTEM_DEFAULT, 0,
                                     pszName, c_cchPrefix,
                                     pszInterfaceName, c_cchPrefix));

        CoTaskMemFree (pszInterfaceName);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsComponentId
//
//  Purpose:    Returns TRUE if a component is of the specified id.
//
//  Arguments:
//      pszComponentId  [in] Component Id to check for.
//      pncc            [in] Component interface pointer.
//
//  Returns:    TRUE if component is of the specified id.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
BOOL
FIsComponentId (
    PCWSTR              pszComponentId,
    INetCfgComponent*   pncc)
{
    Assert (pszComponentId);
    Assert (pncc);

    BOOL fRet = FALSE;
    PWSTR pszId;
    if (SUCCEEDED(pncc->GetId (&pszId)))
    {
        if (FEqualComponentId (pszComponentId, pszId))
            fRet = TRUE;

        CoTaskMemFree (pszId);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddOrRemoveAdapter
//
//  Purpose:
//
//  Arguments:
//      pnc             [in] pointer to an INetCfg object.
//      pszComponentId  [in] component INF id.
//      dwFlags         [in]
//
//          ARA_ADD       :  Add the component
//          ARA_REMOVE    :  Remove the component.  Cannot be specified
//                           with ARA_ADD.
//      pOboToken       [in] If specified, refcount the adapter.  This is the
//                           on behalf of token adding or removing the specified
//                           component.  This allows per-component reference
//                           counts of another.
//      cInstances      [in] this specifies how many instances (or references)
//                           to add or remove.
//      ppncc           [out] (optional). The newly added component.  Can only
//                            be specified when adding one component.
//
//  Returns:    S_OK or an error
//
//  Author:     shaunco   28 Mar 1997
//
//  Notes:
//
HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    DWORD               dwFlags,
    OBO_TOKEN*          pOboToken,
    UINT                cInstances,
    INetCfgComponent**  ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (dwFlags);
    Assert (cInstances);

#ifdef DBG
    AssertSz ((dwFlags & ARA_ADD) || (dwFlags & ARA_REMOVE),
              "Need to add or remove.  Can't do neither.");

    if (dwFlags & ARA_ADD)
    {
        AssertSz (!(dwFlags & ARA_REMOVE), "Can't remove AND add.");
    }
    if (dwFlags & ARA_REMOVE)
    {
        AssertSz (!(dwFlags & ARA_ADD), "Can't add AND remove.");
    }
    AssertSz (FImplies(1 != cInstances, NULL == ppncc),
              "Can't return ppncc when cInstances is greater than one.");
    AssertSz (FImplies(ppncc, 1 == cInstances),
              "Can only add one instance when returning ppncc.");
    AssertSz (FImplies(ppncc, dwFlags & ARA_ADD),
              "Can't return ppncc when removing.");
#endif

    // Get the component class object for adapters.
    INetCfgClass* pncclass;
    HRESULT hr = pnc->QueryNetCfgClass (&GUID_DEVCLASS_NET, IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
    if (S_OK == hr)
    {
        INetCfgClassSetup* pncclasssetup;
        hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                reinterpret_cast<void**>(&pncclasssetup));
        if (S_OK == hr)
        {
            if (dwFlags & ARA_ADD)
            {
                // Install the component the specified number of times.
                //
                while (SUCCEEDED(hr) && cInstances--)
                {
                    hr = pncclasssetup->Install(pszComponentId, pOboToken,
                                                0, 0, NULL, NULL, ppncc );
                }
            }
            else
            {
                // Remove the component the specified number of times.
                //
                AssertSz(S_OK == hr, "hr should be S_OK here to make sure the "
                                     "loop is given a chance.");
                while (SUCCEEDED(hr) && cInstances)
                {
                    // Find and remove the component.
                    //
                    INetCfgComponent* pncc;
                    hr = pncclass->FindComponent (pszComponentId, &pncc);
                    if (S_OK == hr)
                    {
                        hr = pncclasssetup->DeInstall (pncc,
                                pOboToken, NULL);

                        cInstances--;

                        ReleaseObj (pncc);
                    }
                    else if (S_FALSE == hr)
                    {
                        // If it wasn't found, get out.
                        break;
                    }
                }
                AssertSz (FImplies(SUCCEEDED(hr), (0 == cInstances)),
                          "cInstances should be zero.  This assert means "
                          "that we were asked to remove more instances than "
                          "were installed.");
            }

            // Normalize the HRESULT.
            // Possible values of hr at this point are S_FALSE,
            // NETCFG_S_REBOOT, and NETCFG_S_STILL_REFERENCED.
            //
            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }

            ReleaseObj( pncclasssetup );
        }
        ReleaseObj (pncclass);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrAddOrRemoveAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveAllInstancesOfAdapter
//
//  Purpose:    Remove all instances of the adapter with the specified
//              component id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pszComponentId  [in] Component id to search for and remove.
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveAllInstancesOfAdapter (
    INetCfg*    pnc,
    PCWSTR      pszComponentId)
{
    Assert (pnc);
    Assert (pszComponentId);

    PCWSTR apszComponentId [1];
    apszComponentId[0] = pszComponentId;

    HRESULT hr = HrFindAndRemoveAllInstancesOfAdapters (pnc,
                    1, apszComponentId);

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrFindAndRemoveAllInstancesOfAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveAllInstancesOfAdapters
//
//  Purpose:    Remove all instances of the adapters with the specified
//              component ids.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      cComponents      [in] Count of component ids in the array.
//      apszComponentId  [in] Array of compoennt ids to search for and
//                             remove.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveAllInstancesOfAdapters (
    INetCfg*        pnc,
    ULONG           cComponents,
    const PCWSTR*   apszComponentId)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apszComponentId);

    // Get the class object for adapters.
    INetCfgClass* pncclass;
    INetCfgClassSetup* pncclasssetup;

    HRESULT hr = pnc->QueryNetCfgClass (&GUID_DEVCLASS_NET,
                        IID_INetCfgClass,
                        reinterpret_cast<void**>(&pncclass));
    if (S_OK == hr)
    {
        hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                reinterpret_cast<void**>(&pncclasssetup));
        if (S_OK == hr)
        {
            for (ULONG i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
            {
                // Find and remove all instances of the component.
                INetCfgComponent* pncc;

                while ((SUCCEEDED(hr)) &&
                       (S_OK == (hr = pncclass->FindComponent (
                                        apszComponentId[i], &pncc))))
                {
                    hr = pncclasssetup->DeInstall (pncc, NULL, NULL);
                    ReleaseObj (pncc);
                }

                // Normalize the HRESULT.
                //
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
            ReleaseObj (pncclasssetup);
        }
        ReleaseObj (pncclass);
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrFindAndRemoveAllInstancesOfAdapters");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponent
//
//  Purpose:    Find and remove the component with the specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pguidClass      [in] Class GUID of the component.
//      pszComponentId  [in] Component id to search for and remove.
//      pOboToken       [in] (Optional) If specified, remove on behalf of.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponent (
    INetCfg*    pnc,
    const GUID* pguidClass,
    PCWSTR      pszComponentId,
    OBO_TOKEN*  pOboToken)
{
    Assert (pnc);
    Assert (pguidClass);
    Assert (pszComponentId);
    AssertSz (GUID_DEVCLASS_NET != *pguidClass,
                "Don't use this to remove adapters.");

    // Get the component class object.
    //
    INetCfgClass* pncclass;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(hr))
    {
        // Find the component to remove.
        //
        INetCfgComponent* pnccRemove;
        hr = pncclass->FindComponent (pszComponentId, &pnccRemove);
        if (S_OK == hr)
        {
            INetCfgClassSetup* pncclasssetup;
            hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                        reinterpret_cast<void**>(&pncclasssetup));
            if (SUCCEEDED(hr))
            {
                hr = pncclasssetup->DeInstall (pnccRemove, pOboToken, NULL);

                ReleaseObj (pncclasssetup);
            }

            ReleaseObj (pnccRemove);
        }
        else if (S_FALSE == hr)
        {
            hr = S_OK;
        }

        ReleaseObj (pncclass);
    }
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponents
//
//  Purpose:    Find and remove the components with the specified ids.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      cComponents      [in] Count of components in the array.
//      apguidClass      [in] Array of class GUIDs corresponding to the
//                            array of component ids.
//      apszComponentId  [in] Array of component ids to search for and
//                            remove.
//      pOboToken        [in] (Optional) If specified, remove on behalf of.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponents (
    INetCfg*        pnc,
    ULONG           cComponents,
    const GUID**    apguidClass,
    const PCWSTR*   apszComponentId,
    OBO_TOKEN*      pOboToken)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);

    HRESULT hr = S_OK;
    for (ULONG i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        hr = HrFindAndRemoveComponent (pnc, apguidClass[i],
                    apszComponentId[i], pOboToken);
    }
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponentsOboComponent
//
//  Purpose:    Remove multiple components on behalf of one component.
//
//  Arguments:
//      pnc         [in]    pointer to an INetCfg object.
//      cComponents [in]    count of class guid pointers and component id
//                          pointers.
//      apguidClass [in]    array of class guid pointers.
//      apszId      [in]    array of component id pointers.
//      pnccObo     [in]    the component requesting the remove. (i.e. the
//                          "on behalf of" component.)
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponentsOboComponent (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*       apszComponentId,
    INetCfgComponent*   pnccObo)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);
    Assert (pnccObo);

    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrFindAndRemoveComponents (pnc, cComponents,
                    apguidClass, apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponentsOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponentsOboUser
//
//  Purpose:    Remove multiple components on behalf of one component.
//
//  Arguments:
//      pnc         [in]    pointer to an INetCfg object.
//      cComponents [in]    count of class guid pointers and component id
//                          pointers.
//      apguidClass [in]    array of class guid pointers.
//      apszId      [in]    array of component id pointers.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponentsOboUser (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*       apszComponentId)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);

    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrFindAndRemoveComponents (pnc, cComponents,
                    apguidClass, apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponentsOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindComponents
//
//  Purpose:    Find multiple INetCfgComponents with one call.  This makes
//              the error handling associated with multiple calls to
//              QueryNetCfgClass and Find much easier.
//
//  Arguments:
//      pnc             [in] pointer to INetCfg object
//      cComponents     [in] count of class guid pointers, component id
//                           pointers, and INetCfgComponent output pointers.
//      apguidClass     [in] array of class guid pointers.
//      apszComponentId [in] array of component id pointers.
//      apncc           [out] array of returned INetCfgComponet pointers.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   22 Mar 1997
//
//  Notes:      cComponents is the count of pointers in all three arrays.
//              S_OK will still be returned even if no components were
//              found!  This is by design.
//
HRESULT
HrFindComponents (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*       apszComponentId,
    INetCfgComponent**  apncc)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);
    Assert (apncc);

    // Initialize the output parameters.
    //
    ZeroMemory (apncc, cComponents * sizeof(*apncc));

    // Find all of the components requested.
    // Variable initialization is important here.
    HRESULT hr = S_OK;
    ULONG i;
    for (i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        // Get the class object for this component.
        INetCfgClass* pncclass;
        hr = pnc->QueryNetCfgClass (apguidClass[i], IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
        if (SUCCEEDED(hr))
        {
            // Find the component.
            hr = pncclass->FindComponent (apszComponentId[i], &apncc[i]);

            AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");

            ReleaseObj (pncclass);
        }
    }

    // On any error, release what we found and set the output to NULL.
    if (FAILED(hr))
    {
        for (i = 0; i < cComponents; i++)
        {
            ReleaseObj (apncc[i]);
            apncc[i] = NULL;
        }
    }
    // Otherwise, normalize the HRESULT.  (i.e. don't return S_FALSE)
    else
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrFindComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetBindingInterfaceComponents
//
//  Purpose:    Get both upper and lower components involved in a
//              binding interface.
//
//  Arguments:
//      pncbi      [in]     binding interface.
//      ppnccUpper [out]    output upper component.
//      ppnccLower [out]    output lower compoenet.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   18 Apr 1997
//
//  Notes:
//
HRESULT
HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower)
{
    Assert (pncbi);
    Assert (ppnccUpper);
    Assert (ppnccLower);

    // Initialize the output parameters.
    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    INetCfgComponent* pnccUpper;
    HRESULT hr = pncbi->GetUpperComponent (&pnccUpper);
    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pnccLower;
        hr = pncbi->GetLowerComponent (&pnccLower);
        if (SUCCEEDED(hr))
        {
            *ppnccUpper = pnccUpper;
            *ppnccLower = pnccLower;
        }
        else
        {
            // Rather than AddRef this in the above SUCCEEDED block followed
            // by the normal unconditional Release, just Release here in
            // the case of failure to get the lower component.
            ReleaseObj (pnccUpper);
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrGetBindingInterfaceComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponent
//
//  Purpose:    Install the component with a specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pnip            [in] (Optional) If specified, perform the installation
//                           using the answer file.
//      pguidClass      [in] Class guid of the component to install.
//      pszComponentId  [in] Component id to install.
//      pOboToken       [in] (Optional) If specified, perform the installation
//                           on behalf of this token.
//      ppncc           [out] (Optional) Returned component that was
//                            installed.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrInstallComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID*                     pguidClass,
    PCWSTR                          pszComponentId,
    OBO_TOKEN*                      pOboToken,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Get the class setup object.
    //
    INetCfgClassSetup* pncclasssetup;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                    reinterpret_cast<void**>(&pncclasssetup));
    if (SUCCEEDED(hr))
    {
        if (pnip)
        {
            hr = pncclasssetup->Install (
                    pszComponentId,
                    pOboToken,
                    pnip->dwSetupFlags,
                    pnip->dwUpgradeFromBuildNo,
                    pnip->pszAnswerFile,
                    pnip->pszAnswerSection,
                    ppncc);
        }
        else
        {
            hr = pncclasssetup->Install (pszComponentId,
                    pOboToken, 0, 0, NULL, NULL, ppncc);
        }

        ReleaseObj (pncclasssetup);
    }
    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponent (%S)", pszComponentId);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponents
//
//  Purpose:    Install the components with the specified ids.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      pnip             [in] (Optional) If specified, perform the installation
//                            using the answer file.
//      cComponents      [in] Count of components in the arrays.
//      apguidClass      [in] Array of class guids for the specified components.
//      apszComponentId  [in] Array of component ids to install.
//      pOboToken        [in] (Optional) If specified, perform the installation
//                            on behalf of this token.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrInstallComponents (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                   apszComponentId,
    OBO_TOKEN*                      pOboToken)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);

    HRESULT hr = S_OK;
    for (ULONG i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        hr = HrInstallComponent (pnc, pnip,
                apguidClass[i], apszComponentId[i], pOboToken, NULL);
    }
    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentsOboComponent
//
//  Purpose:    Install multiple components on behalf of one component.
//
//  Arguments:
//      pnc              [in] pointer to an INetCfg object.
//      pnip             [in] (Optional) pointer to network install parameters.
//                            If non-NULL, a network install is performed,
//                            otherwise a normal install is performed.
//      cComponents      [in] count of class guid pointers and component id
//                            pointers.
//      apguidClass      [in] array of class guid pointers.
//      apszComponentId  [in] array of component id pointers.
//      pnccObo     [in]      the component requesting the install. (i.e. the
//                            "on behalf of" component.)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrInstallComponentsOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                   apszComponentId,
    INetCfgComponent*               pnccObo)
{
    Assert (pnccObo);

    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrInstallComponents (pnc, pnip, cComponents, apguidClass,
                    apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentsOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentsOboUser
//
//  Purpose:    Install multiple components on behalf of the user.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      pnip             [in] (Optional) If specified, perform the installation
//                            using the answer file.
//      cComponents      [in] Count of components in the arrays.
//      apguidClass      [in] Array of class guids for the specified components.
//      apszComponentId  [in] Array of component ids to install.
//
//  Returns:
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrInstallComponentsOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                   apszComponentId)
{
    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrInstallComponents (pnc, pnip, cComponents, apguidClass,
                    apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentsOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentOboComponent
//
//  Purpose:    Installs a component on behalf of another.  If the component
//              is already installed, it reference count is incremented on
//              behalf of the component doing the install.  When one
//              component calls this function to install another, it is
//              saying that it has a depencency on the component being
//              installed.  This dependency will prevent even the user from
//              removing the component.
//
//  Arguments:
//      pnc           [in]  pointer to an INetCfg object.
//      pnip          [in]  (Optional) pointer to network install parameters.
//                          If non-NULL, a network install is performed,
//                          otherwise a normal install is performed.
//      rguid         [in]  class GUID of the component being installed.
//      pszComponentId [in]  component INF id of the component being installed.
//      pnccObo       [in]  the component requesting the install. (i.e. the
//                          "on behalf of" component.)
//      ppncc         [out] (Optional) set on return to the previously
//                          installed component or the one that was installed.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrInstallComponentOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguid,
    PCWSTR                          pszComponentId,
    INetCfgComponent*               pnccObo,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (pnccObo);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrInstallComponent (pnc, pnip, &rguid, pszComponentId,
                    &OboToken, ppncc);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentOboSoftware
//
//  Purpose:    Installs a component on behalf of a piece of software.
//              If the component is already installed, it's reference count
//              is incremented on behalf of the indicated software piece.
//              This is useful for a component to call
//              when it is installing another component as a convienience for
//              the user.  The user can then remove the component with no
//              ill-effects for the component that called this function.
//
//  Arguments:
//      pnc              [in] pointer to an INetCfg object.
//      pnip             [in] (Optional) pointer to network install parameters.
//                            If non-NULL, a network install is performed,
//                            otherwise a normal install is performed.
//      rguid            [in] class GUID of the component being installed.
//      pszComponentId   [in] component INF id of the component being installed.
//      pszManufacturer  [in] Manufacturer name of software.
//      pszProduct       [in] Product name of software.
//      pszDisplayName   [in] Full display name of software.
//      ppncc            [out] (Optional) set on return to the previously
//                            installed component or the one that was installed.
//
//  Returns:
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT
HrInstallComponentOboSoftware (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguid,
    PCWSTR                          pszComponentId,
    PCWSTR                          pszManufacturer,
    PCWSTR                          pszProduct,
    PCWSTR                          pszDisplayName,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (pszManufacturer);
    Assert (pszDisplayName);
    Assert (pszProduct);
    AssertSz (GUID_DEVCLASS_NET != rguid, "Don't use this to install adapters.");

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Make an "on behalf of" token for the software.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_SOFTWARE;
    OboToken.pszwManufacturer = pszManufacturer;
    OboToken.pszwProduct      = pszProduct;
    OboToken.pszwDisplayName  = pszDisplayName;

    HRESULT hr = HrInstallComponent (pnc, pnip, &rguid, pszComponentId,
                    &OboToken, ppncc);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentOboSoftware");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentOboUser
//
//  Purpose:    Installs a component on behalf of the user.  If the component
//              is already installed, it reference count is incremented on
//              behalf of the user.  This is useful for a component to call
//              when it is installing another component as a convienience for
//              the user.  The user can then remove the component with no
//              ill-effects for the component that called this function.
//
//  Arguments:
//      pnc           [in]  pointer to an INetCfg object.
//      pnip          [in]  (Optional) pointer to network install parameters.
//                          If non-NULL, a network install is performed,
//                          otherwise a normal install is performed.
//      rguid         [in]  class GUID of the component being installed.
//      pszComponentId [in]  component INF id of the component being installed.
//      ppncc         [out] (Optional) set on return to the previously
//                          installed component or the one that was installed.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrInstallComponentOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguid,
    PCWSTR                          pszComponentId,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (&rguid);
    Assert (pszComponentId);
    AssertSz (GUID_DEVCLASS_NET != rguid, "Don't use this to install adapters.");

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrInstallComponent (pnc, pnip, &rguid, pszComponentId,
                    &OboToken, ppncc);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallRasIfNeeded
//
//  Purpose:    Install RAS services on behalf of the user.  No need to
//              check first as we install on behalf of the user which is
//              implicilty checked.
//
//  Arguments:
//      pnc [in] INetCfg pointer to use
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   30 Aug 1997
//
//  Notes:
//      (shaunco) 10 Sep 1997: Don't install RAS Server for Beta1.
//      DHCP addresses get eaten up too quickly.  For Beta2, it will be
//      installed but disabled.
//
//      (shaunco) 20 Dec 1997: We used to install RAS Server only on NTS.
//      We now install it always but its set to not start automatically.
//
HRESULT
HrInstallRasIfNeeded (
    INetCfg*    pnc)
{
    Assert (pnc);

    static const GUID* c_apguidInstalledComponentClasses [] =
    {
        &GUID_DEVCLASS_NETSERVICE,  // RasCli
        &GUID_DEVCLASS_NETSERVICE,  // RasSrv
    };

    static const PCWSTR c_apszInstalledComponentIds [] =
    {
        c_szInfId_MS_RasCli,
        c_szInfId_MS_RasSrv,
    };

    HRESULT hr = HrInstallComponentsOboUser (pnc, NULL,
                        celems (c_apguidInstalledComponentClasses),
                        c_apguidInstalledComponentClasses,
                        c_apszInstalledComponentIds);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallRasIfNeeded");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryNotifyObject
//
//  Purpose:    Helper function to call QueryNotifyObject given an
//              INetCfgComponent.  (Saves the intermediate QI.)
//
//  Arguments:
//      pncc      [in]  INetCfgComponent to call QueryNotifyObject on.
//      riid      [in]  Requested interface identifier.
//      ppvObject [out] Address of pointer to return the requested interface.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   2 Sep 1998
//
//  Notes:
//
HRESULT
HrQueryNotifyObject (
    INetCfgComponent*   pncc,
    REFIID              riid,
    VOID**              ppvObject)
{
    Assert (pncc);
    Assert (ppvObject);

    // Initialize the output parameter.
    //
    *ppvObject = NULL;

    // First, QI for the component private interface.
    //
    INetCfgComponentPrivate* pPrivate;
    HRESULT hr = pncc->QueryInterface(
                            IID_INetCfgComponentPrivate,
                            reinterpret_cast<VOID**>(&pPrivate));

    if (SUCCEEDED(hr))
    {
        // Now query the notify object for the requested interface.
        //
        hr = pPrivate->QueryNotifyObject (riid, ppvObject);

        ReleaseObj (pPrivate);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrQueryNotifyObject");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponent
//
//  Purpose:    Remove the specified component.
//
//  Arguments:
//      pnc          [in] INetCfg pointer.
//      pnccToRemove [in] Component to remove.
//      pOboToken    [in] (Optional) If specified, remove the component
//                        on behalf of this token.
//      pmszRefs     [out] (Optional) Returns Multi-Sz of components that
//                         still reference this one. NOTE: This will be NULL
//                         if the return value is not
//                         NETCFG_S_STILL_REFERENCED
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrRemoveComponent (
    INetCfg*            pnc,
    INetCfgComponent*   pnccToRemove,
    OBO_TOKEN*          pOboToken,
    PWSTR *             pmszRefs)
{
    Assert (pnc);
    Assert (pnccToRemove);

    // Get the class setup interface for this component.
    //
    GUID guidClass;
    HRESULT hr = pnccToRemove->GetClassGuid (&guidClass);
    if (SUCCEEDED(hr))
    {
        // Use the class setup interface to remove the component.
        //
        INetCfgClassSetup* pSetup;
        hr = pnc->QueryNetCfgClass (&guidClass,
                            IID_INetCfgClassSetup,
                            reinterpret_cast<void**>(&pSetup));
        if (SUCCEEDED(hr))
        {
            hr = pSetup->DeInstall (pnccToRemove, pOboToken, pmszRefs);
            ReleaseObj (pSetup);
        }
    }
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponentOboComponent
//
//  Purpose:    Removes a component previously installed by another.
//              Effectively balances a call to HrInstallComponentOboComponent().
//              The reference count of the component is decremented and,
//              if it is zero, the component is removed from the system.
//
//  Arguments:
//      pnc             [in]  pointer to an INetCfg object.
//      rguidClass      [in]  class GUID of the component being removed.
//      pszComponentId  [in]  component INF id of the component being removed.
//      pnccObo         [in]  the component requesting the removal.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrRemoveComponentOboComponent (
    INetCfg*            pnc,
    const GUID&         rguidClass,
    PCWSTR              pszComponentId,
    INetCfgComponent*   pnccObo)
{
    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrFindAndRemoveComponent (pnc, &rguidClass, pszComponentId,
                    &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponentOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponentOboSoftware
//
//  Purpose:    Removes a component previously installed by some software
//              entity. Effectively balances a call to
//              HrAddComponentOboSoftware(). The reference count of the
//              component is decremented and, if it is zero, the component
//              is removed from the system.
//
//  Arguments:
//      pnc              [in] pointer to an INetCfg object.
//      rguidClass       [in] class GUID of the component being removed.
//      pszComponentId   [in] component INF id of the component being removed.
//      pszManufacturer  [in] Manufacturer name of software.
//      pszProduct       [in] Product name of software.
//      pszDisplayName   [in] Full display name of software.
//      pnccObo          [in] the component requesting the removal.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED or an error.
//
//  Author:     jeffspr     13 Jun 1997
//
//  Notes:
//
HRESULT
HrRemoveComponentOboSoftware (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    PCWSTR     pszManufacturer,
    PCWSTR     pszProduct,
    PCWSTR     pszDisplayName)
{
    // Make an "on behalf of" token for the software.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_SOFTWARE;
    OboToken.pszwManufacturer = pszManufacturer;
    OboToken.pszwProduct      = pszProduct;
    OboToken.pszwDisplayName  = pszDisplayName;

    HRESULT hr = HrFindAndRemoveComponent (pnc, &rguidClass, pszComponentId,
                    &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponentOboSoftware");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponentOboUser
//
//  Purpose:    Removes a component previously installed by the user.
//              Effectively balances a call to HrAddComponentOboUser().
//              The reference count of the component is decremented and,
//              if it is zero, the component is removed from the system.
//
//  Arguments:
//      pnc             [in]  pointer to an INetCfg object.
//      rguidClass      [in]  class GUID of the component being removed.
//      pszComponentId  [in]  component INF id of the component being removed.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrRemoveComponentOboUser (
    INetCfg*        pnc,
    const GUID&     rguidClass,
    PCWSTR          pszComponentId)
{
    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrFindAndRemoveComponent (pnc, &rguidClass, pszComponentId,
                    &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponentOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetLastComponentAndInterface
//
//  Purpose:    This function enumerates a binding path, returns the last
//              component on the path and optionally return the last binding
//              interface name in this path.
//
//  Arguments:
//      pncbp               [in]    The INetCfgBindingPath *
//      ppncc               [out]   The INetCfgComponent * of the last component on the path
//      ppszInterfaceName   [out]   The interface name of the last binding interface of the path
//
//  Returns:    S_OK, or an error.
//
//  Author:     tongl   5 Dec 1997
//
//  Notes:
//
HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pncbp,
    INetCfgComponent** ppncc,
    PWSTR* ppszInterfaceName)
{
    Assert(pncbp);

    // Initialize output parameters.
    //
    *ppncc = NULL;
    if (ppszInterfaceName)
    {
        *ppszInterfaceName = NULL;
    }

    // Enumerate binding interfaces and keep track of
    // the last interface.
    //
    HRESULT hr = S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface* pncbi;
    INetCfgBindingInterface* pncbiLast = NULL;

    while(SUCCEEDED(hr) && (hr = ncbiIter.HrNext(&pncbi)) == S_OK)
    {
        ReleaseObj (pncbiLast);
        pncbiLast = pncbi;
    }

    if (S_FALSE == hr) // we got to the end of the loop
    {
        hr = S_OK;

        Assert (pncbiLast);

        INetCfgComponent* pnccLowerComponent;
        hr = pncbiLast->GetLowerComponent(&pnccLowerComponent);
        if (S_OK == hr)
        {
            // Get the name of the interface if requested.
            //
            if (ppszInterfaceName)
            {
                hr = pncbiLast->GetName(ppszInterfaceName);
            }

            // If we've succeded everything, (including the optional
            // return of the interface name above) then assign and addref
            // the output interface.
            //
            if (S_OK == hr)
            {
                AddRefObj (pnccLowerComponent);
                *ppncc = pnccLowerComponent;
            }

            // Important to release our use of this interface in case
            // we failed and didn't assign it as an output parameter.
            //
            ReleaseObj (pnccLowerComponent);
        }
    }

    // Don't forget to release the binding interface itself.
    //
    ReleaseObj (pncbiLast);

    TraceHr (ttidError, FAL, hr, FALSE, "HrGetLastComponentAndInterface");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\ncpnp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P N P . C P P
//
//  Contents:   Common code for PnP.
//
//  Notes:
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"
#include "ncpnp.h"
#include "ncstring.h"
#include "ncsvc.h"

extern const WCHAR c_szDevice[];


//+---------------------------------------------------------------------------
// Function:    HrSendServicePnpEvent
//
// Purpose:     Send to the service one of the net pnp control codes
//
// Parameters:
//          pszService - the service name to send the notification to
//          dwControl - the control code to send
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:   the following control codes are only allowed
//          SERVICE_CONTROL_PARAMCHANGE
//  Informs the service that service-specific parameters that it reads
//  when it starts have changed, and requests it to re-read its startup
//  parameters from whatever location they are stored in. The hService
//  handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDADD
// Informs a network service that a new component has been added to the
// set of components that it should bind to, and requests it to re-read
// its binding information and bind to the new component. The hService
// handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDREMOVE
// Informs a network service that a component has been removed from the
// set of components that it should bind to, and requests it to re-read
// its binding information and unbind from the removed component. The
// hService handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDENABLE
// Informs a network service that one of its previously disabled bindings
// has been enabled, and requests it to re-read its binding information and
// add the new binding. The hService handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDDISABLE
// Informs a network service that one of its bindings has been disabled, and
// requests it to re-read its binding information and unbind the disabled
// binding. The hService handle must have SERVICE_CHANGE_PARAM access.
// (Note: There is nothing network-specific about the Win32 service APIs today.
// This would be the first network-specific thing appearing in the docs.
// I think that's OK.)
//
HRESULT
HrSendServicePnpEvent (
    PCWSTR      pszService,
    DWORD       dwControl )
{
    Assert( pszService && 0 < lstrlen( pszService ) );
    Assert( (dwControl == SERVICE_CONTROL_PARAMCHANGE) ||
            (dwControl == SERVICE_CONTROL_NETBINDADD) ||
            (dwControl == SERVICE_CONTROL_NETBINDREMOVE) ||
            (dwControl == SERVICE_CONTROL_NETBINDENABLE) ||
            (dwControl == SERVICE_CONTROL_NETBINDDISABLE) );

    CServiceManager scm;
    CService service;
    HRESULT hr = scm.HrOpenService(&service, pszService, NO_LOCK, STANDARD_RIGHTS_READ | STANDARD_RIGHTS_WRITE | SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,  STANDARD_RIGHTS_READ | STANDARD_RIGHTS_WRITE | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_INTERROGATE | SERVICE_PAUSE_CONTINUE | SERVICE_USER_DEFINED_CONTROL);
    if (S_OK == hr)
    {
        TraceTag(ttidNetCfgPnp,
                "HrSendServicePnpEvent( service- %S, control- %d )",
                pszService,
                dwControl );

        hr = service.HrControl( dwControl );
    }

    TraceError( "HrSendServicePnpEvent", hr );
    return  hr;
}

//+---------------------------------------------------------------------------
// Function:    SetUnicodeString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      psz - the WSTR to use to initialize the UNICODE_STRING
//
// Notes:  This differs from the RtlInitUnicodeString in that the
//      MaximumLength value contains the terminating null
//
void
SetUnicodeString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR psz )
{
    Assert(pustr);
    Assert(psz);

    pustr->Buffer = const_cast<PWSTR>(psz);
    pustr->Length = wcslen(psz) * sizeof(WCHAR);
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
// Function:    SetUnicodeMultiString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//              multi string buffer
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      pmsz - the multi sz WSTR to use to initialize the UNICODE_STRING
//
void
SetUnicodeMultiString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR pmsz )
{
    AssertSz( pustr != NULL, "Invalid Argument" );
    AssertSz( pmsz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(pmsz);

    ULONG cb = CchOfMultiSzAndTermSafe(pustr->Buffer) * sizeof(WCHAR);
    Assert (cb <= USHRT_MAX);
    pustr->Length = (USHORT)cb;

    pustr->MaximumLength = pustr->Length;
}

//+---------------------------------------------------------------------------
// Function:    HrSendNdisHandlePnpEvent
//
// Purpose:     Send to Ndis a HandlePnpEvent notification
//
// Parameters:
//      uiLayer - either NDIS or TDI
//      uiOperation - either BIND, RECONFIGURE, or UNBIND
//      pszUpper - a WIDE string containing the upper component name
//      pszLower - a WIDE string containing the lower component name
//            This is one of the Export names from that component
//            The values NULL and c_szEmpty are both supported
//      pmszBindList - a WIDE string containing the NULL terminiated list of strings
//            representing the bindlist, vaid only for reconfigure
//            The values NULL and c_szEmpty are both supported
//      pvData - Pointer to ndis component notification data. Content
//            determined by each component.
//      dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:  Do not use this routine directly, see...
//                  HrSendNdisPnpBindOrderChange,
//                  HrSendNdisPnpReconfig
//
HRESULT
HrSendNdisHandlePnpEvent (
    UINT        uiLayer,
    UINT        uiOperation,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PCWSTR      pmszBindList,
    PVOID       pvData,
    DWORD       dwSizeData)
{
    UNICODE_STRING    umstrBindList;
    UNICODE_STRING    ustrLower;
    UNICODE_STRING    ustrUpper;
    UINT nRet;
    HRESULT hr = S_OK;

    Assert(NULL != pszUpper);
    Assert((NDIS == uiLayer)||(TDI == uiLayer));
    Assert( (BIND == uiOperation) || (RECONFIGURE == uiOperation) ||
            (UNBIND == uiOperation) || (UNLOAD == uiOperation) ||
            (REMOVE_DEVICE == uiOperation));
    AssertSz( FImplies( ((NULL != pmszBindList) && (0 != lstrlenW( pmszBindList ))),
            (RECONFIGURE == uiOperation) &&
            (TDI == uiLayer) &&
            (0 == lstrlenW( pszLower ))),
            "bind order change requires a bind list, no lower, only for TDI, "
            "and with Reconfig for the operation" );

    // optional strings must be sent as empty strings
    //
    if (NULL == pszLower)
    {
        pszLower = c_szEmpty;
    }
    if (NULL == pmszBindList)
    {
        pmszBindList = c_szEmpty;
    }

    // build UNICDOE_STRINGs
    SetUnicodeMultiString( &umstrBindList, pmszBindList );
    SetUnicodeString( &ustrUpper, pszUpper );
    SetUnicodeString( &ustrLower, pszLower );

    TraceTag(ttidNetCfgPnp,
                "HrSendNdisHandlePnpEvent( layer- %d, op- %d, upper- %S, lower- %S, &bindlist- %08lx, &data- %08lx, sizedata- %d )",
                uiLayer,
                uiOperation,
                pszUpper,
                pszLower,
                pmszBindList,
                pvData,
                dwSizeData );

    // Now submit the notification
    nRet = NdisHandlePnPEvent( uiLayer,
            uiOperation,
            &ustrLower,
            &ustrUpper,
            &umstrBindList,
            (PVOID)pvData,
            dwSizeData );
    if (!nRet)
    {
        hr = HrFromLastWin32Error();

        // If the transport is not started, ERROR_FILE_NOT_FOUND is expected
        // when the NDIS layer is notified.  If the components of the TDI
        // layer aren't started, we get ERROR_GEN_FAILURE.  We need to map
        // these to one consistent error

        if ((HRESULT_FROM_WIN32(ERROR_GEN_FAILURE) == hr) && (TDI == uiLayer))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

    TraceError( "HrSendNdisHandlePnpEvent",
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr );
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    HrSendNdisPnpReconfig
//
// Purpose:     Send to Ndis a HandlePnpEvent reconfig notification
//
// Parameters:  uiLayer - either NDIS or TDI
//              pszUpper - a WIDE string containing the upper component name
//                         (typically a protocol)
//              pszLower - a WIDE string containing the lower component name
//                         (typically an adapter bindname) The values NULL and
//                         c_szEmpty are both supported
//              pvData - Pointer to ndis component notification data. Content
//                       determined by each component.
//              dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
HRESULT
HrSendNdisPnpReconfig (
    UINT        uiLayer,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PVOID       pvData,
    DWORD       dwSizeData)
{
    Assert(NULL != pszUpper);
    Assert((NDIS == uiLayer) || (TDI == uiLayer));

    HRESULT hr;
    tstring strLower;

    // If a lower component is specified, prefix with "\Device\" else
    // strLower's default of an empty string will be used.
    if (pszLower && *pszLower)
    {
        strLower = c_szDevice;
        strLower += pszLower;
    }

    hr = HrSendNdisHandlePnpEvent(
                uiLayer,
                RECONFIGURE,
                pszUpper,
                strLower.c_str(),
                c_szEmpty,
                pvData,
                dwSizeData);

    TraceError("HrSendNdisPnpReconfig",
              (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <devguid.h>
#include <setupapi.h>
#include <tchar.h>

#include "ncmem.h"

#include "list"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\notifval.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N O T I F V A L . C P P
//
//  Contents:   Validation routines for the INetCfgNotify interfaces.
//
//  Notes:
//
//  Author:     shaunco   14 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "netcfgn.h"
#include "notifval.h"



//+---------------------------------------------------------------------------
// INetCfgNotify
//

BOOL FBadArgs_INetCfgNotify_Initialize (INetCfgComponent* a, INetCfg* b, BOOL c)
{
    return FBadInPtr(a) || FBadInPtr(b);
}

BOOL FBadArgs_INetCfgNotify_ReadAnswerFile (PCWSTR c, PCWSTR d)
{
    return FBadInPtr(c) || FBadInPtr(d);
}

BOOL FBadArgs_INetCfgNotify_Validate (HWND a)
{
    return a && !IsWindow(a);
}


//+---------------------------------------------------------------------------
// INetCfgProperties
//

BOOL FBadArgs_INetCfgProperties_MergePropPages (DWORD* a, LPBYTE* b, UINT* c, HWND hwnd, PCWSTR *psz)
{
    BOOL fRet = FALSE;

    if (!FBadOutPtr (b))
    {
        *b = NULL;
    }
    else
    {
        fRet = TRUE;
    }

    if (!FBadOutPtr (c))
    {
        *c = 0;
    }
    else
    {
        fRet = TRUE;
    }

    if (psz)
    {
        if (!FBadOutPtr(psz))
        {
            *psz = NULL;
        }
        else
        {
            fRet = TRUE;
        }
    }

    return fRet || FBadInPtr (a) || FBadOutPtr (a) || (hwnd && !IsWindow(hwnd));
}

BOOL FBadArgs_INetCfgProperties_ValidateProperties(HWND a)
{
    return a && !IsWindow(a);
}


//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//

BOOL FBadArgs_INetCfgSystemNotify_GetSupportedNotifications (DWORD* a)
{
    BOOL fRet = FALSE;

    if (!FBadOutPtr(a))
    {
        *a = 0;
    }
    else
    {
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcon\ncconv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O N V . H
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Aug 1998
//
//----------------------------------------------------------------------------

#include <atlbase.h>
#include "netconp.h"

class CPropertiesEx
{
public:
    CPropertiesEx(NETCON_PROPERTIES_EX* pPropsEx)
    {
        m_pPropsEx = pPropsEx;
    };

    ~CPropertiesEx() {};

    HRESULT GetField(IN int nField, OUT VARIANT& varElement);
    HRESULT SetField(IN int nField, IN const VARIANT& varElement);

protected:
    NETCON_PROPERTIES_EX* m_pPropsEx;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcon\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSERVICE
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcon\ncnetcon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C O N . C P P
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Aug 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
#include "nccom.h"
#include "ncnetcon.h"
#include "netconp.h"
#include "ncras.h"
#include "ncreg.h"
#include "ncconv.h"

//+---------------------------------------------------------------------------
//
//  Function:   FreeNetconProperties
//
//  Purpose:    Free the memory associated with the output parameter of
//              INetConnection->GetProperties.  This is a helper function
//              used by clients of INetConnection.
//
//  Arguments:
//      pProps  [in] The properties to free.
//
//  Returns:    nothing.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
VOID
FreeNetconProperties (
    IN NETCON_PROPERTIES* pProps)
{
    if (pProps)
    {
        CoTaskMemFree (pProps->pszwName);
        CoTaskMemFree (pProps->pszwDeviceName);
        CoTaskMemFree (pProps);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionPersistData
//
//  Purpose:    Get the persistent form of a connection.  This can be used
//              to later get back to the INetConnection interface with a call
//              to HrGetConnectionFromPersistData.
//
//  Arguments:
//      pConn   [in]  Connection to get persist data from.
//      ppbData [out] Address of where to return pointer to data.
//      pcbSize [out] Address of where to return the size of the data.
//      pclsid  [out] Address of where to return the CLSID of the connection.
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   20 Aug 1998
//
//  Notes:      Free *ppbData with MemFree.
//
HRESULT
HrGetConnectionPersistData (
    IN INetConnection* pConn,
    OUT BYTE** ppbData,
    OUT ULONG* pcbSize,
    OUT CLSID* pclsid OPTIONAL)
{
    Assert (pConn);
    Assert (ppbData);
    Assert (pcbSize);
    // pclsid is optional.

    // Initialize the output parameters.
    //
    *ppbData = NULL;
    *pcbSize = 0;
    if (pclsid)
    {
        *pclsid = GUID_NULL;
    }

    // Get the IPersistNetConnection interfaces.
    //
    IPersistNetConnection* pPersist;

	HRESULT hr = HrQIAndSetProxyBlanket(pConn, &pPersist);

    if (SUCCEEDED(hr))
    {
        // Return the CLSID if requested.
        //
        if (pclsid)
        {
            hr = pPersist->GetClassID (pclsid);
            TraceHr(ttidError, FAL, hr, FALSE, "pPersist->GetClassID");
        }

        if (SUCCEEDED(hr))
        {
            // Get the size required, allocated a buffer, and get the data.
            //

            BYTE* pbData;
            ULONG cbData;

            hr = pPersist->GetSizeMax (&cbData);

            TraceHr(ttidError, FAL, hr, FALSE, "pPersist->GetSizeMax");

            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;
                pbData = (BYTE*)MemAlloc (cbData);
                if (pbData)
                {
                    hr = pPersist->Save (pbData, cbData);

                    TraceHr(ttidError, FAL, hr, FALSE, "pPersist->Save");

                    if (SUCCEEDED(hr))
                    {
                        *ppbData = pbData;
                        *pcbSize = cbData;
                    }
                    else
                    {
                        MemFree (pbData);
                    }
                }
            }
        }

        ReleaseObj (pPersist);
    }

    TraceError("HrGetConnectionPersistData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionFromPersistData
//
//  Purpose:    Get an INetConnection interface given the persistent form of
//              the connection.
//
//  Arguments:
//      clsid  [in]  CLSID to CoCreateInstance with.
//      pbData [in]  Pointer to connection's persist data.
//      cbData [in]  Size of the data in bytes.
//      ppConn [out] Address of where to return the pointer to the
//                   INetConnection interface.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   2 Nov 1998
//
//  Notes:
//
HRESULT
HrGetConnectionFromPersistData (
    IN const CLSID& clsid,
    IN const BYTE* pbData,
    IN ULONG cbData,
    IN REFIID riid,
    OUT VOID** ppv)
{
    Assert (pbData);
    Assert (cbData);
    Assert (ppv);

    HRESULT hr;

    // Initialize the output parameter.
    //
    *ppv = NULL;

    // Create a connection object and get an IPersistNetConnection
    // interface pointer on it.
    //
    IPersistNetConnection* pPersist;
    hr = HrCreateInstance(
        clsid,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pPersist);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        // Initialize the connection object using the persist data.
        //
        hr = pPersist->Load (pbData, cbData);

        TraceHr(ttidError, FAL, hr, FALSE,
            "pPersist->Load: pbData=0x%p, cbData=%u",
            pbData, cbData);

        if (SUCCEEDED(hr))
        {
            // Return an INetConnection interface pointer.
            //
            hr = pPersist->QueryInterface(riid, ppv);

            TraceHr(ttidError, FAL, hr, FALSE, "pPersist->QueryInterface");

            if (SUCCEEDED(hr))
            {
                NcSetProxyBlanket (reinterpret_cast<IUnknown *>(*ppv));
            }
        }
        ReleaseObj (pPersist);
    }

    TraceError("HrGetConnectionFromPersistData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsValidConnectionName
//
//  Purpose:    Determines if the given connection name is valid.
//
//  Arguments:
//      pszName [in]     Connection name to test
//
//  Returns:    TRUE if name is valid, FALSE if not
//
//  Author:     danielwe   14 Sep 1998
//
//  Notes:
//
BOOL
FIsValidConnectionName (
    IN PCWSTR pszName)
{
    static const WCHAR c_szInvalidChars[] = L"\\/:*?\"<>|\t";

    const WCHAR*  pchName;

    if (lstrlen(pszName) > NETCON_MAX_NAME_LEN)
    {
        return FALSE;
    }

    DWORD dwNonSpaceChars = 0;
    for (pchName = pszName; pchName && *pchName; pchName++)
    {
        if (wcschr(c_szInvalidChars, *pchName))
        {
            return FALSE;
        }
        
        if (*pchName != L' ')
        {
            dwNonSpaceChars++;
        }
    }

    if (!dwNonSpaceChars)
    {
        return FALSE;
    }

    return TRUE;
}


#define REGKEY_NETWORK_CONNECTIONS \
    L"System\\CurrentControlSet\\Control\\Network\\Connections"

#define REGVAL_ATLEASTONELANSHOWICON \
    L"AtLeastOneLanShowIcon"

//+---------------------------------------------------------------------------
//
//  Function:   HrSafeArrayFromNetConPropertiesEx
//
//  Purpose:    Create a safe array that can be marshaled across processes.
//              
//              
//
//  Arguments:
//      pPropsEx        [in]  Properties to use to build the safe array.
//      ppsaProperties  [out] Safe array in which to store data.
//
//  Returns:    HRESULT
//
//  Author:     ckotze 19 Mar 2001
//
//  Notes:      Caller must free array and contents.
//              
//
HRESULT
HrSafeArrayFromNetConPropertiesEx (
    IN      NETCON_PROPERTIES_EX* pPropsEx,
    OUT     SAFEARRAY** ppsaProperties)
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND rgsaBound[1] = {0};
    
    if (!pPropsEx)
    {
        return E_INVALIDARG;
    }
    if (!ppsaProperties)
    {
        return E_POINTER;
    }

    rgsaBound[0].cElements = NCP_ELEMENTS;
    rgsaBound[0].lLbound = 0;
    
    *ppsaProperties = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
    if (*ppsaProperties)
    {
        CPropertiesEx peProps(pPropsEx);

        for (LONG i = NCP_DWSIZE; i <= NCP_MAX; i++)
        {
            CComVariant varField;
            hr = peProps.GetField(i, varField);
            if (SUCCEEDED(hr))
            {
                hr = SafeArrayPutElement(*ppsaProperties, &i, reinterpret_cast<void*>(&varField));
            }
            
            if (FAILED(hr))
            {
                break;
            }
                
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSafeArrayFromNetConPropertiesEx");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNetConPropertiesExFromSafeArray
//
//  Purpose:    Rebuilds a NETCON_PROPERTIES_EX* structure from the safearray.
//              
//              
//
//  Arguments:
//      psaProperties  [in]  The safe array containing the data
//      ppPropsEx      [out] Structure containing the properties
//
//  Returns:    HRESULT - S_OK if valid, else an error.
//
//  Author:     ckotze   19 Mar 2001
//
//  Notes:      Caller must free ppPropsEx using HrFreeNetConProperties2
//
HRESULT HrNetConPropertiesExFromSafeArray(
    IN      SAFEARRAY* psaProperties,
    OUT     NETCON_PROPERTIES_EX** ppPropsEx)
{
    HRESULT hr = S_OK;
    LONG lLBound;
    LONG lUBound;
    
    if (!psaProperties)
    {
        return E_INVALIDARG;
    }

    *ppPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));

    if (*ppPropsEx)
    {
        hr = SafeArrayGetLBound(psaProperties, 1, &lLBound);
        if (SUCCEEDED(hr))
        {
            hr = SafeArrayGetUBound(psaProperties, 1, &lUBound);
            if (SUCCEEDED(hr))
            {
                CPropertiesEx PropEx(*ppPropsEx);

                for (LONG i = lLBound; i <= lUBound; i++)
                {
                    CComVariant varField;
                    hr = SafeArrayGetElement(psaProperties, &i, reinterpret_cast<LPVOID>(&varField));
                    if (SUCCEEDED(hr))
                    {
                        hr = PropEx.SetField(i, varField);
                    }

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrNetConPropertiesExFromSafeArray");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFreeNetConProperties2
//
//  Purpose:    Free all strings in the structure and then free the structure.
//              
//              
//
//  Arguments:
//      pPropsEx  [in] The properties to free.
//
//  Returns:    HRESULT - S_OK if success else an error 
//
//  Author:     ckotze   19 Mar 2001
//
//  Notes:
//
HRESULT HrFreeNetConProperties2(NETCON_PROPERTIES_EX* pPropsEx)
{
    HRESULT hr = S_OK;
    
    if (pPropsEx)
    {
        if (pPropsEx->bstrName)
        {
            SysFreeString(pPropsEx->bstrName);
        }

        if (pPropsEx->bstrDeviceName)
        {
            SysFreeString(pPropsEx->bstrDeviceName);
        }

        if (pPropsEx->bstrPhoneOrHostAddress)
        {
            SysFreeString(pPropsEx->bstrPhoneOrHostAddress);
        }
        if (pPropsEx->bstrPersistData)
        {
            SysFreeString(pPropsEx->bstrPersistData);
        }
        
        CoTaskMemFree(pPropsEx);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncoc\ncoc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C O C . C P P
//
//  Contents:   Common functions related to optional components
//
//  Notes:
//
//  Author:     danielwe   18 Dec 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncinf.h"
#include "ncmisc.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "ncsnmp.h"
#include "ncoc.h"
#include "ncsvc.h"
#include <winspool.h>  // Print monitor routines
#include "ncmisc.h"

// SNMP Agent extension
static const WCHAR  c_szSNMPSuffix[]    = L"SNMPAgent";
static const WCHAR  c_szSNMPAddLabel[]  = L"AddAgent";
static const WCHAR  c_szSNMPDelLabel[]  = L"DelAgent";

static const WCHAR  c_szServiceName[]   = L"ServiceName";
static const WCHAR  c_szAgentName[]     = L"AgentName";
static const WCHAR  c_szAgentPath[]     = L"AgentPath";

// Print extension
static const WCHAR  c_szPrintSuffix[]   = L"PrintMonitor";
static const WCHAR  c_szPrintAddLabel[] = L"AddMonitor";
static const WCHAR  c_szPrintDelLabel[] = L"DelMonitor";

static const WCHAR  c_szPrintMonitorName[]  = L"PrintMonitorName";
static const WCHAR  c_szPrintMonitorDLL[]   = L"PrintMonitorDLL";
static const WCHAR  c_szPrintProcName[]     = L"PrintProcName";
static const WCHAR  c_szPrintProcDLL[]      = L"PrintProcDLL";

static const WCHAR  c_szExternalAppCmdLine[]       = L"CommandLine";
static const WCHAR  c_szExternalAppCmdShow[]       = L"WindowStyle";
static const WCHAR  c_szExternalAppDirectory[]     = L"Directory";

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessSNMPAddSection
//
//  Purpose:    Parses the AddSNMPAgent section for parameters then adds the
//              component as an SNMP agent.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise.
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:
//
HRESULT HrProcessSNMPAddSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strServiceName;
    tstring     strAgentName;
    tstring     strAgentPath;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szServiceName,
                               &strServiceName);
    if (S_OK == hr)
    {
        hr = HrSetupGetFirstString(hinfFile, szSection, c_szAgentName,
                                   &strAgentName);
        if (S_OK == hr)
        {
            hr = HrSetupGetFirstString(hinfFile, szSection, c_szAgentPath,
                                       &strAgentPath);
            if (S_OK == hr)
            {
                TraceTag(ttidInfExt, "Adding SNMP agent %S...",
                         strAgentName.c_str());
                hr = HrAddSNMPAgent(strServiceName.c_str(),
                                    strAgentName.c_str(),
                                    strAgentPath.c_str());
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessSNMPAddSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessSNMPRemoveSection
//
//  Purpose:    Handles removal of an SNMP agent.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:
//
HRESULT HrProcessSNMPRemoveSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strAgentName;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szAgentName,
                               &strAgentName);
    if (S_OK == hr)
    {
        hr = HrRemoveSNMPAgent(strAgentName.c_str());
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessSNMPRemoveSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessPrintAddSection
//
//  Purpose:    Parses the AddPrintMonitor section for parameters then adds the
//              monitor.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise.
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrProcessPrintAddSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strPrintMonitorName;
    tstring     strPrintMonitorDLL;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintMonitorName,
            &strPrintMonitorName);
    if (S_OK == hr)
    {
        hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintMonitorDLL,
                &strPrintMonitorDLL);
        if (S_OK == hr)
        {
            hr = HrAddPrintMonitor(
                    strPrintMonitorName.c_str(),
                    strPrintMonitorDLL.c_str());
            if (S_OK == hr)
            {
                tstring     strPrintProcName;
                tstring     strPrintProcDLL;

                hr = HrSetupGetFirstString(hinfFile, szSection,
                                           c_szPrintProcName,
                                           &strPrintProcName);
                if (S_OK == hr)
                {
                    hr = HrSetupGetFirstString(hinfFile, szSection,
                                               c_szPrintProcDLL,
                                               &strPrintProcDLL);
                    if (S_OK == hr)
                    {
                        hr = HrAddPrintProc(strPrintProcDLL.c_str(),
                                            strPrintProcName.c_str());
                    }
                }
                else
                {
                    if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
                    {
                        // Print proc's are optional.
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessPrintAddSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessPrintRemoveSection
//
//  Purpose:    Handles removal of a print monitor.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrProcessPrintRemoveSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strPrintMonitorName;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintMonitorName,
            &strPrintMonitorName);
    if (S_OK == hr)
    {
        hr = HrRemovePrintMonitor(strPrintMonitorName.c_str());
        if (S_OK == hr)
        {
            tstring     strPrintProcName;

            hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintProcName,
                                       &strPrintProcName);
            if (S_OK == hr)
            {
                hr = HrRemovePrintProc(strPrintProcName.c_str());
            }
            else
            {
                if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
                {
                    // Print proc's are optional.
                    hr = S_OK;
                }
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_BUSY) == hr)
        {
            // Consume the device busy error.  NT4 and NT 3.51 had
            // the same limitation
            hr = S_OK;
        }
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessPrintRemoveSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddPrintProc
//
//  Purpose:    Adds a new print procedure.
//
//  Arguments:
//      szDLLName [in]  File name of DLL in which proc resides.
//      szProc    [in]  Name of procedure to add.
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrAddPrintProc(PCWSTR szDLLName, PCWSTR szProc)
{
    HRESULT     hr = S_OK;

    if (!AddPrintProcessor(NULL, NULL, const_cast<PWSTR>(szDLLName),
                           const_cast<PWSTR>(szProc)))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED))
        {
            // Don't complain if processor is already installed.
            hr = S_OK;
        }
    }

    TraceError("HrAddPrintProc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemovePrintProc
//
//  Purpose:    Removes a print procedure.
//
//  Arguments:
//      szProc    [in]  Name of procedure to remove.
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrRemovePrintProc(PCWSTR szProc)
{
    HRESULT     hr = S_OK;

    if (!DeletePrintProcessor(NULL, NULL, const_cast<PWSTR>(szProc)))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_UNKNOWN_PRINTPROCESSOR))
        {
            // Don't complain if print processor doesn't exist.
            hr = S_OK;
        }
    }

    TraceError("HrFromLastWin32Error", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddPrintMonitor
//
//  Purpose:    Adds a print monitor
//
//  Arguments:
//      szPrintMonitorName  [in]    The name of the print monitor being added
//      szPrintMonitorDLL [in]      The DLL associated with the monitor
//
//  Returns:    S_OK if success, WIN32 HRESULT otherwise
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrAddPrintMonitor(PCWSTR szPrintMonitorName,
                          PCWSTR szPrintMonitorDLL)
{
    HRESULT     hr = S_OK;

    MONITOR_INFO_2  moninfoTemp =
    {
        const_cast<WCHAR*>(szPrintMonitorName),
        NULL,
        const_cast<WCHAR*>(szPrintMonitorDLL)
    };

    //$ REVIEW (danielwe) 23 Mar 1998: Need Spooler team to add support to
    // PrintMonitor APIs to start Spooler if needed. Bug #149775

retry:
    // According to MSDN, first param is NULL, second is 2
    // third is the monitor
    TraceTag(ttidInfExt, "Adding print monitor...");
    if (!AddMonitor(NULL, 2, (BYTE*)&moninfoTemp))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_PRINT_MONITOR_ALREADY_INSTALLED))
        {
            // Don't complain if it's already there.
            hr = S_OK;
        }
        else if (hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE))
        {
            // Spooler service isn't started. We need to start it
            TraceTag(ttidInfExt, "Spooler service wasn't started. Starting"
                     " it now...");
            hr = HrEnableAndStartSpooler();
            if (S_OK == hr)
            {
                TraceTag(ttidInfExt, "Spooler service started successfully. "
                         "Retrying...");
                goto retry;
            }
        }
    }

    TraceTag(ttidInfExt, "Done adding print monitor...");

    TraceError("HrAddPrintMonitor", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemovePrintMonitor
//
//  Purpose:    Removes a print monitor
//
//  Arguments:
//      szPrintMonitorName  [in]    The name of the print monitor being removed
//
//  Returns:    S_OK if success, WIN32 HRESULT otherwise
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrRemovePrintMonitor(PCWSTR szPrintMonitorName)
{
    HRESULT     hr = S_OK;

    //$ REVIEW (danielwe) 23 Mar 1998: Need Spooler team to add support to
    // PrintMonitor APIs to start Spooler if needed. Bug #149775

retry:
    // According to MSDN, first param is NULL, second is NULL,
    // third is the monitor
    TraceTag(ttidInfExt, "Removing print monitor...");
    if (!DeleteMonitor(NULL, NULL, const_cast<WCHAR*>(szPrintMonitorName)))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_UNKNOWN_PRINT_MONITOR))
        {
            // Don't complain if monitor is unknown.
            hr = S_OK;
        }
        else if (hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE))
        {
            // Spooler service isn't started. We need to start it
            TraceTag(ttidInfExt, "Spooler service wasn't started. Starting"
                     " it now...");
            hr = HrEnableAndStartSpooler();
            if (S_OK == hr)
            {
                TraceTag(ttidInfExt, "Spooler service started successfully. "
                         "Retrying...");
                goto retry;
            }
        }
    }

    TraceTag(ttidInfExt, "Done removing print monitor...");

    TraceError("HrRemovePrintMonitor", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessAllINFExtensions
//
//  Purpose:    Handles support for all optional component extensions to the
//              INF file format.
//
//  Arguments:
//      hinfFile         [in]   handle to INF to process
//      szInstallSection [in]   Install section to process
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     jeffspr   14 May 1997
//
//  Notes:
//
HRESULT HrProcessAllINFExtensions(HINF hinfFile, PCWSTR szInstallSection)
{
    HRESULT     hr = S_OK;

    //
    // Handle SNMP Agent extension
    //
    hr = HrProcessInfExtension(hinfFile, szInstallSection, c_szSNMPSuffix,
                               c_szSNMPAddLabel, c_szSNMPDelLabel,
                               HrProcessSNMPAddSection,
                               HrProcessSNMPRemoveSection);
    if (FAILED(hr) && hr != HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        goto err;

    //
    // Handle Print monitor/procedure extension
    //
    hr = HrProcessInfExtension(hinfFile, szInstallSection, c_szPrintSuffix,
                               c_szPrintAddLabel, c_szPrintDelLabel,
                               HrProcessPrintAddSection,
                               HrProcessPrintRemoveSection);

    if (FAILED(hr) && hr != HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        goto err;

    hr = S_OK;

err:
    TraceError("HrProcessAllINFExtensions", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcon\ncconv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O N V . C P P
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncconv.h"

HRESULT SysCopyBString(BSTR *bstrDestination, const BSTR bstrSource)
{
    HRESULT hr = S_OK;
    if (bstrSource)
    {
        *bstrDestination = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(bstrSource), SysStringByteLen(bstrSource));
        if (!*bstrDestination)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *bstrDestination = SysAllocString(NULL);
    }
    return hr;
}

HRESULT CPropertiesEx::GetField(IN int nField, OUT VARIANT& varElement)
{
    HRESULT hr = S_OK;

    WCHAR szGuid[MAX_GUID_STRING_LEN];
    
    switch (nField)
    {
    case NCP_DWSIZE:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->dwSize;
        break;
    case NCP_GUIDID:
        if (StringFromGUID2(m_pPropsEx->guidId, szGuid, MAX_GUID_STRING_LEN))
        {
            varElement.vt = VT_BSTR;
            varElement.bstrVal = SysAllocString(szGuid);
            if (!varElement.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRNAME:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrName);
        break;
    case NCP_BSTRDEVICENAME:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrDeviceName);
        break;
    case NCP_NCSTATUS:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->ncStatus;
        break;
    case NCP_MEDIATYPE:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->ncMediaType;
        break;
    case NCP_SUBMEDIATYPE:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->ncSubMediaType;        
        break;
    case NCP_DWCHARACTER:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->dwCharacter;        
        break;
    case NCP_CLSIDTHISOBJECT:
        if (StringFromGUID2(m_pPropsEx->clsidThisObject, szGuid, MAX_GUID_STRING_LEN))
        {
            varElement.vt = VT_BSTR;
            varElement.bstrVal = SysAllocString(szGuid);
            if (!varElement.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_CLSIDUIOBJECT:
        if (StringFromGUID2(m_pPropsEx->clsidUiObject, szGuid, MAX_GUID_STRING_LEN))
        {
            varElement.vt = VT_BSTR;
            varElement.bstrVal = SysAllocString(szGuid);
            if (!varElement.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
        }        
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRPHONEORHOSTADDRESS:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrPhoneOrHostAddress);
        break;
    case NCP_BSTRPERSISTDATA:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrPersistData);
        break;
    default:
        AssertSz(FALSE, "Field is not in list, have you updated the list?");
    }

    AssertSz(SUCCEEDED(hr), "Could not GetField");
    TraceHr (ttidError, FAL, hr, FALSE, "GetField");

    return hr;
}

HRESULT CPropertiesEx::SetField(IN int nField, IN const VARIANT& varElement)
{
    HRESULT hr = S_OK;
    
    switch (nField) 
    {
    case NCP_DWSIZE:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->dwSize = varElement.ulVal;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_GUIDID:
        if (VT_BSTR == varElement.vt)
        {
            hr = CLSIDFromString(varElement.bstrVal, &m_pPropsEx->guidId);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRNAME:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrName, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRDEVICENAME:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrDeviceName, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_NCSTATUS:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->ncStatus = static_cast<NETCON_STATUS>(varElement.ulVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_MEDIATYPE:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->ncMediaType = static_cast<NETCON_MEDIATYPE>(varElement.ulVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_SUBMEDIATYPE:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->ncSubMediaType = static_cast<NETCON_SUBMEDIATYPE>(varElement.ulVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }

        break;
    case NCP_DWCHARACTER:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->dwCharacter = varElement.ulVal;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_CLSIDTHISOBJECT:
        if (VT_BSTR == varElement.vt)
        {
            hr = CLSIDFromString(varElement.bstrVal, &m_pPropsEx->clsidThisObject);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_CLSIDUIOBJECT:
        if (VT_BSTR == varElement.vt)
        {
            hr = CLSIDFromString(varElement.bstrVal, &m_pPropsEx->clsidUiObject);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRPHONEORHOSTADDRESS:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrPhoneOrHostAddress, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRPERSISTDATA:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrPersistData, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
 
    default:
        AssertSz(FALSE, "Field is not in list, have you updated the list?");
    }
    
    TraceHr (ttidError, FAL, hr, FALSE, "SetField");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncoc\ncsnmp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S N M P . H
//
//  Contents:   Functions for adding a service as an SNMP agent.
//
//  Notes:
//
//  Author:     danielwe   8 Apr 1997
//
//----------------------------------------------------------------------------

#ifndef _NCSNMP_H
#define _NCSNMP_H
#pragma once

HRESULT HrGetNextAgentNumber(PCWSTR pszAgentName, DWORD *pdwNumber);
HRESULT HrAddSNMPAgent(PCWSTR pszServiceName, PCWSTR pszAgentName,
                       PCWSTR pszAgentPath);
HRESULT HrRemoveSNMPAgent(PCWSTR pszAgentName);

#endif //! _NCSNMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncoc\ncsnmp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S N M P . C P P
//
//  Contents:   Functions for adding a service as an SNMP agent.
//
//  Notes:
//
//  Author:     danielwe   8 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncsnmp.h"
#include "ncreg.h"

extern const WCHAR  c_szBackslash[];
extern const WCHAR  c_szEmpty[];
extern const WCHAR  c_szRegKeyServices[];

static const WCHAR  c_szSNMP[]          = L"SNMP";
static const WCHAR  c_szSNMPParams[]    = L"SNMP\\Parameters";
static const WCHAR  c_szSoftwareKey[]   = L"SOFTWARE\\Microsoft";
static const WCHAR  c_szAgentsKey[]     = L"SNMP\\Parameters\\ExtensionAgents";
static const WCHAR  c_szAgentsKeyAbs[]  = L"System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ExtensionAgents";
static const WCHAR  c_szParamsKeyAbs[]  = L"System\\CurrentControlSet\\Services\\SNMP\\Parameters";
static const WCHAR  c_szCurrentVersion[]= L"CurrentVersion";
static const WCHAR  c_szPathName[]      = L"Pathname";

struct SNMP_REG_DATA
{
    PCWSTR     pszAgentPath;
    PCWSTR     pszExtAgentValueName;
    PCWSTR     pszEmpty;
};

//+---------------------------------------------------------------------------
//
//  Function:   HrGetNextAgentNumber
//
//  Purpose:    Obtains the next agent number to use as a value name.
//
//  Arguments:
//      pszAgentName [in]      Name of agent being added
//      pdwNumber    [out]     New agent number to use.
//
//  Returns:    S_OK if successful, S_FALSE if agent already exists, or
//              WIN32 error code otherwise.
//
//  Author:     danielwe   8 Apr 1997
//
//  Notes:
//
HRESULT HrGetNextAgentNumber(PCWSTR pszAgentName, DWORD *pdwNumber)
{
    HRESULT         hr = S_OK;
    HKEY            hkeyEnum;
    DWORD           dwIndex = 0;

    Assert(pdwNumber);

    *pdwNumber = 0;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szAgentsKeyAbs, KEY_READ,
                        &hkeyEnum);
    if (S_OK == hr)
    {
        // Enumerate all values.
        do
        {
            WCHAR   szValueName [_MAX_PATH];
            DWORD   cchValueName = celems (szValueName);
            DWORD   dwType;

            hr = HrRegEnumValue(hkeyEnum, dwIndex,
                                szValueName, &cchValueName,
                                &dwType, NULL, 0);
            if (S_OK == hr)
            {
                // Verify the type. If it's not correct, though,
                // we'll ignore the key. No sense failing the entire install
                // (RAID 370702)
                //
                if (REG_SZ == dwType)
                {
                    tstring     strAgent;

                    hr = HrRegQueryString(hkeyEnum, szValueName, &strAgent);
                    if (S_OK == hr)
                    {
                        if (strAgent.find(pszAgentName, 0) != tstring::npos)
                        {
                            hr = S_FALSE;
                        }
                    }
                }
                else
                {
                    // No sense failing the install, but it's still wrong, so
                    // assert
                    //
                    AssertSz(REG_SZ == dwType,
                             "HrGetNextAgentNumber: Expected a type of REG_SZ.");
                }
            }
            else if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hr)
            {
                hr = S_OK;
                break;
            }

            dwIndex++;
        }
        while (hr == S_OK);

        RegCloseKey(hkeyEnum);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // danielwe: 403774 - If key doesn't exist, SNMP isn't installed so
        // we should not continue.
        hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        *pdwNumber = dwIndex + 1;
    }

    TraceError("HrGetNextAgentNumber", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddSNMPAgent
//
//  Purpose:    Adds a service as an SNMP agent.
//
//  Arguments:
//      pszServiceName [in]  Name of service to add (i.e. "WINS")
//      pszAgentName   [in]  Name of the agent to add (i.e. "WINSMibAgent")
//      pszAgentPath   [in]  Path to where the agent DLL lives.
//                           (i.e. "%SystemRoot%\System32\winsmib.dll")
//
//  Returns:    S_OK if successful, WIN32 error code otherwise.
//
//  Author:     danielwe   8 Apr 1997
//
//  Notes:
//
HRESULT HrAddSNMPAgent(PCWSTR pszServiceName, PCWSTR pszAgentName,
                       PCWSTR pszAgentPath)
{
    HRESULT         hr = S_OK;
    HKEY            hkeySNMP;
    HKEY            hkeyService;
    HKEY            hkeyServices;
    DWORD           dwNum;

    SNMP_REG_DATA   srd = {pszAgentPath, const_cast<PCWSTR>(c_szEmpty),
                           const_cast<PCWSTR>(c_szEmpty)};

    tstring         strKeyAgentName;
    tstring         strKeyAgentNameCurVer;
    tstring         strKeyAgentNameParams;

    // Open HKEY_LOCAL_MACHINE\System\CCS\Services key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServices,
                        KEY_READ_WRITE, &hkeyServices);
    if (SUCCEEDED(hr))
    {
        // Open Services\SNMP key
        hr = HrRegOpenKeyEx(hkeyServices, c_szSNMP, KEY_READ_WRITE,
                            &hkeySNMP);
        if (SUCCEEDED(hr))
        {
            hr = HrGetNextAgentNumber(pszAgentName, &dwNum);
            if (S_OK == hr)
            {
                // Open the Services\szService key
                hr = HrRegOpenKeyEx(hkeyServices, pszServiceName,
                                    KEY_READ_WRITE, &hkeyService);
                if (SUCCEEDED(hr))
                {
                    try
                    {
                        // Create key name: "SOFTWARE\Microsoft\<AgentName>
                        strKeyAgentName = c_szSoftwareKey;
                        strKeyAgentName.append(c_szBackslash);
                        strKeyAgentName.append(pszAgentName);

                        // Create key name: "SNMP\Parameters\\<AgentName>
                        strKeyAgentNameParams = c_szSNMPParams;
                        strKeyAgentNameParams.append(c_szBackslash);
                        strKeyAgentNameParams.append(pszAgentName);

                        // Create key name: "SOFTWARE\Microsoft\<AgentName>\CurrentVersion
                        // Start with "SOFTWARE\Microsoft\<AgentName> and append a
                        // backslash and then the constant "CurrentVersion"
                        strKeyAgentNameCurVer = strKeyAgentName;
                        strKeyAgentNameCurVer.append(c_szBackslash);
                        strKeyAgentNameCurVer.append(c_szCurrentVersion);
                    }
                    catch (bad_alloc)
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (SUCCEEDED(hr))
                    {
                        static const WCHAR c_szFmt[] = L"%lu";
                        WCHAR   szAgentNumber[64];

                        wsprintfW(szAgentNumber, c_szFmt, dwNum);
                        srd.pszExtAgentValueName = strKeyAgentNameCurVer.c_str();

                        REGBATCH rbSNMPData[] =
                        {
                            {                   // Software\Microsoft\AgentName
                                HKEY_LOCAL_MACHINE,
                                strKeyAgentName.c_str(),
                                c_szEmpty,
                                REG_CREATE,     // Only create the key
                                offsetof(SNMP_REG_DATA, pszEmpty),
                                NULL
                            },
                            {                   // Software\Microsoft\AgentName\CurrentVersion
                                HKEY_LOCAL_MACHINE,
                                strKeyAgentNameCurVer.c_str(),
                                c_szPathName,
                                REG_EXPAND_SZ,
                                offsetof(SNMP_REG_DATA, pszAgentPath),
                                NULL
                            },
                            {                   // SNMP\Parameters\ExtensionAgents
                                HKLM_SVCS,
                                c_szAgentsKey,
                                szAgentNumber,
                                REG_SZ,
                                offsetof(SNMP_REG_DATA, pszExtAgentValueName),
                                NULL
                            },
                        };

                        hr = HrRegWriteValues(celems(rbSNMPData),
                                              reinterpret_cast<const REGBATCH *>
                                              (&rbSNMPData),
                                              reinterpret_cast<const BYTE *>(&srd),
                                              0, KEY_READ_WRITE);

                    }

                    RegCloseKey(hkeyService);
                }
                else
                {
                    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    {
                        // Ok if Service key does not exist. Means it is not
                        // installed so we do nothing and return S_OK;
                        hr = S_OK;
                    }
                }

            }

            RegCloseKey(hkeySNMP);
        }
        else
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                // Ok if SNMP key does not exist. Means it is not installed
                // so we do nothing and return S_OK;
                hr = S_OK;
            }
        }

        RegCloseKey(hkeyServices);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("HrAddSNMPAgent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveSNMPAgent
//
//  Purpose:    Removes a component as an SNMP agent
//
//  Arguments:
//      pszAgentName [in]    Name of agent to remove (i.e. WINSMibAgent)
//
//  Returns:    S_OK for success, WIN32 error otherwise
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:      Note that *ALL* entries related to this agent are removed, not
//              just the first one.
//
HRESULT HrRemoveSNMPAgent(PCWSTR pszAgentName)
{
    HRESULT     hr = S_OK;
    tstring     strKeyAgentName;
    tstring     strKeyAgentNameParams;

    try
    {
        // Create key name: "SOFTWARE\Microsoft\<AgentName>
        strKeyAgentName = c_szSoftwareKey;
        strKeyAgentName.append(c_szBackslash);
        strKeyAgentName.append(pszAgentName);
    }
    catch (bad_alloc)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        // Delete entire registry tree under SOFTWARE\Microsoft\<agent name>
        hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, strKeyAgentName.c_str());
        if (SUCCEEDED(hr) || (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
        {
            try
            {
                // Delete key:
                // "SYSTEM\CurrentControlSet\Services\SNMP\Parameters\\<AgentName>
                strKeyAgentNameParams = c_szParamsKeyAbs;
                strKeyAgentNameParams.append(c_szBackslash);
                strKeyAgentNameParams.append(pszAgentName);
            }
            catch (bad_alloc)
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr) || (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
            {
                // BUG# 510726, Ignore any errors about registry keys or values 
                // missing. We still want to continue to cleanup this subagent's
                // configuration in the registry.
                hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE, strKeyAgentNameParams.c_str());
                if ((hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) || SUCCEEDED(hr))
                {
                    HKEY    hkeyEnum;

                    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szAgentsKeyAbs,
                                        KEY_READ_WRITE_DELETE, &hkeyEnum);
                    if (SUCCEEDED(hr))
                    {
                        DWORD   dwIndex = 0;

                        // Enumerate all values.
                        do
                        {
                            WCHAR   szValueName [_MAX_PATH];
                            DWORD   cchValueName = celems (szValueName);
                            DWORD   dwType;
                            WCHAR   szValueData[_MAX_PATH];
                            DWORD   cchValueData = celems (szValueData);

                            hr = HrRegEnumValue(hkeyEnum, dwIndex,
                                                szValueName, &cchValueName,
                                                &dwType,
                                                reinterpret_cast<LPBYTE>(szValueData),
                                                &cchValueData);
                            if (SUCCEEDED(hr))
                            {
                                // It's type should be REG_SZ
                                AssertSz(REG_SZ == dwType,
                                         "HrGetNextAgentNumber: Expected a type of "
                                         "REG_SZ.");
                                if (FIsSubstr(pszAgentName, szValueData))
                                {
                                    // Delete value if the agent name is found in the
                                    // data. Don't break though, because there may be
                                    // duplicates for some reason so this will delete
                                    // those as well.
                                    hr = HrRegDeleteValue(hkeyEnum, szValueName);
                                }
                            }
                            else if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hr)
                            {
                                hr = S_OK;
                                break;
                            }

                            dwIndex++;
                        }
                        while (SUCCEEDED(hr));

                        RegCloseKey(hkeyEnum);
                    }
                }
            }
        }
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        // Ignore any errors about registry keys or values missing. We don't
        // want them there anyway so if they're not, who cares!?!?
        hr = S_OK;
    }

    TraceError("HrRemoveSNMPAgent", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncoc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <setupapi.h>
#include <stdio.h>
#include <tchar.h>

#include "ncmem.h"

#include "list"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncnetcfg\netinfid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T I N F I D . H
//
//  Contents:   Network Component IDs
//
//  Notes:
//
//  Author:     kumarp  13 Mar 1997
//
//----------------------------------------------------------------------------

#pragma hdrstop
#include "netcfgx.h"

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

//+---------------------------------------------------------------------------
// Network Adapters: GUID_DEVCLASS_NET

CONST_GLOBAL WCHAR c_szInfId_MS_AtmElan[]       = L"ms_atmelan";
CONST_GLOBAL WCHAR c_szInfId_MS_IrdaMiniport[]  = L"ms_irdaminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_IrModemMiniport[] = L"ms_irmodemminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_L2tpMiniport[]  = L"ms_l2tpminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanAtalk[]  = L"ms_ndiswanatalk";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanBh[]     = L"ms_ndiswanbh";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIp[]     = L"ms_ndiswanip";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIpx[]    = L"ms_ndiswanipx";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanNbfIn[]  = L"ms_ndiswannbfin";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanNbfOut[] = L"ms_ndiswannbfout";
CONST_GLOBAL WCHAR c_szInfId_MS_PppoeMiniport[] = L"ms_pppoeminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_PptpMiniport[]  = L"ms_pptpminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_PSchedMP[]      = L"ms_pschedmp";
CONST_GLOBAL WCHAR c_szInfId_MS_PtiMiniport[]   = L"ms_ptiminiport";


//+---------------------------------------------------------------------------
// Network Protocols: GUID_DEVCLASS_NETTRANS

CONST_GLOBAL WCHAR c_szInfId_MS_AppleTalk[]     = L"ms_appletalk";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmArps[]       = L"ms_atmarps";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmLane[]       = L"ms_atmlane";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmUni[]        = L"ms_atmuni";
CONST_GLOBAL WCHAR c_szInfId_MS_IrDA[]          = L"ms_irda";
CONST_GLOBAL WCHAR c_szInfId_MS_Isotpsys[]      = L"ms_isotpsys";
CONST_GLOBAL WCHAR c_szInfId_MS_L2TP[]          = L"ms_l2tp";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWan[]       = L"ms_ndiswan";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBEUI[]       = L"ms_netbeui";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBT[]         = L"ms_netbt";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBT_SMB[]     = L"ms_netbt_smb";
CONST_GLOBAL WCHAR c_szInfId_MS_NetMon[]        = L"ms_netmon";
CONST_GLOBAL WCHAR c_szInfId_MS_NWIPX[]         = L"ms_nwipx";
CONST_GLOBAL WCHAR c_szInfId_MS_NWNB[]          = L"ms_nwnb";
CONST_GLOBAL WCHAR c_szInfId_MS_NWSPX[]         = L"ms_nwspx";
CONST_GLOBAL WCHAR c_szInfId_MS_PPPOE[]         = L"ms_pppoe";
CONST_GLOBAL WCHAR c_szInfId_MS_PPTP[]          = L"ms_pptp";
CONST_GLOBAL WCHAR c_szInfId_MS_PSchedPC[]      = L"ms_pschedpc";
CONST_GLOBAL WCHAR c_szInfId_MS_RawWan[]        = L"ms_rawwan";
CONST_GLOBAL WCHAR c_szInfId_MS_Streams[]       = L"ms_streams";
CONST_GLOBAL WCHAR c_szInfId_MS_TCPIP[]         = L"ms_tcpip";
CONST_GLOBAL WCHAR c_szInfId_MS_NDISUIO[]       = L"ms_ndisuio";

//+---------------------------------------------------------------------------
// Network Services: GUID_DEVCLASS_NETSERVICE

CONST_GLOBAL WCHAR c_szInfId_MS_ALG[]           = L"ms_alg";
CONST_GLOBAL WCHAR c_szInfId_MS_DHCPServer[]    = L"ms_dhcpserver";
CONST_GLOBAL WCHAR c_szInfId_MS_FPNW[]          = L"ms_fpnw";
CONST_GLOBAL WCHAR c_szInfId_MS_GPC[]           = L"ms_gpc";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBIOS[]       = L"ms_netbios";
CONST_GLOBAL WCHAR c_szInfId_MS_NwSapAgent[]    = L"ms_nwsapagent";
CONST_GLOBAL WCHAR c_szInfId_MS_PSched[]        = L"ms_psched";
CONST_GLOBAL WCHAR c_szInfId_MS_RasCli[]        = L"ms_rascli";
CONST_GLOBAL WCHAR c_szInfId_MS_RasMan[]        = L"ms_rasman";
CONST_GLOBAL WCHAR c_szInfId_MS_RasSrv[]        = L"ms_rassrv";
CONST_GLOBAL WCHAR c_szInfId_MS_Server[]        = L"ms_server";
CONST_GLOBAL WCHAR c_szInfId_MS_Steelhead[]     = L"ms_steelhead";
CONST_GLOBAL WCHAR c_szInfId_MS_WLBS[]          = L"ms_wlbs";
CONST_GLOBAL WCHAR c_szInfId_MS_WZCSVC[]        = L"ms_wzcsvc";

//+---------------------------------------------------------------------------
// Network Clients: GUID_DEVCLASS_NETCLIENT

CONST_GLOBAL WCHAR c_szInfId_MS_MSClient[]      = L"ms_msclient";
CONST_GLOBAL WCHAR c_szInfId_MS_NWClient[]      = L"ms_nwclient";
CONST_GLOBAL WCHAR c_szInfId_MS_WebClient[]     = L"ms_webclient";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncras\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSERVICE
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\ncras\ncras.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R A S . C P P
//
//  Contents:   Common code for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   20 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncras.h"
#include "ncstring.h"
#include <raserror.h>
#include "mprapi.h"
//+---------------------------------------------------------------------------
//
//  Function:   RciFree
//
//  Purpose:    Frees the memory associated with a RASCON_INFO strucutre.
//
//  Arguments:
//      pRasConInfo [in]    Pointer to RASCON_INFO structure to free.
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:      CoTaskMemAlloc/CoTaskMemFree are used as the allocator/
//              deallocator because this structure is marshalled by COM.
//
VOID
RciFree (
    RASCON_INFO* pRasConInfo)
{
    Assert (pRasConInfo);

    CoTaskMemFree (pRasConInfo->pszwPbkFile);
    CoTaskMemFree (pRasConInfo->pszwEntryName);

    ZeroMemory (pRasConInfo, sizeof (*pRasConInfo));
}

//+---------------------------------------------------------------------------
//
//  Function:   FExistActiveRasConnections
//
//  Purpose:    Returns TRUE if there is at least one active RAS connection.
//              Both incoming and outgoing connections are checked.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if at least one incoming or outgoing RAS connection
//              in progress.  FALSE if not.
//
//  Author:     shaunco   8 Jul 1998
//
//  Notes:
//
BOOL
FExistActiveRasConnections ()
{
    BOOL              fExist         = FALSE;
    RASCONN           RasConn;
    DWORD             dwErr;
    DWORD             cbBuf;
    DWORD             cConnections;

    ZeroMemory (&RasConn, sizeof(RasConn));
    RasConn.dwSize = sizeof(RasConn);
    cbBuf = sizeof(RasConn);
    cConnections = 0;
    dwErr = RasEnumConnections (&RasConn, &cbBuf, &cConnections);
    if ((ERROR_SUCCESS == dwErr) || (ERROR_BUFFER_TOO_SMALL == dwErr))
    {
        fExist = (cbBuf > 0) || (cConnections > 0);
    }

    // If no outgoing connections active, check on incoming ones.
    //
    if (!fExist)
    {
        MPR_SERVER_HANDLE hMprServer;
        LPBYTE            lpbBuf         = NULL;
        DWORD             dwEntriesRead  = 0;
        DWORD             dwTotalEntries = 0;

        ZeroMemory (&hMprServer, sizeof(hMprServer));
        //get a handle to the local router ie. name = NULL
        dwErr = MprAdminServerConnect( NULL, &hMprServer );
        if (ERROR_SUCCESS == dwErr)
        {
            //retrieve a pointer to buffer containing all
            //incoming connections (ie dwPrefMaxLen = -1) and
            //the their count ( ie. dwTotalEntries ) 
            dwErr = MprAdminConnectionEnum( hMprServer,
                                            0,
                                            &lpbBuf,
                                            (DWORD)-1,
                                            &dwEntriesRead,
                                            &dwTotalEntries,
                                            NULL );
            if (ERROR_SUCCESS == dwErr)
            {
                fExist = (dwTotalEntries > 0);
		if( lpbBuf )
		{
		    MprAdminBufferFree( lpbBuf );
		    lpbBuf = NULL;
		}
            }
            // close the handle to the router
            MprAdminServerDisconnect( hMprServer );
        }
    }

    return fExist;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRciGetRasConnectionInfo
//
//  Purpose:    QI an INetConnection pointer for INetRasConnection and make
//              a call to GetRasConnectionInfo on it.
//
//  Arguments:
//      pCon        [in]    The connection to QI and call.
//      pRasConInfo [out]   The returned information.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   15 Nov 1997
//
//  Notes:
//
HRESULT
HrRciGetRasConnectionInfo (
    INetConnection* pCon,
    RASCON_INFO*    pRasConInfo)
{
    INetRasConnection* pRasCon;
    HRESULT hr = HrQIAndSetProxyBlanket(pCon, &pRasCon);
    if (S_OK == hr)
    {
        // Make the call to get the info and release the interface.
        //
        hr = pRasCon->GetRasConnectionInfo (pRasConInfo);

        ReleaseObj (pRasCon);
    }
    TraceError ("HrRciGetRasConnectionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasEnumAllActiveConnections
//
//  Purpose:    Enumerate and return all active RAS connections.
//
//  Arguments:
//      paRasConn [out] Pointer to returned allocation of RASCONN structures.
//      pcRasConn [out] Pointer to count of RASCONN structures returned.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:      The returned buffer must be freed using free.
//
HRESULT
HrRasEnumAllActiveConnections (
    RASCONN**   paRasConn,
    DWORD*      pcRasConn)
{
    // Allocate room for two active connections initially.  We'll update
    // this guess after we successfully allocate and find out how much was
    // really needed.  Saving it across calls will keep us from allocating
    // too much or too little.
    //
    static DWORD cbBufGuess = 2 * sizeof (RASCONN);

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *paRasConn = NULL;
    *pcRasConn = NULL;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASCONN* aRasConn = reinterpret_cast<RASCONN*>(MemAlloc (cbBuf));
    if (aRasConn)
    {
        aRasConn->dwSize = sizeof (RASCONN);

        DWORD cRasConn;
        DWORD dwErr = RasEnumConnections (aRasConn, &cbBuf, &cRasConn);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be one more than we got back
            // this time.
            //
            cbBufGuess = cbBuf + sizeof (RASCONN);

            if (cRasConn)
            {
                *paRasConn = aRasConn;
                *pcRasConn = cRasConn;
            }
            else
            {
                MemFree (aRasConn);
            }
        }
        else
        {
            MemFree (aRasConn);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasEnumConnections.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // In case RAS makes more calls by the time we get back
                // to enumerate with the bigger buffer, add room for a few
                // more.
                //
                cbBuf += 2 * sizeof (RASCONN);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasEnumAllActiveConnections", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasEnumAllActiveServerConnections
//
//  Purpose:    Enumerate and return all active RAS server connections.
//
//  Arguments:
//      paRasSrvConn [out]  Pointer to returned allocation of RASSRVCONN
//                          structures.
//      pcRasSrvConn [out]  Pointer to count of RASSRVCONN structures
//                          returned.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:      The returned buffer must be freed using free.
//
HRESULT
HrRasEnumAllActiveServerConnections (
    RASSRVCONN**    paRasSrvConn,
    DWORD*          pcRasSrvConn)
{
    // Allocate room for two active connections initially.  We'll update
    // this guess after we successfully allocate and find out how much was
    // really needed.  Saving it across calls will keep us from allocating
    // too much or too little.
    //
    static DWORD cbBufGuess = 2 * sizeof (RASSRVCONN);

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *paRasSrvConn = NULL;
    *pcRasSrvConn = NULL;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASSRVCONN* aRasSrvConn = reinterpret_cast<RASSRVCONN*>(MemAlloc (cbBuf));
    if (aRasSrvConn)
    {
        aRasSrvConn->dwSize = sizeof (RASSRVCONN);

        DWORD cRasSrvConn;
        DWORD dwErr = RasSrvEnumConnections (aRasSrvConn, &cbBuf, &cRasSrvConn);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be one more than we got back
            // this time.
            //
            cbBufGuess = cbBuf + sizeof (RASSRVCONN);

            if (cRasSrvConn)
            {
                *paRasSrvConn = aRasSrvConn;
                *pcRasSrvConn = cRasSrvConn;
            }
            else
            {
                MemFree (aRasSrvConn);
            }
        }
        else
        {
            MemFree (aRasSrvConn);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasSrvEnumConnections.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // In case RAS makes more calls by the time we get back
                // to enumerate with the bigger buffer, add room for a few
                // more.
                //
                cbBuf += 2 * sizeof (RASSRVCONN);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasEnumAllActiveServerConnections", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasEnumAllEntriesWithDetails
//
//  Purpose:    Enumerate and return all RAS entries in a phone book.
//
//  Arguments:
//      pszPhonebook      [in]  Phonebook file to use.
//      paRasEntryDetails [out] Pointer to returned allocation of
//                              RASENUMENTRYDETAILS structures.
//      pcRasEntryDetails [out] Pointer to count of RASENUMENTRYDETAILS
//                              structures returned.
//
//  Returns:    S_OK, S_FALSE if no entries, or an error code.
//
//  Author:     shaunco   2 Oct 1997
//
//  Notes:      The returned buffer must be freed using free.
//
HRESULT
HrRasEnumAllEntriesWithDetails (
    PCWSTR                  pszPhonebook,
    RASENUMENTRYDETAILS**   paRasEntryDetails,
    DWORD*                  pcRasEntryDetails)
{
    // Allocate room for five entry names initially.  We'll update
    // this guess after we successfully allocate and find out how much was
    // really needed.  Saving it across calls will keep us from allocating
    // too much or too little.
    //
    static DWORD cbBufGuess = 5 * sizeof (RASENUMENTRYDETAILS);

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *paRasEntryDetails = NULL;
    *pcRasEntryDetails = 0;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASENUMENTRYDETAILS* aRasEntryDetails =
        reinterpret_cast<RASENUMENTRYDETAILS*>(MemAlloc (cbBuf));
    if (aRasEntryDetails)
    {
        ZeroMemory(aRasEntryDetails, cbBuf);
        aRasEntryDetails->dwSize = sizeof (RASENUMENTRYDETAILS);

        DWORD cRasEntryDetails;
        DWORD dwErr = DwEnumEntryDetails (
                        pszPhonebook,
                        aRasEntryDetails,
                        &cbBuf, &cRasEntryDetails);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be one more than we got back
            // this time.
            //
            cbBufGuess = cbBuf + sizeof (RASENUMENTRYDETAILS);

            if (cRasEntryDetails)
            {
                *paRasEntryDetails = aRasEntryDetails;
                *pcRasEntryDetails = cRasEntryDetails;
            }
            else
            {
                MemFree (aRasEntryDetails);
                hr = S_FALSE;
            }
        }
        else
        {
            MemFree (aRasEntryDetails);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling DwEnumEntryDetails.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasEnumAllEntriesWithDetails", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindRasConnFromGuidId
//
//  Purpose:    Searches for the active RAS connection that corresponds to
//              the phone book entry given by a GUID.
//
//  Arguments:
//      pguid       [in]    Pointer to the GUID which identifies the entry.
//      phRasConn   [out]   The returned handle to the RAS connection if it
//                          was found.  NULL otherwise.
//      pRasConn    [out]   Optional pointer to returned RASCONN structure
//                          if found.
//
//  Returns:    S_OK if found, S_FALSE if not, or an error code.
//
//  Author:     shaunco   29 Sep 1997
//
//  Notes:
//
HRESULT
HrFindRasConnFromGuidId (
    IN const GUID* pguid,
    OUT HRASCONN* phRasConn,
    OUT RASCONN* pRasConn OPTIONAL)
{
    Assert (pguid);
    Assert (phRasConn);

    HRESULT hr;
    RASCONN* aRasConn;
    DWORD cRasConn;

    // Initialize the output parameter.
    //
    *phRasConn = NULL;

    hr = HrRasEnumAllActiveConnections (&aRasConn, &cRasConn);

    if (S_OK == hr)
    {
        hr = S_FALSE;

        for (DWORD i = 0; i < cRasConn; i++)
        {
            if (*pguid == aRasConn[i].guidEntry)
            {
                *phRasConn = aRasConn[i].hrasconn;

                if (pRasConn)
                {
                    CopyMemory (pRasConn, &aRasConn[i], sizeof(RASCONN));
                }

                hr = S_OK;
                break;
            }
        }

        MemFree (aRasConn);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr, "HrFindRasConnFromGuidId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetEntryProperties
//
//  Purpose:    Wrapper around RasGetEntryProperties that returns an HRESULT
//              and allocates the necessary memory automatically.
//
//  Arguments:
//      pszPhonebook  [in]
//      pszEntry      [in]
//      ppRasEntry    [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Oct 1997
//
//  Notes:      The output parameters should be freed using free.
//
HRESULT
HrRasGetEntryProperties (
    PCWSTR          pszPhonebook,
    PCWSTR          pszEntry,
    RASENTRY**      ppRasEntry,
    DWORD*          pcbRasEntry)
{
    // Init the output parameter if provided.
    //
    if (pcbRasEntry)
    {
        *pcbRasEntry = 0;
    }

    // Allocate room for RASENTRY structure plus 256 bytes initially.
    // We'll update this guess after we successfully allocate and find out
    // how much was really needed.  Saving it across calls will keep us
    // from allocating too much or too little.
    //
    static DWORD cbBufGuess = sizeof (RASENTRY) + 256;

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *ppRasEntry = NULL;
    if (pcbRasEntry)
    {
        *pcbRasEntry = 0;
    }

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASENTRY* pRasEntry = reinterpret_cast<RASENTRY*>(MemAlloc (cbBuf));
    if (pRasEntry)
    {
        pRasEntry->dwSize = sizeof (RASENTRY);

        DWORD dwErr = RasGetEntryProperties (pszPhonebook, pszEntry,
                        pRasEntry, &cbBuf, NULL, NULL);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be a bit more than we
            // got back this time.
            //
            cbBufGuess = cbBuf + 256;

            *ppRasEntry = pRasEntry;
            if (pcbRasEntry)
            {
                *pcbRasEntry = cbBuf;
            }
        }
        else
        {
            MemFree (pRasEntry);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasGetEntryProperties.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasGetEntryProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetSubEntryProperties
//
//  Purpose:    Wrapper around RasGetSubEntryProperties that returns an HRESULT
//              and allocates the necessary memory automatically.
//
//  Arguments:
//      pszPhonebook  [in]
//      pszEntry      [in]
//      dwSubEntry    [in]
//      ppRasSubEntry [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     CWill   02/10/98
//
//  Notes:      The output parameters should be freed using free.
//
HRESULT
HrRasGetSubEntryProperties (
    PCWSTR          pszPhonebook,
    PCWSTR          pszEntry,
    DWORD           dwSubEntry,
    RASSUBENTRY**   ppRasSubEntry)
{
    // Allocate room for RASSUBENTRY structure plus 256 bytes initially.
    // We'll update this guess after we successfully allocate and find out
    // how much was really needed.  Saving it across calls will keep us
    // from allocating too much or too little.
    //
    static DWORD cbBufGuess = sizeof (RASSUBENTRY) + 256;

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *ppRasSubEntry = NULL;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASSUBENTRY* pRasSubEntry = reinterpret_cast<RASSUBENTRY*>(MemAlloc (cbBuf));
    if (pRasSubEntry)
    {
        pRasSubEntry->dwSize = sizeof (RASSUBENTRY);

        DWORD dwErr = RasGetSubEntryProperties (pszPhonebook, pszEntry,
                    dwSubEntry, pRasSubEntry, &cbBuf, NULL, NULL);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be a bit more than we
            // got back this time.
            //
            cbBufGuess = cbBuf + 256;

            *ppRasSubEntry = pRasSubEntry;
        }
        else
        {
            MemFree (pRasSubEntry);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasGetSubEntryProperties.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasGetSubEntryProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetNetconStatusFromRasConnectStatus
//
//  Purpose:    Returns a NETCON_STATUS value given a handle to a RAS
//              connection by calling RasGetConnectStatus and mapping.
//
//  Arguments:
//      hRasConn [in]  Handle to the RAS connection.  (See Win32 RAS APIs.)
//      pStatus  [out] Pointer to where the NETCON_STATUS is returned.
//
//  Returns:    S_OK or an error code in the FACILITY_WIN32 facility.
//
//  Author:     shaunco   6 May 1998
//
//  Notes:
//
HRESULT
HrRasGetNetconStatusFromRasConnectStatus (
    HRASCONN        hRasConn,
    NETCON_STATUS*  pStatus)
{
    Assert (pStatus);

    // Initialize the output parameter.
    //
    *pStatus = NCS_DISCONNECTED;

    // Get its status and map it to our status.
    //
    RASCONNSTATUS RasConnStatus;
    ZeroMemory (&RasConnStatus, sizeof(RasConnStatus));
    RasConnStatus.dwSize = sizeof(RASCONNSTATUS);

    DWORD dwErr = RasGetConnectStatus (hRasConn, &RasConnStatus);

    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr),
        "RasGetConnectStatus");

    if (S_OK == hr)
    {
        if (RasConnStatus.rasconnstate & RASCS_DONE)
        {
            if (RASCS_Disconnected != RasConnStatus.rasconnstate)
            {
                *pStatus = NCS_CONNECTED;
            }
        }
        else
        {
            *pStatus = NCS_CONNECTING;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr),
        "HrRasGetNetconStatusFromRasConnectStatus");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasHangupUntilDisconnected
//
//  Purpose:    Call RasHangup until the connection is disconnected.
//              Ras reference-counts RasDial/RasHangup, so this is called
//              when the connection needs to be dropped no matter what.
//              (For example, the behavior of disconnect from the shell
//              is to drop the connection regardless of who dialed it.)
//
//  Arguments:
//      hRasConn [in] The connection to disconnect.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   29 May 1999
//
HRESULT
HrRasHangupUntilDisconnected (
    IN HRASCONN hRasConn)
{
    HRESULT hr = E_UNEXPECTED;

    BOOL fDisconnectAgain;
    do
    {
        fDisconnectAgain = FALSE;

        // Hang up.
        //
        DWORD dwErr = RasHangUp (hRasConn);
        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasHangUp", hr);

        if (SUCCEEDED(hr))
        {
            // Since the connection may be ref-counted, see if
            // it's still connected and, if it is, go back and
            // disconnect again.
            //
            HRESULT hrT;
            NETCON_STATUS Status;

            hrT = HrRasGetNetconStatusFromRasConnectStatus (
                    hRasConn,
                    &Status);

            if ((S_OK == hrT) && (NCS_CONNECTED == Status))
            {
                fDisconnectAgain = TRUE;

                TraceTag (ttidWanCon, "need to disconnect again...");
            }
        }
    } while (fDisconnectAgain);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRasHangupUntilDisconnected");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasNetConToSharedConnection
//
//  Purpose:    Converts an 'INetConnection' to the format expected
//              by the RAS sharing API routines.
//
//  Arguments:
//      pCon          [in]
//      prcs          [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrNetConToSharedConnection (
    INetConnection* pCon,
    LPRASSHARECONN  prsc)
{
    HRESULT hr;
    NETCON_PROPERTIES* pProps;
    hr = pCon->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        if (pProps->MediaType == NCM_LAN)
        {
            RasGuidToSharedConnection(&pProps->guidId, prsc);
        }
        else
        {
            INetRasConnection* pnrc;
            hr = HrQIAndSetProxyBlanket(pCon, &pnrc);
            if (SUCCEEDED(hr))
            {
                RASCON_INFO rci;
                hr = pnrc->GetRasConnectionInfo (&rci);
                if (SUCCEEDED(hr))
                {
                    RasEntryToSharedConnection (
                        rci.pszwPbkFile, rci.pszwEntryName, prsc );
                    RciFree (&rci);
                }
                ReleaseObj (pnrc);
            }
        }
        FreeNetconProperties(pProps);
    }
    TraceError ("HrRasNetConToSharedConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasIsSharedConnection
//
//  Purpose:    Wrapper around RasIsSharedConnection that returns an HRESULT.
//
//  Arguments:
//      prsc          [in]
//      pfShared      [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/04/98
//
//  Notes:
//
HRESULT
HrRasIsSharedConnection (
    LPRASSHARECONN  prsc,
    BOOL*           pfShared)
{
    *pfShared = FALSE;
    DWORD dwErr = RasIsSharedConnection (prsc, pfShared);
    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasIsSharedConnection", hr);
    return hr;
}

#if 0

//+---------------------------------------------------------------------------
//
//  Function:   HrRasQueryLanConnTable
//
//  Purpose:    Wrapper around RasQueryLanConnTable that returns an HRESULT.
//
//  Arguments:
//      prsc          [in]
//      ppLanTable    [out,optional]
//      pdwLanCount   [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrRasQueryLanConnTable (
    LPRASSHARECONN      prsc,
    NETCON_PROPERTIES** ppLanTable,
    LPDWORD             pdwLanCount)
{
    DWORD dwErr = RasQueryLanConnTable (prsc, (LPVOID*)ppLanTable, pdwLanCount);
    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasQueryLanConnTable", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasShareConnection
//
//  Purpose:    Wrapper around RasShareConnection that returns an HRESULT.
//
//  Arguments:
//      prsc            [in]
//      pPrivateLanGuid [in,optional]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrRasShareConnection (
    LPRASSHARECONN      prsc,
    GUID*               pPrivateLanGuid)
{
    DWORD dwErr = RasShareConnection (prsc, pPrivateLanGuid);
    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasShareConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasUnshareConnection
//
//  Purpose:    Wrapper around HrRasUnshareConnection that returns an HRESULT.
//
//  Arguments:
//      pfWasShared   [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrRasUnshareConnection (
    PBOOL       pfWasShared)
{
    HRESULT hr;
    DWORD dwErr = RasUnshareConnection (pfWasShared);
    hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasUnshareConnection", hr);
    return hr;
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   RasSrvTypeFromRasDeviceType
//
//  Purpose:    Converts from RASDEVICETYPE into an accepted incoming type
//
//  Arguments:
//      rdt [in] the RasDeviceType
//
//  Returns:    RASSRVUI_Xxx type
//
//  Author:     ckotze      19 Apr 2001
//
//  Notes:
//
DWORD RasSrvTypeFromRasDeviceType(RASDEVICETYPE rdt)
{
    DWORD dwType = RASSRVUI_MODEM;
    
    TraceTag (ttidWanCon, "rdt:0x%08x,  dwType:0x%08x",
        rdt,
        dwType);
    
    switch (LOWORD(rdt))
    {
    case RDT_PPPoE:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Modem:
    case RDT_X25:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Isdn:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Serial:
    case RDT_FrameRelay:
    case RDT_Atm:
    case RDT_Sonet:
    case RDT_Sw56:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Tunnel_Pptp:
    case RDT_Tunnel_L2tp:
        dwType = RASSRVUI_VPN;
        break;
        
    case RDT_Irda:
    case RDT_Parallel:
        dwType = RASSRVUI_DCC;
        break;
        
    case RDT_Other:
    default:
        dwType = RASSRVUI_MODEM;
    }
    
    if (rdt & RDT_Tunnel)
    {
        dwType = RASSRVUI_VPN;
    }
    else if (rdt & (RDT_Direct | RDT_Null_Modem))
    {
        dwType = RASSRVUI_DCC;
    }
    return dwType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nctraceui\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSERVICE
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <commctrl.h>
#include <shellapi.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nctraceui\resource.h ===
#define IDD_TRACETAGS                   60000
#define IDD_DBGFLAGS                    60001

// TraceTags page
//
#define IDC_TRACETAGS                   61000
#define IDC_CB_TT_VERBOSE               61001
#define IDC_B_TT_ENABLE                 61002
#define IDC_B_TT_DISABLE                61003
#define IDC_B_TT_ENABLE_ALL             61004
#define IDC_B_TT_DISABLE_ALL            61005
#define IDC_E_TT_LOGFILE_PATH           61006
#define IDC_TT_BROWSE                   61007

// DebugFlags page
//
#define IDC_DBGFLAGS                    61100
#define IDC_B_DF_ENABLE                 61101
#define IDC_B_DF_DISABLE                61102


// Bitmap defines
//
#define IDB_TRACE_CHECKSTATE            62001

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nctraceui\flagspage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T A G S P A G E . C P P
//
//  Contents:   TraceTags propsheet page handlers
//
//  Notes:
//
//  Author:     jeffspr   24 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <crtdbg.h>
#include "ncdebug.h"
#include <ncui.h>
#include "traceui.h"


//---[ Globals ]--------------------------------------------------------------

#if 0
typedef struct _LV_COLUMN {
    UINT mask;
    int fmt;
    int cx;
    PWSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMN;
#endif

//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:

#define LVCF_NORMAL (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH)

static LV_COLUMN    g_lvcTags[] =
{
    {LVCF_NORMAL,   LVCFMT_LEFT,    30, L"Name",           0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    60, L"Description",    0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    30, L"Debug Logging",  0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    30, L"File Logging",   0,  0}
};

const DWORD g_dwTagColumnCount = celems(g_lvcTags);

static const UINT SELS_UNCHECKED     = 0x1;
static const UINT SELS_CHECKED       = 0x2;


CDbgFlagPage::CDbgFlagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::~CDbgFlagPage
//
//  Purpose:    Destroys the CDbgFlagPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
CDbgFlagPage::~CDbgFlagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    HRESULT             hr = S_OK;

    m_hwndLV = GetDlgItem(IDC_TRACETAGS);

    hr = HrInitTraceListView(m_hwndLV, &m_hilCheckIcons);

    for(DWORD dwLoop = 0; dwLoop < g_dwTagColumnCount; dwLoop++)
    {
        ListView_InsertColumn(m_hwndLV,dwLoop+1,&(g_lvcTags[dwLoop]));
    }

    LV_ITEM lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_IMAGE |
               LVIF_STATE | LVIF_PARAM;

    INT nIndex =0;

#if 0
    // Get the component's class image list index
    if (pcild)
    {
        hr = HrSetupDiGetClassImageIndex(pcild, &guidClass, &nIndex);
        TraceError("HrSetupDiGetClassImageIndex failed.", hr);

        lvi.iImage = nIndex;

        hr = S_OK;
    }

    lvi.iItem = *pnPos;
#endif
    lvi.iItem = 0;
#if 0
    NET_ITEM_DATA * pnid = new NET_ITEM_DATA;
    pnid->szwName = SzDupSz(pszwName);
    pnid->szwDesc = SzDupSz(pszwDesc);
    pnid->dwFlags = dwFlags;
    AddRefObj(pnid->pncc = pncc);

    pnid->pCompObj = new CComponentObj(pncc);
    hr = pnid->pCompObj->HrInit(plistBindingPaths);

    if FAILED(hr)
    {
        TraceError("HrInsertComponent: failed to initialize a component object", hr);
        hr = S_OK;
    }

    lvi.lParam = reinterpret_cast<LPARAM>(pnid);
    lvi.pszText = pnid->szwName;
#endif
    lvi.lParam = 0;
    lvi.pszText = L"Hey, Jude";

    // We will refresh the state of the whole list in the end
    UINT iChkIndex = SELS_CHECKED;
    lvi.state = INDEXTOSTATEIMAGEMASK( iChkIndex );

    INT ret;
    ret = ListView_InsertItem(m_hwndLV, &lvi);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnHelp
//
//  Purpose:    Handles the WM_HELP message.
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                            BOOL& bHandled)
{
    OnTraceHelpGeneric(m_hWnd, lParam);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                               BOOL& bHandled)
{
    UninitTraceListView(m_hwndLV);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnSetCursor
//
//  Purpose:    Called in response to the WM_SETCURSOR message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Jan 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& bHandled)
{
    if (m_hPrevCurs)
    {
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        return TRUE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnAdd
//
//  Purpose:    Handles the clicking of the Add button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                           BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    hr = HrLvAdd(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter, &m_listBindingPaths);
    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CDbgFlagPage::OnAdd", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnRemove
//
//  Purpose:    Handles the clicking of the Remove button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                              BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvRemove(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter,
                    &m_listBindingPaths);

    // if list is empty, reset the buttons
    if (0 == ListView_GetItemCount(m_hwndLV))
    {
        // Reset the buttons and the description text based on the changed selection
        LvSetButtons(m_handles);
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CDbgFlagPage::OnRemove", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvProperties(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths);

    TraceError("CDbgFlagPage::OnProperties", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    if (m_fReentrancyCheck)
    {
        TraceTag(ttidLanUi, "CDbgFlagPage::OnApply is being re-entered! "
                 "I'm outta here!");

        // Don't allow the automatic EndDialog() to work just yet
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
        return TRUE;
    }

    m_hPrevCurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = m_pnc->Validate();
    if (hr == S_OK)
    {
        BOOL    fReboot = FALSE;

        // Note: This function becomes reentrant because INetCfg::Apply()
        // has a message pump in it which causes the PSN_APPLY message to
        // be processed twice. This will happen ONLY if the user double-clicks
        // the OK button.
        m_fReentrancyCheck = TRUE;

        TraceTag(ttidLanUi, "Calling INetCfg::Apply()");
        hr = m_pnc->Apply();
        if (NETCFG_S_REBOOT == hr)
        {
            fReboot = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidLanUi, "INetCfg::Apply() succeeded");
            hr = m_pnc->Uninitialize();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fRebootAlreadyRequested || fReboot)
            {
                DWORD dwFlags = QUFR_REBOOT;
                if (!m_fRebootAlreadyRequested)
                    dwFlags |= QUFR_PROMPT;

                (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                              m_hWnd, IDS_LAN_CAPTION,
                                              IDS_REBOOT_REQUIRED,
                                              dwFlags);
            }
        }
    }

    // Apply "general" properties
    //
    if (SUCCEEDED(hr))
    {
        LANCON_INFO linfo = {0};

        linfo.fShowIcon = IsDlgButtonChecked(IDC_CHK_ShowIcon);

        // Set new value of show icon property
        hr = m_plan->SetInfo(LCIF_ICON, &linfo);
    }

    // Normalize result
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (m_hPrevCurs)
    {
        SetCursor(m_hPrevCurs);
        m_hPrevCurs = NULL;
    }

    // Reset this just in case
    m_fReentrancyCheck = FALSE;

    TraceError("CDbgFlagPage::OnApply", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Jan 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    AssertSz(m_pnc, "I need a NetCfg object!");

    hr = m_pnc->Uninitialize();

    TraceError("CDbgFlagPage::OnCancel", hr);
#endif
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    LvDeleteItem(m_hwndLV, pnmlv->iItem);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths, FALSE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnDbClick
//
//  Purpose:    Called in response to the NM_DBLCLK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                m_pnccAdapter, &m_listBindingPaths, TRUE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnKeyDown
//
//  Purpose:    Called in response to the LVN_KEYDOWN message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
#if 0
    OnListKeyDown(m_hwndLV, &m_listBindingPaths, plvkd->wVKey);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   10 Nov 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    HANDLES         handles;

    Assert(pnmlv);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_handles);
#endif
    return 0;
}

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nctraceui\traceui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E U I . H
//
//  Contents:   Tracing Property sheet UI
//
//  Notes:
//
//  Author:     jeffspr   31 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#include "ncatl.h"
#include "ncatlps.h"
#include "resource.h"
#include <nctraceui.h>

//---[ Classes and structs ]--------------------------------------------------

#if 0
struct ADVANCED_ITEM_DATA
{
    PWSTR              szwName;
    INetCfgComponent *  pncc;
};
#endif

//
// CTraceUIDlg
//

class CTraceUIDlg :
    public CDialogImpl<CTraceUIDlg>
{
    BEGIN_MSG_MAP(CTraceUIDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

//    enum { IDD = IDD_LAN_CONNECT};

    CTraceUIDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
};

//
// Trace UI TraceTag Page
//
class CTraceTagPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CTraceTagPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)

        // Listview handlers
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)
    END_MSG_MAP()

    enum {IDD = IDD_TRACETAGS};

    CTraceTagPage();
    ~CTraceTagPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                     BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // listview handlers
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    HIMAGELIST              m_hil;
    HWND                    m_hwndLV;
    BOOL                    m_fLocked;
    HIMAGELIST              m_hilCheckIcons;
    HCURSOR                 m_hPrevCurs;
};

//
// Trace UI TraceTag Page
//
class CDbgFlagPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CDbgFlagPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)

        // Listview handlers
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)
    END_MSG_MAP()

    enum {IDD = IDD_TRACETAGS};

    CDbgFlagPage();
    ~CDbgFlagPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                     BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // listview handlers
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    HIMAGELIST              m_hil;
    HWND                    m_hwndLV;
    BOOL                    m_fLocked;
    HIMAGELIST              m_hilCheckIcons;
    HCURSOR                 m_hPrevCurs;
};



//
// Global functions
//

VOID    OnTraceHelpGeneric(HWND hwnd, LPARAM lParam);
HRESULT HrInitTraceListView(HWND hwndList, HIMAGELIST *philStateIcons);
VOID    UninitTraceListView(HWND hwndList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\dbgext\exts.cpp ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  ncext.c

------------------------------------------------------------------------------*/

#define ENABLETRACE

#define private   public
#define protected public

#include "ncext.h"

// #define VERBOSE

#ifdef VERBOSE
#define dprintfVerbose dprintf
#else
#define dprintfVerbose __noop
#endif

#include "stlint2.h"

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
#include "tracetag.h"
#include "dbgflags.h"
#include "naming.h"
#include "foldinc.h"
#include "connlist.h"
#include "iconhandler.h"
#include "smcent.h"
#include "smeng.h"

#include "netshell.h"

EXTERN_C const GUID IID_INetStatisticsEngine = {0x1355C842,0x9F50,0x11D1,0xA9,0x27,0x00,0x80,0x5F,0xC1,0x27,0x0E};

HRESULT HrGetAddressOfSymbol(LPCSTR szSymbol, PULONG64 pAddress)
{
    HRESULT hr = E_FAIL;

    if (pAddress)
    {
        *pAddress = 0;
    }

    if (!szSymbol || !*szSymbol || !pAddress)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pAddress = GetExpression(szSymbol);
        if (!*pAddress)
        {
            dprintf("\nCould not find symbol: %s. Is your symbols correct?\n", szSymbol);
        }
        else
        {
            dprintfVerbose("%s: 0x%08x\n", szSymbol, *pAddress);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT HrGetAddressOfSymbol(LPCSTR szModule, LPCSTR szSymbol, PULONG64 pAddress)
{
    HRESULT hr = E_FAIL;

    if (pAddress)
    {
        *pAddress = 0;
    }

    if (!szModule || !*szModule || !szSymbol || !*szSymbol || !pAddress)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pAddress = 0;

        CHAR szModulueSymbol[MAX_PATH];
        wsprintf(szModulueSymbol, "%s!%s", szModule, szSymbol);
        dprintfVerbose("%s: ", szModulueSymbol);

        hr = HrGetAddressOfSymbol(szModulueSymbol, pAddress);
    }

    return hr;
}

HRESULT HrReadMemoryFromUlong(ULONG64 Address, IN DWORD dwSize, OUT LPVOID pBuffer)
{
    HRESULT hr = S_OK;
    DWORD cb = dwSize;

    dprintfVerbose(" 0x%04x bytes from 0x%08x\r\n", cb, Address);
    if (ReadMemory(Address, pBuffer, dwSize, &cb) && cb == dwSize)
    {
        hr = S_OK;
    }
    else
    {
        dprintf("Could not read content of memory at 0x%08x. Content might be paged out.\n", Address);
        hr = E_FAIL;
    }
    return hr;
}

HRESULT HrWriteMemoryFromUlong(ULONG64 Address, DWORD dwSize, IN LPCVOID pBuffer)
{
    HRESULT hr = S_OK;
    DWORD cb;

    dprintfVerbose(" to 0x%08x, size=%x\n", Address, dwSize);
    if (WriteMemory(Address, pBuffer, dwSize, &cb) && cb == dwSize)
    {
        hr = S_OK;
    }
    else
    {
        dprintf("Could not write content of memory to 0x%08x. Address might be paged out.\n", Address);
        hr = E_FAIL;
    }
    return hr;
}

HRESULT HrReadMemory(LPCVOID pAddress, IN DWORD dwSize, OUT LPVOID pBuffer)
{
    return HrReadMemoryFromUlong((ULONG64)(ULONG_PTR)pAddress, dwSize, pBuffer);
}

HRESULT HrWriteMemory(LPCVOID pAddress, DWORD dwSize, OUT LPCVOID pBuffer)
{
    return HrWriteMemoryFromUlong((ULONG64)(ULONG_PTR)pAddress, dwSize, pBuffer);
}

HRESULT HrGetTraceTagsForModule(LPCSTR szModuleName, LPDWORD pdwCount, TRACETAGELEMENT** ppTRACETAGELEMENT, ULONG64 *pTraceTagOffset = NULL)
{
    HRESULT hr = E_FAIL;

    if (szModuleName && *szModuleName)
    {
        ULONG64 g_TraceTagCountAddress = 0;
        ULONG64 g_TraceTagsAddress     = 0;
        hr = HrGetAddressOfSymbol(szModuleName, "g_nTraceTagCount", &g_TraceTagCountAddress);
        if (SUCCEEDED(hr))
        {
            INT nTraceTagCount = 0;
            hr = HrReadMemoryFromUlong(g_TraceTagCountAddress, sizeof(nTraceTagCount), &nTraceTagCount);
            if (SUCCEEDED(hr))
            {
                *pdwCount = nTraceTagCount;
                dprintfVerbose("Number of tags: %d\n", nTraceTagCount);
    
                hr = HrGetAddressOfSymbol(szModuleName, "g_TraceTags", &g_TraceTagsAddress);
                if (SUCCEEDED(hr))
                {
                    if (nTraceTagCount)
                    {
                        DWORD dwSize = nTraceTagCount * sizeof(TRACETAGELEMENT);
                
                        *ppTRACETAGELEMENT = reinterpret_cast<TRACETAGELEMENT*>(LocalAlloc(0, dwSize));
                        if (*ppTRACETAGELEMENT)
                        {
                            dprintfVerbose("Reading %d bytes\n", dwSize);

                            hr = HrReadMemoryFromUlong(g_TraceTagsAddress, dwSize, *ppTRACETAGELEMENT);

                            if (pTraceTagOffset)
                            {
                                *pTraceTagOffset = g_TraceTagsAddress;
                            }
                        }
                        else
                        {
                            dprintf("Out of memory allocating %d trace elements\n", nTraceTagCount);
                        }
                    }
                    else
                    {
                        dprintf("Internal error\n");
                    }
                }
            }
            else
            {
                dprintf("*ERROR* Could not read content of %s!g_nTraceTagCount. Value might be paged out.\n", szModuleName);
            }
        }
    }

    return hr;
}

HRESULT HrGetDebugFlagsForModule(LPCSTR szModuleName, LPDWORD pdwCount, DEBUGFLAGELEMENT** ppDEBUGFLAGELEMENT, ULONG64 *pDebugFlagOffset = NULL)
{
    HRESULT hr = E_FAIL;

    if (szModuleName && *szModuleName)
    {
        ULONG64 g_DbgFlagCountAddress = 0;
        ULONG64 g_DbgFlagsAddress     = 0;
        hr = HrGetAddressOfSymbol(szModuleName, "g_nDebugFlagCount", &g_DbgFlagCountAddress);
        if (SUCCEEDED(hr))
        {
            INT nDbgFlagCount = 0;
            hr = HrReadMemoryFromUlong(g_DbgFlagCountAddress, sizeof(nDbgFlagCount), &nDbgFlagCount);
            if (SUCCEEDED(hr))
            {
                *pdwCount = nDbgFlagCount;
                dprintfVerbose("Number of flags: %d\n", nDbgFlagCount);
    
                hr = HrGetAddressOfSymbol(szModuleName, "g_DebugFlags", &g_DbgFlagsAddress);
                if (SUCCEEDED(hr))
                {
                    if (nDbgFlagCount)
                    {
                        DWORD dwSize = nDbgFlagCount * sizeof(DEBUGFLAGELEMENT);
                
                        *ppDEBUGFLAGELEMENT = reinterpret_cast<DEBUGFLAGELEMENT*>(LocalAlloc(0, dwSize));
                        if (*ppDEBUGFLAGELEMENT)
                        {
                            dprintfVerbose("Reading %d bytes\n", dwSize);

                            hr = HrReadMemoryFromUlong(g_DbgFlagsAddress, dwSize, *ppDEBUGFLAGELEMENT);

                            if (pDebugFlagOffset)
                            {
                                *pDebugFlagOffset = g_DbgFlagsAddress;
                            }
                        }
                        else
                        {
                            dprintf("Out of memory allocating %d flag elements\n", nDbgFlagCount);
                        }
                    }
                    else
                    {
                        dprintf("Internal error\n");
                    }
                }
            }
            else
            {
                dprintf("*ERROR* Could not read content of %s!g_nDebugFlagCount. Value might be paged out.\n", szModuleName);
            }
        }
    }

    return hr;
}

HRESULT HrPutTraceTagsForModule(LPCSTR szModuleName, DWORD dwCount, const TRACETAGELEMENT* pTRACETAGELEMENT)
{
    HRESULT hr = E_FAIL;

    if (szModuleName && *szModuleName)
    {
        CHAR szTraceExport[MAX_PATH];
        wsprintf(szTraceExport, "%s!g_TraceTags", szModuleName);
        dprintfVerbose("%s: ", szTraceExport);

        ULONG64 pnTraceAddress = GetExpression(szTraceExport);
        if (!pnTraceAddress)
        {
            dprintf("\n### Could not find g_TraceTags export on module %s. Is %s loaded, and is your symbols correct? ###\n", szModuleName, szModuleName);
        }
        dprintfVerbose("0x%08x\n", pnTraceAddress);

        CHAR szTraceCount[MAX_PATH];
        wsprintf(szTraceCount, "%s!g_nTraceTagCount", szModuleName);
        dprintfVerbose("%s: ", szTraceCount);
        ULONG64 pnTraceTagCount = GetExpression(szTraceCount);
        if (!pnTraceTagCount)
        {
            dprintf("\n### Could not find g_nTraceTagCount export on module %s. Is %s loaded, and is your symbols correct? ###\n", szModuleName, szModuleName);
        }
        dprintfVerbose("0x%08x\n", pnTraceTagCount);

        if (pnTraceAddress & pnTraceTagCount)
        {
            INT nTraceTagCount = 0;
            DWORD cb;
            hr = HrReadMemoryFromUlong(pnTraceTagCount, sizeof(nTraceTagCount), &nTraceTagCount);
            if (SUCCEEDED(hr))
            {
                dwCount = nTraceTagCount;
                if (dwCount != nTraceTagCount)
                {
                    dprintf("Internal Error\n");
                }
                else
                {
                    dprintfVerbose("Number of tags: %d\n", nTraceTagCount);
        
                    if (nTraceTagCount)
                    {
                        DWORD dwSize = nTraceTagCount * sizeof(TRACETAGELEMENT);
                    
                        dprintfVerbose("Writing %d bytes\n", dwSize);
                    }
                    else
                    {
                        dprintf("Internal error\n");
                    }
                 }
            }
            else
            {
                dprintf("*ERROR* Could not read content of %s!g_nTraceTagCount. Value might be paged out.\n", szModuleName);
            }
        }
    }

    return hr;
}

DECLARE_API( tracelist )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Buffer[4];

    if ( (lstrlen(args) > 4) &&
        !strncmp(args, "all ", 4) )
    {
        DWORD dwCount; 
        TRACETAGELEMENT *pTRACETAGELEMENT;
        HRESULT hr = HrGetTraceTagsForModule(args+4, &dwCount, &pTRACETAGELEMENT);
        if (SUCCEEDED(hr))
        {
            DWORD fIsSet = 0;
            for (DWORD x = 0; x < dwCount; x++)
            {
                dprintf(" %s %s - %s\n", 
                            pTRACETAGELEMENT[x].fOutputDebugString ? "*" : " ",
                            pTRACETAGELEMENT[x].szShortName, 
                            pTRACETAGELEMENT[x].szDescription
                    );
                if (pTRACETAGELEMENT[x].fOutputDebugString)
                {
                    fIsSet++;
                }
            }

            if (fIsSet)
            {   
                dprintf(" * --- indicates tag that is set for module: %s\r\n", args+4);
            }

            LocalFree(pTRACETAGELEMENT);
        }
    }
    else
    {
        if (args && *args)
        {
            DWORD dwCount; 
            TRACETAGELEMENT *pTRACETAGELEMENT;
            HRESULT hr = HrGetTraceTagsForModule(args, &dwCount, &pTRACETAGELEMENT);
            if (SUCCEEDED(hr))
            {
                for (DWORD x = 0; x < dwCount; x++)
                {
                    if (pTRACETAGELEMENT[x].fOutputDebugString)
                    {
                        dprintf("  %s\n", pTRACETAGELEMENT[x].szShortName);
                    }
                }

                LocalFree(pTRACETAGELEMENT);
            }
        }
        else
        {
            dprintf("Usage: !tracelist all <module> - List currently available traces for module <module>\n");
            dprintf("       !tracelist <module>     - List all the current traces enabled for module <module>\n");
        }
    }
}

DECLARE_API( flaglist )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Buffer[4];

    if ( (lstrlen(args) > 4) &&
        !strncmp(args, "all ", 4) )
    {
        DWORD dwCount; 
        DEBUGFLAGELEMENT *pDEBUGFLAGELEMENT;
        HRESULT hr = HrGetDebugFlagsForModule(args+4, &dwCount, &pDEBUGFLAGELEMENT);
        if (SUCCEEDED(hr))
        {
            DWORD fIsSet = 0;
            for (DWORD x = 0; x < dwCount; x++)
            {
                dprintf(" %s %s - %s\n", 
                            pDEBUGFLAGELEMENT[x].dwValue ? "*" : " ",
                            pDEBUGFLAGELEMENT[x].szShortName, 
                            pDEBUGFLAGELEMENT[x].szDescription
                    );
                if (pDEBUGFLAGELEMENT[x].dwValue)
                {
                    fIsSet++;
                }
            }

            if (fIsSet)
            {   
                dprintf(" * --- indicates flag that is set for module: %s\r\n", args+4);
            }

            LocalFree(pDEBUGFLAGELEMENT);
        }
    }
    else
    {
        if (args && *args)
        {
            DWORD dwCount; 
            DEBUGFLAGELEMENT *pDEBUGFLAGELEMENT;
            HRESULT hr = HrGetDebugFlagsForModule(args, &dwCount, &pDEBUGFLAGELEMENT);
            if (SUCCEEDED(hr))
            {
                for (DWORD x = 0; x < dwCount; x++)
                {
                    if (pDEBUGFLAGELEMENT[x].dwValue)
                    {
                        dprintf("  %s\n", pDEBUGFLAGELEMENT[x].szShortName);
                    }
                }

                LocalFree(pDEBUGFLAGELEMENT);
            }
        }
        else
        {
            dprintf("Usage: !flaglist <module>     - dump debug flags enabled for module <module>\n");
            dprintf("       !flaglist all <module> - dump all available debug flags for module <module>\n");
        }
    }
}

HRESULT HrEnableDisableTraceTag(LPCSTR argstring, BOOL fEnable)
{
    HRESULT hr = E_FAIL;

    BOOL fShowUsage = FALSE;
    DWORD dwArgLen = lstrlen(argstring);

    if (dwArgLen)
    {
        LPSTR szString = new TCHAR[dwArgLen+1];
        if (!szString)
        {
            dprintf("Out of memory\n");
        }
        else
        {
            LPSTR Args[2];
            DWORD dwCurrentArg = 0;
            lstrcpy(szString, argstring);
            Args[0] = szString;
        
            for (DWORD x = 0; (x < dwArgLen) && (dwCurrentArg < celems(Args)); x++)
            {
                if (szString[x] == ' ')
                {
                    dwCurrentArg++;

                    szString[x] = '\0';
                    Args[dwCurrentArg] = szString + x + 1;
                }
            }

            dprintfVerbose("Number of arguments: %d\n", dwCurrentArg + 1);

            if (dwCurrentArg != 1) 
            {
                hr = E_INVALIDARG;
            }
            else
            {
                dprintfVerbose("Arguments: %s, %s\n", Args[0], Args[1]);
                if (argstring && *argstring)
                {
                    DWORD dwCount; 
                    TRACETAGELEMENT *pTRACETAGELEMENT;
                    ULONG64 ul64TraceTagsOffset = NULL;
                    HRESULT hr = HrGetTraceTagsForModule(Args[0], &dwCount, &pTRACETAGELEMENT, &ul64TraceTagsOffset);
                    if (SUCCEEDED(hr))
                    {
                        BOOL fFound = FALSE;
                        for (DWORD x = 0; x < dwCount; x++)
                        {
                            if (!lstrcmpi(Args[1], pTRACETAGELEMENT[x].szShortName))
                            {
                                fFound = TRUE;

                                if (pTRACETAGELEMENT[x].fOutputDebugString == fEnable)
                                {
                                    dprintf("  [%s] is already %s\n", pTRACETAGELEMENT[x].szShortName, fEnable ? "enabled" : "disabled");
                                    hr = S_FALSE;
                                }
                                else
                                {
                                    LPBOOL pbOutputDebugString = &(pTRACETAGELEMENT[x].fOutputDebugString);
                                    *pbOutputDebugString = fEnable;
                                    ULONG64 ul64OutputDebugString = ul64TraceTagsOffset + (DWORD_PTR)pbOutputDebugString - (DWORD_PTR)pTRACETAGELEMENT;

                                    hr = HrWriteMemoryFromUlong(ul64OutputDebugString, sizeof(pTRACETAGELEMENT[x].fOutputDebugString), pbOutputDebugString);
                                    if (SUCCEEDED(hr))
                                    {
                                        dprintf("  [%s] is now %s on module %s\n", pTRACETAGELEMENT[x].szShortName, fEnable ? "enabled" : "disabled", Args[0]);
                                        hr = S_OK;
                                    }
                                    break;
                                }
                            }
                        }

                        if (!fFound)
                        {
                            dprintf("ERROR: No such TraceTag ID found in module %s\n", Args[0]);
                        }

                        LocalFree(pTRACETAGELEMENT);
                    }
                }
                else
                {
                }
            }
        }

        delete [] szString;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


HRESULT HrEnableDisableDebugFlag(LPCSTR argstring, BOOL fEnable)
{
    HRESULT hr = E_FAIL;

    BOOL fShowUsage = FALSE;
    DWORD dwArgLen = lstrlen(argstring);

    if (dwArgLen)
    {
        LPSTR szString = new TCHAR[dwArgLen+1];
        if (!szString)
        {
            dprintf("Out of memory\n");
        }
        else
        {
            LPSTR Args[2];
            DWORD dwCurrentArg = 0;
            lstrcpy(szString, argstring);
            Args[0] = szString;
        
            for (DWORD x = 0; (x < dwArgLen) && (dwCurrentArg < celems(Args)); x++)
            {
                if (szString[x] == ' ')
                {
                    dwCurrentArg++;

                    szString[x] = '\0';
                    Args[dwCurrentArg] = szString + x + 1;
                }
            }

            dprintfVerbose("Number of arguments: %d\n", dwCurrentArg + 1);

            if (dwCurrentArg != 1) 
            {
                hr = E_INVALIDARG;
            }
            else
            {
                dprintfVerbose("Arguments: %s, %s\n", Args[0], Args[1]);
                if (argstring && *argstring)
                {
                    DWORD dwCount; 
                    DEBUGFLAGELEMENT *pDEBUGFLAGELEMENT;
                    ULONG64 ul64DebugFlagsOffset = NULL;
                    HRESULT hr = HrGetDebugFlagsForModule(Args[0], &dwCount, &pDEBUGFLAGELEMENT, &ul64DebugFlagsOffset);
                    if (SUCCEEDED(hr))
                    {
                        BOOL fFound = FALSE;
                        for (DWORD x = 0; x < dwCount; x++)
                        {
                            if (!lstrcmpi(Args[1], pDEBUGFLAGELEMENT[x].szShortName))
                            {
                                fFound = TRUE;

                                if (pDEBUGFLAGELEMENT[x].dwValue == fEnable)
                                {
                                    dprintf("  '%s' is already %s\n", pDEBUGFLAGELEMENT[x].szShortName, fEnable ? "enabled" : "disabled");
                                    hr = S_FALSE;
                                }
                                else
                                {
                                    LPDWORD pdwOutputDebugString = &(pDEBUGFLAGELEMENT[x].dwValue);
                                    *pdwOutputDebugString = fEnable;
                                    ULONG64 ul64OutputDebugString = ul64DebugFlagsOffset + (DWORD_PTR)pdwOutputDebugString - (DWORD_PTR)pDEBUGFLAGELEMENT;

                                    hr = HrWriteMemoryFromUlong(ul64OutputDebugString, sizeof(pDEBUGFLAGELEMENT[x].dwValue), pdwOutputDebugString);
                                    if (SUCCEEDED(hr))
                                    {
                                        dprintf("  '%s' is now %s on module %s\n", pDEBUGFLAGELEMENT[x].szShortName, fEnable ? "enabled" : "disabled", Args[0]);
                                        hr = S_OK;
                                    }
                                    break;
                                }
                            }
                        }

                        if (!fFound)
                        {
                            dprintf("ERROR: No such DebugFlag ID found in module %s\n", Args[0]);
                        }

                        LocalFree(pDEBUGFLAGELEMENT);
                    }
                }
                else
                {
                }
            }
        }

        delete [] szString;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//
// Extension to edit a dword on target
//  
//    !edit <address> <value>
//
DECLARE_API( traceadd )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Value;

    HRESULT hr = HrEnableDisableTraceTag(args, TRUE);

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage: traceadd <module> \"tracetag\" - Starts tracing for a specific tracetag\n");
    }
}

DECLARE_API ( tracedel )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = HrEnableDisableTraceTag(args, FALSE);

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage: tracedel <module> \"tracetag\" - Stops tracing for a specific tracetag\n");
    }
}

DECLARE_API( flagadd )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Value;

    HRESULT hr = HrEnableDisableDebugFlag(args, TRUE);

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage: flagadd <module> \"flag\" - Enables a specific debug flag\n");
    }
}

DECLARE_API ( flagdel )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = HrEnableDisableDebugFlag(args, FALSE);

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage: flagdel <module> \"flag\" - Disables a specific debug flag\n");
    }
}

LPCSTR DBG_EMNAMES[] = // ENUMFLAG
{
    "INVALID_EVENTMGR",
    "CONMAN_INCOMING",
    "CONMAN_LAN", 
    "CONMAN_RAS"
};

LPCSTR DBG_CMENAMES[] = // ENUMFLAG
{
    "INVALID_TYPE",
    "CONNECTION_ADDED",
    "CONNECTION_BANDWIDTH_CHANGE",
    "CONNECTION_DELETED",
    "CONNECTION_MODIFIED",
    "CONNECTION_RENAMED",
    "CONNECTION_STATUS_CHANGE",
    "REFRESH_ALL",
    "CONNECTION_ADDRESS_CHANGE"
};

LPCSTR DBG_NCMNAMES[] = // ENUMFLAG
{
    "NCM_NONE",
    "NCM_DIRECT",
    "NCM_ISDN",
    "NCM_LAN",
    "NCM_PHONE",
    "NCM_TUNNEL",
    "NCM_PPPOE",
    "NCM_BRIDGE",
    "NCM_SHAREDACCESSHOST_LAN",
    "NCM_SHAREDACCESSHOST_RAS"
};

LPCSTR DBG_NCSMNAMES[] = // ENUMFLAG
{
    "NCSM_NONE",
    "NCSM_LAN",
    "NCSM_WIRELESS",
    "NCSM_ATM",
    "NCSM_ELAN",
    "NCSM_1394",
    "NCSM_DIRECT",
    "NCSM_IRDA",
    "NCSM_CM",
};

LPCSTR DBG_NCSNAMES[] = // ENUMFLAG
{
    "NCS_DISCONNECTED",
    "NCS_CONNECTING",
    "NCS_CONNECTED",
    "NCS_DISCONNECTING",
    "NCS_HARDWARE_NOT_PRESENT",
    "NCS_HARDWARE_DISABLED",
    "NCS_HARDWARE_MALFUNCTION",
    "NCS_MEDIA_DISCONNECTED",
    "NCS_AUTHENTICATING",
    "NCS_AUTHENTICATION_SUCCEEDED",
    "NCS_AUTHENTICATION_FAILED",
    "NCS_INVALID_ADDRESS",
    "NCS_CREDENTIALS_REQUIRED"
};

LPCSTR DBG_NCCFFLAGS[] = // BITFLAG
{
    "NCCF_NONE",                // = 0
    "NCCF_ALL_USERS",           // = 0x1
    "NCCF_ALLOW_DUPLICATION",   // = 0x2
    "NCCF_ALLOW_REMOVAL",       // = 0x4
    "NCCF_ALLOW_RENAME",        // = 0x8
    "NCCF_SHOW_ICON",           // = 0x10
    "NCCF_INCOMING_ONLY",       // = 0x20
    "NCCF_OUTGOING_ONLY",       // = 0x40
    "NCCF_BRANDED",             // = 0x80
    "NCCF_SHARED",              // = 0x100
    "NCCF_BRIDGED",             // = 0x200
    "NCCF_FIREWALLED",          // = 0x400
    "NCCF_DEFAULT"              // = 0x800
};


LPCSTR DBG_NCFFLAGS[] = // BITFLAG
{
    "<NONE>",                    // = 0
    "NCF_VIRTUAL",               // = 0x1
	"NCF_SOFTWARE_ENUMERATED",   // = 0x2
	"NCF_PHYSICAL",              //	= 0x4
	"NCF_HIDDEN",                // = 0x8
	"NCF_NO_SERVICE",            // = 0x10
	"NCF_NOT_USER_REMOVABLE",    // = 0x20
	"NCF_MULTIPORT_INSTANCED_ADAPTER", //	= 0x40
	"NCF_HAS_UI",                // = 0x80
	"NCF_SINGLE_INSTANCE",       // = 0x100
    "0x200",                     // = 0x200
	"NCF_FILTER",                // = 0x400
    "0x800",                     // = 0x800
	"NCF_DONTEXPOSELOWER",       // = 0x1000
	"NCF_HIDE_BINDING",          // = 0x2000
	"NCF_NDIS_PROTOCOL",         // = 0x4000
    "0x8000",                    // = 0x8000
    "0x10000",                   // = 0x10000
	"NCF_FIXED_BINDING"          // = 0x20000
};

LPCSTR DBG_ENUM_ICON_MANAGER[] = // ENUMFLAG
{
    "0",
    "ICO_MGR_INTERNAL",
    "ICO_MGR_CM",
    "ICO_MGR_RESOURCEID",
};

LPCSTR DBG_ENUM_CHARACTERISTICS_ICON[] =  // BITFLAG
{
    "0", 
    "ICO_CHAR_INCOMING",     //= 0x1
    "ICO_CHAR_DEFAULT",      //= 0x2
    "ICO_CHAR_FIREWALLED",   //= 0x4
    "ICO_CHAR_SHARED"        //= 0x8
};

LPCSTR DBG_ENUM_CONNECTION_ICON[] = // ENUMFLAG
{
    "NO_OVERLAY",
    "1",
    "2",
    "3",
    "ICO_CONN_BOTHOFF", // = 0x4
    "ICO_CONN_RIGHTON", // = 0x5
    "ICO_CONN_LEFTON" , // = 0x6
    "ICO_CONN_BOTHON" , // = 0x7
};

LPCSTR DBG_ENUM_STAT_ICON[] = // ENUMFLAG
{
    "ICO_STAT_NONE",         // = 0x0
    "ICO_STAT_FAULT",        // = 0x1
    "ICO_STAT_INVALID_IP",   // = 0x2
    "ICO_STAT_EAPOL_FAILED", // = 0x3
    "4",
    "5",
    "6",
    "7",
    "ICO_STAT_DISABLED"      // = 0x8
};


__declspec(noinline) LPCSTR BITFLAGFn(ULONG64 dwFlag, LPCSTR DUMPARRAY[], DWORD dwArraySize)
{
    static CHAR szName[4096];
    ZeroMemory(szName, 4096);

    LPSTR szTemp = szName;
    BOOL bFirst = TRUE;
    for (DWORD x = 0; x < dwArraySize-1; x++)
    {
        if (dwFlag & (1 << x))
        {
            if (!bFirst)
            {
                szTemp += sprintf(szTemp, " | ");
            }
            else
            {
                szTemp += sprintf(szTemp, "");
            }
            bFirst = FALSE; \
            szTemp += sprintf(szTemp, "%s", DUMPARRAY[x+1]);
        }
    }
    
    ULONG64 dwRemainder = dwFlag & ~((1 << (dwArraySize-1))-1);
    if (dwRemainder)
    {
        szTemp += sprintf(szTemp, " [remainder: %08x]", dwRemainder);
    }

    szTemp += sprintf(szTemp, " (%08x)", dwFlag);
    
    return szName;
}

__declspec(noinline) LPCSTR ENUMFLAGFn(DWORD dwFlag, LPCSTR DUMPARRAY[], DWORD dwArraySize, BOOL bVerbose = FALSE)
{
    static CHAR szName[1024];
    ZeroMemory(szName, 1024);

    LPSTR szTemp = szName;

    if (dwFlag < dwArraySize)
    {
        if (bVerbose)
        {
            szTemp += sprintf(szTemp, "%s (%08x)", DUMPARRAY[dwFlag], dwFlag);
        }
        else
        {
            return DUMPARRAY[dwFlag];
        }
    }
    else
    {
        szTemp += sprintf(szTemp, "[unknown value] (%08x)", dwFlag);
    }
    return szName;
}

#define BITFLAG(dwValue, DUMPARRAY)  BITFLAGFn(dwValue, DUMPARRAY, celems(DUMPARRAY))
#define ENUMFLAGVERBOSE(dwValue, DUMPARRAY) ENUMFLAGFn(dwValue, DUMPARRAY, celems(DUMPARRAY), TRUE)
#define ENUMFLAG(dwValue, DUMPARRAY) ENUMFLAGFn(dwValue, DUMPARRAY, celems(DUMPARRAY), FALSE)

HRESULT CALLBACK HrDumpConnectionListFromAddressCallBack(LPVOID pParam, LPCVOID pvKey, LPCVOID pvRef, LPCVOID pvAddress)
{
    const ConnListCore::key_type& keyArg = *reinterpret_cast<const ConnListCore::key_type*>(pvKey);
    const ConnListCore::referent_type& refArg = *reinterpret_cast<const ConnListCore::referent_type*>(pvRef);

    const ConnListEntry& cle = refArg;
    const CConFoldEntry& cfe = cle.ccfe;

    dprintfVerbose("Address: 0x%08x\n", pvAddress);

    WCHAR szNameEntry[MAX_PATH];
    dprintfVerbose("%d: Reading szNameEntry");
    
    HRESULT hr = HrReadMemory(cfe.m_pszName, celems(szNameEntry), szNameEntry);
    if (SUCCEEDED(hr))
    {
        if (*szNameEntry)
        {
            LPWSTR szGUID;
            StringFromCLSID(cfe.m_guidId, &szGUID);

            dprintf(" * %S [%s:%s:%s:%s]\n", szNameEntry,
                    ENUMFLAG(cfe.m_ncs, DBG_NCSNAMES), 
                    BITFLAG(cfe.m_dwCharacteristics, DBG_NCCFFLAGS),
                    ENUMFLAG(cfe.m_ncm, DBG_NCMNAMES), 
                    ENUMFLAG(cfe.m_ncsm, DBG_NCSMNAMES) );
            dprintf("       guidId      : %S\n", szGUID);
            CoTaskMemFree(szGUID);

            StringFromCLSID(cfe.m_clsid, &szGUID);
            dprintf("       clsId       : %S\n", szGUID);
            CoTaskMemFree(szGUID);

            hr = HrReadMemory(cfe.m_pszDeviceName , celems(szNameEntry), szNameEntry);
            if (SUCCEEDED(hr))
            {
                dprintf("       Device Name : %S\n", szNameEntry);
            }

            hr = HrReadMemory(cfe.m_pszPhoneOrHostAddress, celems(szNameEntry), szNameEntry);
            if (SUCCEEDED(hr))
            {
                dprintf("       Phone #     : %S\n", szNameEntry);
            }
        
            switch (cfe.m_wizWizard)
            {
                case WIZARD_NOT_WIZARD:
                    break;
                case WIZARD_HNW:
                    dprintf("       WIZARD_HNW\n");
                    break;
                case WIZARD_MNC:
                    dprintf("       WIZARD_MNC\n");
                    break;
            }
        }
    }
    
    return hr;
}

HRESULT HrDumpConnectionListFromAddress(ULONG64 address)
{
    HRESULT hr = E_FAIL;

    CConnectionList *pConnectionList = reinterpret_cast<CConnectionList *>(new BYTE[sizeof(CConnectionList)]);
    if (pConnectionList)
    {
        ZeroMemory(pConnectionList, sizeof(CConnectionList));

        dprintfVerbose("Reading pConnectionList (g_ccl) ");
        hr = HrReadMemoryFromUlong(address, sizeof(CConnectionList), pConnectionList);
        if (SUCCEEDED(hr))
        {
            hr = StlDbgMap<ConnListCore>::HrDumpAll(pConnectionList->m_pcclc, NULL, &HrDumpConnectionListFromAddressCallBack);
        }

        if (FAILED(hr))
        {
            dprintf("Could not dump connection list\n");
        }

        delete[] reinterpret_cast<LPBYTE>(pConnectionList);
    }
    return hr;
}

#define GET_THISADJUST(CClassName, IInterfaceName) \
        static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(dynamic_cast<const IInterfaceName *>(reinterpret_cast<CClassName *>(0x0FFFFFFF))) \
                            - reinterpret_cast<DWORD_PTR>(reinterpret_cast<LPVOID>(0x0FFFFFFF)))

// #define reverse_cast(CClassName, IInterfaceName, IInterfacePtr) \
//        reinterpret_cast<const CClassName *>(reinterpret_cast<DWORD_PTR>(IInterfacePtr) - GET_THISADJUST(CClassName, IInterfaceName) )

#define reverse_cast(CClassName, IInterfaceName, IInterfacePtr) \
         reinterpret_cast<const CClassName *>(reinterpret_cast<DWORD_PTR>(IInterfacePtr) \
         - static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(dynamic_cast<const IInterfaceName *>(reinterpret_cast<CClassName *>(0x0FFFFFFF))) \
         - reinterpret_cast<DWORD_PTR>(reinterpret_cast<LPVOID>(0x0FFFFFFF))) )

HRESULT CALLBACK HrDumpNetStatisticsCentralFromAddressCallBack(LPVOID pParam, LPCVOID pvKey, LPCVOID pvRef, LPCVOID pvAddress)
{
    HRESULT hr = E_FAIL;

    dprintfVerbose("Address: 0x%08x\n", pvAddress);
    
    const INetStatisticsEngine *pInse     = reinterpret_cast<const INetStatisticsEngine *>(pvRef);
//    const CNetStatisticsEngine *pcNseReal = reverse_cast(CNetStatisticsEngine, INetStatisticsEngine, pInse);
    const CNetStatisticsEngine *pcNseReal = static_cast<const CNetStatisticsEngine *>(pInse);

    CNetStatisticsEngine *pNse = reinterpret_cast<CNetStatisticsEngine *>(new BYTE[sizeof(CNetStatisticsEngine)]);
    if (pNse)
    {
        hr = HrReadMemory( pcNseReal, sizeof(CNetStatisticsEngine), pNse);
        if (SUCCEEDED(hr))
        {
            LPWSTR szGUID;
            StringFromCLSID(pNse->m_guidId, &szGUID);
            dprintf(" * %S\n", szGUID);
            CoTaskMemFree(szGUID);

            dprintf("       %s, %s, %s\n", 
                    ENUMFLAG(pNse->m_ncmType, DBG_NCMNAMES), 
                    ENUMFLAG(pNse->m_ncsmType, DBG_NCSMNAMES),
                    BITFLAG(pNse->m_dwCharacter, DBG_NCCFFLAGS)
                    );
           
            if (pNse->m_psmEngineData)
            {
                STATMON_ENGINEDATA *pSmed = reinterpret_cast<STATMON_ENGINEDATA *>(new BYTE[sizeof(STATMON_ENGINEDATA)]);
                if (pSmed)
                {
                    dprintfVerbose("Reading STATMON_ENGINEDATA", pNse->m_psmEngineData);
                    hr = HrReadMemory(pNse->m_psmEngineData, sizeof(STATMON_ENGINEDATA), pSmed);
                    if (SUCCEEDED(hr))
                    {
                        dprintf("       m_psmEngineData\n");
                        dprintf("          status             : %s\n", ENUMFLAGVERBOSE(pSmed->SMED_CONNECTIONSTATUS, DBG_NCSNAMES) );
                        dprintf("          duration           : 0x%08x (%d)\n", pSmed->SMED_DURATION, pSmed->SMED_DURATION);
                        dprintf("          xmit speed         : 0x%08x (%d)\n", pSmed->SMED_SPEEDTRANSMITTING, pSmed->SMED_SPEEDTRANSMITTING);
                        dprintf("          recv speed         : 0x%08x (%d)\n", pSmed->SMED_SPEEDRECEIVING, pSmed->SMED_SPEEDRECEIVING);
                        dprintf("          xmit bytes         : 0x%016I64x (%I64d)\n", pSmed->SMED_BYTESTRANSMITTING, pSmed->SMED_BYTESTRANSMITTING);
                        dprintf("          recv bytes         : 0x%016I64x (%I64d)\n", pSmed->SMED_BYTESRECEIVING, pSmed->SMED_BYTESRECEIVING);
                        dprintf("          xmit packets       : 0x%016I64x (%I64d)\n", pSmed->SMED_PACKETSTRANSMITTING, pSmed->SMED_PACKETSTRANSMITTING);
                        dprintf("          recv packets       : 0x%016I64x (%I64d)\n", pSmed->SMED_PACKETSRECEIVING, pSmed->SMED_PACKETSRECEIVING);
                        dprintf("          xmit (compressed)  : 0x%08x (%d)\n", pSmed->SMED_COMPRESSIONTRANSMITTING, pSmed->SMED_COMPRESSIONTRANSMITTING);
                        dprintf("          recv (compressed)  : 0x%08x (%d)\n", pSmed->SMED_COMPRESSIONRECEIVING, pSmed->SMED_COMPRESSIONRECEIVING);
                        dprintf("          xmit (errors)      : 0x%08x (%d)\n", pSmed->SMED_ERRORSTRANSMITTING, pSmed->SMED_ERRORSTRANSMITTING);
                        dprintf("          recv (errors)      : 0x%08x (%d)\n", pSmed->SMED_ERRORSRECEIVING, pSmed->SMED_ERRORSRECEIVING);

                        switch (pSmed->SMED_DHCP_ADDRESS_TYPE)
                        {
                            case NORMAL_ADDR:
                                dprintf("          DHCP               : Assigned by DHCP\n");
                                break;
                            case AUTONET_ADDR:
                                dprintf("          DHCP               : Autonet\n");
                                break;
                            case ALTERNATE_ADDR:
                                dprintf("          DHCP               : Alternate\n");
                                break;
                            case STATIC_ADDR:
                                dprintf("          DHCP               : Static\n");
                                break;
                            case UNKNOWN_ADDR:
                            default:
                                dprintf("          DHCP               : Address type unknown (%d)\n", pSmed->SMED_DHCP_ADDRESS_TYPE);
                                break;

                        }

                        switch (pSmed->SMED_INFRASTRUCTURE_MODE)
                        {
                            case IM_NOT_SUPPORTED:
                                dprintf("          Infrastructure Mode: NOT Supported\n");
                                break;
                            case IM_NDIS802_11IBSS:
                                dprintf("          Infrastructure Mode: 802.11 IBSS\n");
                                break;
                            case IM_NDIS802_11INFRASTRUCTURE:
                                dprintf("          Infrastructure Mode: 802.11 Infrastructure\n");
                                break;
                            case IM_NDIS802_11AUTOUNKNOWN:
                                dprintf("          Infrastructure Mode: 802.11 Automatic/Unknown\n");
                                break;
                            default:
                                dprintf("          Infrastructure Mode: Unknown (%d)\n", pSmed->SMED_INFRASTRUCTURE_MODE);
                                break;
                        }
                        
                        dprintf("          802.11 Encryption  : %s\n", pSmed->SMED_802_11_ENCRYPTION_ENABLED ? "Enabled" : "Disabled");
                        dprintf("          802.11 Signal Stren: %d\n", pSmed->SMED_802_11_SIGNAL_STRENGTH);
                        dprintf("          802.11 SSID        : %S\n", pSmed->SMED_802_11_SSID);
                           
                        delete reinterpret_cast<LPBYTE>(pSmed);
                    }
                }
            }
        }
        
        delete[] reinterpret_cast<LPBYTE>(pNse);
    }
    
    return hr;
}

#define _OOPPTR(pClass, member) \
    (LPVOID)((((LPBYTE)( &(pClass->member) )) - (LPBYTE)pClass + *(LPDWORD)pClass ))

HRESULT HrDumpNetStatisticsCentralFromAddress(ULONG64 address)
{
    HRESULT hr = E_FAIL;

    CNetStatisticsCentral *pNetStatisticsCentral = reinterpret_cast<CNetStatisticsCentral *>(new BYTE[sizeof(CNetStatisticsCentral)]);
    if (pNetStatisticsCentral)
    {
        ZeroMemory(pNetStatisticsCentral, sizeof(CNetStatisticsCentral));

        dprintfVerbose("Reading CNetStatisticsCentral (g_pnscCentral) ");
        hr = HrReadMemoryFromUlong(address, sizeof(CNetStatisticsCentral), pNetStatisticsCentral);
        if (SUCCEEDED(hr))
        {
            hr = StlDbgList<list<INetStatisticsEngine *> >::HrDumpAll( _OOPPTR(pNetStatisticsCentral, m_pnselst), NULL, &HrDumpNetStatisticsCentralFromAddressCallBack);
        }

        if (FAILED(hr))
        {
            dprintf("Could not dump statistics monitor tool entry list\n");
        }

        delete[] reinterpret_cast<LPBYTE>(pNetStatisticsCentral);
    }
    return hr;
}

DECLARE_API ( connlist )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = E_FAIL;;
    ULONG64 g_cclAddress;
    if (*args)
    {
        hr = HrGetAddressOfSymbol(args, &g_cclAddress);
    }
    else
    {
        hr = HrGetAddressOfSymbol("netshell!g_ccl", &g_cclAddress);
    }

    if (SUCCEEDED(hr))
    {
        hr = ::HrDumpConnectionListFromAddress(g_cclAddress);
    }

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage:\n"
            "   connlist                         - Dumps out the connection\n"
            "   connlist <address>               - Dumps out the connection list from address\n");
    }
}


ULONG WDBGAPI SYM_DUMP_FIELD_CALLBACK_SSST(
	PFIELD_INFO pField,
	PVOID UserContext
	)
{
    return TRUE;
}

ULONG Dt( IN LPCSTR Type,
          IN ULONG64 Addr,
          IN ULONG Recur,
          IN ULONG FieldInfoCount,
          IN FIELD_INFO FieldInfo[]
       )
{
    if (
           (0 == _stricmp("LPVOID", Type)) ||
           (0 == _stricmp("LPCVOID", Type))
       )
    {
        return 0;
    }

    SYM_DUMP_PARAM Param;

    Param.size = sizeof( Param);
    Param.sName = (PUCHAR)&Type[0];
    Param.addr = Addr;
    Param.listLink = NULL;
    Param.Context = NULL;
    Param.nFields = FieldInfoCount;
    Param.Fields = FieldInfo;

    if ( 
            (0 == _stricmp("GUID",   Type))
        )
    {
        Param.Options = DBG_DUMP_RECUR_LEVEL(Recur) | DBG_DUMP_FIELD_CALL_BEFORE_PRINT | DBG_DUMP_CALL_FOR_EACH;
        Param.CallbackRoutine = SYM_DUMP_FIELD_CALLBACK_SSST;
    }
    else
    {
        Param.Options = DBG_DUMP_RECUR_LEVEL(Recur);
        Param.CallbackRoutine = NULL; // SYM_DUMP_FIELD_CALLBACK_SPACE;
    }

    return Ioctl( IG_DUMP_SYMBOL_INFO, &Param, Param.size);
}

typedef map<LPVOID, LPVOID> LPVOIDMAP;
typedef list<LPVOID> LPVOIDLIST;

class CKeyRefArgParam
{
public:
    DWORD dwRecursion;
    LPCSTR szKeyType;
    LPCSTR szRefType;
};

HRESULT CALLBACK HrDumpStlMapFromAddressCallBack(LPVOID pParam, LPCVOID pvKey, LPCVOID pvRef, LPCVOID pvAddress)
{
    const CKeyRefArgParam *pKeyRefArgParam = reinterpret_cast<const CKeyRefArgParam*>(pParam);

    ULONG64 Key = (ULONG64)(ULONG_PTR)pvAddress;
    ULONG64 Ref = Key + GetTypeSize(pKeyRefArgParam->szKeyType);
   
    dprintf("Key (%s) @ 0x%08x :\n", pKeyRefArgParam->szKeyType, Key);
    Dt(pKeyRefArgParam->szKeyType, Key, pKeyRefArgParam->dwRecursion, 0, NULL);

    dprintf("Referent (%s) @ 0x%08x :\n", pKeyRefArgParam->szRefType, Ref);
    Dt(pKeyRefArgParam->szRefType, Ref, pKeyRefArgParam->dwRecursion, 0, NULL);
    
    return S_OK;
}

DECLARE_API ( stlmap )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = E_FAIL;;
    ULONG64 ulAddress;
    if (*args)
    {
        hr = S_OK;
        
        LPSTR szKey  = NULL;
        LPSTR szRef  = NULL;
        LPSTR szArgs = NULL;

        CHAR argsCpy[MAX_PATH];

        DWORD dwRecursion = 0;

        if (0 == _strnicmp(args, "-r", 2))
        {
            dwRecursion = args[2] - '0';
            if (dwRecursion > 9)
            {
                dwRecursion = 3;
            }
    
            LPCSTR pArgs = args;
            while (*pArgs && *pArgs != ' ')
            {
                pArgs++;
            }
            strncpy(argsCpy, pArgs, MAX_PATH);
        }
        else
        {
            strncpy(argsCpy, args, MAX_PATH);
        }
       
        szKey = strtok(argsCpy, " ");
        if (szKey)
        {
            szRef = strtok(NULL, " ");
            if (szRef)
            {
                szArgs = szRef + strlen(szRef) + 1;
                if (!*szArgs)
                {
                    hr = E_INVALIDARG;
                    dprintf("Must specify location\n");
                }
            }
            else
            {
                hr = E_INVALIDARG;
                dprintf("Must specify referent type\n");
            }
        }
        else
        {
            hr = E_INVALIDARG;
            dprintf("Must specify key type\n");
        }

        if (S_OK == hr)
        {
            dprintfVerbose("%s,%s,%s\n", szKey, szRef, szArgs);

            if (SUCCEEDED(hr))
            {
                CKeyRefArgParam KeyRefArgParam;
                KeyRefArgParam.dwRecursion = dwRecursion;
                KeyRefArgParam.szKeyType = szKey;
                KeyRefArgParam.szRefType = szRef;

                hr = HrGetAddressOfSymbol(szArgs, &ulAddress);
                if (SUCCEEDED(hr))
                {
            
                    hr = StlDbgMap<LPVOIDMAP>::HrDumpAll((LPVOID)ulAddress, &KeyRefArgParam, &HrDumpStlMapFromAddressCallBack);
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage:\n"
            "     stlmap [-rx] <keytype> <reftype> <address> - Dumps out an STL map from <address> for the <KeyType> and <RefType>\n"
            "e.g. stlmap -r3 GUID LPWSTR mySymbol - Dumps out a map of strings (key-ed by GUID) from mySymbol.\n");
    }
}

HRESULT CALLBACK HrDumpStlListFromAddressCallBack(LPVOID pParam, LPCVOID pvKey, LPCVOID pvRef, LPCVOID pvAddress)
{
    const CKeyRefArgParam *pKeyRefArgParam = reinterpret_cast<const CKeyRefArgParam*>(pParam);

    ULONG64 Ref = (ULONG64)(ULONG_PTR)pvAddress;
  
    dprintf("Value (%s) @ 0x%08x :\n", pKeyRefArgParam->szRefType, Ref);
    Dt(pKeyRefArgParam->szRefType, Ref, pKeyRefArgParam->dwRecursion, 0, NULL);
    
    return S_OK;
}

DECLARE_API ( stllist )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = E_FAIL;;
    ULONG64 ulAddress;
    if (*args)
    {
        hr = S_OK;
        
        LPSTR szRef  = NULL;
        LPSTR szArgs = NULL;

        CHAR argsCpy[MAX_PATH];

        DWORD dwRecursion = 0;

        if (0 == _strnicmp(args, "-r", 2))
        {
            dwRecursion = args[2] - '0';
            if (dwRecursion > 9)
            {
                dwRecursion = 3;
            }
    
            LPCSTR pArgs = args;
            while (*pArgs && *pArgs != ' ')
            {
                pArgs++;
            }
            strncpy(argsCpy, pArgs, MAX_PATH);
        }
        else
        {
            strncpy(argsCpy, args, MAX_PATH);
        }
       
        szRef = strtok(argsCpy, " ");
        if (szRef)
        {
            szArgs = szRef + strlen(szRef) + 1;
            if (!*szArgs)
            {
                hr = E_INVALIDARG;
                dprintf("Must specify location\n");
            }
        }
        else
        {
            hr = E_INVALIDARG;
            dprintfVerbose("Must specify referent type\n");
        }

        if (S_OK == hr)
        {
            dprintf("%s,%s\n", szRef, szArgs);

            if (SUCCEEDED(hr))
            {
                CKeyRefArgParam KeyRefArgParam;
                KeyRefArgParam.dwRecursion = dwRecursion;
                KeyRefArgParam.szKeyType = NULL;
                KeyRefArgParam.szRefType = szRef;

                hr = HrGetAddressOfSymbol(szArgs, &ulAddress);
                if (SUCCEEDED(hr))
                {
            
                    hr = StlDbgList<LPVOIDLIST>::HrDumpAll((LPVOID)ulAddress, &KeyRefArgParam, &HrDumpStlListFromAddressCallBack);
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage:\n"
            "     stllist [-rx] <ValueType> <address> - Dumps out an STL list from <address> for the <ValueType>\n"
            "e.g. stllist -r3 LPWSTR mySymbol - Dumps out a list of LPWSTRs from mySymbol.\n");
    }
}

DECLARE_API ( stats )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = E_FAIL;;
    ULONG64 g_cclAddress;
    if (*args)
    {
        hr = HrGetAddressOfSymbol(args, &g_cclAddress);
    }
    else
    {
        hr = HrGetAddressOfSymbol("netshell!g_pnscCentral", &g_cclAddress);
    }

    if (SUCCEEDED(hr))
    {
        hr = ::HrDumpNetStatisticsCentralFromAddress(g_cclAddress);
    }

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage:\n"
            "   connlist                         - Dumps out the connection\n"
            "   connlist <address>               - Dumps out the connection list from address\n");
    }
}

#define DECLARE_FLAGDUMP_API( ApiName, DUMPARRAY ) \
    DECLARE_API ( ApiName ) \
    { \
        if (*args) \
        { \
            ULONG64 dwFlag = GetExpression(args); \
            if (dwFlag >= celems(DUMPARRAY)) \
            { \
                dprintf("unknown value: %x\n", dwFlag); \
            } \
            else \
            { \
                dprintf("%s\n", DUMPARRAY[dwFlag]); \
            } \
        } \
        else \
        { \
            for (DWORD x = 0; x < celems(DUMPARRAY); x++) \
            { \
                dprintf("%x: %s\n", x, DUMPARRAY[x] ); \
            } \
        } \
    }

#define DECLARE_BITFLAGDUMP_API( ApiName, DUMPARRAY ) \
    DECLARE_API ( ApiName ) \
    { \
        if (*args) \
        { \
            ULONG64 dwFlag = GetExpression(args); \
            dprintf("%s\n", BITFLAGFn(dwFlag, DUMPARRAY, celems(DUMPARRAY) )); \
        } \
        else \
        { \
            dprintf("%08x: %s\n", 0, DUMPARRAY[0] ); \
            for (DWORD x = 1; x < celems(DUMPARRAY); x++) \
            { \
                dprintf("%08x: %s\n", 1 << (x-1), DUMPARRAY[x] ); \
            } \
        } \
    }

DECLARE_FLAGDUMP_API(ncm,  DBG_NCMNAMES)
DECLARE_FLAGDUMP_API(ncs,  DBG_NCSNAMES)
DECLARE_FLAGDUMP_API(ncsm, DBG_NCSMNAMES)
DECLARE_BITFLAGDUMP_API(nccf, DBG_NCCFFLAGS)
DECLARE_BITFLAGDUMP_API(ncf, DBG_NCFFLAGS)
DECLARE_FLAGDUMP_API(eventmgr, DBG_EMNAMES)
DECLARE_FLAGDUMP_API(event, DBG_CMENAMES)

DECLARE_API ( icon )
{
    if (*args)
    {
        DWORD dwFlag = static_cast<DWORD>(GetExpression(args));
        DWORD dwIconManager = (dwFlag & MASK_ICONMANAGER) >> SHIFT_ICONMANAGER;
        dprintf("Icon manager  : %s\n", ENUMFLAGVERBOSE(dwIconManager, DBG_ENUM_ICON_MANAGER));
        switch (dwIconManager <<  SHIFT_ICONMANAGER)
        {
            case ICO_MGR_INTERNAL:
            {
                DWORD ncsm          = (dwFlag & MASK_NETCON_SUBMEDIATYPE) >> SHIFT_NETCON_SUBMEDIATYPE;
                DWORD ncm           = (dwFlag & MASK_NETCON_MEDIATYPE) >> SHIFT_NETCON_MEDIATYPE;
                DWORD connection    = (dwFlag & MASK_CONNECTION) >> SHIFT_CONNECTION;
                DWORD status        = (dwFlag & MASK_STATUS) >> SHIFT_STATUS;
                DWORD characteristic= (dwFlag & MASK_CHARACTERISTICS) >> SHIFT_CHARACTERISTICS;

                dprintf("Media Subtype : %s\n", ENUMFLAGVERBOSE(ncsm, DBG_NCSMNAMES));
                dprintf("Media Type    : %s\n", ENUMFLAGVERBOSE(ncm, DBG_NCMNAMES));
                dprintf("Connection    : %s\n", ENUMFLAGVERBOSE(connection, DBG_ENUM_CONNECTION_ICON));
                dprintf("Status        : %s\n", ENUMFLAGVERBOSE(status, DBG_ENUM_STAT_ICON));
                dprintf("Characteristic: %s\n", BITFLAG(characteristic, DBG_ENUM_CHARACTERISTICS_ICON));
            }
            break;

            case ICO_MGR_CM:
            {
                DWORD characteristic= (dwFlag & MASK_CHARACTERISTICS) >> SHIFT_CHARACTERISTICS;
                dprintf("Characteristic: %s\n", BITFLAG(characteristic, DBG_ENUM_CHARACTERISTICS_ICON));
            }
            break;

            case ICO_MGR_RESOURCEID:
            {
                DWORD characteristic= (dwFlag & MASK_CHARACTERISTICS) >> SHIFT_CHARACTERISTICS;
                dprintf("Characteristic: %s\n", BITFLAG(characteristic, DBG_ENUM_CHARACTERISTICS_ICON));
            }
            break;

            default:
            {
            }
            break;
        }
    }
    else
    {
        dprintf("Usage:\n"
                "icon <value>                     - Displays the ENUM_MEDIA_ICONMASK <corresponding to value>\n"
                "(must specify an argument)\n");
    }
}

/*
  A built-in help for the extension dll
*/

DECLARE_API ( help ) 
{
    dprintf("Help for NetConfig ncext.dll\n"
            "   tracelist <module>               - List all the current traces enabled for module <module>\n"
            "   tracelist all <module>           - List currently available traces for module <module>\n"
            "   traceadd <module> \"tracetag\"     - Starts tracing for a specific tracetag\n"
            "   tracedel <module> \"tracetag\"     - Stops tracing for a specific tracetag\n"
            "   flaglist <module>                - dump debug flags enabled for module <module>\n"
            "   flaglist all <module>            - dump all available debug flags for module <module>\n"
            "   flagadd <module> \"flag\"          - Enables a specific debug flag\n"
            "   flagdel <module> \"flag\"          - Disables a specific debug flag\n"
            "   stlmap [-rx]  <keytype> <reftype> <address> - Dumps out an STL map from <address> for the <KeyType> and <RefType>\n"
            "   stllist [-rx] <ValueType> <address> - Dumps out an STL list from <address> for the <ValueType>\n"
            " * connlist                         - Dumps out the connection\n"
            " * connlist <address>               - Dumps out the connection list from address\n"
            " * stats                            - Displays the CNetStatisticsCentral\n");

    dprintf("   event [value]                    - Displays the CONMAN_EVENTTYPE [corresponding to value]\n"
            "   eventmgr [value]                 - Displays the CONMAN_MANAGER [corresponding to value]\n"
            "   icon <value>                     - Displays the ENUM_MEDIA_ICONMASK <corresponding to value>\n"
            "   ncm [value]                      - Displays the NETCON_MEDIATYPE [corresponding to value]\n"
            "   ncsm [value]                     - Displays the NETCON_SUBMEDIATYPE [corresponding to value]\n"
            "   ncs [value]                      - Displays the NETCON_STATUS [corresponding to value]\n"
            "   nccf [value]                     - Displays the NETCON_CHARACTERISTICS [corresponding to value]\n"
            "   ncf [value]                      - Displays the COMPONENT_CHARACTERISTICS [corresponding to value]\n"
            "   help                             - Shows this help\n"
            " * Commands will work on same platform only (x86 to x86, or IA64 on IA64).\n"
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nctraceui\tagspage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T A G S P A G E . C P P
//
//  Contents:   TraceTags propsheet page handlers
//
//  Notes:
//
//  Author:     jeffspr   24 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <crtdbg.h>
#include "ncdebug.h"
#include <ncui.h>
#include "traceui.h"



//---[ Globals ]--------------------------------------------------------------

#if 0
typedef struct _LV_COLUMN {
    UINT mask;
    int fmt;
    int cx;
    PWSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMN;
#endif

//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:

#define LVCF_NORMAL (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH)

static LV_COLUMN    g_lvcTags[] =
{
    {LVCF_NORMAL,   LVCFMT_LEFT,    90,     L"Name",           0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    180,    L"Description",    0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    70,     L"Debug Logging",  0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    70,     L"File Logging",   0,  0}
};

const DWORD g_dwTagColumnCount = celems(g_lvcTags);

static const UINT SELS_UNCHECKED     = 0x1;
static const UINT SELS_CHECKED       = 0x2;


CTraceTagPage::CTraceTagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::~CTraceTagPage
//
//  Purpose:    Destroys the CTraceTagPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
CTraceTagPage::~CTraceTagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    HRESULT             hr = S_OK;

    m_hwndLV = GetDlgItem(IDC_TRACETAGS);

    for(DWORD dwLoop = 0; dwLoop < g_dwTagColumnCount; dwLoop++)
    {
        ListView_InsertColumn(m_hwndLV,dwLoop+1,&(g_lvcTags[dwLoop]));
    }

    LV_ITEM lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    for(INT iLoop = 0; iLoop < g_nTraceTagCount; iLoop++)
    {
        WCHAR szShortName[c_iMaxTraceTagShortName+1];

        lvi.iItem = iLoop;
        lvi.lParam = reinterpret_cast<LPARAM>(&g_TraceTags[iLoop]);

        MultiByteToWideChar(CP_ACP, 0, g_TraceTags[iLoop].szShortName,
                -1, szShortName, c_iMaxTraceTagShortName+1);
        lvi.pszText = szShortName;

        // We will refresh the state of the whole list in the end

        INT ret = ListView_InsertItem(m_hwndLV, &lvi);
        if(ret != -1)
        {
            WCHAR szColumnText[c_iMaxTraceTagDescription+1];

            for(INT iColumn = 1; iColumn < g_dwTagColumnCount; iColumn++)
            {
                switch(iColumn)
                {
                    // Description
                    //
                    case 1:
                        MultiByteToWideChar(CP_ACP, 0, g_TraceTags[iLoop].szDescription,
                            -1, szColumnText, c_iMaxTraceTagDescription+1);
                        break;

                    // Debug logging
                    //
                    case 2:
                        lstrcpyW(szColumnText, L"Enabled");
                        break;

                    // File logging
                    //
                    case 3:
                        lstrcpyW(szColumnText, L"Disabled");
                        break;

                    default:
                        AssertSz(FALSE, "Bad column in OnInitDialog switch");
                        break;
                }

                ListView_SetItemText(m_hwndLV, iLoop, iColumn,
                        szColumnText);
            }
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnHelp
//
//  Purpose:    Handles the WM_HELP message.
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                            BOOL& bHandled)
{
    OnTraceHelpGeneric(m_hWnd, lParam);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                               BOOL& bHandled)
{
    UninitTraceListView(m_hwndLV);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnSetCursor
//
//  Purpose:    Called in response to the WM_SETCURSOR message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Jan 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& bHandled)
{
    if (m_hPrevCurs)
    {
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        return TRUE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnAdd
//
//  Purpose:    Handles the clicking of the Add button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                           BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    hr = HrLvAdd(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter, &m_listBindingPaths);
    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CTraceTagPage::OnAdd", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnRemove
//
//  Purpose:    Handles the clicking of the Remove button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                              BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvRemove(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter,
                    &m_listBindingPaths);

    // if list is empty, reset the buttons
    if (0 == ListView_GetItemCount(m_hwndLV))
    {
        // Reset the buttons and the description text based on the changed selection
        LvSetButtons(m_handles);
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CTraceTagPage::OnRemove", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvProperties(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths);

    TraceError("CTraceTagPage::OnProperties", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    if (m_fReentrancyCheck)
    {
        TraceTag(ttidLanUi, "CTraceTagPage::OnApply is being re-entered! "
                 "I'm outta here!");

        // Don't allow the automatic EndDialog() to work just yet
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
        return TRUE;
    }

    m_hPrevCurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = m_pnc->Validate();
    if (hr == S_OK)
    {
        BOOL    fReboot = FALSE;

        // Note: This function becomes reentrant because INetCfg::Apply()
        // has a message pump in it which causes the PSN_APPLY message to
        // be processed twice. This will happen ONLY if the user double-clicks
        // the OK button.
        m_fReentrancyCheck = TRUE;

        TraceTag(ttidLanUi, "Calling INetCfg::Apply()");
        hr = m_pnc->Apply();
        if (NETCFG_S_REBOOT == hr)
        {
            fReboot = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidLanUi, "INetCfg::Apply() succeeded");
            hr = m_pnc->Uninitialize();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fRebootAlreadyRequested || fReboot)
            {
                DWORD dwFlags = QUFR_REBOOT;
                if (!m_fRebootAlreadyRequested)
                    dwFlags |= QUFR_PROMPT;

                (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                              m_hWnd, IDS_LAN_CAPTION,
                                              IDS_REBOOT_REQUIRED,
                                              dwFlags);
            }
        }
    }

    // Apply "general" properties
    //
    if (SUCCEEDED(hr))
    {
        LANCON_INFO linfo = {0};

        linfo.fShowIcon = IsDlgButtonChecked(IDC_CHK_ShowIcon);

        // Set new value of show icon property
        hr = m_plan->SetInfo(LCIF_ICON, &linfo);
    }

    // Normalize result
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (m_hPrevCurs)
    {
        SetCursor(m_hPrevCurs);
        m_hPrevCurs = NULL;
    }

    // Reset this just in case
    m_fReentrancyCheck = FALSE;

    TraceError("CTraceTagPage::OnApply", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Jan 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    AssertSz(m_pnc, "I need a NetCfg object!");

    hr = m_pnc->Uninitialize();

    TraceError("CTraceTagPage::OnCancel", hr);
#endif
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    LvDeleteItem(m_hwndLV, pnmlv->iItem);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths, FALSE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnDbClick
//
//  Purpose:    Called in response to the NM_DBLCLK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                m_pnccAdapter, &m_listBindingPaths, TRUE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnKeyDown
//
//  Purpose:    Called in response to the LVN_KEYDOWN message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
#if 0
    OnListKeyDown(m_hwndLV, &m_listBindingPaths, plvkd->wVKey);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   10 Nov 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    HANDLES         handles;

    Assert(pnmlv);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_handles);
#endif
    return 0;
}

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\dbgext\ncext.h ===
/*++
   Copyright (c) 2000  Microsoft Corporation

Module:

    Simple.h
    
    
    Common header file for extensions

--*/

#if (__cplusplus)
#include <pch.h>
#else
#include <windows.h>
#endif
#include <dbghelp.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\common\nctraceui\traceui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E U I . C P P
//
//  Contents:   Trace configuration UI property sheet code
//
//  Notes:
//
//  Author:     jeffspr   1 Sept 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include "ncdebug.h"
#include "ncui.h"
#include "traceui.h"

//---[ Constants ]------------------------------------------------------------

const WCHAR  c_szTraceUICaption[]    = L"Tracing Configuration";    // Propsheet caption


HRESULT HrOpenTracingUI(HWND hwndOwner)
{
    HRESULT             hr          = S_OK;
    INT_PTR             nRet        = 0;
    CPropSheetPage *    ppspTrace   = new CTraceTagPage;
    CPropSheetPage *    ppspFlags   = new CDbgFlagPage;
    HPROPSHEETPAGE      hpsp[2]     = {0};
    PROPSHEETHEADER     psh;

    if (!ppspTrace || !ppspFlags)
    {
        hr = E_FAIL;
        goto Exit;
    }

    hpsp[0] = ppspTrace->CreatePage(IDD_TRACETAGS, 0);
    hpsp[1] = ppspTrace->CreatePage(IDD_DBGFLAGS, 0);

    ZeroMemory (&psh, sizeof(psh));
    psh.dwSize      = sizeof( PROPSHEETHEADER );
    psh.dwFlags     = PSH_NOAPPLYNOW;
    psh.hwndParent  = hwndOwner;
    psh.hInstance   = _Module.GetResourceInstance();
    psh.pszCaption  = c_szTraceUICaption;
    psh.nPages      = 2;
    psh.phpage      = hpsp;

    nRet = PropertySheet(&psh);

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTraceHelpGeneric
//
//  Purpose:    Generic help handler function.
//
//  Arguments:
//      hwnd   [in]     Parent window
//      lParam [in]     lParam passed to WM_HELP handler
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
VOID OnTraceHelpGeneric(HWND hwnd, LPARAM lParam)
{
    LPHELPINFO  lphi;

    lphi = reinterpret_cast<LPHELPINFO>(lParam);

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
#if 0   // NYI
        WinHelp(hwnd, c_szNetCfgHelpFile, HELP_CONTEXTPOPUP,
                lphi->iCtrlId);
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrInitTraceListView
//
//  Purpose:    Initialize the list view.
//              Iterate through all installed clients, services and protocols,
//              insert into the list view with the correct binding state with
//              the adapter used in this connection.
//
//  Arguments:
//      hwndList[in]:    Handle of the list view
//      pnc[in]:         The writable INetcfg pointer
//      pnccAdapter[in]: The INetcfgComponent pointer to the adapter used in this connection
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//

HRESULT HrInitTraceListView(HWND hwndList, HIMAGELIST *philStateIcons)
{
    HRESULT                     hr  = S_OK;
    RECT                        rc;
    LV_COLUMN                   lvc = {0};

    Assert(hwndList);

    // Set the shared image lists bit so the caller can destroy the class
    // image lists itself
    //
    DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE);
    SetWindowLong(hwndList, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));

    // Create state image lists
    *philStateIcons = ImageList_LoadBitmap(
                                    _Module.GetResourceInstance(),
                                    MAKEINTRESOURCE(IDB_TRACE_CHECKSTATE),
                                    16,
                                    0,
                                    PALETTEINDEX(6));
    ListView_SetImageList(hwndList, *philStateIcons, LVSIL_STATE);

    GetClientRect(hwndList, &rc);
    lvc.mask = LVCF_FMT; // | LVCF_WIDTH
    lvc.fmt = LVCFMT_LEFT;
//     lvc.cx = rc.right;

    ListView_InsertColumn(hwndList, 0, &lvc);

    if (SUCCEEDED(hr))
    {
        // Selete the first item
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
    }

    TraceError("HrInitTraceListView", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitTraceListView
//
//  Purpose:    Uninitializes the common component list view
//
//  Arguments:
//      hwndList [in]   HWND of listview
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
VOID UninitTraceListView(HWND hwndList)
{
    Assert(hwndList);

    // delete existing items in the list view
    ListView_DeleteAllItems( hwndList );
}

#endif  // ENABLE_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\dbgext\ncext.c ===
/*++

 Copyright (c) 2000  Microsoft Corporation

Module Name:

    ncext.c

--*/

#include "ncext.h"

#include <ntverp.h>
#include <dbghelp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Routine called by debugger after load
//
VOID
CheckVersion(
    VOID
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\dbgext\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>     // must come before shlguid.h
#include <shlguid.h>
#include <stdio.h>
#include <wchar.h>
#include <hnetcfg.h>
#include <iphlpapi.h>

// Fusion support
#include "shfusion.h"

#include "stlalgor.h"
#include "stllist.h"
#include "stlmap.h"
#include "stlset.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
#include "ncexcept.h"
#include "naming.h"

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>
#include <shlobjp.h>

#include <rasuip.h>
#include <rasdlg.h>

#include <comctrlp.h>
#include <shpriv.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobjp.h>
#include <shlapip.h>

#define LoadIconSize(hInstance, lpszName, dwSize) \
    reinterpret_cast<HICON>(LoadImage(hInstance, lpszName, IMAGE_ICON, dwSize, dwSize, LR_DEFAULTCOLOR))

#define LoadIconSmall(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 16)

#define LoadIconNormal(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 32)

#define LoadIconTile(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 48)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\benchmrk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . H
//
//  Contents:   Benchmark class.
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------


#pragma once

const CHAR c_sznEmpty[] = {'\0'};

class CBenchmark
{
public:
    CBenchmark();
    ~CBenchmark();
    void Start(PCSTR sznDescription);
    void Stop();
    double DblBenchmarkSeconds()
    {
        return m_i64TotalTime / static_cast<double>(m_i64Frequency);
    }
    PCSTR SznDescription(){return m_sznDescription ? m_sznDescription : c_sznEmpty;}
    PCSTR SznBenchmarkSeconds(unsigned short usPrecision);
private:
    __int64 m_i64Frequency;
    PSTR m_sznDescription;
    __int64 m_i64StartTime;
    __int64 m_i64TotalTime;
    BOOL m_fStarted;
    BOOL m_fSupported;
    CHAR m_sznSeconds[50];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\diagctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I A G C T X . H
//
//  Contents:   Implements the optional diagnostic context used by
//              CNetConfig.
//
//  Notes:
//
//  Author:     shaunco   10 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

#include <tracetag.h>

enum DIAG_FLAGS
{
    DF_SHOW_CONSOLE_OUTPUT      = 0x00000001,
    DF_DONT_START_SERVICES      = 0x00000002,
    DF_DONT_DO_PNP_BINDS        = 0x00000004,
    DF_SUPRESS_E_NEED_REBOOT    = 0x00000010,
    DF_REPAIR_REGISTRY_BINDINGS = 0x00000020,
};

// This structure is allocated dynamically by CDiagContext.  Place anything
// big in this structure (as opposed to CDiagContext) so that the size of
// CNetConfig is not directly increased.
//
struct DIAG_CONTEXT
{
    CHAR szPrintBuffer [4096];
};

class CDiagContext
{
private:
    DWORD           m_dwFlags;  // DIAG_FLAGS
    DIAG_CONTEXT*   m_pCtx;
    FILE*           m_pLogFile; // optional, and not owned by this class.
    PVOID           m_pvScratchBuffer;
    DWORD           m_cbScratchBuffer;

public:
    CDiagContext ()
    {
        m_dwFlags = 0;
        m_pCtx = NULL;
        m_pLogFile = NULL;
        m_pvScratchBuffer = NULL;
        m_cbScratchBuffer = 0;
    }

    ~CDiagContext ()
    {
        MemFree (m_pCtx);
        MemFree (m_pvScratchBuffer);
        // Do not close m_pLogFile.  It is not owned by this class.
    }

    VOID
    SetFlags (
        DWORD dwFlags /* DIAG_FLAGS */);

    VOID
    SetLogFile (
        FILE* pLogFile OPTIONAL)
    {
        m_pLogFile = pLogFile;
    }

    DWORD
    Flags () const;

    FILE *
    LogFile () const
    {
        return m_pLogFile;
    }

    PVOID
    GetScratchBuffer (
        OUT PDWORD pcbSize) const
    {
        *pcbSize = m_cbScratchBuffer;
        return m_pvScratchBuffer;
    }

    PVOID
    GrowScratchBuffer (
        IN OUT PDWORD pcbNewSize)
    {
        MemFree(m_pvScratchBuffer);
        m_pvScratchBuffer = MemAlloc (*pcbNewSize);
        m_cbScratchBuffer = (m_pvScratchBuffer) ? *pcbNewSize : 0;
        *pcbNewSize = m_cbScratchBuffer;
        return m_pvScratchBuffer;
    }

#ifdef COMPILE_WITH_TYPESAFE_PRINTF
    DEFINE_TYPESAFE_PRINTF2(INT,  Printf, TRACETAGID, PCSTR);
#else
    VOID
    Printf (
        TRACETAGID ttid,
        PCSTR pszFormat,
        ...);
#endif
};

extern CDiagContext* g_pDiagCtx;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\gpbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       G P B A S E . H
//
//  Contents:   Abstract Base Class for Handling NLA Changes that affect
//              Group Policies
//  Notes:
//
//  Author:     ckotze   20 Feb 2001
//
//----------------------------------------------------------------------------
#pragma once

class CGroupPolicyBase
{
public:
    CGroupPolicyBase(){};
    ~CGroupPolicyBase(){};

    virtual BOOL IsSameNetworkAsGroupPolicies() = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\diag.h ===
#pragma once
#include "diagctx.h"
#include "ncstring.h"
#include "netcon.h"

// The enum constants CMD_SHOW_LANA_DIAG, CMD_SHOW_LANA_PATHS,
// CMD_SET_LANA_NUMBER, and CMD_REWRITE_LANA_INFO are used by lanacfg.exe
// which is published outside Microsoft.
// To keep lanacfg.exe working with new versions of netcfgx.dll, we need
// to make sure these constants do not change. These are sent to a different
// entry point than the previous COMMANDs so overlap is not a problem.
//
enum COMMAND
{
    CMD_SHOW_LANA_DIAG = 17,
    CMD_SHOW_LANA_PATHS = 19,
    CMD_SET_LANA_NUMBER = 20,
    CMD_REWRITE_LANA_INFO = 21,
    CMD_INVALID = 0,
    CMD_SHOW_BINDINGS,
    CMD_SHOW_COMPONENTS,
    CMD_SHOW_STACK_TABLE,
    CMD_SHOW_LAN_ADAPTER_PNPIDS,
    CMD_ADD_COMPONENT,
    CMD_REMOVE_COMPONENT,
    CMD_UPDATE_COMPONENT,
    CMD_REMOVE_REFS,
    CMD_ENABLE_BINDING,
    CMD_DISABLE_BINDING,
    CMD_MOVE_BINDING,
    CMD_WRITE_BINDINGS,
    CMD_SET_WANORDER,
    CMD_FULL_DIAGNOSTIC,
    CMD_CLEANUP,
    CMD_ADD_REMOVE_STRESS,
    CMD_SHOW_LAN_CONNECTIONS,
    CMD_SHOW_LAN_DETAILS,
    CMD_LAN_CHANGE_STATE,
    CMD_SHOW_ALL_DEVICES,
};

//+---------------------------------------------------------------------------
// Parameters for SZ_CMD_SHOW_BINDINGS
//
enum SHOW_BINDINGS_PARAM
{
    SHOW_INVALID = 0,
    SHOW_BELOW,
    SHOW_INVOLVING,
    SHOW_UPPER,
    SHOW_DISABLED,
};

enum COMPONENT_SPECIFIER_TYPE
{
    CST_INVALID = 0,
    CST_ALL,
    CST_BY_NAME,
};

struct COMPONENT_SPECIFIER
{
    COMPONENT_SPECIFIER_TYPE    Type;
    PCWSTR                      pszInfOrPnpId;
};


struct DIAG_OPTIONS
{
    CDiagContext*   pDiagCtx;

    COMMAND         Command;

    // Valid for CMD_ADD_COMPONENT
    GUID            ClassGuid;
    PCWSTR          pszInfId;

    // Valid for SZ_CMD_SHOW_BINDINGS
    //
    SHOW_BINDINGS_PARAM     ShowBindParam;
    COMPONENT_SPECIFIER     CompSpecifier;

    // Valid for SZ_CMD_ENABLE_BINDING and SZ_CMD_DISABLE_BINDING
    //
    PCWSTR          pszBindPath;

    // Valid for SZ_CMD_MOVE_BINDING
    //
    PCWSTR          pszOtherBindPath;
    BOOL            fMoveBefore;

    // Valid for SZ_CMD_SET_WANORDER
    //
    BOOL            fWanAdaptersFirst;

    // Valid for SZ_CMD_FULL_DIAGNOSTIC
    //
    BOOL            fLeakCheck;

    // Need this reserved in order to keep the lanacfg.exe tool working.
    // Otherwise the offsets for OldLanaNumber and NewLanaNumber will
    // be wrong since we published an earlier version of the tool compiled
    // with this BOOL in the structure definition.
    //
    BOOL            fReserved;

    // Valid for SZ_SET_LANA_NUMBER
    //
    BYTE            OldLanaNumber;
    BYTE            NewLanaNumber;

    // Used by CMD_SHOW_LAN_DETAILS
    PCWSTR          szLanConnection;

    // Used by CMD_LAN_CHANGE_STATE & CMD_SHOW_LAN_DETAILS
    BOOL            fConnect;
};

VOID
SzFromCharacteristics (
    DWORD dwChars,
    tstring *pstrChars) throw(std::bad_alloc);

PCWSTR
SzFromNetconStatus (
    NETCON_STATUS Status) throw();

PCWSTR
SzFromCmProb (
    ULONG ulProb) throw();

VOID
SzFromCmStatus (
    ULONG ulStatus, tstring *pstrStatus) throw (std::bad_alloc);

EXTERN_C
VOID
WINAPI
NetCfgDiagFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);

EXTERN_C
VOID
WINAPI
LanaCfgFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);

EXTERN_C
VOID
WINAPI
NetManDiagFromCommandArgs (
    IN DIAG_OPTIONS const * pOptions);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\dbgflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . H
//
//  Contents:   Debug Flag definitions for the Netcfg project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _DBGFLAGS_H_
#define _DBGFLAGS_H_

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//

//+---------------------------------------------------------------------------
//
// DBG (checked) or ENABLETRACE build
//
#if defined(DBG) || defined(ENABLETRACE)


// DebugFlagIds are the identifiers for debug flags, and are used in calls
// to FIsDebugFlagSet()
//
// Hungarian == dfid
//
enum DebugFlagId
{
    dfidBreakOnAlloc = 0,
    dfidBreakOnDoUnattend,
    dfidBreakOnError,
    dfidBreakOnHr,
    dfidBreakOnHrIteration,
    dfidBreakOnIteration,
    dfidBreakOnNetInstall,
    dfidBreakOnNotifySinkRelease,
    dfidBreakOnPrematureDllUnload,
    dfidBreakOnWizard,
    dfidBreakOnStartOfUpgrade,
    dfidBreakOnEndOfUpgrade,
    dfidCheckLegacyMenusAtRuntime,
    dfidCheckLegacyMenusOnStartup,
    dfidDisableShellThreading,
    dfidDisableTray,
    dfidDontCacheShellIcons,
    dfidExtremeTracing,
    dfidNetShellBreakOnInit,
    dfidNoErrorText,
    dfidShowIgnoredErrors,
    dfidShowProcessAndThreadIds,
    dfidSkipLanEnum,
    dfidTraceCallStackOnError,
    dfidTraceFileFunc,
    dfidTraceMultiLevel,
    dfidTraceSource,
    dfidTracingTimeStamps,
    dfidTrackObjectLeaks
};

// Just for kicks
//
typedef enum DebugFlagId    DEBUGFLAGID;

// Maximum sizes for the trace tag elements.
const int c_iMaxDebugFlagShortName      = 32;
const int c_iMaxDebugFlagDescription    = 128;

// For each element in the debug flag list
//
struct DebugFlagElement
{
    DEBUGFLAGID dfid;
    CHAR        szShortName[c_iMaxDebugFlagShortName+1];
    CHAR        szDescription[c_iMaxDebugFlagDescription+1];
    DWORD       dwValue;
};

typedef struct DebugFlagElement DEBUGFLAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern DEBUGFLAGELEMENT g_DebugFlags[];
extern const INT        g_nDebugFlagCount;

BOOL    FIsDebugFlagSet( DEBUGFLAGID    dfid );
DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid );

//+---------------------------------------------------------------------------
//
// !DBG (retail) and !ENABLETRACE build
//
#else

#define FIsDebugFlagSet(dfid)           0
#define DwReturnDebugFlagValue(dfid)    0

#endif //! DBG || ENABLETRACE

#endif  // _DBGFLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\dbgext\stlint2.h ===
typedef HRESULT CALLBACK FNDumpFnCallBack(LPVOID pParam, LPCVOID pvKey, LPCVOID pvRef, LPCVOID pvAddress);

template <class T>
class StlDbgBase : public T
{
public:
    static HRESULT HrInitialRead(ULONG64 lpAddress, StlDbgBase<T>** lpHeader);

    // Implement these in your derived classes:
    static HRESULT HrDumpAllFromUl64(ULONG64 lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);
};

//////////////////////////////////////////////////////////////////////////////
////                      STL MAP<key, ref>                                 //
//////////////////////////////////////////////////////////////////////////////
template <class T>
class StlDbgMap : public StlDbgBase<T>
{
private:
    typedef T::_Imp::_Node    _StlDbgNode;
    typedef T::_Imp::_Nodeptr _StlDbgNodePtr;

    static HRESULT HrDumpAll(LPVOID lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);
    static HRESULT HrDumpNode(LPVOID pvHead, LPVOID pvDbgHead, DWORD dwLevel, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);

public:
    static HRESULT HrDumpAllFromUl64(ULONG64 lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);
};

//////////////////////////////////////////////////////////////////////////////
////                      STL LIST<ref>                                     //
//////////////////////////////////////////////////////////////////////////////
template <class T>
class StlDbgList : public StlDbgBase<T>
{
private:
    typedef T::_Node    _StlDbgNode;
    typedef T::_Nodeptr _StlDbgNodePtr;

    static HRESULT HrDumpAll(LPVOID lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);
    static HRESULT HrDumpNode(LPVOID pvHead, LPVOID pvDbgHead, DWORD dwLevel, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);

public:
    static HRESULT HrDumpAllFromUl64(ULONG64 lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack);
};

template <class T>
HRESULT StlDbgMap<T>::HrDumpNode(LPVOID pvHead, LPVOID pvDbgHead, DWORD dwLevel, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack)
{
    _StlDbgNodePtr pHead    = reinterpret_cast<_StlDbgNodePtr>(pvHead);
    _StlDbgNodePtr pDbgHead = reinterpret_cast<_StlDbgNodePtr>(pvDbgHead);

    dprintfVerbose("Dumping node (level %d) from head: [0x%08x]\n", dwLevel, pvDbgHead);
        
    if (!pvDbgHead)
    {
        return S_FALSE;
    }

    if ( (!pHead->_Left) && (!pHead->_Right) ) // aparently with the STL version we are using, this identifies an end node.
    {
        return S_FALSE; 
    }


    HRESULT hr;
    hr = pFNDumpFnCallBack(lpParam, &(pHead->_Value.first), &(pHead->_Value.second), &(pDbgHead->_Value));
    
    dprintfVerbose("%d: left is : 0x%08x\n", dwLevel, pHead->_Left);
    dprintfVerbose("%d: right is: 0x%08x\n", dwLevel, pHead->_Right);
    if (0 != pHead->_Left) 
    {
        _StlDbgNodePtr pNodeLeft = reinterpret_cast<_StlDbgNodePtr>(new BYTE[sizeof(_StlDbgNode)]);
        if (pNodeLeft)
        {
            ZeroMemory(pNodeLeft, sizeof(_StlDbgNodePtr));
            
            dprintfVerbose("%d: Reading left child node ", dwLevel);
            hr = HrReadMemory(pHead->_Left, sizeof(_StlDbgNode), pNodeLeft);
            if (SUCCEEDED(hr))
            {
                hr = HrDumpNode(pNodeLeft, pHead->_Left, dwLevel+1, lpParam, pFNDumpFnCallBack);
            }
            delete [] reinterpret_cast<LPBYTE>(pNodeLeft);
        }
    }

    if (0 != pHead->_Right) 
    {
        _StlDbgNodePtr pNodeRight = reinterpret_cast<_StlDbgNodePtr>(new BYTE[sizeof(_StlDbgNode)]);
        if (pNodeRight)
        {
            ZeroMemory(pNodeRight, sizeof(_StlDbgNode));

            dprintfVerbose("%d: Reading right child node ", dwLevel);
            hr = HrReadMemory(pHead->_Right, sizeof(_StlDbgNode), pNodeRight);
            if (SUCCEEDED(hr))
            {
                hr = HrDumpNode(pNodeRight, pHead->_Right,  dwLevel+1, lpParam, pFNDumpFnCallBack);
            }
            delete [] reinterpret_cast<LPBYTE>(pNodeRight);
        }
    }
    
    return S_OK;
}

template <class T>
HRESULT StlDbgMap<T>::HrDumpAll(LPVOID lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack)
{
    return HrDumpAllFromUl64((ULONG64)(ULONG_PTR)(lpAddress), lpParam, pFNDumpFnCallBack);
}

template <class T>
HRESULT StlDbgList<T>::HrDumpAll(LPVOID lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack)
{
    return HrDumpAllFromUl64((ULONG64)(ULONG_PTR)(lpAddress), lpParam, pFNDumpFnCallBack);
}

template <class T>
HRESULT StlDbgMap<T>::HrDumpAllFromUl64(ULONG64 lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack)
{
    HRESULT hr = E_FAIL;

    C_ASSERT(sizeof(T) == sizeof(StlDbgMap<T>)); // If you have a compile error on this line it means you added non-static data to your class.
                                                 // This is not allowed as it will break the binary compatibility of the structure.

    StlDbgMap<T> *pStlDbgCore;

    hr = HrInitialRead(lpAddress, reinterpret_cast<StlDbgBase<T> **>(&pStlDbgCore));
    if (S_OK == hr) // don't care if 0 entries
    {
        _StlDbgNodePtr pStlDbgHeadNode = reinterpret_cast<_StlDbgNodePtr>(new BYTE[sizeof(_StlDbgNode)]);
        if (pStlDbgHeadNode)
        {
            ZeroMemory(pStlDbgHeadNode, sizeof(_StlDbgNode));

            dprintfVerbose("Reading map<>.[_Tr]._Head");
            hr = HrReadMemory(pStlDbgCore->_Tr._Head, sizeof(_StlDbgNode), pStlDbgHeadNode);
            if (SUCCEEDED(hr))
            {
                _StlDbgNodePtr pDbgMapRootNode = reinterpret_cast<_StlDbgNodePtr>(new BYTE[sizeof(_StlDbgNode)]);
                if (pDbgMapRootNode)
                {
                    ZeroMemory(pDbgMapRootNode, sizeof(_StlDbgNode));

                    dprintfVerbose("Reading map<>.[_Tr]._Head._Parent");
                    hr = HrReadMemory( pStlDbgHeadNode->_Parent, sizeof(_StlDbgNode), pDbgMapRootNode);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrDumpNode(pDbgMapRootNode, pStlDbgHeadNode->_Parent, 0, lpParam, pFNDumpFnCallBack);
                    }
                    delete [] reinterpret_cast<LPBYTE>(pDbgMapRootNode);
                }
            }
            delete [] reinterpret_cast<LPBYTE>(pStlDbgHeadNode);
            }
        delete reinterpret_cast<LPBYTE>(pStlDbgCore);
    }

    return hr;
}


template <class T>
HRESULT StlDbgList<T>::HrDumpAllFromUl64(ULONG64 lpAddress, LPVOID lpParam, FNDumpFnCallBack* pFNDumpFnCallBack)
{
    HRESULT hr = E_FAIL;

    C_ASSERT(sizeof(T) == sizeof(StlDbgList<T>)); // If you have a compile error on this line it means you added non-static data to your class.
                                                 // This is not allowed as it will break the binary compatibility of the structure.

    StlDbgList<T> *pStlDbgCore;

    hr = HrInitialRead(lpAddress, reinterpret_cast<StlDbgBase<T> **>(&pStlDbgCore));
    if (S_OK == hr) // don't care if 0 entries
    {
        _StlDbgNodePtr pStlDbgHeadNode = reinterpret_cast<_StlDbgNodePtr>(new BYTE[sizeof(_StlDbgNode)]);
        if (pStlDbgHeadNode)
        {
            ZeroMemory(pStlDbgHeadNode, sizeof(_StlDbgNode));

            dprintfVerbose("Reading list<>._Head");
            hr = HrReadMemory(pStlDbgCore->_Head, sizeof(_StlDbgNode), pStlDbgHeadNode);
            if (SUCCEEDED(hr))
            {
                _StlDbgNodePtr pStlDbgNodeNext = reinterpret_cast<_StlDbgNodePtr>(new BYTE[sizeof(_StlDbgNode)]);
                if (pStlDbgNodeNext)
                {
                    BOOL fDone = FALSE;
                    
                    dprintfVerbose("Reading list<>._Head->_Next");
                    hr = HrReadMemory(pStlDbgHeadNode->_Next, sizeof(_StlDbgNode), pStlDbgNodeNext);
                    LPVOID ulReadAddress = pStlDbgNodeNext->_Value;
                    while (SUCCEEDED(hr) && !fDone)
                    {
                        dprintfVerbose("dumping list entry at from 0x%08x\r\n", pStlDbgNodeNext->_Value);
                        hr = pFNDumpFnCallBack(lpParam, NULL, pStlDbgNodeNext->_Value, ulReadAddress);

                        if (SUCCEEDED(hr))
                        {
                            if (pStlDbgNodeNext->_Next == pStlDbgCore->_Head)
                            {
                                dprintfVerbose("end of list\n");
                                fDone = TRUE;
                            }
                            else
                            {
                                hr = HrReadMemory(pStlDbgNodeNext->_Next, sizeof(_StlDbgNode), pStlDbgNodeNext);
                                ulReadAddress = pStlDbgNodeNext->_Value;
                            }
                        }
                    }
                }
            }
            delete [] reinterpret_cast<LPBYTE>(pStlDbgHeadNode);
            }
        delete reinterpret_cast<LPBYTE>(pStlDbgCore);
    }

    return hr;
}

template <class T>
HRESULT StlDbgBase<T>::HrInitialRead(ULONG64 lpAddress, StlDbgBase<T>** lpHeader)
{
    HRESULT hr = E_FAIL;

    C_ASSERT(sizeof(T) == sizeof(StlDbgBase<T>));// If you have a compile error on this line it means you added non-static data to your class.
                                                 // This is not allowed as it will break the binary compatibility of the structure.

    StlDbgBase<T> *pStlDbgCore = reinterpret_cast<StlDbgBase<T> *>(new BYTE[sizeof(StlDbgBase<T>)]);
    if (pStlDbgCore)
    {
        ZeroMemory(pStlDbgCore, sizeof(StlDbgBase<T>));

        dprintfVerbose("Reading STL class starting at %08x", lpAddress);
        hr = HrReadMemoryFromUlong(lpAddress, sizeof(StlDbgBase<T>), pStlDbgCore);
        if (SUCCEEDED(hr))
        {
            dprintf("%d entries found:\n", pStlDbgCore->size());

            if (pStlDbgCore->size())
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }

        if (SUCCEEDED(hr))
        {
            *lpHeader = pStlDbgCore;
        }
        else
        {
            delete reinterpret_cast<LPBYTE>(pStlDbgCore);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\kkenet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K E N E T . H
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#pragma once

HRESULT HrGetNetCardAddr(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr);
HRESULT HrGetNetCardAddrOld(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ipafval.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I P A F V A L . H 
//
//  Contents:   Value/Type pairs of IP-specific AnswerFile strings
//
//  Notes:      
//
//  Author:     Ning Sun (nsun)   17 May 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "ncreg.h"
#include "afilestr.h"

typedef struct 
{
    PCWSTR pszValueName;
    DWORD  dwType;
} ValueTypePair;

//For unconfigurable parameters upgrading
extern const DECLSPEC_SELECTANY ValueTypePair rgVtpNetBt[] = 
{
    {c_szBcastNameQueryCount, REG_DWORD},       // in the inf
    {c_szBcastQueryTimeout, REG_DWORD},         // in the inf
    {c_szBroadcastAddress, REG_DWORD},
    {c_szCacheTimeout, REG_DWORD},              // in the inf
    {c_szEnableProxy, REG_BOOL},
    {c_szEnableProxyRegCheck, REG_BOOL},
    {c_szInitialRefreshTimeout, REG_DWORD},
    {c_szLmhostsTimeout, REG_DWORD},
    {c_szMaxDgramBuffering, REG_DWORD},
    {c_szNameServerPort, REG_DWORD},            // in the inf
    {c_szNameSrvQueryCount, REG_DWORD},         // in the inf
    {c_szNameSrvQueryTimeout, REG_DWORD},       // in the inf
    {c_szNodeType, REG_DWORD},
    {c_szRandomAdapter, REG_BOOL},
    {c_szRefreshOpCode, REG_DWORD},
    {c_szAfScopeid, REG_SZ},
    {c_szSessionKeepAlive, REG_DWORD},          // in the inf
    {c_szSingleResponse, REG_BOOL},
    {c_szSizeSmallMediumLarge, REG_DWORD},      // in the inf
    {c_szWinsDownTimeout, REG_DWORD}
};

extern const DECLSPEC_SELECTANY ValueTypePair rgVtpIp[] = 
{
    {c_szAfArpAlwaysSourceRoute, REG_BOOL},
    {c_szAfArpCacheLife, REG_DWORD},
    {c_szArpCacheMinReferencedLife, REG_DWORD},
    {c_szArpRetryCount, REG_DWORD},
    {c_szAfArpTRSingleRoute, REG_BOOL},
    {c_szAfArpUseEtherSNAP, REG_BOOL},
    {c_szAfDefaultTOS, REG_DWORD},
    {c_szEnableAddrMaskReply, REG_BOOL},
    {c_szEnableDeadGWDetect, REG_BOOL},
    {c_szEnablePMTUBHDetect, REG_BOOL},
    {c_szEnablePMTUDiscovery, REG_BOOL},
    {c_szAfForwardBroadcasts, REG_BOOL},            // in the inf
    {c_szForwardBufferMemory, REG_DWORD},
    {c_szIGMPLevel, REG_DWORD},
    {c_szKeepAliveInterval, REG_DWORD},
    {c_szKeepAliveTime, REG_DWORD},
    {c_szMaxForwardBufferMemory, REG_DWORD},
    {c_szMaxHashTableSize, REG_DWORD},
    {c_szMaxNumForwardPackets, REG_DWORD},
    {c_szMaxUserPort, REG_DWORD},
    {c_szNumForwardPackets, REG_DWORD},
    {c_szPersistentRoutes, REG_FILE},
    {c_szAfPPTPTcpMaxDataRetransmissions, REG_DWORD},
    {c_szSynAttackProtect, REG_BOOL},
    {c_szSyncDomainWithMembership, REG_DWORD},
    {c_szTcpMaxConnectRetransmissions, REG_DWORD},
    {c_szTcpMaxDataRetransmissions, REG_DWORD},
    {c_szTcpMaxDupAcks, REG_DWORD},
    {c_szTCPMaxHalfOpen, REG_DWORD},
    {c_szTCPMaxHalfOpenRetried, REG_DWORD},
    {c_szTCPMaxPortsExhausted, REG_DWORD},
    {c_szTcpNumConnections, REG_DWORD},
    {c_szTcpTimedWaitDelay, REG_DWORD},
    {c_szTcpUseRFC1122UrgentPointer, REG_BOOL}
};

extern const DECLSPEC_SELECTANY ValueTypePair rgVtpIpAdapter[] = 
{
    {c_szMTU, REG_DWORD},
    {c_szAfUseZeroBroadcast, REG_BOOL},
    {c_szMaxForwardPending, REG_DWORD},
    {c_szDontAddDefaultGateway, REG_BOOL},
    {c_szPPTPFiltering, REG_BOOL},
    {c_szAfBindToDhcpServer, REG_BOOL},

    //Bug286037 new unconfigurable param in Windows2000, but we want to support
    //the unattended install for this parameter
    {c_szDhcpClassId, REG_SZ}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\kklog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K L O G . H
//
//  Contents:   Error logging for NetCfg components
//
//  Notes:
//
//  Author:     kumarp    14 April 97 (09:22:00 pm)
//
//  Notes:
//----------------------------------------------------------------------------


enum ENetCfgComponentType;

// ----------------------------------------------------------------------
// Class CLog
//
// Inheritance:
//   none
//
// Purpose:
//   Provides a way to log errors/warnings to
//     - NT EventLog
//     - NT SetupLog (setuperr.log / setupact.log)
//
//   This class hides much of complexity of the EventLog API. In addition
//   the user of this class does not have to first check whether a EventSource
//   has been created in the registry. This class will create one if not found.
//   Also, it is not necessary to call (De)RegisterEventSource for each report.
//
//   Messages are logged to SetupLog only during system install/upgrade
//   Message are always logged to the EventLog
//
//   This class provides function interface that is closer to EventLog API
//   than to the SetupLog API. The EventLog parameter values are mapped to
//   corresponding SetupLog parameters using some helper functions.
//   See nclog.cpp for details.
//
//   The members of this class do not return an error, because this itself is the
//   error reporting mechanism. However, the class has several Trace* functions.
//
// Hungarian: cl
// ----------------------------------------------------------------------

class CLog
{
public:
    CLog(ENetCfgComponentType nccType);
    ~CLog();

    void Initialize(IN ENetCfgComponentType nccType);
    void SetCategory(IN ENetCfgComponentType nccType) { m_nccType = nccType; }

    //Event Reporting functions
    void ReportEvent(IN WORD wType, IN DWORD dwEventID,
                     IN WORD wNumStrings=0, IN PCWSTR* ppszStrings=NULL,
                     IN DWORD dwBinaryDataNumBytes=0,
                     IN PVOID pvBinaryData=NULL) const;

    void ReportEvent(IN WORD wType, IN DWORD dwEventID,
                     IN WORD wNumStrings, ...) const;

    void ReportEvent(IN WORD wType, IN DWORD dwEventID,
                     IN WORD wNumStrings, va_list arglist) const;

    void ReportError(DWORD dwEventID);
    void ReportWarning(DWORD dwEventID);

private:
    static BOOL          m_fNetSetupMode; // TRUE only during NT install/upgrade
                                          // this must be set by some external logic
    static PCWSTR       m_pszEventSource;// EventLog source name
    BOOL                 m_fInitialized;  // TRUE only if correctly initialized
    ENetCfgComponentType m_nccType;       // Component category
};

inline void CLog::ReportError(DWORD dwEventID)
{
    ReportEvent(EVENTLOG_ERROR_TYPE, dwEventID);
}

inline void CLog::ReportWarning(DWORD dwEventID)
{
    ReportEvent(EVENTLOG_WARNING_TYPE, dwEventID);
}

// ----------------------------------------------------------------------
// The wType parameter of ReportEvent can take any on of the following values
//
//   - EVENTLOG_SUCCESS
//   - EVENTLOG_ERROR_TYPE
//   - EVENTLOG_WARNING_TYPE
//   - EVENTLOG_INFORMATION_TYPE
//   - EVENTLOG_AUDIT_SUCCESS
//   - EVENTLOG_AUDIT_FAILURE

// ----------------------------------------------------------------------
// Components categories. This decides which event-message-file to use
// ----------------------------------------------------------------------
enum ENetCfgComponentType
{
    nccUnknown = 0,
    nccError,
    nccNetcfgBase,
    nccNWClientCfg,
    nccRasCli,
    nccRasSrv,
    nccRasRtr,
    nccRasNdisWan,
    nccRasPptp,
    nccNCPA,
    nccCompInst,
    nccMSCliCfg,
    nccSrvrCfg,
    nccNetUpgrade,
    nccNetSetup,
    nccDAFile,
    nccTcpip,
    nccAtmArps,
    nccAtmUni,
    nccLast
};


// ----------------------------------------------------------------------
// These functions should normally be used by components that require
// event reporting for different sub-components using different categories.
//
// For those components that report events only for a single component,
// should probably create a global instance of CLog only once
// and report thru that instance.
// ----------------------------------------------------------------------

void NcReportEvent(IN ENetCfgComponentType nccType,
                   IN WORD  wType, IN DWORD dwEventID,
                   IN WORD  wNumStrings, IN PCWSTR* ppszStrings,
                   IN DWORD dwBinaryDataNumBytes,
                   IN PVOID pvBinaryData);

void NcReportEvent(IN ENetCfgComponentType nccType,
                   IN WORD  wType, IN DWORD dwEventID,
                   IN WORD  wNumStrings, ...);

// ----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\kkreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E G I S T R Y . H
//
//  Contents:   Windows NT Registry Access Class
//
//  Notes:
//
//  Author:     kumarp    14 April 97 (09:22:00 pm)
//
//  Notes:
//    kumarp   1/16/97   most of the code in this file was originally in
//                       net\ui\rhino\common\classes\common.h
//                       extracted only that portion related to CRegKey & related classes
//    kumarp   3/27/97   the original code used MFC. converted the entire code
//                       to make it use STL
//----------------------------------------------------------------------------

#pragma once
#include "kkstl.h"
#include "ncreg.h"
//----------------------------------------------------------------------------
//  Forward declarations
//----------------------------------------------------------------------------

class CORegKey ;
class CORegValueIter ;
class CORegKeyIter ;

typedef CORegKey *PCORegKey;
//
//  Maximum size of a Registry class name
//
#define CORegKEY_MAX_CLASS_NAME MAX_PATH


// ----------------------------------------------------------------------
// Class CORegKey
//
// Inheritance:
//   none
//
// Purpose:
//   Provides a wrapper for NT registry access functions
//
// Hungarian: rk
// ----------------------------------------------------------------------

class CORegKey
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;
    BOOL m_fInherit;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue (PCWSTR pchValueName, DWORD * pdwType,
                       DWORD * pcbSize, BYTE ** ppbData);

    //  Convert a TStringList to the REG_MULTI_SZ format
    static LONG FlattenValue (TStringList & strList, DWORD * pcbSize,
                              BYTE ** ppbData);

    //  Convert a TByteArray to a REG_BINARY block
    static LONG FlattenValue (TByteArray & abData, DWORD * pcbSize,
                              BYTE ** ppbData);

public:
    //
    //  Key information return structure
    //
    typedef struct
    {
        WCHAR chBuff [CORegKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CORegKEY_KEY_INFO ;

    //
    //  Standard constructor for an existing key
    //
    CORegKey (HKEY hKeyBase, PCWSTR pchSubKey = NULL,
              REGSAM regSam = KEY_READ_WRITE_DELETE, PCWSTR pchServerName = NULL);

    //
    //  Constructor creating a new key.
    //
    CORegKey (PCWSTR pchSubKey, HKEY hKeyBase, DWORD dwOptions = 0,
              REGSAM regSam = KEY_READ_WRITE_DELETE, LPSECURITY_ATTRIBUTES pSecAttr = NULL,
              PCWSTR pchServerName = NULL);

    ~ CORegKey () ;

    //
    //  Allow a CORegKey to be used anywhere an HKEY is required.
    //
    operator HKEY ()    { return m_hKey; }

    //
    //  Also provide a function to get HKEY
    //
    HKEY HKey()         { return m_hKey; }

    //
    //  Fill a key information structure
    //
    LONG QueryKeyInfo ( CORegKEY_KEY_INFO * pRegKeyInfo ) ;

    //
    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.
    //
    LONG QueryValue ( PCWSTR pchValueName, tstring & strResult ) ;
    LONG QueryValue ( PCWSTR pchValueName, TStringList & strList ) ;
    LONG QueryValue ( PCWSTR pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( PCWSTR pchValueName, TByteArray & abResult ) ;
    LONG QueryValue ( PCWSTR pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( PCWSTR pchValueName, tstring & strResult ) ;
    LONG SetValue ( PCWSTR pchValueName, tstring & strResult , BOOL fRegExpand) ;
    LONG SetValue ( PCWSTR pchValueName, TStringList & strList ) ;
    LONG SetValue ( PCWSTR pchValueName, DWORD & dwResult ) ;
    LONG SetValue ( PCWSTR pchValueName, TByteArray & abResult ) ;
    LONG SetValue ( PCWSTR pchValueName, void * pvResult, DWORD cbSize );

    LONG DeleteValue ( PCWSTR pchValueName );
};

// ----------------------------------------------------------------------
// Class CORegValueIter
//
// Inheritance:
//   none
//
// Purpose:
//  Iterate the values of a key, return the name and type of each
//
// Hungarian: rki
// ----------------------------------------------------------------------

class CORegValueIter
{
protected:
    CORegKey& m_rk_iter ;
    DWORD     m_dw_index ;
    PWSTR    m_p_buffer ;
    DWORD     m_cb_buffer ;

public:
    CORegValueIter ( CORegKey & regKey ) ;
    ~ CORegValueIter () ;

    //
    // Get the name (and optional last write time) of the next key.
    //
    LONG Next ( tstring * pstrName, DWORD * pdwType ) ;

    //
    // Reset the iterator
    //
    void Reset ()    { m_dw_index = 0 ; }
};

// ----------------------------------------------------------------------
// Class CORegKeyIter
//
// Inheritance:
//   none
//
// Purpose:
//  Iterate the sub-key names of a key.
//
// Hungarian: rki
// ----------------------------------------------------------------------

class CORegKeyIter
{
protected:
    CORegKey & m_rk_iter ;
    DWORD m_dw_index ;
    PWSTR m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CORegKeyIter (CORegKey & regKey) ;
    ~CORegKeyIter () ;

    LONG Next ( tstring * pstrName );

    // Reset the iterator
    void Reset ()    { m_dw_index = 0 ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\afilestr.h ===
/* ----------------------------------------------------------------------

Copyright (c) 1996-1997 Microsoft Corporation


Module Name:

    afilestr.h

Abstract:

    Strings for accessing the AnswerFile

Author:

    Kumar Pandit (kumarp)

Revision History:
    Last modified: Time-stamp: <kumarp    04-February-99 (06:12:41 pm)>

    17-Mar-1997 : Kumar Pandit (kumarp)  : Created

 ---------------------------------------------------------------------- */
#pragma once
#ifndef _AFILESTR_H_
#define _AFILESTR_H_

// ----------------------------------------------------------------------
// General

extern const WCHAR c_szAfNone[];
extern const WCHAR c_szAfUnknown[];
extern const WCHAR c_szAfListDelimiter[];

extern const WCHAR c_szAfDisplay[];
extern const WCHAR c_szAfAllowChanges[];
extern const WCHAR c_szAfOnlyOnError[];

extern const WCHAR c_szAfParams[];

extern const WCHAR c_szAfSectionIdentification[];
extern const WCHAR c_szAfSectionNetAdapters[];
extern const WCHAR c_szAfSectionNetProtocols[];
extern const WCHAR c_szAfSectionNetServices[];
extern const WCHAR c_szAfSectionNetClients[];
extern const WCHAR c_szAfSectionNetBindings[];

extern const WCHAR c_szAfSectionWinsock[];
extern const WCHAR c_szAfKeyWinsockOrder[];

extern const WCHAR c_szAfAdapterSections[];
extern const WCHAR c_szAfSpecificTo[];
extern const WCHAR c_szAfCleanup[];

extern const WCHAR c_szAfInfid[];
extern const WCHAR c_szAfInfidReal[];
extern const WCHAR c_szAfInstance[];

extern const WCHAR c_szAfInstallDefaultComponents[];

// ----------------------------------------------------------------------
// ZAW related
//
extern const WCHAR c_szAfNetComponentsToRemove[];

// ----------------------------------------------------------------------
// Network upgrade related
//
extern const WCHAR c_szAfSectionNetworking[];
extern const WCHAR c_szAfUpgradeFromProduct[];
extern const WCHAR c_szAfBuildNumber[];

extern const WCHAR c_szAfProcessPageSections[];

extern const WCHAR c_szAfNtServer[];
extern const WCHAR c_szAfNtSbServer[];
extern const WCHAR c_szAfNtWorkstation[];
extern const WCHAR c_szAfWin95[];
extern const WCHAR c_szAfDisableServices[];

extern const WCHAR c_szAfSectionToRun[];

extern const WCHAR c_szRegKeyAnswerFileMap[];

extern const WCHAR c_szAfPreUpgradeRouter[];
extern const WCHAR c_szAfNwSapAgentParams[];
extern const WCHAR c_szAfIpRipParameters[];
extern const WCHAR c_szAfDhcpRelayAgentParameters[];
extern const WCHAR c_szAfRadiusParameters[];

extern const WCHAR c_szAfMiscUpgradeData[];
extern const WCHAR c_szAfSapAgentUpgrade[];

extern const WCHAR c_szAfServiceStartTypes[];
extern const WCHAR c_szAfTapiSrvRunInSeparateInstance[];

// ----------------------------------------------------------------------
// OEM upgrade related
//
extern const WCHAR c_szAfOemSection[];
extern const WCHAR c_szAfOemDir[];
extern const WCHAR c_szAfOemDllToLoad[];
extern const WCHAR c_szAfOemInf[];
extern const WCHAR c_szAfSkipInstall[];

// ----------------------------------------------------------------------
// Net card related

// ----------------------------------------------------------------------
// The definition of INTERFACE_TYPE has been picked up from ntioapi.h
// if we try to include ntioapi.h, it leads to inclusion of tons of other
// irrelevant files.

#ifndef _NTIOAPI_
typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;
#endif

// ----------------------------------------------------------------------

//Hardware Bus-Types

extern const WCHAR c_szAfInfIdWildCard[];

extern const WCHAR c_szAfNetCardAddr[];
extern const WCHAR c_szAfBusType[];

extern const WCHAR c_szAfBusInternal[];
extern const WCHAR c_szAfBusIsa[];
extern const WCHAR c_szAfBusEisa[];
extern const WCHAR c_szAfBusMicrochannel[];
extern const WCHAR c_szAfBusTurbochannel[];
extern const WCHAR c_szAfBusPci[];
extern const WCHAR c_szAfBusVme[];
extern const WCHAR c_szAfBusNu[];
extern const WCHAR c_szAfBusPcmcia[];
extern const WCHAR c_szAfBusC[];
extern const WCHAR c_szAfBusMpi[];
extern const WCHAR c_szAfBusMpsa[];
extern const WCHAR c_szAfBusProcessorinternal[];
extern const WCHAR c_szAfBusInternalpower[];
extern const WCHAR c_szAfBusPnpisa[];

//Net card parameters
extern const WCHAR c_szAfAdditionalParams[];
extern const WCHAR c_szAfPseudoAdapter[];
extern const WCHAR c_szAfDetect[];
extern const WCHAR c_szAfIoAddr[];
extern const WCHAR c_szAfIrq[];
extern const WCHAR c_szAfDma[];
extern const WCHAR c_szAfMem[];
extern const WCHAR c_szAfTransceiverType[];
extern const WCHAR c_szAfSlotNumber[];
extern const WCHAR c_szAfConnectionName[];

//Tr