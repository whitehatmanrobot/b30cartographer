     //  If the file is mapped then flush the data so we can simply
                //  trust the Mcb.  There is a performance cost here but otherwise
                //  we would be returning the entire file as allocated.
                //

                if (FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE ) &&
                    FlagOn( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN ) &&
                    (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

                    LONGLONG CheckClusterCount;
                    LONGLONG RemainingCheckClusterCount = ThisClusterCount;
                    LONGLONG FlushOffset;
                    VCN CheckVcn = CurrentVcn;
                    BOOLEAN ReloadAllocation = FALSE;

                    PRESERVED_BITMAP_RANGE BitMap = Scb->ScbType.Data.ReservedBitMap;

                    ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA );

                    while (TRUE) {

                        //
                        //  Check to see if this range is allocated.
                        //

                        Allocated = NtfsIsRangeAllocated( Scb,
                                                          CheckVcn,
                                                          CheckVcn + RemainingCheckClusterCount,
                                                          TRUE,
                                                          &CheckClusterCount );

                        if (!Allocated) {

                            if (Scb->FileObject == NULL) {
                                NtfsCreateInternalAttributeStream( IrpContext, Scb, FALSE, NULL );
                            }

                            NtfsReleaseScb( IrpContext, Scb );
                            AcquiredScb = FALSE;

                            FlushOffset = LlBytesFromClusters( Vcb, CheckVcn );
                            CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                                          (PLARGE_INTEGER) &FlushOffset,
                                          (ULONG) LlBytesFromClusters( Vcb, CheckClusterCount ),
                                          &Irp->IoStatus );

                            NtfsAcquireExclusiveScb( IrpContext, Scb );
                            AcquiredScb = TRUE;

                            //
                            //  On error get out.
                            //

                            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                                &Irp->IoStatus.Status,
                                                                TRUE,
                                                                STATUS_UNEXPECTED_IO_ERROR );

                            ReloadAllocation = TRUE;
                        }

                        if (RemainingCheckClusterCount <= CheckClusterCount) {

                            break;
                        }

                        RemainingCheckClusterCount -= CheckClusterCount;
                        CheckVcn += CheckClusterCount;
                    }

                    //
                    //  Reload two gigabytes of allocation information at our Current Vcn.
                    //

                    if (ReloadAllocation) {

                        NtfsPreloadAllocation( IrpContext,
                                               Scb,
                                               CurrentVcn,
                                               CurrentVcn + ThisClusterCount );
                    }
                }

                //
                //  Loop while we have more clusters to look for.  We will load
                //  two gigabytes of allocation at a time into the Mcb.
                //

                UserMappedView = !(MmCanFileBeTruncated( &(Scb->NonpagedScb->SegmentObject), NULL ));

                do {

                    LONGLONG CurrentClusterCount;

                    //
                    //  Check to see if this range is allocated.
                    //

                    Allocated = NtfsIsRangeAllocated( Scb,
                                                      CurrentVcn,
                                                      CurrentVcn + ThisClusterCount,
                                                      TRUE,
                                                      &CurrentClusterCount );

                    //
                    //  If we have an unallocated range then we need to trim it by any
                    //  sparse units which have reservation. This is possible if it we haven't flushed because
                    //  its never been mapped or its still being user mapped so our flush is unreliable.
                    //  If the first unit has reservation then change the state of the range to 'Allocated'.
                    //

                    if ((UserMappedView || !FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) &&
                        !Allocated &&
                        NtfsCheckForReservedClusters( Scb, CurrentVcn, &CurrentClusterCount ) &&
                        (CurrentClusterCount < Vcb->SparseFileClusters)) {

                        Allocated = TRUE;
                        CurrentClusterCount = Vcb->SparseFileClusters;
                    }

                    //
                    //  If allocated check and see whether to extend a previous
                    //  run or start a new run.
                    //

                    if (Allocated) {

                        //
                        //  Extend the previous run if contiguous.
                        //

                        AccessingUserBuffer = TRUE;
                        if (NextVcn == CurrentVcn) {

                            CurrentBuffer->Length.QuadPart += LlBytesFromClusters( Vcb, CurrentClusterCount );

                        //
                        //  Otherwise use the next buffer location.
                        //

                        } else {

                            //
                            //  Check that there is space.
                            //

                            if (RemainingBytes < sizeof( FILE_ALLOCATED_RANGE_BUFFER )) {

                                //
                                //  We may already have some entries in the buffer.  Return
                                //  a different code if we were able to store at least one
                                //  entry in the output buffer.
                                //

                                if (CurrentBuffer + 1 == OutputBuffer) {

                                    Status = STATUS_BUFFER_TOO_SMALL;

                                } else {

                                    Status = STATUS_BUFFER_OVERFLOW;
                                }

                                RemainingClusters = 0;
                                break;
                            }

                            RemainingBytes -= sizeof( FILE_ALLOCATED_RANGE_BUFFER );

                            //
                            //  Move to the next position in the buffer and
                            //  fill in the current position.
                            //

                            CurrentBuffer += 1;

                            CurrentBuffer->FileOffset.QuadPart = LlBytesFromClusters( Vcb, CurrentVcn );
                            CurrentBuffer->Length.QuadPart = LlBytesFromClusters( Vcb, CurrentClusterCount );
                        }

                        AccessingUserBuffer = FALSE;

                        CurrentVcn += CurrentClusterCount;
                        NextVcn = CurrentVcn;

                    //
                    //  Otherwise move forward to the next range.
                    //

                    } else {

                        CurrentVcn += CurrentClusterCount;
                    }

                    //
                    //  Break out of the loop if we have processed all of the user's
                    //  clusters.
                    //
                    //
                    //  Grab the FsRtl header lock to check if we are beyond
                    //  file size.  If so then trim the last entry in the
                    //  output buffer to file size if necessary and break out.
                    //

                    NtfsAcquireFsrtlHeader( Scb );

                    if (((LONGLONG) LlBytesFromClusters( Vcb, CurrentVcn )) >= Scb->Header.FileSize.QuadPart) {

                        NtfsReleaseFsrtlHeader( Scb );
                        RemainingClusters = 0;
                        break;
                    }

                    NtfsReleaseFsrtlHeader( Scb );

                    ThisClusterCount -= CurrentClusterCount;

                } while (ThisClusterCount > 0);

            } while (RemainingClusters != 0);

            //
            //  If we have at least one entry then check and see if we
            //  need to bias either the starting value or final
            //  length based on the user's input values.
            //

            if (CurrentBuffer != OutputBuffer - 1) {

                AccessingUserBuffer = TRUE;
                if (OutputBuffer->FileOffset.QuadPart < StartingOffset) {

                    OutputBuffer->Length.QuadPart -= (StartingOffset - OutputBuffer->FileOffset.QuadPart);
                    OutputBuffer->FileOffset.QuadPart = StartingOffset;
                }

                if ((CurrentBuffer->FileOffset.QuadPart + CurrentBuffer->Length.QuadPart) >
                    (StartingOffset + Length)) {

                    CurrentBuffer->Length.QuadPart = StartingOffset + Length - CurrentBuffer->FileOffset.QuadPart;
                }
                AccessingUserBuffer = FALSE;
            }

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            //
            //  Convert any unexpected error to INVALID_USER_BUFFER if we
            //  are writing in the user's buffer.
            //

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

        //
        //  If we were successful then update the output information.
        //

        Irp->IoStatus.Information = PtrOffset( OutputBuffer, (CurrentBuffer + 1) );

    } finally {

        DebugUnwind( NtfsQueryAllocatedRanges );

        //
        //  Release resources.
        //

        NtfsReleasePagingIo( IrpContext, Scb->Fcb );

        if (AcquiredScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        //
        //  If nothing raised then complete the irp.
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsSetSparse (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to set the state of a stream to sparse.  We only allow
    this on user data streams.  There is no input or output buffer needed for this call.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN SetSparse = TRUE;

    PAGED_CODE();

    //
    //  Decode the file object, fail this request if not a user data stream.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    if (NtfsDecodeFileObject( IrpContext,
                              IoGetCurrentIrpStackLocation( Irp )->FileObject,
                              &Vcb,
                              &Fcb,
                              &Scb,
                              &Ccb,
                              FALSE ) != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  For now accept a zero length input buffer meaning set sparse
    //  remove this before shipping nt5
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength != 0 &&
        IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( FILE_SET_SPARSE_BUFFER )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Fsctrl is buffered so we don't need to probe etc. the input
    //

    if ((Irp->RequestorMode != KernelMode) && (IrpSp->Parameters.FileSystemControl.InputBufferLength != 0) ) {
        SetSparse = ((PFILE_SET_SPARSE_BUFFER)Irp->AssociatedIrp.SystemBuffer)->SetSparse;
    }

    //
    //  For this release we don't support unsparsifying files
    //

    if (SetSparse == FALSE) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_NOT_IMPLEMENTED );
        return STATUS_NOT_IMPLEMENTED;

    }

    //
    //  Only upgraded volumes can have sparse files.
    //

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_SPARSE_FILE_VERSION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }


    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Acquire the paging Io resource.  User data streams should always have
    //  a paging io resource.
    //

    ASSERT( Scb->Header.PagingIoResource != NULL );
    NtfsAcquireExclusivePagingIo( IrpContext, Fcb );

    //
    //  Acquire the main resource as well.
    //

    NtfsAcquireExclusiveScb( IrpContext, Scb );

    //
    //  Check that the volume is still mounted.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Make sure the caller has the appropriate access to this stream.
    //

    if (!(FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )) &&
        !IrpSp->FileObject->WriteAccess) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Change the sparse state of the file.
    //

    NtfsSetSparseStream( IrpContext, NULL, Scb );

    //
    //  There is no data returned in an output buffer for this.
    //

    Irp->IoStatus.Information = 0;

    //
    //  Go ahead and complete the request.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine.
//

NTSTATUS
NtfsZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to zero a range of a file.  We will also deallocate any convenient
    allocation on a sparse file.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_ZERO_DATA_INFORMATION ZeroRange;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Make sure the input buffer is large enough for the ZeroRange request.
    //

    if (IoGetCurrentIrpStackLocation( Irp )->Parameters.FileSystemControl.InputBufferLength < sizeof( FILE_ZERO_DATA_INFORMATION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Verify the ZeroRange request is properly formed.
    //

    ZeroRange = (PFILE_ZERO_DATA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    if ((ZeroRange->FileOffset.QuadPart < 0) ||
        (ZeroRange->BeyondFinalZero.QuadPart < 0) ||
        (ZeroRange->FileOffset.QuadPart > ZeroRange->BeyondFinalZero.QuadPart)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Decode the file object, fail this request if not a user data stream.
    //

    if (NtfsDecodeFileObject( IrpContext,
                              IoGetCurrentIrpStackLocation( Irp )->FileObject,
                              &Vcb,
                              &Fcb,
                              &Scb,
                              &Ccb,
                              TRUE ) != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Zero this range of the stream.
    //

    Status = NtfsZeroRangeInStream( IrpContext,
                                    IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                    Scb,
                                    &ZeroRange->FileOffset.QuadPart,
                                    ZeroRange->BeyondFinalZero.QuadPart );

    if (Status != STATUS_PENDING) {

        //
        //  There is no data returned in an output buffer for this.
        //

        Irp->IoStatus.Information = 0;

        //
        //  Go ahead and complete the request.  Raise any error
        //  status to make sure to unwind any Usn reasons.
        //

        if (NT_SUCCESS( Status )) {

            NtfsCompleteRequest( IrpContext, Irp, Status );

        } else {

            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsEncryptionFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to pass the request through to the installed encryption
    driver if present.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    TYPE_OF_OPEN TypeOfOpen;

    PVOID InputBuffer;
    ULONG InputBufferLength = 0;
    PVOID OutputBuffer;
    ULONG OutputBufferLength = 0;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    BOOLEAN ReleasePagingIo = FALSE;
    BOOLEAN ReleaseScb = FALSE;
    BOOLEAN ReleaseVcb = FALSE;

    PAGED_CODE();

    //
    //  This call should always be synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Decode the file object, fail this request if not a user data stream or directory.
    //  We check for dismount further below, so send FALSE to not raise here.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       FALSE );

    //
    //  This is only legal for files and directories, and not for anything
    //  that's compressed.
    //

   if (((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen)) ||

       FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED )) {

       NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
       return STATUS_INVALID_PARAMETER;
    }

    //
    //  This is also only supported on upgraded volumes.
    //

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_ENCRYPTION_VERSION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    OutputBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    InputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Probe the user's buffers if necessary.
    //

    if (Irp->RequestorMode != KernelMode) {

        try {

            ProbeForRead( InputBuffer,
                          InputBufferLength,
                          sizeof(UCHAR) );

            ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(UCHAR) );

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }
    }

    //
    //  Use a try-finally to free the resource.
    //

    try {

        //
        //  Acquire both resources if present on the file.
        //

        if (Fcb->PagingIoResource != NULL) {
            NtfsAcquirePagingResourceExclusive( IrpContext, Fcb, TRUE );
            ReleasePagingIo = TRUE;
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        ReleaseScb = TRUE;

        //
        //  Check that the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Call the EFS routine if specified.
        //

        if (NtfsData.EncryptionCallBackTable.FileSystemControl_2 != NULL) {

            ULONG EncryptionFlag = 0;

            if (IsEncrypted( &Fcb->Info )) {

                SetFlag( EncryptionFlag, FILE_ENCRYPTED );

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                    SetFlag( EncryptionFlag, STREAM_ENCRYPTED );
                }
            }

            Status = NtfsData.EncryptionCallBackTable.FileSystemControl_2(
                                InputBuffer,
                                InputBufferLength,
                                OutputBuffer,
                                &OutputBufferLength,
                                EncryptionFlag,
                                Ccb->AccessFlags,
                                (NtfsIsVolumeReadOnly( Vcb )) ? READ_ONLY_VOLUME : 0,
                                IrpSp->Parameters.FileSystemControl.FsControlCode,
                                Fcb,
                                IrpContext,
                                (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb ),
                                Scb,
                                &Scb->EncryptionContext,
                                &Scb->EncryptionContextLength);

            Irp->IoStatus.Information = OutputBufferLength;

        //
        //  There is no encryption driver present.
        //

        } else {

            Status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Information = 0;
        }

        NtfsCleanupTransaction( IrpContext, Status, TRUE );

    } finally {

        DebugUnwind( NtfsEncryptionPassThrough );

        //
        //  Acquire both resources if present on the file.
        //

        if (ReleasePagingIo) {
            NtfsReleasePagingResource( IrpContext, Fcb );
        }

        if (ReleaseScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        if (ReleaseVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  Go ahead and complete the request.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local support routine
//

VOID
NtfsEncryptStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN PATTRIBUTE_ENUMERATION_CONTEXT AttrContext
    )

/*++

Routine Description:

    This routine is called to mark a user data stream as encrypted.  It sets
    the encryption bit in the filerecord (handling logging, etc.) and in the
    Scb if one is provided..

Arguments:

    Fcb - The Fcb containing the stream to mark as encrypted.

    Scb - The Scb (if one exists) to mark as ancrypted.

    AttrContext - The attribute context that indicates where the stream is
                  within the file record.

Return Value:

    None

--*/

{
    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;

    NtfsPinMappedAttribute( IrpContext, Fcb->Vcb, AttrContext );
    Attribute = NtfsFoundAttribute( AttrContext );

    //
    //  We only need enough of the attribute to modify the bit.
    //

    RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

    SetFlag( NewAttribute.Flags, ATTRIBUTE_FLAG_ENCRYPTED );

    //
    //  Now, log the changed attribute.
    //

    (VOID)NtfsWriteLog( IrpContext,
                        Fcb->Vcb->MftScb,
                        NtfsFoundBcb( AttrContext ),
                        UpdateResidentValue,
                        &NewAttribute,
                        SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                        UpdateResidentValue,
                        Attribute,
                        SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                        NtfsMftOffset( AttrContext ),
                        PtrOffset(NtfsContainingFileRecord( AttrContext ), Attribute),
                        0,
                        Fcb->Vcb->BytesPerFileRecordSegment );

    //
    //  Change the attribute by calling the same routine called at restart.
    //

    NtfsRestartChangeValue( IrpContext,
                            NtfsContainingFileRecord( AttrContext ),
                            PtrOffset( NtfsContainingFileRecord( AttrContext ), Attribute ),
                            0,
                            &NewAttribute,
                            SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                            FALSE );

    if (ARGUMENT_PRESENT( Scb )) {

        SetFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );
    }

    //
    //  Now update the Fcb if this is the first of the streams.
    //

    if (!IsEncrypted( &Fcb->Info )) {

        //
        //  Set the flag in the Fcb info field and let ourselves know to
        //  update the standard information.
        //

        ASSERTMSG( "conflict with flush",
                   NtfsIsSharedFcb( Fcb ) ||
                   (Fcb->PagingIoResource != NULL &&
                    NtfsIsSharedFcbPagingIo( Fcb )) );

        SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

        //
        //  If this is a directory, remember to set the appropriate bit in its Fcb.
        //

        if (IsDirectory( &Fcb->Info )) {

            SetFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
        }
    }
}


//
//  Local support routine
//

NTSTATUS
NtfsSetEncryption (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to initiate a set encryption operation.  The input buffer specifies
    whether we are accessing a file or a directory.

Arguments:

    Irp - Request being serviced

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PLCB Lcb;

    PSCB ParentScb = NULL;

    TYPE_OF_OPEN TypeOfOpen;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    BOOLEAN ReleasePagingIo = FALSE;
    BOOLEAN ReleaseVcb = FALSE;

    ULONG EncryptionFlag = 0;
    ULONG EncryptionOperation;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;

    ULONG FilterMatch;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;
    BOOLEAN FoundAttribute;

    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;

    BOOLEAN UpdateCcbFlags = FALSE;
    BOOLEAN ClearFcbUpdateFlag = FALSE;
    BOOLEAN ClearFcbInfoFlags = FALSE;
    BOOLEAN RestoreEncryptionFlag = FALSE;
    BOOLEAN DirectoryFileEncrypted = FALSE;

    PENCRYPTION_BUFFER EncryptionBuffer;
    PDECRYPTION_STATUS_BUFFER DecryptionStatusBuffer;

    PAGED_CODE();

    //
    //  This call should always be synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  Decode the file object, fail this request if not a user data stream or directory.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    //
    //  This is only legal for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Get the input and output buffer lengths and pointers.  Remember that the output
    //  buffer is optional.
    //

    EncryptionBuffer = (PENCRYPTION_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    DecryptionStatusBuffer = (PDECRYPTION_STATUS_BUFFER)NtfsMapUserBuffer( Irp, NormalPagePriority );
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Check for a minimum length on the input and ouput buffers.  The output buffer
    //  only needs to be a certain length if one was specified.
    //

    if ((InputBufferLength < sizeof(ENCRYPTION_BUFFER)) ||

        ((DecryptionStatusBuffer != NULL) && (OutputBufferLength < sizeof(DECRYPTION_STATUS_BUFFER)))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsSetEncryption -> %08lx\n", STATUS_BUFFER_TOO_SMALL) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Probe the user's buffers.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead( EncryptionBuffer, InputBufferLength, sizeof( UCHAR ) );
            if (DecryptionStatusBuffer != NULL) ProbeForWrite( DecryptionStatusBuffer, OutputBufferLength, sizeof( UCHAR ) );
        }

        EncryptionOperation = EncryptionBuffer->EncryptionOperation;
        Irp->IoStatus.Information = 0;

        if (DecryptionStatusBuffer != NULL) {

            DecryptionStatusBuffer->NoEncryptedStreams = FALSE;
        }

    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

        DebugTrace( -1, Dbg, ("NtfsSetEncryption -> %08lx\n", FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER) );
        NtfsRaiseStatus( IrpContext,
                         STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL );
    }

    //
    //  Verify that the user didn't specify any illegal flags.
    //

    if (EncryptionOperation > MAXIMUM_ENCRYPTION_VALUE) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  It's okay to mark the file encryption bit if this stream is compressed,
    //  but we do want to prevent setting the stream encrypted bit for a
    //  compressed stream.  In some future release when we have a chance to
    //  test compression & encryption together (perhaps with some third-party
    //  encryption engine) we can relax/remove this restriction.
    //

    if ((EncryptionOperation == STREAM_SET_ENCRYPTION) &&
        FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  This is also only supported on upgraded volumes.
    //

    if (!NtfsVolumeVersionCheck( Vcb, NTFS_ENCRYPTION_VERSION )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Use a try-finally to free the resource.
    //

    try {

        //
        //  Acquire the Vcb shared in case we need to update the parent directory entry.
        //

        ReleaseVcb = NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

        //
        //  Acquire both resources if present on the file.
        //

        if (Fcb->PagingIoResource != NULL) {
            NtfsAcquirePagingResourceExclusive( IrpContext, Fcb, TRUE );
            ReleasePagingIo = TRUE;
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );

        //
        //  Check that the volume is still mounted.
        //

        if ( !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We can't go on if there isn't an encryption driver loaded.  We did our best
        //  to get it loaded above.  If that didn't work, we need to leave now.
        //

        if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

            Status = STATUS_INVALID_DEVICE_REQUEST;
            leave;
        }

        //
        //  Update the Scb from disk if necessary.
        //

        if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

            if (Scb->ScbType.Index.BytesPerIndexBuffer == 0) {

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                if (!NtfsLookupAttributeByName( IrpContext,
                                                Scb->Fcb,
                                                &Scb->Fcb->FileReference,
                                                $INDEX_ROOT,
                                                &Scb->AttributeName,
                                                NULL,
                                                FALSE,
                                                &AttrContext )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                NtfsUpdateIndexScbFromAttribute( IrpContext,
                                                 Scb,
                                                 NtfsFoundAttribute( &AttrContext ),
                                                 FALSE );

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            }

        } else if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
        }

        //
        //  Remember the starting encryption state for this operation.
        //

        if (IsEncrypted( &Fcb->Info )) {

            SetFlag( EncryptionFlag, FILE_ENCRYPTED );

            if (FlagOn( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED )) {

                DirectoryFileEncrypted = TRUE;
            }

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                SetFlag( EncryptionFlag, STREAM_ENCRYPTED );
            }
        }

        RestoreEncryptionFlag = TRUE;

        //
        //  If the caller wants to clear the encryption bit on the file then there should
        //  be no encrypted streams on the file.
        //

        if ((EncryptionOperation == FILE_CLEAR_ENCRYPTION) && IsEncrypted( &Fcb->Info )) {

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        $DATA,
                                                        &AttrContext );

            while (FoundAttribute) {

                //
                //  We only want to look at this attribute if it is resident or the
                //  first attribute header for a non-resident attribute.
                //

                Attribute = NtfsFoundAttribute( &AttrContext );

                if (NtfsIsAttributeResident( Attribute ) ||
                    (Attribute->Form.Nonresident.LowestVcn == 0)) {

                    if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                        break;
                    }
                }

                FoundAttribute = NtfsLookupNextAttributeByCode( IrpContext,
                                                                Fcb,
                                                                $DATA,
                                                                &AttrContext );
            }

            if (FoundAttribute) {

                Status = STATUS_INVALID_DEVICE_REQUEST;
                leave;
            }

            //
            //  If this is a directory then we need to check the index root as well.
            //

            if (IsDirectory( &Fcb->Info )) {

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $INDEX_ROOT,
                                                            &NtfsFileNameIndex,
                                                            NULL,
                                                            FALSE,
                                                            &AttrContext );

                //
                //  We should always find this attribute in this case.
                //

                if (!FoundAttribute) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                Attribute = NtfsFoundAttribute( &AttrContext );

                if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    leave;
                }
            }

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;
        }

        //
        //  It's a pretty rare case that we'll decide we don't need to update
        //  the duplicate info below, so let's go ahead and prepare now.  We
        //  can't wait until after the convert to nonresident, as that will
        //  acquire the quota resources before we've acquired the parent scb,
        //  resulting in a potential deadlock.
        //

        Lcb = Ccb->Lcb;

        NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );

        //
        //  Now let's go ahead and modify the bit on the file/stream.
        //

        if (EncryptionOperation == FILE_SET_ENCRYPTION) {

            if (!IsEncrypted( &Fcb->Info )) {

                //
                //  Set the flag in the Fcb info field and let ourselves know to
                //  update the standard information.
                //

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( Fcb ) ||
                           (Fcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( Fcb )) );

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
                UpdateCcbFlags = TRUE;
            }

        } else if (EncryptionOperation == FILE_CLEAR_ENCRYPTION) {

            if (IsEncrypted( &Fcb->Info )) {

                //
                //  Clear the flag in the Fcb info field and let ourselves know to
                //  update the standard information.  Also clear the directory
                //  encrypted bit, even though it may not even be set.
                //

                ASSERTMSG( "conflict with flush",
                           NtfsIsSharedFcb( Fcb ) ||
                           (Fcb->PagingIoResource != NULL &&
                            NtfsIsSharedFcbPagingIo( Fcb )) );

                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
                ClearFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
                UpdateCcbFlags = TRUE;
            }

        } else if (EncryptionOperation == STREAM_SET_ENCRYPTION) {

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  If we're being called to set the encyrption bit on a new named stream
                //  and we created the unnamed stream silently without calling out to the
                //  encryption engine, this is the best time to set the encryption bit on
                //  the unnamed stream and convert it to nonresident, too.  Some encryption
                //  engines may not want this behavior, so we check the ImplementationFlags.
                //

                if (!FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                    FlagOn( Fcb->FcbState, FCB_STATE_ENCRYPTION_PENDING) &&
                    FlagOn( NtfsData.EncryptionCallBackTable.ImplementationFlags, ENCRYPTION_ALL_STREAMS ) &&
                    NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                    if (NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $DATA,
                                                   &AttrContext )) {
                        //
                        //  If there is an the unnamed data attribute, it will be the
                        //  first data attribute we find.  There may be no unnamed data
                        //  attribute in the case where we've been asked to encrypt a
                        //  named data stream on a directory.
                        //

                        Attribute = NtfsFoundAttribute( &AttrContext );

                        if (Attribute->NameLength == 0) {

                            PSCB DefaultStreamScb = NULL;

                            ASSERT( NtfsIsAttributeResident( Attribute ) &&
                                    Attribute->Form.Resident.ValueLength == 0 );

                            NtfsConvertToNonresident( IrpContext,
                                                      Fcb,
                                                      Attribute,
                                                      TRUE,
                                                      &AttrContext );

                            while (TRUE) {

                                DefaultStreamScb = NtfsGetNextChildScb( Fcb, DefaultStreamScb );

                                //
                                //  If we've reached the end of the list of Scbs, or else
                                //  found the unnamed data stream's Scb, we're done.
                                //

                                if ((DefaultStreamScb == NULL) ||
                                    FlagOn( DefaultStreamScb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                                    break;
                                }
                            }

                            NtfsEncryptStream( IrpContext, Fcb, DefaultStreamScb, &AttrContext );
                        }
                    }

                    //
                    //  Get the AttrContext ready for reuse.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    NtfsInitializeAttributeContext( &AttrContext );
                }

                //
                //  If the stream is a data stream we can look up the attribute
                //  from the Scb.
                //

                if (TypeOfOpen == UserFileOpen) {

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );
                    //
                    //  Convert to non-resident if necessary.  It's entirely possible
                    //  that our caller will not have read or write access to this
                    //  file and won't have a key.  Therefore we don't want to create
                    //  a cache section for this stream during the convert, as we
                    //  may not have a key with which to do flushes later.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                        NtfsConvertToNonresident( IrpContext,
                                                  Fcb,
                                                  NtfsFoundAttribute( &AttrContext ),
                                                  TRUE,
                                                  &AttrContext );
                    }

                } else {

                    FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                                Fcb,
                                                                &Fcb->FileReference,
                                                                $INDEX_ROOT,
                                                                &NtfsFileNameIndex,
                                                                NULL,
                                                                FALSE,
                                                                &AttrContext );

                    //
                    //  We should always find this attribute in this case.
                    //

                    if (!FoundAttribute) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }
                }

                NtfsEncryptStream( IrpContext, Fcb, Scb, &AttrContext );

                UpdateCcbFlags = TRUE;
            }

        } else { // EncryptionOperation == STREAM_CLEAR_ENCRYPTION

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  If the stream is a data stream we can look up the attribute
                //  from the Scb.
                //

                if (TypeOfOpen == UserFileOpen) {

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );
                } else {

                    FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                                Fcb,
                                                                &Fcb->FileReference,
                                                                $INDEX_ROOT,
                                                                &NtfsFileNameIndex,
                                                                NULL,
                                                                FALSE,
                                                                &AttrContext );

                    //
                    //  We should always find this attribute in this case.
                    //

                    if (!FoundAttribute) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }
                }

                NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
                Attribute = NtfsFoundAttribute( &AttrContext );

                //
                //  We only need enough of the attribute to modify the bit.
                //

                RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

                ClearFlag( NewAttribute.Flags, ATTRIBUTE_FLAG_ENCRYPTED );

                //
                //  Now, log the changed attribute.
                //

                (VOID)NtfsWriteLog( IrpContext,
                                    Vcb->MftScb,
                                    NtfsFoundBcb( &AttrContext ),
                                    UpdateResidentValue,
                                    &NewAttribute,
                                    SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                    UpdateResidentValue,
                                    Attribute,
                                    SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                    NtfsMftOffset( &AttrContext ),
                                    PtrOffset(NtfsContainingFileRecord( &AttrContext ), Attribute),
                                    0,
                                    Vcb->BytesPerFileRecordSegment );


                //
                //  Change the attribute by calling the same routine called at restart.
                //

                NtfsRestartChangeValue( IrpContext,
                                        NtfsContainingFileRecord( &AttrContext ),
                                        PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute ),
                                        0,
                                        &NewAttribute,
                                        SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                        FALSE );

                ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );

                //
                //  Now check if this is the last stream on the file with the encryption
                //  bit set.
                //

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );

                FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $DATA,
                                                            &AttrContext );

                while (FoundAttribute) {

                    //
                    //  We only want to look at this attribute if it is resident or the
                    //  first attribute header for a non-resident attribute.
                    //

                    Attribute = NtfsFoundAttribute( &AttrContext );

                    if (NtfsIsAttributeResident( Attribute ) ||
                        (Attribute->Form.Nonresident.LowestVcn == 0)) {

                        if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                            break;
                        }
                    }

                    FoundAttribute = NtfsLookupNextAttributeByCode( IrpContext,
                                                                    Fcb,
                                                                    $DATA,
                                                                    &AttrContext );
                }

                //
                //  If this is a directory then we need to check the index root as well.
                //

                if (!FoundAttribute && IsDirectory( &Fcb->Info )) {

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    NtfsInitializeAttributeContext( &AttrContext );

                    FoundAttribute = NtfsLookupAttributeByName( IrpContext,
                                                                Fcb,
                                                                &Fcb->FileReference,
                                                                $INDEX_ROOT,
                                                                &NtfsFileNameIndex,
                                                                NULL,
                                                                FALSE,
                                                                &AttrContext );

                    //
                    //  We should always find this attribute in this case.
                    //

                    if (!FoundAttribute) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    Attribute = NtfsFoundAttribute( &AttrContext );

                    if (!FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                        FoundAttribute = FALSE;
                    }
                }

                //
                //  If our caller is interested, let it know if we have decrypted the
                //  last encrypted stream.  Since this is the only place we touch this
                //  buffer, we'll just wrap a little try/except around it here.
                //

                if (DecryptionStatusBuffer != NULL) {

                    try {

                        DecryptionStatusBuffer->NoEncryptedStreams = TRUE;
                        Irp->IoStatus.Information = sizeof(DECRYPTION_STATUS_BUFFER);

                    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

                        DebugTrace( -1, Dbg, ("NtfsSetEncryption -> %08lx\n", FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER) );
                        NtfsRaiseStatus( IrpContext,
                                         STATUS_INVALID_USER_BUFFER,
                                         NULL,
                                         NULL );
                    }
                }

                UpdateCcbFlags = TRUE;
            }
        }

        //
        //  Now let's update the on-disk structures.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb  );
            ClearFcbUpdateFlag = TRUE;

            NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );

            //
            //  Now perform the dir notify call if this is not an
            //  open by FileId.
            //

            if ((Vcb->NotifyCount != 0) &&
                (ParentScb != NULL) &&
                !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                        Fcb->InfoFlags | Lcb->InfoFlags );

                if (FilterMatch != 0) {

                    NtfsReportDirNotify( IrpContext,
                                         Fcb->Vcb,
                                         &Ccb->FullFileName,
                                         Ccb->LastFileNameOffset,
                                         NULL,
                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                           (Ccb->Lcb != NULL) &&
                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                          NULL),
                                         FilterMatch,
                                         FILE_ACTION_MODIFIED,
                                         ParentScb->Fcb );
                }
            }

            NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
            ClearFcbInfoFlags = TRUE;
        }

        //
        //  Call the EFS routine if specified.
        //

        if (NtfsData.EncryptionCallBackTable.FileSystemControl_1 != NULL) {

            Status = NtfsData.EncryptionCallBackTable.FileSystemControl_1(
                                EncryptionBuffer,
                                InputBufferLength,
                                NULL,
                                NULL,
                                EncryptionFlag,
                                Ccb->AccessFlags,
                                (NtfsIsVolumeReadOnly( Vcb )) ? READ_ONLY_VOLUME : 0,
                                IrpSp->Parameters.FileSystemControl.FsControlCode,
                                Fcb,
                                IrpContext,
                                (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb, VOLUME_DEVICE_OBJECT, Vcb ),
                                Scb,
                                &Scb->EncryptionContext,
                                &Scb->EncryptionContextLength);
        }

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_ENCRYPTION_CHANGE );

        NtfsCleanupTransaction( IrpContext, Status, TRUE );

        ASSERT( NT_SUCCESS( Status ));

        //
        //  Clear the flags in the Fcb if the update is complete.
        //

        if (ClearFcbUpdateFlag) {

            ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        if (ClearFcbInfoFlags) {

            Fcb->InfoFlags = 0;
        }

        if (UpdateCcbFlags) {

            SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
        }

        RestoreEncryptionFlag = FALSE;

    } finally {

        DebugUnwind( NtfsSetEncryption );

        //
        //  In the error path we need to restore the correct encryption bit in
        //  the Fcb and Scb.
        //

        if (RestoreEncryptionFlag) {

            DebugTrace( 0, Dbg, ("Error in NtfsSetEncryption, restoring encryption flags\n") );

            if (FlagOn( EncryptionFlag, FILE_ENCRYPTED )) {

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );

                if (DirectoryFileEncrypted) {

                    SetFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                }

            } else {

                ClearFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
            }

            if (FlagOn( EncryptionFlag, STREAM_ENCRYPTED )) {

                SetFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );

            } else {

                ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED );
            }
        }

        //
        //  Acquire both resources if present on the file.
        //

        if (ReleasePagingIo) {
            NtfsReleasePagingResource( IrpContext, Fcb );
        }

        if (ReleaseVcb) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }
    }

    //
    //  Go ahead and complete the request.
    //

    NtfsCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsReadRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs a 'raw' read of encrypted data.  By 'raw', we
    mean without attempting to unencrypt.  This is useful for backup
    operations, and also for data recovery in the event the key stream
    is somehow lost.  Since this fsctrl works with any access, we have
    to fail the request for unencrypted files.  This routine is
    responsible for either completing or enqueuing the input Irp.

    Notes: DataUnit is the size of each peice written out in the buffer
           ChunkUnit is the size of a compression chunk (not used yet)

           For Sparse files DataUnit == CompressionUnit

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    LONGLONG StartingVbo;
    LONGLONG RequestedOffset;
    LONGLONG RoundedFileSize;
    ULONG TotalByteCount;
    ULONG ByteCount;
    ULONG BytesRead;

    PIRP ReadIrp = NULL;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION ReadIrpSp;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG ReadLength;
    PREQUEST_RAW_ENCRYPTED_DATA RequestRawEncryptedData;
    PENCRYPTED_DATA_INFO EncryptedDataInfo;

    USHORT BlockIndex;
    USHORT BlockCount = 0;

    PUCHAR RawDataDestination;

    NTFS_IO_CONTEXT LocalContext;

    BOOLEAN LockedReadIrpPages = FALSE;
    BOOLEAN SparseFile = FALSE;
    BOOLEAN RangeAllocated = TRUE;
    BOOLEAN AccessingUserBuffer = FALSE;
    ULONG OutputBufferOffset;
    ULONG BytesWithinValidDataLength = 0;
    ULONG BytesWithinFileSize = 0;
    ULONG i;
    LONG BytesPerSectorMask;

    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR TotalShift;
    UCHAR DataUnitShift;

    PAGED_CODE();

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    DebugTrace( +1, Dbg, ("NtfsReadRawEncrypted:\n") );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    //
    //  This operation only applies to files, not indexes,
    //  or volumes.
    //

    if (TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We can't allow reads of unencrypted data, as that would let any
    //  user read any file's contents..
    //

    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) ||

        //
        //  Even for an encrypted file, we should only allow this if the
        //  user is a backup operator or has read access.
        //

        !FlagOn( Ccb->AccessFlags, BACKUP_ACCESS | READ_DATA_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input and output buffer lengths and pointers.
    //  Initialize some variables.
    //

    RequestRawEncryptedData = (PREQUEST_RAW_ENCRYPTED_DATA)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    EncryptedDataInfo = (PENCRYPTED_DATA_INFO)NtfsMapUserBuffer( Irp, NormalPagePriority );
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Check for a minimum length on the input and ouput buffers.
    //

    if ((InputBufferLength < sizeof(REQUEST_RAW_ENCRYPTED_DATA)) ||
        (OutputBufferLength < sizeof(ENCRYPTED_DATA_INFO))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", STATUS_BUFFER_TOO_SMALL) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Probe the user's buffers.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead( RequestRawEncryptedData, InputBufferLength, sizeof( UCHAR ) );
            ProbeForWrite( EncryptedDataInfo, OutputBufferLength, sizeof( UCHAR ) );
        }

        RequestedOffset = RequestRawEncryptedData->FileOffset;

        ReadLength = RequestRawEncryptedData->Length;

        //
        //  Zero the buffer.
        //

        RtlZeroMemory( EncryptedDataInfo, OutputBufferLength );

    } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), TRUE, &Status ) ) {

        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER) );
        NtfsRaiseStatus( IrpContext,
                         STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL );
    }

    try {

        //
        //  Get paging & main exclusively to keep eof from changing
        //  beneath us, and so we can safely flush the file and query the mapping info below.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
        NtfsAcquireFcbWithPaging( IrpContext, Scb->Fcb, 0 );

        //
        //  Make sure we aren't starting past the end of the file, in which case
        //  we would have nothing to return.
        //

        if ((RequestedOffset >= Scb->Header.FileSize.QuadPart) || (RequestedOffset >= Scb->Header.AllocationSize.QuadPart)) {

            try_return( Status = STATUS_END_OF_FILE );
        }

        //
        //  Sanity check the read length.
        //

        if (0 == ReadLength) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        RoundedFileSize = (Scb->Header.FileSize.QuadPart + Vcb->BytesPerSector) & ~((LONGLONG)Vcb->BytesPerSector);
        if (RequestedOffset + ReadLength > RoundedFileSize) {
            ReadLength = (ULONG)(RoundedFileSize - RequestedOffset);
        }

        try {

            if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                //
                //  File is not compressed or sparse.
                //

                AccessingUserBuffer = TRUE;
                EncryptedDataInfo->CompressionFormat = COMPRESSION_FORMAT_NONE;
                AccessingUserBuffer = FALSE;

                //
                //  For a simple uncompressed, nonsparse file, we can start on any
                //  cluster boundary.  We like to start on a cluster boundary
                //  since the cluster size is always >= the size of a cipher block,
                //  and a recovery agent will always need to work with whole cipher
                //  blocks.  Notice that the StartingVbo is rounded _down_ to the
                //  previous cluster boundary, while TotalByteCount is rounded _up_ to
                //  the next larger cluster multiple.
                //

                StartingVbo = RequestedOffset & Vcb->InverseClusterMask;

                TotalByteCount = ClusterAlign( Vcb, ReadLength );

                //
                //  We will do the transfer in one block for this simple case.
                //

                BlockCount = 1;
                ByteCount = TotalByteCount;

                //
                //  For an uncompressed file, we'll pick a data unit size so
                //  that it's some convenient power of two.
                //

                for (DataUnitShift = 0, i = TotalByteCount - 1;
                     i > 0;
                     i = i / 2) {

                    DataUnitShift += 1;
                }

                AccessingUserBuffer = TRUE;

                EncryptedDataInfo->DataUnitShift = DataUnitShift;
                EncryptedDataInfo->ChunkShift = DataUnitShift;
                AccessingUserBuffer = FALSE;

            } else if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                //
                //  File is sparse and not compressed.
                //

                SparseFile = TRUE;
                ASSERT( Vcb->ClusterShift + Scb->CompressionUnitShift <= MAXUCHAR );
                TotalShift = (UCHAR)(Scb->CompressionUnitShift + Vcb->ClusterShift);

                AccessingUserBuffer = TRUE;
                EncryptedDataInfo->CompressionFormat = COMPRESSION_FORMAT_NONE;
                EncryptedDataInfo->ChunkShift = TotalShift;
                AccessingUserBuffer = FALSE;

                //
                //  For a sparse file, we can start on any compression unit
                //  boundary.  Notice that the StartingVbo is rounded _down_ to the
                //  previous compression unit boundary, while TotalByteCount is rounded
                //  _up_ to the next larger compression unit multiple.
                //

                StartingVbo = BlockAlignTruncate( RequestedOffset, (LONG)Scb->CompressionUnit );
                TotalByteCount = BlockAlign( ReadLength, (LONG)Scb->CompressionUnit );

                //
                //  BlockCount is the number of blocks needed to describe this range
                //  of the file.  It is simply the number of bytes we're reading on
                //  this request divided by the size of a compression unit.
                //  (Literally, we're shifting, but semantically, we're dividing).
                //

                BlockCount = (USHORT) (TotalByteCount >> TotalShift);

                //
                //  Since BlockCount is derived from a user-supplied value, we need
                //  to make sure we aren't about to divide by zero.
                //

                if (BlockCount == 0) {

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                //
                //  ByteCount is the number of bytes to read per Irp, while TotalByteCount
                //  is how many bytes to try to read during this call into NtfsReadRawEncrypted.
                //

                ByteCount = TotalByteCount / BlockCount;

                AccessingUserBuffer = TRUE;
                EncryptedDataInfo->DataUnitShift = TotalShift;
                AccessingUserBuffer = FALSE;

            } else {

                //
                //  We do not support compressed encrypted files yet.
                //

                Status = STATUS_NOT_IMPLEMENTED;
                leave;
            }

            //
            //  The actual file contents will start after the fixed length part
            //  of the encrypted data info struct plus one ulong per block that
            //  specifies the length of that block.  We also need to round
            //  OutputBufferOffset up so that the buffer we pass to the underlying
            //  driver(s) is sector aligned, since that is required for all
            //  unbuffered I/O.
            //

            BytesPerSectorMask = Vcb->BytesPerSector - 1;
            OutputBufferOffset = sizeof(ENCRYPTED_DATA_INFO) + (BlockCount * sizeof(ULONG));
            OutputBufferOffset = PtrOffset(EncryptedDataInfo,
                                           (((UINT_PTR) EncryptedDataInfo + OutputBufferOffset + BytesPerSectorMask) & ~BytesPerSectorMask));

            AccessingUserBuffer = TRUE;
            EncryptedDataInfo->OutputBufferOffset = OutputBufferOffset;
            EncryptedDataInfo->NumberOfDataBlocks = BlockCount;
            AccessingUserBuffer = FALSE;

            //
            //  Now that we know how much data we're going to try to read, and the
            //  offset into the user's buffer where we will start putting it, we
            //  can test one last time that the buffer is big enough.
            //

            if ((OutputBufferOffset + TotalByteCount) > OutputBufferLength) {

                Status = STATUS_BUFFER_TOO_SMALL;
                leave;
            }

            //
            //  While we have something acquired, let's take this opportunity to make sure
            //  that the volume hasn't been dismounted.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

#ifdef  COMPRESS_ON_WIRE
            if (Scb->Header.FileObjectC != NULL) {

                PCOMPRESSION_SYNC CompressionSync = NULL;

                //
                //  Use a try-finally to clean up the compression sync.
                //

                try {

                    NtfsSynchronizeUncompressedIo( Scb,
                                                   NULL,
                                                   0,
                                                   TRUE,
                                                   &CompressionSync );

                } finally {

                    NtfsReleaseCompressionSync( CompressionSync );
                }
            }
#endif

            //
            //  Get any cached changes flushed to disk.
            //

            CcFlushCache( FileObject->SectionObjectPointer,
                          (PLARGE_INTEGER)&StartingVbo,
                          TotalByteCount,
                          &Irp->IoStatus );

            //
            //  Check for errors in the flush.
            //

            NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                &Irp->IoStatus.Status,
                                                TRUE,
                                                STATUS_UNEXPECTED_IO_ERROR );

            //
            //  Store where we really started in the file.
            //

            AccessingUserBuffer = TRUE;
            EncryptedDataInfo->StartingFileOffset = StartingVbo;
            EncryptedDataInfo->ClusterShift = (UCHAR) Vcb->ClusterShift;
            EncryptedDataInfo->EncryptionFormat = ENCRYPTION_FORMAT_DEFAULT;
            AccessingUserBuffer = FALSE;

            //
            //  Begin by getting a pointer to the device object that the file resides
            //  on.
            //

            DeviceObject = IoGetRelatedDeviceObject( FileObject );

            //
            //  This IrpContext probably isn't ready to do noncached I/O yet,
            //  so let's set up its NtfsIoContext.  We know we will be doing
            //  this operation synchronously, so it is safe to use the
            //  local context.
            //

            if (IrpContext->Union.NtfsIoContext == NULL) {

                //
                //  Make sure the world knows we want this done synchronously.
                //

                ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );
                ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));
                ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_IO_CONTEXT ) );

                NtfsInitializeIoContext( IrpContext, &LocalContext, FALSE );
            }

            //
            //  Now we just loop through for each block and do the actual read(s).
            //

            DebugTrace( 0, Dbg, ("BlockCount     %08lx\n", BlockCount) );
            DebugTrace( 0, Dbg, ("TotalByteCount %08lx\n", TotalByteCount) );
            DebugTrace( 0, Dbg, ("ByteCount      %08lx\n", ByteCount) );

            for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex += 1) {

                //
                //  Compute the address to which we will start copying raw data.
                //

                RawDataDestination = Add2Ptr( EncryptedDataInfo, OutputBufferOffset );
                DebugTrace( 0, Dbg, ("RawDataDestination %p\n", (ULONG_PTR)RawDataDestination) );

                //
                //  If this is a sparse file, we need to determine whether this compression
                //  unit is allocated.
                //

                if (SparseFile) {

                    VCN StartVcn = LlClustersFromBytes( Vcb, StartingVbo );
                    VCN FinalCluster = LlClustersFromBytes( Vcb, (StartingVbo + ByteCount) ) - 1;
                    LONGLONG ClusterCount;

                    DebugTrace( 0, Dbg, ("SparseFile block  %08lx\n",    BlockIndex) );
                    DebugTrace( 0, Dbg, ("     StartingVbo  %016I64x\n", StartingVbo) );
                    DebugTrace( 0, Dbg, ("     StartVcn     %016I64x\n", StartVcn) );
                    DebugTrace( 0, Dbg, ("     FinalCluster %016I64x\n", FinalCluster) );

                    //
                    //  We need to call NtfsPreloadAllocation to make sure all the
                    //  ranges in this NtfsMcb are loaded.
                    //

                    NtfsPreloadAllocation( IrpContext,
                                           Scb,
                                           StartVcn,
                                           FinalCluster );

                    RangeAllocated = NtfsIsRangeAllocated( Scb,
                                                           StartVcn,
                                                           FinalCluster,
                                                           FALSE,
                                                           &ClusterCount );

                    if (!RangeAllocated) { DebugTrace( 0, Dbg, ("Deallocated range at Vcn %016I64x\n", StartVcn) ); }

                } else {

                    //
                    //  If this isn't a sparse file, we can skip the potentially expensive
                    //  mapping lookup.
                    //

                    ASSERT( BlockCount == 1 );
                    ASSERT( RangeAllocated );
                }

                if (RangeAllocated) {

                    //
                    //  Allocate an I/O Request Packet (IRP) for this raw read operation.
                    //

                    AccessingUserBuffer = TRUE;
                    ReadIrp = IoBuildAsynchronousFsdRequest( IRP_MJ_READ,
                                                             Vcb->Vpb->DeviceObject,
                                                             RawDataDestination,
                                                             ByteCount,
                                                             (PLARGE_INTEGER)&StartingVbo,
                                                             NULL );
                    AccessingUserBuffer = FALSE;

                    if (ReadIrp == NULL) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        leave;
                    }

                    //
                    //  We now have an Irp, we want to make it look as though it is part of
                    //  the current call.  We need to adjust the Irp stack to update this.
                    //

                    ReadIrp->CurrentLocation--;

                    ReadIrpSp = IoGetNextIrpStackLocation( ReadIrp );

                    ReadIrp->Tail.Overlay.CurrentStackLocation = ReadIrpSp;

                    ReadIrpSp->DeviceObject = DeviceObject;

                    //
                    //  Put our buffer in the Irp and lock it as well.
                    //

                    ReadIrp->UserBuffer = RawDataDestination;

                    AccessingUserBuffer = TRUE;
                    NtfsLockUserBuffer( IrpContext,
                                        ReadIrp,
                                        IoWriteAccess,
                                        ByteCount );

                    LockedReadIrpPages = TRUE;

                    //
                    //  Put the read code into the IrpContext.
                    //

                    IrpContext->MajorFunction = IRP_MJ_READ;

                    //
                    //  Actually read the raw data from the disk.
                    //
                    //  N.B. -- If the file is compressed, also pass the COMPRESSED_STREAM flag.
                    //

                    NtfsNonCachedIo( IrpContext,
                                     ReadIrp,
                                     Scb,
                                     StartingVbo,
                                     ByteCount,
                                     ENCRYPTED_STREAM );

                    //
                    //  Fill in how many bytes we actually read.
                    //

                    BytesRead = (ULONG) ReadIrp->IoStatus.Information;

                    ASSERT( OutputBufferLength >
                            ((BlockIndex * sizeof(ULONG)) + FIELD_OFFSET(ENCRYPTED_DATA_INFO, DataBlockSize)));

                    EncryptedDataInfo->DataBlockSize[BlockIndex] = BytesRead;
                    AccessingUserBuffer = FALSE;
                    OutputBufferOffset += BytesRead;

                } else {

                    //
                    //  We didn't really read anything, so we want to set the
                    //  size of this block to 0, but we want to pretend we
                    //  read a whole compression unit so that BytesWithinXXX
                    //  get updated correctly.
                    //

                    ASSERT( ReadIrp == NULL );

                    AccessingUserBuffer = TRUE;
                    EncryptedDataInfo->DataBlockSize[BlockIndex] = 0;
                    AccessingUserBuffer = FALSE;
                    BytesRead = Scb->CompressionUnit;
                }

                //
                //  Fill in the fields that let our caller know whether any of
                //  the file size or valid data length boundaries occured in
                //  the range of this transfer.
                //

                if ((StartingVbo + BytesRead) > Scb->Header.FileSize.QuadPart) {

                    //
                    //  Only increment if we start before filesize
                    //

                    if (StartingVbo < Scb->Header.FileSize.QuadPart) {
                        BytesWithinFileSize += (ULONG)(Scb->Header.FileSize.QuadPart -
                                                       StartingVbo);
                    }

                    //
                    //  If we're at the end of the file, and it isn't compressed, we can save
                    //  the user a ton of space on the tape if we truncate to the first 512 byte
                    //  boundary beyond the end of the data.
                    //  512 is the maximum cipher block size an encryption engine can rely on the
                    //  file system to allow..
                    //

                    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                        ASSERT( OutputBufferLength >
                                ((BlockIndex * sizeof(ULONG)) + FIELD_OFFSET(ENCRYPTED_DATA_INFO, DataBlockSize)));

                        AccessingUserBuffer = TRUE;
                        EncryptedDataInfo->DataBlockSize[BlockIndex] = ((BytesWithinFileSize + (ULONG)0x200) & (ULONG)(~0x1ff));
                        AccessingUserBuffer = FALSE;
                    }

                } else {

                    BytesWithinFileSize += BytesRead;
                }

                if ((StartingVbo + BytesRead) > Scb->Header.ValidDataLength.QuadPart) {

                    //
                    //  Make sure BytesWithinValidDataLength can't go negative.
                    //

                    if (Scb->Header.ValidDataLength.QuadPart > StartingVbo) {

                        BytesWithinValidDataLength += (ULONG)(Scb->Header.ValidDataLength.QuadPart -
                                                              StartingVbo);

                    }

                } else {

                    BytesWithinValidDataLength += BytesRead;
                }

                StartingVbo += ByteCount;

                //
                //  We need to clean up the irp before we go around again.
                //

                if (ReadIrp != NULL) {

                    //
                    //  If there is an Mdl we free that first.
                    //

                    if (ReadIrp->MdlAddress != NULL) {

                        if (LockedReadIrpPages) {

                            MmUnlockPages( ReadIrp->MdlAddress );
                            LockedReadIrpPages = FALSE;
                        }

                        IoFreeMdl( ReadIrp->MdlAddress );
                        ReadIrp->MdlAddress = NULL;
                    }

                    IoFreeIrp( ReadIrp );
                    ReadIrp = NULL;
                }
            }  //  endfor

            AccessingUserBuffer = TRUE;
            EncryptedDataInfo->BytesWithinFileSize = BytesWithinFileSize;
            EncryptedDataInfo->BytesWithinValidDataLength = BytesWithinValidDataLength;
            AccessingUserBuffer = FALSE;

        } except( NtfsFsctrlExceptionFilter( IrpContext, GetExceptionInformation(), AccessingUserBuffer, &Status ) ) {

            DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted raising %08lx\n", Status) );
            NtfsRaiseStatus( IrpContext,
                             STATUS_INVALID_USER_BUFFER,
                             NULL,
                             NULL );
        }

    try_exit: NOTHING;

    } finally {

        if (ReadIrp != NULL) {

            //
            //  If there is an Mdl we free that first.
            //

            if (ReadIrp->MdlAddress != NULL) {

                if (LockedReadIrpPages) {

                    MmUnlockPages( ReadIrp->MdlAddress );
                }

                IoFreeMdl( ReadIrp->MdlAddress );
            }

            IoFreeIrp( ReadIrp );
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted -> %08lx\n", Status) );

    return Status;
}

LONG
NtfsWriteRawExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    Exception filter for errors during cleanup.  We want to raise if this is
    a retryable condition or fatal error, plow on as best we can if not.

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( FsRtlIsNtstatusExpected( ExceptionPointer->ExceptionRecord->ExceptionCode ) );
    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
NtfsWriteRawEncrypted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs a 'raw' write of encrypted data.  By 'raw', we
    mean without attempting to encrypt.  This is useful for restore
    operations, where the restore operator does not have a key with which
    to read the plaintext.  This routine is responsible for either
    completing or enqueuing the input Irp.

    NOTE: there is a strong assumption that the encrypted data info blocks
    are ordered monotonically from the beginning to end of the file

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    LONGLONG StartingVbo;
    LONGLONG EndingVbo;
    LONGLONG TotalBytesWritten = 0;
    LONGLONG FirstZero;
    LONGLONG OriginalStartingVbo;
    ULONG ByteCount;
    ULONG BytesWithinValidDataLength;
    ULONG BytesWithinFileSize;
    USHORT CompressionFormat;

    PIRP WriteIrp = NULL;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION WriteIrpSp;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG InputBufferLength;
    PENCRYPTED_DATA_INFO EncryptedDataInfo;
    ULONG InputBufferOffset;
    USHORT BlockIndex;
    USHORT BlockCount;

    PUCHAR RawDataSource;

    BOOLEAN AccessingUserBuffer = FALSE;
    UCHAR EncryptionFormat;
    UCHAR ChunkShift;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Don't post this request, we can't lock both input and output buffers.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    DebugTrace( +1, Dbg, ("NtfsWriteRawEncrypted:\n") );

    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    //
    //  This operation only applies to files, not indexes,
    //  or volumes.
    //

    if (TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted not a UserFileOpen -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        DebugTrace( -1, Dbg, ("SetCompression returning WRITE_PROTECTED\n") );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  We can't allow writes to unencrypted files, as that could let any
    //  user write to any file..
    //

    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) ||

        //
        //  Even for an encrypted file, we should only allow this if the
        //  user has write access.
        //

        (!(FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input buffer length and pointer.
    //

    EncryptedDataInfo = (PENCRYPTED_DATA_INFO)IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Check for a minimum length on the input buffer.
    //

    if (InputBufferLength < sizeof(ENCRYPTED_DATA_INFO)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted -> %08lx\n", STATUS_BUFFER_TOO_SMALL) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Probe the user's buffer.
    //

    try {

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead( EncryptedDataInfo, InputBufferLength, sizeof( UCHAR ) );
        }

        InputBufferOffset = EncryptedDataInfo->OutputBufferOffset;
        BytesWithinValidDataLength = EncryptedDataInfo->BytesWithinValidDataLength;
        BytesWithinFileSize = EncryptedDataInfo->BytesWithinFileSize;
        BlockCount = EncryptedDataInfo->NumberOfDataBlocks;
        EncryptionFormat = EncryptedDataInfo->EncryptionFormat;
        OriginalStartingVbo = StartingVbo = EncryptedDataInfo->StartingFileOffset;
        ChunkShift = EncryptedDataInfo->ChunkShift;
        CompressionFormat = EncryptedDataInfo->CompressionFormat;

    } except( NtfsWriteRawExceptionFilter( IrpContext, GetExceptionInformation() ) ) {

        Status = GetExceptionCode();

        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted raising %08lx\n", Status) );
        NtfsRaiseStatus( IrpContext,
                         FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER,
                         NULL,
                         NULL );
    }

    //
    //  See whether the data we're being given is valid.
    //

    if ((EncryptionFormat != ENCRYPTION_FORMAT_DEFAULT) ||
        (BytesWithinValidDataLength > BytesWithinFileSize) ||
        (CompressionFormat != COMPRESSION_FORMAT_NONE) ||
        (BlockCount == 0) ||
        (InputBufferOffset > InputBufferLength)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted bad input data -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }


    try {

        //
        //  Serialize with anyone who might be changing file sizes. Acquire main directly
        //  because we call CommonWrite mult times and want to hold the resource across the calls
        //

        NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
        NtfsAcquireExclusiveScb( IrpContext, Scb );

#ifdef  COMPRESS_ON_WIRE

        //
        //  Before we proceed, let's make sure this file is not cached.
        //

        if (Scb->Header.FileObjectC != NULL) {

            PCOMPRESSION_SYNC CompressionSync = NULL;

            //
            //  Use a try-finally to clean up the compression sync.
            //

            try {

                NtfsSynchronizeUncompressedIo( Scb,
                                               NULL,
                                               0,
                                               TRUE,
                                               &CompressionSync );

            } finally {

                NtfsReleaseCompressionSync( CompressionSync );
            }
        }
#endif

        CcFlushCache( &Scb->NonpagedScb->SegmentObject, NULL, 0, &Irp->IoStatus );

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Irp->IoStatus.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject, NULL, 0, FALSE )) {

            DebugTrace( 0, Dbg, ("Can't purge cache section in write raw...aborting\n") );
            Status = STATUS_UNABLE_TO_DELETE_SECTION;
            leave;
        }

//  **** TIGHTEN THIS ASSERT ****
//            ASSERT( Scb->NonpagedScb->SegmentObject.SharedCacheMap == NULL );

        //
        //  Since we can't add zeroes in the middle of the file (since we may not
        //  have a key with which to encrypt them) it's illegal to try to write
        //  at some arbitrary offset beyond the current eof.
        //

        if (StartingVbo != Scb->Header.FileSize.QuadPart) {

            DebugTrace( 0, Dbg, ("Attempting to begin a write raw beyond EOF...aborting\n") );
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Add any allocation necc. to reach the new filesize
        //

        if (OriginalStartingVbo + BytesWithinFileSize >  Scb->Header.AllocationSize.QuadPart) {

            EndingVbo = OriginalStartingVbo + BytesWithinFileSize;

            //
            //  Always add in compression units for sparse files
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                EndingVbo = BlockAlign( EndingVbo, (LONG)Scb->CompressionUnit );
            }

            NtfsAddAllocation( IrpContext,
                               NULL,
                               Scb,
                               LlClustersFromBytes( Vcb,
                                                    Scb->Header.AllocationSize.QuadPart ),
                               LlClustersFromBytes( Vcb, EndingVbo - Scb->Header.AllocationSize.QuadPart ),
                               FALSE,
                               NULL );
        }

        //
        //  Now we just loop through for each block and do the actual write(s).
        //

        DebugTrace( 0, Dbg, ("BlockCount     %08lx\n", BlockCount) );

        for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex += 1) {

            AccessingUserBuffer = TRUE;
            ByteCount = EncryptedDataInfo->DataBlockSize[BlockIndex];
            AccessingUserBuffer = FALSE;
            EndingVbo = StartingVbo + ByteCount;

            DebugTrace( 0, Dbg, ("BlockIndex     %08lx\n", BlockIndex) );
            DebugTrace( 0, Dbg, ("ByteCount      %08lx\n", ByteCount) );


            if (ByteCount != 0 && BytesWithinValidDataLength > 0) {

                //
                //  Compute the address from which we will start copying raw data.
                //

                RawDataSource = Add2Ptr( EncryptedDataInfo, InputBufferOffset );

                //
                //  Make sure we aren't about to touch memory beyond that part of the
                //  user's buffer that we probed above.
                //

                if ((InputBufferOffset + ByteCount) > InputBufferLength) {

                    DebugTrace( 0, Dbg, ("Going beyond InputBufferLength...aborting\n") );
                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                InputBufferOffset += ByteCount;

                //
                //  Begin by getting a pointer to the device object that the file resides
                //  on.
                //

                DeviceObject = IoGetRelatedDeviceObject( FileObject );

                //
                //  Allocate an I/O Request Packet (IRP) for this raw write operation.
                //  It has to be synchronous so that it completes before we adjust
                //  filesize and valid data length.
                //

                AccessingUserBuffer = TRUE;
                WriteIrp = IoBuildSynchronousFsdRequest( IRP_MJ_WRITE,
                                                         Vcb->Vpb->DeviceObject,
                                                         RawDataSource,
                                                         ByteCount,
                                                         (PLARGE_INTEGER)&StartingVbo,
                                                         &Event,
                                                         &Iosb );
                AccessingUserBuffer = FALSE;

                if (WriteIrp == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                //
                //  Put our buffer in the Irp and set some other irp fields.
                //

                WriteIrp->UserBuffer = RawDataSource;
                SetFlag( WriteIrp->Flags, IRP_NOCACHE );

                //
                //  We now have an Irp, we want to make it look as though it came from
                //  IoCallDriver and need  to adjust the Irp stack to update this.
                //

                WriteIrpSp = IoGetNextIrpStackLocation( WriteIrp );

                WriteIrpSp->DeviceObject = DeviceObject;
                WriteIrpSp->Parameters.Write.ByteOffset.QuadPart = StartingVbo;
                WriteIrpSp->Parameters.Write.Length = ByteCount;
                WriteIrpSp->FileObject = FileObject;

                ASSERT( NtfsIsExclusiveScb( Scb ) );

                //
                //  Callback directly into ourselfs - don't confuse filters with
                //  an extra write
                //

                Status = IoCallDriver( Vcb->Vpb->DeviceObject, WriteIrp );

                if (Status == STATUS_PENDING) {
                    Status = KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
                    if (Status == STATUS_SUCCESS) {
                        Status = Iosb.Status;
                    }
                }

                //
                //  The write should always be done synchronously, we should still own
                //  the resource and all our cleanup structures and snapshots should be good
                //

                ASSERT(Status != STATUS_PENDING && Status != STATUS_CANT_WAIT);
                ASSERT( NtfsIsExclusiveScb( Scb ) );
                ASSERT( (IrpContext->CleanupStructure == Fcb) && (Scb->ScbSnapshot != NULL) );

                NtfsNormalizeAndCleanupTransaction( IrpContext, &Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

                TotalBytesWritten += ByteCount;

            } else if (ByteCount == 0) {

                //
                //  This is a sparse hole, so there's nothing to actually write.
                //  We just need to make sure this stream is sparse, and zero this
                //  range.  We can't ask our caller to mark the file as sparse,
                //  since they just opened the handle and don't have write
                //  access to this file.
                //

                DebugTrace( 0, Dbg, ("Deallocated range for block %x\n", BlockIndex) );

                //
                //  Make sure our test of the attribute flag is safe.
                //

                ASSERT_SHARED_RESOURCE( Scb->Header.PagingIoResource );

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    DebugTrace( 0, Dbg, ("Marking stream as sparse\n") );
                    NtfsSetSparseStream( IrpContext, NULL, Scb );
                }

                ByteCount = (1 << ChunkShift);
                EndingVbo = StartingVbo + ByteCount;

                //
                //  Add any allocation necc. to back this. Ie we have a sparse region
                //  beyond filesize
                //

                if (Scb->Header.AllocationSize.QuadPart < EndingVbo) {

                    //
                    //  Round up to a compression unit
                    //

                    EndingVbo = BlockAlign( EndingVbo, (LONG)Scb->CompressionUnit );

                    NtfsAddAllocation( IrpContext,
                                       NULL,
                                       Scb,
                                       LlClustersFromBytes( Vcb,
                                                            Scb->Header.AllocationSize.QuadPart ),
                                       LlClustersFromBytes( Vcb,
                                                            EndingVbo - Scb->Header.AllocationSize.QuadPart ),
                                       FALSE,
                                       NULL );
                }

                DebugTrace( 0, Dbg, ("Zeroing range from %I64x\n", StartingVbo) );
                DebugTrace( 0, Dbg, ("to %I64x\n", (StartingVbo + ByteCount - 1)) );

                //
                //  We can't synthesize partial sparse holes, since our caller may
                //  not have a key with which to encrypt a buffer full of zeroes.
                //  Therefore, we can't do this restore if the volume we're restoring
                //  to requires sparse holes to be bigger than the hole we're
                //  trying to restore now.
                //

                if (ByteCount < Scb->CompressionUnit) {

                    DebugTrace( 0, Dbg, ("Can't synthesize partial sparse hole\n") );
                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

                //
                //  Copy StartingVbo in case ZeroRangeInStream modifies it.
                //  NtfsZeroRangeInStream uses the cleanupstructure so always
                //  return it back to its original value afterwards
                //

                FirstZero = StartingVbo;

                Status = NtfsZeroRangeInStream( IrpContext,
                                                FileObject,
                                                Scb,
                                                &FirstZero,
                                                (StartingVbo + ByteCount - 1) );

                ASSERT( (PFCB)IrpContext->CleanupStructure == Fcb );

                if (!NT_SUCCESS( Status )) {

                    leave;
                }

                //
                //  Let's move the filesize up now, just like NtfsCommonWrite does in
                //  the other half of this if statement.
                //

                {
                    LONGLONG NewFileSize = StartingVbo + ByteCount;

                    DebugTrace( 0, Dbg, ("Adjusting sparse file size to %I64x\n", NewFileSize) );

                    Scb->Header.FileSize.QuadPart = NewFileSize;

                    NtfsWriteFileSizes( IrpContext, Scb, &NewFileSize, FALSE, TRUE, TRUE );

                    if (Scb->FileObject != NULL) {

                        CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );
                    }
                }
                TotalBytesWritten += ByteCount;
            }
            StartingVbo += ByteCount;
        }

        DebugTrace( 0, Dbg, ("TotalBytesWritten %I64x\n", TotalBytesWritten) );

        //
        //  Only adjust the filesizes if the write succeeded.  If the write failed
        //  the IrpContext has been freed already. Note: startyingvbo must be <= original eof
        //

        if (NT_SUCCESS( Status ) &&
            ((LONGLONG)BytesWithinFileSize != TotalBytesWritten ||
             (LONGLONG)BytesWithinValidDataLength < TotalBytesWritten)) {

            LONGLONG NewValidDataLength = OriginalStartingVbo + BytesWithinValidDataLength;

            Scb->Header.FileSize.QuadPart = OriginalStartingVbo + BytesWithinFileSize;
            if (NewValidDataLength < Scb->Header.ValidDataLength.QuadPart) {
                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
            }

            //
            //  WriteFileSizes will only move the VDL back since we set AdvanceOnly to False
            //

            ASSERT( IrpContext->CleanupStructure != NULL );

            NtfsWriteFileSizes( IrpContext, Scb, &NewValidDataLength, FALSE, TRUE, TRUE );

            //
            //  Readjust VDD - for non compressed files this is a noop since vdd is not updated for them
            //

            if (Scb->ValidDataToDisk > Scb->Header.ValidDataLength.QuadPart) {
                Scb->ValidDataToDisk = Scb->Header.ValidDataLength.QuadPart;
            }

            if (Scb->FileObject != NULL) {

                CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );
            }
        }
    } except( NtfsWriteRawExceptionFilter( IrpContext, GetExceptionInformation() ) ) {

        Status = GetExceptionCode();

        DebugTrace( -1, Dbg, ("NtfsReadRawEncrypted raising %08lx\n", Status) );
        NtfsRaiseStatus( IrpContext,
                         ((FsRtlIsNtstatusExpected(Status) || !AccessingUserBuffer) ? Status : STATUS_INVALID_USER_BUFFER),
                         NULL,
                         NULL );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsWriteRawEncrypted -> %08lx\n", Status) );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NtfsExtendVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine extends an Ntfs volume.  We will take the number of sectors
    passed to this routine and extend the volume provided that this will grow
    the volume by at least one cluster.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_REFERENCE FileReference = { BOOT_FILE_NUMBER, 0, BOOT_FILE_NUMBER };
    PSCB BootFileScb = NULL;
    BOOLEAN RemovedBootFileFcb = FALSE;

    BOOLEAN UnloadMcb = FALSE;

    LONGLONG NewVolumeSize;
    LONGLONG NewTotalClusters;

    LONGLONG NewBitmapSize;
    LONGLONG NewBitmapAllocation;
    LONGLONG AddBytes;
    LONGLONG AddClusters = 0;

    LONGLONG PreviousBitmapAllocation;

    LCN NewLcn;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG FileOffset;
    LONGLONG BeyondBitsToModify;
    LONGLONG NewSectors;

    IO_STATUS_BLOCK Iosb;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    DISK_GEOMETRY DiskGeometry;
    LONGLONG DiskBytes;

    PBCB PrimaryBootBcb = NULL;
    PBCB BackupBootBcb = NULL;

    PPACKED_BOOT_SECTOR PrimaryBootSector;
    PPACKED_BOOT_SECTOR BackupBootSector;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsExtendVolume...\n") );

    //
    //  Make sure the input parameters are valid.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  The input buffer is a LONGLONG and it should not be zero.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( LONGLONG )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory( &NewSectors, Irp->AssociatedIrp.SystemBuffer, sizeof( LONGLONG ));

    if (NewSectors <= 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Extract and decode the file object, and only permit user volume opens
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext,
                                       IrpSp->FileObject,
                                       &Vcb,
                                       &Fcb,
                                       &Scb,
                                       &Ccb,
                                       TRUE );

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Readonly mount should be just that: read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        DebugTrace( -1, Dbg, ("SetCompression returning WRITE_PROTECTED\n") );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  We don't want to rewind back to a different value than what we currently have
    //

    ASSERT( Vcb->PreviousTotalClusters == Vcb->TotalClusters );

    //
    //  Lets set the Scb to the volume bitmap scb at this point.  We no longer care about
    //  the volume Dasd Scb from here on.
    //

    Scb = NULL;

    //
    //  Compute the new volume size.  Don't forget to allow one sector for the backup
    //  boot sector.
    //

    NewVolumeSize = (NewSectors - 1) * Vcb->BytesPerSector;
    NewTotalClusters = LlClustersFromBytesTruncate( Vcb, NewVolumeSize );

    //
    //  Make sure the volume size didn't wrap and that we don't have more than 2^32 - 2 clusters.
    //  We make this 2^32 - 2 so that we can generate a cluster for the backup boot sector in
    //  order to write it.
    //

    if ((NewVolumeSize < NewSectors) ||
        (NewTotalClusters > (0x100000000 - 2))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We hold the Vcb exclusively for this operation.  Make sure the wait flag is
    //  set in the IrpContext.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    NtfsInitializeAttributeContext( &AttrContext );
    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Make sure the volume is mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  We only need the Mft and volume bitmap for this operation.
        //  Lets set the Scb to the volume bitmap scb at this point.  We no longer care about
        //  the volume Dasd Scb from here on.  We acquire it here solely to be able to
        //  update the size when we are done.
        //

        Scb = Vcb->BitmapScb;
        NtfsAcquireExclusiveFcb( IrpContext, Vcb->VolumeDasdScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );
        NtfsAcquireExclusiveFcb( IrpContext, Vcb->MftScb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK );

        ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, TRUE );
        NtfsAcquireExclusiveFcb( IrpContext, Scb->Fcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_HOLD_BITMAP );
        ASSERT( Scb->Fcb->ExclusiveFcbLinks.Flink != NULL );

        //
        //  Make sure we are adding at least one cluster.
        //

        if ((Vcb->TotalClusters >= NewTotalClusters) &&
            (NewTotalClusters >= 0)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Also check that the driver supports a drive of this size.
        //  Total size in use == NewVolumeSize + the last copy of the boot sector
        //  NewVolumeSize is already biased for the boot sector copy
        //

        NtfsGetDiskGeometry( IrpContext, Vcb->TargetDeviceObject, &DiskGeometry, &DiskBytes );

        if ((Vcb->BytesPerSector != DiskGeometry.BytesPerSector) ||
            (NewVolumeSize + Vcb->BytesPerSector > DiskBytes)) {

            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Go ahead and create an Fcb and Scb for the BootFile.
        //

        BootFileScb = NtfsCreatePrerestartScb( IrpContext, Vcb, &FileReference, $DATA, NULL, 0 );

        //
        //  Acquire this Fcb exclusively but don't put it our exclusive lists or snapshot it.
        //

        NtfsAcquireResourceExclusive( IrpContext, BootFileScb, TRUE );
        if (!FlagOn( BootFileScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

            NtfsUpdateScbFromAttribute( IrpContext, BootFileScb, NULL );
        }

        //
        //  Lets flush and purge the volume bitmap.  We want to make sure there are no
        //  partial pages at the end of the bitmap.
        //

        CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                      NULL,
                      0,
                      &Iosb );

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                  NULL,
                                  0,
                                  FALSE )) {

            NtfsRaiseStatus( IrpContext, STATUS_UNABLE_TO_DELETE_SECTION, NULL, NULL );
        }

        //
        //  We want to snapshot the volume bitmap.
        //

        NtfsSnapshotScb( IrpContext, Scb );

        //
        //  Unload the Mcb in case of errors.
        //

        ASSERT( Scb->ScbSnapshot != NULL );
        Scb->ScbSnapshot->LowestModifiedVcn = 0;
        Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;

        //
        //  Round the bitmap size up to an 8 byte boundary.
        //

        NewBitmapSize = BlockAlign( Int64ShraMod32( NewTotalClusters + 7, 3 ), 8 );
        NewBitmapAllocation = LlBytesFromClusters( Vcb, LlClustersFromBytes( Vcb, NewBitmapSize ));

        PreviousBitmapAllocation = Scb->Header.AllocationSize.QuadPart;

        //
        //  If we are growing the allocation for the volume bitmap then
        //  we want to make sure the entire new clusters are zeroed and
        //  then added to the volume bitmap.
        //

        if (NewBitmapAllocation > PreviousBitmapAllocation) {

            AddBytes = NewBitmapAllocation - PreviousBitmapAllocation;
            AddClusters = LlClustersFromBytesTruncate( Vcb, AddBytes );

            //
            //  Add the entry to Mcb.  We would prefer not to overwrite the existing
            //  backup boot sector if possible.
            //

            NewLcn = Vcb->PreviousTotalClusters + 1;
            if (NewLcn + AddClusters > NewTotalClusters) {

                NewLcn -= 1;
            }

            NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                 LlClustersFromBytesTruncate( Vcb, PreviousBitmapAllocation ),
                                 NewLcn,
                                 AddClusters,
                                 FALSE );

            //
            //  We may need to unload the Mcb by hand if we get a failure before the first log record.
            //

            UnloadMcb = TRUE;

            //
            //  Now write zeroes into these clusters.
            //

            NtfsWriteClusters( IrpContext,
                               Vcb,
                               Scb,
                               PreviousBitmapAllocation,
                               NULL,
                               (ULONG)AddClusters);

            //
            //  Store the new total clusters in the Vcb now.  Several of our routines
            //  check that a cluster being used lies within the volume.  We will temporarily round
            //  this up to an 8 byte boundary so we can set any unused bits in the tail of
            //  the bitmap.
            //

            Vcb->TotalClusters = Int64ShllMod32( NewBitmapSize, 3 );

            //
            //  Go ahead and write the new mapping pairs for the larger allocation.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
            NtfsAddAttributeAllocation( IrpContext, Scb, &AttrContext, NULL, NULL );

            //
            //  Our transaction handling will deal with the Mcb now.
            //

            UnloadMcb = FALSE;

            //
            //  Now tell the cache manager about the larger section.
            //

            CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );

        } else {


            //
            //  Store the new total clusters in the Vcb now.  Several of our routines
            //  check that a cluster being used lies within the volume.  We will temporarily round
            //  this up to an 8 byte boundary so we can set any unused bits in the tail of
            //  the bitmap.
            //

            Vcb->TotalClusters = Int64ShllMod32( NewBitmapSize, 3 );

        }

        //
        //  We now have allocated enough space for the new clusters.  The next step is to mark them
        //  allocated in the new volume bitmap.  Start by updating the file size in the Scb and
        //  on disk for the new size.  We can make the whole new range valid.  We will explicitly
        //  update any bytes that may still be incorrect on disk.
        //

        Scb->Header.ValidDataLength.QuadPart =
        Scb->Header.FileSize.QuadPart = NewBitmapSize;

        Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

        NtfsWriteFileSizes( IrpContext, Scb, &NewBitmapSize, TRUE, TRUE, TRUE );
        CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES) &Scb->Header.AllocationSize );

        //
        //  The file size is now correct in the Scb and on disk.  The next thing to do is
        //  to zero out any bits between the previous end of the bitmap and the end of the previous
        //  allocation (or the current total clusters, whichever is smaller).
        //

        BeyondBitsToModify = Int64ShllMod32( PreviousBitmapAllocation, 3 );

        if (Vcb->TotalClusters < BeyondBitsToModify) {

            BeyondBitsToModify = Vcb->TotalClusters;
        }

        if (BeyondBitsToModify != Vcb->PreviousTotalClusters) {

            NtfsModifyBitsInBitmap( IrpContext,
                                    Vcb,
                                    Vcb->PreviousTotalClusters,
                                    BeyondBitsToModify,
                                    ClearBitsInNonresidentBitMap,
                                    SetBitsInNonresidentBitMap );
        }

        //
        //  Now we need to set bits for all of the new clusters which are part of
        //  the extension of the volume bitmap.
        //

        if (AddClusters != 0) {

            NtfsModifyBitsInBitmap( IrpContext,
                                    Vcb,
                                    NewLcn,
                                    NewLcn + AddClusters,
                                    SetBitsInNonresidentBitMap,
                                    ClearBitsInNonresidentBitMap );
        }

        //
        //  Finally we need to set all of the bits in the new bitmap which lie beyond
        //  the end of the actual on-disk clusters.
        //

        BeyondBitsToModify = Int64ShllMod32( NewBitmapSize, 3 );
        if (BeyondBitsToModify != NewTotalClusters) {

            NtfsModifyBitsInBitmap( IrpContext,
                                    Vcb,
                                    NewTotalClusters,
                                    BeyondBitsToModify,
                                    SetBitsInNonresidentBitMap,
                                    Noop );
        }

        //
        //  Now set to the exact clusters on the disk.
        //

        Vcb->TotalClusters = NewTotalClusters;

        //
        //  Now it is time to modify the boot sectors for the volume.  We want to:
        //
        //      o Remove the allocation for the n/2 boot sector if present (3.51 format)
        //      o Copy the current boot sector to the end of the volume (with the new sector count)
        //      o Update the primary boot sector at the beginning of the volume.
        //
        //  Start by purging the stream.
        //

        NtfsCreateInternalAttributeStream( IrpContext, BootFileScb, TRUE, NULL );

        //
        //  Don't let the lazy writer touch this stream.
        //

        CcSetAdditionalCacheAttributes( BootFileScb->FileObject, TRUE, TRUE );

        //
        //  Now look to see if the file has more than one run.  If so we want to truncate
        //  it to the end of the first run.
        //

        if (NtfsLookupAllocation( IrpContext, BootFileScb, 0, &Lcn, &ClusterCount, NULL, NULL )) {

            NtfsDeleteAllocation( IrpContext,
                                  BootFileScb->FileObject,
                                  BootFileScb,
                                  ClusterCount,
                                  MAXLONGLONG,
                                  TRUE,
                                  FALSE );
        }

        //
        //  Now create mapping for this stream where the first page (or cluster) will be used for the
        //  primary boot sector and we will have the additional sectors to be able to write to the
        //  last sector.
        //

        BootFileScb->Header.FileSize.QuadPart = PAGE_SIZE;

        if (PAGE_SIZE < Vcb->BytesPerCluster) {

            BootFileScb->Header.FileSize.QuadPart = Vcb->BytesPerCluster;
        }

        BootFileScb->Header.FileSize.QuadPart += (NewVolumeSize + Vcb->BytesPerSector) - LlBytesFromClusters( Vcb, NewTotalClusters );

        BootFileScb->Header.ValidDataLength.QuadPart = BootFileScb->Header.FileSize.QuadPart;

        BootFileScb->Header.AllocationSize.QuadPart = LlBytesFromClusters( Vcb, LlClustersFromBytes( Vcb, BootFileScb->Header.FileSize.QuadPart ));

        CcSetFileSizes( BootFileScb->FileObject, (PCC_FILE_SIZES) &BootFileScb->Header.AllocationSize );

        //
        //  Go ahead purge any existing data and empty the Mcb.
        //

        CcPurgeCacheSection( &BootFileScb->NonpagedScb->SegmentObject,
                             NULL,
                             0,
                             FALSE );

        NtfsUnloadNtfsMcbRange( &BootFileScb->Mcb,
                                0,
                                MAXLONGLONG,
                                FALSE,
                                FALSE );

        //
        //  Lets create the Mcb by hand for this.
        //

        NtfsAddNtfsMcbEntry( &BootFileScb->Mcb,
                             0,
                             0,
                             LlClustersFromBytes( Vcb, PAGE_SIZE ),
                             FALSE );

        NtfsAddNtfsMcbEntry( &BootFileScb->Mcb,
                             LlClustersFromBytes( Vcb, PAGE_SIZE ),
                             NewTotalClusters,
                             1,
                             FALSE );

        //
        //  Now lets pin the two boot sectors.
        //

        FileOffset = 0;
        NtfsPinStream( IrpContext,
                       BootFileScb,
                       0,
                       Vcb->BytesPerSector,
                       &PrimaryBootBcb,
                       &PrimaryBootSector );

        FileOffset = BootFileScb->Header.FileSize.QuadPart - Vcb->BytesPerSector;

        NtfsPinStream( IrpContext,
                       BootFileScb,
                       FileOffset,
                       Vcb->BytesPerSector,
                       &BackupBootBcb,
                       &BackupBootSector );

        //
        //  Remember thge new sector count is 1 less than what we were given
        //

        NewSectors -= 1;

        //
        //  Copy the primary boot sector to the backup location.
        //

        RtlCopyMemory( BackupBootSector, PrimaryBootSector, Vcb->BytesPerSector );

        //
        //  Now copy the sector count into the boot sectors and flush to disk.
        //  Use RtlCopy to avoid alignment faults.
        //

        RtlCopyMemory( &BackupBootSector->NumberSectors, &NewSectors, sizeof( LONGLONG ));

        CcSetDirtyPinnedData( BackupBootBcb, NULL );

        CcFlushCache( &BootFileScb->NonpagedScb->SegmentObject,
                      (PLARGE_INTEGER) &FileOffset,
                      Vcb->BytesPerSector,
                      &Iosb );

        //
        //  Make sure the flush worked.
        //

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        //
        //  Now do the primary.
        //

        FileOffset = 0;
        RtlCopyMemory( &PrimaryBootSector->NumberSectors, &NewSectors, sizeof( LONGLONG ));
        CcSetDirtyPinnedData( PrimaryBootBcb, NULL );

        CcFlushCache( &BootFileScb->NonpagedScb->SegmentObject,
                      (PLARGE_INTEGER) &FileOffset,
                      Vcb->BytesPerSector,
                      &Iosb );

        //
        //  Make sure the flush worked.
        //

        NtfsNormalizeAndCleanupTransaction( IrpContext, &Iosb.Status, TRUE, STATUS_UNEXPECTED_IO_ERROR );

        //
        //  Let's get rid of the pages for this stream now.
        //

        NtfsUnpinBcb( IrpContext, &PrimaryBootBcb );
        NtfsUnpinBcb( IrpContext, &BackupBootBcb );

        CcPurgeCacheSection( &BootFileScb->NonpagedScb->SegmentObject,
                             NULL,
                             0,
                             FALSE );

        NtfsCleanupTransaction( IrpContext, Status, TRUE );

        //
        //  Commit the transaction now so we can update some of the in-memory structures.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );
        LfsFlushToLsn( Vcb->LogHandle, LiMax );

        //
        //  We know this request has succeeded.  Go ahead and remember the new total cluster count
        //  and sector count.
        //

        Vcb->PreviousTotalClusters = Vcb->TotalClusters;
        Vcb->NumberSectors = NewSectors;

        //
        //  Also update the volume dasd size.
        //

        Vcb->VolumeDasdScb->Header.ValidDataLength.QuadPart =
        Vcb->VolumeDasdScb->Header.FileSize.QuadPart =
        Vcb->VolumeDasdScb->Header.AllocationSize.QuadPart = LlBytesFromClusters( Vcb, Vcb->TotalClusters );

        //
        //  Set the flag in the Vcb to cause a rescan of the bitmap for free clusters.  This will also
        //  let the bitmap package use the larger blocks of available disk space.
        //

        SetFlag( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS );

    } finally {

        DebugUnwind( NtfsExtendVolume );

        NtfsUnpinBcb( IrpContext, &PrimaryBootBcb );
        NtfsUnpinBcb( IrpContext, &BackupBootBcb );

        //
        //  Remove the boot file Fcb if we created it.
        //

        if (BootFileScb != NULL) {

            //
            //  Let's know the sizes to zero and get rid of the pages.
            //

            BootFileScb->Header.AllocationSize.QuadPart =
            BootFileScb->Header.FileSize.QuadPart =
            BootFileScb->Header.ValidDataLength.QuadPart = 0;

            ClearFlag( BootFileScb->ScbState, SCB_STATE_FILE_SIZE_LOADED );

            NtfsUnloadNtfsMcbRange( &BootFileScb->Mcb,
                                    0,
                                    MAXLONGLONG,
                                    FALSE,
                                    FALSE );

            if (BootFileScb->FileObject != NULL) {

                //
                //  Deleting the internal attribute stream should automatically
                //  trigger teardown since its the last ref count
                //

                CcSetFileSizes( BootFileScb->FileObject, (PCC_FILE_SIZES) &BootFileScb->Header.AllocationSize );
                NtfsIncrementCloseCounts( BootFileScb, TRUE, FALSE );
                NtfsDeleteInternalAttributeStream( BootFileScb, TRUE, FALSE );
                NtfsDecrementCloseCounts( IrpContext, BootFileScb, NULL, TRUE, FALSE, TRUE, NULL );
            }

            NtfsTeardownStructures( IrpContext,
                                    BootFileScb->Fcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    &RemovedBootFileFcb );

            if (!RemovedBootFileFcb) {

                NtfsReleaseResource( IrpContext, BootFileScb );
            }
        }


        if (UnloadMcb) {

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    0,
                                    MAXLONGLONG,
                                    FALSE,
                                    FALSE );
        }

        //
        //  Release the file resources if we hold them.
        //

        if (Scb != NULL) {

            NtfsReleaseFcb( IrpContext, Scb->Fcb );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
            NtfsReleaseFcb( IrpContext, Vcb->MftScb->Fcb );
            NtfsReleaseFcb( IrpContext, Vcb->VolumeDasdScb->Fcb );
        }

        NtfsReleaseVcb( IrpContext, Vcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsExtendVolume -> %08lx\n", Status) );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsMarkHandle (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to attach special properties to a user handle.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PMARK_HANDLE_INFO HandleInfo;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFILE_OBJECT DasdFileObject;
    PFCB DasdFcb, Fcb;
    PSCB DasdScb, Scb;
    PCCB DasdCcb, Ccb;
    BOOLEAN ReleaseScb = FALSE;
#if defined(_WIN64)
    MARK_HANDLE_INFO LocalMarkHandleInfo;
#endif

    extern POBJECT_TYPE *IoFileObjectType;

    PAGED_CODE();

    //
    //  Always make this synchronous.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We currently support this call for files and directories only.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        (TypeOfOpen != UserDirectoryOpen) &&
        (TypeOfOpen != UserViewIndexOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

#if defined(_WIN64)

    //
    //  Win32/64 thunking code
    //

    if (IoIs32bitProcess( Irp )) {

        PMARK_HANDLE_INFO32 MarkHandle32;

        if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MARK_HANDLE_INFO32 )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        MarkHandle32 = (PMARK_HANDLE_INFO32) Irp->AssociatedIrp.SystemBuffer;
        LocalMarkHandleInfo.HandleInfo = MarkHandle32->HandleInfo;
        LocalMarkHandleInfo.UsnSourceInfo = MarkHandle32->UsnSourceInfo;
        LocalMarkHandleInfo.VolumeHandle = (HANDLE)(ULONG_PTR)(LONG) MarkHandle32->VolumeHandle;

        HandleInfo = &LocalMarkHandleInfo;

    } else {

#endif

    //
    //  Get the input buffer pointer and check its length.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < sizeof( MARK_HANDLE_INFO )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    HandleInfo = (PMARK_HANDLE_INFO) Irp->AssociatedIrp.SystemBuffer;

#if defined(_WIN64)
    }
#endif

    //
    //  Check that only legal bits are being set.  We currently only support certain bits in the
    //  UsnSource reasons.
    //

    if (FlagOn( HandleInfo->HandleInfo, ~(MARK_HANDLE_PROTECT_CLUSTERS)) ||
        FlagOn( HandleInfo->UsnSourceInfo,
                ~(USN_SOURCE_DATA_MANAGEMENT |
                  USN_SOURCE_AUXILIARY_DATA |
                  USN_SOURCE_REPLICATION_MANAGEMENT) )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Check that the user has a valid volume handle or the manage volume
    //  privilege or is a kerbel mode caller
    //
    //
    //  NOTE: the kernel mode check is only valid because the rdr doesn't support this
    //  FSCTL
    //

    if ((Irp->RequestorMode != KernelMode) && !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        if (HandleInfo->VolumeHandle == 0) {
            NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
            return STATUS_ACCESS_DENIED;
        }

        Status = ObReferenceObjectByHandle( HandleInfo->VolumeHandle,
                                            0,
                                            *IoFileObjectType,
                                            Irp->RequestorMode,
                                            &DasdFileObject,
                                            NULL );

        if (!NT_SUCCESS(Status)) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
            return Status;
        }

        //  Check that this file object is opened on the same volume as the
        //  handle used to call this routine.
        //

        if (DasdFileObject->Vpb != Vcb->Vpb) {

            ObDereferenceObject( DasdFileObject );

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Now decode this FileObject and verify it is a volume handle.
        //  We don't care to raise on dismounts here because
        //  we check for that further down anyway. So send FALSE.
        //

        TypeOfOpen = NtfsDecodeFileObject( IrpContext, DasdFileObject, &Vcb, &DasdFcb, &DasdScb, &DasdCcb, FALSE );

        ObDereferenceObject( DasdFileObject );

        if ((DasdCcb == NULL) || !FlagOn( DasdCcb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    //  Acquire the paging io resource exclusively if present.
    //

    if (Scb->Header.PagingIoResource != NULL) {
        NtfsAcquirePagingResourceExclusive( IrpContext, Scb, TRUE );
    }

    try {

        //
        //  Acquire the file exclusively to serialize changes to the Ccb.
        //

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        ReleaseScb = TRUE;

        //
        //  Verify the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Set these new bits in the Ccb.
        //

        if (FlagOn( HandleInfo->HandleInfo, MARK_HANDLE_PROTECT_CLUSTERS )) {

            //
            //  We can't deny defrag if anyone else already has
            //

            if (FlagOn( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG )) {
                Status = STATUS_ACCESS_DENIED;
                leave;
            }

            SetFlag( Ccb->Flags, CCB_FLAG_DENY_DEFRAG );
            SetFlag( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG );
        }
        SetFlag( Ccb->UsnSourceInfo, HandleInfo->UsnSourceInfo );

    } finally {

        DebugUnwind( NtfsMarkHandle );

        //
        //  Release the Scb.
        //

        if (ReleaseScb) {

            NtfsReleaseScb( IrpContext, Scb );
        }

        if (Scb->Header.PagingIoResource != NULL) {
            NtfsReleasePagingResource( IrpContext, Scb );
        }
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support routine
//

NTSTATUS
NtfsPrefetchFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to perform the requested prefetch on a system file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS MmStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    PFILE_PREFETCH FilePrefetch;
    PREAD_LIST ReadList = NULL;
    PULONGLONG NextFileId;
    ULONG Count;

    ULONGLONG FileOffset;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN ReleaseMft = FALSE;

    PAGED_CODE();

    //
    //  Always make this synchronous.  There isn't much advantage to posting this work to a
    //  worker thread.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ));

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We currently support this call only for the Mft (accessed through a volume handle).
    //

    if ((Ccb == NULL) || !FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Get the input buffer pointer and check its length.  It needs to be sufficient to
    //  contain the fixed portion of structure plus whatever optional fields passed in.
    //

    FilePrefetch = (PFILE_PREFETCH) Irp->AssociatedIrp.SystemBuffer;
    if (IrpSp->Parameters.FileSystemControl.InputBufferLength < FIELD_OFFSET( FILE_PREFETCH, Prefetch )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Make sure the type and cound fields are valid.
    //

    if ((FilePrefetch->Type != FILE_PREFETCH_TYPE_FOR_CREATE) ||
        (FilePrefetch->Count > 0x300)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Finally verify that the variable length data is of valid length.
    //

    if (IrpSp->Parameters.FileSystemControl.InputBufferLength <
        (FIELD_OFFSET( FILE_PREFETCH, Prefetch ) + (sizeof( ULONGLONG ) * FilePrefetch->Count))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  If the user didn't specify any entries we are done.
    //

    if (FilePrefetch->Count == 0) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Acquire the volume dasd file shared to do this.
    //

    NtfsAcquireSharedScb( IrpContext, Scb );

    try {

        //
        //  Verify the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Allocate the necessary pool to pass to MM.
        //

        ReadList = NtfsAllocatePool( PagedPool,
                                     FIELD_OFFSET( READ_LIST, List ) + (FilePrefetch->Count * sizeof( FILE_SEGMENT_ELEMENT )));

        //
        //  Initialize the read list.
        //

        ReadList->FileObject = Vcb->MftScb->FileObject;
        ASSERT( Vcb->MftScb->FileObject != NULL );

        ReadList->NumberOfEntries = 0;
        ReadList->IsImage = FALSE;

        //
        //  Walk through and load the list.  We won't bother to check sequence numbers
        //  as they don't really change the correctness of this call.  We do check for the
        //  valid length of the Mft though.
        //

        NtfsAcquireSharedScb( IrpContext, Vcb->MftScb );
        ReleaseMft = TRUE;

        NextFileId = &FilePrefetch->Prefetch[0];
        Count = FilePrefetch->Count;

        while (Count > 0) {

            FileOffset = NtfsFullSegmentNumber( NextFileId );
            FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

            //
            //  Round down to page boundary.  This will reduce the number of entries
            //  passed to MM.
            //

            FileOffset = BlockAlignTruncate( FileOffset, PAGE_SIZE );

            //
            //  Check if we are beyond the end of the Mft.  Treat this as a ULONGLONG
            //  so we can catch the case where the ID generates a negative number.
            //

            if (FileOffset >= (ULONGLONG) Vcb->MftScb->Header.ValidDataLength.QuadPart) {

                Status = STATUS_END_OF_FILE;

            //
            //  If not then add to the buffer to pass to mm.
            //

            } else {

                ULONG Index;

                //
                //  Position ourselves in the output array.  Look in reverse
                //  order in case our caller has already sorted this.
                //

                Index = ReadList->NumberOfEntries;

                while (Index != 0) {

                    //
                    //  If the prior entry is less than the current entry we are done.
                    //

                    if (ReadList->List[Index - 1].Alignment < FileOffset) {

                        break;
                    }

                    //
                    //  If the prior entry equals the current entry then skip it.
                    //

                    if (ReadList->List[Index - 1].Alignment == FileOffset) {

                        Index = MAXULONG;
                        break;
                    }

                    //
                    //  Move backwards to the previous entry.
                    //

                    Index -= 1;
                }

                //
                //  Index now points to the insert point, except if MAXULONG.  Insert the entry
                //  and shift any existing entries necessary if we are doing the insert.
                //

                if (Index != MAXULONG) {

                    if (Index != ReadList->NumberOfEntries) {

                        RtlMoveMemory( &ReadList->List[Index + 1],
                                       &ReadList->List[Index],
                                       sizeof( LONGLONG ) * (ReadList->NumberOfEntries - Index) );
                    }

                    ReadList->NumberOfEntries += 1;
                    ReadList->List[Index].Alignment = FileOffset;
                }
            }

            //
            //  Move to the next entry.
            //

            Count -= 1;
            NextFileId += 1;
        }

        //
        //  We're done with the Mft.  If we ever support shrinking the Mft we will have to close
        //  the hole here.
        //

        NtfsReleaseScb( IrpContext, Vcb->MftScb );
        ReleaseMft = FALSE;

        //
        //  Now call mm to do the IO.
        //

        if (ReadList->NumberOfEntries != 0) {

            MmStatus = MmPrefetchPages( 1, &ReadList );

            //
            //  Use the Mm status if we don't already have one.
            //

            if (Status == STATUS_SUCCESS) {

                Status = MmStatus;
            }
        }

    } finally {

        DebugUnwind( NtfsPrefetchFile );

        //
        //  Free the read list if allocated.
        //

        if (ReadList != NULL) {

            NtfsFreePool( ReadList );
        }

        //
        //  Release any Scb acquired.
        //

        if (ReleaseMft) {

            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

        NtfsReleaseScb( IrpContext, Scb );
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local Support routine
//

LONG
NtfsFsctrlExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN BOOLEAN AccessingUserData,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    Generic Exception filter for errors during fsctrl processing. Raise invalid user buffer
    directly or let it filter on to the top level try-except


Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    AccessingUserData - if false always let the exception filter up

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    *Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    if (!FsRtlIsNtstatusExpected( *Status ) && AccessingUserData) {

        NtfsMinimumExceptionProcessing( IrpContext );
        return EXCEPTION_EXECUTE_HANDLER;
    } else {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

#ifdef SYSCACHE_DEBUG

//
//  Local support routine
//

VOID
NtfsInitializeSyscacheLogFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine creates the syscache logfile in the root directory.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None.

--*/

{
    UNICODE_STRING AttrName;
    struct {
        FILE_NAME FileName;
        WCHAR FileNameChars[10];
    } FileNameAttr;
    FILE_REFERENCE FileReference;
    LONGLONG FileRecordOffset;
    PINDEX_ENTRY IndexEntry;
    PBCB FileRecordBcb = NULL;
    PBCB IndexEntryBcb = NULL;
    PBCB ParentSecurityBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    UCHAR FileNameFlags;
    BOOLEAN FoundEntry;
    PFCB Fcb = NULL;
    BOOLEAN AcquiredFcbTable = FALSE;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    ULONG DesiredAccess = GENERIC_READ | GENERIC_WRITE;
    NTSTATUS Status = STATUS_SUCCESS;

    NtfsAcquireExclusiveScb( IrpContext, Vcb->RootIndexScb );

    //
    //  Initialize the FileName.
    //

    RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
    FileNameAttr.FileName.ParentDirectory = Vcb->RootIndexScb->Fcb->FileReference;
    FileNameAttr.FileName.FileNameLength = (UCHAR)(9); // 9 unicode characters long
    RtlCopyMemory( FileNameAttr.FileName.FileName, L"$ntfs.log", 9 * sizeof( WCHAR ) );

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Does the file already exist?
        //

        FoundEntry = NtfsFindIndexEntry( IrpContext,
                                         Vcb->RootIndexScb,
                                         &FileNameAttr,
                                         FALSE,
                                         NULL,
                                         &IndexEntryBcb,
                                         &IndexEntry,
                                         NULL );

        //
        //  If we did not find it, then start creating the file.
        //

        if (!FoundEntry) {

            //
            //  We will now try to do all of the on-disk operations.  This means first
            //  allocating and initializing an Mft record.  After that we create
            //  an Fcb to use to access this record.
            //

            FileReference = NtfsAllocateMftRecord( IrpContext, Vcb, FALSE );

            //
            //  Pin the file record we need.
            //

            NtfsPinMftRecord( IrpContext,
                              Vcb,
                              &FileReference,
                              TRUE,
                              &FileRecordBcb,
                              &FileRecord,
                              &FileRecordOffset );

            //
            //  Initialize the file record header.
            //

            NtfsInitializeMftRecord( IrpContext,
                                     Vcb,
                                     &FileReference,
                                     FileRecord,
                                     FileRecordBcb,
                                     FALSE );

        //
        //  If we found the file, then just get its FileReference out of the
        //  IndexEntry.
        //

        } else {

            FileReference = IndexEntry->FileReference;
        }

        //
        //  Now that we know the FileReference, we can create the Fcb.
        //

        NtfsAcquireFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = TRUE;

        Fcb = NtfsCreateFcb( IrpContext,
                             Vcb,
                             FileReference,
                             FALSE,
                             FALSE,
                             NULL );

        //
        //  Reference the Fcb so it doesn't go away.
        //

        Fcb->ReferenceCount += 1;
        NtfsReleaseFcbTable( IrpContext, Vcb );
        AcquiredFcbTable = FALSE;

        //
        //  Acquire the main resource
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

        NtfsAcquireFcbTable( IrpContext, Vcb );
        Fcb->ReferenceCount -= 1;
        NtfsReleaseFcbTable( IrpContext, Vcb );

        //
        //  If we are creating this file, then carry on.
        //

        if (!FoundEntry) {

            BOOLEAN LogIt = FALSE;

            //
            //  Just copy the Security Id from the parent. (Load it first if necc.)
            //

            if (Vcb->RootIndexScb->Fcb->SharedSecurity == NULL) {
                NtfsLoadSecurityDescriptor( IrpContext, Vcb->RootIndexScb->Fcb );
            }

            NtfsAcquireFcbSecurity( Fcb->Vcb );
            Fcb->SecurityId = Vcb->RootIndexScb->Fcb->SecurityId;

            ASSERT( Fcb->SharedSecurity == NULL );
            Fcb->SharedSecurity = Vcb->RootIndexScb->Fcb->SharedSecurity;
            Fcb->SharedSecurity->ReferenceCount++;
            NtfsReleaseFcbSecurity( Fcb->Vcb );

            //
            //  The changes to make on disk are first to create a standard information
            //  attribute.  We start by filling the Fcb with the information we
            //  know and creating the attribute on disk.
            //

            NtfsInitializeFcbAndStdInfo( IrpContext,
                                         Fcb,
                                         FALSE,
                                         FALSE,
                                         FALSE,
                                         FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                                         NULL );

            //
            //  Now link the file into the $Extend directory.
            //

            NtfsAddLink( IrpContext,
                         TRUE,
                         Vcb->RootIndexScb,
                         Fcb,
                         (PFILE_NAME)&FileNameAttr,
                         &LogIt,
                         &FileNameFlags,
                         NULL,
                         NULL,
                         NULL );
/*

            //
            //  Set this flag to indicate that the file is to be locked via the Scb
            //  pointers in the Vcb.
            //

            SetFlag( FileRecord->Flags, FILE_SYSTEM_FILE );

*/

            //
            //  Log the file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            FileRecordBcb,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            FileRecordOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

        //
        //  Verify that the file record for this file is valid.
        //

        } else {

            ULONG CorruptHint;

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $STANDARD_INFORMATION,
                                            &Context ) ||

                !NtfsCheckFileRecord( Vcb, NtfsContainingFileRecord( &Context ), &Fcb->FileReference, &CorruptHint )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &Fcb->FileReference, NULL );
            }
        }

        //
        //  Update Fcb fields from disk.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_SYSTEM_FILE );
        NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, Fcb, NULL );

        //
        //  Open/Create the data stream
        //

        memset( &AttrName, 0, sizeof( AttrName ) );

        NtOfsCreateAttribute( IrpContext,
                              Fcb,
                              AttrName,
                              CREATE_OR_OPEN,
                              FALSE,
                              &Vcb->SyscacheScb );

        RtlMapGenericMask( &DesiredAccess, IoGetFileObjectGenericMapping() );
        IoSetShareAccess( DesiredAccess, FILE_SHARE_READ, Vcb->SyscacheScb->FileObject, &Vcb->SyscacheScb->ShareAccess );

        do {

            if (STATUS_LOG_FILE_FULL == Status) {

                NtfsCleanCheckpoint( IrpContext->Vcb );
                Status = STATUS_SUCCESS;
            }

            try {
                LONGLONG Length = PAGE_SIZE * 0x1d00; // approx 30mb

                NtOfsSetLength( IrpContext, Vcb->SyscacheScb, Length );

                //
                //  Make this look like it came from a write so ioateof is not done
                //  we must do a writefilesizes to update VDL by hand
                //

                SetFlag( IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN );
                NtfsZeroData( IrpContext, Vcb->SyscacheScb, Vcb->SyscacheScb->FileObject, 0, Length, NULL );
                NtfsWriteFileSizes( IrpContext, Vcb->SyscacheScb, &Vcb->SyscacheScb->Header.ValidDataLength.QuadPart, TRUE, TRUE, TRUE );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                  Status = GetExceptionCode();
                  ASSERT( Status == STATUS_DISK_FULL || Status == STATUS_LOG_FILE_FULL );

                  NtfsMinimumExceptionProcessing( IrpContext );
                  IrpContext->ExceptionStatus = 0;
            }

            ClearFlag(IrpContext->TopLevelIrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_SEEN);
            NtfsReleaseScb( IrpContext, Vcb->SyscacheScb );

        } while ( STATUS_LOG_FILE_FULL == Status   );

        //
        //  Increment cleanup counts to enforce the sharing we set up
        //

        NtfsIncrementCleanupCounts( Vcb->SyscacheScb, NULL, FALSE );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsUnpinBcb( IrpContext, &FileRecordBcb );
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );
        NtfsUnpinBcb( IrpContext, &ParentSecurityBcb );

        //
        //  On any kind of error, nuke the Fcb.
        //

        if (AbnormalTermination()) {

            //
            //  If some error caused us to abort, then delete
            //  the Fcb, because we are the only ones who will.
            //

            if (Fcb) {

                if (!AcquiredFcbTable) {

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;
                }
                NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                ASSERT(!AcquiredFcbTable);
            }

            if (AcquiredFcbTable) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
            }
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fileinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the set and query file information routines for Ntfs
    called by the dispatch driver.

Author:

    Brian Andrew    [BrianAn]       15-Jan-1992

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_FILEINFO)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('FFtN')

#define SIZEOF_FILE_NAME_INFORMATION (FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0]) \
                                      + sizeof( WCHAR ))

//
//  Local flags for rename and set link
//

#define TRAVERSE_MATCH              (0x00000001)
#define EXACT_CASE_MATCH            (0x00000002)
#define ACTIVELY_REMOVE_SOURCE_LINK (0x00000004)
#define REMOVE_SOURCE_LINK          (0x00000008)
#define REMOVE_TARGET_LINK          (0x00000010)
#define ADD_TARGET_LINK             (0x00000020)
#define REMOVE_TRAVERSE_LINK        (0x00000040)
#define REUSE_TRAVERSE_LINK         (0x00000080)
#define MOVE_TO_NEW_DIR             (0x00000100)
#define ADD_PRIMARY_LINK            (0x00000200)
#define OVERWRITE_SOURCE_LINK       (0x00000400)

//
//  Additional local flags for set link
//

#define CREATE_IN_NEW_DIR           (0x00000400)

//
//  Local procedure prototypes
//

//
//  VOID
//  NtfsBuildLastFileName (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFILE_OBJECT FileObject,
//      IN ULONG FileNameOffset,
//      OUT PUNICODE_STRING FileName
//      );
//

#define NtfsBuildLastFileName(IC,FO,OFF,FN) {                           \
    (FN)->MaximumLength = (FN)->Length = (FO)->FileName.Length - OFF;   \
    (FN)->Buffer = (PWSTR) Add2Ptr( (FO)->FileName.Buffer, OFF );       \
}

VOID
NtfsQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb OPTIONAL
    );

VOID
NtfsQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryAttributeTagInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PFILE_ATTRIBUTE_TAG_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb
    );

NTSTATUS
NtfsQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryStreamsInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STREAM_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsQueryCompressedFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
NtfsQueryNetworkOpenInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NtfsSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    );

NTSTATUS
NtfsSetLinkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    );

NTSTATUS
NtfsSetShortNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb
    );

NTSTATUS
NtfsSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL,
    IN BOOLEAN VcbAcquired
    );

NTSTATUS
NtfsSetValidDataLengthInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsCheckScbForLinkRemoval (
    IN PSCB Scb,
    OUT PSCB *BatchOplockScb,
    OUT PULONG BatchOplockCount
    );

VOID
NtfsFindTargetElements (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT TargetFileObject,
    IN PSCB ParentScb,
    OUT PSCB *TargetParentScb,
    OUT PUNICODE_STRING FullTargetFileName,
    OUT PUNICODE_STRING TargetFileName
    );

BOOLEAN
NtfsCheckLinkForNewLink (
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING NewLinkName,
    OUT PULONG LinkFlags
    );

VOID
NtfsCheckLinkForRename (
    IN PFCB Fcb,
    IN PLCB Lcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING TargetFileName,
    IN BOOLEAN IgnoreCase,
    IN OUT PULONG RenameFlags
    );

VOID
NtfsCleanupLinkForRemoval (
    IN PFCB PreviousFcb,
    IN PSCB ParentScb,
    IN BOOLEAN ExistingFcb
    );

VOID
NtfsUpdateFcbFromLinkRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN UNICODE_STRING FileName,
    IN UCHAR FileNameFlags
    );

VOID
NtfsReplaceLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR FileNameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    );

VOID
NtfsMoveLinkToNewDir (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NewFullLinkName,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR NewLinkNameFlags,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    );

VOID
NtfsRenameLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR FileNameFlags,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    );

VOID
NtfsUpdateFileDupInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb OPTIONAL
    );

NTSTATUS
NtfsStreamRename(
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN BOOLEAN ReplaceIfExists,
    IN PUNICODE_STRING NewStreamName
    );

NTSTATUS
NtfsPrepareToShrinkFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    LONGLONG NewFileSize
    );

NTSTATUS
NtfsCheckTreeForBatchOplocks (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB DirectoryScb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCheckLinkForNewLink)
#pragma alloc_text(PAGE, NtfsCheckLinkForRename)
#pragma alloc_text(PAGE, NtfsCheckScbForLinkRemoval)
#pragma alloc_text(PAGE, NtfsCheckTreeForBatchOplocks)
#pragma alloc_text(PAGE, NtfsCleanupLinkForRemoval)
#pragma alloc_text(PAGE, NtfsCommonQueryInformation)
#pragma alloc_text(PAGE, NtfsCommonSetInformation)
#pragma alloc_text(PAGE, NtfsFindTargetElements)
#pragma alloc_text(PAGE, NtfsMoveLinkToNewDir)
#pragma alloc_text(PAGE, NtfsPrepareToShrinkFileSize)
#pragma alloc_text(PAGE, NtfsQueryAlternateNameInfo)
#pragma alloc_text(PAGE, NtfsQueryBasicInfo)
#pragma alloc_text(PAGE, NtfsQueryEaInfo)
#pragma alloc_text(PAGE, NtfsQueryAttributeTagInfo)
#pragma alloc_text(PAGE, NtfsQueryInternalInfo)
#pragma alloc_text(PAGE, NtfsQueryNameInfo)
#pragma alloc_text(PAGE, NtfsQueryPositionInfo)
#pragma alloc_text(PAGE, NtfsQueryStandardInfo)
#pragma alloc_text(PAGE, NtfsQueryStreamsInfo)
#pragma alloc_text(PAGE, NtfsQueryCompressedFileSize)
#pragma alloc_text(PAGE, NtfsQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, NtfsRenameLinkInDir)
#pragma alloc_text(PAGE, NtfsReplaceLinkInDir)
#pragma alloc_text(PAGE, NtfsSetAllocationInfo)
#pragma alloc_text(PAGE, NtfsSetBasicInfo)
#pragma alloc_text(PAGE, NtfsSetDispositionInfo)
#pragma alloc_text(PAGE, NtfsSetEndOfFileInfo)
#pragma alloc_text(PAGE, NtfsSetLinkInfo)
#pragma alloc_text(PAGE, NtfsSetPositionInfo)
#pragma alloc_text(PAGE, NtfsSetRenameInfo)
#pragma alloc_text(PAGE, NtfsSetShortNameInfo)
#pragma alloc_text(PAGE, NtfsSetValidDataLengthInfo)
#pragma alloc_text(PAGE, NtfsStreamRename)
#pragma alloc_text(PAGE, NtfsUpdateFcbFromLinkRemoval)
#pragma alloc_text(PAGE, NtfsUpdateFileDupInfo)
#endif


NTSTATUS
NtfsFsdSetInformation (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of set file information.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ULONG LogFileFullCount = 0;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    DebugTrace( +1, Dbg, ("NtfsFsdSetInformation\n") );

    //
    //  Call the common set Information routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );

                LogFileFullCount += 1;

                if (LogFileFullCount >= 2) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                }
            }

            Status = NtfsCommonSetInformation( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NTSTATUS ExceptionCode;
            PIO_STACK_LOCATION IrpSp;

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            ExceptionCode = GetExceptionCode();

            if ((ExceptionCode == STATUS_FILE_DELETED) &&
                (IrpSp->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation)) {

                IrpContext->ExceptionStatus = ExceptionCode = STATUS_SUCCESS;
            }

            Status = NtfsProcessException( IrpContext, Irp, ExceptionCode );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdSetInformation -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonQueryInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN FsRtlHeaderLocked = FALSE;
    PFILE_ALL_INFORMATION AllInfo;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryInformation\n") );
    DebugTrace( 0, Dbg, ("IrpContext           = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                  = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length               = %08lx\n", IrpSp->Parameters.QueryFile.Length) );
    DebugTrace( 0, Dbg, ("FileInformationClass = %08lx\n", IrpSp->Parameters.QueryFile.FileInformationClass) );
    DebugTrace( 0, Dbg, ("Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {

        case UserVolumeOpen:

            //
            //  We cannot query the user volume open.
            //

            Status = STATUS_INVALID_PARAMETER;
            break;

        case UserFileOpen:
        case UserDirectoryOpen:
        case UserViewIndexOpen:

            if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                //
                //  We don't allow this operation on with open by file id.
                //

                if ((Ccb->Lcb == NULL) &&
                    (FileInformationClass == FileAlternateNameInformation)) {

                    Status = STATUS_INVALID_PARAMETER;
                    break;

                } else if ((FileInformationClass == FileAllInformation) ||
                           (FileInformationClass == FileNameInformation)) {

                    if (FlagOn( Ccb->Flags, CCB_FLAG_TRAVERSE_CHECK )) {

                        //
                        //  If this file was opened by Id by a user without traversal privilege,
                        //  we can't return any info level that includes a file or path name
                        //  unless this open is relative to a directory by file id.
                        //  Look at the file name in the Ccb in that case.  We'll return
                        //  only that portion of the name.
                        //
                        if (Ccb->FullFileName.MaximumLength == 0) {

                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }

                    //
                    //  We'll need to hold the Vcb exclusively through the filename
                    //  synthesis, since it walks up the directory tree.
                    //

                    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
                    VcbAcquired = TRUE;
                }
            }

        //
        //  Deliberate fall through to StreamFileOpen case.
        //

        case StreamFileOpen:

            //
            //  Acquire the Vcb if there is no Ccb.  This is for the
            //  case where the cache manager is querying the name.
            //

            if (Ccb == NULL) {

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                VcbAcquired = TRUE;
            }

            if ((Scb->Header.PagingIoResource != NULL) &&

                ((FileInformationClass == FileAllInformation) ||
                 (FileInformationClass == FileStandardInformation) ||
                 (FileInformationClass == FileCompressionInformation) ||
                 (FileInformationClass == FileNetworkOpenInformation))) {

                ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );

                FsRtlLockFsRtlHeader( &Scb->Header );
                FsRtlHeaderLocked = TRUE;
            }

            NtfsAcquireSharedFcb( IrpContext, Fcb, Scb, 0 );
            FcbAcquired = TRUE;

            //
            //  Fail this request if the volume has been dismounted.
            //  System files may not have the scbstate flag set - so we test the vcb as well
            //  Holding any file's main resource lets us test the vcb since we call acquireallfiles
            //  before doing a dismount
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) ||
                !FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
            }

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  For the all information class we'll typecast a local
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                AllInfo = Buffer;
                Length -= (sizeof(FILE_ACCESS_INFORMATION)
                           + sizeof(FILE_MODE_INFORMATION)
                           + sizeof(FILE_ALIGNMENT_INFORMATION));

                NtfsQueryBasicInfo(    IrpContext, FileObject, Scb, &AllInfo->BasicInformation,    &Length );
                NtfsQueryStandardInfo( IrpContext, FileObject, Scb, &AllInfo->StandardInformation, &Length, Ccb );
                NtfsQueryInternalInfo( IrpContext, FileObject, Scb, &AllInfo->InternalInformation, &Length );
                NtfsQueryEaInfo(       IrpContext, FileObject, Scb, &AllInfo->EaInformation,       &Length );
                NtfsQueryPositionInfo( IrpContext, FileObject, Scb, &AllInfo->PositionInformation, &Length );
                Status =
                NtfsQueryNameInfo(     IrpContext, FileObject, Scb, &AllInfo->NameInformation,     &Length, Ccb );
                break;

            case FileBasicInformation:

                NtfsQueryBasicInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileStandardInformation:

                NtfsQueryStandardInfo( IrpContext, FileObject, Scb, Buffer, &Length, Ccb );
                break;

            case FileInternalInformation:

                NtfsQueryInternalInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileEaInformation:

                NtfsQueryEaInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileAttributeTagInformation:

                NtfsQueryAttributeTagInfo( IrpContext, FileObject, Scb, Ccb, Buffer, &Length );
                break;

            case FilePositionInformation:

                NtfsQueryPositionInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            case FileNameInformation:

                Status = NtfsQueryNameInfo( IrpContext, FileObject, Scb, Buffer, &Length, Ccb );
                break;

            case FileAlternateNameInformation:

                Status = NtfsQueryAlternateNameInfo( IrpContext, Scb, Ccb->Lcb, Buffer, &Length );
                break;

            case FileStreamInformation:

                Status = NtfsQueryStreamsInfo( IrpContext, Fcb, Buffer, &Length );
                break;

            case FileCompressionInformation:

                Status = NtfsQueryCompressedFileSize( IrpContext, Scb, Buffer, &Length );
                break;

            case FileNetworkOpenInformation:

                NtfsQueryNetworkOpenInfo( IrpContext, FileObject, Scb, Buffer, &Length );
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

        //
        //  Abort transaction on error by raising.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonQueryInformation );

        if (FsRtlHeaderLocked) {
            FsRtlUnlockFsRtlHeader( &Scb->Header );
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        if (FcbAcquired) { NtfsReleaseFcb( IrpContext, Fcb ); }
        if (VcbAcquired) { NtfsReleaseVcb( IrpContext, Vcb ); }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonQueryInformation -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN ReleaseScbPaging = FALSE;
    BOOLEAN LazyWriterCallback = FALSE;
    ULONG WaitState;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetInformation\n") );
    DebugTrace( 0, Dbg, ("IrpContext           = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                  = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("Length               = %08lx\n", IrpSp->Parameters.SetFile.Length) );
    DebugTrace( 0, Dbg, ("FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass) );
    DebugTrace( 0, Dbg, ("FileObject           = %08lx\n", IrpSp->Parameters.SetFile.FileObject) );
    DebugTrace( 0, Dbg, ("ReplaceIfExists      = %08lx\n", IrpSp->Parameters.SetFile.ReplaceIfExists) );
    DebugTrace( 0, Dbg, ("Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  We can reject volume opens immediately.
    //

    if (TypeOfOpen == UserVolumeOpen ||
        TypeOfOpen == UnopenedFileObject ||
        TypeOfOpen == UserViewIndexOpen ||
        ((TypeOfOpen != UserFileOpen) &&
         (FileInformationClass == FileValidDataLengthInformation))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonSetInformation -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );

        DebugTrace( -1, Dbg, ("NtfsCommonSetInformation -> STATUS_MEDIA_WRITE_PROTECTED\n") );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    try {

        //
        //  The typical path here is for the lazy writer callback.  Go ahead and
        //  remember this first.
        //

        if (FileInformationClass == FileEndOfFileInformation) {

            LazyWriterCallback = IrpSp->Parameters.SetFile.AdvanceOnly;
        }

        //
        //  Perform the oplock check for changes to allocation or EOF if called
        //  by the user.
        //

        if (!LazyWriterCallback &&
            ((FileInformationClass == FileEndOfFileInformation) ||
             (FileInformationClass == FileAllocationInformation) ||
             (FileInformationClass == FileValidDataLengthInformation)) &&
            (TypeOfOpen == UserFileOpen) &&
            !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

            //
            //  We check whether we can proceed based on the state of the file oplocks.
            //  This call might block this request.
            //

            Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NULL,
                                       NULL );

            if (Status != STATUS_SUCCESS) {

                try_return( NOTHING );
            }

            //
            //  Update the FastIoField.
            //

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );
        }

        //
        //  If this call is for EOF then we need to acquire the Vcb if we may
        //  have to perform an update duplicate call.  Don't block waiting for
        //  the Vcb in the Valid data callback case.
        //  We don't want to block the lazy write threads in the clean checkpoint
        //  case.
        //

        switch (FileInformationClass) {

        case FileEndOfFileInformation:

            //
            //  If this is not a system file then we will need to update duplicate info.
            //

            if (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                WaitState = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                //
                //  Only acquire the Vcb for the Lazy writer if we know the file size in the Fcb
                //  is out of date or can compare the Scb with that in the Fcb.  An unsafe comparison
                //  is OK because if they are changing then someone else can do the work.
                //  We also want to update the duplicate information if the total allocated
                //  has changed and there are no user handles remaining to perform the update.
                //

                if (LazyWriterCallback) {

                    if ((FlagOn( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE ) ||
                         ((Scb->Header.FileSize.QuadPart != Fcb->Info.FileSize) &&
                          FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ))) ||
                        (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                         (Scb->CleanupCount == 0) &&
                         (Scb->ValidDataToDisk >= Scb->Header.ValidDataLength.QuadPart) &&
                         (FlagOn( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE ) ||
                          (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) &&
                           (Scb->TotalAllocated != Fcb->Info.AllocatedLength))))) {

                        //
                        //  Go ahead and try to acquire the Vcb without waiting.
                        //

                        if (NtfsAcquireSharedVcb( IrpContext, Vcb, FALSE )) {

                            VcbAcquired = TRUE;

                        } else {

                            SetFlag( IrpContext->State, WaitState );

                            //
                            //  If we could not get the Vcb for any reason then return.  Let's
                            //  not block an essential thread waiting for the Vcb.  Typically
                            //  we will only be blocked during a clean checkpoint.  The Lazy
                            //  Writer will periodically come back and retry this call.
                            //

                            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                        }
                    }

                //
                //  Otherwise we always want to wait for the Vcb except if we were called from
                //  MM extending a section.  We will try to get this without waiting and test
                //  if called from MM if unsuccessful.
                //

                } else {

                    if (NtfsAcquireSharedVcb( IrpContext, Vcb, FALSE )) {

                        VcbAcquired = TRUE;

                    } else if ((Scb->Header.PagingIoResource == NULL) ||
                               !NtfsIsExclusiveScbPagingIo( Scb )) {

                        SetFlag( IrpContext->State, WaitState );

                        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                        VcbAcquired = TRUE;
                    }
                }

                SetFlag( IrpContext->State, WaitState );
            }

            break;
        //
        //  Acquire the Vcb shared for changes to allocation or basic
        //  information.
        //

        case FileAllocationInformation:
        case FileBasicInformation:
        case FileDispositionInformation:

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            VcbAcquired = TRUE;

            break;

        //
        //  If this is a rename or link operation then we need to make sure
        //  we have the user's context and acquire the Vcb.
        //

        case FileRenameInformation:
        case FileLinkInformation:

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_SECURITY )) {

                IrpContext->Union.SubjectContext = NtfsAllocatePool( PagedPool,
                                                                      sizeof( SECURITY_SUBJECT_CONTEXT ));

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_SECURITY );

                SeCaptureSubjectContext( IrpContext->Union.SubjectContext );
            }

            //  Fall thru

        //
        //  For the two above plus the shortname we might need the Vcb exclusive for either directories
        //  or possible deadlocks.
        //

        case FileShortNameInformation:

            if (IsDirectory( &Fcb->Info )) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
            }

            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

            } else {

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
            }

            VcbAcquired = TRUE;

            break;

        default:

            NOTHING;
        }

        //
        //  The Lazy Writer must still synchronize with Eof to keep the
        //  stream sizes from changing.  This will be cleaned up when we
        //  complete.
        //

        if (LazyWriterCallback) {

            //
            //  Acquire either the paging io resource shared to serialize with
            //  the flush case where the main resource is acquired before IoAtEOF
            //

            if (Scb->Header.PagingIoResource != NULL) {

                ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
                ReleaseScbPaging = TRUE;
            }

            FsRtlLockFsRtlHeader( &Scb->Header );
            IrpContext->CleanupStructure = Scb;

        //
        //  Anyone potentially shrinking/deleting allocation must get the paging I/O
        //  resource first.  Special cases are the rename path and SetBasicInfo.  The
        //  rename path to lock the mapped page writer out of this file for deadlock
        //  prevention.  SetBasicInfo since we may call WriteFileSizes and we
        //  don't want to bump up the file size on disk from the value in the Scb
        //  if a write to EOF is underway.
        //

        } else if ((Scb->Header.PagingIoResource != NULL) &&
                   ((FileInformationClass == FileEndOfFileInformation) ||
                    (FileInformationClass == FileAllocationInformation) ||
                    (FileInformationClass == FileRenameInformation) ||
                    (FileInformationClass == FileBasicInformation) ||
                    (FileInformationClass == FileLinkInformation) ||
                    (FileInformationClass == FileValidDataLengthInformation))) {

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
        }

        //
        //  Acquire exclusive access to the Fcb,  We use exclusive
        //  because it is probable that one of the subroutines
        //  that we call will need to monkey with file allocation,
        //  create/delete extra fcbs.  So we're willing to pay the
        //  cost of exclusive Fcb access.
        //

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );

        //
        //  Make sure the Scb state test we're about to do is properly synchronized.
        //  There's no point in testing the SCB_STATE_VOLUME_DISMOUNTED flag below
        //  if the volume can still get dismounted below us during this operation.
        //

        ASSERT( NtfsIsExclusiveScb( Scb ) || NtfsIsSharedScb( Scb ) );

        //
        //  The lazy writer callback is the only caller who can get this far if the
        //  volume has been dismounted.  We know that there are no user handles or
        //  writeable file objects or dirty pages.  Make one last check to see
        //  if this stream is on a dismounted or locked volume. Note the
        //  vcb tests are unsafe
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) ||
            FlagOn( Vcb->VcbState, VCB_STATE_LOCK_IN_PROGRESS ) ||
           !(FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ))) {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Based on the information class we'll do different
        //  actions.  We will perform checks, when appropriate
        //  to insure that the requested operation is allowed.
        //

        switch (FileInformationClass) {

        case FileBasicInformation:

            Status = NtfsSetBasicInfo( IrpContext, FileObject, Irp, Scb, Ccb );
            break;

        case FileDispositionInformation:

            Status = NtfsSetDispositionInfo( IrpContext, FileObject, Irp, Scb, Ccb );
            break;

        case FileRenameInformation:

            Status = NtfsSetRenameInfo( IrpContext, FileObject, Irp, Vcb, Scb, Ccb, &VcbAcquired );
            break;

        case FilePositionInformation:

            Status = NtfsSetPositionInfo( IrpContext, FileObject, Irp, Scb );
            break;

        case FileLinkInformation:

            Status = NtfsSetLinkInfo( IrpContext, Irp, Vcb, Scb, Ccb, &VcbAcquired );
            break;

        case FileAllocationInformation:

            if (TypeOfOpen == UserDirectoryOpen ||
                TypeOfOpen == UserViewIndexOpen) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = NtfsSetAllocationInfo( IrpContext, FileObject, Irp, Scb, Ccb );
            }

            break;

        case FileEndOfFileInformation:

            if (TypeOfOpen == UserDirectoryOpen ||
                TypeOfOpen == UserViewIndexOpen) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = NtfsSetEndOfFileInfo( IrpContext, FileObject, Irp, Scb, Ccb, VcbAcquired );
            }

            break;

        case FileValidDataLengthInformation:

            Status = NtfsSetValidDataLengthInfo( IrpContext, Irp, Scb, Ccb );
            break;

        case FileShortNameInformation:

            //
            //  Disallow setshortname on the root - its meaningless anyway
            //

            if (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Status = NtfsSetShortNameInfo( IrpContext, FileObject, Irp, Vcb, Scb, Ccb );
            }
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Abort transaction on error by raising.
        //

        if (Status != STATUS_PENDING) {

            NtfsCleanupTransaction( IrpContext, Status, FALSE );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsCommonSetInformation );

        //
        //  Release the paging io resource if acquired shared.
        //

        if (ReleaseScbPaging) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        if (VcbAcquired) {

            NtfsReleaseVcb( IrpContext, Vcb );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonSetInformation -> %08lx\n", Status) );
    }

    //
    //  Complete the request unless it is being done in the oplock
    //  package.
    //

    if (Status != STATUS_PENDING) {
        NtfsCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query basic information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryBasicInfo...\n") );

    //
    //  Update the length used.
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    //
    //  Copy over the time information
    //

    NtfsFillBasicInfo( Buffer, Scb );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryBasicInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine performs the query standard information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Ccb - Optionally supplies the ccb for the opened file object.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryStandardInfo...\n") );

    //
    //  Update the length field.
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    //
    //  If the Scb is uninitialized, we initialize it now.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
        (Scb->AttributeTypeCode != $INDEX_ALLOCATION)) {

        DebugTrace( 0, Dbg, ("Initializing Scb  ->  %08lx\n", Scb) );
        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    //
    //  Call the common routine to fill the output buffer.
    //

    NtfsFillStandardInfo( Buffer, Scb, Ccb );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryStandardInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryInternalInfo...\n") );

    RtlZeroMemory( Buffer, sizeof(FILE_INTERNAL_INFORMATION) );

    *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    //
    //  Copy over the entire file reference including the sequence number
    //

    Buffer->IndexNumber = *(PLARGE_INTEGER)&Scb->Fcb->FileReference;

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryInternalInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query EA information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryEaInfo...\n") );

    RtlZeroMemory( Buffer, sizeof(FILE_EA_INFORMATION) );

    *Length -= sizeof( FILE_EA_INFORMATION );

    //
    //  EAs and reparse points cannot both be in a file at the same
    //  time. We return different information for each case.
    //

    if (FlagOn( Scb->Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {

        Buffer->EaSize = 0;

    } else {

        Buffer->EaSize = Scb->Fcb->Info.PackedEaSize;

        //
        //  Add 4 bytes for the CbListHeader.
        //

        if (Buffer->EaSize != 0) {

            Buffer->EaSize += 4;
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryEaInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryAttributeTagInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PFILE_ATTRIBUTE_TAG_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query of attributes and tag information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PFCB Fcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryAttributeTagInfo...\n") );

    Fcb = Scb->Fcb;

    //
    //  Zero the output buffer and update the length.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_ATTRIBUTE_TAG_INFORMATION) );

    *Length -= sizeof( FILE_ATTRIBUTE_TAG_INFORMATION );

    //
    // Load the file attributes as in NtfsQueryBasicInfo.
    //
    //  For the file attribute information if the flags in the attribute are zero then we
    //  return the file normal attribute otherwise we return the mask of the set attribute
    //  bits.  Note that only the valid attribute bits are returned to the user.
    //

    Buffer->FileAttributes = Fcb->Info.FileAttributes;

    ClearFlag( Buffer->FileAttributes,
               (~FILE_ATTRIBUTE_VALID_FLAGS |
                FILE_ATTRIBUTE_TEMPORARY |
                FILE_ATTRIBUTE_SPARSE_FILE |
                FILE_ATTRIBUTE_ENCRYPTED) );

    //
    //  Pick up the sparse bit for this stream from the Scb.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
    }

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
    }

    //
    //  If this is the main steam then the compression flag is correct but
    //  we need to test if this is a directory.
    //

    if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
        }

    //
    //  If this is not the main stream on the file then use the stream based
    //  compressed bit.
    //

    } else {

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );

        } else {

            ClearFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }
    }

    //
    //  If the temporary flag is set, then return it to the caller.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If there are no flags set then explicitly set the NORMAL flag.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    //
    //  Load the reparse point tag.
    //  As EAs and reparse points cannot both be in a file at the same time, we return
    //  the appropriate information for each case.
    //

    if (FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT)) {

        Buffer->ReparseTag = Fcb->Info.ReparsePointTag;

    } else {

        Buffer->ReparseTag = IO_REPARSE_TAG_RESERVED_ZERO;
    }

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryAttributeTagInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryPositionInfo...\n") );

    RtlZeroMemory( Buffer, sizeof(FILE_POSITION_INFORMATION) );

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryPositionInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query name information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

    Ccb - This is the Ccb for this file object.  If NULL then this request
        is from the Lazy Writer.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
        STATUS_BUFFER_OVERFLOW otherwise.

--*/

{
    ULONG BytesToCopy;
    NTSTATUS Status;
    UNICODE_STRING NormalizedName;
    PUNICODE_STRING SourceName;
    ULONG AvailableNameLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryNameInfo...\n") );

    NormalizedName.Buffer = NULL;

    //
    //  Reduce the buffer length by the size of the fixed part of the structure.
    //

    RtlZeroMemory( Buffer, SIZEOF_FILE_NAME_INFORMATION );

    *Length -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    //
    //  If the name length in this file object is zero, then we try to
    //  construct the name with the Lcb chain.  This means we have been
    //  called by the system for a lazy write that failed.
    //

    if (Ccb == NULL) {

        FILE_REFERENCE FileReference;

        NtfsSetSegmentNumber( &FileReference, 0, UPCASE_TABLE_NUMBER );

        //
        //  If this is a system file with a known name then just use our constant names.
        //

        if (NtfsLeqMftRef( &Scb->Fcb->FileReference, &FileReference )) {

            SourceName =
                (PUNICODE_STRING) &NtfsSystemFiles[ Scb->Fcb->FileReference.SegmentNumberLowPart ];

        } else {

            NtfsBuildNormalizedName( IrpContext, Scb->Fcb, FALSE, &NormalizedName );
            SourceName = &NormalizedName;
        }

    } else {

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
            !FlagOn( Ccb->Flags, CCB_FLAG_TRAVERSE_CHECK)) {

            //
            //  If the file was opened by id, the Ccb doesn't
            //  have a full file name in it.
            //

            NtfsBuildNormalizedName( IrpContext, Scb->Fcb, FALSE, &NormalizedName );
            SourceName = &NormalizedName;

        } else {

            //
            //  Use the name in the Ccb.  This may be a relative name for
            //  some of the open by ID relative cases.
            //

            SourceName = &Ccb->FullFileName;
        }
    }

    Buffer->FileNameLength = SourceName->Length;

    if ((Scb->AttributeName.Length != 0) &&
        NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

        Buffer->FileNameLength += sizeof( WCHAR ) + Scb->AttributeName.Length;
    }

    //
    //  Figure out how many bytes we can copy.
    //

    AvailableNameLength = Buffer->FileNameLength;

    if (*Length >= Buffer->FileNameLength) {

        Status = STATUS_SUCCESS;

    } else {

        //
        //  If we don't have enough for the entire buffer then make sure we only
        //  return full characters (characters are UNICODE).
        //

        Status = STATUS_BUFFER_OVERFLOW;
        AvailableNameLength = *Length & 0xfffffffe;
    }

    //
    //  Update the Length
    //

    *Length -= AvailableNameLength;

    //
    //  Copy over the file name
    //

    if (SourceName->Length <= AvailableNameLength) {

        BytesToCopy = SourceName->Length;

    } else {

        BytesToCopy = AvailableNameLength;
    }

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->FileName[0],
                       SourceName->Buffer,
                       BytesToCopy );
    }

    BytesToCopy = AvailableNameLength - BytesToCopy;

    if (BytesToCopy) {

        PWCHAR DestBuffer;

        DestBuffer = (PWCHAR) Add2Ptr( &Buffer->FileName, SourceName->Length );

        *DestBuffer = L':';
        DestBuffer += 1;

        BytesToCopy -= sizeof( WCHAR );

        if (BytesToCopy) {

            RtlCopyMemory( DestBuffer,
                           Scb->AttributeName.Buffer,
                           BytesToCopy );
        }
    }

    if ((SourceName == &NormalizedName) &&
        (SourceName->Buffer != NULL)) {

        NtfsFreePool( SourceName->Buffer );
    }

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryNameInfo -> 0x%8lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query alternate name information function.
    We will return the alternate name as long as this opener has opened
    a primary link.  We don't return the alternate name if the user
    has opened a hard link because there is no reason to expect that
    the primary link has any relationship to a hard link.

Arguments:

    Scb - Supplies the Scb being queried

    Lcb - Supplies the link the user traversed to open this file.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    ****    We need a status code for the case where there is no alternate name
            or the caller isn't allowed to see it.

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
        STATUS_OBJECT_NAME_NOT_FOUND if we can't return the name,
        STATUS_BUFFER_OVERFLOW otherwise.

        ****    A code like STATUS_NAME_NOT_FOUND would be good.

--*/

{
    ULONG BytesToCopy;
    NTSTATUS Status;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN MoreToGo;

    UNICODE_STRING AlternateName;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_LCB( Lcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryAlternateNameInfo...\n") );

    //
    //  If the Lcb is not a primary link we can return immediately.
    //

    if (!FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

        DebugTrace( -1, Dbg, ("NtfsQueryAlternateNameInfo:  Lcb not a primary link\n") );
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Reduce the buffer length by the size of the fixed part of the structure.
    //

    if (*Length < SIZEOF_FILE_NAME_INFORMATION ) {

        *Length = 0;
        NtfsRaiseStatus( IrpContext, STATUS_BUFFER_OVERFLOW, NULL, NULL );
    }

    RtlZeroMemory( Buffer, SIZEOF_FILE_NAME_INFORMATION );

    *Length -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to cleanup the attribut structure if we need it.
    //

    try {

        //
        //  We can special case for the case where the name is in the Lcb.
        //

        if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS )) {

            AlternateName = Lcb->ExactCaseLink.LinkName;

        } else {

            //
            //  We will walk through the file record looking for a file name
            //  attribute with the 8.3 bit set.  It is not guaranteed to be
            //  present.
            //

            MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                                  Scb->Fcb,
                                                  &Scb->Fcb->FileReference,
                                                  $FILE_NAME,
                                                  &AttrContext );

            while (MoreToGo) {

                PFILE_NAME FileName;

                FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                //
                //  See if the 8.3 flag is set for this name.
                //

                if (FlagOn( FileName->Flags, FILE_NAME_DOS )) {

                    AlternateName.Length = (USHORT)(FileName->FileNameLength * sizeof( WCHAR ));
                    AlternateName.Buffer = (PWSTR) FileName->FileName;

                    break;
                }

                //
                //  The last one wasn't it.  Let's try again.
                //

                MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                          Scb->Fcb,
                                                          $FILE_NAME,
                                                          &AttrContext );
            }

            //
            //  If we didn't find a match, return to the caller.
            //

            if (!MoreToGo) {

                DebugTrace( 0, Dbg, ("NtfsQueryAlternateNameInfo:  No Dos link\n") );
                try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );

                //
                //  ****    Get a better status code.
                //
            }
        }

        //
        //  The name is now in alternate name.
        //  Figure out how many bytes we can copy.
        //

        if ( *Length >= (ULONG)AlternateName.Length ) {

            Status = STATUS_SUCCESS;

            BytesToCopy = AlternateName.Length;

        } else {

            Status = STATUS_BUFFER_OVERFLOW;

            BytesToCopy = *Length;
        }

        //
        //  Copy over the file name
        //

        RtlCopyMemory( Buffer->FileName, AlternateName.Buffer, BytesToCopy);

        //
        //  Copy the number of bytes (not characters) and update the Length
        //

        Buffer->FileNameLength = BytesToCopy;

        *Length -= BytesToCopy;

    try_exit:  NOTHING;
    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  And return to our caller
        //

        DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
        DebugTrace( -1, Dbg, ("NtfsQueryAlternateNameInfo -> 0x%8lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsQueryStreamsInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STREAM_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine will return the attribute name and code name for as
    many attributes in the file as will fit in the user buffer.  We return
    a string which can be appended to the end of the file name to
    open the string.

    For example, for the unnamed data stream we will return the string:

            "::$DATA"

    For a user data stream with the name "Authors", we return the string

            ":Authors:$DATA"

Arguments:

    Fcb - This is the Fcb for the file.

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_SUCCESS if all of the names would fit into the user buffer,
        STATUS_BUFFER_OVERFLOW otherwise.

        ****    We need a code indicating that they didn't all fit but
                some of them got in.

--*/

{
    NTSTATUS Status;
    BOOLEAN MoreToGo;

    PUCHAR UserBuffer;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_DEFINITION_COLUMNS AttrDefinition;
    UNICODE_STRING AttributeCodeString;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ATTRIBUTE_TYPE_CODE TypeCode = $DATA;

    ULONG NextEntry;
    ULONG LastEntry;
    ULONG ThisLength;
    ULONG NameLength;
    ULONG LastQuadAlign;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryStreamsInfo...\n") );

    Status = STATUS_SUCCESS;

    LastEntry = 0;
    NextEntry = 0;
    LastQuadAlign = 0;

    //
    //  Zero the entire buffer.
    //

    UserBuffer = (PUCHAR) Buffer;

    RtlZeroMemory( UserBuffer, *Length );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  There should always be at least one attribute.
        //

        MoreToGo = NtfsLookupAttribute( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        &AttrContext );

        Attribute = NtfsFoundAttribute( &AttrContext );

        //
        //  Walk through all of the entries, checking if we can return this
        //  entry to the user and if it will fit in the buffer.
        //

        while (MoreToGo) {

            //
            //  If we can return this entry to the user, compute it's size.
            //  We only return user defined attributes or data streams
            //  unless we are allowing access to all attributes for
            //  debugging.
            //

            if ((Attribute->TypeCode == TypeCode)

                    &&

                (NtfsIsAttributeResident(Attribute) ||
                 (Attribute->Form.Nonresident.LowestVcn == 0))) {

                PWCHAR StreamName;

                //
                //  Lookup the attribute definition for this attribute code.
                //

                AttrDefinition = NtfsGetAttributeDefinition( Fcb->Vcb,
                                                             Attribute->TypeCode );

                //
                //  Generate a unicode string for the attribute code name.
                //

                RtlInitUnicodeString( &AttributeCodeString, AttrDefinition->AttributeName );

                //
                //
                //  The size is a combination of the length of the attribute
                //  code name and the attribute name plus the separating
                //  colons plus the size of the structure.  We first compute
                //  the name length.
                //

                NameLength = ((2 + Attribute->NameLength) * sizeof( WCHAR ))
                             + AttributeCodeString.Length;

                ThisLength = FIELD_OFFSET( FILE_STREAM_INFORMATION, StreamName[0] ) + NameLength;

                //
                //  If the entry doesn't fit, we return buffer overflow.
                //
                //  ****    This doesn't seem like a good scheme.  Maybe we should
                //          let the user know how much buffer was needed.
                //

                if (ThisLength + LastQuadAlign > *Length) {

                    DebugTrace( 0, Dbg, ("Next entry won't fit in the buffer \n") );

                    Status = STATUS_BUFFER_OVERFLOW ;
                    leave;
                }

                //
                //  Now store the stream information into the user's buffer.
                //  The name starts with a colon, following by the attribute name
                //  and another colon, followed by the attribute code name.
                //

                if (NtfsIsAttributeResident( Attribute )) {

                    Buffer->StreamSize.QuadPart =
                        Attribute->Form.Resident.ValueLength;
                    Buffer->StreamAllocationSize.QuadPart =
                        QuadAlign( Attribute->Form.Resident.ValueLength );

                } else {

                    Buffer->StreamSize.QuadPart = Attribute->Form.Nonresident.FileSize;
                    Buffer->StreamAllocationSize.QuadPart = Attribute->Form.Nonresident.AllocatedLength;
                }

                Buffer->StreamNameLength = NameLength;

                StreamName = (PWCHAR) Buffer->StreamName;

                *StreamName = L':';
                StreamName += 1;

                RtlCopyMemory( StreamName,
                               Add2Ptr( Attribute, Attribute->NameOffset ),
                               Attribute->NameLength * sizeof( WCHAR ));

                StreamName += Attribute->NameLength;

                *StreamName = L':';
                StreamName += 1;

                RtlCopyMemory( StreamName,
                               AttributeCodeString.Buffer,
                               AttributeCodeString.Length );

                //
                //  Set up the previous next entry offset to point to this entry.
                //

                *((PULONG)(&UserBuffer[LastEntry])) = NextEntry - LastEntry;

                //
                //  Subtract the number of bytes used from the number of bytes
                //  available in the buffer.
                //

                *Length -= (ThisLength + LastQuadAlign);

                //
                //  Compute the number of bytes needed to quad-align this entry
                //  and the offset of the next entry.
                //

                LastQuadAlign = QuadAlign( ThisLength ) - ThisLength;

                LastEntry = NextEntry;
                NextEntry += (ThisLength + LastQuadAlign);

                //
                //  Generate a pointer at the next entry offset.
                //

                Buffer = (PFILE_STREAM_INFORMATION) Add2Ptr( UserBuffer, NextEntry );
            }

            //
            //  Look for the next attribute in the file.
            //

            MoreToGo = NtfsLookupNextAttribute( IrpContext,
                                                Fcb,
                                                &AttrContext );

            Attribute = NtfsFoundAttribute( &AttrContext );
        }

    } finally {

        DebugUnwind( NtfsQueryStreamsInfo );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  And return to our caller
        //

        DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
        DebugTrace( -1, Dbg, ("NtfsQueryStreamInfo -> 0x%8lx\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsQueryCompressedFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    //
    //  Lookup the attribute and pin it so that we can modify it.
    //

    //
    //  Reduce the buffer length by the size of the fixed part of the structure.
    //

    if (*Length < sizeof(FILE_COMPRESSION_INFORMATION) ) {

        *Length = 0;
        NtfsRaiseStatus( IrpContext, STATUS_BUFFER_OVERFLOW, NULL, NULL );
    }

    if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
        (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

        Buffer->CompressedFileSize = Li0;

    } else {

        Buffer->CompressedFileSize.QuadPart = Scb->TotalAllocated;
    }

    //
    //  Do not return more than FileSize.
    //

    if (Buffer->CompressedFileSize.QuadPart > Scb->Header.FileSize.QuadPart) {

        Buffer->CompressedFileSize = Scb->Header.FileSize;
    }

    //
    //  Start off saying that the file/directory isn't comressed
    //

    Buffer->CompressionFormat = 0;

    //
    //  If this is the index allocation Scb and it has not been initialized then
    //  lookup the index root and perform the initialization.
    //

    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
        (Scb->ScbType.Index.BytesPerIndexBuffer == 0)) {

        ATTRIBUTE_ENUMERATION_CONTEXT Context;

        NtfsInitializeAttributeContext( &Context );

        //
        //  Use a try-finally to perform cleanup.
        //

        try {

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Scb->Fcb,
                                            &Scb->Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &Context )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            NtfsUpdateIndexScbFromAttribute( IrpContext,
                                             Scb,
                                             NtfsFoundAttribute( &Context ),
                                             FALSE );

        } finally {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }
    }

    //
    //  Return the compression state and the size of the returned data.
    //

    Buffer->CompressionFormat = (USHORT)(Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);

    if (Buffer->CompressionFormat != 0) {
        Buffer->CompressionFormat += 1;
        Buffer->ClusterShift = (UCHAR)Scb->Vcb->ClusterShift;
        Buffer->CompressionUnitShift = (UCHAR)(Scb->CompressionUnitShift + Buffer->ClusterShift);
        Buffer->ChunkShift = NTFS_CHUNK_SHIFT;
    }

    *Length -= sizeof(FILE_COMPRESSION_INFORMATION);

    return  STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

VOID
NtfsQueryNetworkOpenInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query network open information function.

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PFCB Fcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsQueryNetworkOpenInfo...\n") );

    Fcb = Scb->Fcb;

    //
    //  If the Scb is uninitialized, we initialize it now.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
        (Scb->AttributeTypeCode != $INDEX_ALLOCATION)) {

        DebugTrace( 0, Dbg, ("Initializing Scb -> %08lx\n", Scb) );
        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    //
    //  Update the length.
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    //
    //  Copy over the data.
    //

    NtfsFillNetworkOpenInfo( Buffer, Scb );

    //
    //  And return to our caller
    //

    DebugTrace( 0, Dbg, ("*Length = %08lx\n", *Length) );
    DebugTrace( -1, Dbg, ("NtfsQueryNetworkOpenInfo -> VOID\n") );

    return;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set basic information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this operation

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    ULONG UsnReason = 0;
    ULONG NewCcbFlags = 0;

    PFILE_BASIC_INFORMATION Buffer;
    ULONG PreviousFileAttributes = Scb->Fcb->Info.FileAttributes;

    BOOLEAN LeaveChangeTime = BooleanFlagOn( Ccb->Flags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME );

    LONGLONG CurrentTime;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetBasicInfo...\n") );

    Fcb = Scb->Fcb;

    //
    //  Reference the system buffer containing the user specified basic
    //  information record
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  If the user is specifying -1 for a field, that means
    //  we should leave that field unchanged, even if we might
    //  have otherwise set it ourselves.  We'll set the
    //  Ccb flag saying the user set the field so that we
    //  don't do our default updating.
    //
    //  We set the field to 0 then so we know not to actually
    //  set the field to the user-specified (and in this case,
    //  illegal) value.
    //

    if (Buffer->ChangeTime.QuadPart == -1) {

        SetFlag( NewCcbFlags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME );
        Buffer->ChangeTime.QuadPart = 0;

        //
        //  This timestamp is special -- sometimes even this very
        //  function wants to update the ChangeTime, but if the
        //  user is asking us not to, we shouldn't.
        //

        LeaveChangeTime = TRUE;
    }

    if (Buffer->LastAccessTime.QuadPart == -1) {

        SetFlag( NewCcbFlags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME );
        Buffer->LastAccessTime.QuadPart = 0;
    }

    if (Buffer->LastWriteTime.QuadPart == -1) {

        SetFlag( NewCcbFlags, CCB_FLAG_USER_SET_LAST_MOD_TIME );
        Buffer->LastWriteTime.QuadPart = 0;
    }

    if (Buffer->CreationTime.QuadPart == -1) {

        //
        //  We only set the creation time at creation time anyway (how
        //  appropriate), so we don't need to set a Ccb flag in this
        //  case.  In fact, there isn't even a Ccb flag to signify
        //  that the user set the creation time.
        //

        Buffer->CreationTime.QuadPart = 0;
    }

    //
    //  Do a quick check to see there are any illegal time stamps being set.
    //  Ntfs supports all values of Nt time as long as the uppermost bit
    //  isn't set.
    //

    if (FlagOn( Buffer->ChangeTime.HighPart, 0x80000000 ) ||
        FlagOn( Buffer->CreationTime.HighPart, 0x80000000 ) ||
        FlagOn( Buffer->LastAccessTime.HighPart, 0x80000000 ) ||
        FlagOn( Buffer->LastWriteTime.HighPart, 0x80000000 )) {

        DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    NtfsGetCurrentTime( IrpContext, CurrentTime );

    //
    //  Pick up any changes from the fast Io path now while we have the
    //  file exclusive.
    //

    NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

    //
    //  If the user specified a non-zero file attributes field then
    //  we need to change the file attributes.  This code uses the
    //  I/O supplied system buffer to modify the file attributes field
    //  before changing its value on the disk.
    //

    if (Buffer->FileAttributes != 0) {

        //
        //  Check for valid flags being passed in.  We fail if this is
        //  a directory and the TEMPORARY bit is used.  Also fail if this
        //  is a file and the DIRECTORY bit is used.
        //

        if (Scb->AttributeTypeCode == $DATA) {

            if (FlagOn( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", STATUS_INVALID_PARAMETER) );

                return STATUS_INVALID_PARAMETER;
            }

        } else if (IsDirectory( &Fcb->Info )) {

            if (FlagOn( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

                DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", STATUS_INVALID_PARAMETER) );

                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        //  Clear out the normal bit and the directory bit as well as any unsupported
        //  bits.
        //

        ClearFlag( Buffer->FileAttributes,
                   ~FILE_ATTRIBUTE_VALID_SET_FLAGS | FILE_ATTRIBUTE_NORMAL );

        //
        //  Update the attributes in the Fcb if this is a change to the file.
        //  We want to keep the flags that the user can't set.
        //

        Fcb->Info.FileAttributes = (Fcb->Info.FileAttributes & ~FILE_ATTRIBUTE_VALID_SET_FLAGS) |
                                   Buffer->FileAttributes;

        ASSERTMSG( "conflict with flush",
                   NtfsIsSharedFcb( Fcb ) ||
                   (Fcb->PagingIoResource != NULL &&
                    NtfsIsSharedFcbPagingIo( Fcb )) );

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );

        //
        //  If this is the root directory then keep the hidden and system flags.
        //

        if (Fcb == Fcb->Vcb->RootIndexScb->Fcb) {

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN );

        //
        //  Mark the file object temporary flag correctly.
        //

        } else if (FlagOn(Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY)) {

            SetFlag( Scb->ScbState, SCB_STATE_TEMPORARY );
            SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );

        } else {

            ClearFlag( Scb->ScbState, SCB_STATE_TEMPORARY );
            ClearFlag( FileObject->Flags, FO_TEMPORARY_FILE );
        }

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }

        //
        //  Post a Usn change if the file attribute change.
        //

        if (PreviousFileAttributes != Fcb->Info.FileAttributes) {

            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }
    }

    //
    //  Propagate the new Ccb flags to the Ccb now that we know we won't fail.
    //

    SetFlag( Ccb->Flags, NewCcbFlags );

    //
    //  If the user specified a non-zero change time then change
    //  the change time on the record.  Then do the exact same
    //  for the last acces time, last write time, and creation time
    //

    if (Buffer->ChangeTime.QuadPart != 0) {

        if (Fcb->Info.LastChangeTime != Buffer->ChangeTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->Info.LastChangeTime = Buffer->ChangeTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_CHANGE_TIME );

        LeaveChangeTime = TRUE;
    }

    if (Buffer->CreationTime.QuadPart != 0) {

        if (Fcb->Info.CreationTime != Buffer->CreationTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->Info.CreationTime = Buffer->CreationTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_CREATE );

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }
    }

    if (Buffer->LastAccessTime.QuadPart != 0) {

        if (Fcb->CurrentLastAccess != Buffer->LastAccessTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->CurrentLastAccess = Fcb->Info.LastAccessTime = Buffer->LastAccessTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS_TIME );

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }
    }

    if (Buffer->LastWriteTime.QuadPart != 0) {

        if (Fcb->Info.LastModificationTime != Buffer->LastWriteTime.QuadPart) {
            UsnReason = USN_REASON_BASIC_INFO_CHANGE;
        }

        Fcb->Info.LastModificationTime = Buffer->LastWriteTime.QuadPart;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_MOD );
        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_MOD_TIME );

        if (!LeaveChangeTime) {

            Fcb->Info.LastChangeTime = CurrentTime;

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_CHANGE );
            LeaveChangeTime = TRUE;
        }
    }

    //
    //  Now indicate that we should not be updating the standard information attribute anymore
    //  on cleanup.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

        //
        //  Check if the index bit changed.
        //

        if (FlagOn( PreviousFileAttributes ^ Fcb->Info.FileAttributes,
                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED )) {

            SetFlag( UsnReason, USN_REASON_INDEXABLE_CHANGE );
        }

        //
        //  Post the change to the Usn Journal
        //

        if (UsnReason != 0) {

            NtfsPostUsnChange( IrpContext, Scb, UsnReason );
        }

        NtfsUpdateStandardInformation( IrpContext, Fcb  );

        if (FlagOn( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                FALSE,
                                TRUE,
                                FALSE );

            ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

            NtfsCheckpointCurrentTransaction( IrpContext );
            NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );
        }
    }

    Status = STATUS_SUCCESS;

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetBasicInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set disposition information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this handle

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PLCB Lcb;
    BOOLEAN GenerateOnClose = FALSE;
    PIO_STACK_LOCATION IrpSp;
    HANDLE FileHandle = NULL;

    PFILE_DISPOSITION_INFORMATION Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetDispositionInfo...\n") );

    //
    // First pull the file handle out of the irp
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileHandle = IrpSp->Parameters.SetFile.DeleteHandle;

    //
    //  We get the Lcb for this open.  If there is no link then we can't
    //  set any disposition information if this is a file.
    //

    Lcb = Ccb->Lcb;

    if ((Lcb == NULL) &&
        FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        DebugTrace( -1, Dbg, ("NtfsSetDispositionInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the system buffer containing the user specified disposition
    //  information record
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    try {

        if (Buffer->DeleteFile) {

            //
            //  Check if the file is marked read only
            //

            if (IsReadOnly( &Scb->Fcb->Info )) {

                DebugTrace( 0, Dbg, ("File fat flags indicates read only\n") );

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            //
            //  Make sure there is no process mapping this file as an image
            //

            if (!MmFlushImageSection( &Scb->NonpagedScb->SegmentObject,
                                      MmFlushForDelete )) {

                DebugTrace( 0, Dbg, ("Failed to flush image section\n") );

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            //
            //  Check that we are not trying to delete one of the special
            //  system files.
            //

            if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                DebugTrace( 0, Dbg, ("Scb is one of the special system files\n") );

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            //
            //  Only do the auditing if we have a user handle.  We verify that the FileHandle
            //  is still valid and hasn't gone through close.  Note we first check the CCB state
            //  to see if the cleanup has been issued.  If the CCB state is valid then we are
            //  guaranteed the handle couldn't have been reused by the object manager even if
            //  the user close in another thread has gone through OB.  This is because this request
            //  is serialized with Ntfs cleanup.
            //

            if (FileHandle != NULL) {

                //
                //  Check for serialization with Ntfs cleanup first.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_CLEANUP )) {

                    DebugTrace( 0, Dbg, ("This call issued after cleanup\n") );
                    try_return( Status = STATUS_INVALID_HANDLE );
                }

                Status = ObQueryObjectAuditingByHandle( FileHandle,
                                                        &GenerateOnClose );

                //
                //  Fail the request if the object manager doesn't recognize the handle.
                //

                if (!NT_SUCCESS( Status )) {

                    DebugTrace( 0, Dbg, ("Object manager fails to recognize handle\n") );
                    try_return( Status );
                }
            }

            //
            //  Now check that the file is really deleteable according to indexsup
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                BOOLEAN LastLink;
                BOOLEAN NonEmptyIndex = FALSE;

                //
                //  If the link is not deleted, we check if it can be deleted.
                //

                if (!LcbLinkIsDeleted( Lcb )) {

                    if (NtfsIsLinkDeleteable( IrpContext, Scb->Fcb, &NonEmptyIndex, &LastLink )) {

                        //
                        //  It is ok to get rid of this guy.  All we need to do is
                        //  mark this Lcb for delete and decrement the link count
                        //  in the Fcb.  If this is a primary link, then we
                        //  indicate that the primary link has been deleted.
                        //

                        SetFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                        ASSERTMSG( "Link count should not be 0\n", Scb->Fcb->LinkCount != 0 );
                        Scb->Fcb->LinkCount -= 1;

                        if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                            SetFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                        }

                        //
                        //  Call into the notify package to close any handles on
                        //  a directory being deleted.
                        //

                        if (IsDirectory( &Scb->Fcb->Info )) {

                            FsRtlNotifyFilterChangeDirectory( Scb->Vcb->NotifySync,
                                                              &Scb->Vcb->DirNotifyList,
                                                              FileObject->FsContext,
                                                              NULL,
                                                              FALSE,
                                                              FALSE,
                                                              0,
                                                              NULL,
                                                              NULL,
                                                              NULL,
                                                              NULL );
                        }

                    } else if (NonEmptyIndex) {

                        DebugTrace( 0, Dbg, ("Index attribute has entries\n") );
                        try_return( Status = STATUS_DIRECTORY_NOT_EMPTY );

                    } else {

                        DebugTrace( 0, Dbg, ("File is not deleteable\n") );
                        try_return( Status = STATUS_CANNOT_DELETE );
                    }
                }

            //
            //  Otherwise we are simply removing the attribute.
            //

            } else {

                SetFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
            }

            //
            //  Indicate in the file object that a delete is pending
            //

            FileObject->DeletePending = TRUE;

            //
            //  Now do the audit.
            //

            if ((FileHandle != NULL) && GenerateOnClose) {

                SeDeleteObjectAuditAlarm( FileObject, FileHandle );
            }

        } else {

            if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                if (LcbLinkIsDeleted( Lcb )) {

                    //
                    //  The user doesn't want to delete the link so clear any delete bits
                    //  we have laying around
                    //

                    DebugTrace( 0, Dbg, ("File is being marked as do not delete on close\n") );

                    ClearFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                    Scb->Fcb->LinkCount += 1;
                    ASSERTMSG( "Link count should not be 0\n", Scb->Fcb->LinkCount != 0 );

                    if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                        ClearFlag( Scb->Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                    }
                }

            //
            //  Otherwise we are undeleting an attribute.
            //

            } else {

                ClearFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
            }

            FileObject->DeletePending = FALSE;
        }

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsSetDispositionInfo );

        NOTHING;
    }

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetDispositionInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    )

/*++

Routine Description:

    This routine performs the set rename function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Vcb - Supplies the Vcb for the Volume

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this file object

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PLCB Lcb = Ccb->Lcb;
    PFCB Fcb = Scb->Fcb;
    PSCB ParentScb;
    USHORT FcbLinkCountAdj = 0;

    BOOLEAN AcquiredParentScb = TRUE;
    BOOLEAN AcquiredObjectIdIndex = FALSE;
    BOOLEAN AcquiredReparsePointIndex = FALSE;

    PFCB TargetLinkFcb = NULL;
    BOOLEAN ExistingTargetLinkFcb;
    BOOLEAN AcquiredTargetLinkFcb = FALSE;
    USHORT TargetLinkFcbCountAdj = 0;

    BOOLEAN AcquiredFcbTable = FALSE;
    PFCB FcbWithPagingToRelease = NULL;

    PFILE_OBJECT TargetFileObject;
    PSCB TargetParentScb;

    UNICODE_STRING NewLinkName;
    UNICODE_STRING NewFullLinkName;
    PWCHAR NewFullLinkNameBuffer = NULL;
    UCHAR NewLinkNameFlags;

    PFILE_NAME FileNameAttr = NULL;
    USHORT FileNameAttrLength = 0;

    UNICODE_STRING PrevLinkName;
    UNICODE_STRING PrevFullLinkName;
    UCHAR PrevLinkNameFlags;

    UNICODE_STRING SourceFullLinkName;
    USHORT SourceLinkLastNameOffset;

    BOOLEAN FoundLink;
    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;
    PWCHAR NextChar;

    BOOLEAN ReportDirNotify = FALSE;

    ULONG RenameFlags = ACTIVELY_REMOVE_SOURCE_LINK | REMOVE_SOURCE_LINK | ADD_TARGET_LINK;

    PFCB_USN_RECORD SavedFcbUsnRecord = NULL;
    ULONG SavedUsnReason = 0;

    NAME_PAIR NamePair;
    NTFS_TUNNELED_DATA TunneledData;
    ULONG TunneledDataSize;
    BOOLEAN HaveTunneledInformation = FALSE;
    PFCB LockedFcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE ();

    DebugTrace( +1, Dbg, ("NtfsSetRenameInfo...\n") );

    //
    //  See if we are doing a stream rename.  The allowed inputs are:
    //      No associated file object.
    //      Rename Name begins with a colon
    //  If so, perform the rename
    //

    TargetFileObject = IrpSp->Parameters.SetFile.FileObject;

    if (TargetFileObject == NULL) {
        PFILE_RENAME_INFORMATION FileRename;

        FileRename = IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer;

        if (FileRename->FileNameLength >= sizeof( WCHAR ) &&
            FileRename->FileName[0] == L':') {

            NewLinkName.Buffer = FileRename->FileName;
            NewLinkName.MaximumLength =
                NewLinkName.Length = (USHORT) FileRename->FileNameLength;

            Status = NtfsStreamRename( IrpContext, FileObject, Fcb, Scb, Ccb, FileRename->ReplaceIfExists, &NewLinkName );
            DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit -> %08lx\n", Status) );
            return Status;
        }
    }

    //
    //  Do a quick check that the caller is allowed to do the rename.
    //  The opener must have opened the main data stream by name and this can't be
    //  a system file.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE ) ||
        (Lcb == NULL) ||
        FlagOn(Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If this link has been deleted, then we don't allow this operation.
    //

    if (LcbLinkIsDeleted( Lcb )) {

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Verify that we can wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Can't wait\n") );
        return Status;
    }

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Initialize the local variables.
        //

        ParentScb = Lcb->Scb;
        NtfsInitializeNamePair( &NamePair );

        if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
            (Vcb->NotifyCount != 0)) {

            ReportDirNotify = TRUE;
        }

        PrevFullLinkName.Buffer = NULL;
        SourceFullLinkName.Buffer = NULL;

        //
        //  If this is a directory file, we need to examine its descendents.
        //  We may not remove a link which may be an ancestor path
        //  component of any open file.
        //

        if (IsDirectory( &Fcb->Info )) {

            Status = NtfsCheckTreeForBatchOplocks( IrpContext, Irp, Scb );

            if (Status != STATUS_SUCCESS) { leave; }
        }

        //
        //  We now assemble the names and in memory-structures for both the
        //  source and target links and check if the target link currently
        //  exists.
        //

        NtfsFindTargetElements( IrpContext,
                                TargetFileObject,
                                ParentScb,
                                &TargetParentScb,
                                &NewFullLinkName,
                                &NewLinkName );

        //
        //  Check that the new name is not invalid.
        //

        if ((NewLinkName.Length > (NTFS_MAX_FILE_NAME_LENGTH * sizeof( WCHAR ))) ||
            !NtfsIsFileNameValid( &NewLinkName, FALSE )) {

            Status = STATUS_OBJECT_NAME_INVALID;
            leave;
        }

        //
        //  Acquire the current parent in order to synchronize removing the current name.
        //

        NtfsAcquireExclusiveScb( IrpContext, ParentScb );

        //
        //  If this Scb does not have a normalized name then provide it with one now.
        //

        if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

            NtfsBuildNormalizedName( IrpContext,
                                     ParentScb->Fcb,
                                     ParentScb,
                                     &ParentScb->ScbType.Index.NormalizedName );
        }

        //
        //  If this is a directory then make sure it has a normalized name.
        //

        if (IsDirectory( &Fcb->Info ) &&
            (Scb->ScbType.Index.NormalizedName.Length == 0)) {

            NtfsUpdateNormalizedName( IrpContext,
                                      ParentScb,
                                      Scb,
                                      NULL,
                                      FALSE,
                                      FALSE );
        }

        //
        //  Check if we are renaming to the same directory with the exact same name.
        //

        if (TargetParentScb == ParentScb) {

            if (NtfsAreNamesEqual( Vcb->UpcaseTable, &NewLinkName, &Lcb->ExactCaseLink.LinkName, FALSE )) {

                DebugTrace( 0, Dbg, ("Renaming to same name and directory\n") );
                leave;
            }

        //
        //  Otherwise we want to acquire the target directory.
        //

        } else {

            //
            //  We need to do the acquisition carefully since we may only have the Vcb shared.
            //

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                if (!NtfsAcquireExclusiveFcb( IrpContext,
                                              TargetParentScb->Fcb,
                                              TargetParentScb,
                                              ACQUIRE_DONT_WAIT )) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                //
                //  Now snapshot the Scb.
                //

                if (FlagOn( TargetParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                    NtfsSnapshotScb( IrpContext, TargetParentScb );
                }

            } else {

                NtfsAcquireExclusiveScb( IrpContext, TargetParentScb );
            }

            SetFlag( RenameFlags, MOVE_TO_NEW_DIR );
        }

        //
        //  We also determine which type of link to
        //  create.  We create a hard link only unless the source link is
        //  a primary link and the user is an IgnoreCase guy.
        //

        if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ) &&
            FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE )) {

            SetFlag( RenameFlags, ADD_PRIMARY_LINK );
        }

        //
        //  Lookup the entry for this filename in the target directory.
        //  We look in the Ccb for the type of case match for the target
        //  name.
        //

        FoundLink = NtfsLookupEntry( IrpContext,
                                     TargetParentScb,
                                     BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                     &NewLinkName,
                                     &FileNameAttr,
                                     &FileNameAttrLength,
                                     NULL,
                                     &IndexEntry,
                                     &IndexEntryBcb,
                                     NULL );

        //
        //  This call to NtfsLookupEntry may decide to push the root index,
        //  in which case we might be holding the Mft now.  If there is a
        //  transaction, commit it now so we will be able to free the Mft to
        //  eliminate a potential deadlock with the ObjectId index when we
        //  look up the object id for the rename source to add it to the
        //  tunnel cache.
        //

        if (IrpContext->TransactionId != 0) {

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Go through and free any Scb's in the queue of shared
            //  Scb's for transactions.
            //

            if (IrpContext->SharedScb != NULL) {

                NtfsReleaseSharedResources( IrpContext );
                ASSERT( IrpContext->SharedScb == NULL );
            }

            //
            //  Release the mft, if we acquired it in pushing the root index.
            //

            NtfsReleaseExclusiveScbIfOwned( IrpContext, Vcb->MftScb );
        }

        //
        //  If we found a matching link, we need to check how we want to operate
        //  on the source link and the target link.  This means whether we
        //  have any work to do, whether we need to remove the target link
        //  and whether we need to remove the source link.
        //

        if (FoundLink) {

            PFILE_NAME IndexFileName;

            //
            //  Assume we will remove this link.
            //

            SetFlag( RenameFlags, REMOVE_TARGET_LINK );

            IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

            NtfsCheckLinkForRename( Fcb,
                                    Lcb,
                                    IndexFileName,
                                    IndexEntry->FileReference,
                                    &NewLinkName,
                                    BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                    &RenameFlags );

            //
            //  Assume we will use the existing name flags on the link found.  This
            //  will be the case where the file was opened with the 8.3 name and
            //  the new name is exactly the long name for the same file.
            //

            PrevLinkNameFlags =
            NewLinkNameFlags = IndexFileName->Flags;

            //
            //  If we didn't have an exact match, then we need to check if we
            //  can remove the found link and then remove it from the disk.
            //

            if (FlagOn( RenameFlags, REMOVE_TARGET_LINK )) {

                //
                //  We need to check that the user wanted to remove that link.
                //

                if (!FlagOn( RenameFlags, TRAVERSE_MATCH ) &&
                    !IrpSp->Parameters.SetFile.ReplaceIfExists) {

                    Status = STATUS_OBJECT_NAME_COLLISION;
                    leave;
                }

                //
                //  We want to preserve the case and the flags of the matching
                //  link found.  We also want to preserve the case of the
                //  name being created.  The following variables currently contain
                //  the exact case for the target to remove and the new name to
                //  apply.
                //
                //      Link to remove - In 'IndexEntry'.
                //          The link's flags are also in 'IndexEntry'.  We copy
                //          these flags to 'PrevLinkNameFlags'
                //
                //      New Name - Exact case is stored in 'NewLinkName'
                //               - It is also in 'FileNameAttr
                //
                //  We modify this so that we can use the FileName attribute
                //  structure to create the new link.  We copy the linkname being
                //  removed into 'PrevLinkName'.   The following is the
                //  state after the switch.
                //
                //      'FileNameAttr' - contains the name for the link being
                //          created.
                //
                //      'PrevLinkFileName' - Contains the link name for the link being
                //          removed.
                //
                //      'PrevLinkFileNameFlags' - Contains the name flags for the link
                //          being removed.
                //

                //
                //  Allocate a buffer for the name being removed.  It should be
                //  large enough for the entire directory name.
                //

                PrevFullLinkName.MaximumLength = TargetParentScb->ScbType.Index.NormalizedName.Length +
                                                 sizeof( WCHAR ) +
                                                 (IndexFileName->FileNameLength * sizeof( WCHAR ));

                PrevFullLinkName.Buffer = NtfsAllocatePool( PagedPool,
                                                            PrevFullLinkName.MaximumLength );

                RtlCopyMemory( PrevFullLinkName.Buffer,
                               TargetParentScb->ScbType.Index.NormalizedName.Buffer,
                               TargetParentScb->ScbType.Index.NormalizedName.Length );

                NextChar = Add2Ptr( PrevFullLinkName.Buffer,
                                    TargetParentScb->ScbType.Index.NormalizedName.Length );

                if (TargetParentScb != Vcb->RootIndexScb) {

                    *NextChar = L'\\';
                    NextChar += 1;
                }

                RtlCopyMemory( NextChar,
                               IndexFileName->FileName,
                               IndexFileName->FileNameLength * sizeof( WCHAR ));

                //
                //  Copy the name found in the Index Entry to 'PrevLinkName'
                //

                PrevLinkName.Buffer = NextChar;
                PrevLinkName.MaximumLength =
                PrevLinkName.Length = IndexFileName->FileNameLength * sizeof( WCHAR );

                //
                //  Update the full name length with the final component.
                //

                PrevFullLinkName.Length = (USHORT) PtrOffset( PrevFullLinkName.Buffer, NextChar ) + PrevLinkName.Length;

                //
                //  We only need this check if the link is for a different file.
                //

                if (!FlagOn( RenameFlags, TRAVERSE_MATCH )) {

                    //
                    //  We check if there is an existing Fcb for the target link.
                    //  If there is, the unclean count better be 0.
                    //

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;

                    TargetLinkFcb = NtfsCreateFcb( IrpContext,
                                                   Vcb,
                                                   IndexEntry->FileReference,
                                                   FALSE,
                                                   BooleanFlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ),
                                                   &ExistingTargetLinkFcb );

                    //
                    //  Before we go on, make sure we aren't about to rename over a system file.
                    //

                    if (FlagOn( TargetLinkFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                        Status = STATUS_ACCESS_DENIED;
                        leave;
                    }

                    //
                    //  If there is no paging resource, then try to create one
                    //  by first locking the fcb then make sure there is
                    //  still no paging resource before adding one.
                    //  Once PagingIoResource is allocated, it will not go away.
                    //  That's why it is safe to peek at it before locking it
                    //  as long as pointer value is atomic.
                    //

                    if (TargetLinkFcb->PagingIoResource == NULL) {

                        //
                        //  Increase the reference count so that the fcb can't go away.
                        //  This need to be done while holding onto the fcb table.
                        //

                        TargetLinkFcb->ReferenceCount += 1;
                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;

                        //
                        //  Add a paging resource to the target - this is not supplied if its created
                        //  from scratch. We need this (acquired in the proper order) for the delete
                        //  to work correctly if there are any data streams. It's not going to harm a
                        //  directory del and because of the teardown in the finally clause its difficult
                        //  to retry again without looping.
                        //

                        NtfsLockFcb( IrpContext, TargetLinkFcb );
                        LockedFcb = TargetLinkFcb;

                        if (TargetLinkFcb->PagingIoResource == NULL) {

                            TargetLinkFcb->PagingIoResource = NtfsAllocateEresource();
                        }

                        NtfsUnlockFcb( IrpContext, LockedFcb );
                        LockedFcb = NULL;

                        //
                        //  Now decrease the reference count while holding the fcb table
                        //

                        NtfsAcquireFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = TRUE;

                        TargetLinkFcb->ReferenceCount -= 1;
                    }

                    //
                    //  We need to acquire this file carefully in the event that we don't hold
                    //  the Vcb exclusively.
                    //

                    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                        if (!NtfsAcquirePagingResourceExclusive( IrpContext, TargetLinkFcb, FALSE )) {
                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                        FcbWithPagingToRelease = TargetLinkFcb;

                        if (!NtfsAcquireExclusiveFcb( IrpContext, TargetLinkFcb, NULL, ACQUIRE_DONT_WAIT )) {

                            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                        }

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;

                    } else {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        AcquiredFcbTable = FALSE;

                        //
                        //  Acquire the paging Io resource for this file before the main
                        //  resource in case we need to delete.
                        //

                        FcbWithPagingToRelease = TargetLinkFcb;

                        NtfsAcquirePagingResourceExclusive( IrpContext, FcbWithPagingToRelease, TRUE );
                        NtfsAcquireExclusiveFcb( IrpContext, TargetLinkFcb, NULL, 0 );
                    }

                    AcquiredTargetLinkFcb = TRUE;

                    //
                    //  If the Fcb Info field needs to be initialized, we do so now.
                    //  We read this information from the disk as the duplicate information
                    //  in the index entry is not guaranteed to be correct.
                    //

                    if (!FlagOn( TargetLinkFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

                        NtfsUpdateFcbInfoFromDisk( IrpContext,
                                                   TRUE,
                                                   TargetLinkFcb,
                                                   NULL );
                        NtfsConditionallyFixupQuota( IrpContext, TargetLinkFcb );

                        //
                        //  Commit any fixups and release the quota index so we don't deadlock
                        //  acquiring the objectid when doing any tunnelling below
                        //  

                        if (IrpContext->TransactionId != 0) {

                            NtfsCheckpointCurrentTransaction( IrpContext );
                            NtfsReleaseSharedResources( IrpContext );
                            ASSERTMSG( "Ntfs: we should not own the mftscb\n", !NtfsIsSharedScb( Vcb->MftScb ) );
                        }
                    }

                    //
                    //  We are adding a link to the source file which already
                    //  exists as a link to a different file in the target directory.
                    //
                    //  We need to check whether we permitted to delete this
                    //  link.  If not then it is possible that the problem is
                    //  an existing batch oplock on the file.  In that case
                    //  we want to delete the batch oplock and try this again.
                    //

                    Status = NtfsCheckFileForDelete( IrpContext,
                                                     TargetParentScb,
                                                     TargetLinkFcb,
                                                     ExistingTargetLinkFcb,
                                                     IndexEntry );

                    if (!NT_SUCCESS( Status )) {

                        PSCB NextScb = NULL;

                        //
                        //  We are going to either fail this request or pass
                        //  this on to the oplock package.  Test if there is
                        //  a batch oplock on any streams on this file.
                        //

                        while ((NextScb = NtfsGetNextChildScb( TargetLinkFcb,
                                                               NextScb )) != NULL) {

                            if ((NextScb->AttributeTypeCode == $DATA) &&
                                (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                                FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                                if (*VcbAcquired) {
                                    NtfsReleaseVcb( IrpContext, Vcb );
                                    *VcbAcquired = FALSE;
                                }

                                Status = FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                                           Irp,
                                                           IrpContext,
                                                           NtfsOplockComplete,
                                                           NtfsPrePostIrp );
                                break;
                            }
                        }

                        leave;
                    }

                    NtfsCleanupLinkForRemoval( TargetLinkFcb, TargetParentScb, ExistingTargetLinkFcb );

                    //
                    //  DeleteFile might need to get the reparse index to remove a reparse
                    //  point.  We may need the object id index later to deal with the
                    //  tunnel cache.  Let's acquire them in the right order now.
                    //

                    if (Vcb->ObjectIdTableScb != NULL) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                        AcquiredObjectIdIndex = TRUE;
                    }

                    if (HasReparsePoint( &TargetLinkFcb->Info ) &&
                        (Vcb->ReparsePointTableScb != NULL)) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                        AcquiredReparsePointIndex = TRUE;
                    }


                    if (TargetLinkFcb->LinkCount == 1) {

                        PFCB TempFcb;

                        //
                        //  Fixup the IrpContext CleanupStructure so deletefile logs correctly
                        //

                        TempFcb = (PFCB) IrpContext->CleanupStructure;
                        IrpContext->CleanupStructure = FcbWithPagingToRelease;

                        ASSERT( (NULL == TempFcb) || (NTFS_NTC_FCB == SafeNodeType( TempFcb )) );

                        FcbWithPagingToRelease = TempFcb;

                        NtfsDeleteFile( IrpContext,
                                        TargetLinkFcb,
                                        TargetParentScb,
                                        &AcquiredParentScb,
                                        NULL,
                                        NULL );

                        FcbWithPagingToRelease = IrpContext->CleanupStructure;
                        IrpContext->CleanupStructure = TempFcb;

                        //
                        //  Make sure to force the close record out to disk.
                        //

                        TargetLinkFcbCountAdj += 1;

                    } else {
                        NtfsPostUsnChange( IrpContext, TargetLinkFcb, USN_REASON_HARD_LINK_CHANGE | USN_REASON_CLOSE );
                        NtfsRemoveLink( IrpContext,
                                        TargetLinkFcb,
                                        TargetParentScb,
                                        PrevLinkName,
                                        NULL,
                                        NULL );

                        ClearFlag( TargetLinkFcb->FcbState, FCB_STATE_VALID_USN_NAME );

                        TargetLinkFcbCountAdj += 1;
                        NtfsUpdateFcb( TargetLinkFcb, FCB_INFO_CHANGED_LAST_CHANGE );
                    }

                //
                //  The target link is for the same file as the source link.  No security
                //  checks need to be done.  Go ahead and remove it.
                //

                } else {

                    NtfsPostUsnChange( IrpContext, Scb, USN_REASON_RENAME_OLD_NAME );

                    TargetLinkFcb = Fcb;
                    NtfsRemoveLink( IrpContext,
                                    Fcb,
                                    TargetParentScb,
                                    PrevLinkName,
                                    NULL,
                                    NULL );

                    FcbLinkCountAdj += 1;
                }
            }
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  Post the Usn record for the old name.  Don't write it until after
        //  we check if we need to remove an object ID due to tunnelling.
        //  Otherwise we might deadlock between the journal/mft resources
        //  and the object id resources.
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_RENAME_OLD_NAME );

        //
        //  See if we need to remove the current link.
        //

        if (FlagOn( RenameFlags, REMOVE_SOURCE_LINK )) {

            //
            //  Now we want to remove the source link from the file.  We need to
            //  remember if we deleted a two part primary link.
            //

            if (FlagOn( RenameFlags, ACTIVELY_REMOVE_SOURCE_LINK )) {

                TunneledData.HasObjectId = FALSE;
                NtfsRemoveLink( IrpContext,
                                Fcb,
                                ParentScb,
                                Lcb->ExactCaseLink.LinkName,
                                &NamePair,
                                &TunneledData );

                //
                //  Remember the full name for the original filename and some
                //  other information to pass to the dirnotify package.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                    if (!IsDirectory( &Fcb->Info ) &&
                        !FlagOn( FileObject->Flags, FO_OPENED_CASE_SENSITIVE )) {

                        //
                        //  Tunnel property information for file links
                        //

                        NtfsGetTunneledData( IrpContext,
                                             Fcb,
                                             &TunneledData );

                        FsRtlAddToTunnelCache(  &Vcb->Tunnel,
                                                *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                                &NamePair.Short,
                                                &NamePair.Long,
                                                BooleanFlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS ),
                                                sizeof( NTFS_TUNNELED_DATA ),
                                                &TunneledData );
                    }
                }

                FcbLinkCountAdj += 1;
            }

            if (ReportDirNotify) {

                SourceFullLinkName.Buffer = NtfsAllocatePool( PagedPool, Ccb->FullFileName.Length );

                RtlCopyMemory( SourceFullLinkName.Buffer,
                               Ccb->FullFileName.Buffer,
                               Ccb->FullFileName.Length );

                SourceFullLinkName.MaximumLength = SourceFullLinkName.Length = Ccb->FullFileName.Length;
                SourceLinkLastNameOffset = Ccb->LastFileNameOffset;
            }
        }

        //
        //  See if we need to add the target link.
        //

        if (FlagOn( RenameFlags, ADD_TARGET_LINK )) {

            //
            //  Check that we have permission to add a file to this directory.
            //

            NtfsCheckIndexForAddOrDelete( IrpContext,
                                          TargetParentScb->Fcb,
                                          (IsDirectory( &Fcb->Info ) ?
                                           FILE_ADD_SUBDIRECTORY :
                                           FILE_ADD_FILE),
                                          Ccb->AccessFlags >> 2 );

            //
            //  Grunge the tunnel cache for property restoration
            //

            if (!IsDirectory( &Fcb->Info ) &&
                !FlagOn( FileObject->Flags, FO_OPENED_CASE_SENSITIVE )) {

                NtfsResetNamePair( &NamePair );
                TunneledDataSize = sizeof( NTFS_TUNNELED_DATA );

                if (FsRtlFindInTunnelCache( &Vcb->Tunnel,
                                            *(PULONGLONG)&TargetParentScb->Fcb->FileReference,
                                            &NewLinkName,
                                            &NamePair.Short,
                                            &NamePair.Long,
                                            &TunneledDataSize,
                                            &TunneledData)) {

                    ASSERT( TunneledDataSize == sizeof( NTFS_TUNNELED_DATA ));
                    HaveTunneledInformation = TRUE;

                    //
                    //  Preacquire the objectid index which we need for tunnelling if its
                    //  not already  owned before adding the link which may acquire the mft
                    //  if it has to allocate a record or acquire the quota index if it moves
                    //  a data attribute around while adding the new filename
                    //  

                    if ((!AcquiredObjectIdIndex && (Vcb->ObjectIdTableScb != NULL))) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                        AcquiredObjectIdIndex = TRUE;
                    }
                }
            }

            //
            //  We now want to add the new link into the target directory.
            //  We create a hard link only if the source name was a hard link
            //  or this is a case-sensitive open.  This means that we can
            //  replace a primary link pair with a hard link only.
            //

            NtfsAddLink( IrpContext,
                         BooleanFlagOn( RenameFlags, ADD_PRIMARY_LINK ),
                         TargetParentScb,
                         Fcb,
                         FileNameAttr,
                         NULL,
                         &NewLinkNameFlags,
                         NULL,
                         HaveTunneledInformation ? &NamePair : NULL,
                         NULL );

            //
            //  Restore timestamps on tunneled files
            //

            if (HaveTunneledInformation) {

                NtfsSetTunneledData( IrpContext,
                                     Fcb,
                                     &TunneledData );

                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_CREATE );
                SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

                //
                //  If we have tunneled information then copy the correct case of the
                //  name into the new link pointer.
                //

                if (NewLinkNameFlags == FILE_NAME_DOS) {

                    RtlCopyMemory( NewLinkName.Buffer,
                                   NamePair.Short.Buffer,
                                   NewLinkName.Length );
                }
            }

            //
            //  Update the flags field in the target file name.  We will use this
            //  below if we are updating the normalized name.
            //

            FileNameAttr->Flags = NewLinkNameFlags;

            if (ParentScb != TargetParentScb) {

                NtfsUpdateFcb( TargetParentScb->Fcb,
                               (FCB_INFO_CHANGED_LAST_CHANGE |
                                FCB_INFO_CHANGED_LAST_MOD |
                                FCB_INFO_UPDATE_LAST_ACCESS) );
            }

            //
            //  If we need a full buffer for the new name for notify and don't already
            //  have one then construct the full name now.  This will only happen if
            //  we are renaming within the same directory.
            //

            if (ReportDirNotify &&
                (NewFullLinkName.Buffer == NULL)) {

                NewFullLinkName.MaximumLength = Ccb->LastFileNameOffset + NewLinkName.Length;

                NewFullLinkNameBuffer = NtfsAllocatePool( PagedPool,
                                                          NewFullLinkName.MaximumLength );

                RtlCopyMemory( NewFullLinkNameBuffer,
                               Ccb->FullFileName.Buffer,
                               Ccb->LastFileNameOffset );

                RtlCopyMemory( Add2Ptr( NewFullLinkNameBuffer, Ccb->LastFileNameOffset ),
                               NewLinkName.Buffer,
                               NewLinkName.Length );

                NewFullLinkName.Buffer = NewFullLinkNameBuffer;
                NewFullLinkName.Length = NewFullLinkName.MaximumLength;
            }

            FcbLinkCountAdj -= 1;
        }

        //
        //  Now write the Usn record for the old name if it exists.  Since this call
        //  needs to acquire the usn journal and/or mft, we need to do this after the
        //  NtfsSetTunneledData call, since that may acquire the object id index.
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsWriteUsnJournalChanges( IrpContext );
        }

        //
        //  We need to update the names in the Lcb for this file as well as any subdirectories
        //  or files.  We will do this in two passes.  The first pass is just to reserve enough
        //  space in all of the file objects and Lcb's.  We update the names in the second pass.
        //

        if (FlagOn( RenameFlags, TRAVERSE_MATCH )) {

            if (FlagOn( RenameFlags, REMOVE_TARGET_LINK )) {

                SetFlag( RenameFlags, REMOVE_TRAVERSE_LINK );

            } else {

                SetFlag( RenameFlags, REUSE_TRAVERSE_LINK );
            }
        }

        //
        //  If this is a directory and we added a target link it means that the
        //  normalized name has changed.  Make sure the buffer in the Scb will hold
        //  the larger name.
        //

        if (IsDirectory( &Fcb->Info ) && FlagOn( RenameFlags, ADD_TARGET_LINK )) {

            NtfsUpdateNormalizedName( IrpContext,
                                      TargetParentScb,
                                      Scb,
                                      FileNameAttr,
                                      TRUE,
                                      FALSE );
        }

        //
        //  Now post a rename change on the Fcb.  We delete the old Usn record first,
        //  since it has the wrong name.  No need to get the mutex since we have the
        //  file exclusive.
        //

        if (Fcb->FcbUsnRecord != NULL) {

            SavedFcbUsnRecord = Fcb->FcbUsnRecord;
            SavedUsnReason = SavedFcbUsnRecord->UsnRecord.Reason;
            if (SavedFcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {
                NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                RemoveEntryList( &SavedFcbUsnRecord->ModifiedOpenFilesLinks );

                if (SavedFcbUsnRecord->TimeOutLinks.Flink != NULL) {

                    RemoveEntryList( &SavedFcbUsnRecord->TimeOutLinks );
                    SavedFcbUsnRecord->ModifiedOpenFilesLinks.Flink = NULL;
                }

                NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
            }
            Fcb->FcbUsnRecord = NULL;

            //
            //  Note - Fcb is unlocked immediately below in the finally clause.
            //
        }

        //
        //  Post the rename to the Usn Journal.  We wait until the end, in order to
        //  reduce resource contention on the UsnJournal, in the event that we already
        //  posted a change when we deleted the target file.
        //

        NtfsPostUsnChange( IrpContext,
                           Scb,
                           (SavedUsnReason & ~USN_REASON_RENAME_OLD_NAME) | USN_REASON_RENAME_NEW_NAME );

        //
        //  Now, if anything at all is posted to the Usn Journal, we write it now
        //  so we don't get a recursive failure later on 
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsWriteUsnJournalChanges( IrpContext );
        }

        //
        //  Cleanup/Raise on any recursive failures before modifying in memory structures
        //  

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

        //
        //  We have now modified the on-disk structures.  We now need to
        //  modify the in-memory structures.  This includes the Fcb and Lcb's
        //  for any links we superseded, and the source Fcb and it's Lcb's.
        //
        //  We will do this in two passes.  The first pass will guarantee that all of the
        //  name buffers will be large enough for the names.  The second pass will store the
        //  names into the buffers.
        //

        if (FlagOn( RenameFlags, MOVE_TO_NEW_DIR )) {

            NtfsMoveLinkToNewDir( IrpContext,
                                  &NewFullLinkName,
                                  &NewLinkName,
                                  NewLinkNameFlags,
                                  TargetParentScb,
                                  Fcb,
                                  Lcb,
                                  RenameFlags,
                                  &PrevLinkName,
                                  PrevLinkNameFlags );

        //
        //  Otherwise we will rename in the current directory.  We need to remember
        //  if we have merged with an existing link on this file.
        //

        } else {

            NtfsRenameLinkInDir( IrpContext,
                                 ParentScb,
                                 Fcb,
                                 Lcb,
                                 &NewLinkName,
                                 NewLinkNameFlags,
                                 RenameFlags,
                                 &PrevLinkName,
                                 PrevLinkNameFlags );
        }
                   
        //
        //  At this point a commit was done in the NtfsRenameMoveLink above 
        //  which dropped any resources associated with the USN Journal and we
        //  should not do any more transactional work
        //  

        ASSERT( IrpContext->TransactionId == 0 );

        //
        //  Nothing should fail from this point forward. 
        //  

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_NO_FAILURES_EXPECTED );

        //
        //   Update the normalized name - the buffer should already be big enough
        //  

        if (IsDirectory( &Fcb->Info ) && FlagOn( RenameFlags, ADD_TARGET_LINK )) {

            NtfsUpdateNormalizedName( IrpContext,
                                      TargetParentScb,
                                      Scb,
                                      FileNameAttr,
                                      FALSE,
                                      FALSE );
        }

        //
        //  Now look at the link we superseded.  If we deleted the file then go through and
        //  mark everything as deleted.
        //

        if (FlagOn( RenameFlags, REMOVE_TARGET_LINK | TRAVERSE_MATCH ) == REMOVE_TARGET_LINK) {

            NtfsUpdateFcbFromLinkRemoval( IrpContext,
                                          TargetParentScb,
                                          TargetLinkFcb,
                                          PrevLinkName,
                                          PrevLinkNameFlags );
        }

        //
        //  Change the time stamps in the parent if we modified the links in this directory.
        //

        if (FlagOn( RenameFlags, REMOVE_SOURCE_LINK )) {

            NtfsUpdateFcb( ParentScb->Fcb,
                           (FCB_INFO_CHANGED_LAST_CHANGE |
                            FCB_INFO_CHANGED_LAST_MOD |
                            FCB_INFO_UPDATE_LAST_ACCESS) );
        }

        //
        //  We always set the last change time on the file we renamed unless
        //  the caller explicitly set this.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Don't set the archive bit on a directory.  Otherwise we break existing
        //  apps that don't expect to see this flag.
        //

        if (!IsDirectory( &Fcb->Info )) {

            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

        //
        //  Report the changes to the affected directories.  We defer reporting
        //  until now so that all of the on disk changes have been made.
        //  We have already preserved the original file name for any changes
        //  associated with it.
        //
        //  Note that we may have to make a call to notify that we are removing
        //  a target if there is only a case change.  This could make for
        //  a third notify call.
        //
        //  Now that we have the new name we need to decide whether to report
        //  this as a change in the file or adding a file to a new directory.
        //

        if (ReportDirNotify) {

            ULONG FilterMatch = 0;
            ULONG Action;

            //
            //  If we are deleting a target link in order to make a case change then
            //  report that.
            //

            if ((PrevFullLinkName.Buffer != NULL) &&
                FlagOn( RenameFlags,
                        OVERWRITE_SOURCE_LINK | REMOVE_TARGET_LINK | EXACT_CASE_MATCH ) == REMOVE_TARGET_LINK) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &PrevFullLinkName,
                                     PrevFullLinkName.Length - PrevLinkName.Length,
                                     NULL,
                                     ((TargetParentScb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &TargetParentScb->ScbType.Index.NormalizedName :
                                      NULL),
                                     (IsDirectory( &TargetLinkFcb->Info ) ?
                                      FILE_NOTIFY_CHANGE_DIR_NAME :
                                      FILE_NOTIFY_CHANGE_FILE_NAME),
                                     FILE_ACTION_REMOVED,
                                     TargetParentScb->Fcb );
            }

            //
            //  If we stored the original name then we report the changes
            //  associated with it.
            //

            if (FlagOn( RenameFlags, REMOVE_SOURCE_LINK )) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &SourceFullLinkName,
                                     SourceLinkLastNameOffset,
                                     NULL,
                                     ((ParentScb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &ParentScb->ScbType.Index.NormalizedName :
                                      NULL),
                                     (IsDirectory( &Fcb->Info ) ?
                                      FILE_NOTIFY_CHANGE_DIR_NAME :
                                      FILE_NOTIFY_CHANGE_FILE_NAME),
                                     ((FlagOn( RenameFlags, MOVE_TO_NEW_DIR ) ||
                                       !FlagOn( RenameFlags, ADD_TARGET_LINK ) ||
                                       (FlagOn( RenameFlags, REMOVE_TARGET_LINK | EXACT_CASE_MATCH ) == (REMOVE_TARGET_LINK | EXACT_CASE_MATCH))) ?
                                      FILE_ACTION_REMOVED :
                                      FILE_ACTION_RENAMED_OLD_NAME),
                                     ParentScb->Fcb );
            }

            //
            //  Check if a new name will appear in the directory.
            //

            if (!FoundLink ||
                (FlagOn( RenameFlags, OVERWRITE_SOURCE_LINK | EXACT_CASE_MATCH) == OVERWRITE_SOURCE_LINK) ||
                (FlagOn( RenameFlags, REMOVE_TARGET_LINK | EXACT_CASE_MATCH ) == REMOVE_TARGET_LINK)) {

                FilterMatch = IsDirectory( &Fcb->Info)
                              ? FILE_NOTIFY_CHANGE_DIR_NAME
                              : FILE_NOTIFY_CHANGE_FILE_NAME;

                //
                //  If we moved to a new directory, remember the
                //  action was a create operation.
                //

                if (FlagOn( RenameFlags, MOVE_TO_NEW_DIR )) {

                    Action = FILE_ACTION_ADDED;

                } else {

                    Action = FILE_ACTION_RENAMED_NEW_NAME;
                }

            //
            //  There was an entry with the same case.  If this isn't the
            //  same file then we report a change to all the file attributes.
            //

            } else if (FlagOn( RenameFlags, REMOVE_TARGET_LINK | TRAVERSE_MATCH ) == REMOVE_TARGET_LINK) {

                FilterMatch = (FILE_NOTIFY_CHANGE_ATTRIBUTES |
                               FILE_NOTIFY_CHANGE_SIZE |
                               FILE_NOTIFY_CHANGE_LAST_WRITE |
                               FILE_NOTIFY_CHANGE_LAST_ACCESS |
                               FILE_NOTIFY_CHANGE_CREATION |
                               FILE_NOTIFY_CHANGE_SECURITY |
                               FILE_NOTIFY_CHANGE_EA);

                //
                //  The file name isn't changing, only the properties of the
                //  file.
                //

                Action = FILE_ACTION_MODIFIED;
            }

            if (FilterMatch != 0) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &NewFullLinkName,
                                     NewFullLinkName.Length - NewLinkName.Length,
                                     NULL,
                                     ((TargetParentScb->ScbType.Index.NormalizedName.Length != 0) ?
                                      &TargetParentScb->ScbType.Index.NormalizedName :
                                      NULL),
                                     FilterMatch,
                                     Action,
                                     TargetParentScb->Fcb );
            }
        }

        //
        //  Now adjust the link counts on the different files.
        //

        if (TargetLinkFcb != NULL) {
            TargetLinkFcb->LinkCount -= TargetLinkFcbCountAdj;
            TargetLinkFcb->TotalLinks -= TargetLinkFcbCountAdj;
        }

        Fcb->TotalLinks -= FcbLinkCountAdj;
        Fcb->LinkCount -= FcbLinkCountAdj;

        //
        //  If we have a recursive failure at this point we will unwind the transaction
        //  in the fsd and leave the in memory stuff changed
        //

        ASSERT( !NT_SUCCESS( Status ) || NT_SUCCESS( IrpContext->ExceptionStatus ));

    } finally {

        DebugUnwind( NtfsSetRenameInfo );

        if (LockedFcb != NULL) {
            NtfsUnlockFcb( IrpContext, LockedFcb );
        }

        //
        //  See if we have a SavedFcbUsnRecord.
        //

        if (SavedFcbUsnRecord != NULL) {

            //
            //  Conceivably we failed to reallcoate the record when we tried to post
            //  the rename.  If so, we will simply restore it here.  (Note the rename
            //  back to the old name will occur anyway.)
            //

            if (Fcb->FcbUsnRecord == NULL) {
                Fcb->FcbUsnRecord = SavedFcbUsnRecord;

            //
            //  Else just free the pool.
            //

            } else {
                NtfsFreePool( SavedFcbUsnRecord );
            }
        }

        //
        //  release objectid and reparse explicitly so we can call Teardown structures and wait to go up chain
        //

        if (AcquiredObjectIdIndex) { NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb ); }
        if (AcquiredReparsePointIndex) { NtfsReleaseScb( IrpContext, Vcb->ReparsePointTableScb ); }

        //
        //  Release the PagingToResource first while holding onto the FcbTable otherwise
        //  the Fcb can go away and freeing the paging resource first
        //

        if (FcbWithPagingToRelease != NULL) { NtfsReleasePagingResource( IrpContext, FcbWithPagingToRelease ); }
        if (AcquiredFcbTable) { NtfsReleaseFcbTable( IrpContext, Vcb ); }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  If we allocated any buffers for the notify operations deallocate them now.
        //

        if (NewFullLinkNameBuffer != NULL) { NtfsFreePool( NewFullLinkNameBuffer ); }
        if (PrevFullLinkName.Buffer != NULL) { NtfsFreePool( PrevFullLinkName.Buffer ); }
        if (SourceFullLinkName.Buffer != NULL) {

            NtfsFreePool( SourceFullLinkName.Buffer );
        }

        //
        //  If we allocated a file name attribute, we deallocate it now.
        //

        if (FileNameAttr != NULL) { NtfsFreePool( FileNameAttr ); }

        //
        //  If we allocated a buffer for the tunneled names, deallocate them now.
        //

        if (NamePair.Long.Buffer != NamePair.LongBuffer) {

            NtfsFreePool( NamePair.Long.Buffer );
        }

        //
        //  Some cleanup only occurs if this request has not been posted to
        // the oplock package

        if (Status != STATUS_PENDING) {

            if (AcquiredTargetLinkFcb) {

                NtfsTeardownStructures( IrpContext,
                                        TargetLinkFcb,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL );
            }
        }

        DebugTrace( -1, Dbg, ("NtfsSetRenameInfo:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetLinkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN OUT PBOOLEAN VcbAcquired
    )

/*++

Routine Description:

    This routine performs the set link function.  It will create a new link for a
    file.

Arguments:

    Irp - Supplies the Irp being processed

    Vcb - Supplies the Vcb for the Volume

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this file object

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PLCB Lcb = Ccb->Lcb;
    PFCB Fcb = Scb->Fcb;
    PSCB ParentScb = NULL;
    SHORT LinkCountAdj = 0;

    BOOLEAN AcquiredParentScb = TRUE;
    BOOLEAN AcquiredObjectIdIndex = FALSE;
    BOOLEAN AcquiredPreviousFcb = FALSE;
    PFCB LockedFcb = NULL;

    UNICODE_STRING NewLinkName;
    UNICODE_STRING NewFullLinkName;
    PWCHAR NewFullLinkNameBuffer = NULL;
    PFILE_NAME NewLinkNameAttr = NULL;
    USHORT NewLinkNameAttrLength = 0;
    UCHAR NewLinkNameFlags;

    PSCB TargetParentScb;
    PFILE_OBJECT TargetFileObject = IrpSp->Parameters.SetFile.FileObject;

    BOOLEAN FoundPrevLink;
    UNICODE_STRING PrevLinkName;
    UNICODE_STRING PrevFullLinkName;
    UCHAR PrevLinkNameFlags;
    USHORT PrevFcbLinkCountAdj = 0;
    BOOLEAN ExistingPrevFcb = FALSE;
    PFCB PreviousFcb = NULL;

    ULONG RenameFlags = 0;

    BOOLEAN AcquiredFcbTable = FALSE;
    PFCB FcbWithPagingResourceToRelease = NULL;

    BOOLEAN ReportDirNotify = FALSE;
    PWCHAR NextChar;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    PISECURITY_DESCRIPTOR SecurityDescriptor;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetLinkInfo...\n") );

    PrevFullLinkName.Buffer = NULL;

    //
    //  If we are not opening the entire file, we can't set link info.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We also fail this if we are attempting to create a link on a directory.
    //  This will prevent cycles from being created.
    //

    if (FlagOn( Fcb->Info.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT)) {

        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit -> %08lx\n", STATUS_FILE_IS_A_DIRECTORY) );
        return STATUS_FILE_IS_A_DIRECTORY;
    }

    //
    //  We can't add a link without having a parent directory.  Either we want to use the same
    //  parent or our caller supplied a parent.
    //

    if (Lcb == NULL) {

        //
        //  If the current file has been opened by FileId and there are no
        //  remaining links not marked for delete then don't allow this
        //  operation.  This is because we defer the delete of the last link
        //  until all of the OpenByID handles are closed.  We don't have any
        //  easy way to remember that there is a link to delete after
        //  the open through the link is closed.
        //
        //  The OPEN_BY_FILE_ID flag indicates that we used an open by Id somewhere
        //  in the open path.  This operation is OK if this user opened through
        //  a link, that's why we will only do this test if there is no Lcb.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
            (Fcb->LinkCount == 0)) {

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
            return Status;
        }

        //
        //  If there is no target file object, then we can't add a link.
        //

        if (TargetFileObject == NULL) {

            DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  No target file object -> %08lx\n", STATUS_INVALID_PARAMETER) );
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        ParentScb = Lcb->Scb;

        //
        //  If this link has been deleted, then we don't allow this operation.
        //

        if (LcbLinkIsDeleted( Lcb )) {

            Status = STATUS_ACCESS_DENIED;

            DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
            return Status;
        }
    }

    //
    //  Check if we are allowed to perform this link operation.  We can't if this
    //  is a system file or the user hasn't opened the entire file.  We
    //  don't need to check for the root explicitly since it is one of
    //  the system files.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

        Status = STATUS_INVALID_PARAMETER;
        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
        return Status;
    }

    //
    //  Verify that we can wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );
        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Can't wait\n") );
        return Status;
    }

    //
    //  Check if we will want to report this via the dir notify package.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID ) &&
        (Ccb->FullFileName.Buffer[0] == L'\\') &&
        (Vcb->NotifyCount != 0)) {

        ReportDirNotify = TRUE;
    }

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Post the change to the Usn Journal (on errors change is backed out)
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_HARD_LINK_CHANGE );

        //
        //  We now assemble the names and in memory-structures for both the
        //  source and target links and check if the target link currently
        //  exists.
        //

        NtfsFindTargetElements( IrpContext,
                                TargetFileObject,
                                ParentScb,
                                &TargetParentScb,
                                &NewFullLinkName,
                                &NewLinkName );

        //
        //  Check that the new name is not invalid.
        //

        if ((NewLinkName.Length > (NTFS_MAX_FILE_NAME_LENGTH * sizeof( WCHAR ))) ||
            !NtfsIsFileNameValid( &NewLinkName, FALSE )) {

            Status = STATUS_OBJECT_NAME_INVALID;
            leave;
        }

        if (TargetParentScb == ParentScb) {

            //
            //  Acquire the target parent in order to synchronize adding a link.
            //

            NtfsAcquireExclusiveScb( IrpContext, ParentScb );

            //
            //  Check if we are creating a link to the same directory with the
            //  exact same name.
            //

            if (NtfsAreNamesEqual( Vcb->UpcaseTable,
                                   &NewLinkName,
                                   &Lcb->ExactCaseLink.LinkName,
                                   FALSE )) {

                DebugTrace( 0, Dbg, ("Creating link to same name and directory\n") );
                Status = STATUS_SUCCESS;
                leave;
            }

            //
            //  Make sure the normalized name is in this Scb.
            //

            if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

                NtfsBuildNormalizedName( IrpContext,
                                         ParentScb->Fcb,
                                         ParentScb,
                                         &ParentScb->ScbType.Index.NormalizedName );
            }

        //
        //  Otherwise we remember that we are creating this link in a new directory.
        //

        } else {

            SetFlag( RenameFlags, CREATE_IN_NEW_DIR );

            //
            //  We know that we need to acquire the target directory so we can
            //  add and remove links.  We want to carefully acquire the Scb in the
            //  event we only have the Vcb shared.
            //

            if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                if (!NtfsAcquireExclusiveFcb( IrpContext,
                                              TargetParentScb->Fcb,
                                              TargetParentScb,
                                              ACQUIRE_DONT_WAIT )) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                //
                //  Now snapshot the Scb.
                //

                if (FlagOn( TargetParentScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                    NtfsSnapshotScb( IrpContext, TargetParentScb );
                }

            } else {

                NtfsAcquireExclusiveScb( IrpContext, TargetParentScb );
            }
        }

        //
        //  If we are exceeding the maximum link count on this file then return
        //  an error.  There isn't a descriptive error code to use at this time.
        //

        if (Fcb->TotalLinks >= NTFS_MAX_LINK_COUNT) {

            Status = STATUS_TOO_MANY_LINKS;
            leave;
        }

        //
        //  Lookup the entry for this filename in the target directory.
        //  We look in the Ccb for the type of case match for the target
        //  name.
        //

        FoundPrevLink = NtfsLookupEntry( IrpContext,
                                         TargetParentScb,
                                         BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                         &NewLinkName,
                                         &NewLinkNameAttr,
                                         &NewLinkNameAttrLength,
                                         NULL,
                                         &IndexEntry,
                                         &IndexEntryBcb,
                                         NULL );

        //
        //  If we found a matching link, we need to check how we want to operate
        //  on the source link and the target link.  This means whether we
        //  have any work to do, whether we need to remove the target link
        //  and whether we need to remove the source link.
        //

        if (FoundPrevLink) {

            PFILE_NAME IndexFileName;

            IndexFileName = (PFILE_NAME) NtfsFoundIndexEntry( IndexEntry );

            //
            //  If the file references match, we are trying to create a
            //  link where one already exists.
            //

            if (NtfsCheckLinkForNewLink( Fcb,
                                         IndexFileName,
                                         IndexEntry->FileReference,
                                         &NewLinkName,
                                         &RenameFlags )) {

                //
                //  There is no work to do.
                //

                Status = STATUS_SUCCESS;
                leave;
            }

            //
            //  We need to check that the user wanted to remove that link.
            //

            if (!IrpSp->Parameters.SetFile.ReplaceIfExists) {

                Status = STATUS_OBJECT_NAME_COLLISION;
                leave;
            }

            //
            //  We want to preserve the case and the flags of the matching
            //  target link.  We also want to preserve the case of the
            //  name being created.  The following variables currently contain
            //  the exact case for the target to remove and the new name to
            //  apply.
            //
            //      Link to remove - In 'IndexEntry'.
            //          The links flags are also in 'IndexEntry'.  We copy
            //          these flags to 'PrevLinkNameFlags'
            //
            //      New Name - Exact case is stored in 'NewLinkName'
            //               - Exact case is also stored in 'NewLinkNameAttr'
            //
            //  We modify this so that we can use the FileName attribute
            //  structure to create the new link.  We copy the linkname being
            //  removed into 'PrevLinkName'.   The following is the
            //  state after the switch.
            //
            //      'NewLinkNameAttr' - contains the name for the link being
            //          created.
            //
            //      'PrevLinkName' - Contains the link name for the link being
            //          removed.
            //
            //      'PrevLinkNameFlags' - Contains the name flags for the link
            //          being removed.
            //

            //
            //  Remember the file name flags for the match being made.
            //

            PrevLinkNameFlags = IndexFileName->Flags;

            //
            //  If we are report this via dir notify then build the full name.
            //  Otherwise just remember the last name.
            //

            if (ReportDirNotify) {

                PrevFullLinkName.MaximumLength =
                PrevFullLinkName.Length = (ParentScb->ScbType.Index.NormalizedName.Length +
                                           sizeof( WCHAR ) +
                                           NewLinkName.Length);

                PrevFullLinkName.Buffer = NtfsAllocatePool( PagedPool,
                                                            PrevFullLinkName.MaximumLength );

                RtlCopyMemory( PrevFullLinkName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Length );

                NextChar = Add2Ptr( PrevFullLinkName.Buffer,
                                    ParentScb->ScbType.Index.NormalizedName.Length );

                if (ParentScb->ScbType.Index.NormalizedName.Length != sizeof( WCHAR )) {


                    *NextChar = L'\\';
                    NextChar += 1;

                } else {

                    PrevFullLinkName.Length -= sizeof( WCHAR );
                }

                PrevLinkName.Buffer = NextChar;

            } else {

                PrevFullLinkName.Buffer =
                PrevLinkName.Buffer = NtfsAllocatePool( PagedPool, NewLinkName.Length );

                PrevFullLinkName.Length = PrevLinkName.MaximumLength = NewLinkName.Length;
            }

            //
            //  Copy the name found in the Index Entry to 'PrevLinkName'
            //

            PrevLinkName.Length =
            PrevLinkName.MaximumLength = NewLinkName.Length;

            RtlCopyMemory( PrevLinkName.Buffer,
                           IndexFileName->FileName,
                           NewLinkName.Length );

            //
            //  We only need this check if the existing link is for a different file.
            //

            if (!FlagOn( RenameFlags, TRAVERSE_MATCH )) {

                //
                //  We check if there is an existing Fcb for the target link.
                //  If there is, the unclean count better be 0.
                //

                NtfsAcquireFcbTable( IrpContext, Vcb );
                AcquiredFcbTable = TRUE;

                PreviousFcb = NtfsCreateFcb( IrpContext,
                                             Vcb,
                                             IndexEntry->FileReference,
                                             FALSE,
                                             BooleanFlagOn( Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ),
                                             &ExistingPrevFcb );

                //
                //  Before we go on, make sure we aren't about to rename over a system file.
                //

                if (FlagOn( PreviousFcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

                    Status = STATUS_ACCESS_DENIED;
                    leave;
                }

                //
                //  Add a paging resource to the target - this is not supplied if its created
                //  from scratch. We need this (acquired in the proper order) for the delete
                //  to work correctly if there are any data streams. It's not going to harm a
                //  directory del and because of the teardown in the finally clause its difficult
                //  to retry again without looping
                //

                NtfsLockFcb( IrpContext, PreviousFcb );
                LockedFcb = PreviousFcb;
                if (PreviousFcb->PagingIoResource == NULL) {
                    PreviousFcb->PagingIoResource = NtfsAllocateEresource();
                }
                NtfsUnlockFcb( IrpContext, LockedFcb );
                LockedFcb = NULL;

                //
                //  We need to acquire this file carefully in the event that we don't hold
                //  the Vcb exclusively.
                //

                if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX )) {

                    if (!NtfsAcquirePagingResourceExclusive( IrpContext, PreviousFcb, FALSE )) {
                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                    FcbWithPagingResourceToRelease = PreviousFcb;

                    if (!NtfsAcquireExclusiveFcb( IrpContext, PreviousFcb, NULL, ACQUIRE_DONT_WAIT )) {

                        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );
                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                    }

                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = FALSE;

                } else {

                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = FALSE;

                    //
                    //  Acquire the paging Io resource for this file before the main
                    //  resource in case we need to delete.
                    //

                    FcbWithPagingResourceToRelease = PreviousFcb;

                    NtfsAcquirePagingResourceExclusive( IrpContext, PreviousFcb, TRUE );
                    NtfsAcquireExclusiveFcb( IrpContext, PreviousFcb, NULL, 0 );
                }

                AcquiredPreviousFcb = TRUE;

                //
                //  If the Fcb Info field needs to be initialized, we do so now.
                //  We read this information from the disk as the duplicate information
                //  in the index entry is not guaranteed to be correct.
                //

                if (!FlagOn( PreviousFcb->FcbState, FCB_STATE_DUP_INITIALIZED )) {

                    NtfsUpdateFcbInfoFromDisk( IrpContext,
                                               TRUE,
                                               PreviousFcb,
                                               NULL );
                    //
                    //  If we need to acquire the object id index later in order
                    //  to set or lookup information for the tunnel cache, we
                    //  risk a deadlock if the quota index is still held.  Given
                    //  that superceding renames where the target Fcb isn't
                    //  already open are a fairly rare case, we can tolerate the
                    //  potential inefficiency of preacquiring the object id
                    //  index now.
                    //

                    if (Vcb->ObjectIdTableScb != NULL) {

                        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                        AcquiredObjectIdIndex = TRUE;
                    }

                    NtfsConditionallyFixupQuota( IrpContext, PreviousFcb );
                }

                //
                //  We are adding a link to the source file which already
                //  exists as a link to a different file in the target directory.
                //
                //  We need to check whether we permitted to delete this
                //  link.  If not then it is possible that the problem is
                //  an existing batch oplock on the file.  In that case
                //  we want to delete the batch oplock and try this again.
                //

                Status = NtfsCheckFileForDelete( IrpContext,
                                                 TargetParentScb,
                                                 PreviousFcb,
                                                 ExistingPrevFcb,
                                                 IndexEntry );

                if (!NT_SUCCESS( Status )) {

                    PSCB NextScb = NULL;

                    //
                    //  We are going to either fail this request or pass
                    //  this on to the oplock package.  Test if there is
                    //  a batch oplock on any streams on this file.
                    //

                    while ((NextScb = NtfsGetNextChildScb( PreviousFcb,
                                                           NextScb )) != NULL) {

                        if ((NextScb->AttributeTypeCode == $DATA) &&
                            (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                            FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                            //
                            //  Go ahead and perform any necessary cleanup now.
                            //  Once we call the oplock package below we lose
                            //  control of the IrpContext.
                            //

                            if (*VcbAcquired) {
                                NtfsReleaseVcb( IrpContext, Vcb );
                                *VcbAcquired = FALSE;
                            }

                            Status = FsRtlCheckOplock( &NextScb->ScbType.Data.Oplock,
                                                       Irp,
                                                       IrpContext,
                                                       NtfsOplockComplete,
                                                       NtfsPrePostIrp );

                            break;
                        }
                    }

                    leave;
                }

                //
                //  We are adding a link to the source file which already
                //  exists as a link to a different file in the target directory.
                //

                NtfsCleanupLinkForRemoval( PreviousFcb,
                                           TargetParentScb,
                                           ExistingPrevFcb );

                //
                //  If the link count on this file is 1, then delete the file.  Otherwise just
                //  delete the link.
                //

                if (PreviousFcb->LinkCount == 1) {

                    PVOID TempFcb;

                    TempFcb = (PFCB)IrpContext->CleanupStructure;
                    IrpContext->CleanupStructure = FcbWithPagingResourceToRelease;
                    FcbWithPagingResourceToRelease = TempFcb;

                    ASSERT( (NULL == TempFcb) || (NTFS_NTC_FCB == SafeNodeType( TempFcb )) );

                    NtfsDeleteFile( IrpContext,
                                    PreviousFcb,
                                    TargetParentScb,
                                    &AcquiredParentScb,
                                    NULL,
                                    NULL );

                    FcbWithPagingResourceToRelease = IrpContext->CleanupStructure;
                    IrpContext->CleanupStructure = TempFcb;

                    //
                    //  Make sure to force the close record out to disk.
                    //

                    PrevFcbLinkCountAdj += 1;

                } else {

                    NtfsPostUsnChange( IrpContext, PreviousFcb, USN_REASON_HARD_LINK_CHANGE | USN_REASON_CLOSE );
                    NtfsRemoveLink( IrpContext,
                                    PreviousFcb,
                                    TargetParentScb,
                                    PrevLinkName,
                                    NULL,
                                    NULL );

                    ClearFlag( PreviousFcb->FcbState, FCB_STATE_VALID_USN_NAME );

                    PrevFcbLinkCountAdj += 1;
                    NtfsUpdateFcb( PreviousFcb, FCB_INFO_CHANGED_LAST_CHANGE );
                }

            //
            //  Otherwise we need to remove this link as our caller wants to replace it
            //  with a different case.
            //

            } else {

                NtfsRemoveLink( IrpContext,
                                Fcb,
                                TargetParentScb,
                                PrevLinkName,
                                NULL,
                                NULL );

                //
                //  Make sure we find the name again when posting another change.
                //

                ClearFlag( Fcb->FcbState, FCB_STATE_VALID_USN_NAME );

                PreviousFcb = Fcb;
                LinkCountAdj += 1;
            }
        }

        //
        //  Make sure we have the full name of the target if we will be reporting
        //  this.
        //

        if (ReportDirNotify && (NewFullLinkName.Buffer == NULL)) {

            NewFullLinkName.MaximumLength =
            NewFullLinkName.Length = (ParentScb->ScbType.Index.NormalizedName.Length +
                                      sizeof( WCHAR ) +
                                      NewLinkName.Length);

            NewFullLinkNameBuffer =
            NewFullLinkName.Buffer = NtfsAllocatePool( PagedPool,
                                                       NewFullLinkName.MaximumLength );

            RtlCopyMemory( NewFullLinkName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Length );

            NextChar = Add2Ptr( NewFullLinkName.Buffer,
                                ParentScb->ScbType.Index.NormalizedName.Length );

            if (ParentScb->ScbType.Index.NormalizedName.Length != sizeof( WCHAR )) {

                *NextChar = L'\\';
                NextChar += 1;

            } else {

                NewFullLinkName.Length -= sizeof( WCHAR );
            }

            RtlCopyMemory( NextChar,
                           NewLinkName.Buffer,
                           NewLinkName.Length );
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        //
        //  Check that we have permission to add a file to this directory.
        //

        NtfsCheckIndexForAddOrDelete( IrpContext,
                                      TargetParentScb->Fcb,
                                      FILE_ADD_FILE,
                                      Ccb->AccessFlags >> 2 );

        //
        //  We always set the last change time on the file we renamed unless
        //  the caller explicitly set this.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );

        //
        //  We now want to add the new link into the target directory.
        //  We never create a primary link through the link operation although
        //  we can remove one.
        //

        NtfsAddLink( IrpContext,
                     FALSE,
                     TargetParentScb,
                     Fcb,
                     NewLinkNameAttr,
                     NULL,
                     &NewLinkNameFlags,
                     NULL,
                     NULL,
                     NULL );

        LinkCountAdj -= 1;
        NtfsUpdateFcb( TargetParentScb->Fcb,
                       (FCB_INFO_CHANGED_LAST_CHANGE |
                        FCB_INFO_CHANGED_LAST_MOD |
                        FCB_INFO_UPDATE_LAST_ACCESS) );

        //
        //  Now we want to update the Fcb for the link we renamed.  If we moved it
        //  to a new directory we need to move all the Lcb's associated with
        //  the previous link.
        //

        if (FlagOn( RenameFlags, TRAVERSE_MATCH )) {

            NtfsReplaceLinkInDir( IrpContext,
                                  TargetParentScb,
                                  Fcb,
                                  &NewLinkName,
                                  NewLinkNameFlags,
                                  &PrevLinkName,
                                  PrevLinkNameFlags );
        }

        //
        //  We have now modified the on-disk structures.  We now need to
        //  modify the in-memory structures.  This includes the Fcb and Lcb's
        //  for any links we superseded, and the source Fcb and it's Lcb's.
        //
        //  We start by looking at the link we superseded.  We know the
        //  the target directory, link name and flags, and the file the
        //  link was connected to.
        //

        if (FoundPrevLink && !FlagOn( RenameFlags, TRAVERSE_MATCH )) {

            NtfsUpdateFcbFromLinkRemoval( IrpContext,
                                          TargetParentScb,
                                          PreviousFcb,
                                          PrevLinkName,
                                          PrevLinkNameFlags );
        }

        //
        //  We have three cases to report for changes in the target directory..
        //
        //      1.  If we overwrote an existing link to a different file, we
        //          report this as a modified file.
        //
        //      2.  If we moved a link to a new directory, then we added a file.
        //
        //      3.  If we renamed a link in in the same directory, then we report
        //          that there is a new name.
        //
        //  We currently combine cases 2 and 3.
        //

        if (ReportDirNotify) {

            ULONG FilterMatch = 0;
            ULONG FileAction;

            //
            //  If we removed an entry and it wasn't an exact case match, then
            //  report the entry which was removed.
            //

            if (!FlagOn( RenameFlags, EXACT_CASE_MATCH )) {

                if (FoundPrevLink) {

                    NtfsReportDirNotify( IrpContext,
                                         Vcb,
                                         &PrevFullLinkName,
                                         PrevFullLinkName.Length - PrevLinkName.Length,
                                         NULL,
                                         &TargetParentScb->ScbType.Index.NormalizedName,
                                         (IsDirectory( &PreviousFcb->Info ) ?
                                          FILE_NOTIFY_CHANGE_DIR_NAME :
                                          FILE_NOTIFY_CHANGE_FILE_NAME),
                                         FILE_ACTION_REMOVED,
                                         TargetParentScb->Fcb );
                }

                //
                //  We will be adding an entry.
                //

                FilterMatch = FILE_NOTIFY_CHANGE_FILE_NAME;
                FileAction = FILE_ACTION_ADDED;

            //
            //  If this was not a traverse match then report that all the file
            //  properties changed.
            //

            } else if (!FlagOn( RenameFlags, TRAVERSE_MATCH )) {

                FilterMatch |= (FILE_NOTIFY_CHANGE_ATTRIBUTES |
                                FILE_NOTIFY_CHANGE_SIZE |
                                FILE_NOTIFY_CHANGE_LAST_WRITE |
                                FILE_NOTIFY_CHANGE_LAST_ACCESS |
                                FILE_NOTIFY_CHANGE_CREATION |
                                FILE_NOTIFY_CHANGE_SECURITY |
                                FILE_NOTIFY_CHANGE_EA);

                FileAction = FILE_ACTION_MODIFIED;
            }

            if (FilterMatch != 0) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &NewFullLinkName,
                                     NewFullLinkName.Length - NewLinkName.Length,
                                     NULL,
                                     &TargetParentScb->ScbType.Index.NormalizedName,
                                     FilterMatch,
                                     FileAction,
                                     TargetParentScb->Fcb );
            }
        }

        //
        //  Checkpoint the transaction before we make the changes below.  If there are Usn
        //  records then writing them could raise.
        //

        if (IrpContext->Usn.CurrentUsnFcb != NULL) {
            NtfsCheckpointCurrentTransaction( IrpContext );
        }

        //
        //  Adjust the link counts on the files.
        //

        Fcb->TotalLinks = (SHORT) Fcb->TotalLinks - LinkCountAdj;
        Fcb->LinkCount = (SHORT) Fcb->LinkCount - LinkCountAdj;

        //
        //  We can now adjust the total link count on the previous Fcb.
        //

        if (PreviousFcb != NULL) {

            PreviousFcb->TotalLinks -= PrevFcbLinkCountAdj;
            PreviousFcb->LinkCount -= PrevFcbLinkCountAdj;

            if (PreviousFcb->LinkCount == 0) {

                //
                //  Release the quota control block.  This does not have to be done
                //  here however, it allows us to free up the quota control block
                //  before the fcb is removed from the table.  This keeps the assert
                //  about quota table empty from triggering in
                //  NtfsClearAndVerifyQuotaIndex.
                //

                if (NtfsPerformQuotaOperation( PreviousFcb )) {
                    NtfsDereferenceQuotaControlBlock( Vcb,
                                                      &PreviousFcb->QuotaControl );
                }
            }
        }

        //
        //  Do an audit record for the link creation if necc.
        //  Check if we need to load the security descriptor for the file
        //

        if (Fcb->SharedSecurity == NULL) {
            NtfsLoadSecurityDescriptor( IrpContext, Fcb );
        }

        SecurityDescriptor = (PISECURITY_DESCRIPTOR) Fcb->SharedSecurity->SecurityDescriptor;

        if (SeAuditingHardLinkEventsWithContext( TRUE, SecurityDescriptor, NULL )) {

            UNICODE_STRING GeneratedName;
            PUNICODE_STRING OldFullLinkName;
            UNICODE_STRING DeviceAndOldLinkName;
            UNICODE_STRING DeviceAndNewLinkName;
            USHORT Length;

            GeneratedName.Buffer = NULL;
            DeviceAndOldLinkName.Buffer = NULL;
            DeviceAndNewLinkName.Buffer = NULL;

            try {

                //
                //  Generate current filename
                //

                if (Ccb->FullFileName.Length != 0 ) {
                    OldFullLinkName = &Ccb->FullFileName;

                } else {

                    NtfsBuildNormalizedName( IrpContext, Scb->Fcb, FALSE, &GeneratedName );
                    OldFullLinkName = &GeneratedName;
                }

                //
                //  Create the full device and file name strings
                //

                Length = Vcb->DeviceName.Length + OldFullLinkName->Length;
                DeviceAndOldLinkName.Buffer = NtfsAllocatePool( PagedPool, Length );
                DeviceAndOldLinkName.Length = DeviceAndOldLinkName.MaximumLength = Length;
                RtlCopyMemory( DeviceAndOldLinkName.Buffer, Vcb->DeviceName.Buffer, Vcb->DeviceName.Length );
                RtlCopyMemory( Add2Ptr( DeviceAndOldLinkName.Buffer, Vcb->DeviceName.Length ), OldFullLinkName->Buffer, OldFullLinkName->Length );

                Length = Vcb->DeviceName.Length + TargetParentScb->ScbType.Index.NormalizedName.Length + sizeof( WCHAR ) + NewLinkName.Length;
                DeviceAndNewLinkName.Buffer = NtfsAllocatePool( PagedPool, Length );
                DeviceAndNewLinkName.Length = DeviceAndNewLinkName.MaximumLength = Length;
                RtlCopyMemory( DeviceAndNewLinkName.Buffer, Vcb->DeviceName.Buffer, Vcb->DeviceName.Length );
                RtlCopyMemory( Add2Ptr( DeviceAndNewLinkName.Buffer, Vcb->DeviceName.Length ),
                               TargetParentScb->ScbType.Index.NormalizedName.Buffer,
                               TargetParentScb->ScbType.Index.NormalizedName.Length );

                NextChar = Add2Ptr( DeviceAndNewLinkName.Buffer,
                                    Vcb->DeviceName.Length + TargetParentScb->ScbType.Index.NormalizedName.Length );

                if (TargetParentScb->ScbType.Index.NormalizedName.Length != sizeof( WCHAR )) {
                    *NextChar = L'\\';
                    NextChar += 1;
                } else {
                    DeviceAndNewLinkName.Length -= sizeof( WCHAR );
                }

                RtlCopyMemory( NextChar, NewLinkName.Buffer, NewLinkName.Length );

                SeAuditHardLinkCreation( &DeviceAndOldLinkName,
                                         &DeviceAndNewLinkName,
                                         TRUE );
            } finally {

                if (GeneratedName.Buffer != NULL) {
                    NtfsFreePool( GeneratedName.Buffer );
                }
                if (DeviceAndNewLinkName.Buffer != NULL) {
                    NtfsFreePool( DeviceAndNewLinkName.Buffer );
                }
                if (DeviceAndOldLinkName.Buffer != NULL) {
                    NtfsFreePool( DeviceAndOldLinkName.Buffer );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsSetLinkInfo );

        if (LockedFcb != NULL) {
            NtfsUnlockFcb( IrpContext, LockedFcb );
        }

        //
        //  release objectid and reparse explicitly so we can call Teardown structures and wait to go up chain
        //

        if (AcquiredObjectIdIndex) { NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb ); }
        if (AcquiredFcbTable) { NtfsReleaseFcbTable( IrpContext, Vcb ); }

        //
        //  If we allocated any buffers for name storage then deallocate them now.
        //

        if (PrevFullLinkName.Buffer != NULL) { NtfsFreePool( PrevFullLinkName.Buffer ); }
        if (NewFullLinkNameBuffer != NULL) { NtfsFreePool( NewFullLinkNameBuffer ); }

        //
        //  Release any paging io resource acquired.
        //

        if (FcbWithPagingResourceToRelease != NULL) { ExReleaseResourceLite( FcbWithPagingResourceToRelease->PagingIoResource ); }

        //
        //  If we allocated a file name attribute, we deallocate it now.
        //

        if (NewLinkNameAttr != NULL) { NtfsFreePool( NewLinkNameAttr ); }

        //
        //  If we have acquired the Fcb for a removed link and it didn't previously
        //  exist, call our teardown routine.
        //

        if ((Status != STATUS_PENDING) && AcquiredPreviousFcb) {

            NtfsTeardownStructures( IrpContext,
                                    PreviousFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        DebugTrace( -1, Dbg, ("NtfsSetLinkInfo:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetShortNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set shortname function.  We first check that the short name
    passed to us is valid for the context established by the system, i.e. check length and
    whether extended characters are allowed.  We will use the same test Ntfs uses in the
    create path to determine whether to generate a short name.  If the name is valid then
    check whether it is legal to put this short name on the link used to open the file.
    It is legal if the existing link is either a long, long/short or a short name.  It is
    also legal if this is any link AND there isn't a specialized link (long, long/short, short)
    on this file.  The final check is that this new link can't be a case insensitive match with
    any other link in the directory except for the existing short name on the file.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Vcb - Vcb for the volume

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this file object

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    PLCB Lcb = Ccb->Lcb;
    PFCB Fcb = Scb->Fcb;
    PSCB ParentScb;
    PLCB ShortNameLcb = NULL;
    PLCB LongNameLcb = NULL;

    UNICODE_STRING FullShortName;
    UNICODE_STRING ShortName;
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING OldShortName;
    UNICODE_STRING FullOldShortName;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;
    BOOLEAN ExistingShortName = FALSE;

    PFILE_NAME FoundFileName;

    BOOLEAN FoundLink;
    PFILE_NAME ShortNameAttr = NULL;
    USHORT ShortNameAttrLength = 0;

    LOGICAL ReportDirNotify = FALSE;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb = NULL;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE ();

    DebugTrace( +1, Dbg, ("NtfsSetShortNameInfo...\n") );

    OldShortName.Buffer = NULL;
    FullOldShortName.Buffer = NULL;
    FullShortName.Buffer = NULL;

    //
    //  Do a quick check that the caller is allowed to do the rename.
    //  The opener must have opened the main data stream by name and this can't be
    //  a system file.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE ) ||
        (Lcb == NULL) ||
        FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Exit -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  The caller also must have restore privilege + plus some kind of write access to set the short name
    //

    if (!FlagOn( Ccb->AccessFlags, RESTORE_ACCESS ) ||
        !FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )) {

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  This operation only applies to case-insensitive handles.
    //

    if (FlagOn( FileObject->Flags, FO_OPENED_CASE_SENSITIVE )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Case sensitive handle\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Validate the new short name.  It must be a valid Ntfs name and satisfy
    //  the current requirement for a short name.  The short name must be a full number of
    //  unicode characters and a valid short name for the current system.
    //

    ShortName.MaximumLength =
    ShortName.Length = (USHORT) ((PFILE_NAME_INFORMATION) IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer)->FileNameLength;
    ShortName.Buffer = (PWSTR) &((PFILE_NAME_INFORMATION) IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer)->FileName;

    if ((ShortName.Length == 0) ||
        FlagOn( ShortName.Length, 1 ) ||
        !NtfsIsFatNameValid( &ShortName, FALSE )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Invalid name\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure the name is upcased.
    //

    NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &ShortName );

    //
    //  If this link has been deleted, then we don't allow this operation.
    //

    if (LcbLinkIsDeleted( Lcb )) {

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Exit -> %08lx\n", STATUS_ACCESS_DENIED) );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Verify that we can wait.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Can't wait\n") );
        return Status;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If this is a directory file, we need to examine its descendents.
        //  We may not remove a link which may be an ancestor path
        //  component of any open file.
        //

        if (IsDirectory( &Fcb->Info )) {

            Status = NtfsCheckTreeForBatchOplocks( IrpContext, Irp, Scb );

            //
            //  Get out if there are any blocking batch oplocks.
            //

            if (Status != STATUS_SUCCESS) {

                leave;
            }
        }

        //
        //  Find the Parent Scb.
        //

        ParentScb = Lcb->Scb;

        //
        //  Acquire the parent and make sure it has a normalized name.  Also make sure the current
        //  Fcb has a normalized name if it is a directory.
        //

        NtfsAcquireExclusiveScb( IrpContext, ParentScb );

        if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

            NtfsBuildNormalizedName( IrpContext,
                                     ParentScb->Fcb,
                                     ParentScb,
                                     &ParentScb->ScbType.Index.NormalizedName );
        }

        if (IsDirectory( &Fcb->Info ) &&
            (Scb->ScbType.Index.NormalizedName.Length == 0)) {

            NtfsUpdateNormalizedName( IrpContext,
                                      ParentScb,
                                      Scb,
                                      NULL,
                                      FALSE,
                                      FALSE );
        }

        if (Vcb->NotifyCount != 0) {

            ReportDirNotify = TRUE;
        }

        //
        //  Check if the current Lcb is either part of or all of Ntfs/Dos name pair, if so then
        //  our life is much easier.  Otherwise look through the filename attributes to verify
        //  there isn't already an Ntfs/Dos name.
        //

        if (!FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_NTFS | FILE_NAME_DOS )) {

            //
            //  Initialize the attribute enumeration context.
            //

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $FILE_NAME,
                                            &AttrContext )) {

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Now keep looking until we find a match.
            //

            while (TRUE) {

                FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                //
                //  If we find any with the Ntfs/Dos flags set then get out.
                //

                if (FlagOn( FoundFileName->Flags, FILE_NAME_NTFS | FILE_NAME_DOS )) {

                    NtfsRaiseStatus( IrpContext, STATUS_OBJECT_NAME_COLLISION, NULL, NULL );
                }

                //
                //  Get the next filename attribute.
                //

                if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                    Fcb,
                                                    $FILE_NAME,
                                                    &AttrContext )) {

                    break;
                }
            }

            //
            //  We know the link in our hand will become the long name Lcb.
            //

            LongNameLcb = Lcb;

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;

        //
        //  Find the appropriate long and short name Lcbs if they are present.  We
        //  need to update them if present.
        //

        } else {

            //
            //  The Lcb has at least one flag set.  If both aren't set then there
            //  is a separate short name.
            //

            if (Lcb->FileNameAttr->Flags != (FILE_NAME_NTFS | FILE_NAME_DOS)) {

                ExistingShortName = TRUE;
            }

            //
            //  If a long name flag is set then we have the long name Lcb.
            //

            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_NTFS )) {

                LongNameLcb = Lcb;
            }

            //
            //  Find out if there are any Lcb's for these links in memory.
            //  If not there then we don't need to update them.
            //

            ShortNameLcb = NtfsLookupLcbByFlags( Fcb, FILE_NAME_DOS );

            if (LongNameLcb == NULL) {

                LongNameLcb = NtfsLookupLcbByFlags( Fcb, FILE_NAME_NTFS );
            }
        }

        //
        //  Verify that we don't have a case insensitive match in the directory UNLESS it is for
        //  the short name on the link we are adding this entry to.  Our checks above already
        //  verified that any short name we find will match some component of the link we
        //  were called with.
        //

        FoundLink = NtfsLookupEntry( IrpContext,
                                     ParentScb,
                                     TRUE,
                                     &ShortName,
                                     &ShortNameAttr,
                                     &ShortNameAttrLength,
                                     NULL,
                                     &IndexEntry,
                                     &IndexEntryBcb,
                                     NULL );

        //
        //  If we found a link then there is nothing to do. Either its the same file in
        //  which case we noop or we have a name collision
        //

        if (FoundLink) {

            if (NtfsEqualMftRef( &IndexEntry->FileReference, &Scb->Fcb->FileReference )) {
                leave;
            } else {
                NtfsRaiseStatus( IrpContext, STATUS_OBJECT_NAME_COLLISION, NULL, NULL );
            }
        }

        //
        //  Make sure the short name DOS bit is set.
        //

        ShortNameAttr->Flags = FILE_NAME_DOS;

        //
        //  Grow the short name Lcb buffers if present.
        //

        if (ShortNameLcb != NULL) {

            NtfsRenameLcb( IrpContext,
                           ShortNameLcb,
                           &ShortName,
                           FILE_NAME_DOS,
                           TRUE );
        }

        //
        //  We now have the appropriate Lcb's for the name switch and know that their buffers
        //  are the appropriate size.  Proceed now to make the changes on disk and update the
        //  appropriate in-memory structures.  Start with any on-disk changes which may need to
        //  be rolled back.
        //

        //
        //  Convert the corresponding long name to an Ntfs-only long name if necessary.
        //

        if (LongNameLcb != NULL) {

            //
            //  It's possible that we don't need to update the flags.
            //

            if (LongNameLcb->FileNameAttr->Flags != FILE_NAME_NTFS) {

                NtfsUpdateFileNameFlags( IrpContext,
                                         Fcb,
                                         ParentScb,
                                         FILE_NAME_NTFS,
                                         LongNameLcb->FileNameAttr );
            }

        } else {

            //
            //  If the LongNameLcb is NULL then our caller must have opened
            //  through the short name Lcb.  Since there must be a corresponding
            //  NTFS only name we don't need to update the flags.
            //

            ASSERT( Lcb->FileNameAttr->Flags == FILE_NAME_DOS );
            ExistingShortName = TRUE;
        }

        //
        //  Remove the existing short name if necessary.
        //

        if (ExistingShortName) {

            NtfsRemoveLinkViaFlags( IrpContext,
                                    Fcb,
                                    ParentScb,
                                    FILE_NAME_DOS,
                                    NULL,
                                    &OldShortName );

            //
            //  Now allocate a full name for the dir notify.
            //

            if (ReportDirNotify) {

                //
                //  Figure out the length of the name.
                //

                FullOldShortName.Length = OldShortName.Length + ParentScb->ScbType.Index.NormalizedName.Length;

                if (ParentScb != Vcb->RootIndexScb) {

                    FullOldShortName.Length += sizeof( WCHAR );
                }

                FullOldShortName.MaximumLength = FullOldShortName.Length;
                FullOldShortName.Buffer = NtfsAllocatePool( PagedPool, FullOldShortName.Length );

                //
                //  Copy in the full name.  Note we always copy in the '\' separator but will automatically
                //  overwrite in the case where it wasn't needed.
                //

                RtlCopyMemory( FullOldShortName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Buffer,
                               ParentScb->ScbType.Index.NormalizedName.Length );

                *(FullOldShortName.Buffer + (ParentScb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR ))) = L'\\';

                RtlCopyMemory( Add2Ptr( FullOldShortName.Buffer, FullOldShortName.Length - OldShortName.Length ),
                               OldShortName.Buffer,
                               OldShortName.Length );
            }
        }

        //
        //  Copy the correct dup info into the attribute.
        //

        RtlCopyMemory( &ShortNameAttr->Info,
                       &Fcb->Info,
                       sizeof( DUPLICATED_INFORMATION ));

        //
        //  Put it in the file record.
        //

        NtfsInitializeAttributeContext( &AttrContext );
        CleanupAttrContext = TRUE;

        NtfsCreateAttributeWithValue( IrpContext,
                                      Fcb,
                                      $FILE_NAME,
                                      NULL,
                                      ShortNameAttr,
                                      NtfsFileNameSize( ShortNameAttr ),
                                      0,
                                      &ParentScb->Fcb->FileReference,
                                      TRUE,
                                      &AttrContext );

        //
        //  Now put it in the index entry.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           ShortNameAttr,
                           NtfsFileNameSize( ShortNameAttr ),
                           &Fcb->FileReference,
                           NULL,
                           NULL );

        //
        //  Now allocate a full name for the dir notify.
        //

        if (ReportDirNotify) {

            //
            //  Figure out the length of the name.
            //

            FullShortName.Length = ShortName.Length + ParentScb->ScbType.Index.NormalizedName.Length;

            if (ParentScb != Vcb->RootIndexScb) {

                FullShortName.Length += sizeof( WCHAR );
            }

            FullShortName.MaximumLength = FullShortName.Length;
            FullShortName.Buffer = NtfsAllocatePool( PagedPool, FullShortName.Length );

            //
            //  Copy in the full name.  Note we always copy in the '\' separator but will automatically
            //  overwrite in the case where it wasn't needed.
            //

            RtlCopyMemory( FullShortName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Buffer,
                           ParentScb->ScbType.Index.NormalizedName.Length );

            *(FullShortName.Buffer + (ParentScb->ScbType.Index.NormalizedName.Length / sizeof( WCHAR ))) = L'\\';

            RtlCopyMemory( Add2Ptr( FullShortName.Buffer, FullShortName.Length - ShortName.Length ),
                           ShortName.Buffer,
                           ShortName.Length );
        }

        //
        //  Write the usn journal entry now if active.  We want to write this log record
        //  before updating the in-memory data structures.
        //

        NtfsPostUsnChange( IrpContext,
                           Fcb,
                           USN_REASON_HARD_LINK_CHANGE );

        //
        //  The on-disk changes are complete.  Checkpoint the transaction now so we don't have to
        //  roll back any in-memory structures if we get a LOG_FILE_FULL when writing to the Usn journal.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update the existing long and short names Lcb with the new names and flags if necessary.
        //

        if (LongNameLcb != NULL) {

            LongNameLcb->FileNameAttr->Flags = FILE_NAME_NTFS;
        }

        if (ShortNameLcb != NULL) {

            NtfsRenameLcb( IrpContext,
                           ShortNameLcb,
                           &ShortName,
                           FILE_NAME_DOS,
                           FALSE );
        }

        if (ReportDirNotify) {

            //
            //  Generate the DirNotify event for the old short name if necessary.
            //

            if (ExistingShortName) {

                NtfsReportDirNotify( IrpContext,
                                     Vcb,
                                     &FullOldShortName,
                                     FullOldShortName.Length - OldShortName.Length,
                                     NULL,
                                     NULL,
                                     IsDirectory( &Fcb->Info ) ? FILE_NOTIFY_CHANGE_DIR_NAME : FILE_NOTIFY_CHANGE_FILE_NAME,
                                     FILE_ACTION_RENAMED_OLD_NAME,
                                     ParentScb->Fcb );
            }

            //
            //  Generate the DirNotify event for the new short name.
            //

            NtfsReportDirNotify( IrpContext,
                                 Vcb,
                                 &FullShortName,
                                 FullShortName.Length - ShortName.Length,
                                 NULL,
                                 NULL,
                                 IsDirectory( &Fcb->Info ) ? FILE_NOTIFY_CHANGE_DIR_NAME : FILE_NOTIFY_CHANGE_FILE_NAME,
                                 FILE_ACTION_RENAMED_NEW_NAME,
                                 ParentScb->Fcb );
        }

        //
        //  Change the time stamps in the parent if we modified the links in this directory.
        //

        NtfsUpdateFcb( ParentScb->Fcb,
                       (FCB_INFO_CHANGED_LAST_CHANGE |
                        FCB_INFO_CHANGED_LAST_MOD |
                        FCB_INFO_UPDATE_LAST_ACCESS) );

        //
        //  Update the last change time and archive bit.  No archive bit change for
        //  directories.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );

        //
        //  Don't set the archive bit on a directory.  Otherwise we break existing
        //  apps that don't expect to see this flag.
        //

        if (!IsDirectory( &Fcb->Info )) {

            SetFlag( Ccb->Flags, CCB_FLAG_SET_ARCHIVE );
        }

    } finally {

        DebugUnwind( NtfsSetShortNameInfo );

        //
        //  Cleanup the allocations and contexts used.
        //

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (ShortNameAttr != NULL) {

            NtfsFreePool( ShortNameAttr );
        }

        if (OldShortName.Buffer != NULL) {

            NtfsFreePool( OldShortName.Buffer );
        }

        if (FullOldShortName.Buffer != NULL) {

            NtfsFreePool( FullOldShortName.Buffer );
        }

        if (FullShortName.Buffer != NULL) {

            NtfsFreePool( FullShortName.Buffer );
        }

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        DebugTrace( -1, Dbg, ("NtfsSetShortNameInfo:  Exit  ->  %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine performs the set position information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;

    PFILE_POSITION_INFORMATION Buffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetPositionInfo...\n") );

    //
    //  Reference the system buffer containing the user specified position
    //  information record
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;
    Status = STATUS_SUCCESS;


    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsSetPositionInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsPrepareToShrinkFileSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    LONGLONG NewFileSize
    )
/*++

Routine Description:

    Page in the last page of the file so we don't deadlock behind another thread
    trying to access it. (CcSetFileSizes will do a purge that will try to zero
    the cachemap directly when we shrink a file)

    Note: this requires droping and regaining the main resource to not deadlock
    and must be done before a transaction has started

Arguments:

    FileObject - Supplies the file object being processed

    Scb - Supplies the Scb for the file/directory being modified

    NewFileSize - The new size the file will shrink to

Return Value:

    NTSTATUS - The status of the operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    ULONG Buffer;

    if (!MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                               (PLARGE_INTEGER)&NewFileSize )) {

        return STATUS_USER_MAPPED_FILE;
    }

    if ((Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
        ((NewFileSize % PAGE_SIZE) != 0)) {

        if (NULL == Scb->FileObject) {
            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               FALSE,
                                               &NtfsInternalUseFile[PREPARETOSHRINKFILESIZE_FILE_NUMBER] );
        }

        ASSERT( NtfsIsExclusiveScb( Scb ) );
        NtfsReleaseScb( IrpContext,  Scb  );

        NewFileSize = NewFileSize & ~(PAGE_SIZE - 1);
        if (!CcCopyRead( Scb->FileObject,
                         (PLARGE_INTEGER)&NewFileSize,
                         1,
                         BooleanFlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                         &Buffer,
                         &Iosb )) {

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        NtfsAcquireExclusiveScb( IrpContext, Scb );
    }

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set allocation information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - This is the Scb for the open operation.  May not be present if
        this is a Mm call.

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb = Scb->Fcb;
    BOOLEAN NonResidentPath = FALSE;
    BOOLEAN FileIsCached = FALSE;
    BOOLEAN ClearCheckSizeFlag = FALSE;

    LONGLONG NewAllocationSize;
    LONGLONG PrevAllocationSize;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetAllocationInfo...\n") );

    //
    //  Are we serialized correctly?  In NtfsCommonSetInformation above, we get
    //  paging shared for a lazy writer callback, but we should never end up in
    //  here from a lazy writer callback.
    //

    ASSERT( NtfsIsExclusiveScbPagingIo( Scb ) );

    //
    //  If this attribute has been 'deleted' then we we can return immediately
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        Status = STATUS_SUCCESS;

        DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo:  Attribute is already deleted\n") );

        return Status;
    }

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    if (Ccb != NULL) {

        //
        //  Remember the source info flags in the Ccb.
        //

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;
    }

    //
    //  Save the current state of the Scb.
    //

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  Get the new allocation size.
    //

    NewAllocationSize = ((PFILE_ALLOCATION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->AllocationSize.QuadPart;
    PrevAllocationSize = Scb->Header.AllocationSize.QuadPart;

    //
    //  Check for a valid input value for the file size.
    //

    ASSERT( NewAllocationSize >= 0 );

    if ((ULONGLONG)NewAllocationSize > MAXFILESIZE) {

        Status = STATUS_INVALID_PARAMETER;
        DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo:  Invalid allocation size\n") );
        return Status;
    }

    //
    //  Do work to prepare for shrinking file if necc.
    //

    if (NewAllocationSize < Scb->Header.FileSize.QuadPart) {

        //
        //  Paging IO should never shrink the file.
        //

        ASSERT( !FlagOn( Irp->Flags, IRP_PAGING_IO ) );

        Status = NtfsPrepareToShrinkFileSize( IrpContext, FileObject, Scb, NewAllocationSize );
        if (Status != STATUS_SUCCESS) {

            DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo -> %08lx\n", Status) );
            return Status;
        }
    }

    //
    //  Use a try-finally so we can update the on disk time-stamps.
    //

    try {

#ifdef SYSCACHE
        //
        //  Let's remember this.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_SYSCACHE_FILE )) {

            PSYSCACHE_EVENT SyscacheEvent;

            SyscacheEvent = NtfsAllocatePool( PagedPool, sizeof( SYSCACHE_EVENT ) );

            SyscacheEvent->EventTypeCode = SYSCACHE_SET_ALLOCATION_SIZE;
            SyscacheEvent->Data1 = NewAllocationSize;
            SyscacheEvent->Data2 = 0L;

            InsertTailList( &Scb->ScbType.Data.SyscacheEventList, &SyscacheEvent->EventList );
        }
#endif

        //
        //  It is extremely expensive to make this call on a file that is not
        //  cached, and Ntfs has suffered stack overflows in addition to massive
        //  time and disk I/O expense (CcZero data on user mapped files!).  Therefore,
        //  if no one has the file cached, we cache it here to make this call cheaper.
        //
        //  Don't create the stream file if called from FsRtlSetFileSize (which sets
        //  IRP_PAGING_IO) because mm is in the process of creating a section.
        //


        if ((NewAllocationSize != Scb->Header.AllocationSize.QuadPart) &&
            (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

            FileIsCached = CcIsFileCached( FileObject );

            if (!FileIsCached &&
                !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                !FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   Scb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[SETALLOCATIONINFO_FILE_NUMBER] );
                FileIsCached = TRUE;
            }
        }

        //
        //  If the caller is extending the allocation of resident attribute then
        //  we will force it to become non-resident.  This solves the problem of
        //  trying to keep the allocation and file sizes in sync with only one
        //  number to use in the attribute header.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttrContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext,
                                       Scb,
                                       NULL,
                                       &AttrContext );

            //
            //  Convert if extending.
            //

            if (NewAllocationSize > Scb->Header.AllocationSize.QuadPart) {

                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &AttrContext ),
                                          (BOOLEAN) (!FileIsCached),
                                          &AttrContext );

                NonResidentPath = TRUE;

            //
            //  Otherwise the allocation is shrinking or staying the same.
            //

            } else {

                NewAllocationSize = QuadAlign( (ULONG) NewAllocationSize );

                //
                //  If the allocation size doesn't change, we are done.
                //

                if ((ULONG) NewAllocationSize == Scb->Header.AllocationSize.LowPart) {

                    try_return( NOTHING );
                }

                //
                //  We are sometimes called by MM during a create section, so
                //  for right now the best way we have of detecting a create
                //  section is IRP_PAGING_IO being set, as in FsRtlSetFileSizes.
                //

                NtfsChangeAttributeValue( IrpContext,
                                          Fcb,
                                          (ULONG) NewAllocationSize,
                                          NULL,
                                          0,
                                          TRUE,
                                          FALSE,
                                          (BOOLEAN) (!FileIsCached),
                                          FALSE,
                                          &AttrContext );

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                CleanupAttrContext = FALSE;

                //
                //  Post this to the Usn journal if we are shrinking the data.
                //

                if (NewAllocationSize < Scb->Header.FileSize.QuadPart) {
                    NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_TRUNCATION );
                }

                //
                //  Now update the sizes in the Scb.
                //

                Scb->Header.AllocationSize.LowPart =
                Scb->Header.FileSize.LowPart =
                Scb->Header.ValidDataLength.LowPart = (ULONG) NewAllocationSize;

                Scb->TotalAllocated = NewAllocationSize;

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_ALLOC, 0, 0, NewAllocationSize );
                }
#endif
            }

        } else {

            NonResidentPath = TRUE;
        }

        //
        //  We now test if we need to modify the non-resident allocation.  We will
        //  do this in two cases.  Either we're converting from resident in
        //  two steps or the attribute was initially non-resident.
        //

        if (NonResidentPath) {

            NewAllocationSize = LlClustersFromBytes( Scb->Vcb, NewAllocationSize );
            NewAllocationSize = LlBytesFromClusters( Scb->Vcb, NewAllocationSize );


            DebugTrace( 0, Dbg, ("NewAllocationSize -> %016I64x\n", NewAllocationSize) );

            //
            //  Now if the file allocation is being increased then we need to only add allocation
            //  to the attribute
            //

            if (Scb->Header.AllocationSize.QuadPart < NewAllocationSize) {

                //
                //  Add either the true disk allocation or add a hole for a sparse
                //  file.
                //

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    //
                    //  If there is a compression unit then we could be in the process of
                    //  decompressing.  Allocate precisely in this case because we don't
                    //  want to leave any holes.  Specifically the user may have truncated
                    //  the file and is now regenerating it yet the clear compression operation
                    //  has already passed this point in the file (and dropped all resources).
                    //  No one will go back to cleanup the allocation if we leave a hole now.
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
                        (Scb->CompressionUnit != 0)) {

                        ASSERT( FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ));

                        NewAllocationSize = BlockAlign( NewAllocationSize, (LONG)Scb->CompressionUnit );
                    }

                    NtfsAddAllocation( IrpContext,
                                       FileObject,
                                       Scb,
                                       LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ),
                                       LlClustersFromBytes( Scb->Vcb, NewAllocationSize - Scb->Header.AllocationSize.QuadPart ),
                                       FALSE,
                                       NULL );

                } else {

                    NtfsAddSparseAllocation( IrpContext,
                                             FileObject,
                                             Scb,
                                             Scb->Header.AllocationSize.QuadPart,
                                             NewAllocationSize - Scb->Header.AllocationSize.QuadPart );
                }

                //
                //  Set the truncate on close flag.
                //

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

            //
            //  Otherwise delete the allocation as requested.
            //

            } else if (Scb->Header.AllocationSize.QuadPart > NewAllocationSize) {

                //
                //  Check on possible cleanup if the file will shrink.
                //

                if (NewAllocationSize < Scb->Header.FileSize.QuadPart) {

                    //
                    //  If we will shrink FileSize, then write the UsnJournal.
                    //

                    NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_TRUNCATION );

                    Scb->Header.FileSize.QuadPart = NewAllocationSize;

                    //
                    //  Do we need to shrink any of the valid data length values.
                    //

                    if (NewAllocationSize < Scb->Header.ValidDataLength.QuadPart) {

                        Scb->Header.ValidDataLength.QuadPart = NewAllocationSize;
#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_ALLOC, 0, 0, NewAllocationSize );
                        }
#endif
                    }

                    if (NewAllocationSize < Scb->ValidDataToDisk) {

                        Scb->ValidDataToDisk = NewAllocationSize;

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDD_CHANGE, SCE_FLAG_SET_ALLOC, 0, 0, NewAllocationSize );
                        }
#endif
                    }
                }

                NtfsDeleteAllocation( IrpContext,
                                      FileObject,
                                      Scb,
                                      LlClustersFromBytes( Scb->Vcb, NewAllocationSize ),
                                      MAXLONGLONG,
                                      TRUE,
                                      TRUE );

            }

            //
            //  If this is the paging file then guarantee that the Mcb is fully loaded.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                NtfsPreloadAllocation( IrpContext,
                                       Scb,
                                       0,
                                       LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ));
            }
        }

    try_exit:

        if (PrevAllocationSize != Scb->Header.AllocationSize.QuadPart) {

            //
            //  Mark this file object as modified and with a size change in order to capture
            //  all of the changes to the Fcb.
            //

            SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
            ClearCheckSizeFlag = TRUE;
        }

        //
        //  Always set the file as modified to force a time stamp change.
        //

        if (ARGUMENT_PRESENT( Ccb )) {

            SetFlag( Ccb->Flags,
                     (CCB_FLAG_UPDATE_LAST_MODIFY |
                      CCB_FLAG_UPDATE_LAST_CHANGE |
                      CCB_FLAG_SET_ARCHIVE) );

        } else {

            SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
        }

        //
        //  Now capture any file size changes in this file object back to the Fcb.
        //

        NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

        //
        //  Update the standard information if required.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        //
        //  We know we wrote out any changes to the file size above so clear the
        //  flag in the Scb to check the attribute size.  This will save us from doing
        //  this unnecessarily at cleanup.
        //

        if (ClearCheckSizeFlag) {

            ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update duplicated information.
        //

        NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );

        //
        //  Update the cache manager if needed.
        //

        if (CcIsFileCached( FileObject )) {
            //
            //  We want to checkpoint the transaction if there is one active.
            //

            if (IrpContext->TransactionId != 0) {

                NtfsCheckpointCurrentTransaction( IrpContext );
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_CC_SET_SIZE, SCE_FLAG_SET_ALLOC, *((PULONG)Add2Ptr( FileObject->SectionObjectPointer->SharedCacheMap, 0x6c)), Scb->Header.ValidDataLength.QuadPart, Scb->Header.FileSize.QuadPart );
            }
#endif

            //
            //  Truncate either stream that is cached.
            //  Cachemap better exist or we will skip notifying cc and not potentially.
            //  purge the data section
            //

            ASSERT( FileObject->SectionObjectPointer->SharedCacheMap != NULL );
            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            //
            //  Clear out the write mask on truncates to zero.
            //

#ifdef SYSCACHE
            if ((Scb->Header.FileSize.QuadPart == 0) && FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) &&
                (Scb->ScbType.Data.WriteMask != NULL)) {
                RtlZeroMemory(Scb->ScbType.Data.WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
            }
#endif

            //
            //  Now cleanup the stream we created if there are no more user
            //  handles.
            //

            if ((Scb->CleanupCount == 0) && (Scb->FileObject != NULL)) {
                NtfsDeleteInternalAttributeStream( Scb, FALSE, FALSE );
            }
        }

        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( NtfsSetAllocation );

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsSetAllocationInfo -> %08lx\n", Status) );
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL,
    IN BOOLEAN VcbAcquired
    )

/*++

Routine Description:

    This routine performs the set end of file information function.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Supplies the Ccb for this operation.  Will always be present if the
        Vcb is acquired.  Otherwise we must test for it.

    AcquiredVcb - Indicates if this request has acquired the Vcb, meaning
        do we have duplicate information to update.

Return Value:

    NTSTATUS - The status of the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb = Scb->Fcb;
    BOOLEAN NonResidentPath = TRUE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN FileIsCached = FALSE;

    LONGLONG NewFileSize;
    LONGLONG NewValidDataLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FILE_OBJECT( FileObject );
    ASSERT_IRP( Irp );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsSetEndOfFileInfo...\n") );

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

        NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
    }

    //
    //  Get the new file size and whether this is coming from the lazy writer.
    //

    NewFileSize = ((PFILE_END_OF_FILE_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->EndOfFile.QuadPart;

    //
    //  If this attribute has been 'deleted' then return immediately.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        DebugTrace( -1, Dbg, ("NtfsEndOfFileInfo:  No work to do\n") );

        return STATUS_SUCCESS;
    }

    //
    //  Save the current state of the Scb.
    //

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  If we are called from the cache manager then we want to update the valid data
    //  length if necessary and also perform an update duplicate call if the Vcb
    //  is held.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.AdvanceOnly) {

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb ) && (Scb->CleanupCount == 0)) {
            FsRtlLogSyscacheEvent( Scb, SCE_WRITE, SCE_FLAG_SET_EOF, Scb->Header.ValidDataLength.QuadPart, Scb->ValidDataToDisk, NewFileSize );
        }
#endif

        //
        //  We only have work to do if the file is nonresident.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            //
            //  Assume this is the lazy writer and set NewValidDataLength to
            //  NewFileSize (NtfsWriteFileSizes never goes beyond what's in the
            //  Fcb).
            //

            NewValidDataLength = NewFileSize;
            NewFileSize = Scb->Header.FileSize.QuadPart;

            //
            //  If this file has a compressed stream, then we have to possibly
            //  reduce NewValidDataLength according to dirty data in the opposite
            //  stream (compressed or uncompressed) from which we were called.
            //

#ifdef  COMPRESS_ON_WIRE
            if (Scb->NonpagedScb->SegmentObjectC.SharedCacheMap != NULL) {

                LARGE_INTEGER FlushedValidData;
                PSECTION_OBJECT_POINTERS SegmentObject = &Scb->NonpagedScb->SegmentObject;

                //
                //  Assume the other stream is not cached.
                //

                FlushedValidData.QuadPart = NewValidDataLength;

                //
                //  If we were called for the compressed stream, then get flushed number
                //  for the normal stream.
                //

                if (FileObject->SectionObjectPointer != SegmentObject) {
                    if (SegmentObject->SharedCacheMap != NULL) {
                        FlushedValidData = CcGetFlushedValidData( SegmentObject, FALSE );
                    }

                //
                //  Else if we were called for the normal stream, get the flushed number
                //  for the compressed stream.
                //

                } else {
                    FlushedValidData = CcGetFlushedValidData( &Scb->NonpagedScb->SegmentObjectC, FALSE );
                }

                if (NewValidDataLength > FlushedValidData.QuadPart) {
                    NewValidDataLength = FlushedValidData.QuadPart;
                }
            }
#endif
            //
            //  NtfsWriteFileSizes will trim the new vdl down to filesize if necc. for on disk updates
            //  so we only need to explicitly trim it ourselfs for cases when its really growing
            //  but cc thinks its gone farther than it really has
            //  E.g in the activevacb case when its replaced cc considers the whole page dirty and
            //  advances valid data goal to the end of the page
            //
            //  3 pts protect us here - cc always trims valid data goal when we shrink so any
            //  callbacks indicate real data from this size file
            //  We inform cc of the new vdl on all unbuffered writes so eventually he will
            //  call us back to update for new disk sizes
            //  if mm and cc are active in a file we will let mm
            //  flush all pages beyond vdl. For the boundary page
            //  cc can flush it but we will move vdl fwd at that time as well
            //

            if ((Scb->Header.ValidDataLength.QuadPart < NewFileSize) &&
                (NewValidDataLength > Scb->Header.ValidDataLength.QuadPart)) {

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_EOF, NewValidDataLength, 0, Scb->Header.ValidDataLength.QuadPart );
                }
#endif

                NewValidDataLength = Scb->Header.ValidDataLength.QuadPart;
            } //  endif advancing VDL

            //
            //  Always call writefilesizes in case on disk VDL is less than the
            //  in memory one
            //

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &NewValidDataLength,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  If we acquired the Vcb then do the update duplicate if necessary.
        //

        if (VcbAcquired) {

            //
            //  Now capture any file size changes in this file object back to the Fcb.
            //

            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

            //
            //  Update the standard information if required.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                NtfsUpdateStandardInformation( IrpContext, Fcb );
                ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
            }

            NtfsCheckpointCurrentTransaction( IrpContext );

            //
            //  Update duplicated information.
            //

            NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );
        }

        //
        //  We know the file size for this Scb is now correct on disk.
        //

        NtfsAcquireFsrtlHeader( Scb );
        ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        NtfsReleaseFsrtlHeader( Scb );

    } else {

        if (Ccb != NULL) {

            //
            //  Remember the source info flags in the Ccb.
            //

            IrpContext->SourceInfo = Ccb->UsnSourceInfo;
        }

        //
        //  Check for a valid input value for the file size.
        //

        if ((ULONGLONG)NewFileSize > MAXFILESIZE) {

            Status = STATUS_INVALID_PARAMETER;
            DebugTrace( -1, Dbg, ("NtfsSetEndOfFileInfo: Invalid file size -> %08lx\n", Status) );
            return Status;
        }

        //
        //  Do work to prepare for shrinking file if necc.
        //

        if (NewFileSize < Scb->Header.FileSize.QuadPart) {

            Status = NtfsPrepareToShrinkFileSize( IrpContext, FileObject, Scb, NewFileSize );
            if (Status != STATUS_SUCCESS) {

                DebugTrace( -1, Dbg, ("NtfsSetEndOfFileInfo -> %08lx\n", Status) );
                return Status;
            }
        }

        //
        //  Check if we really are changing the file size.
        //

        if (Scb->Header.FileSize.QuadPart != NewFileSize) {

            FileSizeChanged = TRUE;

            //
            //  Post the FileSize change to the Usn Journal
            //

            NtfsPostUsnChange( IrpContext,
                               Scb,
                               ((NewFileSize > Scb->Header.FileSize.QuadPart) ?
                                 USN_REASON_DATA_EXTEND :
                                 USN_REASON_DATA_TRUNCATION) );
        }

        //
        //  It is extremely expensive to make this call on a file that is not
        //  cached, and Ntfs has suffered stack overflows in addition to massive
        //  time and disk I/O expense (CcZero data on user mapped files!).  Therefore,
        //  if no one has the file cached, we cache it here to make this call cheaper.
        //
        //  Don't create the stream file if called from FsRtlSetFileSize (which sets
        //  IRP_PAGING_IO) because mm is in the process of creating a section.
        //

        if (FileSizeChanged &&
            (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL)) {

            FileIsCached = CcIsFileCached( FileObject );

            if (!FileIsCached &&
                !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                !FlagOn( Irp->Flags, IRP_PAGING_IO )) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   Scb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[SETENDOFFILEINFO_FILE_NUMBER] );
                FileIsCached = TRUE;
            }
        }

        //
        //  If this is a resident attribute we will try to keep it resident.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            if (FileSizeChanged) {

                //
                //  If the new file size is larger than a file record then convert
                //  to non-resident and use the non-resident code below.  Otherwise
                //  call ChangeAttributeValue which may also convert to nonresident.
                //

                NtfsInitializeAttributeContext( &AttrContext );

                try {

                    NtfsLookupAttributeForScb( IrpContext,
                                               Scb,
                                               NULL,
                                               &AttrContext );

                    //
                    //  If we are growing out of the file record then force the non-resident
                    //  path.  We especially need this for sparse files to make sure it
                    //  stays either fully allocated or fully deallocated.  QuadAlign the new
                    //  size to handle the close boundary cases.
                    //

                    FileRecord = NtfsContainingFileRecord( &AttrContext );

                    ASSERT( FileRecord->FirstFreeByte > Scb->Header.FileSize.LowPart );

                    if ((FileRecord->FirstFreeByte - Scb->Header.FileSize.QuadPart + QuadAlign( NewFileSize )) >=
                        Scb->Vcb->BytesPerFileRecordSegment) {

                        NtfsConvertToNonresident( IrpContext,
                                                  Fcb,
                                                  NtfsFoundAttribute( &AttrContext ),
                                                  (BOOLEAN) (!FileIsCached),
                                                  &AttrContext );

                    } else {

                        ULONG AttributeOffset;

                        //
                        //  We are sometimes called by MM during a create section, so
                        //  for right now the best way we have of detecting a create
                        //  section is IRP_PAGING_IO being set, as in FsRtlSetFileSizes.
                        //

                        if ((ULONG) NewFileSize > Scb->Header.FileSize.LowPart) {

                            AttributeOffset = Scb->Header.ValidDataLength.LowPart;

                        } else {

                            AttributeOffset = (ULONG) NewFileSize;
                        }

                        NtfsChangeAttributeValue( IrpContext,
                                                  Fcb,
                                                  AttributeOffset,
                                                  NULL,
                                                  (ULONG) NewFileSize - AttributeOffset,
                                                  TRUE,
                                                  FALSE,
                                                  (BOOLEAN) (!FileIsCached),
                                                  FALSE,
                                                  &AttrContext );

                        Scb->Header.FileSize.QuadPart = NewFileSize;

                        //
                        //  If the file went non-resident, then the allocation size in
                        //  the Scb is correct.  Otherwise we quad-align the new file size.
                        //

                        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                            Scb->Header.AllocationSize.LowPart = QuadAlign( Scb->Header.FileSize.LowPart );
                            Scb->Header.ValidDataLength.QuadPart = NewFileSize;
                            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

#ifdef SYSCACHE_DEBUG
                            if (ScbIsBeingLogged( Scb )) {
                                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_EOF, 0, 0, NewFileSize );
                            }
#endif

                        }

                        NonResidentPath = FALSE;
                    }

                } finally {

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                }

            } else {

                NonResidentPath = FALSE;
            }
        }

        //
        //  We now test if we need to modify the non-resident Eof.  We will
        //  do this in two cases.  Either we're converting from resident in
        //  two steps or the attribute was initially non-resident.  We can ignore
        //  this step if not changing the file size.
        //

        if (NonResidentPath) {

            //
            //  Now determine where the new file size lines up with the
            //  current file layout.  The two cases we need to consider are
            //  where the new file size is less than the current file size and
            //  valid data length, in which case we need to shrink them.
            //  Or we new file size is greater than the current allocation,
            //  in which case we need to extend the allocation to match the
            //  new file size.
            //

            if (NewFileSize > Scb->Header.AllocationSize.QuadPart) {

                DebugTrace( 0, Dbg, ("Adding allocation to file\n") );

                //
                //  Add either the true disk allocation or add a hole for a sparse
                //  file.
                //

                if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

                    LONGLONG NewAllocationSize = NewFileSize;

                    //
                    //  If there is a compression unit then we could be in the process of
                    //  decompressing.  Allocate precisely in this case because we don't
                    //  want to leave any holes.  Specifically the user may have truncated
                    //  the file and is now regenerating it yet the clear compression operation
                    //  has already passed this point in the file (and dropped all resources).
                    //  No one will go back to cleanup the allocation if we leave a hole now.
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
                        (Scb->CompressionUnit != 0)) {

                        ASSERT( FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ));
                        NewAllocationSize += Scb->CompressionUnit - 1;
                        ((PLARGE_INTEGER) &NewAllocationSize)->LowPart &= ~(Scb->CompressionUnit - 1);
                    }

                    NtfsAddAllocation( IrpContext,
                                       FileObject,
                                       Scb,
                                       LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ),
                                       LlClustersFromBytes(Scb->Vcb, (NewAllocationSize - Scb->Header.AllocationSize.QuadPart)),
                                       FALSE,
                                       NULL );

                } else {

                    NtfsAddSparseAllocation( IrpContext,
                                             FileObject,
                                             Scb,
                                             Scb->Header.AllocationSize.QuadPart,
                                             NewFileSize - Scb->Header.AllocationSize.QuadPart );
                }

            } else {

                LONGLONG DeletePoint;

                //
                //  If this is a sparse file we actually want to leave a hole between
                //  the end of the file and the allocation size.
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
                    (NewFileSize < Scb->Header.FileSize.QuadPart) &&
                    ((DeletePoint = NewFileSize + Scb->CompressionUnit - 1) < Scb->Header.AllocationSize.QuadPart)) {

                    ((PLARGE_INTEGER) &DeletePoint)->LowPart &= ~(Scb->CompressionUnit - 1);

                    ASSERT( DeletePoint < Scb->Header.AllocationSize.QuadPart );

                    NtfsDeleteAllocation( IrpContext,
                                          FileObject,
                                          Scb,
                                          LlClustersFromBytesTruncate( Scb->Vcb, DeletePoint ),
                                          LlClustersFromBytesTruncate( Scb->Vcb, Scb->Header.AllocationSize.QuadPart ) - 1,
                                          TRUE,
                                          TRUE );
                }

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
            }

            NewValidDataLength = Scb->Header.ValidDataLength.QuadPart;

            //
            //  If this is a paging file, let the whole thing be valid
            //  so that we don't end up zeroing pages!  Also, make sure
            //  we really write this into the file.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                VCN AllocatedVcns;

                AllocatedVcns = Int64ShraMod32(Scb->Header.AllocationSize.QuadPart, Scb->Vcb->ClusterShift);

                Scb->Header.ValidDataLength.QuadPart =
                NewValidDataLength = NewFileSize;

                //
                //  If this is the paging file then guarantee that the Mcb is fully loaded.
                //

                NtfsPreloadAllocation( IrpContext, Scb, 0, AllocatedVcns );
            }

            if (NewFileSize < NewValidDataLength) {

                Scb->Header.ValidDataLength.QuadPart =
                NewValidDataLength = NewFileSize;

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                   FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_EOF, 0, 0, NewFileSize );
                }
#endif
            }

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                (NewFileSize < Scb->ValidDataToDisk)) {

                Scb->ValidDataToDisk = NewFileSize;

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_VDD_CHANGE, SCE_FLAG_SET_EOF, 0, 0, NewFileSize );
                }
#endif

            }

            Scb->Header.FileSize.QuadPart = NewFileSize;

            //
            //  Call our common routine to modify the file sizes.  We are now
            //  done with NewFileSize and NewValidDataLength, and we have
            //  PagingIo + main exclusive (so no one can be working on this Scb).
            //  NtfsWriteFileSizes uses the sizes in the Scb, and this is the
            //  one place where in Ntfs where we wish to use a different value
            //  for ValidDataLength.  Therefore, we save the current ValidData
            //  and plug it with our desired value and restore on return.
            //

            ASSERT( NewFileSize == Scb->Header.FileSize.QuadPart );
            ASSERT( NewValidDataLength == Scb->Header.ValidDataLength.QuadPart );
            NtfsVerifySizes( &Scb->Header );
            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                BooleanFlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ),
                                TRUE,
                                TRUE );
        }

        //
        //  If the file size changed then mark this file object as having changed the size.
        //

        if (FileSizeChanged) {

            SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
        }

        //
        //  Always mark the data stream as modified.
        //

        if (ARGUMENT_PRESENT( Ccb )) {

            SetFlag( Ccb->Flags,
                     (CCB_FLAG_UPDATE_LAST_MODIFY |
                      CCB_FLAG_UPDATE_LAST_CHANGE |
                      CCB_FLAG_SET_ARCHIVE) );

        } else {

            SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
        }

        //
        //  Now capture any file size changes in this file object back to the Fcb.
        //

        NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, VcbAcquired );

        //
        //  Update the standard information if required.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

            NtfsUpdateStandardInformation( IrpContext, Fcb );
            ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        }

        //
        //  We know we wrote out any changes to the file size above so clear the
        //  flag in the Scb to check the attribute size.  This will save us from doing
        //  this unnecessarily at cleanup.
        //

        if (FileSizeChanged) {

            ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        }

        NtfsCheckpointCurrentTransaction( IrpContext );

        //
        //  Update duplicated information.
        //

        if (VcbAcquired) {

            NtfsUpdateFileDupInfo( IrpContext, Fcb, Ccb );
        }

        if (CcIsFileCached( FileObject )) {

            //
            //  We want to checkpoint the transaction if there is one active.
            //

            if (IrpContext->TransactionId != 0) {

                NtfsCheckpointCurrentTransaction( IrpContext );
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_CC_SET_SIZE, SCE_FLAG_SET_EOF, *((PULONG)Add2Ptr( FileObject->SectionObjectPointer->SharedCacheMap, 0x6c)), Scb->Header.ValidDataLength.QuadPart, Scb->Header.FileSize.QuadPart );
            }
#endif

            //
            //  Cache map should still exist or we won't purge the data section
            //

            ASSERT( FileObject->SectionObjectPointer->SharedCacheMap != NULL );
            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            //
            //  Clear out the write mask on truncates to zero.
            //

#ifdef SYSCACHE
            if ((Scb->Header.FileSize.QuadPart == 0) && FlagOn(Scb->ScbState, SCB_STATE_SYSCACHE_FILE) &&
                (Scb->ScbType.Data.WriteMask != NULL)) {
                RtlZeroMemory(Scb->ScbType.Data.WriteMask, (((0x2000000) / PAGE_SIZE) / 8));
            }
#endif

            //
            //  Now cleanup the stream we created if there are no more user
            //  handles.
            //

            if ((Scb->CleanupCount == 0) && (Scb->FileObject != NULL)) {
                NtfsDeleteInternalAttributeStream( Scb, FALSE, FALSE );
            }
        }
    }

    Status = STATUS_SUCCESS;

    DebugTrace( -1, Dbg, ("NtfsSetEndOfFileInfo -> %08lx\n", Status) );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NtfsSetValidDataLengthInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set valid data length information function.
    Notes: we interact with CC but do not initiate caching ourselves. This is
    only possible if the file is not mapped so we can do purges on the section.

    Also the filetype check that restricts this to fileopens only is done in the
    CommonSetInformation call.

Arguments:

    FileObject - Supplies the file object being processed

    Irp - Supplies the Irp being processed

    Scb - Supplies the Scb for the file/directory being modified

    Ccb - Ccb attached to the file. Contains cached privileges of opener


Return Value:

    NTSTATUS - The status of the operation

--*/

{
    LONGLONG NewValidDataLength;
    LONGLONG NewFileSize;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  User must have manage volume privilege to explicitly tweak the VDL
    //

    if (!FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS)) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  We don't support this call for compressed or sparse files
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE)) {
        return STATUS_INVALID_PARAMETER;
    }

    NewValidDataLength = ((PFILE_VALID_DATA_LENGTH_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->ValidDataLength.QuadPart;
    NewFileSize = Scb->Header.FileSize.QuadPart;

    //
    //  VDL can only move forward
    //

    if ((NewValidDataLength < Scb->Header.ValidDataLength.QuadPart) ||
        (NewValidDataLength > NewFileSize) ||
        (NewValidDataLength < 0)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We only have work to do if the file is nonresident.
    //

    if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

        //
        //  We can't change the VDL without being able to purge. This should stay
        //  constant since we own everything exclusive
        //

        if (!MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject, &Li0 )) {
            return STATUS_USER_MAPPED_FILE;
        }

        NtfsSnapshotScb( IrpContext, Scb );

        //
        //  Flush old data out and purge the cache so we can see new data
        //

        NtfsFlushAndPurgeScb( IrpContext, Scb, NULL );

        //
        //  update the scb
        //

        Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
            Scb->ValidDataToDisk = NewValidDataLength;
        }

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_SET_VDL, 0, 0, NewValidDataLength );
        }
#endif

        ASSERT( IrpContext->CleanupStructure != NULL );
        NtfsWriteFileSizes( IrpContext,
                            Scb,
                            &NewValidDataLength,
                            TRUE,
                            TRUE,
                            TRUE );

        //
        //  Now capture any file size changes in this file object back to the Fcb.
        //

        NtfsUpdateScbFromFileObject( IrpContext, IrpSp->FileObject, Scb, FALSE );

        //
        //  Inform CC of the new values
        //

        NtfsSetBothCacheSizes( IrpSp->FileObject,
                               (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                               Scb );

        //
        //  We know the file size for this Scb is now correct on disk.
        //

        NtfsAcquireFsrtlHeader( Scb );
        ClearFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Post a usn record
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_OVERWRITE );
        NtfsWriteUsnJournalChanges( IrpContext );
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
NtfsCheckScbForLinkRemoval (
    IN PSCB Scb,
    OUT PSCB *BatchOplockScb,
    OUT PULONG BatchOplockCount
    )

/*++

Routine Description:

    This routine is called to check if a link to an open Scb may be
    removed for rename.  We walk through all the children and
    verify that they have no user opens.

Arguments:

    Scb - Scb whose children are to be examined.

    BatchOplockScb - Address to store Scb which may have a batch oplock.

    BatchOplockCount - Number of files which have batch oplocks on this
        pass through the directory tree.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the link can be removed,
               STATUS_ACCESS_DENIED otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSCB NextScb;
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckScbForLinkRemoval:  Entered\n") );

    //
    //  Initialize the batch oplock state.
    //

    *BatchOplockCount = 0;
    *BatchOplockScb = NULL;

    //
    //  If this is a directory file and we are removing a link,
    //  we need to examine its descendents.  We may not remove a link which
    //  may be an ancestor path component of any open file.
    //

    //
    //  First look for any descendents with a non-zero unclean count.
    //

    NextScb = Scb;

    while ((NextScb = NtfsGetNextScb( NextScb, Scb )) != NULL) {

        //
        //  Stop if there are open handles.  If there is a batch oplock on
        //  this file then we will try to break the batch oplock.  In this
        //  pass we will just count the number of files with batch oplocks
        //  and remember the first one we encounter.
        //
        //  Skip over the Scb's with a zero cleanup count as we would otherwise
        //  fail this if we encounter them.
        //

        if (NextScb->CleanupCount != 0) {

            if ((NextScb->AttributeTypeCode == $DATA) &&
                (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                FsRtlCurrentBatchOplock( &NextScb->ScbType.Data.Oplock )) {

                *BatchOplockCount += 1;

                if (*BatchOplockScb == NULL) {

                    *BatchOplockScb = NextScb;
                    Status = STATUS_PENDING;
                }

            } else {

                Status = STATUS_ACCESS_DENIED;
                DebugTrace( 0, Dbg, ("NtfsCheckScbForLinkRemoval:  Directory to rename has open children\n") );

                break;
            }
        }
    }

    //
    //
    //  We know there are no opens below this point.  We will remove any prefix
    //  entries later.
    //

    DebugTrace( -1, Dbg, ("NtfsCheckScbForLinkRemoval:  Exit -> %08lx\n") );

    return Status;
}


//
//  Local support routine
//

VOID
NtfsFindTargetElements (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT TargetFileObject,
    IN PSCB ParentScb,
    OUT PSCB *TargetParentScb,
    OUT PUNICODE_STRING FullTargetFileName,
    OUT PUNICODE_STRING TargetFileName
    )

/*++

Routine Description:

    This routine determines the target directory for the rename and the
    target link name.  If these is a target file object, we use that to
    find the target.  Otherwise the target is the same directory as the
    source.

Arguments:

    TargetFileObject - This is the file object which describes the target
        for the link operation.

    ParentScb - This is current directory for the link.

    TargetParentScb - This is the location to store the parent of the target.

    FullTargetFileName - This is a pointer to a unicode string which will point
        to the name from the root.  We clear this if there is no full name
        available.

    TargetFileName - This is a pointer to a unicode string which will point to
        the target name on exit.

Return Value:

    BOOLEAN - TRUE if there is no work to do, FALSE otherwise.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFindTargetElements:  Entered\n") );

    //
    //  We need to find the target parent directory, target file and target
    //  name for the new link.  These three pieces of information allow
    //  us to see if the link already exists.
    //
    //  Check if we have a file object for the target.
    //

    if (TargetFileObject != NULL) {

        PVCB TargetVcb;
        PFCB TargetFcb;
        PCCB TargetCcb;

        USHORT PreviousLength;
        USHORT LastFileNameOffset;

        //
        //  The target directory is given by the TargetFileObject.
        //  The name for the link is contained in the TargetFileObject.
        //
        //  The target must be a user directory and must be on the
        //  current Vcb.
        //

        if ((NtfsDecodeFileObject( IrpContext,
                                   TargetFileObject,
                                   &TargetVcb,
                                   &TargetFcb,
                                   TargetParentScb,
                                   &TargetCcb,
                                   TRUE ) != UserDirectoryOpen) ||

            ((ParentScb != NULL) &&
             (TargetVcb != ParentScb->Vcb))) {

            DebugTrace( -1, Dbg, ("NtfsFindTargetElements:  Target file object is invalid\n") );

            NtfsRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER, NULL, NULL );
        }

        //
        //  Temporarily set the file name to point to the full buffer.
        //

        LastFileNameOffset = PreviousLength = TargetFileObject->FileName.Length;

        TargetFileObject->FileName.Length = TargetFileObject->FileName.MaximumLength;

        *FullTargetFileName = TargetFileObject->FileName;

        //
        //  If the first character at the final component is a backslash, move the
        //  offset ahead by 2.
        //

        if (TargetFileObject->FileName.Buffer[LastFileNameOffset / sizeof( WCHAR )] == L'\\') {

            LastFileNameOffset += sizeof( WCHAR );
        }

        NtfsBuildLastFileName( IrpContext,
                               TargetFileObject,
                               LastFileNameOffset,
                               TargetFileName );

        //
        //  Restore the file object length.
        //

        TargetFileObject->FileName.Length = PreviousLength;

    //
    //  Otherwise the rename occurs in the current directory.  The directory
    //  is the parent of this Fcb, the name is stored in a Rename buffer.
    //

    } else {

        PFILE_RENAME_INFORMATION Buffer;

        Buffer = IrpContext->OriginatingIrp->AssociatedIrp.SystemBuffer;

        *TargetParentScb = ParentScb;

        TargetFileName->MaximumLength =
        TargetFileName->Length = (USHORT)Buffer->FileNameLength;
        TargetFileName->Buffer = (PWSTR) &Buffer->FileName;

        FullTargetFileName->Length =
        FullTargetFileName->MaximumLength = 0;
        FullTargetFileName->Buffer = NULL;
    }

    DebugTrace( -1, Dbg, ("NtfsFindTargetElements:  Exit\n") );

    return;
}


BOOLEAN
NtfsCheckLinkForNewLink (
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING NewLinkName,
    OUT PULONG LinkFlags
    )

/*++

Routine Description:

    This routine checks the source and target directories and files.
    It determines whether the target link needs to be removed and
    whether the target link spans the same parent and file as the
    source link.  This routine may determine that there
    is absolutely no work remaining for this link operation.  This is true
    if the desired link already exists.

Arguments:

    Fcb - This is the Fcb for the link which is being renamed.

    FileNameAttr - This is the file name attribute for the matching link
        on the disk.

    FileReference - This is the file reference for the matching link found.

    NewLinkName - This is the name to use for the rename.

    LinkFlags - Address of flags field to store whether the source link and target
        link traverse the same directory and file.

Return Value:

    BOOLEAN - TRUE if there is no work to do, FALSE otherwise.

--*/

{
    BOOLEAN NoWorkToDo = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckLinkForNewLink:  Entered\n") );

    //
    //  Check if the file references match.
    //

    if (NtfsEqualMftRef( &FileReference, &Fcb->FileReference )) {

        SetFlag( *LinkFlags, TRAVERSE_MATCH );
    }

    //
    //  We need to determine if we have an exact match for the link names.
    //

    if (RtlEqualMemory( FileNameAttr->FileName,
                        NewLinkName->Buffer,
                        NewLinkName->Length )) {

        SetFlag( *LinkFlags, EXACT_CASE_MATCH );
    }

    //
    //  We now have to decide whether we will be removing the target link.
    //  The following conditions must hold for us to preserve the target link.
    //
    //      1 - The target link connects the same directory to the same file.
    //
    //      2 - The names are an exact case match.
    //

    if (FlagOn( *LinkFlags, TRAVERSE_MATCH | EXACT_CASE_MATCH ) == (TRAVERSE_MATCH | EXACT_CASE_MATCH)) {

        NoWorkToDo = TRUE;
    }

    DebugTrace( -1, Dbg, ("NtfsCheckLinkForNewLink:  Exit\n") );

    return NoWorkToDo;
}


//
//  Local support routine
//

VOID
NtfsCheckLinkForRename (
    IN PFCB Fcb,
    IN PLCB Lcb,
    IN PFILE_NAME FileNameAttr,
    IN FILE_REFERENCE FileReference,
    IN PUNICODE_STRING TargetFileName,
    IN BOOLEAN IgnoreCase,
    IN OUT PULONG RenameFlags
    )

/*++

Routine Description:

    This routine checks the source and target directories and files.
    It determines whether the target link needs to be removed and
    whether the target link spans the same parent and file as the
    source link.  We also determine if the new link name is an exact case
    match for the existing link name.  The booleans indicating which links
    to remove or add have already been initialized to the default values.

Arguments:

    Fcb - This is the Fcb for the link which is being renamed.

    Lcb - This is the link being renamed.

    FileNameAttr - This is the file name attribute for the matching link
        on the disk.

    FileReference - This is the file reference for the matching link found.

    TargetFileName - This is the name to use for the rename.

    IgnoreCase - Indicates if the user is case sensitive.

    RenameFlags - Flag field which indicates which updates to perform.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckLinkForRename:  Entered\n") );

    //
    //  Check if the file references match.
    //

    if (NtfsEqualMftRef( &FileReference, &Fcb->FileReference )) {

        SetFlag( *RenameFlags, TRAVERSE_MATCH );
    }

    //
    //  We need to determine if we have an exact match between the desired name
    //  and the current name for the link.  We already know the length are the same.
    //

    if (RtlEqualMemory( FileNameAttr->FileName,
                        TargetFileName->Buffer,
                        TargetFileName->Length )) {

        SetFlag( *RenameFlags, EXACT_CASE_MATCH );
    }

    //
    //  If this is a traverse match (meaning the desired link and the link
    //  being replaced connect the same directory to the same file) we check
    //  if we can leave the link on the file.
    //
    //  At the end of the rename, there must be an Ntfs name or hard link
    //  which matches the target name exactly.
    //

    if (FlagOn( *RenameFlags, TRAVERSE_MATCH )) {

        //
        //  If we are in the same directory and are renaming between Ntfs and Dos
        //  links then don't remove the link twice.
        //

        if (!FlagOn( *RenameFlags, MOVE_TO_NEW_DIR )) {

            //
            //  If We are renaming from between primary links then don't remove the
            //  source.  It is removed with the target.
            //

            if ((Lcb->FileNameAttr->Flags != 0) && (FileNameAttr->Flags != 0)) {

                ClearFlag( *RenameFlags, ACTIVELY_REMOVE_SOURCE_LINK );
                SetFlag( *RenameFlags, OVERWRITE_SOURCE_LINK );

                //
                //  If this is an exact case match then don't remove the source at all.
                //

                if (FlagOn( *RenameFlags, EXACT_CASE_MATCH )) {

                    ClearFlag( *RenameFlags, REMOVE_SOURCE_LINK );
                }

            //
            //  If we are changing the case of a link only, then don't remove the link twice.
            //

            } else if (RtlEqualMemory( Lcb->ExactCaseLink.LinkName.Buffer,
                                       FileNameAttr->FileName,
                                       Lcb->ExactCaseLink.LinkName.Length )) {

                SetFlag( *RenameFlags, OVERWRITE_SOURCE_LINK );
                ClearFlag( *RenameFlags, ACTIVELY_REMOVE_SOURCE_LINK );
            }
        }

        //
        //  If the names match exactly we can reuse the links if we don't have a
        //  conflict with the name flags.
        //

        if (FlagOn( *RenameFlags, EXACT_CASE_MATCH ) &&
            (FlagOn( *RenameFlags, OVERWRITE_SOURCE_LINK ) ||
             !IgnoreCase ||
             !FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ))) {

            //
            //  Otherwise we are renaming hard links or this is a Posix opener.
            //

            ClearFlag( *RenameFlags, REMOVE_TARGET_LINK | ADD_TARGET_LINK );
        }
    }

    //
    //  The non-traverse case is already initialized.
    //

    DebugTrace( -1, Dbg, ("NtfsCheckLinkForRename:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsCleanupLinkForRemoval (
    IN PFCB PreviousFcb,
    IN PSCB ParentScb,
    IN BOOLEAN ExistingFcb
    )

/*++

Routine Description:

    This routine does the cleanup on a file/link which is the target
    of either a rename or set link operation.

Arguments:

    PreviousFcb - Address to store the Fcb for the file whose link is
        being removed.

    ParentScb - This is the parent for the link being removed.

    ExistingFcb - Address to store whether this Fcb already existed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCleanupLinkForRemoval:  Entered\n") );

    //
    //  If the Fcb existed, we remove all of the prefix entries for it which
    //  belong to the parent we are given.
    //

    if (ExistingFcb) {

        PLIST_ENTRY Links;
        PLCB ThisLcb;

        for (Links = PreviousFcb->LcbQueue.Flink;
             Links != &PreviousFcb->LcbQueue;
             Links = Links->Flink ) {

            ThisLcb = CONTAINING_RECORD( Links,
                                         LCB,
                                         FcbLinks );

            if (ThisLcb->Scb == ParentScb) {

                ASSERT( NtfsIsExclusiveScb( ThisLcb->Scb ) );
                NtfsRemovePrefix( ThisLcb );
            }

            //
            //  Remove any hash table entries for this Lcb.
            //

            NtfsRemoveHashEntriesForLcb( ThisLcb );

        } // End for each Lcb of Fcb
    }

    DebugTrace( -1, Dbg, ("NtfsCleanupLinkForRemoval:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsUpdateFcbFromLinkRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN UNICODE_STRING FileName,
    IN UCHAR FileNameFlags
    )

/*++

Routine Description:

    This routine is called to update the in-memory part of a link which
    has been removed from a file.  We find the Lcb's for the links and
    mark them as deleted and removed.

Arguments:

    ParentScb - Scb for the directory the was removed from.

    ParentScb - This is the Scb for the new directory.

    Fcb - The Fcb for the file whose link is being renamed.

    FileName - File name for link being removed.

    FileNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB Lcb;
    PLCB SplitPrimaryLcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFcbFromLinkRemoval:  Entered\n") );

    SplitPrimaryLcb = NULL;

    //
    //  Find the Lcb for the link which was removed.
    //

    Lcb = NtfsCreateLcb( IrpContext,
                         ParentScb,
                         Fcb,
                         FileName,
                         FileNameFlags,
                         NULL );

    //
    //  If this is a split primary, we need to find the name flags for
    //  the Lcb.
    //

    if (LcbSplitPrimaryLink( Lcb )) {

        SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                (UCHAR) LcbSplitPrimaryComplement( Lcb ));
    }

    //
    //  Mark any Lcb's we have as deleted and removed.
    //

    SetFlag( Lcb->LcbState, (LCB_STATE_DELETE_ON_CLOSE | LCB_STATE_LINK_IS_GONE) );

    if (SplitPrimaryLcb) {

        SetFlag( SplitPrimaryLcb->LcbState,
                 (LCB_STATE_DELETE_ON_CLOSE | LCB_STATE_LINK_IS_GONE) );
    }

    DebugTrace( -1, Dbg, ("NtfsUpdateFcbFromLinkRemoval:  Exit\n") );

    return;
}


//
//  Local support routine
//

VOID
NtfsReplaceLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR FileNameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine is called to create the in-memory part of a link in a new
    directory.

Arguments:

    ParentScb - Scb for the directory the link is being created in.

    Fcb - The Fcb for the file whose link is being created.

    NewLinkName - Name for the new component.

    FileNameFlags - These are the flags to use for the new link.

    PrevLinkName - File name for link being removed.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB TraverseLcb;
    PLCB SplitPrimaryLcb = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateLinkInNewDir:  Entered\n") );

    SplitPrimaryLcb = NULL;

    //
    //  Build the name for the traverse link and call strucsup to
    //  give us an Lcb.
    //

    TraverseLcb = NtfsCreateLcb( IrpContext,
                                 ParentScb,
                                 Fcb,
                                 *PrevLinkName,
                                 PrevLinkNameFlags,
                                 NULL );

    //
    //  If this is a split primary, we need to find the name flags for
    //  the Lcb.
    //

    if (LcbSplitPrimaryLink( TraverseLcb )) {

        SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));
    }

    //
    //  We now need only to rename and combine any existing Lcb's.
    //

    NtfsRenameLcb( IrpContext,
                   TraverseLcb,
                   NewLinkName,
                   FileNameFlags,
                   FALSE );

    if (SplitPrimaryLcb != NULL) {

        NtfsRenameLcb( IrpContext,
                       SplitPrimaryLcb,
                       NewLinkName,
                       FileNameFlags,
                       FALSE );

        NtfsCombineLcbs( IrpContext,
                         TraverseLcb,
                         SplitPrimaryLcb );

        NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateLinkInNewDir:  Exit\n") );

    return;
}


//
//  Local support routine.
//

VOID
NtfsMoveLinkToNewDir (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NewFullLinkName,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR NewLinkNameFlags,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine is called to move the in-memory part of a link to a new
    directory.  We move the link involved and its primary link partner if
    it exists.
    
    LCBs are not rolled back so after its called - no exceptions can occur that would
    cause rollback. Because of this we checkpoint the current transaction before the 2nd 
    phase of modification when all allocations have already been done. 

Arguments:

    NewFullLinkName - This is the full name for the new link from the root.

    NewLinkName - This is the last component name only.

    NewLinkNameFlags - These are the flags to use for the new link.

    ParentScb - This is the Scb for the new directory.

    Fcb - The Fcb for the file whose link is being renamed.

    Lcb - This is the Lcb which is the base of the rename.

    RenameFlags - Flag field indicating the type of operations to perform
        on file name links.

    PrevLinkName - File name for link being removed.  Only meaningful here
        if this is a traverse match and there are remaining Lcbs for the
        previous link.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    PLCB TraverseLcb = NULL;
    PLCB SplitPrimaryLcb = NULL;
    BOOLEAN SplitSourceLcb = FALSE;

    UNICODE_STRING TargetDirectoryName;
    UNICODE_STRING SplitLinkName;

    UCHAR SplitLinkNameFlags = NewLinkNameFlags;
    BOOLEAN Found;

    PFILE_NAME FileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;

    ULONG Pass;
    BOOLEAN CheckBufferOnly;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMoveLinkToNewDir:  Entered\n") );

    //
    //  Use a try-finally to perform cleanup.
    //

    try {

        //
        //  Construct the unicode string for the parent directory.
        //

        TargetDirectoryName = *NewFullLinkName;
        TargetDirectoryName.Length -= NewLinkName->Length;

        if (TargetDirectoryName.Length > sizeof( WCHAR )) {

            TargetDirectoryName.Length -= sizeof( WCHAR );
        }

        //  If the link being moved is a split primary link, we need to find
        //  its other half.
        //

        if (LcbSplitPrimaryLink( Lcb )) {

            SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                    (UCHAR) LcbSplitPrimaryComplement( Lcb ));
            SplitSourceLcb = TRUE;

            //
            //  If we found an existing Lcb we have to update its name as well.  We may be
            //  able to use the new name used for the Lcb passed in.  However we must check
            //  that we don't overwrite a DOS name with an NTFS only name.
            //

            if (SplitPrimaryLcb &&
                (SplitPrimaryLcb->FileNameAttr->Flags == FILE_NAME_DOS) &&
                (NewLinkNameFlags == FILE_NAME_NTFS)) {

                //
                //  Lookup the dos only name on disk.
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  Walk through the names for this entry.  There better
                //  be one which is not a DOS-only name.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &AttrContext );

                while (Found) {

                    FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                    if (FileName->Flags == FILE_NAME_DOS) { break; }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Fcb,
                                                           $FILE_NAME,
                                                           &AttrContext );
                }

                //
                //  We should have found the entry.
                //

                if (!Found) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                //
                //  Now build the component name.
                //

                SplitLinkName.Buffer = FileName->FileName;
                SplitLinkName.MaximumLength =
                SplitLinkName.Length = FileName->FileNameLength * sizeof( WCHAR );
                SplitLinkNameFlags = FILE_NAME_DOS;

            } else {

                SplitLinkName = *NewLinkName;
            }
        }

        //
        //  If we removed or reused a traverse link, we need to check if there is
        //  an Lcb for it.
        //

        if (FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK | REUSE_TRAVERSE_LINK )) {

            //
            //  Build the name for the traverse link and call strucsup to
            //  give us an Lcb.
            //

            if (FlagOn( RenameFlags, EXACT_CASE_MATCH )) {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *NewLinkName,
                                             PrevLinkNameFlags,
                                             NULL );

            } else {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *PrevLinkName,
                                             PrevLinkNameFlags,
                                             NULL );
            }

            if (FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK )) {

                //
                //  If this is a split primary, we need to find the name flags for
                //  the Lcb.
                //

                if (LcbSplitPrimaryLink( TraverseLcb )) {

                    SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                            (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));
                }
            }
        }

        //
        //  Now move and combine the Lcbs.  We will do this in two passes.  One will allocate buffers
        //  of sufficient size.  The other will store the names in.
        //

        Pass = 0;
        CheckBufferOnly = TRUE;
        do {

            //
            //  Start with the Lcb used for the rename.
            //

            NtfsMoveLcb( IrpContext,
                         Lcb,
                         ParentScb,
                         Fcb,
                         &TargetDirectoryName,
                         NewLinkName,
                         NewLinkNameFlags,
                         CheckBufferOnly );

            //
            //  Next do the split primary if from the source file or the target.
            //

            if (SplitPrimaryLcb && SplitSourceLcb) {

                NtfsMoveLcb( IrpContext,
                             SplitPrimaryLcb,
                             ParentScb,
                             Fcb,
                             &TargetDirectoryName,
                             &SplitLinkName,
                             SplitLinkNameFlags,
                             CheckBufferOnly );

                //
                //  If we are in the second pass then optionally combine these
                //  Lcb's and delete the split.
                //

                if ((SplitLinkNameFlags == NewLinkNameFlags) && !CheckBufferOnly) {

                    NtfsCombineLcbs( IrpContext, Lcb, SplitPrimaryLcb );
                    NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
                }
            }

            //
            //  If we have a traverse link and are in the second pass then combine
            //  with the primary Lcb.
            //

            if (!CheckBufferOnly) {

                if (TraverseLcb != NULL) {

                    if (!FlagOn( RenameFlags, REUSE_TRAVERSE_LINK )) {

                        NtfsRenameLcb( IrpContext,
                                       TraverseLcb,
                                       NewLinkName,
                                       NewLinkNameFlags,
                                       CheckBufferOnly );

                        if (SplitPrimaryLcb && !SplitSourceLcb) {

                            NtfsRenameLcb( IrpContext,
                                           SplitPrimaryLcb,
                                           NewLinkName,
                                           NewLinkNameFlags,
                                           CheckBufferOnly );

                            //
                            //  If we are in the second pass then optionally combine these
                            //  Lcb's and delete the split.
                            //

                            if (!CheckBufferOnly) {

                                NtfsCombineLcbs( IrpContext, Lcb, SplitPrimaryLcb );
                                NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
                            }
                        }
                    }

                    NtfsCombineLcbs( IrpContext,
                                     Lcb,
                                     TraverseLcb );

                    NtfsDeleteLcb( IrpContext, &TraverseLcb );
                }
            }

            //
            //  Checkpoint the transaction before modifying the in memory lcbs duirng the
            //  2nd pass 
            // 

            if (Pass == 0) {
                NtfsCheckpointCurrentTransaction( IrpContext );
            }

            Pass += 1;
            CheckBufferOnly = FALSE;

        } while (Pass < 2);

    } finally {

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsMoveLinkToNewDir:  Exit\n") );

    return;
}


//
//  Local support routine.
//

VOID
NtfsRenameLinkInDir (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN OUT PLCB Lcb,
    IN PUNICODE_STRING NewLinkName,
    IN UCHAR NewLinkNameFlags,
    IN ULONG RenameFlags,
    IN PUNICODE_STRING PrevLinkName,
    IN UCHAR PrevLinkNameFlags
    )

/*++

Routine Description:

    This routine performs the in-memory work of moving renaming a link within
    the same directory.  It will rename an existing link to the
    new name.  It also merges whatever other links need to be joined with
    this link.  This includes the complement of a primary link pair or
    an existing hard link which may be overwritten.  Merging the existing
    links has the effect of moving any of the Ccb's on the stale Links to
    the newly modified link.
    
    LCBs are not rolled back so after its called - no exceptions can occur that would
    cause rollback. Because of this we checkpoint the current transaction before the 2nd 
    phase of modification when all allocations have already been done. 

Arguments:

    ParentScb - Scb for the directory the rename is taking place in.

    Fcb - The Fcb for the file whose link is being renamed.

    Lcb - This is the Lcb which is the base of the rename.

    NewLinkName - This is the name to use for the new link.

    NewLinkNameFlags - These are the flags to use for the new link.

    RenameFlags - Flag field indicating the type of operations to perform
        on the file name links.

    PrevLinkName - File name for link being removed.  Only meaningful for a traverse link.

    PrevLinkNameFlags - File name flags for link being removed.

Return Value:

    None.

--*/

{
    UNICODE_STRING SplitLinkName;
    UCHAR SplitLinkNameFlags = NewLinkNameFlags;

    PLCB TraverseLcb = NULL;
    PLCB SplitPrimaryLcb = NULL;

    PFILE_NAME FileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;
    BOOLEAN Found;

    ULONG Pass;
    BOOLEAN CheckBufferOnly;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRenameLinkInDir:  Entered\n") );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We have the Lcb which will be our primary Lcb and the name we need
        //  to perform the rename.  If the current Lcb is a split primary link
        //  or we removed a split primary link, then we need to find
        //  the other split link.
        //

        if (LcbSplitPrimaryLink( Lcb )) {

            SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                    (UCHAR) LcbSplitPrimaryComplement( Lcb ));

            //
            //  If we found an existing Lcb we have to update its name as well.  We may be
            //  able to use the new name used for the Lcb passed in.  However we must check
            //  that we don't overwrite a DOS name with an NTFS only name.
            //

            if (SplitPrimaryLcb &&
                (SplitPrimaryLcb->FileNameAttr->Flags == FILE_NAME_DOS) &&
                (NewLinkNameFlags == FILE_NAME_NTFS)) {

                //
                //  Lookup the dos only name on disk.
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                //
                //  Walk through the names for this entry.  There better
                //  be one which is not a DOS-only name.
                //

                Found = NtfsLookupAttributeByCode( IrpContext,
                                                   Fcb,
                                                   &Fcb->FileReference,
                                                   $FILE_NAME,
                                                   &AttrContext );

                while (Found) {

                    FileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                    if (FileName->Flags == FILE_NAME_DOS) { break; }

                    Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                           Fcb,
                                                           $FILE_NAME,
                                                           &AttrContext );
                }

                //
                //  We should have found the entry.
                //

                if (!Found) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }

                //
                //  Now build the component name.
                //

                SplitLinkName.Buffer = FileName->FileName;
                SplitLinkName.MaximumLength =
                SplitLinkName.Length = FileName->FileNameLength * sizeof( WCHAR );
                SplitLinkNameFlags = FILE_NAME_DOS;

            } else {

                SplitLinkName = *NewLinkName;
            }
        }

        //
        //  If we used a traverse link, we need to check if there is
        //  an Lcb for it.  Ignore this for the case where we traversed to
        //  the other half of a primary link.
        //

        if (!FlagOn( RenameFlags, OVERWRITE_SOURCE_LINK ) &&
            FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK | REUSE_TRAVERSE_LINK )) {

            if (FlagOn( RenameFlags, EXACT_CASE_MATCH )) {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *NewLinkName,
                                             PrevLinkNameFlags,
                                             NULL );

            } else {

                TraverseLcb = NtfsCreateLcb( IrpContext,
                                             ParentScb,
                                             Fcb,
                                             *PrevLinkName,
                                             PrevLinkNameFlags,
                                             NULL );
            }

            if (FlagOn( RenameFlags, REMOVE_TRAVERSE_LINK )) {

                //
                //  If this is a split primary, we need to find the name flags for
                //  the Lcb.
                //

                if (LcbSplitPrimaryLink( TraverseLcb )) {

                    SplitPrimaryLcb = NtfsLookupLcbByFlags( Fcb,
                                                            (UCHAR) LcbSplitPrimaryComplement( TraverseLcb ));

                    SplitLinkName = *NewLinkName;
                }
            }
        }

        //
        //  Now move and combine the Lcbs.  We will do this in two passes.  One will allocate buffers
        //  of sufficient size.  The other will store the names in.
        //

        Pass = 0;
        CheckBufferOnly = TRUE;
        do {

            //
            //  Start with the Lcb used for the rename.
            //

            NtfsRenameLcb( IrpContext,
                           Lcb,
                           NewLinkName,
                           NewLinkNameFlags,
                           CheckBufferOnly );

            //
            //  Next do the split primary if from the source file or the target.
            //

            if (SplitPrimaryLcb) {

                NtfsRenameLcb( IrpContext,
                               SplitPrimaryLcb,
                               &SplitLinkName,
                               SplitLinkNameFlags,
                               CheckBufferOnly );

                //
                //  If we are in the second pass then optionally combine these
                //  Lcb's and delete the split.
                //

                if (!CheckBufferOnly && (SplitLinkNameFlags == NewLinkNameFlags)) {

                    NtfsCombineLcbs( IrpContext, Lcb, SplitPrimaryLcb );
                    NtfsDeleteLcb( IrpContext, &SplitPrimaryLcb );
                }
            }

            //
            //  If we have a traverse link and are in the second pass then combine
            //  with the primary Lcb.
            //

            if (!CheckBufferOnly) {

                if (TraverseLcb != NULL) {

                    if (!FlagOn( RenameFlags, REUSE_TRAVERSE_LINK )) {

                        NtfsRenameLcb( IrpContext,
                                       TraverseLcb,
                                       NewLinkName,
                                       NewLinkNameFlags,
                                       CheckBufferOnly );
                    }

                    NtfsCombineLcbs( IrpContext,
                                     Lcb,
                                     TraverseLcb );

                    NtfsDeleteLcb( IrpContext, &TraverseLcb );
                }
            }

            //
            //  Checkpoint the transaction before modifying the in memory lcbs duirng the
            //  2nd pass 
            // 

            if (Pass == 0) {
                NtfsCheckpointCurrentTransaction( IrpContext );
            }

            Pass += 1;
            CheckBufferOnly = FALSE;

        } while (Pass < 2);

    } finally {

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        DebugTrace( -1, Dbg, ("NtfsRenameLinkInDir:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

LONG
NtfsFileInfoExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    Exception filter for errors during cleanup.  We want to raise if this is
    a retryable condition or fatal error, plow on as best we can if not.

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    NTSTATUS Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    //
    //  For now break if we catch corruption errors on both free and checked
    //  TODO:  Remove this before we ship
    //

    if (NtfsBreakOnCorrupt &&
        ((Status == STATUS_FILE_CORRUPT_ERROR) ||
         (Status == STATUS_DISK_CORRUPT_ERROR))) {

        if (*KdDebuggerEnabled) {
            DbgPrint("*******************************************\n");
            DbgPrint("NTFS detected corruption on your volume\n");
            DbgPrint("IrpContext=0x%08x, VCB=0x%08x\n",IrpContext,IrpContext->Vcb);
            DbgPrint("Send email to NTFSDEV\n");
            DbgPrint("*******************************************\n");
            DbgBreakPoint();
        }
    }

    if (!FsRtlIsNtstatusExpected( Status )) {
        return EXCEPTION_CONTINUE_SEARCH;
    } else {
        return EXCEPTION_EXECUTE_HANDLER;
    }

    UNREFERENCED_PARAMETER( IrpContext );
}


//
//  Local support routine
//

VOID
NtfsUpdateFileDupInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine updates the duplicate information for a file for calls
    to set allocation or EOF on the main data stream.  It is in a separate routine
    so we don't have to put a try-except in the main path.

    We will overlook any expected errors in this path.  If we get any errors we
    will simply leave this update to be performed at some other time.

    We are guaranteed that the current transaction has been checkpointed before this
    routine is called.  We will look to see if the MftScb is on the exclusive list
    for this IrpContext and release it if so.  This is to prevent a deadlock when
    we attempt to acquire the parent of this file.

Arguments:

    Fcb - This is the Fcb to update.

    Ccb - If specified, this is the Ccb for the caller making the call.

Return Value:

    None.

--*/

{
    PLCB Lcb = NULL;
    PSCB ParentScb = NULL;
    ULONG FilterMatch;

    PLIST_ENTRY Links;
    PFCB NextFcb;
    PFCB UnlockFcb = NULL;

    PAGED_CODE();

    ASSERT( IrpContext->TransactionId == 0 );

    //
    //  Check if there is an Lcb in the Ccb.
    //

    if (ARGUMENT_PRESENT( Ccb )) {

        Lcb = Ccb->Lcb;
    }

    //
    //  Use a try-except to catch any errors.
    //

    try {

        //
        //  Check that we don't own the Mft Scb.
        //

        if (Fcb->Vcb->MftScb != NULL) {

            for (Links = IrpContext->ExclusiveFcbList.Flink;
                 Links != &IrpContext->ExclusiveFcbList;
                 Links = Links->Flink) {

                ULONG Count;

                NextFcb = (PFCB) CONTAINING_RECORD( Links,
                                                    FCB,
                                                    ExclusiveFcbLinks );

                //
                //  If this is the Fcb for the Mft then remove it from the list.
                //

                if (NextFcb == Fcb->Vcb->MftScb->Fcb) {

                    //
                    //  Free the snapshots for the Fcb and release the Fcb enough times
                    //  to remove it from the list.
                    //

                    NtfsFreeSnapshotsForFcb( IrpContext, NextFcb );

                    Count = NextFcb->BaseExclusiveCount;

                    while (Count--) {

                        NtfsReleaseFcb( IrpContext, NextFcb );
                    }

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );

                    break;
                }
            }
        }

        //
        //  Check that we don't own the quota table Scb.
        //

        if (Fcb->Vcb->QuotaTableScb != NULL) {

            for (Links = IrpContext->ExclusiveFcbList.Flink;
                 Links != &IrpContext->ExclusiveFcbList;
                 Links = Links->Flink) {

                ULONG Count;

                NextFcb = (PFCB) CONTAINING_RECORD( Links,
                                                    FCB,
                                                    ExclusiveFcbLinks );

                //
                //  If this is the Fcb for the Quota table then remove
                //  it from the list.
                //

                if (NextFcb == Fcb->Vcb->QuotaTableScb->Fcb) {

                    //
                    //  Free the snapshots for the Fcb and release the Fcb enough times
                    //  to remove it from the list.
                    //

                    NtfsFreeSnapshotsForFcb( IrpContext, NextFcb );

                    Count = NextFcb->BaseExclusiveCount;

                    while (Count--) {

                        NtfsReleaseFcb( IrpContext, NextFcb );
                    }

                    break;
                }
            }
        }

        //
        //  Go through and free any Scb's in the queue of shared Scb's
        //  for transactions.
        //

        if (IrpContext->SharedScb != NULL) {

            NtfsReleaseSharedResources( IrpContext );
        }

        NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );
        NtfsUpdateDuplicateInfo( IrpContext, Fcb, Lcb, ParentScb );

        //
        //  Use a try-finally to guarantee we unlock the Fcb we might lock.
        //

        try {

            //
            //  If there is no Ccb then look for one in the Lcb we just got.
            //

            if (!ARGUMENT_PRESENT( Ccb ) &&
                ARGUMENT_PRESENT( Lcb )) {

                PCCB NextCcb;

                Links = Lcb->CcbQueue.Flink;

                while (Links != &Lcb->CcbQueue) {

                    NextCcb = CONTAINING_RECORD( Links, CCB, LcbLinks );

                    NtfsLockFcb( IrpContext, NextCcb->Lcb->Fcb );
                    if (!FlagOn( NextCcb->Flags, CCB_FLAG_CLOSE | CCB_FLAG_OPEN_BY_FILE_ID )) {

                        Ccb = NextCcb;

                        //
                        //  Transfer ownership of the name to the ccb - so we protected from
                        //  closes while we're using the name
                        //

                        ASSERT( NtfsIsExclusiveFcb( Fcb ));
                        SetFlag( Ccb->Flags, CCB_FLAG_PROTECT_NAME );
                        NtfsUnlockFcb( IrpContext, NextCcb->Lcb->Fcb );

                        UnlockFcb = NextCcb->Lcb->Fcb;
                        break;
                    }

                    NtfsUnlockFcb( IrpContext, NextCcb->Lcb->Fcb );
                    Links = Links->Flink;
                }
            }

            //
            //  Now perform the dir notify call if there is a Ccb and this is not an
            //  open by FileId.
            //

            if (ARGUMENT_PRESENT( Ccb ) &&
                (Fcb->Vcb->NotifyCount != 0) &&
                (ParentScb != NULL) &&
                !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID )) {

                FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                        Fcb->InfoFlags | Lcb->InfoFlags );

                if (FilterMatch != 0) {

                    NtfsReportDirNotify( IrpContext,
                                         Fcb->Vcb,
                                         &Ccb->FullFileName,
                                         Ccb->LastFileNameOffset,
                                         NULL,
                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                           (Ccb->Lcb != NULL) &&
                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                          NULL),
                                         FilterMatch,
                                         FILE_ACTION_MODIFIED,
                                         ParentScb->Fcb );
                }
            }

        } finally {

            if (UnlockFcb != NULL) {

                NtfsLockFcb( IrpContext, UnlockFcb );
                ClearFlag( Ccb->Flags, CCB_FLAG_PROTECT_NAME );
                NtfsUnlockFcb( IrpContext, UnlockFcb );
            }
        }

        NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
        Fcb->InfoFlags = 0;

    } except(NtfsFileInfoExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NtfsMinimumExceptionProcessing( IrpContext );
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsStreamRename (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PCCB Ccb,
    IN BOOLEAN ReplaceIfExists,
    IN PUNICODE_STRING NewStreamName
    )

/*++

Routine Description:

    This routine performs a stream rename within a single Fcb.

Arguments:

    IrpContext - Context of the call

    FileObject - File object being used

    Fcb - Fcb of file/directory

    Scb - Stream being renamed.  The parent Fcb is acquired exclusively.

    Ccb - Handle used to perform the rename.  Look here for usn source information.

    ReplaceIfExists - TRUE => overwrite an existing stream

    NewStreamName - name of new stream

Return Value:

    NTSTATUS of the operation.

--*/

{
    NTFS_NAME_DESCRIPTOR Name;
    BOOLEAN FoundIllegalCharacter;
    PSCB TargetScb = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    ATTRIBUTE_TYPE_CODE TypeCode;
    BOOLEAN EmptyFile;
    BOOLEAN NamesSwapped = FALSE;

    PSCB RestoreTargetScb = NULL;
    ULONG TargetScbCompressionUnit;
    USHORT TargetScbAttributeFlags;
    UCHAR TargetScbCompressionUnitShift;
    LONGLONG OldValidDataLengthOnDisk;

    DebugDoit( int Count = 0 );

    PAGED_CODE( );

    DebugTrace( +1, Dbg, (  "NtfsStreamRename\n"
                            "  IrpContext     %x\n"
                            "  Scb            %x\n"
                            "  ReplaceIf      %x\n"
                            "  NewStreamName '%Z'\n",
                            IrpContext, Scb, ReplaceIfExists, NewStreamName ));

    //
    //  Take a snapshot if one doesn't exist because we'll be calling writefilesizes
    //

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  Capture the ccb source information.
    //

    if (Ccb != NULL) {

        IrpContext->SourceInfo = Ccb->UsnSourceInfo;
    }

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Validate name is just :stream:type.  No file name is specified and
        //  at least a stream or type must be specified.
        //

        RtlZeroMemory( &Name, sizeof( Name ));

        if (!NtfsParseName( *NewStreamName, FALSE, &FoundIllegalCharacter, &Name ) ||
            FlagOn( Name.FieldsPresent, FILE_NAME_PRESENT_FLAG ) ||
            (!FlagOn( Name.FieldsPresent, ATTRIBUTE_NAME_PRESENT_FLAG ) &&
             !FlagOn( Name.FieldsPresent, ATTRIBUTE_TYPE_PRESENT_FLAG )) ||
            (Name.AttributeName.Length > NTFS_MAX_ATTR_NAME_LEN * sizeof( WCHAR ))) {

            DebugTrace( 0, Dbg, ("Name is illegal\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        DebugTrace( 0, Dbg, (" Fields: %x\n"
                             " AttributeName %x %x/%x\n",
                             Name.FieldsPresent,
                             Name.AttributeName.Buffer,
                             Name.AttributeName.Length,
                             Name.AttributeName.MaximumLength ));

        //
        //  Find out the attribute type specified
        //

        if (FlagOn( Name.FieldsPresent, ATTRIBUTE_TYPE_PRESENT_FLAG )) {

            NtfsUpcaseName ( IrpContext->Vcb->UpcaseTable,
                             IrpContext->Vcb->UpcaseTableSize,
                             &Name.AttributeType );
            TypeCode = NtfsGetAttributeTypeCode( IrpContext->Vcb, &Name.AttributeType );

        } else {

            TypeCode = Scb->AttributeTypeCode;
        }

        if (TypeCode != Scb->AttributeTypeCode) {
            DebugTrace( 0, Dbg, ("Attribute types don't match %x - %x\n", Scb->AttributeTypeCode, TypeCode));
            Status = STATUS_OBJECT_TYPE_MISMATCH;
            leave;
        }

        //
        //  Verify that the source stream is $DATA
        //

        if (Scb->AttributeTypeCode != $DATA) {
            DebugTrace( 0, Dbg, ("Type code is illegal\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        //
        //  Just to be non-orthogonal, we disallow renaming to default data stream
        //  on directories
        //

        if (TypeCode == $DATA &&
            Name.AttributeName.Length == 0 &&
            IsDirectory( &(Scb->Fcb->Info) )) {
            DebugTrace( 0, Dbg, ("Cannot rename directory stream to ::$Data\n") );
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }


        //
        //  We have a valid source stream and a valid target name.  Take the short cut
        //  if the names match.  Yes, you could argue about sharing violation, or
        //  renaming to non-empty streams.  We just claim success and let it go.
        //

        if (NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable,
                               &Scb->AttributeName, &Name.AttributeName,
                               TRUE )) {
            DebugTrace( 0, Dbg, ("Names are the same\n"));
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        //  Open / Create the target stream and validate ReplaceIfExists.
        //

        Status = NtOfsCreateAttribute( IrpContext,
                                       Fcb,
                                       Name.AttributeName,
                                       ReplaceIfExists ? CREATE_OR_OPEN : CREATE_NEW,
                                       FALSE,
                                       &TargetScb );

        if (!NT_SUCCESS( Status )) {
            DebugTrace( 0, Dbg, ("Unable to create target stream\n"));
            leave;
        }

        if (TargetScb == Scb) {
            DebugTrace( 0, Dbg, ("Somehow, you've got the same Scb\n"));
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        //  Verify that the target Scb is not in use nor has any allocation
        //  or data.
        //

        NtfsAcquireFsrtlHeader( TargetScb );
        EmptyFile = TargetScb->Header.AllocationSize.QuadPart == 0;
        NtfsReleaseFsrtlHeader( TargetScb );

        if (!EmptyFile) {
            DebugTrace( 0, Dbg, ("Target has allocation\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        if (TargetScb->CleanupCount != 0 ||
            !MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                                   (PLARGE_INTEGER)&Li0 )) {
            DebugTrace( 0, Dbg, ("Target in use\n"));
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }

        NtfsAcquireFsrtlHeader( Scb );
        EmptyFile = Scb->Header.AllocationSize.QuadPart == 0;
        NtfsReleaseFsrtlHeader( Scb );

        //
        //  We might end up with deallocating or even allocating an MFT
        //  record in the process of deleting the old stream. So, it's wise to preacquire
        //  QuotaControl resource, lest we deadlock with the MftScb resource.
        //

        if (NtfsPerformQuotaOperation( TargetScb->Fcb )) {
            NtfsAcquireQuotaControl( IrpContext, TargetScb->Fcb->QuotaControl );
        }

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

        //
        //  Always force both streams to be non-resident.  Then we will never have
        //  a conflict between the Scb and attribute.  We don't want to take an
        //  empty non-resident stream and point it to a resident attribute.
        //  NOTE: we call with CreateSectionUnderWay set to true which forces
        //  the data to be flushed directly out to the new clusters. We need this
        //  because we explicitly move VDL a little later on.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            if (NtfsIsAttributeResident( NtfsFoundAttribute( &Context ))) {
                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &Context ),
                                          TRUE,
                                          &Context );
            }
        }

        //
        //  Cache the old VDL presisted to disk so we can update it in the new location
        //

        OldValidDataLengthOnDisk = NtfsFoundAttribute( &Context )->Form.Nonresident.ValidDataLength;
        NtfsCleanupAttributeContext( IrpContext, &Context );


        if (FlagOn( TargetScb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

            NtfsLookupAttributeForScb( IrpContext, TargetScb, NULL, &Context );

            if (NtfsIsAttributeResident( NtfsFoundAttribute( &Context ))) {
                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          NtfsFoundAttribute( &Context ),
                                          TRUE,
                                          &Context );
            }

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Load all Mcb information for the source stream, we'll need it to generate the mapping.
        //

        (VOID)NtfsPreloadAllocation( IrpContext, Scb, 0, MAXLONGLONG );

        //
        //  Make sure the attribute flags on the target match that on the source.
        //

        if (TargetScb->AttributeFlags != Scb->AttributeFlags) {

            RestoreTargetScb = TargetScb;
            TargetScbCompressionUnit = TargetScb->CompressionUnit;
            TargetScbAttributeFlags = TargetScb->AttributeFlags;
            TargetScbCompressionUnitShift = TargetScb->CompressionUnitShift;

            NtfsModifyAttributeFlags( IrpContext, TargetScb, Scb->AttributeFlags );
        }

        //
        //  At this point, we have Scb to the source of
        //  the rename and a target Scb.  The Source has all its allocation loaded
        //  and the target has no allocation.  The only thing that really ties
        //  either Scb to the disk attribute is the AttributeName field.  We swap
        //  the attribute names in order to swap them on disk.
        //

        Name.FileName = TargetScb->AttributeName;
        TargetScb->AttributeName = Scb->AttributeName;
        Scb->AttributeName = Name.FileName;
        NamesSwapped = TRUE;

        //
        //  If there is data in the source attribute
        //

        if (!EmptyFile) {

            VCN AllocationClusters;

            //
            //  Now, we bring the disk image of these attributes up to date with
            //  the Mcb information. First, add the allocation to the new attribute.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );
            AllocationClusters = LlClustersFromBytes( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart );

            //
            //  Set the original scb to the target's size (This is really the target now)
            //

            ASSERT( Scb->ScbSnapshot != NULL );
            Scb->Header.AllocationSize = TargetScb->Header.AllocationSize;

            NtfsAddAttributeAllocation( IrpContext,
                                        Scb,
                                        &Context,
                                        &Li0.QuadPart,
                                        &AllocationClusters );

            NtfsCleanupAttributeContext( IrpContext, &Context );

            //
            //  We've put the mapping into the new attribute record.  However
            //  the valid data length in the record is probably zero.  Update
            //  it to reflect the data in this stream already written to disk.
            //  Otherwise we may never update the data.
            //

            ASSERT( OldValidDataLengthOnDisk <= Scb->Header.FileSize.QuadPart );

            NtfsVerifySizes( &Scb->Header );
            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &OldValidDataLengthOnDisk,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Next, find all occurrences of the old attribute and delete them.
        //

        NtfsLookupAttributeForScb( IrpContext, TargetScb, NULL, &Context );

        do {
            DebugDoit(
                      if (Count++ != 0) {
                          DebugTrace( 0, Dbg, ("Deleting attribute record %d\n", Count));
                      } else {
                          DebugTrace( 0, Dbg, ("%x Mcb's\n", Scb->Mcb.NtfsMcbArraySizeInUse ));
                          if (Scb->Mcb.NtfsMcbArray[0].NtfsMcbEntry != NULL) {
                              DebugTrace( 0, Dbg, ("First Mcb has %x entries\n",
                                                   Scb->Mcb.NtfsMcbArray[0].NtfsMcbEntry->LargeMcb.BaseMcb.PairCount ));
                          }
                      }
                       );

            NtfsDeleteAttributeRecord( IrpContext,
                                       Fcb,
                                       (DELETE_LOG_OPERATION |
                                        DELETE_RELEASE_FILE_RECORD),
                                       &Context );
        } while (NtfsLookupNextAttributeForScb( IrpContext, TargetScb, &Context ));

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  If we are renaming a stream on a file, we must make sure that
        //  there is a default data stream still on the file.  Check the
        //  TargetScb to see if the name is for the default data stream
        //  and recreate the default data stream if we need to.
        //
        //  We rely on the type code being $DATA and there being NO buffer
        //  in the attribute type name.
        //

        if (TypeCode == $DATA && TargetScb->AttributeName.Buffer == NULL) {

            //
            //  Always create this stream non-resident in case the stream is encrypted.
            //

            NtfsAllocateAttribute( IrpContext,
                                   TargetScb,
                                   $DATA,
                                   &TargetScb->AttributeName,
                                   Scb->AttributeFlags,
                                   TRUE,
                                   TRUE,
                                   0,
                                   NULL );

        } else {
            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ));
        }

        //
        //  Checkpoint the transaction so we know we are done
        //

        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_STREAM_CHANGE );
        NtfsCommitCurrentTransaction( IrpContext );
        RestoreTargetScb = NULL;


        //
        //  Let cleanup handle updating the standard information for the file
        //

        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

        //
        //  If either Scb or TargetScb refers to the default data stream, then
        //  bring the Ccb, Scb, and Fcb flags and counts back into sync.  This
        //  is due to the fact that all operations tied to the default data
        //  stream are believed to apply to the file as a whole and not
        //  simply to the stream.
        //

        if (FlagOn( TargetScb->ScbState, SCB_STATE_UNNAMED_DATA )) {

            //
            //  We have renamed *TO* the default data stream.  In this case we
            //  must mark all Ccb's for this stream as being CCB_FLAG_OPEN_AS_FILE
            //  and mark the Scb as the UNNAMED DATA stream
            //
            //  Also, for each Ccb that is opened with DELETE access, we
            //  adjust the Fcb->FcbDeleteFile count and CCB_FLAG_DELETE_FILE.
            //

            PCCB ThisCcb;

            DebugTrace( 0, Dbg, ("Renaming to default data stream\n"));
            DebugTrace( 0, Dbg, ("Scanning Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));

            SetFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

            for (ThisCcb = NtfsGetFirstCcbEntry( Scb );
                 ThisCcb != NULL;
                 ThisCcb = NtfsGetNextCcbEntry( Scb, ThisCcb )) {

                DebugTrace( 0, Dbg, ("ThisCcb = %x\n", ThisCcb));

                //
                //  Mark Ccb as being opened for the file as a whole
                //

                SetFlag( ThisCcb->Flags, CCB_FLAG_OPEN_AS_FILE );

                //
                //  If deleted access was granted, then we need
                //  to adjust the FCB delete count
                //

                if (FlagOn( ThisCcb->Flags, CCB_FLAG_DELETE_ACCESS )) {

                    DebugTrace( 0, Dbg, ("Found one\n" ));
                    Fcb->FcbDeleteFile += 1;
                    SetFlag( ThisCcb->Flags, CCB_FLAG_DELETE_FILE );
                }

                //
                //  If the stream was marked as delete-on-close,
                //  propagate that to the CCB
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE )) {

                    SetFlag( ThisCcb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
                }
            }

            //
            //  Update the file size and allocation size in the Fcb Info field.
            //

            if (Fcb->Info.FileSize != Scb->Header.FileSize.QuadPart) {

                Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            if (Fcb->Info.AllocatedLength != Scb->TotalAllocated) {

                Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

            DebugTrace( 0, Dbg, ("Done Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));

        } else if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

            //
            //  We have renamed *FROM* the default data stream.  In this case we
            //  must unmark all Ccb's for this stream as being CCB_FLAG_OPEN_AS_FILE
            //
            //  Also, for each Ccb that is opened with DELETE access, we
            //  adjust the Fcb->FcbDeleteFile count and CCB_FLAG_DELETE_FILE.
            //

            PCCB ThisCcb;

            DebugTrace( 0, Dbg, ("Renaming from default data stream\n"));
            DebugTrace( 0, Dbg, ("Scanning Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));

            ClearFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

            for (ThisCcb = NtfsGetFirstCcbEntry( Scb );
                 ThisCcb != NULL;
                 ThisCcb = NtfsGetNextCcbEntry( Scb, ThisCcb )) {

                DebugTrace( 0, Dbg, ("ThisCcb = %x\n", ThisCcb));

                //
                //  Unmark Ccb from representing the file as a whole.
                //

                ClearFlag( ThisCcb->Flags, CCB_FLAG_OPEN_AS_FILE );

                //
                //  If deleted access was granted, then we need
                //  to unadjust the FCB delete count
                //

                if (FlagOn( ThisCcb->Flags, CCB_FLAG_DELETE_ACCESS )) {

                    DebugTrace( 0, Dbg, ("Found one\n" ));
                    Fcb->FcbDeleteFile -= 1;
                    ClearFlag( ThisCcb->Flags, CCB_FLAG_DELETE_FILE );
                }
            }

            //
            //  Update the file size and allocation size in the Fcb Info field.
            //

            if (Fcb->Info.FileSize != 0) {

                Fcb->Info.FileSize = 0;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            if (Fcb->Info.AllocatedLength != 0) {

                Fcb->Info.AllocatedLength = 0;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

            DebugTrace( 0, Dbg, ("Done Ccb's.  FcbDeleteFile = %x\n", Fcb->FcbDeleteFile ));
        }

        //
        //  Set the Scb flag to indicate that the attribute is gone.  Mark the
        //  Scb so it will never be returned.
        //

        TargetScb->ValidDataToDisk =
        TargetScb->Header.AllocationSize.QuadPart =
        TargetScb->Header.FileSize.QuadPart =
        TargetScb->Header.ValidDataLength.QuadPart = 0;

        TargetScb->AttributeTypeCode = $UNUSED;
        SetFlag( TargetScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

    } finally {

        if (AbnormalTermination( )) {

            //
            //  Restore the names.
            //

            if (NamesSwapped) {
                Name.FileName = TargetScb->AttributeName;
                TargetScb->AttributeName = Scb->AttributeName;
                Scb->AttributeName = Name.FileName;
            }

            //
            //  Restore the Target Scb flags.
            //

            if (RestoreTargetScb) {

                RestoreTargetScb->CompressionUnit = TargetScbCompressionUnit;
                RestoreTargetScb->AttributeFlags = TargetScbAttributeFlags;
                RestoreTargetScb->CompressionUnitShift = TargetScbCompressionUnitShift;
            }
        }

        if (TargetScb != NULL) {
            NtOfsCloseAttribute( IrpContext, TargetScb );
        }

        NtfsCleanupAttributeContext( IrpContext, &Context );
        DebugTrace( -1, Dbg, ("NtfsStreamRename --> %x\n", Status) );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsCheckTreeForBatchOplocks (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB DirectoryScb
    )

/*++

Routine Description:

    This routine walks a directory tree and looks for batch oplocks which might
    prevent the rename, link operation or short name operation from taking place.

    This routine will release the Vcb if there are batch oplocks we are waiting on the
    break for.

Arguments:

    Irp - Irp for this request.

    DirectoryScb - Scb for the root of the directory tree.

Return Value:

    NTSTATUS of the operation.  This routine can raise.

--*/

{
    NTSTATUS Status;
    PSCB BatchOplockScb;
    ULONG BatchOplockCount;

    PAGED_CODE();

    ASSERT( NtfsIsSharedVcb( DirectoryScb->Vcb ));

    Status = NtfsCheckScbForLinkRemoval( DirectoryScb, &BatchOplockScb, &BatchOplockCount );

    //
    //  If STATUS_PENDING is returned then we need to check whether
    //  to break a batch oplock.
    //

    if (Status == STATUS_PENDING) {

        //
        //  If the number of batch oplocks has grown then fail the request.
        //

        if ((Irp->IoStatus.Information != 0) &&
            (BatchOplockCount >= Irp->IoStatus.Information)) {

            Status = STATUS_ACCESS_DENIED;

        } else {

            //
            //  Remember the count of batch oplocks in the Irp and
            //  then call the oplock package.
            //

            Irp->IoStatus.Information = BatchOplockCount;

            Status = FsRtlCheckOplock( &BatchOplockScb->ScbType.Data.Oplock,
                                       Irp,
                                       IrpContext,
                                       NtfsOplockComplete,
                                       NtfsPrePostIrp );

            //
            //  If we got back success then raise CANT_WAIT to retry otherwise
            //  clean up.
            //

            if (Status == STATUS_SUCCESS) {

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fstiosup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FstIoSup.c

Abstract:

    This module implements the fast I/O routines for Ntfs.

Author:

    Tom Miller      [TomM]          16-May-96

Revision History:

--*/

#include "NtfsProc.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCopyReadA)
#pragma alloc_text(PAGE, NtfsCopyWriteA)
#pragma alloc_text(PAGE, NtfsMdlReadA)
#pragma alloc_text(PAGE, NtfsPrepareMdlWriteA)
#pragma alloc_text(PAGE, NtfsWaitForIoAtEof)
#pragma alloc_text(PAGE, NtfsFinishIoAtEof)
#endif

#ifdef NTFS_RWC_DEBUG

PRWC_HISTORY_ENTRY
NtfsGetHistoryEntry (
    IN PSCB Scb
    );
#endif


BOOLEAN
NtfsCopyReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LARGE_INTEGER BeyondLastByte;
    PDEVICE_OBJECT targetVdo;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    BOOLEAN WasDataRead = TRUE;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES( FileOffset->QuadPart, Length );
    BOOLEAN DoingIoAtEof = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

#ifdef NTFS_NO_FASTIO
    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( IoStatus );

    return FALSE;
#endif

    //
    //  Don't take the fast io path if someone is already active in this thread.
    //

    if (IoGetTopLevelIrp() != NULL) {

        return FALSE;
    }

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Get a real pointer to the common fcb header. Check for overflow.
        //

        if (MAXLONGLONG - FileOffset->QuadPart < (LONGLONG)Length) {

            return FALSE;
        }

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Make our best guess on whether we need the file exclusive
        //  or shared.  Note that we do not check FileOffset->HighPart
        //  until below.
        //

        if (Wait) {
            FsRtlIncrementCcFastReadWait();
        } else {
            FsRtlIncrementCcFastReadNoWait();
        }
        
        if ((Header->PagingIoResource == NULL) ||
            !ExAcquireResourceSharedLite(Header->PagingIoResource, Wait)) {
            FsRtlIncrementCcFastReadResourceMiss();
            WasDataRead = FALSE;
            goto Done2;
        }

        //
        //  Now synchronize with the FsRtl Header
        //

        NtfsAcquireFsrtlHeader( (PSCB)Header );
        
        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.
        //

        if (BeyondLastByte.QuadPart > Header->ValidDataLength.QuadPart) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.
            //

            DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                           NtfsWaitForIoAtEof( Header, FileOffset, Length );

            //
            //  Set the Flag if we are in fact beyond ValidDataLength.
            //

            if (DoingIoAtEof) {
                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

            } else {

                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
            }
        }

        NtfsReleaseFsrtlHeader( (PSCB)Header );
        
        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            FsRtlIncrementCcFastReadNotPossible();

            WasDataRead = FALSE;
            goto Done;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            targetVdo = IoGetRelatedDeviceObject( FileObject );
            FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;


            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        targetVdo )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                FsRtlIncrementCcFastReadNotPossible();
                
                WasDataRead = FALSE;
                goto Done;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                goto Done;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
                          
        try {

            //
            //  If there is a compressed section, then synchronize with that cache.
            //

            IoStatus->Status = STATUS_SUCCESS;

#ifdef  COMPRESS_ON_WIRE

            //
            //  If there is a compressed section, then we have to synchronize with
            //  the data out there.  Note the FileObjectC better also be there, or else
            //  we would have made the fast I/O not possible.
            //

            if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                LONGLONG LocalOffset = FileOffset->QuadPart;
                ULONG LocalLength;
                ULONG LengthLeft = Length;

                ASSERT(Header->FileObjectC != NULL);

                //
                //  If we are doing DoingIoAtEof then take the long path.  Otherwise a recursive
                //  flush will try to reacquire DoingIoAtEof and deadlock.
                //

                if (DoingIoAtEof) {

                    WasDataRead = FALSE;

                } else {

                    do {

                        ULONG ViewOffset;

                        //
                        //  Calculate length left in view.
                        //

                        ViewOffset = ((ULONG) LocalOffset & (VACB_MAPPING_GRANULARITY - 1));
                        LocalLength = LengthLeft;

                        if (LocalLength > VACB_MAPPING_GRANULARITY - ViewOffset) {
                            LocalLength = VACB_MAPPING_GRANULARITY - ViewOffset;
                        }

                        //
                        //  Trim the read so we don't inadvertently go beyond the end of the 
                        //  view because of the MM read ahead.
                        //

                        PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(((PVOID)(ULONG_PTR)((ULONG)LocalOffset)), LocalLength);

                        if (LocalLength > (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset)) {

#ifdef NTFS_RWC_DEBUG
                            {
                                PRWC_HISTORY_ENTRY NextBuffer;

                                NextBuffer = NtfsGetHistoryEntry( (PSCB) Header );

                                NextBuffer->Operation = TrimCopyRead;
                                NextBuffer->Information = PageCount;
                                NextBuffer->FileOffset = (ULONG) LocalOffset;
                                NextBuffer->Length = (ULONG) LocalLength;
                            }
#endif
                            LocalLength = (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset);
                            PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES(((PVOID)(ULONG_PTR)((ULONG)LocalOffset)), LocalLength);

                            ASSERT( LocalLength <= (VACB_MAPPING_GRANULARITY - ((PageCount - 1) * PAGE_SIZE) - ViewOffset) );
                        }

                        IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                          &LocalOffset,
                                                                          LocalLength,
                                                                          FALSE,
                                                                          &CompressionSync );

                        if (NT_SUCCESS(IoStatus->Status)) {

                            if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                                CcFastCopyRead( FileObject,
                                                (ULONG)LocalOffset,
                                                LocalLength,
                                                PageCount,
                                                Buffer,
                                                IoStatus );

                                ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                                        ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

                            } else {

                                WasDataRead = CcCopyRead( FileObject,
                                                     (PLARGE_INTEGER)&LocalOffset,
                                                     LocalLength,
                                                     Wait,
                                                     Buffer,
                                                     IoStatus );

                                ASSERT( !WasDataRead || (IoStatus->Status == STATUS_END_OF_FILE) ||
                                        ((LocalOffset + (LONG_PTR) IoStatus->Information) <= Header->FileSize.QuadPart));
                            }

                            LocalOffset += LocalLength;
                            LengthLeft -= LocalLength;
                            Buffer = Add2Ptr( Buffer, LocalLength );
                        }

                    } while ((LengthLeft != 0) && WasDataRead && NT_SUCCESS(IoStatus->Status));

                    //
                    //  Remember the full amount of the read.
                    //

                    if (WasDataRead) {

                        IoStatus->Information = Length;
                    }
                }

            } else {

#endif

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( (PSCB)Header )) {
                    ULONG Flags = SCE_FLAG_READ | SCE_FLAG_FASTIO;

                    if (!Wait)
                    {
                        Flags |= SCE_FLAG_ASYNC;
                    }

                    ASSERT( ((PSCB)Header)->NonpagedScb->SegmentObject.ImageSectionObject == NULL );
                    FsRtlLogSyscacheEvent( ((PSCB)Header), SCE_READ, Flags, FileOffset->QuadPart, Length, (LONGLONG)FileObject );
                }
#endif

                if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                    CcFastCopyRead( FileObject,
                                    FileOffset->LowPart,
                                    Length,
                                    PageCount,
                                    Buffer,
                                    IoStatus );

                    ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                            ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

                } else {

                    WasDataRead = CcCopyRead( FileObject,
                                         FileOffset,
                                         Length,
                                         Wait,
                                         Buffer,
                                         IoStatus );

                    ASSERT( !WasDataRead || (IoStatus->Status == STATUS_END_OF_FILE) ||
                            ((FileOffset->QuadPart + (LONG_PTR) IoStatus->Information) <= Header->FileSize.QuadPart));
                }

#ifdef  COMPRESS_ON_WIRE
            }
#endif

            FileObject->Flags |= FO_FILE_FAST_IO_READ;

            if (WasDataRead) {

                FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + IoStatus->Information;
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

            WasDataRead = FALSE;
        }

        IoSetTopLevelIrp( NULL );
        
#ifdef  COMPRESS_ON_WIRE
        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

Done:

        if (DoingIoAtEof) {
            FsRtlUnlockFsRtlHeader( Header );
        }
        ExReleaseResourceLite( Header->PagingIoResource );

Done2:

        FsRtlExitFileSystem();

    } else {

        //
        //  A zero length transfer was requested.
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;
    }

    return WasDataRead;
}


BOOLEAN
NtfsCopyWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.  For a complete description of the arguments
    see CcCopyWrite.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LARGE_INTEGER Offset;
    LARGE_INTEGER NewFileSize;
    LARGE_INTEGER OldFileSize;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN WasDataWritten = FALSE;

#ifdef SYSCACHE_DEBUG
    PSCB Scb = (PSCB) FileObject->FsContext;
#endif

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

#ifdef NTFS_NO_FASTIO
    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( IoStatus );

    return FALSE;
#endif

    //
    //  Don't take the fast io path if someone is already active in this thread.
    //

    if (IoGetTopLevelIrp() != NULL) {

        return FALSE;
    }

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (!FlagOn( FileObject->Flags, FO_WRITE_THROUGH ) &&
        CcCanIWrite( FileObject, Length, Wait, FALSE ) &&
        CcCopyWriteWontFlush( FileObject, FileOffset, Length ) &&
        (Header->PagingIoResource != NULL)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Split into separate paths for increased performance.  First
            //  we have the faster path which only supports Wait == TRUE and
            //  32 bits.  We will make an unsafe test on whether the fast path
            //  is ok, then just return FALSE later if we were wrong.  This
            //  should virtually never happen.
            //
            //  IMPORTANT NOTE: It is very important that any changes mad to
            //                  this path also be applied to the 64-bit path
            //                  which is the else of this test!
            //

            NewFileSize.QuadPart = FileOffset->QuadPart + Length;
            Offset = *FileOffset;

            if (Wait && (Header->AllocationSize.HighPart == 0)) {

                //
                //  Prevent truncates by acquiring paging I/O
                //

                ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

                //
                //  Now synchronize with the FsRtl Header
                //

                NtfsAcquireFsrtlHeader( (PSCB) Header );
                
                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ((FileOffset->HighPart < 0) || (NewFileSize.LowPart > Header->ValidDataLength.LowPart)) {

                    //
                    //  We can change FileSize and ValidDataLength if either, no one
                    //  else is now, or we are still extending after waiting.
                    //

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, FileOffset, Length );

                    //
                    //  Set the Flag if we are changing FileSize or ValidDataLength,
                    //  and save current values.
                    //

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

                        //
                        //  Now that we are synchronized for end of file cases,
                        //  we can calculate the real offset for this transfer and
                        //  the new file size (if we succeed).
                        //


                        if ((FileOffset->HighPart < 0)) {
                            Offset = Header->FileSize;
                        }

                        //
                        //  Above we allowed any negative .HighPart for the 32-bit path,
                        //  but now we are counting on the I/O system to have thrown
                        //  any negative number other than write to end of file.
                        //

                        ASSERT(Offset.HighPart >= 0);

                        //
                        //  Now calculate the new FileSize and see if we wrapped the
                        //  32-bit boundary.
                        //

                        NewFileSize.QuadPart = Offset.QuadPart + Length;

                        //
                        //  Update Filesize now so that we do not truncate reads.
                        //

                        OldFileSize.QuadPart = Header->FileSize.QuadPart;
                        if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                            //
                            //  If we are beyond AllocationSize, make sure we will
                            //  ErrOut below, and don't modify FileSize now!
                            //

                            if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                                NewFileSize.QuadPart = (LONGLONG)0x7FFFFFFFFFFFFFFF;
                            } else {
                                Header->FileSize.QuadPart = NewFileSize.QuadPart;
                            }
                        }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    } else {

                        ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                    }
                }

                NtfsReleaseFsrtlHeader( (PSCB)Header );
                
                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we have to do any zeroing. This is handled in the main path
                //  which deals with sparse files - cc rollbacks etc.
                //
                //  If there is a compressed stream and we are DoingIoAtEof, then get
                //  out because we could deadlock on a recursive flush from the synchronize.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
/* Remove? */       (NewFileSize.LowPart > Header->AllocationSize.QuadPart) ||
                    (Offset.LowPart > (Header->ValidDataLength.LowPart)) ||
                    (NewFileSize.HighPart != 0) ||
#ifdef  COMPRESS_ON_WIRE
                    ((((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) && 
                     DoingIoAtEof)
#else
                    FALSE
#endif                    
                    ) {

                    goto ErrOut;
                }
                
                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    targetVdo = IoGetRelatedDeviceObject( FileObject );
                    FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                &Offset,
                                                                Length,
                                                                TRUE,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so cleanup and return.
                        //

                        goto ErrOut;
                    }
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );

                try {

                    ASSERT( Offset.LowPart <= Header->ValidDataLength.LowPart );

#ifdef  COMPRESS_ON_WIRE

                    //
                    //  If there is a compressed section, then we have to synchronize with
                    //  the data out there.  Note the FileObjectC better also be there, or else
                    //  we would have made the fast I/O not possible.
                    //

                    if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                        LONGLONG LocalOffset = Offset.QuadPart;
                        ULONG LocalLength;
                        ULONG LengthLeft = Length;

                        ASSERT( Header->FileObjectC != NULL );

                        do {

                             //
                             //  Calculate length left in view.
                             //

                             LocalLength = LengthLeft;
                             if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                                 LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                             }

                             IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                               &LocalOffset,
                                                                               LocalLength,
                                                                               TRUE,
                                                                               &CompressionSync );

                             if (NT_SUCCESS(IoStatus->Status)) {

                                 WasDataWritten = TRUE;

                                 CcFastCopyWrite( FileObject,
                                                  (ULONG)LocalOffset,
                                                  LocalLength,
                                                  Buffer );

                                 LocalOffset += LocalLength;
                                 LengthLeft -= LocalLength;
                                 Buffer = Add2Ptr( Buffer, LocalLength );
                             }

                        } while ((LengthLeft != 0) && NT_SUCCESS( IoStatus->Status ));

                    } else {

#endif

                        CcFastCopyWrite( FileObject,
                                         Offset.LowPart,
                                         Length,
                                         Buffer );
                        WasDataWritten = TRUE;

#ifdef  COMPRESS_ON_WIRE
                    }
#endif

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    WasDataWritten = FALSE;
                }

                IoSetTopLevelIrp( NULL );
                
#ifdef COMPRESS_ON_WIRE
                if (CompressionSync != NULL) {
                    NtfsReleaseCompressionSync( CompressionSync );
                }
#endif

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (WasDataWritten) {

                    //
                    //  Set this handle as having modified the file and update
                    //  the current file position pointer
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;
                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                    if (DoingIoAtEof) {

#ifdef  COMPRESS_ON_WIRE
                        CC_FILE_SIZES CcFileSizes;
#endif

                        //
                        //  Make sure Cc knows the current FileSize, as set above,
                        //  (we may not have changed it).  Update ValidDataLength
                        //  and finish EOF.
                        //

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;

                        NtfsAcquireFsrtlHeader( (PSCB) Header );
                        CcGetFileSizePointer(FileObject)->LowPart = Header->FileSize.LowPart;
                        Header->ValidDataLength = NewFileSize;

#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( ((PSCB)Header) )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_WRITE | SCE_FLAG_FASTIO, 0, 0, NewFileSize.QuadPart );
                        }
#endif

#ifdef  COMPRESS_ON_WIRE
                        CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
#endif

                        NtfsVerifySizes( Header );
                        NtfsFinishIoAtEof( Header );
                        NtfsReleaseFsrtlHeader( (PSCB) Header );

#ifdef  COMPRESS_ON_WIRE

                        //
                        //  Update the CompressedCache with ValidDataLength.
                        //
            
                        if (Header->FileObjectC != NULL) {
                            CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                        }
#endif
                    }

                    goto Done1;
                }

            //
            //  Here is the 64-bit or no-wait path.
            //

            } else {

                //
                //  Prevent truncates by acquiring paging I/O
                //

                WasDataWritten = ExAcquireResourceSharedLite( Header->PagingIoResource, Wait );
                if (!WasDataWritten) {
                    goto Done2;
                }

                //
                //  Now synchronize with the FsRtl Header
                //

                NtfsAcquireFsrtlHeader( (PSCB) Header );
                
                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ((FileOffset->QuadPart < 0) || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                    //
                    //  We can change FileSize and ValidDataLength if either, no one
                    //  else is now, or we are still extending after waiting.
                    //

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, FileOffset, Length );

                    //
                    //  Set the Flag if we are changing FileSize or ValidDataLength,
                    //  and save current values.
                    //

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

                        //
                        //  Now that we are synchronized for end of file cases,
                        //  we can calculate the real offset for this transfer and
                        //  the new file size (if we succeed).
                        //

                        if ((FileOffset->QuadPart < 0)) {
                            Offset = Header->FileSize;
                        }

                        //
                        //  Now calculate the new FileSize and see if we wrapped the
                        //  32-bit boundary.
                        //

                        NewFileSize.QuadPart = Offset.QuadPart + Length;

                        //
                        //  Update Filesize now so that we do not truncate reads.
                        //

                        OldFileSize.QuadPart = Header->FileSize.QuadPart;
                        if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                            //
                            //  If we are beyond AllocationSize, make sure we will
                            //  ErrOut below, and don't modify FileSize now!
                            //

                            if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                                NewFileSize.QuadPart = (LONGLONG)0x7FFFFFFFFFFFFFFF;
                            } else {
                                Header->FileSize.QuadPart = NewFileSize.QuadPart;
                            }
                        }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    } else {

                        ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                    }
                }

                NtfsReleaseFsrtlHeader( (PSCB) Header );
                
                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we need to zero anything - handle in the main path
                //
                //  If there is a compressed stream and we are DoingIoAtEof, then get
                //  out because we could deadlock on a recursive flush from the synchronize.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
/* Remove? */       (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) ||
                    (Offset.QuadPart > Header->ValidDataLength.QuadPart) ||
#ifdef  COMPRESS_ON_WIRE
                    ((((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) && 
                     DoingIoAtEof)
#else
                    FALSE
#endif
                    ) {

                    goto ErrOut;
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    targetVdo = IoGetRelatedDeviceObject( FileObject );
                    FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                &Offset,
                                                                Length,
                                                                Wait,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so cleanup and return.
                        //

                        goto ErrOut;
                    }
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
                
                try {

                    ASSERT( Offset.QuadPart <= Header->ValidDataLength.QuadPart );
#ifdef  COMPRESS_ON_WIRE
                    if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                        LONGLONG LocalOffset = Offset.QuadPart;
                        ULONG LocalLength;
                        ULONG LengthLeft = Length;

                        ASSERT(Header->FileObjectC != NULL);

                        do {

                            //
                            //  Calculate length left in view.
                            //

                            LocalLength = LengthLeft;
                            if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                                LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                            }

                            IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                              &LocalOffset,
                                                                              LocalLength,
                                                                              TRUE,
                                                                              &CompressionSync );

                            
                            if (NT_SUCCESS(IoStatus->Status)) {

                                WasDataWritten = CcCopyWrite( FileObject,
                                                      (PLARGE_INTEGER)&LocalOffset,
                                                      LocalLength,
                                                      Wait,
                                                      Buffer );

                                LocalOffset += LocalLength;
                                LengthLeft -= LocalLength;
                                Buffer = Add2Ptr( Buffer, LocalLength );
                            }

                        } while ((LengthLeft != 0) && WasDataWritten && NT_SUCCESS(IoStatus->Status));

                    } else {
#endif

                    WasDataWritten = CcCopyWrite( FileObject,
                                                  &Offset,
                                                  Length,
                                                  Wait,
                                                  Buffer );

#ifdef  COMPRESS_ON_WIRE
                    }
#endif

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    WasDataWritten = FALSE;
                }

                IoSetTopLevelIrp( NULL );
                
#ifdef COMPRESS_ON_WIRE
                if (CompressionSync != NULL) {
                    NtfsReleaseCompressionSync( CompressionSync );
                }
#endif

                //
                //  If we succeeded, see if we have to update FileSize ValidDataLength.
                //

                if (WasDataWritten) {

                    //
                    //  Set this handle as having modified the file and update
                    //  the current file position pointer
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;
                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                    if (DoingIoAtEof) {

#ifdef  COMPRESS_ON_WIRE
                        CC_FILE_SIZES CcFileSizes;
#endif
            
                        //
                        //  Make sure Cc knows the current FileSize, as set above,
                        //  (we may not have changed it).  Update ValidDataLength
                        //  and finish EOF.
                        //

                        NtfsAcquireFsrtlHeader( (PSCB) Header );
                        CcGetFileSizePointer(FileObject)->QuadPart = Header->FileSize.QuadPart;
                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                        Header->ValidDataLength = NewFileSize;

#ifdef  COMPRESS_ON_WIRE
                        CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
#endif

                        NtfsVerifySizes( Header );
                        NtfsFinishIoAtEof( Header );
                        NtfsReleaseFsrtlHeader( (PSCB) Header );
#ifdef SYSCACHE_DEBUG
                        if (ScbIsBeingLogged( Scb )) {
                            FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_WRITE | SCE_FLAG_FASTIO, 0, 0, NewFileSize.QuadPart );
                        }
#endif


#ifdef  COMPRESS_ON_WIRE
                        //
                        //  Update the CompressedCache with ValidDataLength.
                        //
            
                        if (Header->FileObjectC != NULL) {
                            CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                        }
#endif
                    }

                    goto Done1;
                }
            }

ErrOut:

            WasDataWritten = FALSE;
            if (DoingIoAtEof) {
                NtfsAcquireFsrtlHeader( (PSCB) Header ); 
#ifdef  COMPRESS_ON_WIRE
                if (Header->FileObjectC != NULL) {
                    *CcGetFileSizePointer(Header->FileObjectC) = OldFileSize;
                }
#endif
                Header->FileSize = OldFileSize;
                NtfsFinishIoAtEof( Header );
                NtfsReleaseFsrtlHeader( (PSCB) Header );
            }

Done1: 
            ExReleaseResourceLite( Header->PagingIoResource );

Done2:
            FsRtlExitFileSystem();
        } else {

            //
            //  Noop case
            //  

            WasDataWritten = TRUE;
        }

    } else {

        //
        //  We could not do the I/O now.
        //

        WasDataWritten = FALSE;
    }

    return WasDataWritten;
}


BOOLEAN
NtfsMdlReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not delivered, or if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN WasDataRead = TRUE;
    LARGE_INTEGER BeyondLastByte;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //  Special case a read of zero length
    //

    if (Length == 0) {

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

    //
    //  Get a real pointer to the common fcb header
    //

    } else {

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

        //
        //  Overflows should've been handled by the caller.
        //

        ASSERT(MAXLONGLONG - FileOffset->QuadPart >= (LONGLONG)Length);
        
        Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

#ifdef _WIN64
        //
        //  The following should work for either 64 or 32 bits.
        //  Remove the 32 bit-only version in the #else clause
        //  after NT2K ships.
        //

        **((PULONG *)&CcFastMdlReadWait) += 1;
#else
        *(PULONG)CcFastMdlReadWait += 1;
#endif

        //
        //  Acquired shared on the common fcb header
        //

        if (Header->PagingIoResource == NULL) {
            WasDataRead = FALSE;
            goto Done2;
        }

        (VOID)ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

        //
        //  Now synchronize with the FsRtl Header
        //

        NtfsAcquireFsrtlHeader( (PSCB) Header );
        
        //
        //  Now see if we are reading beyond ValidDataLength.  We have to
        //  do it now so that our reads are not nooped.
        //

        if (BeyondLastByte.QuadPart > Header->ValidDataLength.QuadPart) {

            //
            //  We must serialize with anyone else doing I/O at beyond
            //  ValidDataLength, and then remember if we need to declare
            //  when we are done.
            //

            DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                           NtfsWaitForIoAtEof( Header, FileOffset, Length );

            //
            //  Set the Flag if we are in fact beyond ValidDataLength.
            //

            if (DoingIoAtEof) {
                SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();

            } else {

                ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
            }
        }

        NtfsReleaseFsrtlHeader( (PSCB) Header );
        
        //
        //  Now that the File is acquired shared, we can safely test if it is
        //  really cached and if we can do fast i/o and if not
        //  then release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            WasDataRead = FALSE;
            goto Done;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the file system
        //  the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;

            //
            //  All file system then set "Is Questionable" had better support fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is anything
            //  other than GoForIt then we cannot take the fast I/O path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        TRUE,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        IoGetRelatedDeviceObject( FileObject ) )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                WasDataRead = FALSE;
                goto Done;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {

                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                goto Done;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  mdl read fails, then return FALSE to our caller.
        //
        //
        //  Also mark this as the top level "Irp" so that lower file system levels
        //  will not attempt a pop-up
        //

        IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
        
        try {

            //
            //  If there is a compressed section, then synchronize with that cache.
            //

            IoStatus->Status = STATUS_SUCCESS;

            //
            //  If there is a compressed section, then we have to synchronize with
            //  the data out there.  Note the FileObjectC better also be there, or else
            //  we would have made the fast I/O not possible.
            //

            WasDataRead = FALSE;

#ifdef  COMPRESS_ON_WIRE
            if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                LONGLONG LocalOffset = FileOffset->QuadPart;
                ULONG LengthRemaining = Length;
                ULONG LocalLength;

                ASSERT(Header->FileObjectC != NULL);

                //
                //  If we are doing DoingIoAtEof then take the long path.  Otherwise a recursive
                //  flush will try to reacquire DoingIoAtEof and deadlock.
                //

                if (DoingIoAtEof) {

                    WasDataRead = FALSE;

                } else {

                    do {

                        //
                        //  Calculate length left in view.
                        //

                        LocalLength = LengthRemaining;
                        if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                            LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                        }

                        IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                          &LocalOffset,
                                                                          LocalLength,
                                                                          FALSE,
                                                                          &CompressionSync );

                        if (NT_SUCCESS(IoStatus->Status)) {

#ifdef NTFS_RWCMP_TRACE
                            if (NtfsCompressionTrace && IsSyscache(Header)) {
                                DbgPrint("CcMdlRead(F): FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                            }
#endif
                        
                            CcMdlRead( FileObject,
                                       (PLARGE_INTEGER)&LocalOffset,
                                       LocalLength,
                                       MdlChain,
                                       IoStatus );

                            LocalOffset += LocalLength;
                            LengthRemaining -= LocalLength;
                        }

                    } while ((LengthRemaining != 0) && NT_SUCCESS(IoStatus->Status));

                    //
                    //  Store final return byte count.
                    //
    
                    if (NT_SUCCESS( IoStatus->Status )) {
                        IoStatus->Information = Length;
                    }
                }

            } else {

#endif

#ifdef NTFS_RWCMP_TRACE
                if (NtfsCompressionTrace && IsSyscache(Header)) {
                    DbgPrint("CcMdlRead(F): FO = %08lx, Len = %08lx\n", FileOffset->LowPart, Length );
                }
#endif

                CcMdlRead( FileObject, FileOffset, Length, MdlChain, IoStatus );

                WasDataRead = TRUE;

#ifdef  COMPRESS_ON_WIRE
            }
#endif

            FileObject->Flags |= FO_FILE_FAST_IO_READ;

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                       ? EXCEPTION_EXECUTE_HANDLER
                                       : EXCEPTION_CONTINUE_SEARCH ) {

            WasDataRead = FALSE;
        }

        IoSetTopLevelIrp( NULL );
        
#ifdef COMPRESS_ON_WIRE
        if (CompressionSync != NULL) {
            NtfsReleaseCompressionSync( CompressionSync );
        }
#endif

    Done: NOTHING;

        if (DoingIoAtEof) {
            FsRtlUnlockFsRtlHeader( Header );
        }
        ExReleaseResourceLite( Header->PagingIoResource );

    Done2: NOTHING;
        FsRtlExitFileSystem();
    }

    return WasDataRead;
}


BOOLEAN
NtfsPrepareMdlWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not written, or if there is an I/O error.

    TRUE - if the data is being written

--*/

{
    PNTFS_ADVANCED_FCB_HEADER Header;
    LARGE_INTEGER Offset, NewFileSize;
    LARGE_INTEGER OldFileSize;
#ifdef COMPRESS_ON_WIRE
    PCOMPRESSION_SYNC CompressionSync = NULL;
#endif
    BOOLEAN DoingIoAtEof = FALSE;
    BOOLEAN WasDataWritten = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PNTFS_ADVANCED_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (CcCanIWrite( FileObject, Length, TRUE, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length) &&
        (Header->PagingIoResource != NULL)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Make our best guess on whether we need the file exclusive or
            //  shared.
            //

            NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
            Offset = *FileOffset;

            //
            //  Prevent truncates by acquiring paging I/O
            //

            ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );

            //
            //  Now synchronize with the FsRtl Header
            //

            NtfsAcquireFsrtlHeader( (PSCB) Header );
            
            //
            //  Now see if we will change FileSize.  We have to do it now
            //  so that our reads are not nooped.
            //

            if ((FileOffset->QuadPart < 0) || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                //
                //  We can change FileSize and ValidDataLength if either, no one
                //  else is now, or we are still extending after waiting.
                //

                DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                               NtfsWaitForIoAtEof( Header, FileOffset, Length );

                //
                //  Set the Flag if we are changing FileSize or ValidDataLength,
                //  and save current values.
                //

                if (DoingIoAtEof) {

                    SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif
                    //
                    //  Now that we are synchronized for end of file cases,
                    //  we can calculate the real offset for this transfer and
                    //  the new file size (if we succeed).
                    //

                    if ((FileOffset->QuadPart < 0)) {
                        Offset = Header->FileSize;
                    }

                    //
                    //  Now calculate the new FileSize and see if we wrapped the
                    //  32-bit boundary.
                    //

                    NewFileSize.QuadPart = Offset.QuadPart + Length;

                    //
                    //  Update Filesize now so that we do not truncate reads.
                    //

                    OldFileSize.QuadPart = Header->FileSize.QuadPart;
                    if (NewFileSize.QuadPart > Header->FileSize.QuadPart) {

                        //
                        //  If we are beyond AllocationSize, make sure we will
                        //  ErrOut below, and don't modify FileSize now!
                        //

                        if (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) {
                            NewFileSize.QuadPart = (LONGLONG)0x7FFFFFFFFFFFFFFF;
                        } else {
                            Header->FileSize.QuadPart = NewFileSize.QuadPart;
                        }
                    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                } else {

                    ASSERT( ((PSCB) Header)->IoAtEofThread != (PERESOURCE_THREAD) ExGetCurrentResourceThread() );
#endif
                }
            }

            NtfsReleaseFsrtlHeader( (PSCB) Header );

            //
            //  Now that the File is acquired shared, we can safely test
            //  if it is really cached and if we can do fast i/o and we
            //  do not have to extend. If not then release the fcb and
            //  return.
            //
            //  Get out if we need to do any zeroing and do that in the main write path
            //

            if ((FileObject->PrivateCacheMap == NULL) ||
                (Header->IsFastIoPossible == FastIoIsNotPossible) ||
/* Remove? */   (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) ||
                (Offset.QuadPart > Header->ValidDataLength.QuadPart)) {

                goto ErrOut;
            }

            //
            //  Check if fast I/O is questionable and if so then go ask the file system
            //  the answer
            //

            if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                PFAST_IO_DISPATCH FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;

                //
                //  All file system then set "Is Questionable" had better support fast I/O
                //

                ASSERT(FastIoDispatch != NULL);
                ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                //
                //  Call the file system to check for fast I/O.  If the answer is anything
                //  other than GoForIt then we cannot take the fast I/O path.
                //

                if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                            &Offset,
                                                            Length,
                                                            TRUE,
                                                            LockKey,
                                                            FALSE, // write operation
                                                            IoStatus,
                                                            IoGetRelatedDeviceObject( FileObject ) )) {

                    //
                    //  Fast I/O is not possible so release the Fcb and return.
                    //

                    goto ErrOut;
                }
            }

            //
            //  We can do fast i/o so call the cc routine to do the work and then
            //  release the fcb when we've done.  If for whatever reason the
            //  copy write fails, then return FALSE to our caller.
            //
            //
            //  Also mark this as the top level "Irp" so that lower file system levels
            //  will not attempt a pop-up
            //

            IoSetTopLevelIrp( (PIRP) FSRTL_FAST_IO_TOP_LEVEL_IRP );
            
            try {

                ASSERT( Offset.QuadPart <= Header->ValidDataLength.QuadPart );

#ifdef  COMPRESS_ON_WIRE
                if (((PSCB)Header)->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) {

                    LONGLONG LocalOffset = Offset.QuadPart;
                    ULONG LocalLength;
                    ULONG LengthLeft = Length;

                    ASSERT(Header->FileObjectC != NULL);

                    //
                    //  If we are doing DoingIoAtEof then take the long path.  Otherwise a recursive
                    //  flush will try to reacquire DoingIoAtEof and deadlock.
                    //
    
                    if (DoingIoAtEof) {
    
                        WasDataWritten = FALSE;
    
                    } else {
    
                        do {

                            //
                            //  Calculate length left in view.
                            //

                            LocalLength = LengthLeft;
                            if (LocalLength > (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)))) {
                                LocalLength = (ULONG)(VACB_MAPPING_GRANULARITY - (LocalOffset & (VACB_MAPPING_GRANULARITY - 1)));
                            }

                            IoStatus->Status = NtfsSynchronizeUncompressedIo( (PSCB)Header,
                                                                              &LocalOffset,
                                                                              LocalLength,
                                                                              TRUE,
                                                                              &CompressionSync );

                            if (NT_SUCCESS(IoStatus->Status)) {

#ifdef NTFS_RWCMP_TRACE
                                if (NtfsCompressionTrace && IsSyscache(Header)) {
                                    DbgPrint("CcMdlWrite(F): FO = %08lx, Len = %08lx\n", (ULONG)LocalOffset, LocalLength );
                                }
#endif

                                CcPrepareMdlWrite( FileObject,
                                                   (PLARGE_INTEGER)&LocalOffset,
                                                   LocalLength,
                                                   MdlChain,
                                                   IoStatus );

                                LocalOffset += LocalLength;
                                LengthLeft -= LocalLength;
                            }

                        } while ((LengthLeft != 0) && NT_SUCCESS(IoStatus->Status));
                        WasDataWritten = TRUE;
                    }

                } else {
#endif

#ifdef NTFS_RWCMP_TRACE
                    if (NtfsCompressionTrace && IsSyscache(Header)) {
                        DbgPrint("CcMdlWrite(F): FO = %08lx, Len = %08lx\n", Offset.LowPart, Length );
                    }
#endif

                    CcPrepareMdlWrite( FileObject, &Offset, Length, MdlChain, IoStatus );
                    WasDataWritten = TRUE;

#ifdef  COMPRESS_ON_WIRE
                }
#endif

            } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                            ? EXCEPTION_EXECUTE_HANDLER
                                            : EXCEPTION_CONTINUE_SEARCH ) {

                WasDataWritten = FALSE;
            }

            IoSetTopLevelIrp( NULL );
            
#ifdef COMPRESS_ON_WIRE
            if (CompressionSync != NULL) {
                NtfsReleaseCompressionSync( CompressionSync );
            }
#endif

            //
            //  If we succeeded, see if we have to update FileSize ValidDataLength.
            //

            if (WasDataWritten) {

                //
                //  Set this handle as having modified the file
                //

                FileObject->Flags |= FO_FILE_MODIFIED;
                IoStatus->Information = Length;

                if (DoingIoAtEof) {

#ifdef  COMPRESS_ON_WIRE
                    CC_FILE_SIZES CcFileSizes;
#endif
        
                    //
                    //  Make sure Cc knows the current FileSize, as set above,
                    //  (we may not have changed it).  Update ValidDataLength
                    //  and finish EOF.
                    //

                    NtfsAcquireFsrtlHeader( (PSCB) Header );
                    CcGetFileSizePointer(FileObject)->QuadPart = Header->FileSize.QuadPart;
                    FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    Header->ValidDataLength = NewFileSize;

#ifdef  COMPRESS_ON_WIRE
                    CcFileSizes = *(PCC_FILE_SIZES)&Header->AllocationSize;
#endif
                    NtfsVerifySizes( Header );
                    NtfsFinishIoAtEof( Header );
                    NtfsReleaseFsrtlHeader( (PSCB) Header );

#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( (PSCB)Header )) {
                        FsRtlLogSyscacheEvent( (PSCB)Header, SCE_VDL_CHANGE, SCE_FLAG_WRITE | SCE_FLAG_FASTIO | SCE_FLAG_MDL, 0, 0, NewFileSize.QuadPart );
                    }
#endif

                    
#ifdef  COMPRESS_ON_WIRE

                    //
                    //  Update the CompressedCache with ValidDataLength.
                    //
        
                    if (Header->FileObjectC != NULL) {
                        CcSetFileSizes( Header->FileObjectC, &CcFileSizes );
                    }
#endif
                }

                goto Done1;
            }

        ErrOut: NOTHING;

            WasDataWritten = FALSE;
            if (DoingIoAtEof) {
                NtfsAcquireFsrtlHeader( (PSCB) Header );
#ifdef  COMPRESS_ON_WIRE
                if (Header->FileObjectC != NULL) {
                    *CcGetFileSizePointer(Header->FileObjectC) = OldFileSize;
                }
#endif
                Header->FileSize = OldFileSize;
                NtfsFinishIoAtEof( Header );
                NtfsReleaseFsrtlHeader( (PSCB) Header );
            }

        Done1: ExReleaseResourceLite( Header->PagingIoResource );

            FsRtlExitFileSystem();
        }

    } else {

        //
        // We could not do the I/O now.
        //

        WasDataWritten = FALSE;
    }

    return WasDataWritten;
}


BOOLEAN
NtfsWaitForIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN OUT PLARGE_INTEGER FileOffset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine may be called while synchronized for cached write, to
    test for a possible Eof update, and return with a status if Eof is
    being updated and with the previous FileSize to restore on error.
    All updates to Eof are serialized by waiting in this routine.  If
    this routine returns TRUE, then NtfsFinishIoAtEof must be called.

    This routine must be called while synchronized with the FsRtl header.

Arguments:

    Header - Pointer to the FsRtl header for the file

    FileOffset - Pointer to FileOffset for the intended write

    Length - Length for the intended write

    EofWaitBlock - Uninitialized structure used only to serialize Eof updates

Return Value:

    FALSE - If the write does not extend Eof (OldFileSize not returned)
    TRUE - If the write does extend Eof OldFileSize returned and caller
           must eventually call NtfsFinishIoAtEof

--*/

{
    EOF_WAIT_BLOCK EofWaitBlock;

    PAGED_CODE();
    
    ASSERT( Header->FileSize.QuadPart >= Header->ValidDataLength.QuadPart );

    //
    //  Initialize the event and queue our block
    //

    KeInitializeEvent( &EofWaitBlock.Event, NotificationEvent, FALSE );
    InsertTailList( Header->PendingEofAdvances, &EofWaitBlock.EofWaitLinks );

    //
    //  Free the mutex and wait
    //

    NtfsReleaseFsrtlHeader( (PSCB) Header );
    
    KeWaitForSingleObject( &EofWaitBlock.Event,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    //  Now, resynchronize and get on with it.
    //

    NtfsAcquireFsrtlHeader( (PSCB) Header );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    ASSERT( ((PSCB) Header)->IoAtEofThread == NULL );
    ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif

    //
    //  Now we have to check again, and actually catch the case
    //  where we are no longer extending!
    //

    if ((FileOffset->QuadPart >= 0) &&
        ((FileOffset->QuadPart + Length) <= Header->ValidDataLength.QuadPart)) {

        NtfsFinishIoAtEof( Header );

        return FALSE;
    }

    return TRUE;
}


VOID
NtfsFinishIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header
    )

/*++

Routine Description:

    This routine must be called if NtfsWaitForIoAtEof returned
    TRUE, or we otherwise set EOF_ADVANCE_ACTIVE.

    This routine must be called while synchronized with the FsRtl header.

Arguments:

    Header - Pointer to the FsRtl header for the file

Return Value:

    None

--*/

{
    PEOF_WAIT_BLOCK EofWaitBlock;

    PAGED_CODE();

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    ((PSCB) Header)->IoAtEofThread = NULL;
#endif

    //
    //  If anyone is waiting, just let them go.
    //

    if (!IsListEmpty(Header->PendingEofAdvances)) {

        EofWaitBlock = (PEOF_WAIT_BLOCK)RemoveHeadList( Header-> PendingEofAdvances );
        KeSetEvent( &EofWaitBlock->Event, 0, FALSE );

    //
    //  Otherwise, show there is no active extender now.
    //

    } else {
        ClearFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\fspdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Ntfs
    Fsp

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

#define BugCheckFileId                   (NTFS_BUG_CHECK_FSPDISP)

#pragma alloc_text(PAGE, NtfsSpecialDispatch)
#pragma alloc_text(PAGE, NtfsPostSpecial)

//
//  Define our local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSP_DISPATCHER)

extern PETHREAD NtfsDesignatedTimeoutThread;


VOID
NtfsFspDispatch (
    IN PVOID Context
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:


    Context - Supplies the thread id.

Return Value:

    None - This routine never exits

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    
    PIRP Irp;
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;
    ULONG LogFileFullCount = 0;

    PVOLUME_DEVICE_OBJECT VolDo;
    BOOLEAN Retry;
    NTSTATUS Status = STATUS_SUCCESS;

    PCREATE_CONTEXT CreateContext;

    IrpContext = (PIRP_CONTEXT)Context;

    //
    //  Reset the shared fields
    //  

    InitializeListHead( &IrpContext->RecentlyDeallocatedQueue );
    InitializeListHead( &IrpContext->ExclusiveFcbList );

    Irp = IrpContext->OriginatingIrp;

    if (Irp != NULL) {

        IrpSp = IoGetCurrentIrpStackLocation( Irp );
    }

    //
    //  Now because we are the Fsp we will force the IrpContext to
    //  indicate true on Wait.
    //

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  If this request has an associated volume device object, remember it.
    //

    if ((Irp != NULL) &&
        (IrpSp->FileObject != NULL)) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );

        ObReferenceObject( IrpSp->DeviceObject );

    } else {

        VolDo = NULL;
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate FSP routine or case on the minor
    //  function and then call the FSP routine.  The FSP routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble (e.g., if NtfsReadSectorsSync has trouble).
    //

    while (TRUE) {

        FsRtlEnterFileSystem();

        ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );

        NtfsPostRequests += 1;

        do {

            //
            //  If this is the initial try with this Irp Context, update the
            //  top level Irp fields.
            //
    
            NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );
    
            Retry = FALSE;
    
            try {

                //
                //  Always clear the exception code in the IrpContext so we respond
                //  correctly to errors encountered in the Fsp.
                //

                IrpContext->ExceptionStatus = 0;
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP );

                //
                //  See if we were posted due to a log file full condition, and
                //  if so, then do a clean volume checkpoint if we are the
                //  first ones to get there.  If we see a different Lsn and do
                //  not do the checkpoint, the worst that can happen is that we
                //  will get posted again if the log file is still full.
                //

                if (IrpContext->LastRestartArea.QuadPart != 0) {

                    NtfsCheckpointForLogFileFull( IrpContext );

                    if (++LogFileFullCount >= 2) {

                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                    }
                }

                //
                //  If we have an Irp then proceed with our normal processing.
                //

                if (Irp != NULL) {

                    switch ( IrpContext->MajorFunction ) {

                        //
                        //  For Create Operation,
                        //

                    case IRP_MJ_CREATE:

                            //
                            //  Clear the efs flag so we complete the irp 
                            //  Any poster will have set a completion routine to catch that
                            // 

                            ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE );
                            CreateContext = IrpContext->Union.CreateContext;
                            
                            if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_OPEN )) {

                                Status = NtfsCommonVolumeOpen( IrpContext, Irp );

                            } else {

                                RtlZeroMemory( CreateContext, sizeof( CREATE_CONTEXT ) );
                                Status = NtfsCommonCreate( IrpContext, Irp, CreateContext );
                            }
                            break;

                        //
                        //  For close operations
                        //

                        case IRP_MJ_CLOSE:

                            //
                            //  We should never post closes to this workqueue.
                            //

                            NtfsBugCheck( 0, 0, 0 );
                            break;

                        //
                        //  For read operations
                        //

                        case IRP_MJ_READ:

                            (VOID) NtfsCommonRead( IrpContext, Irp, TRUE );
                            break;

                        //
                        //  For write operations,
                        //

                        case IRP_MJ_WRITE:

                            (VOID) NtfsCommonWrite( IrpContext, Irp );
                            break;

                        //
                        //  For Query Information operations,
                        //

                        case IRP_MJ_QUERY_INFORMATION:

                            (VOID) NtfsCommonQueryInformation( IrpContext, Irp );
                            break;

                        //
                        //  For Set Information operations,
                        //

                        case IRP_MJ_SET_INFORMATION:

                            (VOID) NtfsCommonSetInformation( IrpContext, Irp );
                            break;

                        //
                        //  For Query EA operations,
                        //

                        case IRP_MJ_QUERY_EA:

                            (VOID) NtfsCommonQueryEa( IrpContext, Irp );
                            break;

                        //
                        //  For Set EA operations,
                        //

                        case IRP_MJ_SET_EA:

                            (VOID) NtfsCommonSetEa( IrpContext, Irp );
                            break;


                        //
                        //  For Flush buffers operations,
                        //

                        case IRP_MJ_FLUSH_BUFFERS:

                            (VOID) NtfsCommonFlushBuffers( IrpContext, Irp );
                            break;

                        //
                        //  For Query Volume Information operations,
                        //

                        case IRP_MJ_QUERY_VOLUME_INFORMATION:

                            (VOID) NtfsCommonQueryVolumeInfo( IrpContext, Irp );
                            break;

                        //
                        //  For Set Volume Information operations,
                        //

                        case IRP_MJ_SET_VOLUME_INFORMATION:

                            (VOID) NtfsCommonSetVolumeInfo( IrpContext, Irp );
                            break;

                        //
                        //  For File Cleanup operations,
                        //

                        case IRP_MJ_CLEANUP:

                            (VOID) NtfsCommonCleanup( IrpContext, Irp );
                            break;

                        //
                        //  For Directory Control operations,
                        //

                        case IRP_MJ_DIRECTORY_CONTROL:

                            (VOID) NtfsCommonDirectoryControl( IrpContext, Irp );
                            break;

                        //
                        //  For File System Control operations,
                        //

                        case IRP_MJ_FILE_SYSTEM_CONTROL:

                            (VOID) NtfsCommonFileSystemControl( IrpContext, Irp );
                            break;

                        //
                        //  For Lock Control operations,
                        //

                        case IRP_MJ_LOCK_CONTROL:

                            (VOID) NtfsCommonLockControl( IrpContext, Irp );
                            break;

                        //
                        //  For Device Control operations,
                        //

                        case IRP_MJ_DEVICE_CONTROL:

                            (VOID) NtfsCommonDeviceControl( IrpContext, Irp );
                            break;

                        //
                        //  For Query Security Information operations,
                        //

                        case IRP_MJ_QUERY_SECURITY:

                            (VOID) NtfsCommonQuerySecurityInfo( IrpContext, Irp );
                            break;

                        //
                        //  For Set Security Information operations,
                        //

                        case IRP_MJ_SET_SECURITY:

                            (VOID) NtfsCommonSetSecurityInfo( IrpContext, Irp );
                            break;

                        //
                        //  For Query Quota operations,
                        //

                        case IRP_MJ_QUERY_QUOTA:

                            (VOID) NtfsCommonQueryQuota( IrpContext, Irp );
                            break;

                        //
                        //  For Set Quota operations,
                        //

                        case IRP_MJ_SET_QUOTA:

                            (VOID) NtfsCommonSetQuota( IrpContext, Irp );
                            break;

                        //
                        //  For any other major operations, return an invalid
                        //  request.
                        //

                        default:

                            NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                            break;
                    }

                //
                //  Otherwise complete the request to clean up this Irp Context.
                //

                } else {

                    NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
                    IrpContext = NULL;
                }

                ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
        
            } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

                //
                //  We had some trouble trying to perform the requested
                //  operation, so we'll abort the I/O request with
                //  the error status that we get back from the
                //  execption code
                //

                if (Irp != NULL) {

                    IrpSp = IoGetCurrentIrpStackLocation( Irp );

                    Status = GetExceptionCode();

                    if ((Status == STATUS_FILE_DELETED) && 
                        ((IrpContext->MajorFunction == IRP_MJ_READ) || 
                         (IrpContext->MajorFunction == IRP_MJ_WRITE) || 
                         ((IrpContext->MajorFunction == IRP_MJ_SET_INFORMATION) &&
                          (IrpSp->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation)))) {

                        IrpContext->ExceptionStatus = Status = STATUS_SUCCESS;
                    }
                }
                
                //
                //  If we failed to upgrade the volume's version during mount, we may
                //  not have put the right exception code into the irp context yet.
                //
                
                if ((IrpContext != NULL) &&
                    (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_VOL_UPGR_FAILED )) &&
                    (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                    (IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME)) {

                    IrpContext->ExceptionStatus = Status;
                }

                //  
                //  This is the return status code that we want the Irp Completion routine to receive.
                //

                Status = NtfsProcessException( IrpContext, Irp, Status );

                if ((Status == STATUS_CANT_WAIT) || (Status == STATUS_LOG_FILE_FULL)) {

                    Retry = TRUE;
                }
            }

        } while (Retry);

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (VolDo != NULL) {

            KIRQL SavedIrql;
            PLIST_ENTRY Entry = NULL;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

            while (VolDo->OverflowQueueCount > 0) {

                //
                //  There is overflow work to do in this volume so we'll
                //  decrement the Overflow count, dequeue the IRP, and release
                //  the Event
                //

                Entry = VolDo->OverflowQueue.Flink;
                IrpContext = CONTAINING_RECORD( Entry,
                                                IRP_CONTEXT,
                                                WorkQueueItem.List );
                Irp = IrpContext->OriginatingIrp;

                //
                //  If the cancel routine thinks it owns the irp ignore it
                //  

                if (NtfsSetCancelRoutine( Irp, NULL, 0, FALSE )) {
                    
                    VolDo->OverflowQueueCount -= 1;
                    RemoveEntryList( (PLIST_ENTRY)Entry );
                    //
                    //  Reset the shared fields
                    //  

                    InitializeListHead( &IrpContext->RecentlyDeallocatedQueue );
                    InitializeListHead( &IrpContext->ExclusiveFcbList );

                    break;
                
                } else {

                    //
                    //  Release the spinlock to let the cancel routine gain it and finish
                    //  its action
                    //  

                    KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );
                    KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );
                    Entry = NULL;
                }
            } //  endwhile

            //
            //  There wasn't an entry, so before dropping the spinlock decrement the posted
            //  count to be in synch with NtfsAddToWorkQueue and deref the device
            //

            if (Entry == NULL) {
                VolDo->PostedRequestCount -= 1;
                KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );
                ObDereferenceObject( &VolDo->DeviceObject );
                break;
            } else {
                
                KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );
            }

            if (VolDo->OverflowQueueCount < OVERFLOW_QUEUE_LIMIT) {
                KeSetEvent( &VolDo->OverflowQueueEvent, IO_NO_INCREMENT, FALSE );
            }

            //
            //  set wait to TRUE, and loop.
            //

            LogFileFullCount = 0;
            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
            continue;

        } else {

            //
            //  No VolDo so just leave
            //  

            break;
        }
    }

    return;
}

VOID
NtfsPostSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN POST_SPECIAL_CALLOUT PostSpecialCallout,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine posts a special request to a worker thread.  The function
    to be called is passed in.  The Vcb is referenced to ensure it is not
    deleted while the posted request is excuting.

Arguments:

    Vcb - Volume control block for volume to post to.

    PostSpecialCallout - Function to be called from the worker thread.

    Context - Context point to pass to the function.

Return Value:

    None

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    //
    //  Create an IrpContext for use to post the request.
    //

    NtfsInitializeIrpContext( NULL, TRUE, &NewIrpContext );
    NewIrpContext->Vcb = Vcb;

    NewIrpContext->Union.PostSpecialCallout = PostSpecialCallout;
    NewIrpContext->OriginatingIrp = Context;

    //
    //  Updating the CloseCount and SystemFileCloseCount allows the volume
    //  to be locked or dismounted, but the Vcb will not be deleted.  This
    //  routine will only be called with non-zero close counts so it is ok
    //  to increment theses counts.
    //

    ASSERT( Vcb->CloseCount > 0 );
    InterlockedIncrement( &Vcb->CloseCount );
    InterlockedIncrement( &Vcb->SystemFileCloseCount );

    RtlZeroMemory( &NewIrpContext->WorkQueueItem, sizeof( WORK_QUEUE_ITEM ) );

    ExInitializeWorkItem( &NewIrpContext->WorkQueueItem,
                          NtfsSpecialDispatch,
                          NewIrpContext );

    //
    //  Determine if the scavenger is already running.
    //

    ExAcquireFastMutexUnsafe( &NtfsScavengerLock );

    if (NtfsScavengerRunning) {

        //
        //  Add this item to the scavanger work list.
        //

        NewIrpContext->WorkQueueItem.List.Flink = NULL;

        if (NtfsScavengerWorkList == NULL) {

            NtfsScavengerWorkList = NewIrpContext;
        } else {
            PIRP_CONTEXT WorkIrpContext;

            WorkIrpContext = NtfsScavengerWorkList;

            while (WorkIrpContext->WorkQueueItem.List.Flink != NULL) {
                WorkIrpContext = (PIRP_CONTEXT)
                            WorkIrpContext->WorkQueueItem.List.Flink;
            }

            WorkIrpContext->WorkQueueItem.List.Flink = (PLIST_ENTRY)
                                                            NewIrpContext;
        }

    } else {

        //
        //  Start a worker thread to do scavenger work.
        //

        ExQueueWorkItem( &NewIrpContext->WorkQueueItem, DelayedWorkQueue );
        NtfsScavengerRunning = TRUE;
    }

    ExReleaseFastMutexUnsafe( &NtfsScavengerLock);
}


VOID
NtfsSpecialDispatch (
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when a special operation needs to be posted.
    It is called indirectly by NtfsPostSpecial.  It is assumes that the
    Vcb is protected from going away by incrementing the volemue close
    counts for a file.  If this routine fails nothing is done except
    to clean up the Vcb.  This routine also handles issues log file full
    and can't wait.

    The function to be called is stored in the PostSpecialCallout field
    of the Irp Context, and the context is stored int he OriginatingIrp.
    Both fields are zeroed before the the callout function is called.

Arguments:

    Context - Supplies a pointer to an IrpContext.

Return Value:

--*/

{
    PVCB Vcb;
    PIRP_CONTEXT IrpContext = Context;
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    POST_SPECIAL_CALLOUT PostSpecialCallout;
    PVOID SpecialContext;
    ULONG LogFileFullCount;
    BOOLEAN Retry;

    PAGED_CODE();

    FsRtlEnterFileSystem();

    do {

        Vcb = IrpContext->Vcb;
        LogFileFullCount = 0;

        //
        //  Capture the funciton pointer and context before using the IrpContext.
        //

        PostSpecialCallout = IrpContext->Union.PostSpecialCallout;
        SpecialContext = IrpContext->OriginatingIrp;
        IrpContext->Union.PostSpecialCallout = NULL;
        IrpContext->OriginatingIrp = NULL;

        //
        //  Reset the shared fields
        //  

        InitializeListHead( &IrpContext->RecentlyDeallocatedQueue );
        InitializeListHead( &IrpContext->ExclusiveFcbList );

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );
        ASSERT( ThreadTopLevelContext == &TopLevelContext );
        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));
        ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ALLOC_FROM_POOL ));

        //
        //  Initialize the thread top level structure, if needed.
        //

        ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        //
        //  Don't let this IrpContext be deleted.
        //

        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        do {

            Retry = FALSE;

            try {

                //
                //  See if we failed due to a log file full condition, and
                //  if so, then do a clean volume checkpoint if we are the
                //  first ones to get there.  If we see a different Lsn and do
                //  not do the checkpoint, the worst that can happen is that we
                //  will fail again if the log file is still full.
                //

                if (IrpContext->LastRestartArea.QuadPart != 0) {

                    NtfsCheckpointForLogFileFull( IrpContext );

                    if (++LogFileFullCount >= 2) {

                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                    }
                }

                //
                //  Call the requested function.
                //

                ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));
                PostSpecialCallout( IrpContext, SpecialContext );

                NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

                NTSTATUS ExceptionCode;

                ExceptionCode = GetExceptionCode();
                ExceptionCode = NtfsProcessException( IrpContext, NULL, ExceptionCode );

                if ((ExceptionCode == STATUS_CANT_WAIT) ||
                    (ExceptionCode == STATUS_LOG_FILE_FULL)) {

                    Retry = TRUE;
                }
            }

        } while (Retry);

        //
        //  Ok to let this IrpContext be deleted.
        //

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

        //
        //  At this point regardless of the status the volume needs to
        //  be cleaned up and the IrpContext freed.
        //  Dereference the Vcb and check to see if it needs to be deleted.
        //  since this call might raise wrap it with a try/execpt.
        //

        try {

            //
            //  Acquire the volume exclusive so the counts can be
            //  updated.
            //

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));
            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

            InterlockedDecrement( &Vcb->SystemFileCloseCount );
            InterlockedDecrement( &Vcb->CloseCount );

            NtfsReleaseVcb( IrpContext, Vcb );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            ASSERT( FsRtlIsNtstatusExpected( GetExceptionCode() ) );
        }

        //
        //  Free the irp context.
        //

        NtfsCleanupIrpContext( IrpContext, TRUE );

        //
        //  See if there is more work on the scavenger list.
        //

        ExAcquireFastMutexUnsafe( &NtfsScavengerLock );

        ASSERT( NtfsScavengerRunning );

        IrpContext = NtfsScavengerWorkList;

        if (IrpContext != NULL) {

            //
            //  Remove the entry from the list.
            //

            NtfsScavengerWorkList = (PIRP_CONTEXT) IrpContext->WorkQueueItem.List.Flink;

        } else {

            NtfsScavengerRunning = FALSE;

        }

        ExReleaseFastMutexUnsafe( &NtfsScavengerLock );

    } while ( IrpContext != NULL );

    FsRtlExitFileSystem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\hashsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    HashSup.c

Abstract:

    This module implements the Ntfs hasing support routines

Author:

    Chris Davis     [CDavis]        2-May-1997
    Brian Andrew    [BrianAn]       29-Dec-1998

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_HASHSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_HASHSUP)

/*
    Here are 10 primes slightly greater than 10^9 which may come in handy
    1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    1000000093, 1000000097, 1000000103, 1000000123, 1000000181
*/

//
//  Local definitions
//

//
//  Hash value is modula this value.
//

#define HASH_PRIME                          (1048583)

//
//  Bucket depth before starting to split.
//

#ifdef NTFS_HASH_DATA
#define HASH_MAX_BUCKET_DEPTH               (7)
ULONG NtfsInsertHashCount = 0;
BOOLEAN NtfsFillHistogram = FALSE;
VOID
NtfsFillHashHistogram (
    PNTFS_HASH_TABLE Table
    );
#else
#define HASH_MAX_BUCKET_DEPTH               (5)
#endif

//
//  VOID
//  NtfsHashBucketFromHash (
//      IN PNTFS_HASH_TABLE Table,
//      IN ULONG Hash,
//      OUT PULONG Index
//      );
//

#define NtfsHashBucketFromHash(T,H,PI) {            \
    *(PI) = (H) & ((T)->MaxBucket - 1);             \
    if (*(PI) < (T)->SplitPoint) {                  \
        *(PI) = (H) & ((2 * (T)->MaxBucket) - 1);   \
    }                                               \
}

//
//  VOID
//  NtfsGetHashSegmentAndIndex (
//      IN ULONG HashBucket,
//      IN PULONG HashSegment,
//      IN PULONG HashIndex
//      );
//

#define NtfsGetHashSegmentAndIndex(B,S,I) { \
    *(S) = (B) >> HASH_INDEX_SHIFT;         \
    *(I) = (B) & (HASH_MAX_INDEX_COUNT - 1);\
}


//
//  Local procedures
//

VOID
NtfsInitHashSegment (
    IN OUT PNTFS_HASH_TABLE Table,
    IN ULONG SegmentIndex
    );

PNTFS_HASH_ENTRY
NtfsLookupHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN ULONG FullNameLength,
    IN ULONG HashValue,
    IN PNTFS_HASH_ENTRY CurrentEntry OPTIONAL
    );

BOOLEAN
NtfsAreHashNamesEqual (
    IN PSCB StartingScb,
    IN PLCB HashLcb,
    IN PUNICODE_STRING RelativeName
    );

VOID
NtfsExpandHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAreHashNamesEqual)
#pragma alloc_text(PAGE, NtfsExpandHashTable)
#pragma alloc_text(PAGE, NtfsFindPrefixHashEntry)
#pragma alloc_text(PAGE, NtfsInitHashSegment)
#pragma alloc_text(PAGE, NtfsInitializeHashTable)
#pragma alloc_text(PAGE, NtfsInsertHashEntry)
#pragma alloc_text(PAGE, NtfsLookupHashEntry)
#pragma alloc_text(PAGE, NtfsRemoveHashEntry)
#pragma alloc_text(PAGE, NtfsUninitializeHashTable)
#endif


VOID
NtfsInitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    )

/*++
Routine Description:

    This routine is called to initialize the hash table.  We set this up with a single
    hash segment. May raise due to InitHashSegment

Arguments:

    Table - Hash table to initialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    RtlZeroMemory( Table, sizeof( NTFS_HASH_TABLE ));
    NtfsInitHashSegment( Table, 0 );

    Table->MaxBucket = HASH_MAX_INDEX_COUNT;

    return;
}


VOID
NtfsUninitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    )

/*++
Routine Description:

    This routine will uninitialize the hash table.  Note that all of the buckets should be
    empty.

Arguments:

    Table - Hash table.

Return Value:

    None

--*/

{
    PNTFS_HASH_SEGMENT *ThisSegment;
    PNTFS_HASH_SEGMENT *LastSegment;

    PAGED_CODE();

    //
    //  Walk through the array of hash segments.
    //

    ThisSegment = &Table->HashSegments[0];
    LastSegment = &Table->HashSegments[HASH_MAX_SEGMENT_COUNT - 1];

    while (*ThisSegment != NULL) {

        NtfsFreePool( *ThisSegment );
        *ThisSegment = NULL;

        if (ThisSegment == LastSegment) { break; }

        ThisSegment += 1;
    }

    return;
}


PLCB
NtfsFindPrefixHashEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_HASH_TABLE Table,
    IN PSCB ParentScb,
    OUT PULONG CreateFlags,
    IN OUT PFCB *CurrentFcb,
    OUT PULONG FileHashValue,
    OUT PULONG FileNameLength,
    OUT PULONG ParentHashValue,
    OUT PULONG ParentNameLength,
    IN OUT PUNICODE_STRING RemainingName
    )

/*++
Routine Description:

    This routine is called to look for a match in the hash table for the given
    starting Scb and remaining name.  We will first look for the full name, if
    we don't find a match on that we will check for a matching parent string.

Arguments:

    Table - Hash table to process.

    ParentScb - The name search begins from this directory.  The Scb is
        initially acquired and its Fcb is stored in *CurrentFcb.

    OwnParentScb - Boolean which indicates if this thread owns the parent Scb.

    CurrentFcb - Points to the last Fcb acquired.  If we need to perform a
        teardown it will begin from this point.

    FileHashValue - Address to store the hash value for the input string.  Applies to
        the full string and starting Scb even if a match wasn't found.

    FileNameLength - Location to store the length of the relative name which
        matches the hash value generated above.  If we didn't generate a hash
        then we will return a 0 for the length.

    ParentHashValue - Address to store the hash value for the parent of the input string.
        Applies to parent of the full string and starting Scb even if a match wasn't found
        for the full string.

    ParentNameLength - Location to store the length of the parent of the full name.
        It corresponds to the parent hash generated above.  Note that our caller
        will have to check the remaining name on return to know if the parent hash
        was computed.  If we didn't generate a hash for the parent above then
        we will return 0 for the length.

    RemainingName - Name relative to the StartingScb above, on return it will be
        the unmatched portion of the name.

Return Value:

    PLCB - Pointer to the Lcb found in the hash lookup or FALSE if no Lcb is found.
        If an Lcb is found then we will own the Fcb for it exclusively on return.

--*/

{
    PVCB Vcb = ParentScb->Vcb;
    PNTFS_HASH_ENTRY FoundEntry;
    PLCB FoundLcb = NULL;
    UNICODE_STRING TempName;
    WCHAR Separator = L'\\';
    ULONG RemainingNameLength;
    PWCHAR RemainingNameBuffer;
    PWCHAR NextChar;

    PAGED_CODE();

    ASSERT( RemainingName->Length != 0 );
    ASSERT( RemainingName->Buffer[0] != L'\\' );
    ASSERT( RemainingName->Buffer[0] != L':' );
    ASSERT( ParentScb->AttributeTypeCode == $INDEX_ALLOCATION );

    //
    //  Compute the hash for the file before acquiring the hash table.
    //

    *ParentHashValue = *FileHashValue = ParentScb->ScbType.Index.HashValue;

    //
    //  Check whether we need to generate the separator.
    //

    if (ParentScb != Vcb->RootIndexScb) {

        NtfsConvertNameToHash( &Separator, sizeof( WCHAR ), Vcb->UpcaseTable, FileHashValue );
    }

    //
    //  Generate the hash for the file name.
    //

    NtfsConvertNameToHash( RemainingName->Buffer,
                           RemainingName->Length,
                           Vcb->UpcaseTable,
                           FileHashValue );

    *FileHashValue = NtfsGenerateHashFromUlong( *FileHashValue );


    NtfsAcquireHashTable( Vcb );

    //
    //  Generate the hash value based on the starting Scb and the string.
    //  Return immediately if there is no parent name.
    //

    if (ParentScb->ScbType.Index.NormalizedName.Length == 0) {

        NtfsReleaseHashTable( Vcb );
        return NULL;
    }

    *ParentNameLength = *FileNameLength = ParentScb->ScbType.Index.NormalizedName.Length;
    *FileNameLength += RemainingName->Length;

#ifdef NTFS_HASH_DATA
    Table->HashLookupCount += 1;
#endif

    //
    //  Check whether to include a separator.
    //

    if (ParentScb != Vcb->RootIndexScb) {

        *FileNameLength += sizeof( WCHAR );
    }

    //
    //  Loop looking for a match on the hash value and then verify the name.
    //

    FoundEntry = NULL;

    while ((FoundEntry = NtfsLookupHashEntry( Table,
                                              *FileNameLength,
                                              *FileHashValue,
                                              FoundEntry )) != NULL) {

        //
        //  If we have a match then verify the name strings.
        //

        if (NtfsAreHashNamesEqual( ParentScb,
                                   FoundEntry->HashLcb,
                                   RemainingName )) {

            //
            //  The name string match.  Adjust the input remaining name to
            //  show there is no name left to process.
            //

            FoundLcb = FoundEntry->HashLcb;

            //
            //  Move to the end of the input string.
            //

            RemainingNameLength = 0;
            RemainingNameBuffer = Add2Ptr( RemainingName->Buffer,
                                           RemainingName->Length );

            //
            //  Show that we never generated a parent hash.  No need to
            //  remember the file hash in this case either.
            //

#ifdef NTFS_HASH_DATA
            Table->FileMatchCount += 1;
#endif
            *ParentNameLength = 0;
            *FileNameLength = 0;
            break;
        }
    }

    //
    //  If we don't have a match then let's look at a possible parent string.
    //

    if (FoundLcb == NULL) {

        //
        //  Search backwards for a '\'.  If it is a '\' then do the
        //  same search for a match on the string based on the parent.
        //

        TempName.Length = RemainingName->Length;
        NextChar = &RemainingName->Buffer[ (TempName.Length - sizeof( WCHAR )) / sizeof( WCHAR ) ];

        while (TRUE) {

            //
            //  Break out if no separator is found.
            //

            if (TempName.Length == 0) {

                *ParentNameLength = 0;
                break;
            }

            if (*NextChar == L'\\') {

                //
                //  We found the separator.  Back up one more character to step over
                //  the '\' character and then complete a hash for the parent.
                //

                TempName.Buffer = RemainingName->Buffer;
                TempName.Length -= sizeof( WCHAR );
                TempName.MaximumLength = TempName.Length;

                //
                //  Drop the mutex while we compute the hash.
                //

                NtfsReleaseHashTable( Vcb );

                if (ParentScb != Vcb->RootIndexScb) {

                    NtfsConvertNameToHash( &Separator, sizeof( WCHAR ), Vcb->UpcaseTable, ParentHashValue );
                    *ParentNameLength += sizeof( WCHAR );
                }

                NtfsConvertNameToHash( TempName.Buffer,
                                       TempName.Length,
                                       Vcb->UpcaseTable,
                                       ParentHashValue );

                *ParentHashValue = NtfsGenerateHashFromUlong( *ParentHashValue );
                *ParentNameLength += TempName.Length;

                NtfsAcquireHashTable( Vcb );

                FoundEntry = NULL;
                while ((FoundEntry = NtfsLookupHashEntry( Table,
                                                          *ParentNameLength,
                                                          *ParentHashValue,
                                                          FoundEntry )) != NULL) {

                    //
                    //  If we have a match then verify the name strings.
                    //

                    if (NtfsAreHashNamesEqual( ParentScb,
                                               FoundEntry->HashLcb,
                                               &TempName )) {

                        //
                        //  The name string match.  Adjust the remaining name to
                        //  swallow the parent string found.
                        //

                        FoundLcb = FoundEntry->HashLcb;

                        RemainingNameLength = RemainingName->Length - (TempName.Length + sizeof( WCHAR ));
                        RemainingNameBuffer = Add2Ptr( RemainingName->Buffer,
                                                       TempName.Length + sizeof( WCHAR ));

#ifdef NTFS_HASH_DATA
                        Table->ParentMatchCount += 1;
#endif
                        *ParentNameLength = 0;
                        break;
                    }

                }

                //
                //  No match found.  Break out in any case.
                //

                break;
            }

            TempName.Length -= sizeof( WCHAR );
            NextChar -= 1;
        }
    }

    //
    //  We now have the Lcb to return.  We need to carefully acquire the Fcb for this Lcb.
    //  We can't acquire it while waiting because of deadlock possibilities.
    //

    if (FoundLcb != NULL) {

        UCHAR LcbFlags;
        BOOLEAN CreateNewLcb = FALSE;
        ULONG RemainingNameOffset;

        //
        //  While we own the hash table it will be safe to copy the exact case of the
        //  names over to our input buffer.  We will work our way backwards through the
        //  remaining name passed to us.
        //

        RemainingNameOffset = RemainingNameLength + FoundLcb->ExactCaseLink.LinkName.Length;

        //
        //  If this was a match on the parent then step back over the '\'.
        //  We know there must be a separator.
        //

        if (RemainingNameLength != 0) {

            RemainingNameOffset += sizeof( WCHAR );
        }

        //
        //  Now back up the length of the name in the Lcb.  Save this location in
        //  case we have to look up the Lcb again.
        //

        TempName.Buffer = Add2Ptr( RemainingName->Buffer,
                                   RemainingName->Length - RemainingNameOffset );

        TempName.MaximumLength = TempName.Length = FoundLcb->ExactCaseLink.LinkName.Length;

        RtlCopyMemory( TempName.Buffer,
                       FoundLcb->ExactCaseLink.LinkName.Buffer,
                       FoundLcb->ExactCaseLink.LinkName.Length );

        //
        //  Now the balance of the name which is part of the Lcb->Scb parent name.
        //

        if (RemainingNameOffset != RemainingName->Length) {

            //
            //  There are prior components in our input string.  We want to back up
            //  over the preceding backslash and then copy over the relevant portion
            //  of the normalized name.
            //

            RemainingNameOffset = RemainingName->Length - (RemainingNameOffset + sizeof( WCHAR ));

            RtlCopyMemory( RemainingName->Buffer,
                           Add2Ptr( FoundLcb->Scb->ScbType.Index.NormalizedName.Buffer,
                                    FoundLcb->Scb->ScbType.Index.NormalizedName.Length - RemainingNameOffset ),
                           RemainingNameOffset );
        }

        if (!NtfsAcquireFcbWithPaging( IrpContext, FoundLcb->Fcb, ACQUIRE_DONT_WAIT )) {

            PFCB ThisFcb = FoundLcb->Fcb;
            PFCB ParentFcb = FoundLcb->Scb->Fcb;
            PSCB ThisScb;

            //
            //  Remember the current Lcb flags.
            //

            LcbFlags = FoundLcb->FileNameAttr->Flags;

            //
            //  Acquire the Fcb table and reference the Fcb.  Then release the hash table, Fcb table
            //  and ParentScb.  We should now be able to acquire the Fcb.  Reacquire the Fcb table
            //  to clean up the Fcb reference count.  Finally verify that the Lcb is still in the
            //  hash table (requires another lookup).
            //

            NtfsAcquireFcbTable( IrpContext, Vcb );
            ThisFcb->ReferenceCount += 1;
            ParentFcb->ReferenceCount += 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            NtfsReleaseScb( IrpContext, ParentScb );
            ClearFlag( *CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
            *CurrentFcb = NULL;

            NtfsReleaseHashTable( Vcb );

            NtfsAcquireFcbWithPaging( IrpContext, ThisFcb, 0 );
            *CurrentFcb = ThisFcb;
            NtfsAcquireSharedFcb( IrpContext, ParentFcb, NULL, 0 );

            NtfsAcquireFcbTable( IrpContext, Vcb );
            ThisFcb->ReferenceCount -= 1;
            ParentFcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            //
            //  Now look for an existing Scb and Lcb.
            //

            ThisScb = NtfsCreateScb( IrpContext,
                                     ParentFcb,
                                     $INDEX_ALLOCATION,
                                     &NtfsFileNameIndex,
                                     TRUE,
                                     NULL );

            if (ThisScb == NULL) {

#ifdef NTFS_HASH_DATA
                Table->CreateScbFails += 1;
#endif
                NtfsReleaseFcb( IrpContext, ParentFcb );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            FoundLcb = NtfsCreateLcb( IrpContext,
                                      ThisScb,
                                      ThisFcb,
                                      TempName,
                                      LcbFlags,
                                      &CreateNewLcb );

            NtfsReleaseFcb( IrpContext, ParentFcb );

            //
            //  If this wasn't an existing Lcb then reacquire the starting Scb.
            //  This is the rare case so raise CANT_WAIT and retry.
            //

            if (FoundLcb == NULL) {

#ifdef NTFS_HASH_DATA
                Table->CreateLcbFails += 1;
#endif
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

        //
        //  Release the starting Scb and remember our current Fcb.
        //

        } else {

            NtfsReleaseHashTable( Vcb );

            NtfsReleaseScb( IrpContext, ParentScb );
            ClearFlag( *CreateFlags, CREATE_FLAG_SHARED_PARENT_FCB );
            *CurrentFcb = FoundLcb->Fcb;
        }

        //
        //  If we still have the Lcb then update the remaining name string.
        //

        if (FoundLcb != NULL) {

            RemainingName->Length = (USHORT) RemainingNameLength;
            RemainingName->Buffer = RemainingNameBuffer;
        }

    } else {

        NtfsReleaseHashTable( Vcb );
    }

    return FoundLcb;
}


VOID
NtfsInsertHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb,
    IN ULONG NameLength,
    IN ULONG HashValue
    )

/*++
Routine Description:

    This routine will insert a entry into the hash table. May raise due to
    memory allocation.

Arguments:

    Table - Hash table.

    HashLcb - Final target of the hash operation.

    NameLength - Full path used to reach the hash value.

    HashValue - Hash value to insert.

Return Value:

    None

--*/

{
    PNTFS_HASH_ENTRY NewHashEntry;

    ULONG Segment;
    ULONG Index;

    ULONG Bucket;

    PAGED_CODE();

    //
    //  Allocate and initialize the hash entry.  Nothing to do if unsuccessful.
    //

    NewHashEntry = NtfsAllocatePoolNoRaise( PagedPool, sizeof( NTFS_HASH_ENTRY ));

    if (NewHashEntry == NULL) {

        return;
    }

    NewHashEntry->HashValue = HashValue;
    NewHashEntry->FullNameLength = NameLength;
    NewHashEntry->HashLcb = HashLcb;

    //
    //  Find the bucket to insert into and then do the insertion.
    //

    NtfsAcquireHashTable( HashLcb->Fcb->Vcb );

    //
    //  Continue the process of growing the table if needed.
    //

    if (Table->TableState == TABLE_STATE_EXPANDING) {

        NtfsExpandHashTable( Table );
    }

    NtfsHashBucketFromHash( Table, HashValue, &Bucket );
    NtfsGetHashSegmentAndIndex( Bucket, &Segment, &Index );

    NewHashEntry->NextEntry = (*Table->HashSegments[ Segment ])[ Index ];
    (*Table->HashSegments[ Segment ])[ Index ] = NewHashEntry;

#ifdef NTFS_HASH_DATA
    NtfsInsertHashCount += 1;

    if (!FlagOn( NtfsInsertHashCount, 0xff ) && NtfsFillHistogram) {

        NtfsFillHashHistogram( Table );
    }
#endif

    NtfsReleaseHashTable( HashLcb->Fcb->Vcb );

    //
    //  Remember that we've inserted a hash.
    //

    HashLcb->HashValue = HashValue;
    SetFlag( HashLcb->LcbState, LCB_STATE_VALID_HASH_VALUE );

    return;
}


VOID
NtfsRemoveHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb
    )

/*++
Routine Description:

    This routine will remove all entries with a given hash value for the given Lcb.

Arguments:

    Table - Hash table.

    HashLcb - Final target of the hash operation.

Return Value:

    None

--*/

{
    PNTFS_HASH_ENTRY *NextHashEntry;
    PNTFS_HASH_ENTRY CurrentEntry;

    ULONG Segment;
    ULONG Index;

    ULONG Bucket;

    ULONG BucketDepth = 0;

    PAGED_CODE();

    NtfsAcquireHashTable( HashLcb->Fcb->Vcb );

    //
    //  Find the bucket to remove from and then search for this hash value.
    //

    NtfsHashBucketFromHash( Table, HashLcb->HashValue, &Bucket );
    NtfsGetHashSegmentAndIndex( Bucket, &Segment, &Index );

    //
    //  Get the address of the first entry.
    //

    NextHashEntry = (PNTFS_HASH_ENTRY *) &(*Table->HashSegments[ Segment ])[ Index ];

    while (*NextHashEntry != NULL) {

        //
        //  Look for a match entry.
        //

        if (((*NextHashEntry)->HashValue == HashLcb->HashValue) &&
            ((*NextHashEntry)->HashLcb == HashLcb)) {

            CurrentEntry = *NextHashEntry;

            *NextHashEntry = CurrentEntry->NextEntry;

            NtfsFreePool( CurrentEntry );

        //
        //  Move to the next entry but remember the depth of the bucket.
        //

        } else {

            NextHashEntry = &(*NextHashEntry)->NextEntry;
            BucketDepth += 1;
        }
    }

    //
    //  Check if the bucket depth is greater than our max.
    //

    if ((BucketDepth > HASH_MAX_BUCKET_DEPTH) &&
        (Table->TableState == TABLE_STATE_STABLE) &&
        (Table->MaxBucket < HASH_MAX_BUCKET_COUNT)) {

        ASSERT( Table->SplitPoint == 0 );
        Table->TableState = TABLE_STATE_EXPANDING;
    }

    NtfsReleaseHashTable( HashLcb->Fcb->Vcb );

    HashLcb->HashValue = 0;
    ClearFlag( HashLcb->LcbState, LCB_STATE_VALID_HASH_VALUE );

    return;
}


//
//  Local support routine
//

VOID
NtfsInitHashSegment (
    IN OUT PNTFS_HASH_TABLE Table,
    IN ULONG SegmentIndex
    )

/*++

Routine Description:

    This routine allocates and initializes a new segment in the segment array.
    It may raise out of resources.

Arguments:

    Table - Table with an entry to initialize.

    SegmentIndex - Index to be initialized.

Return Value:

    None

--*/

{
    PAGED_CODE();

    Table->HashSegments[ SegmentIndex ] = NtfsAllocatePool( PagedPool, sizeof( NTFS_HASH_SEGMENT ));
    RtlZeroMemory( Table->HashSegments[ SegmentIndex ], sizeof( NTFS_HASH_SEGMENT ));

    return;
}


//
//  Local support routine
//

PNTFS_HASH_ENTRY
NtfsLookupHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN ULONG FullNameLength,
    IN ULONG HashValue,
    IN PNTFS_HASH_ENTRY CurrentEntry OPTIONAL
    )

/*++

Routine Description:

    This routine looks up a match in the hash table for a given hash value.
    The entry is uniquely indentified by the hash value, and the full name length.
    This routine also takes a pointer to a hash entry for the case where we are
    resuming a search for the same hash value.

    If the target bucket has more than our optimal number of entries then set
    the state of the table to grow the number of buckets.

Arguments:

    Table - Hash table to search

    FullNameLength - Number of bytes in the name relative to the root.

    HashValue - Precomputed hash value.

    CurrentEntry - NULL if this is the first search for this hash entry.  Otherwise
        it is the last entry returned.

Return Value:

    PNTFS_HASH_ENTRY - this is NULL if no match was found.  Otherwise it points it to
        a hash entry which matches the input value.  NOTE - the caller must then verify
        the name strings.

--*/

{
    ULONG ChainDepth = 0;
    PNTFS_HASH_ENTRY NextEntry;
    ULONG HashBucket;
    ULONG HashSegment;
    ULONG HashIndex;

    PAGED_CODE();

    //
    //  If we weren't passed an initial hash entry then look up the start of
    //  the chain for the bucket containing this hash value.
    //

    if (!ARGUMENT_PRESENT( CurrentEntry )) {

        //
        //  Find the bucket by computing the segment and index to look in.
        //

        NtfsHashBucketFromHash( Table, HashValue, &HashBucket );
        NtfsGetHashSegmentAndIndex( HashBucket, &HashSegment, &HashIndex );

        //
        //  Get the first entry in the bucket.
        //

        NextEntry = (*Table->HashSegments[ HashSegment ])[ HashIndex ];

    //
    //  Otherwise we use the next entry in the chain.
    //

    } else {

        NextEntry = CurrentEntry->NextEntry;
    }

    //
    //  Walk down the chain looking for a match.  Keep track of the depth
    //  of the chain in case we need to grow the table.
    //

    while (NextEntry != NULL) {

        ChainDepth += 1;

        if ((NextEntry->HashValue == HashValue) &&
            (NextEntry->FullNameLength == FullNameLength)) {

            break;
        }

        NextEntry = NextEntry->NextEntry;
    }

    //
    //  If the depth is greater than our optimal value then mark the table
    //  for expansion.  The table may already be growing or at its maximum
    //  value.
    //

    if ((ChainDepth > HASH_MAX_BUCKET_DEPTH) &&
        (Table->TableState == TABLE_STATE_STABLE) &&
        (Table->MaxBucket < HASH_MAX_BUCKET_COUNT)) {

        ASSERT( Table->SplitPoint == 0 );
        Table->TableState = TABLE_STATE_EXPANDING;
    }

    //
    //  Return the value if found.
    //

    return NextEntry;
}


//
//  Local support routine
//

BOOLEAN
NtfsAreHashNamesEqual (
    IN PSCB StartingScb,
    IN PLCB HashLcb,
    IN PUNICODE_STRING RelativeName
    )

/*++
Routine Description:

    This routine is called to verify that the match found in the hash table has the
    same name as the input string.

Arguments:

    StartingScb - The name search begins from this directory.  It is not
        necessarily the parent of the file being opened.

    HashLcb - This is the Lcb found in the hash table.  This Lcb points
        directly to the full string matched.

    StartingName - This is the name we need to match.  It is 1 OR MORE of the
        final components of the name.

Return Value:

    None

--*/

{
    PUNICODE_STRING StartingScbName;
    PUNICODE_STRING HashScbName;
    UNICODE_STRING RemainingHashScbName;
    UNICODE_STRING RemainingRelativeName;
    USHORT SeparatorBias = 0;

    PAGED_CODE();

    //
    //  Start by verifying that there is a '\' separator in the correct positions.
    //  There must be a separator in the Relative name prior to the last component.
    //  There should also be a separator in the normalized name of the Scb in the
    //  HashLcb where the StartingScb ends.
    //

    //
    //  If the HashLcb Scb is not the StartingScb then there must be a separator
    //  where the StartingScb string ends.
    //

    StartingScbName = &StartingScb->ScbType.Index.NormalizedName;
    HashScbName = &HashLcb->Scb->ScbType.Index.NormalizedName;

    //
    //  If there is no normalized name in this Scb then get out.
    //

    if (HashScbName->Length == 0) {

        return FALSE;
    }

    if (StartingScb != HashLcb->Scb) {

        //
        //  Also get out if name in the StartingScb is longer than the one in the
        //  HashScb.  Obviously there is no match if the last component of the
        //  HashScb is longer than the last one or more components in
        //  the input name.  We can use >= as the test because if the lengths
        //  match but they aren't the same Scb then there can be no match either.
        //

        if (StartingScbName->Length >= HashScbName->Length) {

            return FALSE;
        }

        //
        //  Check for the separator provided the starting Scb is not the root.
        //

        if (StartingScb != StartingScb->Vcb->RootIndexScb) {

            if (HashScbName->Buffer[ StartingScbName->Length / sizeof( WCHAR ) ] != L'\\') {

                return FALSE;

            //
            //  Make sure the StartingScbName and the first part of the HashScbName
            //  match.  If not, this is definitely not the right hash entry.
            //

            } else {

                RemainingHashScbName.Buffer = HashScbName->Buffer;
                RemainingHashScbName.MaximumLength =
                RemainingHashScbName.Length = StartingScbName->Length;

                //
                //  OK to do a direct memory compare here because both name fragments
                //  are in the normalized form (exactly as on disk).
                //

                if (!NtfsAreNamesEqual( StartingScb->Vcb->UpcaseTable,
                                        StartingScbName,
                                        &RemainingHashScbName,
                                        FALSE )) {

                    return FALSE;
                }
            }

            SeparatorBias = sizeof( WCHAR );
        }

        //
        //  Set up a unicode string for the remaining portion of the hash scb name.
        //

        RemainingHashScbName.Buffer = Add2Ptr( HashScbName->Buffer,
                                               StartingScbName->Length + SeparatorBias );

        RemainingHashScbName.MaximumLength =
        RemainingHashScbName.Length = HashScbName->Length - (StartingScbName->Length + SeparatorBias);
    }

    RemainingRelativeName.MaximumLength =
    RemainingRelativeName.Length = HashLcb->IgnoreCaseLink.LinkName.Length;
    RemainingRelativeName.Buffer = Add2Ptr( RelativeName->Buffer,
                                            RelativeName->Length - RemainingRelativeName.Length );

    //
    //  Check for a separator between the last component of relative name and its parent.
    //  Verify the parent portion actually exists.
    //

    if (RemainingRelativeName.Length != RelativeName->Length) {

        if (*(RemainingRelativeName.Buffer - 1) != L'\\') {

            return FALSE;
        }
    }

    //
    //  Now verify that the tail of the name matches the name in the Lcb.
    //
    //  OK to do a direct memory compare here because both name fragments
    //  are already upcased.
    //
    //

    if (!NtfsAreNamesEqual( StartingScb->Vcb->UpcaseTable,
                            &HashLcb->IgnoreCaseLink.LinkName,
                            &RemainingRelativeName,
                            FALSE )) {

        return FALSE;
    }

    //
    //  It is possible that the StartingScb matches the Scb in the HashLcb.  If it doesn't
    //  then verify the other names in the name string.
    //

    if (StartingScb != HashLcb->Scb) {

        RemainingRelativeName.MaximumLength =
        RemainingRelativeName.Length = RemainingHashScbName.Length;
        RemainingRelativeName.Buffer = RelativeName->Buffer;

        //
        //  We must to a case-insensitive compare here because the
        //  HashScbName is in normalized form but the RemainingRelativeName
        //  is already upcased.
        //

        if (!NtfsAreNamesEqual( StartingScb->Vcb->UpcaseTable,
                                &RemainingHashScbName,
                                &RemainingRelativeName,
                                TRUE )) {

            return FALSE;
        }
    }

    return TRUE;
}


//
//  Local support routines
//


VOID
NtfsExpandHashTable(
    IN OUT PNTFS_HASH_TABLE Table
    )

/*++
Routine Description:

    This routine is called to add a single bucket to the hash table.  If we are at the
    last bucket then set the hash table state to stable.

Arguments:

    Table - Hash table to add a bucket to.

Return Value:

    None

--*/

{
    PNTFS_HASH_ENTRY *CurrentOldEntry;
    PNTFS_HASH_ENTRY *CurrentNewEntry;
    PNTFS_HASH_ENTRY CurrentEntry;

    ULONG OldSegment;
    ULONG OldIndex;

    ULONG NewSegment;
    ULONG NewIndex;

    ULONG NextBucket;


    PAGED_CODE();

    //
    //  Are we already at the maximum then return.
    //

    if (Table->MaxBucket == HASH_MAX_BUCKET_COUNT) {

        Table->TableState = TABLE_STATE_STABLE;
        return;
    }

    //
    //  If we have completed the split then set the state to stable and quit.
    //

    if (Table->MaxBucket == Table->SplitPoint) {

        Table->TableState = TABLE_STATE_STABLE;
        Table->MaxBucket *= 2;
        Table->SplitPoint = 0;

        return;
    }

    //
    //  Check if we need allocate a new segment.
    //

    if (!FlagOn( Table->SplitPoint, (HASH_MAX_INDEX_COUNT - 1))) {

        //
        //  If we can't allocate a new hash segment leave the table in its
        //  old state and return - we can still use it as is
        //

        try {
            NtfsInitHashSegment( Table, (Table->MaxBucket + Table->SplitPoint) >> HASH_INDEX_SHIFT );
        } except( (GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES) ?
                  EXCEPTION_EXECUTE_HANDLER :
                  EXCEPTION_CONTINUE_SEARCH ) {

            return;
        }
    }

    //
    //  Now perform the split on the next bucket.
    //

    NtfsGetHashSegmentAndIndex( Table->SplitPoint, &OldSegment, &OldIndex );
    NtfsGetHashSegmentAndIndex( Table->MaxBucket + Table->SplitPoint, &NewSegment, &NewIndex );
    CurrentOldEntry = (PNTFS_HASH_ENTRY *) &(*Table->HashSegments[ OldSegment ])[ OldIndex ];
    CurrentNewEntry = (PNTFS_HASH_ENTRY *) &(*Table->HashSegments[ NewSegment ])[ NewIndex ];

    Table->SplitPoint += 1;

    while (*CurrentOldEntry != NULL) {

        NtfsHashBucketFromHash( Table, (*CurrentOldEntry)->HashValue, &NextBucket );

        //
        //  The entry belongs in the new bucket.  Take it out of the existing
        //  bucket and insert it at the head of the new bucket.
        //

        if (NextBucket >= Table->MaxBucket) {

            ASSERT( NextBucket == (Table->MaxBucket + Table->SplitPoint - 1) );

            CurrentEntry = *CurrentOldEntry;
            *CurrentOldEntry = CurrentEntry->NextEntry;

            CurrentEntry->NextEntry = *CurrentNewEntry;
            *CurrentNewEntry = CurrentEntry;

        //
        //  Move to the next entry in the existing bucket.
        //

        } else {

            CurrentOldEntry = &(*CurrentOldEntry)->NextEntry;
        }
    }

    return;
}

#ifdef NTFS_HASH_DATA
VOID
NtfsFillHashHistogram (
    PNTFS_HASH_TABLE Table
    )

{
    ULONG CurrentBucket = 0;
    ULONG Segment;
    ULONG Index;

    PNTFS_HASH_ENTRY NextEntry;
    ULONG Count;

    //
    //  Zero the current histogram.
    //

    RtlZeroMemory( Table->Histogram, sizeof( Table->Histogram ));
    RtlZeroMemory( Table->ExtendedHistogram, sizeof( Table->ExtendedHistogram ));

    //
    //  Walk through all of the buckets in use.
    //

    while (CurrentBucket < Table->MaxBucket + Table->SplitPoint) {

        Count = 0;

        NtfsGetHashSegmentAndIndex( CurrentBucket, &Segment, &Index );

        NextEntry = (*Table->HashSegments[ Segment ])[ Index ];

        //
        //  Count the number of entries in each bucket.
        //

        while (NextEntry != NULL) {

            Count += 1;
            NextEntry = NextEntry->NextEntry;
        }

        //
        //  Store it into the first histogram set if count is less than 16.
        //

        if (Count < 16) {

            Table->Histogram[Count] += 1;

        //
        //  Store it in the last bucket if larger than our max.
        //

        } else if (Count >= 32) {

            Table->ExtendedHistogram[15] += 1;

        //
        //  Otherwise store it into the extended histogram.
        //

        } else {

            Table->ExtendedHistogram[(Count - 16) / 2] += 1;
        }

        CurrentBucket += 1;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\lockorder.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lockorder.h

Abstract:

    This module defines all data associated with lock order enforcement.
    
    If you define a new resource add it to the NTFS_RESOURCE_NAME enum. If you hit
    an unknown state transition run tests\analyze which shows what makes up the state
    Then see if you're releasing / acquiring the resource and if its a safe or unsafe transition.
    An unsafe transition is a non-blocking one. If the transition makes sense then you should add
    it to one of 4 tables. 1st it may be neccessary to create a new state. Scan the list 
    which is organized in a mostly ordered fashion to make sure the state doesn't already
    exist. Then if the transition is a normal 2 way one add it to the OwnershipTransitionTable.
    If its a release only transition (usually caused by out of order resource releases) add it
    to the OwnershipTransitionTableRelease. If its an acquire only transiton add it to 
    OwnershipTransitionTableAcquire. These only included transitions involving the wild card
    resource NtfsResourceAny and are used to model the ExclusiveVcb resource chains. Finally if
    its only an unsafe transition ex. acquire parent and then acquire child add it to
    the OwnershipTransitionTableUnsafe. After you're donw recompile analyze and check to
    make sure it doesn't warn about anything invalid in the total rule set. Finally compile with
    NTFSDBG defined and the new rule will be in place.
    
    
Author:
    
    Benjamin Leis   [benl]          20-Mar-2000

Revision History:

--*/

#ifndef _NTFSLOCKORDER_
#define _NTFSLOCKORDER_

//
//  Data for the lock order enforcement package. This includes names for resources
//  and the resource ownership states
//  

typedef enum _NTFS_RESOURCE_NAME  {
    NtfsResourceAny               = 0x1,  
    NtfsResourceExVcb             = 0x2,
    NtfsResourceSharedVcb         = 0x4,
    NtfsResourceVolume            = 0x8,  
    NtfsResourceFile              = 0x10, 
    NtfsResourceRootDir           = 0x20,  
    NtfsResourceObjectIdTable     = 0x40,
    NtfsResourceReparseTable      = 0x80,
    NtfsResourceQuotaTable        = 0x100,
    NtfsResourceSecure            = 0x200,
    NtfsResourceExtendDir         = 0x400,
    NtfsResourceBadClust          = 0x800,  
    NtfsResourceUpCase            = 0x1000,  
    NtfsResourceAttrDefTable      = 0x2000,
    NtfsResourceLogFile           = 0x4000,
    NtfsResourceMft2              = 0x8000,
    NtfsResourceMft               = 0x10000,
    NtfsResourceUsnJournal        = 0x20000, 
    NtfsResourceBitmap            = 0x40000,
    NtfsResourceBoot              = 0x80000,

    NtfsResourceMaximum           = 0x100000

} NTFS_RESOURCE_NAME, *PNTFS_RESOURCE_NAME;


typedef enum _NTFS_OWNERSHIP_STATE {
    None = 0,
    NtfsOwns_All = NtfsResourceMaximum - 1,
    NtfsOwns_File = NtfsResourceFile,
    NtfsOwns_ExVcb = NtfsResourceExVcb,
    NtfsOwns_Vcb = NtfsResourceSharedVcb, 
    NtfsOwns_BadClust = NtfsResourceBadClust,
    NtfsOwns_Boot = NtfsResourceBoot,
    NtfsOwns_Bitmap = NtfsResourceBitmap,
    NtfsOwns_Extend = NtfsResourceExtendDir,
    NtfsOwns_Journal = NtfsResourceUsnJournal,
    NtfsOwns_LogFile = NtfsResourceLogFile,
    NtfsOwns_Mft = NtfsResourceMft,
    NtfsOwns_Mft2 = NtfsResourceMft2,
    NtfsOwns_ObjectId = NtfsResourceObjectIdTable,
    NtfsOwns_Quota = NtfsResourceQuotaTable,
    NtfsOwns_Reparse = NtfsResourceReparseTable,
    NtfsOwns_Root = NtfsResourceRootDir,
    NtfsOwns_Secure = NtfsResourceSecure,
    NtfsOwns_Upcase = NtfsResourceUpCase,
    NtfsOwns_Volume = NtfsResourceVolume,  
    
    NtfsOwns_Root_File = NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_Root_File_Bitmap = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Root_File_ObjectId = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Root_File_ObjectId_Extend = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceExtendDir,
    NtfsOwns_Root_File_ObjectId_Extend_Bitmap = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceExtendDir | NtfsResourceBitmap,
    NtfsOwns_Root_File_ObjectId_Secure = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_Root_File_ObjectId_Secure_Bitmap = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_Root_File_Quota = NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Root_BadClust = NtfsResourceRootDir | NtfsResourceBadClust,
    NtfsOwns_Root_Bitmap = NtfsResourceRootDir | NtfsResourceBitmap,
    NtfsOwns_Root_Extend = NtfsResourceRootDir | NtfsResourceExtendDir,
    NtfsOwns_Root_LogFile = NtfsResourceRootDir | NtfsResourceLogFile,
    NtfsOwns_Root_Mft2 = NtfsResourceRootDir | NtfsResourceMft2,
    NtfsOwns_Root_Quota = NtfsResourceRootDir | NtfsResourceQuotaTable,
    NtfsOwns_Root_ObjectId = NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_Root_Upcase = NtfsResourceRootDir | NtfsResourceUpCase,
    NtfsOwns_Root_Secure = NtfsResourceRootDir | NtfsResourceSecure,
    NtfsOwns_Root_Mft = NtfsResourceRootDir | NtfsResourceMft,
    NtfsOwns_Root_Mft_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_File = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile,
    NtfsOwns_Root_Mft_File_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_File_Quota = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Root_Mft_File_Journal = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Root_Mft_File_Journal_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_File_ObjectId = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Root_Mft_File_ObjectId_Quota = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Root_Mft_Journal = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_Root_Mft_Journal_Bitmap = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Root_Mft_ObjectId = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceObjectIdTable,
    NtfsOwns_Root_Mft_Quota = NtfsResourceRootDir | NtfsResourceMft | NtfsResourceQuotaTable,

    NtfsOwns_Vcb_BadClust = NtfsResourceSharedVcb | NtfsResourceBadClust,
    NtfsOwns_Vcb_Bitmap = NtfsResourceSharedVcb | NtfsResourceBitmap,
    NtfsOwns_Vcb_Boot = NtfsResourceSharedVcb | NtfsResourceBoot,
    NtfsOwns_Vcb_Journal = NtfsResourceSharedVcb | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_LogFile = NtfsResourceSharedVcb | NtfsResourceLogFile,
    NtfsOwns_Vcb_Quota = NtfsResourceSharedVcb | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Reparse = NtfsResourceSharedVcb | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Root = NtfsResourceSharedVcb | NtfsResourceRootDir,   
    NtfsOwns_Vcb_Upcase = NtfsResourceSharedVcb | NtfsResourceUpCase,
    NtfsOwns_Vcb_Volume = NtfsResourceSharedVcb | NtfsResourceVolume,

    NtfsOwns_Vcb_Mft = NtfsResourceSharedVcb | NtfsResourceMft,
    NtfsOwns_Vcb_Mft_BadClust = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceBadClust,
    NtfsOwns_Vcb_Mft_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Boot = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceBoot,
    NtfsOwns_Vcb_Mft_LogFile = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceLogFile,
    NtfsOwns_Vcb_Mft_Mft2 = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceMft2,
    NtfsOwns_Vcb_Mft_Upcase = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceUpCase,
    NtfsOwns_Vcb_Mft_Secure = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceSecure,
    NtfsOwns_Vcb_Mft_Volume = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceVolume,
    NtfsOwns_Vcb_Mft_Volume_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Volume_Bitmap_Boot = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceVolume | NtfsResourceBitmap | NtfsResourceBoot,
    NtfsOwns_Vcb_Mft_Extend = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceExtendDir,
    NtfsOwns_Vcb_Mft_File = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile,
    NtfsOwns_Vcb_Mft_File_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Secure = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_Vcb_Mft_File_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_File_Quota_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_Quota_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Reparse = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Mft_File_Reparse_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_File_Reparse_Quota_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_Reparse_Quota_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_Reparse_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_File_ObjectId_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,  
    NtfsOwns_Vcb_Mft_File_ObjectId_Quota_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable | NtfsResourceUsnJournal,  
    NtfsOwns_Vcb_Mft_File_ObjectId_Reparse = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Mft_File_ObjectId_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_File_ObjectId_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir,
    NtfsOwns_Vcb_Mft_Root_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Root_Quota_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceQuotaTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_Quota_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceQuotaTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_Vcb_Mft_Root_File_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_File_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_Root_File_ObjectId_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Root_File_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Root_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_File_Quota_Journal = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_Mft_Root_File_Quota_Journal_Bitmap = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Vcb_Mft_Root_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_ObjectId = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft_Quota = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Mft_Reparse = NtfsResourceSharedVcb | NtfsResourceMft | NtfsResourceReparseTable,

    NtfsOwns_Vcb_Extend = NtfsResourceSharedVcb | NtfsResourceExtendDir,
    NtfsOwns_Vcb_Extend_Reparse = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceReparseTable,
    NtfsOwns_Vcb_Extend_Reparse_Secure = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceReparseTable | NtfsResourceSecure,     
    NtfsOwns_Vcb_Extend_ObjectId = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Extend_ObjectId_Secure = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_Vcb_Extend_Quota = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Extend_Journal = NtfsResourceSharedVcb | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_Vcb_ObjectId = NtfsResourceSharedVcb | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Mft2 = NtfsResourceSharedVcb | NtfsResourceMft2,
    NtfsOwns_Vcb_Secure = NtfsResourceSharedVcb | NtfsResourceSecure,
    NtfsOwns_Vcb_Root_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_Mft2 = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceMft2,
    NtfsOwns_Vcb_Root_Upcase = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceUpCase,
    NtfsOwns_Vcb_Root_Extend = NtfsResourceSharedVcb |  NtfsResourceRootDir | NtfsResourceExtendDir,     
    NtfsOwns_Vcb_Root_Quota = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Root_ObjectId = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Root_Secure = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceSecure,
    NtfsOwns_Vcb_Root_Secure_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_Boot = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceBoot,
    NtfsOwns_Vcb_Root_LogFile = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceLogFile,
    NtfsOwns_Vcb_Root_BadClust = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceBadClust,
    NtfsOwns_Vcb_Root_File = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_Vcb_Root_File_Secure = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceSecure, 
    NtfsOwns_Vcb_Root_File_Bitmap = NtfsResourceSharedVcb |  NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_Root_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Root_File_ObjectId_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_Root_File_Quota = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_Root_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File = NtfsResourceSharedVcb | NtfsResourceFile,
    NtfsOwns_Vcb_File_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Secure = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceSecure,     
    NtfsOwns_Vcb_File_Extend = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceExtendDir,     
    NtfsOwns_Vcb_File_ObjectId = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Vcb_File_ObjectId_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_ObjectId_Quota = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_File_ObjectId_Reparse = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_Vcb_File_ObjectId_Reparse_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Quota = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_File_Quota_Secure = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceSecure,
    NtfsOwns_Vcb_File_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Reparse = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_Vcb_File_Reparse_Quota = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable,
    NtfsOwns_Vcb_File_Reparse_Quota_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Reparse_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceBitmap,
    NtfsOwns_Vcb_File_Extend_Secure = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceExtendDir | NtfsResourceSecure,     
    NtfsOwns_Vcb_File_Secure_Bitmap = NtfsResourceSharedVcb | NtfsResourceFile | NtfsResourceSecure | NtfsResourceBitmap,

    NtfsOwns_Extend_Reparse = NtfsResourceExtendDir | NtfsResourceReparseTable,
    NtfsOwns_Extend_ObjectId = NtfsResourceExtendDir | NtfsResourceObjectIdTable,
    NtfsOwns_Extend_Journal = NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_Extend_Quota = NtfsResourceExtendDir | NtfsResourceQuotaTable,

    NtfsOwns_Mft_Bitmap = NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_Mft_Journal = NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_Mft_Journal_Bitmap = NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_Volume = NtfsResourceMft | NtfsResourceVolume,
    NtfsOwns_Mft_Volume_Bitmap = NtfsResourceMft | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_Mft_Extend = NtfsResourceMft | NtfsResourceExtendDir,
    NtfsOwns_Mft_Extend_Journal = NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File = NtfsResourceMft | NtfsResourceFile,
    NtfsOwns_Mft_File_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_Journal_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Quota = NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_Mft_File_Quota_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Quota_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_Quota_Journal_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Reparse = NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_Mft_File_Reparse_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_Reparse_Journal_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_File_Reparse_Quota = NtfsResourceMft | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable,
    NtfsOwns_Mft_File_Secure = NtfsResourceMft | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_Mft_File_Secure_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceSecure | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_ObjectId = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_Mft_File_ObjectId_Quota = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_Mft_File_ObjectId_Quota_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_File_ObjectId_Quota_Journal_Bitmap = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_Mft_File_ObjectId_Reparse = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_Mft_File_ObjectId_Journal = NtfsResourceMft | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_ObjectId = NtfsResourceMft | NtfsResourceObjectIdTable,
    NtfsOwns_Mft_ObjectId_Journal = NtfsResourceMft | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    NtfsOwns_Mft_ObjectId_Bitmap = NtfsResourceMft | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_Mft_Upcase = NtfsResourceMft | NtfsResourceUpCase,
    NtfsOwns_Mft_Upcase_Bitmap = NtfsResourceMft | NtfsResourceUpCase | NtfsResourceBitmap,
    NtfsOwns_Mft_Secure = NtfsResourceMft | NtfsResourceSecure,
    NtfsOwns_Mft_Secure_Bitmap = NtfsResourceMft | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_Mft_Quota = NtfsResourceMft | NtfsResourceQuotaTable,
    NtfsOwns_Mft_Quota_Bitmap = NtfsResourceMft | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_Mft_Reparse = NtfsResourceMft | NtfsResourceReparseTable,
    NtfsOwns_Mft_Reparse_Bitmap = NtfsResourceMft | NtfsResourceReparseTable | NtfsResourceBitmap,
    
    NtfsOwns_File_Bitmap = NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_File_ObjectId = NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_File_ObjectId_Bitmap = NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    NtfsOwns_File_ObjectId_Quota = NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable,
    NtfsOwns_File_ObjectId_Quota_Bitmap = NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_File_ObjectId_Reparse = NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceReparseTable,
    NtfsOwns_File_Quota = NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_File_Quota_Bitmap = NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap ,
    NtfsOwns_File_Reparse = NtfsResourceFile | NtfsResourceReparseTable,
    NtfsOwns_File_Reparse_Bitmap = NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceBitmap,
    NtfsOwns_File_Reparse_Quota = NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable,
    NtfsOwns_File_Reparse_Quota_Bitmap = NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_File_Secure = NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_File_Secure_Bitmap = NtfsResourceFile | NtfsResourceSecure | NtfsResourceBitmap,

    
    NtfsOwns_Volume_Quota = NtfsResourceVolume | NtfsResourceQuotaTable,
    NtfsOwns_Volume_ObjectId = NtfsResourceVolume | NtfsResourceObjectIdTable,
    
    NtfsOwns_ExVcb_File = NtfsResourceExVcb | NtfsResourceFile,
    NtfsOwns_ExVcb_File_Volume = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume,
    NtfsOwns_ExVcb_File_Volume_Bitmap = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_ExVcb_File_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_File_Secure = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_ExVcb_File_Secure_ObjectId = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceSecure | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_File_Secure_Reparse_ObjectId = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceSecure | NtfsResourceReparseTable | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_File_Secure_Reparse = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceSecure | NtfsResourceReparseTable,
    NtfsOwns_ExVcb_File_Secure_Reparse_ObjectId_Journal = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceReparseTable | NtfsResourceObjectIdTable | NtfsResourceSecure | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_File_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceSecure,
    
    NtfsOwns_ExVcb_Extend = NtfsResourceExVcb | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Extend_File = NtfsResourceExVcb | NtfsResourceExtendDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Extend_Journal = NtfsResourceExVcb | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Extend_Journal_Bitmap = NtfsResourceExVcb | NtfsResourceExtendDir | NtfsResourceUsnJournal | NtfsResourceBitmap,

    NtfsOwns_ExVcb_Journal = NtfsResourceExVcb | NtfsResourceUsnJournal,

    NtfsOwns_ExVcb_Mft = NtfsResourceExVcb | NtfsResourceMft,
    NtfsOwns_ExVcb_Mft_Extend = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Mft_Extend_File = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Mft_Extend_File_Secure = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_ExVcb_Mft_Extend_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceExtendDir | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_File = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceFile,  //  flush vol + write journal when release all
    NtfsOwns_ExVcb_Mft_File_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_File_Volume = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceMft,
    NtfsOwns_ExVcb_Mft_File_Volume_Bitmap = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceMft | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Mft_File_Volume_Journal = NtfsResourceExVcb | NtfsResourceFile | NtfsResourceVolume | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_Root = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir,
    NtfsOwns_ExVcb_Mft_Root_File = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Mft_Root_File_Bitmap = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Mft_Root_File_Journal = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_Root_File_Journal_Bitmap = NtfsResourceExVcb | NtfsResourceMft | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceUsnJournal | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Mft_Root_File_Quota = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceMft,
    NtfsOwns_ExVcb_Mft_Root_File_Quota_Journal = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceMft | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Mft_Root_File_Quota_Journal_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBitmap,
    
    NtfsOwns_ExVcb_ObjectId = NtfsResourceExVcb | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceObjectIdTable | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceObjectIdTable | NtfsResourceSecure,

    NtfsOwns_ExVcb_Quota = NtfsResourceExVcb | NtfsResourceQuotaTable,
    NtfsOwns_ExVcb_Quota_Reparse = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable,
    NtfsOwns_ExVcb_Quota_Reparse_Extend = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Quota_Reparse_ObjectId = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Quota_Reparse_Secure = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable | NtfsResourceSecure,
    NtfsOwns_ExVcb_Quota_Reparse_Secure_Journal = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceReparseTable | NtfsResourceSecure | NtfsResourceUsnJournal,
    NtfsOwns_ExVcb_Quota_ObjectId = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Quota_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceObjectIdTable | NtfsResourceExtendDir,
    NtfsOwns_ExVcb_Quota_Extend = NtfsResourceExVcb | NtfsResourceQuotaTable | NtfsResourceExtendDir,

    NtfsOwns_ExVcb_Reparse_Objid_Secure_Journal = NtfsResourceExVcb | NtfsResourceReparseTable | NtfsResourceObjectIdTable | NtfsResourceSecure | NtfsResourceUsnJournal,
    
    NtfsOwns_ExVcb_Root = NtfsResourceExVcb | NtfsResourceRootDir,             
    NtfsOwns_ExVcb_Root_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceSecure,             
    NtfsOwns_ExVcb_Root_Secure_Quota = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceSecure | NtfsResourceQuotaTable,             
    NtfsOwns_ExVcb_Root_Extend = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceExtendDir, 
    NtfsOwns_ExVcb_Root_File = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile,
    NtfsOwns_ExVcb_Root_File_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceSecure,
    NtfsOwns_ExVcb_Root_File_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_File_Quota = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable,
    NtfsOwns_ExVcb_Root_File_Quota_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceQuotaTable | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_File_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Root_File_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceExtendDir,  
    NtfsOwns_ExVcb_Root_File_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_ExVcb_Root_File_Volume = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceVolume,
    NtfsOwns_ExVcb_Root_File_Volume_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceVolume | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_File_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceFile | NtfsResourceVolume | NtfsResourceObjectIdTable,
    
    NtfsOwns_ExVcb_Root_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Root_ObjectId_Extend = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable | NtfsResourceExtendDir, 
    NtfsOwns_ExVcb_Root_ObjectId_Secure = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable | NtfsResourceSecure,
    NtfsOwns_ExVcb_Root_ObjectId_Secure_Bitmap = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceObjectIdTable | NtfsResourceSecure | NtfsResourceBitmap,
    NtfsOwns_ExVcb_Root_Volume = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceVolume,
    NtfsOwns_ExVcb_Root_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceRootDir | NtfsResourceVolume | NtfsResourceObjectIdTable,

    NtfsOwns_ExVcb_Secure = NtfsResourceExVcb | NtfsResourceSecure,
    NtfsOwns_ExVcb_Secure_ObjectId = NtfsResourceExVcb | NtfsResourceSecure | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Secure_Reparse = NtfsResourceExVcb | NtfsResourceSecure | NtfsResourceReparseTable,
    NtfsOwns_ExVcb_Secure_Reparse_ObjectId = NtfsResourceExVcb | NtfsResourceSecure | NtfsResourceReparseTable | NtfsResourceObjectIdTable,
    NtfsOwns_ExVcb_Secure_Reparse_ObjectId_Journal = NtfsResourceExVcb | NtfsResourceSecure | NtfsResourceReparseTable | NtfsResourceObjectIdTable | NtfsResourceUsnJournal,
    
    NtfsOwns_ExVcb_Volume = NtfsResourceExVcb | NtfsResourceVolume,
    NtfsOwns_ExVcb_Volume_ObjectId = NtfsResourceExVcb | NtfsResourceVolume | NtfsResourceObjectIdTable,  // set vol objectid
    NtfsOwns_ExVcb_Volume_ObjectId_Bitmap = NtfsResourceExVcb | NtfsResourceVolume | NtfsResourceObjectIdTable | NtfsResourceBitmap,
    
    NtfsStateMaximum = NtfsResourceMaximum - 1

} NTFS_OWNERSHIP_STATE, *PNTFS_OWNERSHIP_STATE;

typedef struct _NTFS_OWNERSHIP_TRANSITION {
    NTFS_OWNERSHIP_STATE Begin;
    NTFS_RESOURCE_NAME Acquired;
    NTFS_OWNERSHIP_STATE End;
} NTFS_OWNERSHIP_TRANSITION, *PNTFS_OWNERSHIP_TRANSITION;

//
//  Transition table definitions
//  

#ifdef _NTFS_NTFSDBG_DEFINITIONS_

//
//  Two way transitions
//  

NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTable[] = 
{
    {None, NtfsResourceFile, NtfsOwns_File},
    {None, NtfsResourceRootDir, NtfsOwns_Root},
    
    {NtfsOwns_Vcb, NtfsResourceRootDir, NtfsOwns_Vcb_Root},
    {NtfsOwns_Vcb, NtfsResourceFile, NtfsOwns_Vcb_File},
    {NtfsOwns_Vcb, NtfsResourceUsnJournal, NtfsOwns_Vcb_Journal},
    
    {NtfsOwns_Vcb_Upcase, NtfsResourceRootDir, NtfsOwns_Vcb_Root_Upcase},
    
    {NtfsOwns_Vcb_File, NtfsResourceRootDir, NtfsOwns_Vcb_Root_File},

    {NtfsOwns_Vcb_Mft_File, NtfsResourceRootDir, NtfsOwns_Vcb_Mft_Root_File}, //  deletefile

//    {NtfsOwns_Vcb_File_Quota, NtfsResourceRootDir, NtfsOwns_Vcb_Root_File_Quota}, efs createcallback preacquire

    {NtfsOwns_Vcb_Mft_Volume_Bitmap, NtfsResourceBoot, NtfsOwns_Vcb_Mft_Volume_Bitmap_Boot},
    
    {NtfsOwns_Vcb_Extend, NtfsResourceFile, NtfsOwns_Vcb_File_Extend},  // usn journal create
    {NtfsOwns_Vcb_Extend, NtfsResourceRootDir, NtfsOwns_Vcb_Root_Extend},


    {NtfsOwns_ExVcb_Secure, NtfsResourceFile, NtfsOwns_ExVcb_File_Secure}, // syscache file acquire in dismount
    {NtfsOwns_ExVcb_Secure_Reparse, NtfsResourceFile, NtfsOwns_ExVcb_File_Secure_Reparse}, // syscache file acquire in dismount
    {NtfsOwns_ExVcb_Secure_Reparse, NtfsResourceFile, NtfsOwns_ExVcb_File_Secure_Reparse}, // syscache file acquire in dismount
    {NtfsOwns_ExVcb_Secure_Reparse_ObjectId, NtfsResourceFile, NtfsOwns_ExVcb_File_Secure_Reparse_ObjectId}, // syscache file acquire in dismount
    {NtfsOwns_ExVcb_Secure_ObjectId, NtfsResourceFile, NtfsOwns_ExVcb_File_Secure_ObjectId}, // syscache file acquire in dismount
    {NtfsOwns_ExVcb_Secure_Reparse_ObjectId_Journal, NtfsResourceFile, NtfsOwns_ExVcb_File_Secure_Reparse_ObjectId_Journal}, // syscache file acquire in dismount 
    
    //
    //  Flush Volume for vol. open
    //  

    {NtfsOwns_ExVcb_Volume, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_Volume},
    {NtfsOwns_ExVcb_Volume, NtfsResourceFile, NtfsOwns_ExVcb_File_Volume}, // fsp close
    {NtfsOwns_ExVcb_File_Volume, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_File_Volume}, // fsp close
    {NtfsOwns_ExVcb_Root_Volume, NtfsResourceFile, NtfsOwns_ExVcb_Root_File_Volume},
    {NtfsOwns_ExVcb_File, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_File},

    {NtfsOwns_ExVcb, NtfsResourceRootDir, NtfsOwns_ExVcb_Root},
    {NtfsOwns_ExVcb, NtfsResourceFile, NtfsOwns_ExVcb_File},
    {NtfsOwns_ExVcb, NtfsResourceUsnJournal, NtfsOwns_ExVcb_Journal},  //  delete usn jrnl
    
    {NtfsOwns_ExVcb_Mft, NtfsResourceExtendDir, NtfsOwns_ExVcb_Mft_Extend},  //  CreateUnsJrnl  new
    {NtfsOwns_ExVcb_Extend, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_Extend},
    {NtfsOwns_ExVcb_Mft_Extend_File, NtfsResourceSecure, NtfsOwns_ExVcb_Mft_Extend_File_Secure}, //  createjrnl

    {NtfsOwns_ExVcb_Journal, NtfsResourceExtendDir, NtfsOwns_ExVcb_Extend_Journal}, //  delete usnjrnl special
    {NtfsOwns_ExVcb_Extend_Journal, NtfsResourceMft, NtfsOwns_ExVcb_Mft_Extend_Journal}, //  DeleteJournal
    {NtfsOwns_ExVcb_Mft_Journal, NtfsResourceExtendDir, NtfsOwns_ExVcb_Mft_Extend_Journal}, //  DeleteJournalSpecial
    
//    {NtfsOwns_ExVcb_Root_Secure, NtfsResourceQuotaTable, NtfsOwns_ExVcb_Root_Secure_Quota}, // cache secure in createnew path
    {NtfsOwns_ExVcb_Root, NtfsResourceFile, NtfsOwns_ExVcb_Root_File},
//    {NtfsOwns_ExVcb_Reparse_Objid_Secure_Journal, NtfsResourceRootDir, NtfsOwns_ExVcb_Root_Reparse_Objid_Secure_Journal },  //  paging file create path
    
};

//
//  These are release only possible transitions
//  

NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTableRelease[] = 
{
    //
    //  NtfsResourceAny def. backpaths
    //  

    {NtfsOwns_ExVcb, NtfsResourceAny, NtfsOwns_ExVcb},
    {NtfsOwns_ExVcb_File, NtfsResourceAny, NtfsOwns_ExVcb_File},
    {NtfsOwns_ExVcb_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_ObjectId_Secure},
    {NtfsOwns_ExVcb_Quota_Reparse_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Reparse_ObjectId},
    {NtfsOwns_ExVcb_Quota, NtfsResourceAny, NtfsOwns_ExVcb_Quota},
    {NtfsOwns_ExVcb_Root, NtfsResourceAny, NtfsOwns_ExVcb_Root},
    {NtfsOwns_ExVcb_Root_File_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId},
    {NtfsOwns_ExVcb_Root_File_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId_Secure},
    {NtfsOwns_ExVcb_Root_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_Volume_ObjectId},
    {NtfsOwns_ExVcb_Volume, NtfsResourceAny, NtfsOwns_ExVcb_Volume},  
    {NtfsOwns_ExVcb_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Volume_ObjectId},  

    {NtfsOwns_Root_File_ObjectId_Extend, NtfsResourceAny, NtfsOwns_Root_File_ObjectId_Extend}, // acquire all files + exception and transaction
    {NtfsOwns_Root_File_ObjectId_Secure, NtfsResourceAny, NtfsOwns_Root_File_ObjectId_Secure} // acquire all files + exception and transaction

};

//
//  Acquire Only transtions
//  
                            
NTFS_OWNERSHIP_TRANSITION OwnershipTransitionTableAcquire[] = 
{
    //
    //  Any relations
    //  

    {NtfsOwns_ExVcb, NtfsResourceAny, NtfsOwns_ExVcb},
    {NtfsOwns_ExVcb_Volume, NtfsResourceAny, NtfsOwns_ExVcb_Volume},  
    {NtfsOwns_ExVcb_File, NtfsResourceAny, NtfsOwns_ExVcb_File},
    {NtfsOwns_ExVcb_File_Secure, NtfsResourceAny, NtfsOwns_ExVcb_File_Secure},
    {NtfsOwns_ExVcb_ObjectId_Extend, NtfsResourceAny, NtfsOwns_ExVcb_ObjectId_Extend},
    {NtfsOwns_ExVcb_Root_File_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId},
    {NtfsOwns_ExVcb_Root_File_ObjectId_Extend, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId_Extend},
    {NtfsOwns_ExVcb_Root_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_Volume_ObjectId},

    //
    //  Acquire all files 
    // 

    {NtfsOwns_ExVcb_Root_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_Root_ObjectId_Secure},  // no userfiles
    {NtfsOwns_ExVcb_Root_File_ObjectId_Secure, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_ObjectId_Secure},  // userfile
    {NtfsOwns_ExVcb_Root_File_Volume_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Root_File_Volume_ObjectId},  // from volopen

    {NtfsOwns_ExVcb_Quota, NtfsResourceAny, NtfsOwns_ExVcb_Quota},
    {NtfsOwns_ExVcb_Quota_Extend, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Extend},
    {NtfsOwns_ExVcb_Quota_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Quota_ObjectId},
    {NtfsOwns_ExVcb_Quota_Reparse_Extend, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Reparse_Extend},
    {NtfsOwns_ExVcb_Quota_Reparse_ObjectId, NtfsResourceAny, NtfsOwns_ExVcb_Quota_Reparse_ObjectId}
    
};

//   
//   Rules 
// 

typedef struct _NTFS_OWNERSHIP_TRANSITION_RULE {
    NTFS_RESOURCE_NAME NewResource;
    ULONG RequiredResourcesMask;
    ULONG DisallowedResourcesMask;
} NTFS_OWNERSHIP_TRANSITION_RULE, *PNTFS_OWNERSHIP_TRANSITION_RULE;


//
//  Table of rules going in general from end resources to first resources
//

NTFS_OWNERSHIP_TRANSITION_RULE OwnershipTransitionRuleTable[] = 
{
   {NtfsResourceBitmap, 0, 0},

   {NtfsResourceBoot, 0, NtfsResourceBitmap},
   {NtfsResourceUsnJournal, 0, NtfsResourceBoot | NtfsResourceBitmap},
   {NtfsResourceMft, 0, NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap | NtfsResourceBoot},
   
   {NtfsResourceMft2, 0, NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap | NtfsResourceBoot},
   {NtfsResourceLogFile, 0, NtfsResourceMft2 | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap | NtfsResourceBoot},
   {NtfsResourceAttrDefTable, 0, NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap | NtfsResourceBoot | NtfsResourceExtendDir},
   {NtfsResourceBadClust, 0, NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile |NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap },
   
   {NtfsResourceExtendDir, 0, NtfsResourceBadClust | NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},
   {NtfsResourceSecure, 0, NtfsResourceExtendDir | NtfsResourceBadClust | NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},
   {NtfsResourceUpCase, 0, NtfsResourceSecure | NtfsResourceExtendDir | NtfsResourceBadClust | NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},
   {NtfsResourceQuotaTable, 0, NtfsResourceUpCase | NtfsResourceSecure | NtfsResourceExtendDir | NtfsResourceBadClust | NtfsResourceUpCase | NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},
   {NtfsResourceReparseTable, 0, NtfsResourceQuotaTable | NtfsResourceUpCase | NtfsResourceSecure | NtfsResourceExtendDir | NtfsResourceBadClust | NtfsResourceUpCase | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceAttrDefTable | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},
   {NtfsResourceObjectIdTable, 0, NtfsResourceReparseTable | NtfsResourceQuotaTable | NtfsResourceUpCase | NtfsResourceSecure | NtfsResourceExtendDir | NtfsResourceBadClust | NtfsResourceUpCase | NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},

   {NtfsResourceVolume, 0, NtfsResourceObjectIdTable | NtfsResourceReparseTable | NtfsResourceQuotaTable | NtfsResourceUpCase | NtfsResourceSecure | NtfsResourceExtendDir | NtfsResourceBadClust | NtfsResourceUpCase | NtfsResourceAttrDefTable | NtfsResourceMft2 | NtfsResourceLogFile | NtfsResourceMft | NtfsResourceUsnJournal | NtfsResourceBoot | NtfsResourceBitmap},

   {NtfsResourceSharedVcb, 0, NtfsOwns_All},  
   {NtfsResourceExVcb, 0, NtfsOwns_All},
   {None, 0, 0}
};

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\lockctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the File Lock Control routine for Ntfs called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]        28-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonLockControl)
#pragma alloc_text(PAGE, NtfsFastLock)
#pragma alloc_text(PAGE, NtfsFastUnlockAll)
#pragma alloc_text(PAGE, NtfsFastUnlockAllByKey)
#pragma alloc_text(PAGE, NtfsFastUnlockSingle)
#endif


NTSTATUS
NtfsFsdLockControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Lock Control.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    DebugTrace( +1, Dbg, ("NtfsFsdLockControl\n") );

    //
    //  Call the common Lock Control routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, CanFsdWait( Irp ), &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //
    
                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }

            Status = NtfsCommonLockControl( IrpContext, Irp );
            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdLockControl -> %08lx\n", Status) );

    return Status;
}


BOOLEAN
NtfsFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PSCB Scb;
    PFCB Fcb;
    BOOLEAN ResourceAcquired = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastLock\n") );

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    if ((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace( -1, Dbg, ("NtfsFastLock -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    Fcb = Scb->Fcb;

    //
    //  Acquire shared access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );
        ResourceAcquired = TRUE;

    } else {

        //(VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        if ((Scb->ScbType.Data.Oplock != NULL) &&
            !FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        if (Results = FsRtlFastLock( Scb->ScbType.Data.FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is questionable.  We
            //  only change this flag is the current state is possible.
            //  Retest again after synchronizing on the header.
            //

            if (Scb->Header.IsFastIoPossible == FastIoIsPossible) {

                NtfsAcquireFsrtlHeader( Scb );
                Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
                NtfsReleaseFsrtlHeader( Scb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastLock );

        //
        //  Release the Fcb, and return to our caller
        //

        if (ResourceAcquired) {
            ExReleaseResourceLite( Fcb->Resource );
        }

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastLock -> %08lx\n", Results) );
    }

    return Results;
}


BOOLEAN
NtfsFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PFCB Fcb;
    PSCB Scb;
    BOOLEAN ResourceAcquired = FALSE;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastUnlockSingle\n") );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    if ((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        DebugTrace( -1, Dbg, ("NtfsFastUnlockSingle -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    Fcb = Scb->Fcb;

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );
        ResourceAcquired = TRUE;

    } else {

        //(VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Scb->ScbType.Data.Oplock != NULL) &&
            !FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( Scb->ScbType.Data.FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible.  We are
        //  only concerned if there are no longer any filelocks on this
        //  file.
        //

        if (!FsRtlAreThereCurrentFileLocks( Scb->ScbType.Data.FileLock ) &&
            (Scb->Header.IsFastIoPossible != FastIoIsPossible)) {

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastUnlockSingle );

        //
        //  Release the Fcb, and return to our caller
        //

        if (ResourceAcquired) {
            ExReleaseResourceLite( Fcb->Resource );
        }

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastUnlockSingle -> %08lx\n", Results) );
    }

    return Results;
}


BOOLEAN
NtfsFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    IRP_CONTEXT IrpContext;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastUnlockAll\n") );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAll -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );

    } else {

        (VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( Scb->ScbType.Data.FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastUnlockAll );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAll -> %08lx\n", Results) );
    }

    return Results;
}


BOOLEAN
NtfsFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    IRP_CONTEXT IrpContext;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFastUnlockAllByKey\n") );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAllByKey -> TRUE (STATUS_INVALID_PARAMETER)\n") );
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    if (Scb->ScbType.Data.FileLock == NULL) {

        (VOID) ExAcquireResourceExclusiveLite( Fcb->Resource, TRUE );

    } else {

        (VOID) ExAcquireResourceSharedLite( Fcb->Resource, TRUE );
    }

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &Scb->ScbType.Data.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL
            && !NtfsCreateFileLock( Scb, FALSE )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( Scb->ScbType.Data.FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsFastUnlockAllByKey );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, ("NtfsFastUnlockAllByKey -> %08lx\n", Results) );
    }

    return Results;
}


NTSTATUS
NtfsCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Lock Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    BOOLEAN FcbAcquired = FALSE;

    BOOLEAN OplockPostIrp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonLockControl\n") );
    DebugTrace( 0, Dbg, ("IrpContext    = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("MinorFunction = %08lx\n", IrpSp->MinorFunction) );

    //
    //  Extract and decode the type of file object we're being asked to process
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace( -1, Dbg, ("NtfsCommonLockControl -> STATUS_INVALID_PARAMETER\n") );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Fcb
    //

    if (Scb->ScbType.Data.FileLock == NULL) {

        NtfsAcquireExclusiveFcb( IrpContext, Fcb, Scb, 0 );
        FcbAcquired = TRUE;

    } else {

        //NtfsAcquireSharedFcb( IrpContext, Fcb, Scb );
    }

    OplockPostIrp = FALSE;

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //  This call might post the irp for us.
        //

        Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                   Irp,
                                   IrpContext,
                                   NtfsOplockComplete,
                                   NtfsPrePostIrp );

        if (Status != STATUS_SUCCESS) {

            OplockPostIrp = TRUE;
            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if (Scb->ScbType.Data.FileLock == NULL) {

            NtfsCreateFileLock( Scb, TRUE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        Status = FsRtlProcessFileLock( Scb->ScbType.Data.FileLock, Irp, NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        NtfsReleaseFsrtlHeader( Scb );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCommonLockControl );

        //
        //  Only if this is not an abnormal termination and we did not post the irp
        //  do we delete the irp context
        //

        if (!OplockPostIrp) {

            //
            //  Release the Fcb.
            //
    
            if (FcbAcquired) { NtfsReleaseFcb( IrpContext, Fcb ); }

            if (!AbnormalTermination()) {

                NtfsCompleteRequest( IrpContext, NULL, 0 );
            }
        }

        DebugTrace( -1, Dbg, ("NtfsCommonLockControl -> %08lx\n", Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\mcbsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    McbSup.c

Abstract:

    This module implements the Ntfs Mcb package.

Author:

    Gary Kimura     [GaryKi]        10-Sep-1994
    Tom Miller      [TomM]

Revision History:

--*/

#include "NtfsProc.h"

#define FIRST_RANGE ((PVOID)1)

#ifndef NTFS_VERIFY_MCB
#define NtfsVerifyNtfsMcb(M)                    NOTHING;
#define NtfsVerifyUncompressedNtfsMcb(M,S,E)    NOTHING;
#endif

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('MFtN')

//
//  Local procedure prototypes
//

ULONG
NtfsMcbLookupArrayIndex (
    IN PNTFS_MCB Mcb,
    IN VCN Vcn
    );

VOID
NtfsInsertNewRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN ULONG ArrayIndex,
    IN BOOLEAN MakeNewRangeEmpty
    );

VOID
NtfsCollapseRanges (
    IN PNTFS_MCB Mcb,
    IN ULONG StartingArrayIndex,
    IN ULONG EndingArrayIndex
    );

VOID
NtfsMcbCleanupLruQueue (
    IN PVOID Parameter
    );

#ifdef NTFS_VERIFY_MCB
VOID
NtfsVerifyNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsVerifyUncompressedNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn
    );
#endif

BOOLEAN
NtfsLockNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsUnlockNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsGrowMcbArray(
    IN PNTFS_MCB Mcb
    );

//
//  Local macros to ASSERT that caller's resource is exclusive or restart is
//  underway.
//

#define ASSERT_STREAM_EXCLUSIVE(M) {                                    \
    ASSERT( FlagOn( ((PSCB) (M)->FcbHeader)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||  \
            ExIsResourceAcquiredExclusiveLite((M)->FcbHeader->Resource ));  \
}

//
//  Local macros to enqueue and dequeue elements from the lru queue
//

#define NtfsMcbEnqueueLruEntry(M,E) {                       \
    InsertTailList( &NtfsMcbLruQueue, &(E)->LruLinks );     \
    NtfsMcbCurrentLevel += 1;                               \
}

#define NtfsMcbDequeueLruEntry(M,E) {      \
    if ((E)->LruLinks.Flink != NULL) {     \
        RemoveEntryList( &(E)->LruLinks ); \
        NtfsMcbCurrentLevel -= 1;          \
    }                                      \
}

//
//  Local macro to unload a single array entry
//

#define UnloadEntry(M,I) {                              \
    PNTFS_MCB_ENTRY _Entry;                             \
    _Entry = (M)->NtfsMcbArray[(I)].NtfsMcbEntry;       \
    (M)->NtfsMcbArray[(I)].NtfsMcbEntry = NULL;         \
    if (_Entry != NULL) {                               \
        ExAcquireFastMutex( &NtfsMcbFastMutex );        \
        NtfsMcbDequeueLruEntry( Mcb, _Entry );          \
        ExReleaseFastMutex( &NtfsMcbFastMutex );        \
        FsRtlUninitializeLargeMcb( &_Entry->LargeMcb ); \
        if ((M)->NtfsMcbArraySize != MCB_ARRAY_PHASE1_SIZE) {               \
            NtfsFreePool( _Entry );                       \
        }                                               \
    }                                                   \
}


VOID
NtfsInitializeNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN PNTFS_ADVANCED_FCB_HEADER FcbHeader,
    IN PNTFS_MCB_INITIAL_STRUCTS McbStructs,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes a new Ntfs Mcb structure.

Arguments:

    Mcb - Supplies the Mcb being initialized

    FcbHeader - Supplies a pointer to the Fcb header containing
        the resource to grab when accessing the Mcb

    McbStructs - Initial allocation typically coresident in another
                 structure to handle initial structures for small and
                 medium files.  This structure should be initially zeroed.

    PoolType - Supplies the type of pool to use when
        allocating mapping information storage

Return Value:

    None.

--*/

{
    PNTFS_MCB_ARRAY Array;

    RtlZeroMemory( McbStructs, sizeof(NTFS_MCB_INITIAL_STRUCTS) );

    //
    //  Initialize the fcb header field of the mcb
    //

    Mcb->FcbHeader = FcbHeader;

    //
    //  Initialize the pool type
    //

    Mcb->PoolType = PoolType;

    //
    //  Now initialize the initial array element
    //

    Mcb->NtfsMcbArray = Array = &McbStructs->Phase1.SingleMcbArrayEntry;
    Mcb->NtfsMcbArraySize = MCB_ARRAY_PHASE1_SIZE;
    Mcb->NtfsMcbArraySizeInUse = 1;
    Mcb->FastMutex = FcbHeader->FastMutex;

    //
    //  Initialize the first array entry.
    //

    Array[0].StartingVcn = 0;
    Array[0].EndingVcn = -1;

    //
    //  And return to our caller
    //

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


VOID
NtfsUninitializeNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine uninitializes an Ntfs Mcb structure.

Arguments:

    Mcb - Supplies the Mcb being decommissioned

Return Value:

    None.

--*/

{
    ULONG i;
    PNTFS_MCB_ENTRY Entry;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Deallocate the mcb array if it exists.  For every entry in the array
    //  if the mcb entry is not null then remove the entry from the lru
    //  queue, uninitialize the large mcb, and free the pool.
    //

    if (Mcb->NtfsMcbArray != NULL) {

        for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

            if ((Entry = Mcb->NtfsMcbArray[i].NtfsMcbEntry) != NULL) {

                //
                //  Remove the entry from the lru queue
                //

                ExAcquireFastMutex( &NtfsMcbFastMutex );
                NtfsMcbDequeueLruEntry( Mcb, Entry );
                ExReleaseFastMutex( &NtfsMcbFastMutex );

                //
                //  Now release the entry
                //

                FsRtlUninitializeLargeMcb( &Entry->LargeMcb );

                //
                //  We can tell from the array count whether this is
                //  the initial entry and does not need to be deallocated.
                //

                if (Mcb->NtfsMcbArraySize > MCB_ARRAY_PHASE1_SIZE) {
                    NtfsFreePool( Entry );
                }
            }
        }

        //
        //  We can tell from the array count whether this is
        //  the initial array entry(s) and do not need to be deallocated.
        //


        if (Mcb->NtfsMcbArraySize > MCB_ARRAY_PHASE2_SIZE) {
            NtfsFreePool( Mcb->NtfsMcbArray );
        }

        Mcb->NtfsMcbArray = NULL;

        //
        //  Clear the fast mutex field.
        //

        Mcb->FastMutex = NULL;
    }

    //
    //  And return to our caller
    //

    return;
}


ULONG
NtfsNumberOfRangesInNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine returns the total number of ranges stored in
    the mcb

Arguments:

    Mcb - Supplies the Mcb being queried

Return Value:

    ULONG - The number of ranges mapped by the input mcb

--*/

{
    ASSERT_STREAM_EXCLUSIVE( Mcb );

    //
    //  Our answer is the number of ranges in use in the mcb
    //

    NtfsVerifyNtfsMcb( Mcb );

    return Mcb->NtfsMcbArraySizeInUse;
}


BOOLEAN
NtfsNumberOfRunsInRange (
    IN PNTFS_MCB Mcb,
    IN PVOID RangePtr,
    OUT PULONG NumberOfRuns
    )

/*++

Routine Description:

    This routine returns the total number of runs stored withing a range

Arguments:

    Mcb - Supplies the Mcb being queried

    RangePtr - Supplies the range to being queried

    NumberOrRuns - Returns the number of run in the specified range
        but only if the range is loaded

Return Value:

    BOOLEAN - TRUE if the range is loaded and then output variable
        is valid and FALSE if the range is not loaded.

--*/

{
    VCN TempVcn;
    LCN TempLcn;
    PNTFS_MCB_ENTRY Entry = (PNTFS_MCB_ENTRY)RangePtr;

    //
    //  Null RangePtr means first range
    //

    if (Entry == FIRST_RANGE) {
        Entry = Mcb->NtfsMcbArray[0].NtfsMcbEntry;

        //
        //  If not loaded, return FALSE
        //

        if (Entry == NULL) {
            return FALSE;
        }
    }

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    ASSERT( Mcb == Entry->NtfsMcb );

    *NumberOfRuns = FsRtlNumberOfRunsInLargeMcb( &Entry->LargeMcb );

    //
    //  Check if the current entry ends with a hole and increment the run count
    //  to reflect this.  Detect the case where the range has length 0 for a
    //  file with no allocation.  EndingVcn will be less than the starting Vcn
    //  in this case.
    //

    if (!FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, &TempVcn, &TempLcn )) {

        //
        //  If this is a non-zero length range then add one for the implied hole.
        //

        if (Entry->NtfsMcbArray->EndingVcn >= Entry->NtfsMcbArray->StartingVcn) {

            *NumberOfRuns += 1;
        }

    //
    //  There is an entry then check if it reaches the end boundary of the range.
    //

    } else if (TempVcn != (Entry->NtfsMcbArray->EndingVcn - Entry->NtfsMcbArray->StartingVcn)) {

        *NumberOfRuns += 1;
    }

    return TRUE;
}


BOOLEAN
NtfsLookupLastNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn
    )

/*++

Routine Description:

    This routine returns the last mapping stored in the mcb

Arguments:

    Mcb - Supplies the Mcb being queried

    Vcn - Receives the Vcn of the last mapping

    Lcn - Receives the Lcn corresponding to the Vcn

Return Value:

    BOOLEAN - TRUE if the mapping exist and FALSE if no mapping has been
        defined or it is unloaded

--*/

{
    PNTFS_MCB_ENTRY Entry;
    LONGLONG StartingVcn;

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Get the last entry and compute its starting vcn, and make sure
    //  the entry is valid
    //

    if ((Entry = Mcb->NtfsMcbArray[Mcb->NtfsMcbArraySizeInUse - 1].NtfsMcbEntry) == NULL) {

        return FALSE;
    }

    StartingVcn = Mcb->NtfsMcbArray[Mcb->NtfsMcbArraySizeInUse - 1].StartingVcn;

    //
    //  Otherwise lookup the last entry and compute the real vcn
    //

    if (FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, Vcn, Lcn )) {

        *Vcn += StartingVcn;

    } else {

        *Vcn = Mcb->NtfsMcbArray[Mcb->NtfsMcbArraySizeInUse - 1].EndingVcn;
        *Lcn = UNUSED_LCN;
    }

    return TRUE;
}


BOOLEAN
NtfsLookupNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    OUT PLONGLONG Lcn OPTIONAL,
    OUT PLONGLONG CountFromLcn OPTIONAL,
    OUT PLONGLONG StartingLcn OPTIONAL,
    OUT PLONGLONG CountFromStartingLcn OPTIONAL,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    )

/*++

Routine Description:

    This routine is used to query mapping information

Arguments:

    Mcb - Supplies the Mcb being queried

    Vcn - Supplies the Vcn being queried

    Lcn - Optionally receives the lcn corresponding to the input vcn

    CountFromLcn - Optionally receives the number of clusters following
        the lcn in the run

    StartingLcn - Optionally receives the start of the run containing the
        input vcn

    CountFromStartingLcn - Optionally receives the number of clusters in
        the entire run

    RangePtr - Optionally receives the index for the range that we're returning

    RunIndex - Optionally receives the index for the run within the range that
        we're returning

Return Value:

    BOOLEAN - TRUE if the mapping exists and FALSE if it doesn't exist
        or if it is unloaded.

--*/

{
    ULONG LocalRangeIndex;

    PNTFS_MCB_ENTRY Entry;

    NtfsAcquireNtfsMcbMutex( Mcb );

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Do a basic bounds check
    //

    ASSERT( Mcb->NtfsMcbArraySizeInUse > 0 );

    //
    //  Locate the array entry that has the hit for the input vcn, and
    //  make sure it is valid.  Also set the output range index if present
    //

    LocalRangeIndex = NtfsMcbLookupArrayIndex(Mcb, Vcn);

    //
    //  Now lookup the large mcb entry.  The Vcn we pass in is
    //  biased by the starting vcn.  If we miss then we'll just return false
    //

    if (((Entry = Mcb->NtfsMcbArray[LocalRangeIndex].NtfsMcbEntry) == NULL) ||
        (Vcn > Entry->NtfsMcbArray->EndingVcn) ||
        (Vcn < Entry->NtfsMcbArray->StartingVcn)) {

        ASSERT( (Entry == NULL) || (Vcn > Entry->NtfsMcbArray->EndingVcn) || (Vcn < 0) );

        if (ARGUMENT_PRESENT(RangePtr)) {

            *RangePtr = (PVOID)Entry;

            //
            //  If this is the first range, always normalize back to the reserved pointer,
            //  since this is the only range which can move if we split out of our
            //  initial static allocation!
            //

            if (LocalRangeIndex == 0) {
                *RangePtr = FIRST_RANGE;
            }
        }

        NtfsReleaseNtfsMcbMutex( Mcb );
        return FALSE;
    }

    if (!FsRtlLookupLargeMcbEntry( &Entry->LargeMcb,
                                   Vcn - Mcb->NtfsMcbArray[LocalRangeIndex].StartingVcn,
                                   Lcn,
                                   CountFromLcn,
                                   StartingLcn,
                                   CountFromStartingLcn,
                                   RunIndex )) {

        //
        //  If we go off the end of the Mcb, but are in the range, then we
        //  return a hole to the end of the range.
        //

        if (ARGUMENT_PRESENT(Lcn)) {
            *Lcn = UNUSED_LCN;
        }

        if (ARGUMENT_PRESENT(CountFromLcn)) {
            *CountFromLcn = Mcb->NtfsMcbArray[LocalRangeIndex].EndingVcn - Vcn + 1;
        }

        if (ARGUMENT_PRESENT(StartingLcn)) {
            *StartingLcn = UNUSED_LCN;
        }

        if (ARGUMENT_PRESENT(RunIndex)) {
            *RunIndex = FsRtlNumberOfRunsInLargeMcb( &Entry->LargeMcb );
        }

        if (ARGUMENT_PRESENT( CountFromStartingLcn )) {

            //
            //  If there are no runs in the Mcb then specify
            //  a hole for the full range.
            //

            *CountFromStartingLcn = Mcb->NtfsMcbArray[LocalRangeIndex].EndingVcn -
                                    Mcb->NtfsMcbArray[LocalRangeIndex].StartingVcn + 1;

            if (*RunIndex != 0) {

                VCN LastVcn;
                LCN LastLcn;

                FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb,
                                              &LastVcn,
                                              &LastLcn );

                ASSERT( LastVcn <= *CountFromStartingLcn );
                *CountFromStartingLcn -= (LastVcn + 1);
            }
        }
    }

    if (ARGUMENT_PRESENT(RangePtr)) {

        *RangePtr = (PVOID)Entry;

        //
        //  If this is the first range, always normalize back to the reserved pointer,
        //  since this is the only range which can move if we split out of our
        //  initial static allocation!
        //

        if (LocalRangeIndex == 0) {
            *RangePtr = FIRST_RANGE;
        }
    }

    //
    //  Now move this entry to the tail of the lru queue.
    //  We need to take out the global mutex to do this.
    //  Only do this if he is already in the queue - we can
    //  deadlock if we take a fault in the paging file path.
    //

    if (Entry->LruLinks.Flink != NULL) {

        if (ExTryToAcquireFastMutex( &NtfsMcbFastMutex )) {

            NtfsMcbDequeueLruEntry( Mcb, Entry );
            NtfsMcbEnqueueLruEntry( Mcb, Entry );

            ExReleaseFastMutex( &NtfsMcbFastMutex );
        }
    }

    NtfsReleaseNtfsMcbMutex( Mcb );

    return TRUE;
}


BOOLEAN
NtfsGetNextNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN PVOID *RangePtr,
    IN ULONG RunIndex,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn,
    OUT PLONGLONG Count
    )

/*++

Routine Description:

    This routine returns the range denoted by the type index values

Arguments:

    Mcb - Supplies the Mcb being queried

    RangePtr - Supplies the pointer to the range being queried, or NULL for the first one,
               returns next range

    RunIndex - Supplies the index within then being queried, or MAXULONG for first in next

    Vcn - Receives the starting Vcn of the run being returned

    Lcn - Receives the starting Lcn of the run being returned or unused
        lbn value of -1

    Count - Receives the number of clusters within this run

Return Value:

    BOOLEAN - TRUE if the two input indices are valid and FALSE if the
        the index are not valid or if the range is not loaded

--*/

{
    PNTFS_MCB_ENTRY Entry = (PNTFS_MCB_ENTRY)*RangePtr;
    BOOLEAN Result = FALSE;

    NtfsAcquireNtfsMcbMutex( Mcb );

    NtfsVerifyNtfsMcb(Mcb);

    try {

        //
        //  Null RangePtr means first range
        //

        if (Entry == FIRST_RANGE) {
            Entry = Mcb->NtfsMcbArray[0].NtfsMcbEntry;
        }

        //
        //  If there is no entry 0, get out.
        //

        if (Entry == NULL) {

            try_return(Result = FALSE);
        }

        //
        //  RunIndex of MAXULONG means first of next
        //

        if (RunIndex == MAXULONG) {

            //
            //  If we are already in the last range, get out.
            //

            if (Entry->NtfsMcbArray == (Mcb->NtfsMcbArray + Mcb->NtfsMcbArraySizeInUse - 1)) {

                try_return(Result = FALSE);
            }

            *RangePtr = Entry = (Entry->NtfsMcbArray + 1)->NtfsMcbEntry;
            RunIndex = 0;
        }

        //
        //  If there is no next entry, get out.
        //

        if (Entry == NULL) {

            try_return(Result = FALSE);
        }

        ASSERT( Mcb == Entry->NtfsMcb );

        //
        //  Lookup the large mcb entry.  If we get a miss then the we're
        //  beyond the end of the ntfs mcb and should return false
        //

        if (!FsRtlGetNextLargeMcbEntry( &Entry->LargeMcb, RunIndex, Vcn, Lcn, Count )) {

            //
            //  Our caller should only be off by one or two (if there is
            //  a hole) runs.
            //

            ASSERT(RunIndex <= (FsRtlNumberOfRunsInLargeMcb(&Entry->LargeMcb) + 1));

            //
            //  Get the first Vcn past the last Vcn in a run.  It is -1 if there
            //  are no runs.
            //

            if (!FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, Vcn, Lcn )) {

                *Vcn = -1;
            }

            *Vcn += Entry->NtfsMcbArray->StartingVcn + 1;

            //
            //  If that one is beyond the ending Vcn, then get out.
            //  Otherwise there is a hole at the end of the range, and we
            //  must return that when he is reading one index beyond the
            //  last run.  If we have a run index beyond that, then it is
            //  time to return FALSE as well.
            //

            if ((*Vcn  > Entry->NtfsMcbArray->EndingVcn) ||
                (RunIndex > FsRtlNumberOfRunsInLargeMcb(&Entry->LargeMcb))) {

                try_return(Result = FALSE);
            }

            //
            //  If we go off the end of the Mcb, but are in the range, then we
            //  return a hole to the end of the range.
            //

            *Lcn = UNUSED_LCN;
            *Count = Entry->NtfsMcbArray->EndingVcn - *Vcn + 1;

        } else {

            //
            //  Otherwise we have a hit on the large mcb and need to bias the returned
            //  vcn by the starting vcn value for this range.
            //

            *Vcn = *Vcn + Entry->NtfsMcbArray->StartingVcn;
        }

        //
        //  Make certain we aren't returning a VCN that maps over to
        //  the next range.
        //

        ASSERT(*Vcn - 1 != Entry->NtfsMcbArray->EndingVcn);

        Result = TRUE;

    try_exit: NOTHING;

    } finally {

        NtfsReleaseNtfsMcbMutex( Mcb );
    }

    return Result;
}


BOOLEAN
NtfsSplitNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Amount
    )

/*++

Routine Description:

    This routine splits an mcb

Arguments:

    Mcb - Supplies the Mcb being maniuplated

    Vcn - Supplies the Vcn to be shifted

    Amount - Supplies the amount to shift by

Return Value:

    BOOLEAN - TRUE if worked okay and FALSE otherwise

--*/

{
    ULONG RangeIndex;
    PNTFS_MCB_ENTRY Entry;
    ULONG i;

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Locate the array entry that has the hit for the input vcn
    //

    RangeIndex = NtfsMcbLookupArrayIndex(Mcb, Vcn);

    Entry = Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry;

    //
    //  Now if the entry is not null then we have to call the large
    //  mcb package to split the mcb.  Bias the vcn by the starting vcn
    //

    if (Entry != NULL) {

        if (!FsRtlSplitLargeMcb( &Entry->LargeMcb,
                                 Vcn - Mcb->NtfsMcbArray[RangeIndex].StartingVcn,
                                 Amount )) {

            NtfsVerifyNtfsMcb(Mcb);

            return FALSE;
        }
    }

    //
    //  Even if the entry is null we will march through the rest of our ranges
    //  updating the ending vcn and starting vcn as we go.  We will update the
    //  ending vcn for the range we split and only update the starting vcn
    //  for the last entry, because its ending vcn is already max long long
    //

    for (i = RangeIndex + 1; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

        Mcb->NtfsMcbArray[i - 1].EndingVcn += Amount;
        Mcb->NtfsMcbArray[i].StartingVcn += Amount;
    }

    //
    //  And grow the last range unless it would wrap.
    //

    if ((Mcb->NtfsMcbArray[i - 1].EndingVcn + Amount) > Mcb->NtfsMcbArray[i - 1].EndingVcn) {
        Mcb->NtfsMcbArray[i - 1].EndingVcn += Amount;
    }

    //
    //  Then return to our caller
    //

    NtfsVerifyNtfsMcb(Mcb);

    return TRUE;
}


VOID
NtfsRemoveNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG Count
    )

/*++

Routine Description:

    This routine removes an range of mappings from the Mcb.  After
    the call the mapping for the range will be a hole.  It is an
    error to call this routine with the mapping range being removed
    also being unloaded.

Arguments:

    Mcb - Supplies the Mcb being maniuplated

    StartingVcn - Supplies the starting Vcn to remove

    Count - Supplies the number of mappings to remove

Return Value:

    None.

--*/

{
    LONGLONG Vcn;
    LONGLONG RunLength;
    LONGLONG RemainingCount;

    ULONG RangeIndex;
    PNTFS_MCB_ENTRY Entry;
    VCN EntryStartingVcn;
    VCN EntryEndingVcn;

    ASSERT_STREAM_EXCLUSIVE(Mcb);

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Loop through the range of vcn's that we need to remove
    //

    for (Vcn = StartingVcn, RemainingCount = Count;
         Vcn < StartingVcn + Count;
         Vcn += RunLength, RemainingCount -= RunLength) {

        //
        //  Locate the array entry that has the hit for the vcn
        //

        RangeIndex = NtfsMcbLookupArrayIndex(Mcb, Vcn);

        Entry = Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry;
        EntryStartingVcn = Mcb->NtfsMcbArray[RangeIndex].StartingVcn;
        EntryEndingVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;

        //
        //  Compute how much to delete from the entry.  We will delete to
        //  to end of the entry or as much as count is remaining
        //

        RunLength = EntryEndingVcn - Vcn + 1;

        //
        //  If the Mcb is set up correctly, the only way we can get
        //  RunLength == 0 is if the Mcb is completely empty.  Assume
        //  that this is error recovery, and that it is ok.
        //

        if ((Entry == NULL) || (RunLength == 0)) {
            break;
        }

        //
        //  If that is too much, then just delete what we need.
        //

        if ((ULONGLONG)RunLength > (ULONGLONG)RemainingCount) { RunLength = RemainingCount; }

        //
        //  Now remove the mapping from the large mcb, bias the vcn
        //  by the start of the range
        //

        FsRtlRemoveLargeMcbEntry( &Entry->LargeMcb, Vcn - EntryStartingVcn,  RunLength );
    }

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


BOOLEAN
NtfsAddNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Lcn,
    IN LONGLONG RunCount,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine add a new entry to a Mcb

Arguments:

    Mcb - Supplies the Mcb being modified

    Vcn - Supplies the Vcn that we are providing a mapping for

    Lcn - Supplies the Lcn corresponding to the input Vcn if run count is non zero

    RunCount - Supplies the size of the run following the hole

    AlreadySynchronized - Indicates if the caller has already acquired the mcb mutex

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully and FALSE otherwise

--*/

{
    LONGLONG LocalVcn;
    LONGLONG LocalLcn;
    LONGLONG RunLength;
    LONGLONG RemainingCount;

    ULONG RangeIndex;
    PNTFS_MCB_ENTRY Entry;
    PNTFS_MCB_ENTRY NewEntry = NULL;
    LONGLONG EntryStartingVcn;
    LONGLONG EntryEndingVcn;
    LONGLONG PrevEndingVcn;

    BOOLEAN Result = FALSE;

    if (!AlreadySynchronized) { NtfsAcquireNtfsMcbMutex( Mcb ); }

    NtfsVerifyNtfsMcb(Mcb);

    try {

        //
        //  Loop through the range of vcn's that we need to add
        //

        for (LocalVcn = Vcn, LocalLcn = Lcn, RemainingCount = RunCount;
             LocalVcn < Vcn + RunCount;
             LocalVcn += RunLength, LocalLcn += RunLength, RemainingCount -= RunLength) {

            //
            //  Locate the array entry that has the hit for the vcn
            //

            RangeIndex = NtfsMcbLookupArrayIndex(Mcb, LocalVcn);

            Entry = Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry;
            EntryStartingVcn = Mcb->NtfsMcbArray[RangeIndex].StartingVcn;

            //
            //  Now if the entry doesn't exist then we'll need to create one
            //

            if (Entry == NULL) {

                //
                //  See if we need to get the first entry in the initial structs.
                //

                if (Mcb->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {
                    Entry = &CONTAINING_RECORD(&Mcb->NtfsMcbArray[0],
                                               NTFS_MCB_INITIAL_STRUCTS,
                                               Phase1.SingleMcbArrayEntry)->Phase1.McbEntry;

                //
                //  Allocate pool and initialize the fields in of the entry
                //

                } else {
                    NewEntry =
                    Entry = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ENTRY), 'MftN' );
                }

                //
                //  Initialize the entry but don't put into the Mcb array until
                //  initialization is complete.
                //

                Entry->NtfsMcb = Mcb;
                Entry->NtfsMcbArray = &Mcb->NtfsMcbArray[RangeIndex];
                FsRtlInitializeLargeMcb( &Entry->LargeMcb, Mcb->PoolType );

                //
                //  Now put the entry into the lru queue under the protection of
                //  the global mutex
                //

                ExAcquireFastMutex( &NtfsMcbFastMutex );

                //
                //  Only put paged Mcb entries in the queue.
                //

                if (Mcb->PoolType == PagedPool) {
                    NtfsMcbEnqueueLruEntry( Mcb, Entry );
                }

                //
                //  Now that the initialization is complete we can store
                //  this entry in the Mcb array.  This will now be cleaned
                //  up with the Scb if there is a future error.
                //

                Mcb->NtfsMcbArray[RangeIndex].NtfsMcbEntry = Entry;
                NewEntry = NULL;

                //
                //  Check if we should fire off the cleanup lru queue work item
                //

                if ((NtfsMcbCurrentLevel > NtfsMcbHighWaterMark) && !NtfsMcbCleanupInProgress) {

                    NtfsMcbCleanupInProgress = TRUE;

                    ExInitializeWorkItem( &NtfsMcbWorkItem, NtfsMcbCleanupLruQueue, NULL );

                    ExQueueWorkItem( &NtfsMcbWorkItem, CriticalWorkQueue );
                }

                ExReleaseFastMutex( &NtfsMcbFastMutex );
            }

            //
            //  Get out if he is trying to add a hole.  At least we created the LargeMcb
            //

            if (Lcn == UNUSED_LCN) {
                try_return( Result = TRUE );
            }

            //
            //  If this request goes beyond the end of the range,
            //  and it is the last range, and we will simply
            //  grow it.
            //

            EntryEndingVcn = LocalVcn + RemainingCount - 1;

            if ((EntryEndingVcn > Mcb->NtfsMcbArray[RangeIndex].EndingVcn) &&
                ((RangeIndex + 1) == Mcb->NtfsMcbArraySizeInUse)) {

                PrevEndingVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;
                Mcb->NtfsMcbArray[RangeIndex].EndingVcn = EntryEndingVcn;

            //
            //  Otherwise, just insert enough of this run to go to the end
            //  of the range.
            //

            } else {
                EntryEndingVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;
            }

            //
            //  At this point the entry exists so now compute how much to add
            //  We will add to end of the entry or as much as count allows us
            //

            RunLength = EntryEndingVcn - LocalVcn + 1;

            if (((ULONGLONG)RunLength) > ((ULONGLONG)RemainingCount)) { RunLength = RemainingCount; }

            //
            //  We need to deal with the case where a range is larger than (2^32 - 1) clusters.
            //  If there are no runs in this range then the state is legal.  Otherwise we
            //  need to split up the entry.
            //

            if (EntryEndingVcn - EntryStartingVcn >= MAX_CLUSTERS_PER_RANGE) {

                if (((PSCB)(Mcb->FcbHeader))->ScbSnapshot) {

                    //
                    //  We should only be adding this entry as part of a transaction and the
                    //  snapshot limits should force this range to be unloaded on error.
                    //

                    ASSERT( ExIsResourceAcquiredExclusiveLite( ((PSCB) (Mcb->FcbHeader))->Header.Resource ));

                    if (Mcb->NtfsMcbArray[RangeIndex].StartingVcn < ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->LowestModifiedVcn) {
    
                        ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->LowestModifiedVcn = Mcb->NtfsMcbArray[RangeIndex].StartingVcn;
                    }
    
                    if (Mcb->NtfsMcbArray[RangeIndex].EndingVcn > ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->HighestModifiedVcn) {
    
                        ((PSCB) (Mcb->FcbHeader))->ScbSnapshot->HighestModifiedVcn = Mcb->NtfsMcbArray[RangeIndex].EndingVcn;
                    }

                } else {

                    //
                    //  If we are not taking snapshots, we better be in restart mode
                    //

                    ASSERT( FlagOn(((PSCB)Mcb->FcbHeader)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS) );
                }


                //
                //  If the count in the this Mcb is non-zero then we must be growing the
                //  range.  We can simply split at the previoius end of the Mcb.  It must
                //  be legal.
                //

                if (FsRtlNumberOfRunsInLargeMcb( &Entry->LargeMcb ) != 0) {

                    ASSERT( PrevEndingVcn < EntryEndingVcn );

                    NtfsInsertNewRange( Mcb, PrevEndingVcn + 1, RangeIndex, FALSE );

                //
                //  There are no runs currently in this range.  If we are at the
                //  start of the range then split at our maximum range value.
                //  Otherwise split at the Vcn being inserted.  We don't need
                //  to be too smart here.  The mapping pair package will decide where
                //  the final range values are.
                //

                } else if (LocalVcn == EntryStartingVcn) {

                    NtfsInsertNewRange( Mcb,
                                        EntryStartingVcn + MAX_CLUSTERS_PER_RANGE,
                                        RangeIndex,
                                        FALSE );

                //
                //  Go ahead and split at the CurrentVcn.  On our next pass we will
                //  trim the length of this new range if necessary.
                //

                } else {

                    NtfsInsertNewRange( Mcb,
                                        LocalVcn,
                                        RangeIndex,
                                        FALSE );
                }

                //
                //  Set the run length to 0 and go back to the start of the loop.
                //  We will encounter the inserted range on the next pass.
                //

                RunLength = 0;
                continue;
            }

            //
            //  Now add the mapping from the large mcb, bias the vcn
            //  by the start of the range
            //

            ASSERT( (LocalVcn - EntryStartingVcn) >= 0 );

            if (!FsRtlAddLargeMcbEntry( &Entry->LargeMcb,
                                        LocalVcn - EntryStartingVcn,
                                        LocalLcn,
                                        RunLength )) {

                try_return( Result = FALSE );
            }
        }

        Result = TRUE;

    try_exit: NOTHING;

    } finally {

        NtfsVerifyNtfsMcb(Mcb);

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }

        if (NewEntry != NULL) { NtfsFreePool( NewEntry ); }
    }

    return Result;
}


VOID
NtfsUnloadNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN TruncateOnly,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine unloads the mapping stored in the Mcb.  After
    the call everything from startingVcn and endingvcn is now unmapped and unknown.

Arguments:

    Mcb - Supplies the Mcb being manipulated

    StartingVcn - Supplies the first Vcn which is no longer being mapped

    EndingVcn - Supplies the last vcn to be unloaded

    TruncateOnly - Supplies TRUE if last affected range should only be
                   truncated, or FALSE if it should be unloaded (as during
                   error recovery)

    AlreadySynchronized - Supplies TRUE if our caller already owns the Mcb mutex.

Return Value:

    None.

--*/

{
    ULONG StartingRangeIndex;
    ULONG EndingRangeIndex;

    ULONG i;

    if (!AlreadySynchronized) { NtfsAcquireNtfsMcbMutex( Mcb ); }

    //
    //  Verify that we've been called to unload a valid range.  If we haven't,
    //  then there's nothing we can unload, so we just return here.  Still,
    //  we'll assert so we can see why we were called with an invalid range.
    //

    if ((StartingVcn < 0) || (EndingVcn < StartingVcn)) {

        //
        //  The only legal case is if the range is empty.
        //

        ASSERT( StartingVcn == EndingVcn + 1 );
        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }
        return;
    }

    NtfsVerifyNtfsMcb(Mcb);
    NtfsVerifyUncompressedNtfsMcb(Mcb,StartingVcn,EndingVcn);

    //
    //  Get the starting and ending range indices for this call
    //

    StartingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, StartingVcn );
    EndingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, EndingVcn );

    //
    //  Use try finally to enforce common termination processing.
    //

    try {

        //
        //  For all paged Mcbs, just unload all ranges touched by the
        //  unload range, and collapse with any unloaded neighbors.
        //

        if (Mcb->PoolType == PagedPool) {

            //
            //  Handle truncate case.  The first test insures that we only truncate
            //  the Mcb were were initialized with (we cannot deallocate it).
            //
            //  Also only truncate if ending is MAXLONGLONG and we are not eliminating
            //  the entire range, because that is the common truncate case, and we
            //  do not want to unload the last range every time we truncate on close.
            //

            if (((StartingRangeIndex == 0) && (Mcb->NtfsMcbArraySizeInUse == 1))

                ||

                (TruncateOnly && (StartingVcn != Mcb->NtfsMcbArray[StartingRangeIndex].StartingVcn))) {

                //
                //  If this is not a truncate call, make sure to eliminate the
                //  entire range.
                //

                if (!TruncateOnly) {
                    StartingVcn = 0;
                }

                if (Mcb->NtfsMcbArray[StartingRangeIndex].NtfsMcbEntry != NULL) {

                    FsRtlTruncateLargeMcb( &Mcb->NtfsMcbArray[StartingRangeIndex].NtfsMcbEntry->LargeMcb,
                                           StartingVcn - Mcb->NtfsMcbArray[StartingRangeIndex].StartingVcn );
                }

                Mcb->NtfsMcbArray[StartingRangeIndex].EndingVcn = StartingVcn - 1;

                StartingRangeIndex += 1;
            }

            //
            //  Unload entries that are beyond the starting range index
            //

            for (i = StartingRangeIndex; i <= EndingRangeIndex; i += 1) {

                UnloadEntry( Mcb, i );
            }

            //
            //  If there is a preceding unloaded range, we must collapse him too.
            //

            if ((StartingRangeIndex != 0) &&
                (Mcb->NtfsMcbArray[StartingRangeIndex - 1].NtfsMcbEntry == NULL)) {

                StartingRangeIndex -= 1;
            }

            //
            //  If there is a subsequent unloaded range, we must collapse him too.
            //

            if ((EndingRangeIndex != (Mcb->NtfsMcbArraySizeInUse - 1)) &&
                (Mcb->NtfsMcbArray[EndingRangeIndex + 1].NtfsMcbEntry == NULL)) {

                EndingRangeIndex += 1;
            }

            //
            //  Now collapse empty ranges.
            //

            if (StartingRangeIndex < EndingRangeIndex) {
                NtfsCollapseRanges( Mcb, StartingRangeIndex, EndingRangeIndex );
            }

            try_return(NOTHING);
        }

        //
        //  For nonpaged Mcbs, there is only one range and we truncate it.
        //

        ASSERT((StartingRangeIndex | EndingRangeIndex) == 0);

        if (Mcb->NtfsMcbArray[0].NtfsMcbEntry != NULL) {

            FsRtlTruncateLargeMcb( &Mcb->NtfsMcbArray[0].NtfsMcbEntry->LargeMcb, StartingVcn );
        }

        Mcb->NtfsMcbArray[0].EndingVcn = StartingVcn - 1;

    try_exit: NOTHING;

    } finally {

        //
        //  Truncate all unused entries from the end by dropping ArraySizeInUse
        //  to be the index of the last loaded entry + 1.
        //

        for (i = Mcb->NtfsMcbArraySizeInUse - 1;
             (Mcb->NtfsMcbArray[i].NtfsMcbEntry == NULL);
             i--) {

            //
            //  If the first range is unloaded, set it to its initial state
            //  (empty) and break out.
            //

            if (i==0) {
                Mcb->NtfsMcbArray[0].EndingVcn = -1;
                break;
            }
        }
        Mcb->NtfsMcbArraySizeInUse = i + 1;

        //
        //  See if we broke anything.
        //

        NtfsVerifyNtfsMcb(Mcb);
        NtfsVerifyUncompressedNtfsMcb(Mcb,StartingVcn,EndingVcn);

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }
    }

    return;
}


VOID
NtfsDefineNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine splits an existing range within the Mcb into two ranges

Arguments:

    Mcb - Supplies the Mcb being modified

    StartingVcn - Supplies the beginning of the new range being split

    EndingVcn - Supplies the ending vcn to include in this new range

    AlreadySynchronized - Indicates if the caller has already acquired the mcb mutex

Return Value:

    None.

--*/

{
    ULONG StartingRangeIndex, EndingRangeIndex;

    if (!AlreadySynchronized) { NtfsAcquireNtfsMcbMutex( Mcb ); }

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Make sure we're of the right pool type
    //
    //  If the ending vcn is less than or equal to the starting vcn then we will no op
    //  this call
    //

    if ((Mcb->PoolType != PagedPool) || (EndingVcn < StartingVcn)) {

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }

        return;
    }

    try {

        PNTFS_MCB_ARRAY StartingArray;
        PNTFS_MCB_ARRAY EndingArray;
        PNTFS_MCB_ENTRY StartingEntry;
        PNTFS_MCB_ENTRY EndingEntry;
        ULONG i;

        //
        //  Locate the Starting Mcb
        //

        StartingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, StartingVcn );

        //
        //  Locate the ending Mcb
        //

        EndingRangeIndex = NtfsMcbLookupArrayIndex( Mcb, EndingVcn );
        EndingArray = &Mcb->NtfsMcbArray[EndingRangeIndex];
        EndingEntry = EndingArray->NtfsMcbEntry;

        //
        //  Special case:  extending last range where StartingVcn matches
        //

        if (((EndingRangeIndex + 1) == Mcb->NtfsMcbArraySizeInUse) &&
            (StartingVcn == EndingArray->StartingVcn) &&
            (EndingArray->EndingVcn <= EndingVcn)) {

            //
            //  Since this range already starts with the desired Vcn
            //  we adjust the end to match the caller's request
            //

            EndingArray->EndingVcn = EndingVcn;

            ASSERT( ((EndingVcn - StartingVcn) < MAX_CLUSTERS_PER_RANGE) ||
                    (EndingEntry == NULL) ||
                    (FsRtlNumberOfRunsInLargeMcb( &EndingEntry->LargeMcb ) == 0) );

            leave;
        }

        //
        //  Special case:  handling defining a range after the end of the file
        //

        if (StartingVcn > EndingArray->EndingVcn) {

            LONGLONG OldEndingVcn = EndingArray->EndingVcn;

            //
            //  Has to be the last range.
            //

            ASSERT( StartingRangeIndex == EndingRangeIndex );
            ASSERT( (EndingRangeIndex + 1) == Mcb->NtfsMcbArraySizeInUse );

            //
            //  First extend the last range to include our new range.
            //

            EndingArray->EndingVcn = EndingVcn;

            //
            //  We will be adding a new range and inserting or growing the
            //  previous range up to the new range.  If the previous range is
            //  *empty* but has an NtfsMcbEntry then we want to unload the entry.
            //  Otherwise we will grow that range to the correct value but
            //  the Mcb won't contain the clusters for the range.  We want
            //  to unload that range and update the OldEndingVcn value so
            //  as not to create two empty ranges prior to this.
            //

            if ((OldEndingVcn == -1) &&
                (EndingArray->NtfsMcbEntry != NULL)) {

                ASSERT( EndingRangeIndex == 0 );

                UnloadEntry( Mcb, EndingRangeIndex );
            }

            //
            //  Create the range the caller specified.
            //

            NtfsInsertNewRange( Mcb, StartingVcn, EndingRangeIndex, TRUE );
            DebugDoit( StartingArray = EndingArray = NULL );
            DebugDoit( StartingEntry = EndingEntry = NULL );

            //
            //  If this range does not abut the previous last range, *and*
            //  the previous range was not *empty*, then we have to define a
            //  range to contain the unloaded space in the middle.
            //

            if (((OldEndingVcn + 1) < StartingVcn) &&
                ((OldEndingVcn + 1) != 0)) {

                NtfsInsertNewRange( Mcb, OldEndingVcn + 1, StartingRangeIndex, TRUE );
                DebugDoit( StartingArray = EndingArray = NULL );
                DebugDoit( StartingEntry = EndingEntry = NULL );
            }

            ASSERT( ((EndingVcn - StartingVcn) < MAX_CLUSTERS_PER_RANGE) ||
                    (Mcb->NtfsMcbArray[NtfsMcbLookupArrayIndex( Mcb, EndingVcn )].NtfsMcbEntry == NULL) ||
                    (FsRtlNumberOfRunsInLargeMcb( &Mcb->NtfsMcbArray[NtfsMcbLookupArrayIndex( Mcb, EndingVcn )].NtfsMcbEntry->LargeMcb ) == 0) );

            leave;
        }

        //
        //  Check if we really need to insert a new range at the ending vcn
        //  we only need to do the work if there is not already one at that vcn
        //  and this is not the last range
        //

        if (EndingVcn < EndingArray->EndingVcn) {

            NtfsInsertNewRange( Mcb, EndingVcn + 1, EndingRangeIndex, FALSE );
            DebugDoit( StartingArray = EndingArray = NULL );
            DebugDoit( StartingEntry = EndingEntry = NULL );

            //
            //  Recache pointers since NtfsMcbArray may have moved
            //

            EndingArray = &Mcb->NtfsMcbArray[EndingRangeIndex];
            EndingEntry = EndingArray->NtfsMcbEntry;

            ASSERT( EndingArray->EndingVcn == EndingVcn );
        }

        //
        //  Determine location for insertion
        //

        StartingArray = &Mcb->NtfsMcbArray[StartingRangeIndex];
        StartingEntry = StartingArray->NtfsMcbEntry;

        //
        //  Check if we really need to insert a new range at the starting vcn
        //  we only need to do the work if this Mcb doesn't start at the
        //  requested Vcn
        //

        if (StartingArray->StartingVcn < StartingVcn) {

            NtfsInsertNewRange( Mcb, StartingVcn, StartingRangeIndex, FALSE );
            DebugDoit( StartingArray = EndingArray = NULL );
            DebugDoit( StartingEntry = EndingEntry = NULL );

            StartingRangeIndex++;
            StartingArray = &Mcb->NtfsMcbArray[StartingRangeIndex];
            StartingEntry = StartingArray->NtfsMcbEntry;
            ASSERT( StartingArray->StartingVcn == StartingVcn );

            EndingRangeIndex++;
            // EndingArray = &Mcb->NtfsMcbArray[EndingRangeIndex];
            // EndingEntry = EndingArray->NtfsMcbEntry;
            // ASSERT( EndingArray->EndingVcn == EndingVcn );
        }

        ASSERT( StartingArray->StartingVcn == StartingVcn );
        // ASSERT( EndingArray->EndingVcn == EndingVcn );

        //
        //  At this point, we have a Vcn range beginning at StartingVcn stored in
        //  NtfsMcbArray[StartingRangeIndex] AND ending at EndingVcb which is the
        //  end of NtfsMcbArray[StartingRangeIndex]. This is a collection (>= 1)
        //  of NtfsMcbEntry's.  Our caller expects to have these reduced to
        //  a single run.  Note that our caller should never break the restriction
        //  on maximum number clusters per range.
        //

        while (StartingRangeIndex != EndingRangeIndex) {

            VCN Vcn;
            BOOLEAN MoreEntries;
            LCN Lcn;
            LONGLONG Count;
            ULONG Index;

            PNTFS_MCB_ARRAY NextArray;
            PNTFS_MCB_ENTRY NextEntry;

            //
            //  We merge the contents of NtfsMcbArray[StartingRangeIndex + 1] into
            //  NtfsMcbArray[StartingRangeIndex]
            //

            //
            //  Look up the first Vcn to move in the second Mcb.  If this
            //  Mcb consists of one large hole then there is nothing to
            //  move.
            //

            NextArray = &Mcb->NtfsMcbArray[StartingRangeIndex + 1];
            NextEntry = NextArray->NtfsMcbEntry;

            //
            //  We should never exceed our limit on the maximum number of clusters.
            //

            ASSERT( ((NextArray->EndingVcn - StartingArray->StartingVcn + 1) <= MAX_CLUSTERS_PER_RANGE) ||
                    ((FsRtlNumberOfRunsInLargeMcb( &StartingEntry->LargeMcb ) == 0) &&
                     (FsRtlNumberOfRunsInLargeMcb( &NextEntry->LargeMcb ) == 0)) );

            Vcn = 0;
            MoreEntries = FsRtlLookupLargeMcbEntry( &NextEntry->LargeMcb,
                                                    Vcn,
                                                    &Lcn,
                                                    &Count,
                                                    NULL,
                                                    NULL,
                                                    &Index );

            //
            //  Loop to move entries over.
            //

            //
            // this is the case described by bug #9054.
            // the mcb has somehow? been incorrectly split
            // so this will force everything to be unloaded
            // instead of half loaded and half unloaded
            //
            // the assert is here simply for debug purposes.
            // if this assert fires then we simply want to step
            // thru the code and examine the mcb state to
            // be certain that our assumtions about this bug
            // are correct.  the actual bug scenario could not
            // be reproed so this code path is un-tested.
            //

            ASSERT( StartingEntry != NULL );

            if (StartingEntry != NULL) {

                while (MoreEntries) {

                    //
                    //  If this entry is not a hole, move it.
                    //

                    if (Lcn != UNUSED_LCN) {

                        FsRtlAddLargeMcbEntry( &StartingEntry->LargeMcb,
                                               (Vcn + NextArray->StartingVcn) - StartingArray->StartingVcn,
                                               Lcn,
                                               Count );
                    }

                    Index += 1;

                    MoreEntries = FsRtlGetNextLargeMcbEntry( &NextEntry->LargeMcb,
                                                             Index,
                                                             &Vcn,
                                                             &Lcn,
                                                             &Count );
                }

                ASSERT( StartingArray->EndingVcn < NextArray->EndingVcn );
                StartingArray->EndingVcn = NextArray->EndingVcn;
            }

            //
            //  We've completely emptied the next Mcb.  Unload it.
            //

            UnloadEntry( Mcb, StartingRangeIndex + 1 );

            Mcb->NtfsMcbArraySizeInUse -= 1;

            //
            //  Compact the array
            //

            RtlMoveMemory( StartingArray + 1,
                           StartingArray + 2,
                           sizeof( NTFS_MCB_ARRAY ) * (Mcb->NtfsMcbArraySizeInUse - (StartingRangeIndex + 1))
                           );

            //
            //  Adjust the backpointers
            //

            for (i = StartingRangeIndex + 1;
                 i < Mcb->NtfsMcbArraySizeInUse;
                 i += 1) {

                if (Mcb->NtfsMcbArray[i].NtfsMcbEntry != NULL) {
                    Mcb->NtfsMcbArray[i].NtfsMcbEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[i];
                }
            }

            EndingRangeIndex--;
        }

    } finally {

        NtfsVerifyNtfsMcb(Mcb);

        if (!AlreadySynchronized) { NtfsReleaseNtfsMcbMutex( Mcb ); }
    }

    return;
}


//
//  Local support routines
//

ULONG
NtfsMcbLookupArrayIndex (
    IN PNTFS_MCB Mcb,
    IN VCN Vcn
    )

/*++

Routine Description:

    This routines searches the mcb array for an entry that contains
    the input vcn value

Arguments:

    Mcb - Supplies the Mcb being queried

    Vcn - Supplies the Vcn to lookup

Return Value:

    ULONG - The index of the entry containing the input Vcn value

--*/

{
    ULONG Index;
    ULONG MinIndex;
    ULONG MaxIndex;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Do a quick binary search for the entry containing the vcn
    //

    MinIndex = 0;
    MaxIndex = Mcb->NtfsMcbArraySizeInUse - 1;

    while (TRUE) {

        Index = (MaxIndex + MinIndex) / 2;

        if ((Mcb->NtfsMcbArray[Index].StartingVcn > Vcn) &&
            (Index != 0)) {

            MaxIndex = Index - 1;

        } else if ((Mcb->NtfsMcbArray[Index].EndingVcn < Vcn) &&
                   (Index != Mcb->NtfsMcbArraySizeInUse - 1)) {

            MinIndex = Index + 1;

        } else {

            return Index;
        }
    }
}


//
//  Local support routines
//

VOID
NtfsInsertNewRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN ULONG ArrayIndex,
    IN BOOLEAN MakeNewRangeEmpty
    )

/*++

    This routine is used to add a new range at the specified vcn and index location.
    Since this routine will resize the NtfsMcbArray, the caller must be sure to
    invalidate all cached pointers to NtfsMcbArray entries.

Arguments:

    Mcb - Supplies the Mcb being modified

    StartingVcn - Supplies the vcn for the new range

    ArrayIndex - Supplies the index currently containing the starting vcn

    MakeNewRangeEmpty - TRUE if the caller wants the new range unloaded regardless
                        of the state of the current range

Return Value:

    None.

--*/

{
    ULONG i;
    PNTFS_MCB_ENTRY Entry;
    PNTFS_MCB_ENTRY NewEntry;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Check if we need to grow the array
    //

    if (Mcb->NtfsMcbArraySizeInUse >= Mcb->NtfsMcbArraySize) {
        NtfsGrowMcbArray( Mcb );
    }

    //
    //  Now move entries that are beyond the array index over by one to make
    //  room for the new entry
    //

    if (ArrayIndex + 2 <= Mcb->NtfsMcbArraySizeInUse) {

        RtlMoveMemory( &Mcb->NtfsMcbArray[ArrayIndex + 2],
                       &Mcb->NtfsMcbArray[ArrayIndex + 1],
                       sizeof(NTFS_MCB_ARRAY) * (Mcb->NtfsMcbArraySizeInUse - ArrayIndex - 1));

        for (i = ArrayIndex + 2; i < Mcb->NtfsMcbArraySizeInUse + 1; i += 1) {

            if (Mcb->NtfsMcbArray[i].NtfsMcbEntry != NULL) {

                Mcb->NtfsMcbArray[i].NtfsMcbEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[i];
            }
        }
    }

    //
    //  Increment our in use count by one
    //

    Mcb->NtfsMcbArraySizeInUse += 1;

    //
    //  Now fix the starting and ending Vcn values for the old entry and the
    //  new entry
    //

    Mcb->NtfsMcbArray[ArrayIndex + 1].StartingVcn = StartingVcn;
    Mcb->NtfsMcbArray[ArrayIndex + 1].EndingVcn = Mcb->NtfsMcbArray[ArrayIndex].EndingVcn;
    Mcb->NtfsMcbArray[ArrayIndex + 1].NtfsMcbEntry = NULL;

    Mcb->NtfsMcbArray[ArrayIndex].EndingVcn = StartingVcn - 1;

    //
    //  Now if the entry is old entry is not null then we have a bunch of work to do
    //

    if (!MakeNewRangeEmpty && (Entry = Mcb->NtfsMcbArray[ArrayIndex].NtfsMcbEntry) != NULL) {

        LONGLONG Vcn;
        LONGLONG Lcn;
        LONGLONG RunLength;
        ULONG Index;
        BOOLEAN FreeNewEntry = FALSE;

        //
        //  Use a try-finally in case the Mcb initialization fails.
        //

        try {

            //
            //  Allocate the new entry slot
            //

            NewEntry = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ENTRY), 'MftN' );

            FreeNewEntry = TRUE;
            NewEntry->NtfsMcb = Mcb;
            NewEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[ArrayIndex + 1];
            FsRtlInitializeLargeMcb( &NewEntry->LargeMcb, Mcb->PoolType );

            ExAcquireFastMutex( &NtfsMcbFastMutex );
            NtfsMcbEnqueueLruEntry( Mcb, NewEntry );
            ExReleaseFastMutex( &NtfsMcbFastMutex );

            //
            //  Now that the initialization is complete we can store
            //  this entry in the Mcb array.  This will now be cleaned
            //  up with the Scb if there is a future error.
            //

            Mcb->NtfsMcbArray[ArrayIndex + 1].NtfsMcbEntry = NewEntry;
            FreeNewEntry = FALSE;

            //
            //  Lookup the entry containing the starting vcn in the old entry and put it
            //  in the new entry.  But only if the entry exists otherwise we know that
            //  the large mcb doesn't extend into the new range
            //

            if (FsRtlLookupLargeMcbEntry( &Entry->LargeMcb,
                                          StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn,
                                          &Lcn,
                                          &RunLength,
                                          NULL,
                                          NULL,
                                          &Index )) {

                if (Lcn != UNUSED_LCN) {

                    FsRtlAddLargeMcbEntry( &NewEntry->LargeMcb,
                                           0,
                                           Lcn,
                                           RunLength );
                }

                //
                //  Now for every run in the old entry that is beyond the starting vcn we will
                //  copy it into the new entry. This will also copy over the dummy run at the end
                //  of the mcb if it exists
                //

                for (i = Index + 1; FsRtlGetNextLargeMcbEntry( &Entry->LargeMcb, i, &Vcn, &Lcn, &RunLength ); i += 1) {

                    if (Lcn != UNUSED_LCN) {
                        ASSERT( (Vcn - (StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn)) >= 0 );
                        FsRtlAddLargeMcbEntry( &NewEntry->LargeMcb,
                                               Vcn - (StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn),
                                               Lcn,
                                               RunLength );
                    }
                }

                //
                //  Now modify the old mcb to be smaller and put in the dummy run
                //

                FsRtlTruncateLargeMcb( &Entry->LargeMcb,
                                       StartingVcn - Mcb->NtfsMcbArray[ArrayIndex].StartingVcn );
            }

        } finally {

            if (FreeNewEntry) { NtfsFreePool( NewEntry ); }
        }
    }

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


//
//  Local support routines
//

VOID
NtfsCollapseRanges (
    IN PNTFS_MCB Mcb,
    IN ULONG StartingArrayIndex,
    IN ULONG EndingArrayIndex
    )

/*++

Routine Description:

    This routine will remove the indicated array entries

Arguments:

    Mcb - Supplies the Mcb being modified

    StartingArrayIndex - Supplies the first index to remove

    EndingArrayIndex - Supplies the last index to remove

Return Value:

    None.

--*/

{
    ULONG i;

    NtfsVerifyNtfsMcb(Mcb);

    //
    //  Make sure all the ranges are unloaded.
    //

    DebugDoit(

        for (i = StartingArrayIndex; i <= EndingArrayIndex; i++) {
            ASSERT(Mcb->NtfsMcbArray[i].NtfsMcbEntry == NULL);
        }
    );

    //
    //  We keep the first entry by we need to copy over
    //  the ending vcn of the last entry
    //

    Mcb->NtfsMcbArray[StartingArrayIndex].EndingVcn = Mcb->NtfsMcbArray[EndingArrayIndex].EndingVcn;

    //
    //  Check if we need to move the ending entries up the array
    //  if so then move them forward, and adjust the back pointers.
    //

    if (EndingArrayIndex < Mcb->NtfsMcbArraySizeInUse - 1) {

        RtlMoveMemory( &Mcb->NtfsMcbArray[StartingArrayIndex + 1],
                       &Mcb->NtfsMcbArray[EndingArrayIndex + 1],
                       sizeof(NTFS_MCB_ARRAY) * (Mcb->NtfsMcbArraySizeInUse - EndingArrayIndex - 1));

        for (i = StartingArrayIndex + 1;
             i <= (StartingArrayIndex + Mcb->NtfsMcbArraySizeInUse - EndingArrayIndex - 1);
             i += 1) {

            if (Mcb->NtfsMcbArray[i].NtfsMcbEntry != NULL) {

                Mcb->NtfsMcbArray[i].NtfsMcbEntry->NtfsMcbArray = &Mcb->NtfsMcbArray[i];
            }
        }
    }

    //
    //  Decrement the in use count and return to our caller
    //

    Mcb->NtfsMcbArraySizeInUse -= (EndingArrayIndex - StartingArrayIndex);

    NtfsVerifyNtfsMcb(Mcb);

    return;
}


//
//  Local support routine
//

VOID
NtfsMcbCleanupLruQueue (
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine is called as an ex work queue item and its job is
    to free up the lru queue until we reach the low water mark


Arguments:

    Parameter - ignored

Return Value:

    None.

--*/

{
    PLIST_ENTRY Links;

    PNTFS_MCB Mcb;
    PNTFS_MCB_ARRAY Array;
    PNTFS_MCB_ENTRY Entry;

    UNREFERENCED_PARAMETER( Parameter );

    //
    //  Grab the global lock
    //

    ExAcquireFastMutex( &NtfsMcbFastMutex );

    try {

        //
        //  Scan through the lru queue until we either exhaust the queue
        //  or we've trimmed enough
        //

        for (Links = NtfsMcbLruQueue.Flink;
             (Links != &NtfsMcbLruQueue) && (NtfsMcbCurrentLevel > NtfsMcbLowWaterMark);
             Links = Links->Flink ) {

            //
            //  Get the entry and the mcb it points to
            //

            Entry = CONTAINING_RECORD( Links, NTFS_MCB_ENTRY, LruLinks );

            Mcb = Entry->NtfsMcb;

            //
            //  Skip this entry if it is in the open attribute table.
            //

            if (((PSCB)(Mcb->FcbHeader))->NonpagedScb->OpenAttributeTableIndex != 0) {

                continue;
            }

            //
            //  Try and lock the mcb
            //

            if (NtfsLockNtfsMcb( Mcb )) {

                NtfsVerifyNtfsMcb(Mcb);

                //
                //  The previous test was an unsafe test.  Check again in case
                //  this entry has been added.
                //

                if (((PSCB)(Mcb->FcbHeader))->NonpagedScb->OpenAttributeTableIndex == 0) {

                    //
                    //  We locked the mcb so we can remove this entry, but
                    //  first backup our links pointer so we can continue with the loop
                    //

                    Links = Links->Blink;

                    //
                    //  Get a point to the array entry and then remove this entry and return
                    //  it to pool
                    //

                    Array = Entry->NtfsMcbArray;

                    Array->NtfsMcbEntry = NULL;
                    NtfsMcbDequeueLruEntry( Mcb, Entry );
                    FsRtlUninitializeLargeMcb( &Entry->LargeMcb );
                    if (Mcb->NtfsMcbArraySize != 1) {
                        NtfsFreePool( Entry );
                    }
                }

                NtfsUnlockNtfsMcb( Mcb );
            }
        }

    } finally {

        //
        //  Say we're done with the cleanup so that another one can be fired off when
        //  necessary
        //

        NtfsMcbCleanupInProgress = FALSE;

        ExReleaseFastMutex( &NtfsMcbFastMutex );
    }

    //
    //  Return to our caller
    //

    return;
}


VOID
NtfsSwapMcbs (
    IN PNTFS_MCB McbTarget,
    IN PNTFS_MCB McbSource
    )
/*++

Routine Description:

    This routine swaps the mapping pairs between two mcbs atomically

Arguments:

    McbTarget -

    McbSource -

Return Value:

    None.

--*/
{
    ULONG TempNtfsMcbArraySizeInUse;
    ULONG TempNtfsMcbArraySize;
    PNTFS_MCB_ARRAY TempNtfsMcbArray;
    ULONG Index;

    ASSERT( McbTarget->PoolType == McbSource->PoolType );

    //
    //  Grab the mutex in the original and new  mcb to block everyone out
    //

    NtfsAcquireNtfsMcbMutex( McbTarget );
    NtfsAcquireNtfsMcbMutex( McbSource );

    try {

        //
        //  Check if we need to grow either array so they are in the general form
        //  In the general form we can swap the two by switching the array of mcb entries
        //

        if (McbSource->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {
            NtfsGrowMcbArray( McbSource );
        }
        if (McbSource->NtfsMcbArraySize == MCB_ARRAY_PHASE2_SIZE) {
            NtfsGrowMcbArray( McbSource );
        }

        if (McbTarget->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {
            NtfsGrowMcbArray( McbTarget);
        }
        if (McbTarget->NtfsMcbArraySize == MCB_ARRAY_PHASE2_SIZE) {
            NtfsGrowMcbArray( McbTarget );
        }

        //
        //  Swap the arrays in the two mcb's
        //

        TempNtfsMcbArraySizeInUse = McbTarget->NtfsMcbArraySizeInUse;
        TempNtfsMcbArraySize = McbTarget->NtfsMcbArraySize;
        TempNtfsMcbArray = McbTarget->NtfsMcbArray;

        McbTarget->NtfsMcbArray = McbSource->NtfsMcbArray;
        McbTarget->NtfsMcbArraySize = McbSource->NtfsMcbArraySize;
        McbTarget->NtfsMcbArraySizeInUse = McbSource->NtfsMcbArraySizeInUse;

        McbSource->NtfsMcbArray = TempNtfsMcbArray;
        McbSource->NtfsMcbArraySize = TempNtfsMcbArraySize;
        McbSource->NtfsMcbArraySizeInUse = TempNtfsMcbArraySizeInUse;

        //
        //  Fixup the backptr in the array entries to point the the correct mcb
        //

        for (Index=0; Index < McbSource->NtfsMcbArraySize; Index++) {
            if (McbSource->NtfsMcbArray[Index].NtfsMcbEntry != NULL) {
                McbSource->NtfsMcbArray[Index].NtfsMcbEntry->NtfsMcb = McbSource;
            }
        }

        for (Index=0; Index < McbTarget->NtfsMcbArraySize; Index++) {
            if (McbTarget->NtfsMcbArray[Index].NtfsMcbEntry != NULL) {
                McbTarget->NtfsMcbArray[Index].NtfsMcbEntry->NtfsMcb = McbTarget;
            }
        }

    } finally {
        NtfsReleaseNtfsMcbMutex( McbSource );
        NtfsReleaseNtfsMcbMutex( McbTarget );
    }
}


//
//  Local support routine
//

BOOLEAN
NtfsLockNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine attempts to get the Fcb resource(s) exclusive so that
    ranges may be unloaded.

Arguments:

    Mcb - Supplies the mcb being queried

Return Value:

--*/

{
    //
    //  Try to acquire paging resource exclusive.
    //

    if ((Mcb->FcbHeader->PagingIoResource == NULL) ||
        ExAcquireResourceExclusiveLite(Mcb->FcbHeader->PagingIoResource, FALSE)) {

        //
        //  Now we can try to acquire the main resource exclusively as well.
        //

        if (ExAcquireResourceExclusiveLite(Mcb->FcbHeader->Resource, FALSE)) {
            return TRUE;
        }

        //
        //  We failed to acquire the paging I/O resource, so free the main one
        //  on the way out.
        //

        if (Mcb->FcbHeader->PagingIoResource != NULL) {
            ExReleaseResourceLite( Mcb->FcbHeader->PagingIoResource );
        }
    }

    //
    //  Could not get this file exclusive.
    //

    return FALSE;
}


//
//  Local support routine
//

VOID
NtfsUnlockNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine verifies that an mcb is properly formed

Arguments:

    Mcb - Supplies the mcb being queried

Return Value:

    None.

--*/

{
    //
    //  If there is a paging I/O resource, release it first.
    //

    if (Mcb->FcbHeader->PagingIoResource != NULL) {
        ExReleaseResourceLite(Mcb->FcbHeader->PagingIoResource);
    }

    //
    //  Now release the main resource.
    //

    ExReleaseResourceLite(Mcb->FcbHeader->Resource);
}


//
//  Local support routine
//

VOID
NtfsGrowMcbArray(
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine grows the mcb array. If its phase1 - then it will be promoted to phase2
    If its phase2 it will become the general form. If its the general form 8 new entries will be added.

Arguments:

    Mcb - Supplies the mcb being grown

Return Value:

    None.

--*/

{
    PNTFS_MCB_ARRAY NewArray = NULL;
    ULONG OldArraySize = Mcb->NtfsMcbArraySize;
    PNTFS_MCB_ENTRY Entry;

    //
    //  Test for initial case where we only have one array entry.
    //

    if (Mcb->NtfsMcbArraySize == MCB_ARRAY_PHASE1_SIZE) {

        //
        //  Convince ourselves that we do not have to move the array entry.
        //

        ASSERT(FIELD_OFFSET(NTFS_MCB_INITIAL_STRUCTS, Phase1.SingleMcbArrayEntry) ==
               FIELD_OFFSET(NTFS_MCB_INITIAL_STRUCTS, Phase2.ThreeMcbArrayEntries));

        if (Mcb->NtfsMcbArray[0].NtfsMcbEntry != NULL) {

            //
            //  Allocate a new Mcb Entry, copy the current one over and change the pointer.
            //

            Entry = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ENTRY), 'MftN' );

            //
            //  Once space is allocated, dequeue the old entry.
            //

            ExAcquireFastMutex( &NtfsMcbFastMutex );
            NtfsMcbDequeueLruEntry( Mcb, Mcb->NtfsMcbArray[0].NtfsMcbEntry );

            RtlCopyMemory( Entry, Mcb->NtfsMcbArray[0].NtfsMcbEntry, sizeof(NTFS_MCB_ENTRY) );

            Mcb->NtfsMcbArray[0].NtfsMcbEntry = Entry;

            NtfsMcbEnqueueLruEntry( Mcb, Entry );
            ExReleaseFastMutex( &NtfsMcbFastMutex );
        }

        //
        //  Now change to using the three array elements
        //

        Mcb->NtfsMcbArraySize = MCB_ARRAY_PHASE2_SIZE;

    } else {

        ULONG i;

        //
        //  If we do then allocate an array that can contain 8 more entires
        //

        NewArray = NtfsAllocatePoolWithTag( Mcb->PoolType, sizeof(NTFS_MCB_ARRAY) * (Mcb->NtfsMcbArraySize + 8), 'mftN' );
        Mcb->NtfsMcbArraySize += 8;

        //
        //  Copy over the memory from the old array to the new array and then
        //  for every loaded entry we need to adjust its back pointer to the
        //  array
        //

        RtlCopyMemory( NewArray, Mcb->NtfsMcbArray, sizeof(NTFS_MCB_ARRAY) * OldArraySize );

        for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

            if (NewArray[i].NtfsMcbEntry != NULL) {

                NewArray[i].NtfsMcbEntry->NtfsMcbArray = &NewArray[i];
            }
        }

        //
        //  Free the old array if it was not the original array.
        //

        if (OldArraySize > MCB_ARRAY_PHASE2_SIZE) {
           NtfsFreePool( Mcb->NtfsMcbArray );
        }

        Mcb->NtfsMcbArray = NewArray;
    }

    //
    //  Zero the new part of the array.
    //

    ASSERT( (NewArray == NULL) ||
            (sizeof( NTFS_MCB_ARRAY ) == ((PCHAR)&NewArray[1] - (PCHAR)&NewArray[0])) );

    RtlZeroMemory( &Mcb->NtfsMcbArray[OldArraySize],
                   (Mcb->NtfsMcbArraySize - OldArraySize) * sizeof( NTFS_MCB_ARRAY ));

    return;
}

#ifdef NTFS_VERIFY_MCB

//
//  Local support routine
//

VOID
NtfsVerifyNtfsMcb (
    IN PNTFS_MCB Mcb
    )

/*++

Routine Description:

    This routine verifies that an mcb is properly formed

Arguments:

    Mcb - Supplies the mcb being queried

Return Value:

--*/

{
    ULONG i;
    PNTFS_MCB_ARRAY Array;
    PNTFS_MCB_ENTRY Entry;

    LONGLONG Vbn;
    LONGLONG Lbn;

    ASSERT(Mcb->FcbHeader != NULL);
    ASSERT(Mcb->FcbHeader->NodeTypeCode != 0);

    ASSERT((Mcb->PoolType == PagedPool) || (Mcb->PoolType == NonPagedPool));

    ASSERT(Mcb->NtfsMcbArraySizeInUse <= Mcb->NtfsMcbArraySize);

    for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

        Array = &Mcb->NtfsMcbArray[i];

        ASSERT(((i == 0) && (Array->StartingVcn == 0)) ||
               ((i != 0) && (Array->StartingVcn != 0)));

        ASSERT(Array->StartingVcn <= (Array->EndingVcn + 1));

        if ((Entry = Array->NtfsMcbEntry) != NULL) {

            ASSERT(Entry->NtfsMcb == Mcb);
            ASSERT(Entry->NtfsMcbArray == Array);

            if (FsRtlLookupLastLargeMcbEntry( &Entry->LargeMcb, &Vbn, &Lbn )) {
                ASSERT( Vbn <= (Array->EndingVcn - Array->StartingVcn) );
            }
        }
    }
}


//
//  Local support routine
//

VOID
NtfsVerifyUncompressedNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn
    )

/*++

Routine Description:

    This routines checks if an mcb is for an uncompressed scb and then
    checks that there are no holes in the mcb.  Holes within the range being
    removed are legal provided EndingVcn is max long long.

Arguments:

    Mcb - Supplies the Mcb being examined

    StartingVcn - The starting Vcn being unloaded

    EndingVcn - The ending Vcn being unloaded

Return Value:

    None

--*/

{
    ULONG i;
    ULONG j;
    PNTFS_MCB_ARRAY Array;
    PNTFS_MCB_ENTRY Entry;

    LONGLONG Vbn;
    LONGLONG Lbn;
    LONGLONG Count;

    //
    //  Check if the scb is compressed
    //

    if (((PSCB)Mcb->FcbHeader)->CompressionUnit != 0) { return; }

    //
    //  For each large mcb in the ntfs mcb we will make sure it doesn't
    //  have any holes.
    //

    for (i = 0; i < Mcb->NtfsMcbArraySizeInUse; i += 1) {

        Array = &Mcb->NtfsMcbArray[i];

        if ((Entry = Array->NtfsMcbEntry) != NULL) {

            for (j = 0; FsRtlGetNextLargeMcbEntry(&Entry->LargeMcb,j,&Vbn,&Lbn,&Count); j += 1) {

                ASSERT((Lbn != -1) ||
                       ((Vbn + Array->StartingVcn >= StartingVcn) && (EndingVcn == MAXLONGLONG)) ||
                       FlagOn(((PSCB)Mcb->FcbHeader)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS));
            }
        }
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\mftsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MftSup.c

Abstract:

    This module implements the master file table management routines for Ntfs

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_STRUCSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_MFTSUP)

//
//  Boolean controlling whether to allow holes in the Mft.
//

BOOLEAN NtfsPerforateMft = FALSE;

//
//  Local support routines
//

BOOLEAN
NtfsTruncateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsDefragMftPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

LONG
NtfsReadMftExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN PBCB Bcb,
    IN LONGLONG FileOffset
    );

#if  (DBG || defined( NTFS_FREE_ASSERTS ))
VOID
NtfsVerifyFileReference (
    IN PIRP_CONTEXT IrpContext,
    IN PMFT_SEGMENT_REFERENCE MftSegment
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAllocateMftRecord)
#pragma alloc_text(PAGE, NtfsCheckForDefrag)
#pragma alloc_text(PAGE, NtfsDeallocateMftRecord)
#pragma alloc_text(PAGE, NtfsDefragMftPriv)
#pragma alloc_text(PAGE, NtfsFillMftHole)
#pragma alloc_text(PAGE, NtfsInitializeMftHoleRecords)
#pragma alloc_text(PAGE, NtfsInitializeMftRecord)
#pragma alloc_text(PAGE, NtfsIsMftIndexInHole)
#pragma alloc_text(PAGE, NtfsLogMftFileRecord)
#pragma alloc_text(PAGE, NtfsPinMftRecord)
#pragma alloc_text(PAGE, NtfsReadFileRecord)
#pragma alloc_text(PAGE, NtfsReadMftRecord)
#pragma alloc_text(PAGE, NtfsTruncateMft)
#pragma alloc_text(PAGE, NtfsIterateMft)

#if  (DBG || defined( NTFS_FREE_ASSERTS ))
#pragma alloc_text(PAGE, NtfsVerifyFileReference)
#endif

#endif


#if NTFSDBG
ULONG FileRecordCacheHit = 0;
ULONG FileRecordCacheMiss = 0;
#endif  //  DBG

VOID
NtfsReadFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *BaseFileRecord,
    OUT PATTRIBUTE_RECORD_HEADER *FirstAttribute,
    OUT PLONGLONG MftFileOffset OPTIONAL
    )

/*++

Routine Description:

    This routine reads the specified file record from the Mft or cache if its present
    If it comes from disk it is always verified.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    Fcb - If specified allows us to identify the file which owns the
        invalid file record.

    FileReference - File reference, including sequence number, of the file record
        to be read.

    Bcb - Returns the Bcb for the file record.  This Bcb is mapped, not pinned.

    BaseFileRecord - Returns a pointer to the requested file record.

    FirstAttribute - Returns a pointer to the first attribute in the file record.

    MftFileOffset - If specified, returns the file offset of the file record.

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadFileRecord\n") );

    //
    //  Perform a quick look-aside to see if the file record being requested
    //  is one that we have cached in the IrpContext.  If so, we reuse that Bcb
    //

    if (NtfsFindCachedFileRecord( IrpContext,
                                  NtfsSegmentNumber( FileReference ),
                                  Bcb,
                                  BaseFileRecord )) {

        //
        //  We found the Bcb and File record in the cache.  Figure out the remainder
        //  of the data
        //

        if (ARGUMENT_PRESENT( MftFileOffset )) {
            *MftFileOffset =
                LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( FileReference ));

        DebugDoit( FileRecordCacheHit++ );

        }
    } else {

        USHORT SequenceNumber = FileReference->SequenceNumber;

        DebugDoit( FileRecordCacheMiss++ );

        NtfsReadMftRecord( IrpContext,
                           Vcb,
                           FileReference,
                           TRUE,
                           Bcb,
                           BaseFileRecord,
                           MftFileOffset );

        //
        //  Make sure the file is in use - we validated everything else in NtfsReadMftRecord
        //

        if (!FlagOn( (*BaseFileRecord)->Flags, FILE_RECORD_SEGMENT_IN_USE )) {

            NtfsUnpinBcb( IrpContext, Bcb );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, FileReference, NULL );
        }
    }

    *FirstAttribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)*BaseFileRecord +
                      (*BaseFileRecord)->FirstAttributeOffset);

    DebugTrace( -1, Dbg, ("NtfsReadFileRecord -> VOID\n") );

    return;
}


VOID
NtfsReadMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN CheckRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    )

/*++

Routine Description:

    This routine reads the specified Mft record from the Mft, without checking
    sequence numbers.  This routine may be used to read records in the Mft for
    a file other than its base file record, or it could conceivably be used for
    extraordinary maintenance functions.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    SegmentReference - File reference, including sequence number, of the file
                       record to be read.

    Bcb - Returns the Bcb for the file record.  This Bcb is mapped, not pinned.

    FileRecord - Returns a pointer to the requested file record.

    MftFileOffset - If specified, returns the file offset of the file record.

    CheckRecord - Do a check of records consistency -  always set TRUE unless the
                  record is unowned and could change beneath us

Return Value:

    None

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord2;
    LONGLONG FileOffset;
    PBCB Bcb2 = NULL;
    BOOLEAN ErrorPath = FALSE;

    LONGLONG LlTemp1;
    ULONG CorruptHint;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReadMftRecord\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("SegmentReference = %08lx\n", NtfsSegmentNumber( SegmentReference )) );
    *Bcb = NULL;

    try {

        //
        //  Capture the Segment Reference and make sure the Sequence Number is 0.
        //

        FileOffset = NtfsFullSegmentNumber( SegmentReference );

        //
        //  Calculate the file offset in the Mft to the file record segment.
        //

        FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

        //
        //  Pass back the file offset within the Mft.
        //

        if (ARGUMENT_PRESENT( MftFileOffset )) {

            *MftFileOffset = FileOffset;
        }

        //
        //  Try to read it from the normal Mft.
        //

        try {

            NtfsMapStream( IrpContext,
                           Vcb->MftScb,
                           FileOffset,
                           Vcb->BytesPerFileRecordSegment,
                           Bcb,
                           (PVOID *)FileRecord );

            //
            //  Raise here if we have a file record covered by the mirror,
            //  and we do not see the file signature.
            //

            if ((FileOffset < Vcb->Mft2Scb->Header.FileSize.QuadPart) &&
                (*(PULONG)(*FileRecord)->MultiSectorHeader.Signature != *(PULONG)FileSignature)) {

                NtfsRaiseStatus( IrpContext, STATUS_DATA_ERROR, NULL, NULL );
            }


        //
        //  If we get an exception that is not expected, then we will allow
        //  the search to continue and let the crash occur in the "normal" place.
        //  Otherwise, if the read is within the part of the Mft mirrored in Mft2,
        //  then we will simply try to read the data from Mft2.  If the expected
        //  status came from a read not within Mft2, then we will also continue,
        //  which cause one of our caller's try-except's to initiate an unwind.
        //

        } except (NtfsReadMftExceptionFilter( IrpContext, GetExceptionInformation(), *Bcb, FileOffset )) {

            NtfsMinimumExceptionProcessing( IrpContext );
            ErrorPath = TRUE;
        }

        if (ErrorPath) {

            //
            //  Try to read from Mft2.  If this fails with an expected status,
            //  then we are just going to have to give up and let the unwind
            //  occur from one of our caller's try-except.
            //

            NtfsMapStream( IrpContext,
                           Vcb->Mft2Scb,
                           FileOffset,
                           Vcb->BytesPerFileRecordSegment,
                           &Bcb2,
                           (PVOID *)&FileRecord2 );

            //
            //  Pin the original page because we are going to update it.
            //

            NtfsPinMappedData( IrpContext,
                               Vcb->MftScb,
                               FileOffset,
                               Vcb->BytesPerFileRecordSegment,
                               Bcb );

            //
            //  Now copy the entire page.
            //

            RtlCopyMemory( *FileRecord,
                           FileRecord2,
                           Vcb->BytesPerFileRecordSegment );

            //
            //  Set it dirty with the largest Lsn, so that whoever is doing Restart
            //  will successfully establish the "oldest unapplied Lsn".
            //

            LlTemp1 = MAXLONGLONG;

            CcSetDirtyPinnedData( *Bcb,
                                  (PLARGE_INTEGER)&LlTemp1 );


            NtfsUnpinBcb( IrpContext, &Bcb2 );
        }

        //
        //  Do a consistency check
        //

        if ( CheckRecord && FlagOn((*FileRecord)->Flags, FILE_RECORD_SEGMENT_IN_USE ) ) {
            if (!NtfsCheckFileRecord( Vcb, *FileRecord, SegmentReference, &CorruptHint )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, SegmentReference, NULL );
            }
        }

    } finally {

        if (AbnormalTermination()) {

            NtfsUnpinBcb( IrpContext, Bcb );
            NtfsUnpinBcb( IrpContext, &Bcb2 );
        }
    }

    //
    //  Now that we've pinned a file record, cache it in the IrpContext so that
    //  it can be safely retrieved later without the expense of mapping again.
    //  Don't do any caching if there are no handles, we don't want to do this for
    //  mount.
    //

    if (Vcb->CleanupCount != 0) {

        NtfsAddToFileRecordCache( IrpContext,
                                  NtfsSegmentNumber( SegmentReference ),
                                  *Bcb,
                                  *FileRecord );
    }

    DebugTrace( 0, Dbg, ("Bcb > %08lx\n", Bcb) );
    DebugTrace( 0, Dbg, ("FileRecord > %08lx\n", *FileRecord) );
    DebugTrace( -1, Dbg, ("NtfsReadMftRecord -> VOID\n") );

    return;
}


VOID
NtfsPinMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN PreparingToWrite,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    )

/*++

Routine Description:

    This routine pins the specified Mft record from the Mft, without checking
    sequence numbers.  This routine may be used to pin records in the Mft for
    a file other than its base file record, or it could conceivably be used for
    extraordinary maintenance functions, such as during restart.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    SegmentReference - File reference, including sequence number, of the file
                       record to be read.

    PreparingToWrite - TRUE if caller is preparing to write, and does not care
                       about whether the record read correctly

    Bcb - Returns the Bcb for the file record.  This Bcb is mapped, not pinned.

    FileRecord - Returns a pointer to the requested file record.

    MftFileOffset - If specified, returns the file offset of the file record.

Return Value:

    None

--*/

{
    LONGLONG FileOffset;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPinMftRecord\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );
    DebugTrace( 0, Dbg, ("SegmentReference = %08lx\n", NtfsSegmentNumber( SegmentReference )) );

    //
    //  Capture the Segment Reference and make sure the Sequence Number is 0.
    //

    FileOffset = NtfsFullSegmentNumber( SegmentReference );

    //
    //  Calculate the file offset in the Mft to the file record segment.
    //

    FileOffset = LlBytesFromFileRecords( Vcb, FileOffset );

    //
    //  Pass back the file offset within the Mft.
    //

    if (ARGUMENT_PRESENT( MftFileOffset )) {

        *MftFileOffset = FileOffset;
    }

    //
    //  Try to read it from the normal Mft.
    //

    try {

        NtfsPinStream( IrpContext,
                       Vcb->MftScb,
                       FileOffset,
                       Vcb->BytesPerFileRecordSegment,
                       Bcb,
                       (PVOID *)FileRecord );

    //
    //  If we get an exception that is not expected, then we will allow
    //  the search to continue and let the crash occur in the "normal" place.
    //  Otherwise, if the read is within the part of the Mft mirrored in Mft2,
    //  then we will simply try to read the data from Mft2.  If the expected
    //  status came from a read not within Mft2, then we will also continue,
    //  which cause one of our caller's try-except's to initiate an unwind.
    //

    } except(!FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                        EXCEPTION_CONTINUE_SEARCH :
                        ( FileOffset < Vcb->Mft2Scb->Header.FileSize.QuadPart ) ?
                            EXCEPTION_EXECUTE_HANDLER :
                            EXCEPTION_CONTINUE_SEARCH ) {

        //
        //  Try to read from Mft2.  If this fails with an expected status,
        //  then we are just going to have to give up and let the unwind
        //  occur from one of our caller's try-except.
        //

        NtfsMinimumExceptionProcessing( IrpContext );
        NtfsPinStream( IrpContext,
                       Vcb->Mft2Scb,
                       FileOffset,
                       Vcb->BytesPerFileRecordSegment,
                       Bcb,
                       (PVOID *)FileRecord );

    }

    if (!PreparingToWrite &&
        (*(PULONG)(*FileRecord)->MultiSectorHeader.Signature != *(PULONG)FileSignature)) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, SegmentReference, NULL );
    }

    //
    //  Now that we've pinned a file record, cache it in the IrpContext so that
    //  it can be safely retrieved later without the expense of mapping again.
    //  Don't do any caching if there are no handles, we don't want to do this for
    //  mount.
    //

    if (Vcb->CleanupCount != 0) {

        NtfsAddToFileRecordCache( IrpContext,
                                  NtfsSegmentNumber( SegmentReference ),
                                  *Bcb,
                                  *FileRecord );
    }

    DebugTrace( 0, Dbg, ("Bcb > %08lx\n", Bcb) );
    DebugTrace( 0, Dbg, ("FileRecord > %08lx\n", *FileRecord) );
    DebugTrace( -1, Dbg, ("NtfsPinMftRecord -> VOID\n") );

    return;
}


MFT_SEGMENT_REFERENCE
NtfsAllocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MftData
    )

/*++

Routine Description:

    This routine is called to allocate a record in the Mft file.  We need
    to find the bitmap attribute for the Mft file and call into the bitmap
    package to allocate us a record.

Arguments:

    Vcb - Vcb for volume on which Mft is to be read

    MftData - TRUE if the file record is being allocated to describe the
              $DATA attribute for the Mft.

Return Value:

    MFT_SEGMENT_REFERENCE - The is the segment reference for the allocated
        record.  It contains the file reference number but without
        the previous sequence number.

--*/

{
    MFT_SEGMENT_REFERENCE NewMftRecord;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN FoundAttribute;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateMftRecord:  Entered\n") );

    //
    //  Synchronize the lookup by acquiring the Mft.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );

    //
    //  Lookup the bitmap allocation for the Mft file.  This is the
    //  bitmap attribute for the Mft file.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try finally to cleanup the attribute context.
    //

    try {

        //
        //  Lookup the bitmap attribute for the Mft.
        //

        FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                    Vcb->MftScb->Fcb,
                                                    &Vcb->MftScb->Fcb->FileReference,
                                                    $BITMAP,
                                                    &AttrContext );
        //
        //  Error if we don't find the bitmap
        //

        if (!FoundAttribute) {

            DebugTrace( 0, Dbg, ("Should find bitmap attribute\n") );

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  Reserve a new mft record if necc.
        //

        if (!FlagOn(Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED)) {

            (VOID)NtfsReserveMftRecord( IrpContext,
                                        Vcb,
                                        &AttrContext );
        }

        //
        //  If we need this record for the Mft Data attribute, then we need to
        //  use the one we have already reserved, and then remember there is'nt
        //  one reserved anymore.
        //

        if (MftData) {

            ASSERT( FlagOn(Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED) );

            NtfsSetSegmentNumber( &NewMftRecord,
                                  0,
                                  NtfsAllocateMftReservedRecord( IrpContext,
                                                                 Vcb,
                                                                 &AttrContext ) );

            //
            //  Never let use get file record zero for this or we could lose a
            //  disk.
            //

            ASSERT( NtfsUnsafeSegmentNumber( &NewMftRecord ) != 0 );

            if (NtfsUnsafeSegmentNumber( &NewMftRecord ) == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

        //
        //  Allocate the record.
        //

        } else {

            NtfsSetSegmentNumber( &NewMftRecord,
                                  0,
                                  NtfsAllocateRecord( IrpContext,
                                                      &Vcb->MftScb->ScbType.Index.RecordAllocationContext,
                                                      &AttrContext ) );
        }

        NtfsReleaseScb( IrpContext, Vcb->MftScb );

    } finally {

        DebugUnwind( NtfsAllocateMftRecord );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        DebugTrace( -1, Dbg, ("NtfsAllocateMftRecord:  Exit\n") );
    }

    return NewMftRecord;
}


VOID
NtfsInitializeMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PMFT_SEGMENT_REFERENCE MftSegment,
    IN OUT PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB Bcb,
    IN BOOLEAN Directory
    )

/*++

Routine Description:

    This routine initializes a Mft record for use.  We need to initialize the
    sequence number for this usage of the the record.  We also initialize the
    update sequence array and the field which indicates the first usable
    attribute offset in the record.

Arguments:

    Vcb - Vcb for volume for the Mft.

    MftSegment - This is a pointer to the file reference for this
        segment.  We store the sequence number in it to make this
        a fully valid file reference.

    FileRecord - Pointer to the file record to initialize.

    Bcb - Bcb to use to set this page dirty via NtfsWriteLog.

    Directory - Boolean indicating if this file is a directory containing
        an index over the filename attribute.

Return Value:

    None.

--*/

{
    LONGLONG FileRecordOffset;

    PUSHORT UsaSequenceNumber;

    PATTRIBUTE_RECORD_HEADER AttributeHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeMftRecord:  Entered\n") );

    //
    //  Write a log record to uninitialize the structure in case we abort.
    //  We need to do this prior to setting the IN_USE bit.
    //  We don't store the Lsn for this operation in the page because there
    //  is no redo operation.
    //

    //
    //  Capture the Segment Reference and make sure the Sequence Number is 0.
    //

    FileRecordOffset = NtfsFullSegmentNumber(MftSegment);

    FileRecordOffset = LlBytesFromFileRecords( Vcb, FileRecordOffset );

    //
    //  We now log the new Mft record.
    //

    FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                    Vcb->MftScb,
                                    Bcb,
                                    Noop,
                                    NULL,
                                    0,
                                    DeallocateFileRecordSegment,
                                    NULL,
                                    0,
                                    FileRecordOffset,
                                    0,
                                    0,
                                    Vcb->BytesPerFileRecordSegment );

    RtlZeroMemory( &FileRecord->ReferenceCount,
                   Vcb->BytesPerFileRecordSegment - FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER, ReferenceCount ));

    //
    //  First we update the sequence count in the file record and our
    //  Mft segment.  We avoid using 0 as a sequence number.
    //

    if (FileRecord->SequenceNumber == 0) {

        FileRecord->SequenceNumber = 1;
    }

    //
    //  Store the new sequence number in the Mft segment given us by the
    //  caller.
    //

    MftSegment->SequenceNumber = FileRecord->SequenceNumber;

#if (DBG || defined( NTFS_FREE_ASSERTS ))

    //
    //  Do a DBG-only sanity check to see if we're errorneously reusing this file reference.
    //

    NtfsVerifyFileReference( IrpContext, MftSegment );

#endif

    //
    //  Fill in the header for the Update sequence array.
    //

    *(PULONG)FileRecord->MultiSectorHeader.Signature = *(PULONG)FileSignature;

    FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset = FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly );
    FileRecord->MultiSectorHeader.UpdateSequenceArraySize = (USHORT)UpdateSequenceArraySize( Vcb->BytesPerFileRecordSegment );

    //
    //  We initialize the update sequence array sequence number to one.
    //

    UsaSequenceNumber = Add2Ptr( FileRecord, FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset );
    *UsaSequenceNumber = 1;

    //
    //  The first attribute offset begins on a quad-align boundary
    //  after the update sequence array.
    //

    FileRecord->FirstAttributeOffset = (USHORT)(FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset
                                                + (FileRecord->MultiSectorHeader.UpdateSequenceArraySize
                                                * sizeof( UPDATE_SEQUENCE_NUMBER )));

    FileRecord->FirstAttributeOffset = (USHORT)QuadAlign( FileRecord->FirstAttributeOffset );

    //
    //  This is also the first free byte in this file record.
    //

    FileRecord->FirstFreeByte = FileRecord->FirstAttributeOffset;

    //
    //  We set the flags to show the segment is in use and look at
    //  the directory parameter to indicate whether to show
    //  the name index present.
    //

    FileRecord->Flags = (USHORT)(FILE_RECORD_SEGMENT_IN_USE |
                                 (Directory ? FILE_FILE_NAME_INDEX_PRESENT : 0));

    //
    //  The size is given in the Vcb.
    //

    FileRecord->BytesAvailable = Vcb->BytesPerFileRecordSegment;

    //
    //  The current FRS number.
    //

    FileRecord->SegmentNumberHighPart = MftSegment->SegmentNumberHighPart;
    FileRecord->SegmentNumberLowPart = MftSegment->SegmentNumberLowPart;

    //
    //  Now we put an $END attribute in the File record.
    //

    AttributeHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord,
                                                          FileRecord->FirstFreeByte );

    FileRecord->FirstFreeByte += QuadAlign( sizeof(ATTRIBUTE_TYPE_CODE) );

    //
    //  Fill in the fields in the attribute.
    //

    AttributeHeader->TypeCode = $END;

    //
    //  Remember if this is the first time used.
    //

    AttributeHeader->RecordLength = 0x11477982;

    DebugTrace( -1, Dbg, ("NtfsInitializeMftRecord:  Exit\n") );

    return;
}


VOID
NtfsDeallocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FileNumber
    )

/*++

Routine Description:

    This routine will cause an Mft record to go into the NOT_USED state.
    We pin the record and modify the sequence count and IN USE bit.

Arguments:

    Vcb - Vcb for volume.

    FileNumber - This is the low 32 bits for the file number.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG FileOffset;
    MFT_SEGMENT_REFERENCE Reference;
    PBCB MftBcb = NULL;

    BOOLEAN FoundAttribute;
    BOOLEAN AcquiredMft = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeallocateMftRecord:  Entered\n") );

    NtfsSetSegmentNumber( &Reference, 0, FileNumber );
    Reference.SequenceNumber = 0;

    //
    //  Lookup the bitmap allocation for the Mft file.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try finally to cleanup the attribute context.
    //

    try {

        NtfsPinMftRecord( IrpContext,
                          Vcb,
                          &Reference,
                          TRUE,
                          &MftBcb,
                          &FileRecord,
                          &FileOffset );

        //
        //  Log changes if the file is currently in use
        //

        if (FlagOn(FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE)) {

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            Vcb->MftScb,
                                            MftBcb,
                                            DeallocateFileRecordSegment,
                                            NULL,
                                            0,
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            PtrOffset(FileRecord, &FileRecord->Flags) + 4,
                                            FileOffset,
                                            0,
                                            0,
                                            Vcb->BytesPerFileRecordSegment );

            //
            //  We increment the sequence count in the file record and clear
            //  the In-Use flag.
            //

            ClearFlag( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE );

            FileRecord->SequenceNumber += 1;

            NtfsUnpinBcb( IrpContext, &MftBcb );
        }

        //
        //  Synchronize the lookup by acquiring the Mft.
        //

        NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
        AcquiredMft = TRUE;

        //
        //  Lookup the bitmap attribute for the Mft.
        //

        FoundAttribute = NtfsLookupAttributeByCode( IrpContext,
                                                    Vcb->MftScb->Fcb,
                                                    &Vcb->MftScb->Fcb->FileReference,
                                                    $BITMAP,
                                                    &AttrContext );
        //
        //  Error if we don't find the bitmap
        //

        if (!FoundAttribute) {

            DebugTrace( 0, Dbg, ("Should find bitmap attribute\n") );

            NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
        }

        NtfsDeallocateRecord( IrpContext,
                              &Vcb->MftScb->ScbType.Index.RecordAllocationContext,
                              FileNumber,
                              &AttrContext );

        //
        //  If this file number is less than our reserved index then clear
        //  the reserved index.
        //

        if (FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED ) && 
            (FileNumber < Vcb->MftScb->ScbType.Mft.ReservedIndex)) {

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
            ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );

            Vcb->MftScb->ScbType.Mft.ReservedIndex = 0;
        }

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        Vcb->MftFreeRecords += 1;
        Vcb->MftScb->ScbType.Mft.FreeRecordChange += 1;

        if (AcquiredMft) {
            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }

    } finally {

        DebugUnwind( NtfsDeallocateMftRecord );

        NtfsUnpinBcb( IrpContext, &MftBcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsDeallocateMftRecord:  Exit\n") );
    }
}


BOOLEAN
NtfsIsMftIndexInHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index,
    OUT PULONG HoleLength OPTIONAL
    )

/*++

Routine Description:

    This routine is called to check if an Mft index lies within a hole in
    the Mft.

Arguments:

    Vcb - Vcb for volume.

    Index - This is the index to test.  It is the lower 32 bits of an
        Mft segment.

    HoleLength - This is the length of the hole starting at this index.

Return Value:

    BOOLEAN - TRUE if the index is within the Mft and there is no allocation
        for it.

--*/

{
    BOOLEAN InHole = FALSE;
    VCN Vcn;
    LCN Lcn;
    LONGLONG Clusters;

    PAGED_CODE();

    //
    //  If the index is past the last file record then it is not considered
    //  to be in a hole.
    //

    if (Index < (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart )) {

        if (Vcb->FileRecordsPerCluster == 0) {

            Vcn = Index << Vcb->MftToClusterShift;

        } else {

            Vcn = Index >> Vcb->MftToClusterShift;
        }

        //
        //  Now look this up the Mcb for the Mft.  This Vcn had better be
        //  in the Mcb or there is some problem.
        //

        if (!NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                     Vcn,
                                     &Lcn,
                                     &Clusters,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL )) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext,
                             STATUS_FILE_CORRUPT_ERROR,
                             NULL,
                             Vcb->MftScb->Fcb );
        }

        if (Lcn == UNUSED_LCN) {

            InHole = TRUE;

            //
            //  We know the number of clusters beginning from
            //  this point in the Mcb.  Convert to file records
            //  and return to the user.
            //

            if (ARGUMENT_PRESENT( HoleLength )) {

                if (Vcb->FileRecordsPerCluster == 0) {

                    *HoleLength = ((ULONG)Clusters) >> Vcb->MftToClusterShift;

                } else {

                    *HoleLength = ((ULONG)Clusters) << Vcb->MftToClusterShift;
                }
            }
        }
    }

    return InHole;
}


VOID
NtfsFillMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine is called to fill in a hole within the Mft.  We will find
    the beginning of the hole and then allocate the clusters to fill the
    hole.  We will try to fill a hole with the HoleGranularity in the Vcb.
    If the hole containing this index is not that large we will truncate
    the size being added.  We always guarantee to allocate the clusters on
    file record boundaries.

Arguments:

    Vcb - Vcb for volume.

    Index - This is the index to test.  It is the lower 32 bits of an
        Mft segment.

Return Value:

    None.

--*/

{
    ULONG FileRecords;
    ULONG BaseIndex;

    VCN IndexVcn;
    VCN HoleStartVcn;
    VCN StartingVcn;

    LCN Lcn = UNUSED_LCN;
    LONGLONG ClusterCount;
    LONGLONG RunClusterCount;

    PAGED_CODE();

    //
    //  Convert the Index to a Vcn in the file.  Find the cluster that would
    //  be the start of this hole if the hole is fully deallocated.
    //

    if (Vcb->FileRecordsPerCluster == 0) {

        IndexVcn = Index << Vcb->MftToClusterShift;
        HoleStartVcn = (Index & Vcb->MftHoleInverseMask) << Vcb->MftToClusterShift;

    } else {

        IndexVcn = Index >> Vcb->MftToClusterShift;
        HoleStartVcn = (Index & Vcb->MftHoleInverseMask) >> Vcb->MftToClusterShift;
    }

    //
    //  Lookup the run containing this index.
    //

    NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                            IndexVcn,
                            &Lcn,
                            &ClusterCount,
                            NULL,
                            &RunClusterCount,
                            NULL,
                            NULL );

    //
    //  This had better be a hole.
    //

    if (Lcn != UNUSED_LCN) {

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
    }

    //
    //  Take the start of the deallocated space and round up to a hole boundary.
    //

    StartingVcn = IndexVcn - (RunClusterCount - ClusterCount);

    if (StartingVcn <= HoleStartVcn) {

        StartingVcn = HoleStartVcn;
        RunClusterCount -= (HoleStartVcn - StartingVcn);
        StartingVcn = HoleStartVcn;

    //
    //  We can go to the beginning of a hole.  Just use the Vcn for the file
    //  record we want to reallocate.
    //

    } else {

        RunClusterCount = ClusterCount;
        StartingVcn = IndexVcn;
    }

    //
    //  Trim the cluster count back to a hole if necessary.
    //

    if ((ULONG) RunClusterCount >= Vcb->MftClustersPerHole) {

        RunClusterCount = Vcb->MftClustersPerHole;

    //
    //  We don't have enough clusters for a full hole.  Make sure
    //  we end on a file record boundary however.  We must end up
    //  with enough clusters for the file record we are reallocating.
    //

    } else if (Vcb->FileRecordsPerCluster == 0) {

        ((PLARGE_INTEGER) &ClusterCount)->LowPart &= (Vcb->ClustersPerFileRecordSegment - 1);

        if (StartingVcn + ClusterCount < IndexVcn + Vcb->ClustersPerFileRecordSegment) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
        }
    }

    //
    //  Now attempt to allocate the space.
    //

    NtfsAddAllocation( IrpContext,
                       Vcb->MftScb->FileObject,
                       Vcb->MftScb,
                       StartingVcn,
                       ClusterCount,
                       FALSE,
                       NULL );

    //
    //  Compute the number of file records reallocated and then
    //  initialize and deallocate each file record.
    //

    if (Vcb->FileRecordsPerCluster == 0) {

        FileRecords = (ULONG) ClusterCount >> Vcb->MftToClusterShift;
        BaseIndex = (ULONG) StartingVcn >> Vcb->MftToClusterShift;

    } else {

        FileRecords = (ULONG) ClusterCount << Vcb->MftToClusterShift;
        BaseIndex = (ULONG) StartingVcn << Vcb->MftToClusterShift;
    }

    NtfsInitializeMftHoleRecords( IrpContext,
                                  Vcb,
                                  BaseIndex,
                                  FileRecords );

    Vcb->MftHoleRecords -= FileRecords;
    Vcb->MftScb->ScbType.Mft.HoleRecordChange -= FileRecords;

    return;
}


VOID
NtfsLogMftFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN LONGLONG MftOffset,
    IN PBCB Bcb,
    IN BOOLEAN Redo
    )

/*++

Routine Description:

    This routine is called to log changes to the file record for the Mft
    file.  We log the entire record instead of individual changes so
    that we can recover the data even if there is a USA error.  The entire
    data will be sitting in the Log file.

Arguments:

    Vcb - This is the Vcb for the volume being logged.

    FileRecord - This is the file record being logged.

    MftOffset - This is the offset of this file record in the Mft stream.

    Bcb - This is the Bcb for the pinned file record.

    RedoOperation - Boolean indicating if we are logging
        a redo or undo operation.

Return Value:

    None.

--*/

{
    PVOID RedoBuffer;
    NTFS_LOG_OPERATION RedoOperation;
    ULONG RedoLength;

    PVOID UndoBuffer;
    NTFS_LOG_OPERATION UndoOperation;
    ULONG UndoLength;

    PAGED_CODE();

    //
    //  Find the logging values based on whether this is an
    //  undo or redo.
    //

    if (Redo) {

        RedoBuffer = FileRecord;
        RedoOperation = InitializeFileRecordSegment;
        RedoLength = FileRecord->FirstFreeByte;

        UndoBuffer = NULL;
        UndoOperation = Noop;
        UndoLength = 0;

    } else {

        UndoBuffer = FileRecord;
        UndoOperation = InitializeFileRecordSegment;
        UndoLength = FileRecord->FirstFreeByte;

        RedoBuffer = NULL;
        RedoOperation = Noop;
        RedoLength = 0;
    }

    //
    //  Now that we have calculated all the values, call the logging
    //  routine.
    //

    NtfsWriteLog( IrpContext,
                  Vcb->MftScb,
                  Bcb,
                  RedoOperation,
                  RedoBuffer,
                  RedoLength,
                  UndoOperation,
                  UndoBuffer,
                  UndoLength,
                  MftOffset,
                  0,
                  0,
                  Vcb->BytesPerFileRecordSegment );

    return;
}


BOOLEAN
NtfsDefragMft (
    IN PDEFRAG_MFT DefragMft
    )

/*++

Routine Description:

    This routine is called whenever we have detected that the Mft is in a state
    where defragging is desired.

Arguments:

    DefragMft - This is the defrag structure.

Return Value:

    BOOLEAN - TRUE if we took some defrag step, FALSE otherwise.

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    PVCB Vcb;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN DefragStepTaken = FALSE;

    DebugTrace( +1, Dbg, ("NtfsDefragMft:  Entered\n") );

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, FALSE );
    ASSERT( ThreadTopLevelContext == &TopLevelContext );

    Vcb = DefragMft->Vcb;

    //
    //  Use a try-except to catch errors here.
    //

    try {

        //
        //  Deallocate the defrag structure we were called with.
        //

        if (DefragMft->DeallocateWorkItem) {

            NtfsFreePool( DefragMft );
        }

        //
        //  Create the Irp context.  We will use all of the transaction support
        //  contained in a normal IrpContext.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        IrpContext->Vcb = Vcb;

        NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED )
            && FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            DefragStepTaken = NtfsDefragMftPriv( IrpContext,
                                                 Vcb );
        } else {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation())) {

        NtfsProcessException( IrpContext, NULL, GetExceptionCode() );

        //
        //  If the exception code was not LOG_FILE_FULL then
        //  disable defragging.
        //

        if (GetExceptionCode() != STATUS_LOG_FILE_FULL) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        DefragStepTaken = FALSE;
    }

    NtfsAcquireCheckpoint( IrpContext, Vcb );
    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE );
    NtfsReleaseCheckpoint( IrpContext, Vcb );

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    DebugTrace( -1, Dbg, ("NtfsDefragMft:  Exit\n") );

    return DefragStepTaken;
}


VOID
NtfsCheckForDefrag (
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to check whether there is any defrag work to do
    involving freeing file records and creating holes in the Mft.  It
    will modify the TRIGGERED flag in the Vcb if there is still work to
    do.

Arguments:

    Vcb - This is the Vcb for the volume to defrag.

Return Value:

    None.

--*/

{
    LONGLONG RecordsToClusters;
    LONGLONG AdjClusters;

    PAGED_CODE();

    //
    //  Convert the available Mft records to clusters.
    //

    if (Vcb->FileRecordsPerCluster) {

        RecordsToClusters = Int64ShllMod32(((LONGLONG)(Vcb->MftFreeRecords - Vcb->MftHoleRecords)),
                                           Vcb->MftToClusterShift);

    } else {

        RecordsToClusters = Int64ShraMod32(((LONGLONG)(Vcb->MftFreeRecords - Vcb->MftHoleRecords)),
                                           Vcb->MftToClusterShift);
    }

    //
    //  If we have already triggered the defrag then check if we are below
    //  the lower threshold.
    //

    if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

        AdjClusters = Vcb->FreeClusters >> MFT_DEFRAG_LOWER_THRESHOLD;

        if (AdjClusters >= RecordsToClusters) {

            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED );
        }

    //
    //  Otherwise check if we have exceeded the upper threshold.
    //

    } else {

        AdjClusters = Vcb->FreeClusters >> MFT_DEFRAG_UPPER_THRESHOLD;

        if (AdjClusters < RecordsToClusters) {

            SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED );
        }
    }

    return;
}


VOID
NtfsInitializeMftHoleRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FirstIndex,
    IN ULONG RecordCount
    )

/*++

Routine Description:

    This routine is called to initialize the file records created when filling
    a hole in the Mft.

Arguments:

    Vcb - Vcb for volume.

    FirstIndex - Index for the start of the hole to fill.

    RecordCount - Count of file records in the hole.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Loop to initialize each file record.
        //

        while (RecordCount--) {

            PUSHORT UsaSequenceNumber;
            PMULTI_SECTOR_HEADER UsaHeader;

            MFT_SEGMENT_REFERENCE ThisMftSegment;
            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            PATTRIBUTE_RECORD_HEADER AttributeHeader;

            //
            //  Convert the index to a segment reference.
            //

            *((PLONGLONG)&ThisMftSegment) = FirstIndex;

            //
            //  Pin the file record to initialize.
            //

            NtfsPinMftRecord( IrpContext,
                              Vcb,
                              &ThisMftSegment,
                              TRUE,
                              &Bcb,
                              &FileRecord,
                              NULL );

            //
            //  Initialize the file record including clearing the in-use
            //  bit.
            //

            RtlZeroMemory( FileRecord, Vcb->BytesPerFileRecordSegment );

            //
            //  Fill in the header for the Update sequence array.
            //

            UsaHeader = (PMULTI_SECTOR_HEADER) FileRecord;

            *(PULONG)UsaHeader->Signature = *(PULONG)FileSignature;

            UsaHeader->UpdateSequenceArrayOffset = FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER,
                                                                 UpdateArrayForCreateOnly );
            UsaHeader->UpdateSequenceArraySize = (USHORT)UpdateSequenceArraySize( Vcb->BytesPerFileRecordSegment );

            //
            //  We initialize the update sequence array sequence number to one.
            //

            UsaSequenceNumber = Add2Ptr( FileRecord, UsaHeader->UpdateSequenceArrayOffset );
            *UsaSequenceNumber = 1;

            //
            //  The first attribute offset begins on a quad-align boundary
            //  after the update sequence array.
            //

            FileRecord->FirstAttributeOffset = (USHORT)(UsaHeader->UpdateSequenceArrayOffset
                                                        + (UsaHeader->UpdateSequenceArraySize
                                                           * sizeof( UPDATE_SEQUENCE_NUMBER )));

            FileRecord->FirstAttributeOffset = (USHORT)QuadAlign( FileRecord->FirstAttributeOffset );

            //
            //  The size is given in the Vcb.
            //

            FileRecord->BytesAvailable = Vcb->BytesPerFileRecordSegment;

            //
            //  Now we put an $END attribute in the File record.
            //

            AttributeHeader = (PATTRIBUTE_RECORD_HEADER) Add2Ptr( FileRecord,
                                                                  FileRecord->FirstAttributeOffset );

            //
            //  The first free byte is after this location.
            //

            FileRecord->FirstFreeByte = QuadAlign( FileRecord->FirstAttributeOffset
                                                   + sizeof( ATTRIBUTE_TYPE_CODE ));

            //
            //  Fill in the fields in the attribute.
            //

            AttributeHeader->TypeCode = $END;

            //
            //  The current FRS number.
            //

            FileRecord->SegmentNumberHighPart = ThisMftSegment.SegmentNumberHighPart;
            FileRecord->SegmentNumberLowPart = ThisMftSegment.SegmentNumberLowPart;

            //
            //  Log the entire file record.
            //

            NtfsLogMftFileRecord( IrpContext,
                                  Vcb,
                                  FileRecord,
                                  LlBytesFromFileRecords( Vcb, FirstIndex ),
                                  Bcb,
                                  TRUE );

            NtfsUnpinBcb( IrpContext, &Bcb );

            //
            //  Move to the next record.
            //

            FirstIndex += 1;
        }

    } finally {

        DebugUnwind( NtfsInitializeMftHoleRecords );

        NtfsUnpinBcb( IrpContext, &Bcb );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsTruncateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to perform the work of truncating the Mft.  If will
    truncate the Mft and adjust the sizes of the Mft and Mft bitmap.

Arguments:

    Vcb - This is the Vcb for the volume to defrag.

Return Value:

    BOOLEAN - TRUE if we could deallocate any disk space, FALSE otherwise.

--*/

{
    PVOID RangePtr;
    ULONG Index;
    VCN StartingVcn;
    VCN NextVcn;
    LCN NextLcn;
    LONGLONG ClusterCount;
    LONGLONG FileOffset;

    ULONG FreeRecordChange;
    IO_STATUS_BLOCK IoStatus;

    PAGED_CODE();

    //
    //  Try to find a range of file records at the end of the file which can
    //  be deallocated.
    //

    if (!NtfsFindMftFreeTail( IrpContext, Vcb, &FileOffset )) {

        return FALSE;
    }

    FreeRecordChange = (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart - FileOffset );

    Vcb->MftFreeRecords -= FreeRecordChange;
    Vcb->MftScb->ScbType.Mft.FreeRecordChange -= FreeRecordChange;

    //
    //  Now we want to figure out how many holes we may be removing from the Mft.
    //  Walk through the Mcb and count the holes.
    //

    StartingVcn = LlClustersFromBytes( Vcb, FileOffset );

    NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                            StartingVcn,
                            &NextLcn,
                            &ClusterCount,
                            NULL,
                            NULL,
                            &RangePtr,
                            &Index );

    do {

        //
        //  If this is a hole then update the hole count in the Vcb and
        //  hole change count in the MftScb.
        //

        if (NextLcn == UNUSED_LCN) {

            ULONG HoleChange;

            if (Vcb->FileRecordsPerCluster == 0) {

                HoleChange = ((ULONG)ClusterCount) >> Vcb->MftToClusterShift;

            } else {

                HoleChange = ((ULONG)ClusterCount) << Vcb->MftToClusterShift;
            }

            Vcb->MftHoleRecords -= HoleChange;
            Vcb->MftScb->ScbType.Mft.HoleRecordChange -= HoleChange;
        }

        Index += 1;

    } while (NtfsGetSequentialMcbEntry( &Vcb->MftScb->Mcb,
                                        &RangePtr,
                                        Index,
                                        &NextVcn,
                                        &NextLcn,
                                        &ClusterCount ));

    //
    //  We want to flush the data in the Mft out to disk in
    //  case a lazywrite comes in during a window where we have
    //  removed the allocation but before a possible abort.
    //

    CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                  (PLARGE_INTEGER)&FileOffset,
                  BytesFromFileRecords( Vcb, FreeRecordChange ),
                  &IoStatus );

    ASSERT( IoStatus.Status == STATUS_SUCCESS );

    //
    //  Now do the truncation.
    //

    NtfsDeleteAllocation( IrpContext,
                          Vcb->MftScb->FileObject,
                          Vcb->MftScb,
                          StartingVcn,
                          MAXLONGLONG,
                          TRUE,
                          FALSE );

    return TRUE;
}

NTSTATUS
NtfsIterateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PFILE_REFERENCE FileReference,
    IN FILE_RECORD_WALK FileRecordFunction,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine interates over the MFT.  It calls the FileRecordFunction
    with an Fcb for each existing file on the volume.  The Fcb is owned
    exclusive and Vcb is owned shared.  The starting FileReference number
    is passed in so that iterate can be restarted where is left off.

Arguments:

    Vcb - Pointer to the volume to control for the MFT

    FileReference - Suplies a pointer to the starting file reference number
                    This value is updated as the interator progresses.

    FileRecordFunction - Suplies a pointer to function to be called with
                          each file found in the MFT.

    Context - Passed along to the FileRecordFunction.

Return Value:

    Returns back status of the entire operation.

--*/

{

    ULONG LogFileFullCount = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PFCB CurrentFcb = NULL;
    BOOLEAN DecrementReferenceCount = FALSE;
    KEVENT Event;
    LARGE_INTEGER Timeout;

    PAGED_CODE();

    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );
    Timeout.QuadPart = 0;

    while (TRUE) {

        FsRtlExitFileSystem();

        //
        //  Check for APC delivery indicating thread death or cancel
        //

        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        UserMode,
                                        FALSE,
                                        &Timeout );
        FsRtlEnterFileSystem();

        if (STATUS_TIMEOUT == Status) {
            Status = STATUS_SUCCESS;
        } else {
            break;
        }

        //
        //  If irp has been cancelled break out
        //

        if (IrpContext->OriginatingIrp && IrpContext->OriginatingIrp->Cancel) {

#ifdef BENL_DBG
            KdPrint(( "Ntfs: cancelled mft iteration irp: 0x%x\n", IrpContext->OriginatingIrp ));
#endif
            Status = STATUS_CANCELLED;
            break;
        }


        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

        try {

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            //
            //  Set the irp context flags to indicate that we are in the
            //  fsp and that the irp context should not be deleted when
            //  complete request or process exception are called. The in
            //  fsp flag keeps us from raising in a few places.  These
            //  flags must be set inside the loop since they are cleared
            //  under certain conditions.
            //

            SetFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP);

            DecrementReferenceCount = TRUE;

            Status = NtfsTryOpenFcb( IrpContext,
                                     Vcb,
                                     &CurrentFcb,
                                     *FileReference );

            if (!NT_SUCCESS( Status )) {
                leave;
            }

            //
            //  Call the worker function.
            //

            Status = FileRecordFunction( IrpContext, CurrentFcb, Context );

            if (!NT_SUCCESS( Status )) {
                leave;
            }

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );

            NtfsAcquireFcbTable( IrpContext, Vcb );
            ASSERT(CurrentFcb->ReferenceCount > 0);
            CurrentFcb->ReferenceCount--;
            NtfsReleaseFcbTable( IrpContext, Vcb );
            DecrementReferenceCount = FALSE;
            NtfsTeardownStructures( IrpContext,
                                    CurrentFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );

        } finally {

            if (CurrentFcb != NULL) {

                if (DecrementReferenceCount) {


                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    ASSERT(CurrentFcb->ReferenceCount > 0);
                    CurrentFcb->ReferenceCount--;
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    DecrementReferenceCount = FALSE;
                }

                CurrentFcb = NULL;
            }

            //
            //  Make sure to release any maps in the cached file records in
            //  the Irp Context.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        //
        //  If a status of not found was return then just continue to
        //  the next file record.
        //

        if (Status == STATUS_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS( Status )) {
            break;
        }

        //
        //  Release resources
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

        //
        //  Advance to the next file record.
        //

        (*((LONGLONG UNALIGNED *) FileReference))++;
    }

    return Status;
}


//
//  Local support routine.
//

BOOLEAN
NtfsDefragMftPriv (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This is the main worker routine which performs the Mft defragging.  This routine
    will defrag according to the following priorities.  First try to deallocate the
    tail of the file.  Second rewrite the mapping for the file if necessary.  Finally
    try to find a range of the Mft that we can turn into a hole.  We will only do
    the first and third if we are trying to reclaim disk space.  The second we will
    do to try and keep us from getting into trouble while modify Mft records which
    describe the Mft itself.

Arguments:

    Vcb - This is the Vcb for the volume being defragged.

Return Value:

    BOOLEAN - TRUE if a defrag operation was successfully done, FALSE otherwise.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN CleanupAttributeContext = FALSE;
    BOOLEAN DefragStepTaken = FALSE;

    PAGED_CODE();

    //
    //  We will acquire the Scb for the Mft for this operation.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we don't have a reserved record then reserve one now.
        //

        if (!FlagOn( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED )) {

            NtfsInitializeAttributeContext( &AttrContext );
            CleanupAttributeContext = TRUE;

            //
            //  Lookup the bitmap.  There is an error if we can't find
            //  it.
            //

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Vcb->MftScb->Fcb,
                                            &Vcb->MftScb->Fcb->FileReference,
                                            $BITMAP,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR, NULL, NULL );
            }

            (VOID)NtfsReserveMftRecord( IrpContext,
                                        Vcb,
                                        &AttrContext );

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttributeContext = FALSE;
        }

        //
        //  We now want to test for the three defrag operation we
        //  do.  Start by checking if we are still trying to
        //  recover Mft space for the disk.  This is true if
        //  have begun defragging and are above the lower threshold
        //  or have not begun defragging and are above the upper
        //  threshold.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        NtfsCheckForDefrag( Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        //
        //  If we are actively defragging and can deallocate space
        //  from the tail of the file then do that.  We won't synchronize
        //  testing the flag for the defrag state below since making
        //  the calls is benign in any case.
        //

        if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

            if (NtfsTruncateMft( IrpContext, Vcb )) {

                try_return( DefragStepTaken = TRUE );
            }
        }

        //
        //  Else if we need to rewrite the mapping for the file do
        //  so now.
        //

        if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_EXCESS_MAP )) {

            if (NtfsRewriteMftMapping( IrpContext,
                                       Vcb )) {

                try_return( DefragStepTaken = TRUE );
            }
        }

        //
        //  The last choice is to try to find a candidate for a hole in
        //  the file.  We will walk backwards from the end of the file.
        //

        if (NtfsPerforateMft &&
            FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

            if (NtfsCreateMftHole( IrpContext, Vcb )) {

                try_return( DefragStepTaken = TRUE );
            }
        }

        //
        //  We couldn't do any work to defrag.  This means that we can't
        //  even try to defrag unless a file record is freed at some
        //  point.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );
        ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( NtfsDefragMftPriv );

        if (CleanupAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        NtfsReleaseScb( IrpContext, Vcb->MftScb );
    }

    return DefragStepTaken;
}


//
//  Local support routine
//

LONG
NtfsReadMftExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN PBCB Bcb,
    IN LONGLONG FileOffset
    )
{
    //
    //  Check if we support this error,
    //  if we didn't fail to  totally page in the first time since we need the original
    //  to copy the mirror one into, or if the offset isn't within the mirror range
    //

    if (!FsRtlIsNtstatusExpected( ExceptionPointer->ExceptionRecord->ExceptionCode ) ||
        (Bcb == NULL) ||
        (FileOffset >= IrpContext->Vcb->Mft2Scb->Header.FileSize.QuadPart)) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    //  Clear the status field in the IrpContext. We're going to retry in the mirror
    //

    IrpContext->ExceptionStatus = STATUS_SUCCESS;

    return EXCEPTION_EXECUTE_HANDLER;
}


#if  (DBG || defined( NTFS_FREE_ASSERTS ))

//
//  Look for a prior entry in the Fcb table for the same value.
//

VOID
NtfsVerifyFileReference (
    IN PIRP_CONTEXT IrpContext,
    IN PMFT_SEGMENT_REFERENCE MftSegment
    )

{
    MFT_SEGMENT_REFERENCE TestReference;
    ULONG Index = 5;
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Entry;

    TestReference = *MftSegment;
    TestReference.SequenceNumber -= 1;

    NtfsAcquireFcbTable( NULL, IrpContext->Vcb );

    while((TestReference.SequenceNumber != 0) && (Index != 0)) {

        Key.FileReference = TestReference;

        if ((Entry = RtlLookupElementGenericTable( &IrpContext->Vcb->FcbTable, &Key )) != NULL) {

            //
            //  Let's be optimistic and do an unsafe check. If we can't get the resource,
            //  we'll just assume that it's in the process of getting deleted.
            //

            if (!FlagOn( Entry->Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                if (NtfsAcquireResourceExclusive( IrpContext, Entry->Fcb, FALSE )) {

                    //
                    //  Either the Fcb should be marked as deleted or there should be no
                    //  Scbs lying around to flush.
                    //

                    if (!FlagOn( Entry->Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                        PLIST_ENTRY Links;
                        PSCB NextScb;

                        Links = Entry->Fcb->ScbQueue.Flink;

                        //
                        //  We don't care if there are Scb's as long as none of them
                        //  represent real data.
                        //

                        while (Links != &Entry->Fcb->ScbQueue) {

                            NextScb = CONTAINING_RECORD( Links, SCB, FcbLinks );
                            if (NextScb->AttributeTypeCode != $UNUSED) {

                                break;
                            }

                            Links = Links->Flink;
                        }

                        //
                        //  Leave the test for deleted in the assert message so the debugger output
                        //  is more descriptive.
                        //

                        ASSERT( FlagOn( Entry->Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                                (Links == &Entry->Fcb->ScbQueue) );
                    }
                    NtfsReleaseResource( IrpContext, Entry->Fcb );
                }
            }
        }

        Index -= 1;
        TestReference.SequenceNumber -= 1;
    }

    NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\indexsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    IndexSup.c

Abstract:

    This module implements the Index management routines for Ntfs

Author:

    Tom Miller      [TomM]          14-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"
#include "Index.h"

//
//  This constant affects the logic in NtfsRetrieveOtherFileName.
//  If an index is greater than this size, then we retrieve the other
//  name by reading the file record.  The number is arbitrary, but the
//  below value should normally kick in for directories of around 150
//  to 200 files, or fewer if the names are quite large.
//

#define MAX_INDEX_TO_SCAN_FOR_NAMES      (0x10000)

#if DBG
BOOLEAN NtfsIndexChecks = TRUE;
#endif

#if DBG

#define CheckRoot() {                                               \
if (NtfsIndexChecks) {                                              \
    NtfsCheckIndexRoot(Scb->Vcb,                                    \
                       (PINDEX_ROOT)NtfsAttributeValue(Attribute),  \
                       Attribute->Form.Resident.ValueLength);       \
    }                                                               \
}

#define CheckBuffer(IB) {                                           \
if (NtfsIndexChecks) {                                              \
    NtfsCheckIndexBuffer(Scb,                                       \
                         (IB));                                     \
    }                                                               \
}

#else

#define CheckRoot() {NOTHING;}
#define CheckBuffer(IB) {NOTHING;}

#endif

#define BINARY_SEARCH_ENTRIES           (128)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_INDEXSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('IFtN')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsReinitializeIndexContext)
#pragma alloc_text(PAGE, NtfsGrowLookupStack)
#pragma alloc_text(PAGE, AddToIndex)
#pragma alloc_text(PAGE, BinarySearchIndex)
#pragma alloc_text(PAGE, DeleteFromIndex)
#pragma alloc_text(PAGE, DeleteIndexBuffer)
#pragma alloc_text(PAGE, DeleteSimple)
#pragma alloc_text(PAGE, FindFirstIndexEntry)
#pragma alloc_text(PAGE, FindMoveableIndexRoot)
#pragma alloc_text(PAGE, FindNextIndexEntry)
#pragma alloc_text(PAGE, GetIndexBuffer)
#pragma alloc_text(PAGE, InsertSimpleAllocation)
#pragma alloc_text(PAGE, InsertSimpleRoot)
#pragma alloc_text(PAGE, InsertWithBufferSplit)
#pragma alloc_text(PAGE, NtfsAddIndexEntry)
#pragma alloc_text(PAGE, NtfsCleanupAfterEnumeration)
#pragma alloc_text(PAGE, NtfsCleanupIndexContext)
#pragma alloc_text(PAGE, NtfsContinueIndexEnumeration)
#pragma alloc_text(PAGE, NtfsCreateIndex)
#pragma alloc_text(PAGE, NtfsDeleteIndex)
#pragma alloc_text(PAGE, NtfsDeleteIndexEntry)
#pragma alloc_text(PAGE, NtfsFindIndexEntry)
#pragma alloc_text(PAGE, NtfsInitializeIndexContext)
#pragma alloc_text(PAGE, NtfsIsIndexEmpty)
#pragma alloc_text(PAGE, NtfsPushIndexRoot)
#pragma alloc_text(PAGE, NtfsRestartDeleteSimpleAllocation)
#pragma alloc_text(PAGE, NtfsRestartDeleteSimpleRoot)
#pragma alloc_text(PAGE, NtfsRestartIndexEnumeration)
#pragma alloc_text(PAGE, NtfsRestartInsertSimpleAllocation)
#pragma alloc_text(PAGE, NtfsRestartInsertSimpleRoot)
#pragma alloc_text(PAGE, NtfsRestartSetIndexBlock)
#pragma alloc_text(PAGE, NtfsRestartUpdateFileName)
#pragma alloc_text(PAGE, NtfsRestartWriteEndOfIndex)
#pragma alloc_text(PAGE, NtfsRetrieveOtherFileName)
#pragma alloc_text(PAGE, NtfsUpdateFileNameInIndex)
#pragma alloc_text(PAGE, NtfsUpdateIndexScbFromAttribute)
#pragma alloc_text(PAGE, PruneIndex)
#pragma alloc_text(PAGE, PushIndexRoot)
#pragma alloc_text(PAGE, ReadIndexBuffer)
#pragma alloc_text(PAGE, NtOfsRestartUpdateDataInIndex)
#endif


VOID
NtfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE IndexedAttributeType,
    IN COLLATION_RULE CollationRule,
    IN ULONG BytesPerIndexBuffer,
    IN UCHAR BlocksPerIndexBuffer,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN NewIndex,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    This routine may be called to create (or reinitialize) an index
    within a given file over a given attribute.  For example, to create
    a normal directory, an index over the FILE_NAME attribute is created
    within the desired (directory) file.

Arguments:

    Fcb - File in which the index is to be created.

    IndexedAttributeType - Type code of attribute to be indexed.

    CollationRule - Collation Rule for this index.

    BytesPerIndexBuffer - Number of bytes in an index buffer.

    BlocksPerIndexBuffer - Number of contiguous blocks to allocate for each
        index buffer allocated from the index allocation.

    Context - If reinitializing an existing index, this context must
              currently describe the INDEX_ROOT attribute.  Must be
              supplied if NewIndex is FALSE.

    NewIndex - Supplied as FALSE to reinitialize an existing index, or
               TRUE if creating a new index.

    LogIt - May be supplied as FALSE by Create or Cleanup when already
            logging the creation or deletion of an entire file record.
            Otherwise must be specified as TRUE to allow logging.

Return Value:

    None

--*/

{
    UNICODE_STRING AttributeName;
    WCHAR NameBuffer[10];
    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    ULONG idx;

    struct {
        INDEX_ROOT IndexRoot;
        INDEX_ENTRY EndEntry;
    } R;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( NewIndex || ARGUMENT_PRESENT(Context) );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateIndex\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("CollationRule = %08lx\n", CollationRule) );
    DebugTrace( 0, Dbg, ("BytesPerIndexBuffer = %08lx\n", BytesPerIndexBuffer) );
    DebugTrace( 0, Dbg, ("BlocksPerIndexBuffer = %08lx\n", BlocksPerIndexBuffer) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );
    DebugTrace( 0, Dbg, ("NewIndex = %02lx\n", NewIndex) );
    DebugTrace( 0, Dbg, ("LogIt = %02lx\n", LogIt) );

    //
    //  First we will initialize the Index Root structure which is the value
    //  of the attribute we need to create.  We initialize it with 0 free bytes,
    //  which means the first insert will have to expand the record
    //

    RtlZeroMemory( &R, sizeof(INDEX_ROOT) + sizeof(INDEX_ENTRY) );

    R.IndexRoot.IndexedAttributeType = IndexedAttributeType;
    R.IndexRoot.CollationRule = CollationRule;
    R.IndexRoot.BytesPerIndexBuffer = BytesPerIndexBuffer;
    R.IndexRoot.BlocksPerIndexBuffer = BlocksPerIndexBuffer;

    R.IndexRoot.IndexHeader.FirstIndexEntry = QuadAlign(sizeof(INDEX_HEADER));
    R.IndexRoot.IndexHeader.FirstFreeByte =
    R.IndexRoot.IndexHeader.BytesAvailable = QuadAlign(sizeof(INDEX_HEADER)) +
                                             QuadAlign(sizeof(INDEX_ENTRY));

    //
    //  Now we need to put in the special End entry.
    //

    R.EndEntry.Length = sizeof(INDEX_ENTRY);
    SetFlag( R.EndEntry.Flags, INDEX_ENTRY_END );

    //
    //  Now calculate the name which will be used to name the Index Root and
    //  Index Allocation attributes for this index.  It is $Ixxx, where "xxx"
    //  is the attribute number being indexed in hex with leading 0's suppressed.
    //

    if (NewIndex) {

        //
        //  First, there are some illegal values for the attribute code being indexed.
        //

        ASSERT( IndexedAttributeType < 0x10000000 );
        ASSERT( IndexedAttributeType != $UNUSED );

        //
        //  Initialize the attribute name.
        //

        NameBuffer[0] = (WCHAR)'$';
        NameBuffer[1] = (WCHAR)'I';
        idx = 2;

        //
        //  Now shift a "marker" into the low order nibble, so we know when to stop
        //  shifting below.
        //

        IndexedAttributeType = (IndexedAttributeType << 4) + 0xF;

        //
        //  Outer loop strips leading 0's
        //

        while (TRUE) {

            if ((IndexedAttributeType & 0xF0000000) == 0) {
                IndexedAttributeType <<= 4;
            } else {

                //
                //  The inner loop forms the name until the marker is in the high
                //  nibble.
                //

                while (IndexedAttributeType != 0xF0000000) {
                    NameBuffer[idx] = (WCHAR)(IndexedAttributeType / 0x10000000 + '0');
                    idx += 1;
                    IndexedAttributeType <<= 4;
                }
                NameBuffer[idx] = UNICODE_NULL;
                break;
            }
        }

        RtlInitUnicodeString( &AttributeName, NameBuffer );

        //
        //  Now, just create the Index Root Attribute.
        //

        Context = &LocalContext;
        NtfsInitializeAttributeContext( Context );
    }

    try {

        if (NewIndex) {

            LONGLONG Delta = NtfsResidentStreamQuota( Fcb->Vcb );

            NtfsConditionallyUpdateQuota( IrpContext,
                                          Fcb,
                                          &Delta,
                                          LogIt,
                                          TRUE );

            NtfsCreateAttributeWithValue( IrpContext,
                                          Fcb,
                                          $INDEX_ROOT,
                                          &AttributeName,
                                          &R,
                                          sizeof( INDEX_ROOT ) + sizeof( INDEX_ENTRY ),
                                          AttributeFlags,
                                          NULL,
                                          LogIt,
                                          Context );
        } else {

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      0,
                                      &R,
                                      sizeof( INDEX_ROOT ) + sizeof( INDEX_ENTRY ),
                                      TRUE,
                                      FALSE,
                                      FALSE,
                                      TRUE,
                                      Context );
        }

    } finally {

        DebugUnwind( NtfsCreateIndex );

        if (NewIndex) {
            NtfsCleanupAttributeContext( IrpContext, Context );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateIndex -> VOID\n") );

    return;
}


VOID
NtfsUpdateIndexScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER IndexRootAttr,
    IN ULONG MustBeFileName
    )

/*++

Routine Description:

    This routine is called when an Index Scb needs initialization.  Typically
    once in the life of the Scb.  It will update the Scb out of the $INDEX_ROOT
    attribute.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexRootAttr - Supplies the $INDEX_ROOT attribute.

    MustBeFileName - Force this to be a filename.  Mark the volume dirty if
        the attribute isn't currently marked as such but let processing continue.
        This is used to continue mounting a volume where either the root directory or
        the $Extend directory is incorrectly marked.

Return Value:

    None

--*/

{
    PINDEX_ROOT IndexRoot = (PINDEX_ROOT) NtfsAttributeValue( IndexRootAttr );
    PAGED_CODE();

    //
    //  Update the Scb out of the attribute.
    //

    SetFlag( Scb->AttributeFlags,
             IndexRootAttr->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_ENCRYPTED) );

    //
    //  Capture the values out of the attribute.  Note that we load the
    //  BytesPerIndexBuffer last as a flag to indicate that the Scb is
    //  loaded.
    //

    Scb->ScbType.Index.CollationRule = IndexRoot->CollationRule;
    Scb->ScbType.Index.BlocksPerIndexBuffer = IndexRoot->BlocksPerIndexBuffer;

    //
    //  Check if we must collate on the file name.
    //

    if (MustBeFileName) {

        Scb->ScbType.Index.AttributeBeingIndexed = $FILE_NAME;

    } else if (!FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

        Scb->ScbType.Index.AttributeBeingIndexed = IndexRoot->IndexedAttributeType;
    }

    //
    //  If the type code is $FILE_NAME then make sure the collation type
    //  is FILE_NAME.
    //

    if (Scb->ScbType.Index.AttributeBeingIndexed == $FILE_NAME) {

        if (IndexRoot->CollationRule != COLLATION_FILE_NAME) {

            ASSERTMSG( "Invalid collation rule", FALSE );
            ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX ));
            NtfsMarkVolumeDirty( IrpContext, Scb->Vcb );

            Scb->ScbType.Index.CollationRule = COLLATION_FILE_NAME;
        }
    }

    //
    //  Compute the shift count for this index.
    //

    if (IndexRoot->BytesPerIndexBuffer >= Scb->Vcb->BytesPerCluster) {

        Scb->ScbType.Index.IndexBlockByteShift = (UCHAR) Scb->Vcb->ClusterShift;

    } else {

        Scb->ScbType.Index.IndexBlockByteShift = DEFAULT_INDEX_BLOCK_BYTE_SHIFT;
    }

    Scb->ScbType.Index.BytesPerIndexBuffer = IndexRoot->BytesPerIndexBuffer;

    return;
}


BOOLEAN
NtfsFindIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PBCB *Bcb,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to look up a given value in a given index
    and return the file reference of the indexed file record.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Supplies a pointer to the value to lookup.

    IgnoreCase - For indices with collation rules where character case
                 may be relevant, supplies whether character case is
                 to be ignored.  For example, if supplied as TRUE, then
                 'T' and 't' are treated as equivalent.

    QuickIndex - If specified, supplies a pointer to a quick lookup structure
                 to be updated by this routine.

    Bcb - Returns a Bcb pointer which must be unpinned by the caller

    IndexEntry - Returns a pointer to the actual Index Entry, valid until
                 the Bcb is unpinned.

    IndexContext - If specified then this is an initialized index context.
                   It is used to insert a new entry later if this search
                   doesn't find a match.

Return Value:

    FALSE - if no match was found.
    TRUE - if a match was found and being returned in FileReference.

--*/

{
    PINDEX_CONTEXT LocalIndexContext;
    BOOLEAN Result = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFindIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );

    //
    //  Check if we need to initialize a local structure.
    //

    if (ARGUMENT_PRESENT( IndexContext )) {

        LocalIndexContext = IndexContext;

    } else {

        //
        //  AllocateFromStack can raise.  Our FSD exception filter will catch it.
        //

        LocalIndexContext = NtfsAllocateFromStack( sizeof( INDEX_CONTEXT ));
        NtfsInitializeIndexContext( LocalIndexContext );
    }

    try {

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             Value,
                             LocalIndexContext );

        //
        //  We are doing a direct compare in FindNextIndexEntry below
        //  so we don't have to upcase Value.  The name compare routine
        //  called later will upcase both.
        //

        if (FindNextIndexEntry( IrpContext,
                                Scb,
                                Value,
                                FALSE,
                                IgnoreCase,
                                LocalIndexContext,
                                FALSE,
                                NULL )) {

            //
            //  Return our outputs, clearing the Bcb so it won't get
            //  unpinned.
            //

            *IndexEntry = LocalIndexContext->Current->IndexEntry;

            //
            //  Now return the correct Bcb.
            //

            if (LocalIndexContext->Current == LocalIndexContext->Base) {

                *Bcb = NtfsFoundBcb(&LocalIndexContext->AttributeContext);
                NtfsFoundBcb(&LocalIndexContext->AttributeContext) = NULL;

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->BufferOffset = 0;
                }

            } else {

                PINDEX_LOOKUP_STACK Sp = LocalIndexContext->Current;

                *Bcb = Sp->Bcb;
                Sp->Bcb = NULL;

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                    QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                    QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                    QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
                }
            }

            try_return( Result = TRUE );

        } else {

            try_return( Result = FALSE );
        }

    try_exit: NOTHING;
    } finally{

        DebugUnwind( NtfsFindIndexEntry );

        if (!ARGUMENT_PRESENT( IndexContext )) {

            NtfsCleanupIndexContext( IrpContext, LocalIndexContext );
        }
    }

    DebugTrace( 0, Dbg, ("Bcb < %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("IndexEntry < %08lx\n", *IndexEntry) );
    DebugTrace( -1, Dbg, ("NtfsFindIndexEntry -> %08lx\n", Result) );

    return Result;
}


VOID
NtfsUpdateFileNameInIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN PDUPLICATED_INFORMATION Info,
    IN OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to look up a given value in a given index
    and pin it for modification.

Arguments:

    Scb - Supplies the Scb for the index.

    FileName - Supplies a pointer to the file name to lookup.

    Info - Supplies a pointer to the information for the update

    QuickIndex - If present, this is the fast lookup information for this index entry.

Return Value:

    None.

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_ENTRY IndexEntry;
    PFILE_NAME FileNameInIndex;
    PVCB Vcb = Scb->Vcb;
    PINDEX_LOOKUP_STACK Sp;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFileNameInIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileName = %08lx\n", FileName) );
    DebugTrace( 0, Dbg, ("Info = %08lx\n", Info) );

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  If the index entry for this filename hasn't moved we can go
        //  directly to the location in the buffer.  For this to be the case the
        //  following must be true.
        //
        //      - The entry must already be in an index buffer
        //      - The index stream may not have been truncated
        //      - The Lsn in the page can't have changed
        //

        if (ARGUMENT_PRESENT( QuickIndex ) &&
            QuickIndex->BufferOffset != 0 &&
            QuickIndex->ChangeCount == Scb->ScbType.Index.ChangeCount) {

            //
            //  Use the top location in the index context to perform the
            //  read.
            //

            Sp = IndexContext.Base;

            ReadIndexBuffer( IrpContext,
                             Scb,
                             QuickIndex->IndexBlock,
                             FALSE,
                             Sp );

            //
            //  If the Lsn matches then we can use this buffer directly.
            //

            if (QuickIndex->CapturedLsn.QuadPart == Sp->CapturedLsn.QuadPart) {

                IndexBuffer = (PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer;
                IndexEntry = (PINDEX_ENTRY) Add2Ptr( Sp->StartOfBuffer,
                                                     QuickIndex->BufferOffset );

                FileNameInIndex = (PFILE_NAME)(IndexEntry + 1);

                //
                //  Pin the index buffer
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                //
                //  Write the log record, but do not update the IndexBuffer Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  Indexbuffer->Lsn =
                //

                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              UpdateFileNameAllocation,
                              Info,
                              sizeof(DUPLICATED_INFORMATION),
                              UpdateFileNameAllocation,
                              &FileNameInIndex->Info,
                              sizeof(DUPLICATED_INFORMATION),
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              (ULONG)((PCHAR)IndexEntry - (PCHAR)IndexBuffer),
                              Scb->ScbType.Index.BytesPerIndexBuffer );

                //
                //  Now call the Restart routine to do it.
                //

                NtfsRestartUpdateFileName( IndexEntry,
                                           Info );

                leave;

            //
            //  Otherwise we need to reinitialize the index context and take
            //  the long path below.
            //

            } else {

                NtfsReinitializeIndexContext( IrpContext, &IndexContext );
            }
        }

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             (PVOID)FileName,
                             &IndexContext );

        //
        //  See if there is an actual match.
        //

        if (FindNextIndexEntry( IrpContext,
                                Scb,
                                (PVOID)FileName,
                                FALSE,
                                FALSE,
                                &IndexContext,
                                FALSE,
                                NULL )) {

            //
            //  Point to the index entry and the file name within it.
            //

            IndexEntry = IndexContext.Current->IndexEntry;
            FileNameInIndex = (PFILE_NAME)(IndexEntry + 1);

            //
            //  Now pin the entry.
            //

            if (IndexContext.Current == IndexContext.Base) {

                PFILE_RECORD_SEGMENT_HEADER FileRecord;
                PATTRIBUTE_RECORD_HEADER Attribute;
                PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext.AttributeContext;

                //
                //  Pin the root
                //

                NtfsPinMappedAttribute( IrpContext,
                                        Vcb,
                                        Context );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                FileRecord = NtfsContainingFileRecord(Context);
                Attribute = NtfsFoundAttribute(Context);

                //
                //  Write the log record, but do not update the FileRecord Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  FileRecord->Lsn =
                //

                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NtfsFoundBcb(Context),
                              UpdateFileNameRoot,
                              Info,
                              sizeof(DUPLICATED_INFORMATION),
                              UpdateFileNameRoot,
                              &FileNameInIndex->Info,
                              sizeof(DUPLICATED_INFORMATION),
                              NtfsMftOffset( Context ),
                              (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                              (ULONG)((PCHAR)IndexEntry - (PCHAR)Attribute),
                              Vcb->BytesPerFileRecordSegment );

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->BufferOffset = 0;
                }

            } else {

                Sp = IndexContext.Current;
                IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

                //
                //  Pin the index buffer
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                //
                //  Write the log record, but do not update the IndexBuffer Lsn,
                //  since nothing moved and we don't want to force index contexts
                //  to have to rescan.
                //
                //  Indexbuffer->Lsn =
                //

                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              UpdateFileNameAllocation,
                              Info,
                              sizeof(DUPLICATED_INFORMATION),
                              UpdateFileNameAllocation,
                              &FileNameInIndex->Info,
                              sizeof(DUPLICATED_INFORMATION),
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)IndexBuffer),
                              Scb->ScbType.Index.BytesPerIndexBuffer );

                if (ARGUMENT_PRESENT( QuickIndex )) {

                    QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
                    QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
                    QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
                    QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
                }
            }

            //
            //  Now call the Restart routine to do it.
            //

            NtfsRestartUpdateFileName( IndexEntry,
                                       Info );

        //
        //  If the file name is not in the index, this is a bad file.
        //

        } else {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

    } finally{

        DebugUnwind( NtfsUpdateFileNameInIndex );

        NtfsCleanupIndexContext( IrpContext, &IndexContext );
    }

    DebugTrace( -1, Dbg, ("NtfsUpdateFileNameInIndex -> VOID\n") );

    return;
}


VOID
NtfsAddIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PFILE_REFERENCE FileReference,
    IN PINDEX_CONTEXT IndexContext OPTIONAL,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to add an entry to an index.  This routine
    always allows duplicates.  If duplicates are not allowed, it is the
    caller's responsibility to detect and eliminate any duplicate before
    calling this routine.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Supplies a pointer to the value to add to the index

    ValueLength - Supplies the length of the value in bytes.

    FileReference - Supplies the file reference to place with the index entry.

    QuickIndex - If specified we store the location of the index added.

    IndexContext - If specified, previous result of doing the lookup for the name in the index.

Return Value:

    None

--*/

{
    INDEX_CONTEXT IndexContextStruct;
    PINDEX_CONTEXT LocalIndexContext;
    struct {
        INDEX_ENTRY IndexEntry;
        PVOID Value;
        PVOID MustBeNull;
    } IE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );
    ASSERT( (Scb->ScbType.Index.CollationRule != COLLATION_FILE_NAME) ||
            ( *(PLONGLONG)&((PFILE_NAME)Value)->ParentDirectory ==
              *(PLONGLONG)&Scb->Fcb->FileReference ) );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("ValueLength = %08lx\n", ValueLength) );
    DebugTrace( 0, Dbg, ("FileReference = %08lx\n", FileReference) );

    //
    //  Remember if we are using the local or input IndexContext.
    //

    if (ARGUMENT_PRESENT( IndexContext )) {

        LocalIndexContext = IndexContext;

    } else {

        LocalIndexContext = &IndexContextStruct;
        NtfsInitializeIndexContext( LocalIndexContext );
    }

    try {

        //
        //  Do the lookup again if we don't have a context.
        //

        if (!ARGUMENT_PRESENT( IndexContext )) {

            //
            //  Position to first possible match.
            //

            FindFirstIndexEntry( IrpContext,
                                 Scb,
                                 Value,
                                 LocalIndexContext );

            //
            //  See if there is an actual match.
            //

            if (FindNextIndexEntry( IrpContext,
                                    Scb,
                                    Value,
                                    FALSE,
                                    FALSE,
                                    LocalIndexContext,
                                    FALSE,
                                    NULL )) {

                ASSERTMSG( "NtfsAddIndexEntry already exists", FALSE );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
        }

        //
        //  Initialize the Index Entry in pointer form.
        //

        IE.IndexEntry.FileReference = *FileReference;
        IE.IndexEntry.Length = (USHORT)(sizeof(INDEX_ENTRY) + QuadAlign(ValueLength));
        IE.IndexEntry.AttributeLength = (USHORT)ValueLength;
        IE.IndexEntry.Flags = INDEX_ENTRY_POINTER_FORM;
        IE.IndexEntry.Reserved = 0;
        IE.Value = Value;
        IE.MustBeNull = NULL;

        //
        //  Now add it to the index.  We can only add to a leaf, so force our
        //  position back to the correct spot in a leaf first.
        //

        LocalIndexContext->Current = LocalIndexContext->Top;
        AddToIndex( IrpContext, Scb, (PINDEX_ENTRY)&IE, LocalIndexContext, QuickIndex, FALSE );

    } finally{

        DebugUnwind( NtfsAddIndexEntry );

        if (!ARGUMENT_PRESENT( IndexContext )) {

            NtfsCleanupIndexContext( IrpContext, LocalIndexContext );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsAddIndexEntry -> VOID\n") );

    return;
}


VOID
NtfsDeleteIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN PFILE_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine may be called to delete a specified index entry.  The
    first entry is removed which matches the value exactly (including in Case,
    if relevant) and the file reference.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Supplies a pointer to the value to delete from the index.

    FileReference - Supplies the file reference of the index entry.

Return Value:

    None

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_ENTRY IndexEntry;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("FileReference = %08lx\n", FileReference) );

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             Value,
                             &IndexContext );

        //
        //  See if there is an actual match.
        //

        if (!FindNextIndexEntry( IrpContext,
                                 Scb,
                                 Value,
                                 FALSE,
                                 FALSE,
                                 &IndexContext,
                                 FALSE,
                                 NULL )) {

            ASSERTMSG( "NtfsDeleteIndexEntry does not exist", FALSE );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Extract the found index entry pointer.
        //

        IndexEntry = IndexContext.Current->IndexEntry;

        //
        //  If the file reference also matches, then this is the one we
        //  are supposed to delete.
        //

        if (!NtfsEqualMftRef(&IndexEntry->FileReference, FileReference)) {

            ASSERTMSG( "NtfsDeleteIndexEntry unexpected file reference", FALSE );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        DeleteFromIndex( IrpContext, Scb, &IndexContext );

    } finally{

        DebugUnwind( NtfsDeleteIndexEntry );

        NtfsCleanupIndexContext( IrpContext, &IndexContext );
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteIndexEntry -> VOID\n") );

    return;
}


VOID
NtfsPushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine may be called to "push" the index root, i.e., add another
    level to the BTree, to make more room in the file record.

Arguments:

    Scb - Supplies the Scb for the index.

Return Value:

    None

--*/

{
    INDEX_CONTEXT IndexContext;
    PINDEX_LOOKUP_STACK Sp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPushIndexRoot\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );

    NtfsInitializeIndexContext( &IndexContext );

    try {

        //
        //  Position to first possible match.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             NULL,
                             &IndexContext );

        //
        //  See if the stack will have to be grown to do the push
        //

        Sp = IndexContext.Top + 1;

        if (Sp >= IndexContext.Base + (ULONG)IndexContext.NumberEntries) {
            NtfsGrowLookupStack( Scb,
                                 &IndexContext,
                                 &Sp );
        }

        PushIndexRoot( IrpContext, Scb, &IndexContext );

    } finally{

        DebugUnwind( NtfsPushIndexRoot );

        NtfsCleanupIndexContext( IrpContext, &IndexContext );
    }

    DebugTrace( -1, Dbg, ("NtfsPushIndexRoot -> VOID\n") );

    return;
}


BOOLEAN
NtfsRestartIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry,
    IN PFCB AcquiredFcb
    )

/*++

Routine Description:

    This routine may be called to start or restart an index enumeration,
    according to the parameters as described below.  The first matching
    entry, if any, is returned by this call.  Subsequent entries, if any,
    may be returned by subsequent calls to NtfsContinueIndexEnumeration.

    For each entry found, a pointer is returned to a copy of the entry, in
    dynamically allocated pool pointed to by the Ccb.  Therefore, there is
    nothing for the caller to unpin.

    Note that the Value, ValueLength, and IgnoreCase parameters on the first
    call for a given Ccb fix what will be returned for this Ccb forever.  A
    subsequent call to this routine may also specify these parameters, but
    in this case these parameters will be used for positioning only; all
    matches returned will continue to match the value and IgnoreCase flag
    specified on the first call for the Ccb.

    Note that all calls to this routine must be from within a try-finally,
    and the finally clause must include a call to NtfsCleanupAfterEnumeration.

Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

    Scb - Supplies the Scb for the index.

    Value - Pointer to the value containing the pattern which is to match
            all returns for enumerations on this Ccb.

    IgnoreCase - If FALSE, all returns will match the pattern value with
                 exact case (if relevant).  If TRUE, all returns will match
                 the pattern value ignoring case.  On a second or subsequent
                 call for a Ccb, this flag may be specified differently just
                 for positioning.  For example, an IgnoreCase TRUE enumeration
                 may be restarted at a previously returned value found by exact
                 case match.

    NextFlag - FALSE if the first match of the enumeration is to be returned.
               TRUE if the next match after the first one is to be returned.

    IndexEntry - Returns a pointer to a copy of the index entry.

    AcquiredFcb - Supplies a pointer to an Fcb which has been preacquired to
                  potentially aide NtfsRetrieveOtherFileName

Return Value:

    FALSE - If no match is being returned, and the output pointer is undefined.
    TRUE - If a match is being returned.

--*/

{
    PINDEX_ENTRY FoundIndexEntry;
    INDEX_CONTEXT OtherContext;
    BOOLEAN WildCardsInExpression;
    BOOLEAN SynchronizationError;
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    PINDEX_CONTEXT IndexContext = NULL;
    BOOLEAN CleanupOtherContext = FALSE;
    BOOLEAN Result = FALSE;
    BOOLEAN ContextJustCreated = FALSE;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );
    ASSERT( ARGUMENT_PRESENT(Value) || (Ccb->IndexContext != NULL) );

    DebugTrace( +1, Dbg, ("NtfsRestartIndexEnumeration\n") );
    DebugTrace( 0, Dbg, ("Ccb = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("NextFlag = %02lx\n", NextFlag) );

    try {

        //
        //  If the Ccb does not yet have an index context, then we must
        //  allocate one and initialize this Context and the Ccb as well.
        //

        if (Ccb->IndexContext == NULL) {

            //
            //  Allocate and initialize the index context.
            //

            Ccb->IndexContext = (PINDEX_CONTEXT)ExAllocateFromPagedLookasideList( &NtfsIndexContextLookasideList );

            NtfsInitializeIndexContext( Ccb->IndexContext );
            ContextJustCreated = TRUE;

            //
            //  Capture the caller's IgnoreCase flag.
            //

            if (IgnoreCase) {
                SetFlag( Ccb->Flags, CCB_FLAG_IGNORE_CASE );
            }
        }

        //
        //  Pick up the pointer to the index context, and save the current
        //  change count from the Scb.
        //

        IndexContext = Ccb->IndexContext;

        //
        //  The first step of enumeration is to position our IndexContext.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             Value,
                             IndexContext );

        //
        //  The following code only applies to file name indices.
        //

        if (!FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {

            //
            //  Remember if there are wild cards.
            //

            if ((*NtfsContainsWildcards[Scb->ScbType.Index.CollationRule])
                                        ( Value )) {

                WildCardsInExpression = TRUE;

            } else {

                WildCardsInExpression = FALSE;
            }

            //
            //  If the operation is caseinsensitive, upcase the string.
            //

            if (IgnoreCase) {

                (*NtfsUpcaseValue[Scb->ScbType.Index.CollationRule])
                                  ( UpcaseTable,
                                    IrpContext->Vcb->UpcaseTableSize,
                                    Value );
            }
        } else {

            //
            //  For view indices, it is implied that all searches
            //  are wildcard searches.
            //

            WildCardsInExpression = TRUE;
        }

        //
        //  If this is not actually the first call, then we have to
        //  position exactly to the Value specified, and set NextFlag
        //  correctly.  The first call can either the initial call
        //  to query or the first call after a restart.
        //

        if (!ContextJustCreated && NextFlag) {

            PIS_IN_EXPRESSION MatchRoutine;
            PFILE_NAME NameInIndex;
            BOOLEAN ItsThere;

            //
            //  See if the specified value is actually there, because
            //  we are not allowed to resume from a Dos-only name.
            //

            ItsThere = FindNextIndexEntry( IrpContext,
                                           Scb,
                                           Value,
                                           WildCardsInExpression,
                                           IgnoreCase,
                                           IndexContext,
                                           FALSE,
                                           NULL );

            //
            //  We will set up pointers from our returns, but we must
            //  be careful only to use them if we found something.
            //

            FoundIndexEntry = IndexContext->Current->IndexEntry;
            NameInIndex = (PFILE_NAME)(FoundIndexEntry + 1);

            //
            //  Figure out which match routine to use.
            //

            if (FlagOn(Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION)) {
                MatchRoutine = NtfsIsInExpression[COLLATION_FILE_NAME];
            } else {
                MatchRoutine = (PIS_IN_EXPRESSION)NtfsIsEqual[COLLATION_FILE_NAME];
            }

            //
            //  If we are trying to resume from a Ntfs-only or Dos-Only name, then
            //  we take action here.  Do not do this on the internal
            //  call from NtfsContinueIndexEnumeration, which is the
            //  only one who would point at the index entry in the Ccb.
            //
            //  We can think of this code this way.  No matter what our search
            //  expression is, we traverse the index only one way.  For each
            //  name we find, we will only return the file name once - either
            //  from an Ntfs-only match or from a Dos-only match if the Ntfs-only
            //  name does not match.  Regardless of whether resuming from the
            //  Ntfs-Only or Dos-only name, we still can determine a unique
            //  position in the directory.  That unique position is the Ntfs-only
            //  name if it matches the expression, or else the Dos-only name if
            //  it only matches.  In the illegal case that neither matches, we
            //  arbitrarily resume from the Ntfs-only name.
            //
            //      This code may be read aloud to the tune
            //          "While My Heart Gently Weeps"
            //

            if (ItsThere &&
                (Value != (PVOID)(Ccb->IndexEntry + 1)) &&
                (Scb->ScbType.Index.CollationRule == COLLATION_FILE_NAME) &&

                //
                //  Is it a Dos-only or Ntfs-only name?
                //

                (BooleanFlagOn( NameInIndex->Flags, FILE_NAME_DOS ) !=
                  BooleanFlagOn( NameInIndex->Flags, FILE_NAME_NTFS )) &&

                //
                //  Try to resume from the other name if he either gave
                //  us a Dos-only name, or he gave us an Ntfs-only name
                //  that does not fit in the search expression.
                //

                (FlagOn( NameInIndex->Flags, FILE_NAME_DOS ) ||
                 !(*MatchRoutine)( UpcaseTable,
                                   Ccb->QueryBuffer,
                                   FoundIndexEntry,
                                   IgnoreCase ))) {

                PFILE_NAME FileNameBuffer;
                ULONG FileNameLength;

                NtfsInitializeIndexContext( &OtherContext );
                CleanupOtherContext = TRUE;

                FileNameBuffer = NtfsRetrieveOtherFileName( IrpContext,
                                                            Ccb,
                                                            Scb,
                                                            FoundIndexEntry,
                                                            &OtherContext,
                                                            AcquiredFcb,
                                                            &SynchronizationError );

                //
                //  We have to position to the long name and actually
                //  resume from there.  To do this we have to cleanup and initialize
                //  the IndexContext in the Ccb, and lookup the long name we just
                //  found.
                //
                //  If the other index entry is not there, there is some minor
                //  corruption going on, but we will just charge on in that event.
                //  Also, if the other index entry is there, but it does not match
                //  our expression, then we are supposed to resume from the short
                //  name, so we carry on.
                //

                ItsThere = (FileNameBuffer != NULL);

                if (!ItsThere && SynchronizationError) {
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                if (ItsThere &&

                    (FlagOn(Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION)  ?

                     NtfsFileNameIsInExpression(UpcaseTable,
                                                (PFILE_NAME)Ccb->QueryBuffer,
                                                FileNameBuffer,
                                                IgnoreCase) :



                     NtfsFileNameIsEqual(UpcaseTable,
                                         (PFILE_NAME)Ccb->QueryBuffer,
                                         FileNameBuffer,
                                         IgnoreCase))) {

                    ULONG SizeOfFileName = FIELD_OFFSET( FILE_NAME, FileName );

                    NtfsReinitializeIndexContext( IrpContext, IndexContext );

                    //
                    //  Extract a description of the file name from the found index
                    //  entry.
                    //

                    FileNameLength = FileNameBuffer->FileNameLength * sizeof( WCHAR );

                    //
                    //  Call FindFirst/FindNext to position our context to the corresponding
                    //  long name.
                    //

                    FindFirstIndexEntry( IrpContext,
                                         Scb,
                                         (PVOID)FileNameBuffer,
                                         IndexContext );

                    ItsThere = FindNextIndexEntry( IrpContext,
                                                   Scb,
                                                   (PVOID)FileNameBuffer,
                                                   FALSE,
                                                   FALSE,
                                                   IndexContext,
                                                   FALSE,
                                                   NULL );

                    if (!ItsThere) {

                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }
                }
            }

            //
            //  NextFlag should only remain TRUE, if the specified value
            //  is actually there, and NextFlag was specified as TRUE
            //  on input.  In particular, it is important to make
            //  NextFlag FALSE if the specified value is not actually
            //  there.  (Experience shows this behavior is important to
            //  implement "delnode" correctly for the Lan Manager Server!)
            //

            NextFlag = (BOOLEAN)(NextFlag && ItsThere);

        //
        //  If we created the context then we need to remember if the
        //  expression has wildcards.
        //

        } else {

            //
            //  We may not handle correctly an initial enumeration with
            //  NextFlag TRUE, because the context is initially sitting
            //  in the root.  Dirctrl must always pass NextFlag FALSE
            //  on the initial enumeration.
            //

            ASSERT(!NextFlag);

            //
            //  Remember if the value has wild cards.
            //

            if (WildCardsInExpression) {

                SetFlag( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION );
            }
        }

        //
        //  Now we are correctly positioned.  See if there is an actual
        //  match at our current position.  If not, return FALSE.
        //
        //  (Note, FindFirstIndexEntry always leaves us positioned in
        //  some leaf of the index, and it is the first FindNext that
        //  actually positions us to the first match.)
        //

        if (!FindNextIndexEntry( IrpContext,
                                 Scb,
                                 Ccb->QueryBuffer,
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION ),
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                 IndexContext,
                                 NextFlag,
                                 NULL )) {

            try_return( Result = FALSE );
        }

        //
        //  If we get here, then we have a match that we want to return.
        //  We always copy the complete IndexEntry away and pass a pointer
        //  back to the copy.  See if our current buffer for the index entry
        //  is large enough.
        //

        FoundIndexEntry = IndexContext->Current->IndexEntry;

        if (Ccb->IndexEntryLength < (ULONG)FoundIndexEntry->Length) {

            //
            //  If there is a buffer currently allocated, deallocate it before
            //  allocating a larger one.  (Clear Ccb fields in case we get an
            //  allocation error.)
            //

            if (Ccb->IndexEntry != NULL) {

                NtfsFreePool( Ccb->IndexEntry );
                Ccb->IndexEntry = NULL;
                Ccb->IndexEntryLength = 0;
            }

            //
            //  Allocate a new buffer for the index entry we just found, with
            //  some "padding" in case the next match is larger.
            //

            Ccb->IndexEntry = (PINDEX_ENTRY)NtfsAllocatePool(PagedPool, (ULONG)FoundIndexEntry->Length + 16 );

            Ccb->IndexEntryLength = (ULONG)FoundIndexEntry->Length + 16;
        }

        //
        //  Now, save away our copy of the IndexEntry, and return a pointer
        //  to it.
        //

        RtlMoveMemory( Ccb->IndexEntry,
                       FoundIndexEntry,
                       (ULONG)FoundIndexEntry->Length );

        *IndexEntry = Ccb->IndexEntry;

        try_return( Result = TRUE );

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsRestartIndexEnumeration );

        if (CleanupOtherContext) {
            NtfsCleanupIndexContext( IrpContext, &OtherContext );
        }
        //
        //  If we died during the first call, then deallocate everything
        //  that we might have allocated.
        //

        if (AbnormalTermination() && ContextJustCreated) {

            if (Ccb->IndexEntry != NULL) {
                NtfsFreePool( Ccb->IndexEntry );
                Ccb->IndexEntry = NULL;
            }

            if (Ccb->IndexContext != NULL) {
                NtfsCleanupIndexContext( IrpContext, Ccb->IndexContext );
                ExFreeToPagedLookasideList( &NtfsIndexContextLookasideList, Ccb->IndexContext );
                Ccb->IndexContext = NULL;
            }
        }

        //
        //  Remember if we are not returning anything, to save work later.
        //

        if (!Result && (Ccb->IndexEntry != NULL)) {
            Ccb->IndexEntry->Length = 0;
        }
    }

    DebugTrace( 0, Dbg, ("*IndexEntry < %08lx\n", *IndexEntry) );
    DebugTrace( -1, Dbg, ("NtfsRestartIndexEnumeration -> %08lx\n", Result) );

    return Result;
}


BOOLEAN
NtfsContinueIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry
    )

/*++

Routine Description:

    This routine may be called to return again the last match on an active
    enumeration, or to return the next match.  Enumerations must always be
    started or restarted via a call to NtfsRestartIndexEnumeration.

    Note that all calls to this routine must be from within a try-finally,
    and the finally clause must include a call to NtfsCleanupAfterEnumeration.

Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

    Scb - Supplies the Scb for the index.

    NextFlag - FALSE if the last returned match is to be returned again.
               TRUE if the next match is to be returned.

    IndexEntry - Returns a pointer to a copy of the index entry.

Return Value:

    FALSE - If no match is being returned, and the output pointer is undefined.
    TRUE - If a match is being returned.

--*/

{
    PINDEX_ENTRY FoundIndexEntry;
    PINDEX_CONTEXT IndexContext;
    BOOLEAN MustRestart;
    BOOLEAN Result = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsContinueIndexEnumeration\n") );
    DebugTrace( 0, Dbg, ("Ccb = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("NextFlag = %02lx\n", NextFlag) );

    //
    //  It seems many apps like to come back one more time and really get
    //  an error status, so if we did not return anything last time, we can
    //  get out now too.
    //
    //  There also may be no index entry, in the case of an empty directory
    //  and dirctrl is cycling through with "." and "..".
    //

    if ((Ccb->IndexEntry == NULL) || (Ccb->IndexEntry->Length == 0)) {

        DebugTrace( -1, Dbg, ("NtfsContinueIndexEnumeration -> FALSE\n") );
        return FALSE;
    }

    IndexContext = Ccb->IndexContext;

    try {

        //
        //  Lookup the next match.
        //

        if (!FindNextIndexEntry( IrpContext,
                                 Scb,
                                 Ccb->QueryBuffer,
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_WILDCARD_IN_EXPRESSION ),
                                 BooleanFlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ),
                                 IndexContext,
                                 NextFlag,
                                 &MustRestart )) {

            //
            //  If he is saying we must restart, then that means something changed
            //  in our saved enumeration context across two file system calls.
            //  Reestablish our position in the tree by looking up the last entry
            //  we returned.
            //

            if (MustRestart) {

                NtfsReinitializeIndexContext( IrpContext, Ccb->IndexContext );

                try_return( Result = NtfsRestartIndexEnumeration( IrpContext,
                                                                  Ccb,
                                                                  Scb,
                                                                  (PVOID)(Ccb->IndexEntry + 1),
                                                                  FALSE,
                                                                  NextFlag,
                                                                  IndexEntry,
                                                                  NULL ));

            //
            //  Otherwise, there is nothing left to return.
            //

            } else {

                try_return( Result = FALSE );
            }
        }

        //
        //  If we get here, then we have a match that we want to return.
        //  We always copy the complete IndexEntry away and pass a pointer
        //  back to the copy.  See if our current buffer for the index entry
        //  is large enough.
        //

        FoundIndexEntry = IndexContext->Current->IndexEntry;

        if (Ccb->IndexEntryLength < (ULONG)FoundIndexEntry->Length) {

            //
            //  If there is a buffer currently allocated, deallocate it before
            //  allocating a larger one.
            //

            if (Ccb->IndexEntry != NULL) {

                NtfsFreePool( Ccb->IndexEntry );
                Ccb->IndexEntry = NULL;
                Ccb->IndexEntryLength = 0;
            }

            //
            //  Allocate a new buffer for the index entry we just found, with
            //  some "padding".
            //

            Ccb->IndexEntry = (PINDEX_ENTRY)NtfsAllocatePool(PagedPool, (ULONG)FoundIndexEntry->Length + 16 );

            Ccb->IndexEntryLength = (ULONG)FoundIndexEntry->Length + 16;
        }

        //
        //  Now, save away our copy of the IndexEntry, and return a pointer
        //  to it.
        //

        RtlMoveMemory( Ccb->IndexEntry,
                       FoundIndexEntry,
                       (ULONG)FoundIndexEntry->Length );

        *IndexEntry = Ccb->IndexEntry;

        try_return( Result = TRUE );

    try_exit: NOTHING;

    } finally {

        DebugUnwind( NtfsContinueIndexEnumeration );

        //
        //  Remember if we are not returning anything, to save work later.
        //

        if (!Result && (Ccb->IndexEntry != NULL)) {
            Ccb->IndexEntry->Length = 0;
        }
    }

    DebugTrace( 0, Dbg, ("*IndexEntry < %08lx\n", *IndexEntry) );
    DebugTrace( -1, Dbg, ("NtfsContinueIndexEnumeration -> %08lx\n", Result) );

    return Result;
}


PFILE_NAME
NtfsRetrieveOtherFileName (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT OtherContext,
    IN PFCB AcquiredFcb OPTIONAL,
    OUT PBOOLEAN SynchronizationError
    )

/*++

Routine Description:

    This routine may be called to retrieve the other index entry for a given
    index entry.  I.e., for an input Ntfs-only index entry it will find the
    Dos-only index entry for the same file referenced, or visa versa.  This
    is a routine which clearly is relevant only to file name indices, but it
    is located here because it uses the Index Context in the Ccb.

    The idea is that nearly always the other name for a given index entry will
    be very near to the given name.

    This routine first scans the leaf index buffer described by the index
    context for the Dos name.  If this fails, this routine attempts to look
    the other name up in the index.  Currently there will always be a Dos name,
    however if one does not exist, we treat that as benign, and simply return
    FALSE.


Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

    Scb - Supplies the Scb for the index.

    IndexEntry - Suppliess a pointer to an index entry, for which the Dos name
                 is to be retrieved.


    OtherContext - Must be initialized on input, and subsequently cleaned up
                   by the caller after the information has been extracted from
                   the other index entry.

    AcquiredFcb - An Fcb which has been acquired so that its file record may be
                  read

    SynchronizationError - Returns TRUE if no file name is being returned because
                           of an error trying to acquire an Fcb to read its file
                           record.

Return Value:

    Pointer to the other desired file name.

--*/

{
    PINDEX_CONTEXT IndexContext;
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY IndexTemp, IndexLast;
    PINDEX_LOOKUP_STACK Top;

    struct {
        FILE_NAME FileName;
        WCHAR NameBuffer[2];
    }OtherFileName;

    UNICODE_STRING OtherName;
    USHORT OtherFlag;
    PVCB Vcb = Scb->Vcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_CCB( Ccb );
    ASSERT_SCB( Scb );
    ASSERT_SHARED_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRetrieveOtherFileName\n") );
    DebugTrace( 0, Dbg, ("Ccb = %08lx\n", Ccb) );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );

    *SynchronizationError = FALSE;

    //
    //  Calculate the other name space flag.
    //

    OtherFlag = ((PFILE_NAME)(IndexEntry + 1))->Flags;
    ClearFlag( OtherFlag, ~(FILE_NAME_NTFS | FILE_NAME_DOS) );
    OtherFlag ^= FILE_NAME_NTFS | FILE_NAME_DOS;

    ASSERT( (OtherFlag == FILE_NAME_NTFS) || (OtherFlag == FILE_NAME_DOS) );

    //
    //  Point to the IndexContext in the Ccb.
    //

    IndexContext = Ccb->IndexContext;

    //
    //  We can only scan the top of the index if it is safe
    //  to read it.
    //

    Top = IndexContext->Top;

    if ((Top->Bcb != NULL) ||
        (Top == IndexContext->Base) ||
        ReadIndexBuffer(IrpContext, Scb, 0, TRUE, Top)) {

        //
        //  Point to the first index entry in the index buffer at the bottom of
        //  the index.
        //

        IndexHeader = Top->IndexHeader;
        IndexTemp = Add2Ptr(IndexHeader, IndexHeader->FirstIndexEntry);
        IndexLast = Add2Ptr(IndexHeader, IndexHeader->FirstFreeByte);

        //
        //  Now scan this buffer for a matching Dos name.
        //

        while (IndexTemp < IndexLast) {

            //
            //  If we find an entry with the same file reference and the Dos flag
            //  set, then we can return it and get out.
            //

            if (NtfsEqualMftRef(&IndexTemp->FileReference, &IndexEntry->FileReference) &&
                FlagOn(((PFILE_NAME)(IndexTemp + 1))->Flags, OtherFlag)) {

                DebugTrace( -1, Dbg, ("NtfsRetrieveOtherFileName -> %08lx\n", IndexTemp) );

                return (PFILE_NAME)(IndexTemp + 1);
            }

            IndexTemp = Add2Ptr(IndexTemp, IndexTemp->Length);
        }
    }

    //
    //  If this is a pretty large directory, then it may be too expensive to
    //  scan for the other name in the directory.  Note in the degenerate
    //  case, we have actually do a sequential scan of the entire directory,
    //  and if all the files in the directory start with the same 6 characters,
    //  which is unfortunately common, then even our "pie-wedge" scan reads
    //  the entire directory.
    //
    //  Thus we will just try to go read the file record in this case to get
    //  the other name.  This is complicated from a synchronization standpoint -
    //  if the file is open, we need to acquire it shared before we can read
    //  it to get the other name.  Here is a summary of the strategy implemented
    //  primarily here and in dirctrl:
    //
    //      1.  Read the file record, in an attempt to avoid a fault while
    //          being synchronized.
    //      2.  If the file reference we need to synchronize is the same as
    //          in the optional AcquiredFcb parameter, go ahead and find/return
    //          the other name.
    //      3.  Else, acquire the Fcb Table to try to look up the Fcb.
    //      4.  If there is no Fcb, hold the table while returning the name.
    //      5.  If there is an Fcb, try to acquire it shared with Wait = FALSE,
    //          and hold it while returning the name.
    //      6.  If we cannot get the Fcb, and AcquiredFcb was not specified, then
    //          store the File Reference we are trying to get and return
    //          *SynchronizationError = TRUE.  Dirctrl must figure out how to
    //          call us back with the FcbAcquired, by forcing a resume of the
    //          enumeration.
    //      7.  If we could not get the Fcb and there *was* a different AcquiredFcb
    //          specified, then this is the only case where we give up and fall
    //          through to find the other name in the directory.  This should be
    //          extremely rare, but if we try to return *SynchronizationError = TRUE,
    //          and force a resume, we could be unlucky and loop forever, essentially
    //          toggling between synchronizing on two Fcbs.  Presumably this could
    //          only happen if we have some kind of dumb client who likes to back
    //          up a few files when he resumes.
    //

    if (Scb->Header.AllocationSize.QuadPart > MAX_INDEX_TO_SCAN_FOR_NAMES) {

        FCB_TABLE_ELEMENT Key;
        PFCB_TABLE_ELEMENT Entry;
        PFCB FcbWeNeed;
        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER Attribute;
        BOOLEAN Synchronized = TRUE;

        //
        //  Get the base file record active and valid before synchronizing.
        //  Don't verify it since we aren't syncrhonized
        //

        NtfsReadMftRecord( IrpContext,
                           Vcb, 
                           &IndexEntry->FileReference,
                           FALSE,
                           &OtherContext->AttributeContext.FoundAttribute.Bcb,
                           &FileRecord,
                           NULL );
        //
        //  If we are not synchronized with the correct Fcb, then try to
        //  synchronize.
        //

        if (!ARGUMENT_PRESENT(AcquiredFcb) ||
            !NtfsEqualMftRef(&AcquiredFcb->FileReference, &IndexEntry->FileReference)) {

            //
            //  Now look up the Fcb, and if it is there, reference it
            //  and remember it.
            //

            Key.FileReference = IndexEntry->FileReference;
            NtfsAcquireFcbTable( IrpContext, Vcb );
            Entry = RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );

            if (Entry != NULL) {

                FcbWeNeed = Entry->Fcb;

                //
                //  Now that it cannot go anywhere, try to acquire it.
                //

                Synchronized = NtfsAcquireResourceShared( IrpContext, FcbWeNeed, FALSE );

                //
                //  If we manage to acquire it, then increment its reference count
                //  and remember it for subsequent cleanup.
                //

                if (Synchronized) {

                    FcbWeNeed->ReferenceCount += 1;
                    OtherContext->AcquiredFcb = FcbWeNeed;
                }

                NtfsReleaseFcbTable( IrpContext, Vcb );

            } else {

                SetFlag( OtherContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
            }
        }

        if (Synchronized) {

            ULONG CorruptHint = 0;

            if (!NtfsCheckFileRecord( Vcb, FileRecord, &IndexEntry->FileReference, &CorruptHint ) ||
                (!FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ))) {

                if (FlagOn( OtherContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED )) {
                    ClearFlag( OtherContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
                    NtfsReleaseFcbTable( IrpContext, Vcb );
                }

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &IndexEntry->FileReference, NULL );
            }

            Attribute = (PATTRIBUTE_RECORD_HEADER)Add2Ptr(FileRecord, FileRecord->FirstAttributeOffset);

            while (((PVOID)Attribute < Add2Ptr(FileRecord, FileRecord->FirstFreeByte)) &&
                   (Attribute->TypeCode <= $FILE_NAME)) {

                if ((Attribute->TypeCode == $FILE_NAME) &&
                    FlagOn(((PFILE_NAME)NtfsAttributeValue(Attribute))->Flags, OtherFlag)) {

                    return (PFILE_NAME)NtfsAttributeValue(Attribute);
                }

                Attribute = NtfsGetNextRecord(Attribute);
            }

        } else if (!ARGUMENT_PRESENT(AcquiredFcb)) {

            Ccb->FcbToAcquire.FileReference = IndexEntry->FileReference;
            *SynchronizationError = TRUE;
            return NULL;
        }

        //
        //  Cleanup from above before proceding.
        //

        NtfsReinitializeIndexContext( IrpContext, OtherContext );
    }

    //
    //  Well, we were unlucky, and did not find the other name yet, form
    //  a name to scan a range of the index.
    //

    RtlZeroMemory( &OtherFileName, sizeof(OtherFileName) );
    OtherName.MaximumLength = 6;
    OtherName.Buffer = (PWCHAR) &OtherFileName.FileName.FileName[0];
    OtherName.Buffer[0] = ((PFILE_NAME)(IndexEntry + 1))->FileName[0];

    //
    //  Name generation is complicated enough, that we are only going to
    //  guess the other name using the first two (special case is one)
    //  characters followed by *.
    //

    if (((PFILE_NAME)(IndexEntry + 1))->FileNameLength > 1) {

        OtherName.Buffer[1] = ((PFILE_NAME)(IndexEntry + 1))->FileName[1];
        OtherName.Buffer[2] = L'*';
        OtherFileName.FileName.FileNameLength = 3;
        OtherName.Length = 6;

    } else {

        OtherName.Buffer[1] = L'*';
        OtherFileName.FileName.FileNameLength = 2;
        OtherName.Length = 4;
    }

    //
    //  Now we think we have formed a pretty good name fairly tightly
    //  encompasses the range of possible Dos names we expect for the
    //  given Ntfs name.  We will enumerate all of the files which match
    //  the pattern we have formed, and see if any of them are the Dos
    //  name for the same file.  If this expression still doesn't work,
    //  (extremely unlikely), then we will substitute the pattern with
    //  "*" and make one final attempt.
    //
    //  Note many names are the same in Dos and Ntfs, and for them this
    //  routine is never called.  Of the ones that do have separate names,
    //  the pattern we formed above should really match it and will probably
    //  scan parts of the directory already in the cache.  The last loop is
    //  a terrible sequential scan of the entire directory.  It should never,
    //  never happen, but it is here so that in the worst case we do not
    //  break, we just take a bit longer.
    //

    while (TRUE) {

        BOOLEAN NextFlag;
        ULONG NameLength;

        NameLength = sizeof(FILE_NAME) + OtherFileName.FileName.FileNameLength - 1;

        //
        //  The first step of enumeration is to position our IndexContext.
        //

        FindFirstIndexEntry( IrpContext,
                             Scb,
                             &OtherFileName,
                             OtherContext );

        NextFlag = FALSE;

        //
        //  Now scan through all of the case insensitive matches.
        //  Upcase our name structure.
        //

        NtfsUpcaseName( Vcb->UpcaseTable, Vcb->UpcaseTableSize, &OtherName );

        while (FindNextIndexEntry( IrpContext,
                                   Scb,
                                   &OtherFileName,
                                   TRUE,
                                   TRUE,
                                   OtherContext,
                                   NextFlag,
                                   NULL )) {

            IndexTemp = OtherContext->Current->IndexEntry;

            //
            //  If we find an entry with the same file reference and the Dos flag
            //  set, then we can return it and get out.
            //

            if (NtfsEqualMftRef(&IndexTemp->FileReference, &IndexEntry->FileReference) &&
                FlagOn(((PFILE_NAME)(IndexTemp + 1))->Flags, OtherFlag)) {

                DebugTrace( -1, Dbg, ("NtfsRetrieveOtherFileName -> %08lx\n", IndexTemp) );

                return (PFILE_NAME)(IndexTemp + 1);
            }

            NextFlag = TRUE;
        }

        //
        //  Give up if we have already scanned everything.
        //

        if ((OtherName.Buffer[0] == '*') && (OtherName.Length == 2)) {
            break;
        }


        NtfsReinitializeIndexContext( IrpContext, OtherContext );

        OtherName.Buffer[0] = '*';
        OtherName.Length = 2;
        OtherFileName.FileName.FileNameLength = 1;
    }

    return NULL;
}


VOID
NtfsCleanupAfterEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )

/*++

Routine Description:

    A call to this routine must exist within the finally clause of any routine
    which calls either NtfsRestartIndexEnumeration or NtfsContinueIndexEnumeration.

Arguments:

    Ccb - Pointer to the Ccb for this enumeration.

Return Value:

    None

--*/


{
    PAGED_CODE();

    if (Ccb->IndexContext != NULL) {
        NtfsReinitializeIndexContext( IrpContext, Ccb->IndexContext );
    }
}


BOOLEAN
NtfsIsIndexEmpty (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    )

/*++

Routine Description:

    This routine may be called to see if the specified index is empty.

Arguments:

    Attribute - Pointer to the attribute record header of an INDEX_ROOT
                attribute.

Return Value:

    FALSE - if the index is not empty.
    TRUE - if the index is empty.

--*/

{
    PINDEX_ROOT IndexRoot;
    PINDEX_ENTRY IndexEntry;
    BOOLEAN Result;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsIndexEmpty\n") );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );

    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue( Attribute );
    IndexEntry = NtfsFirstIndexEntry( &IndexRoot->IndexHeader );

    Result = (BOOLEAN)(!FlagOn( IndexEntry->Flags, INDEX_ENTRY_NODE ) &&
                       FlagOn( IndexEntry->Flags, INDEX_ENTRY_END ));

    DebugTrace( -1, Dbg, ("NtfsIsIndexEmpty -> %02lx\n", Result) );

    return Result;
}


VOID
NtfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING AttributeName
    )

/*++

Routine Description:

    This routine may be called to delete the specified index.  The index
    must be empty.

    NOTE: This routine is not required until we can separately create/delete
          indices, therefore it is not implemented.  Use NtfsDeleteFile
          to delete a "directory" (or a normal file).

Arguments:

    Fcb - Supplies the Fcb for the index.

    AttributeName - Name of the index attributes: $Ixxx

Return Value:

    None

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( Fcb );
    UNREFERENCED_PARAMETER( AttributeName );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteIndex\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("AttributeName = %08lx\n", AttributeName) );

    DbgDoit( DbgPrint("NtfsDeleteIndex is not yet implemented\n"); DbgBreakPoint(); );

    DebugTrace( -1, Dbg, ("NtfsDeleteIndex -> VOID\n") );
}


VOID
NtfsInitializeIndexContext (
    OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine may be called to initialize the specified index context.

Arguments:

    IndexContext - Index context to initialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    RtlZeroMemory( IndexContext, sizeof(INDEX_CONTEXT) );
    NtfsInitializeAttributeContext( &IndexContext->AttributeContext );

    //
    //  Describe the resident lookup stack
    //

    IndexContext->Base = IndexContext->LookupStack;
    IndexContext->NumberEntries = INDEX_LOOKUP_STACK_SIZE;
}


VOID
NtfsCleanupIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine may be called to cleanup the specified index context,
    typically during finally processing.

Arguments:

    IndexContext - Index context to clean up.

Return Value:

    None

--*/

{
    ULONG i;

    PAGED_CODE();

    //
    //  Release the Fcb Table and/or an acquired Fcb.
    //

    if (FlagOn(IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED)) {
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
        ClearFlag( IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
    }

    if (IndexContext->AcquiredFcb != NULL) {

        NtfsAcquireFcbTable( IrpContext, IrpContext->Vcb );
        ASSERT(IndexContext->AcquiredFcb->ReferenceCount > 0);
        IndexContext->AcquiredFcb->ReferenceCount -= 1;
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );

        NtfsReleaseResource( IrpContext, IndexContext->AcquiredFcb );
        IndexContext->AcquiredFcb = NULL;
    }

    for (i = 0; i < IndexContext->NumberEntries; i++) {
        NtfsUnpinBcb( IrpContext, &IndexContext->Base[i].Bcb );
    }

    //
    //  See if we need to deallocate a lookup stack.  Point to the embedded
    //  lookup stack if we deallocate to handle the case where cleanup is
    //  called twice in a row.  We will have to zero the stack so the
    //  subsequent cleanup won't find any Bcb's in the stack.
    //

    if (IndexContext->Base != IndexContext->LookupStack) {
        NtfsFreePool( IndexContext->Base );
    }

    NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
}


VOID
NtfsReinitializeIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine may be called to cleanup the specified index context,
    and reinitialize it, preserving fields that should not be zeroed.

Arguments:

    IndexContext - Index context to clean up.

Return Value:

    None

--*/

{
    ULONG i;

    PAGED_CODE();

    //
    //  Release the Fcb Table and/or an acquired Fcb.
    //

    if (FlagOn(IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED)) {
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );
        ClearFlag( IndexContext->Flags, INDX_CTX_FLAG_FCB_TABLE_ACQUIRED );
    }

    if (IndexContext->AcquiredFcb != NULL) {

        NtfsAcquireFcbTable( IrpContext, IrpContext->Vcb );
        ASSERT(IndexContext->AcquiredFcb->ReferenceCount > 0);
        IndexContext->AcquiredFcb->ReferenceCount -= 1;
        NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );

        NtfsReleaseResource( IrpContext, IndexContext->AcquiredFcb );

        IndexContext->AcquiredFcb = NULL;
    }

    for (i = 0; i < IndexContext->NumberEntries; i++) {
        NtfsUnpinBcb( IrpContext, &IndexContext->Base[i].Bcb );
    }

    NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
    NtfsInitializeAttributeContext( &IndexContext->AttributeContext );
}


VOID
NtfsGrowLookupStack (
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN PINDEX_LOOKUP_STACK *Sp
    )

/*++

Routine Description:

    This routine grows and index lookup stack to contain the specified number
    of entries.

Arguments:

    Scb - Scb for index

    IndexContext - Index context to grow.

    Sp - Caller's local stack pointer to be updated

Return Value:

    None

--*/

{
    PINDEX_LOOKUP_STACK NewLookupStack;
    ULONG_PTR Relocation;
    USHORT NumberEntries;

    PAGED_CODE();

    //
    //  Extract current index hint, if there is one.
    //

    NumberEntries = Scb->ScbType.Index.IndexDepthHint;

    //
    //  If there was no hint, or it was too small, then
    //  calculate a new hint.
    //

    if (NumberEntries <= IndexContext->NumberEntries) {

        Scb->ScbType.Index.IndexDepthHint =
        NumberEntries = IndexContext->NumberEntries + 3;
    }

    //
    //  Allocate (may fail), initialize and copy over the old one.
    //

    NewLookupStack = NtfsAllocatePool( PagedPool, NumberEntries * sizeof(INDEX_LOOKUP_STACK) );

    RtlZeroMemory( NewLookupStack, NumberEntries * sizeof(INDEX_LOOKUP_STACK) );

    RtlCopyMemory( NewLookupStack,
                   IndexContext->Base,
                   IndexContext->NumberEntries * sizeof(INDEX_LOOKUP_STACK) );

    //
    //  Free the old one unless we were using the local stack.
    //

    if (IndexContext->Base != IndexContext->LookupStack) {
        NtfsFreePool( IndexContext->Base );
    }

    //
    //  Now relocate all pointers to the old stack
    //

    Relocation = ((PCHAR)NewLookupStack - (PCHAR)IndexContext->Base);
    IndexContext->Current = (PINDEX_LOOKUP_STACK)((PCHAR)IndexContext->Current + Relocation);
    IndexContext->Top = (PINDEX_LOOKUP_STACK)((PCHAR)IndexContext->Top + Relocation);
    *Sp = (PINDEX_LOOKUP_STACK)((PCHAR)*Sp + Relocation);

    //
    //  Finally update context to describe new stack
    //

    IndexContext->Base = NewLookupStack;
    IndexContext->NumberEntries = NumberEntries;
}


BOOLEAN
ReadIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG IndexBlock,
    IN BOOLEAN Reread,
    OUT PINDEX_LOOKUP_STACK Sp
    )

/*++

Routine Description:

    This routine reads the index buffer at the specified Vcn, and initializes
    the stack pointer to describe it.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexBlock - Supplies the index block of this index buffer, ignored if
                 Reread is TRUE.

    Reread - Supplies TRUE if buffer is being reread, and the CapturedLsn
             should be checked.

    Sp - Returns a description of the index buffer read.

Return Value:

    FALSE - if Reread was supplied as TRUE and the Lsn changed
    TRUE - if the buffer was read successfully (or did not change)

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("ReadIndexBuffer\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );

    ASSERT(Sp->Bcb == NULL);

    //
    //  If the attribute stream does not already exist, create it.
    //

    if (Scb->FileObject == NULL) {

        NtfsCreateInternalAttributeStream( IrpContext,
                                           Scb,
                                           TRUE,
                                           &NtfsInternalUseFile[DIRECTORY_FILE_NUMBER] );
    }

    //
    // If Reread is TRUE, then convert the directory entry pointer in the
    // buffer to an offset (to be relocated later) and overwrite the Lbn
    // input parameter with the Lbn in the stack location.
    //

    if (Reread) {
        Sp->IndexEntry = (PINDEX_ENTRY)((PCHAR)Sp->IndexEntry - (PCHAR)Sp->StartOfBuffer);
        IndexBlock = Sp->IndexBlock;
    }

    Sp->IndexBlock = IndexBlock;

    //
    //  The vcn better only have 32 bits, other wise the the test in NtfsMapStream
    //  may not catch this error.
    //

    if (((PLARGE_INTEGER) &IndexBlock)->HighPart != 0) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    NtfsMapStream( IrpContext,
                   Scb,
                   LlBytesFromIndexBlocks( IndexBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                   Scb->ScbType.Index.BytesPerIndexBuffer,
                   &Sp->Bcb,
                   &Sp->StartOfBuffer );

    IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

    if (!NtfsCheckIndexBuffer( Scb, IndexBuffer ) ||
        (IndexBuffer->ThisBlock != IndexBlock)) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    Sp->IndexHeader = &IndexBuffer->IndexHeader;
    if (Reread) {

        if (IndexBuffer->Lsn.QuadPart != Sp->CapturedLsn.QuadPart) {

            NtfsUnpinBcb( IrpContext, &Sp->Bcb );
            DebugTrace( -1, Dbg, ("ReadIndexBuffer->TRUE\n") );
            return FALSE;
        }

        Sp->IndexEntry = (PINDEX_ENTRY)((PCHAR)Sp->IndexEntry + ((PCHAR)Sp->StartOfBuffer - (PCHAR)NULL));

    } else {

        Sp->IndexEntry = NtfsFirstIndexEntry(Sp->IndexHeader);
        Sp->CapturedLsn = IndexBuffer->Lsn;
    }


    DebugTrace( -1, Dbg, ("ReadIndexBuffer->VOID\n") );

    return TRUE;
}


PINDEX_ALLOCATION_BUFFER
GetIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    OUT PINDEX_LOOKUP_STACK Sp,
    OUT PLONGLONG EndOfValidData
    )

/*++

Routine Description:

    This routine allocates and initializes an index buffer, and initializes
    the stack pointer to describe it.

Arguments:

    Scb - Supplies the Scb for the index.

    Sp - Returns a description of the index buffer allocated.

    EndOfValidData - This is the file offset of the end of the allocated buffer.
        This is used to update the valid data length of the stream when the
        block is written.

Return Value:

    Pointer to the Index Buffer allocated.

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    ATTRIBUTE_ENUMERATION_CONTEXT BitMapContext;
    ULONG RecordIndex;
    LONGLONG BufferOffset;

    PUSHORT UsaSequenceNumber;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("GetIndexBuffer\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );

    //
    //  Initialize the BitMap attribute context and insure cleanup on the
    //  way out.
    //

    NtfsInitializeAttributeContext( &BitMapContext );

    try {

        //
        //  Lookup the BITMAP attribute.
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Scb->Fcb,
                                        &Scb->Fcb->FileReference,
                                        $BITMAP,
                                        &Scb->AttributeName,
                                        NULL,
                                        FALSE,
                                        &BitMapContext )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  If the attribute stream does not already exist, create it.
        //

        if (Scb->FileObject == NULL) {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[DIRECTORY_FILE_NUMBER] );
        }

        //
        //  If the allocation for this index has not been initialized yet,
        //  then we must initialize it first.
        //

        if (!Scb->ScbType.Index.AllocationInitialized) {

            ULONG ExtendGranularity = 1;
            ULONG TruncateGranularity = 4;

            if (Scb->ScbType.Index.BytesPerIndexBuffer < Scb->Vcb->BytesPerCluster) {

                ExtendGranularity = Scb->Vcb->BytesPerCluster / Scb->ScbType.Index.BytesPerIndexBuffer;

                if (ExtendGranularity > 4) {

                    TruncateGranularity = ExtendGranularity;
                }
            }

            NtfsInitializeRecordAllocation( IrpContext,
                                            Scb,
                                            &BitMapContext,
                                            Scb->ScbType.Index.BytesPerIndexBuffer,
                                            ExtendGranularity,
                                            TruncateGranularity,
                                            &Scb->ScbType.Index.RecordAllocationContext );

            Scb->ScbType.Index.AllocationInitialized = TRUE;
        }

        //
        //  Now allocate a record.  We always "hint" from the front to keep the
        //  index compact.
        //

        RecordIndex = NtfsAllocateRecord( IrpContext,
                                          &Scb->ScbType.Index.RecordAllocationContext,
                                          &BitMapContext );

        //
        //  Calculate the IndexBlock.
        //

        BufferOffset = Int32x32To64( RecordIndex, Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Now remember the offset of the end of the added record.
        //

        *EndOfValidData = BufferOffset + Scb->ScbType.Index.BytesPerIndexBuffer;

        //
        //  Now pin and zero the buffer, in order to initialize it.
        //

        NtfsPreparePinWriteStream( IrpContext,
                                   Scb,
                                   BufferOffset,
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   TRUE,
                                   &Sp->Bcb,
                                   (PVOID *)&IndexBuffer );


        //
        //  Now we can fill in the lookup stack.
        //

        Sp->StartOfBuffer = (PVOID)IndexBuffer;
        Sp->IndexHeader = &IndexBuffer->IndexHeader;
        Sp->IndexEntry = (PINDEX_ENTRY)NULL;

        //
        //  Initialize the Index Allocation Buffer and return.
        //

        *(PULONG)IndexBuffer->MultiSectorHeader.Signature = *(PULONG)IndexSignature;

        IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset =
          (USHORT)FIELD_OFFSET( INDEX_ALLOCATION_BUFFER, UpdateSequenceArray );
        IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize =
            (USHORT)UpdateSequenceArraySize( Scb->ScbType.Index.BytesPerIndexBuffer );

        UsaSequenceNumber = Add2Ptr( IndexBuffer,
                                     IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset );
        *UsaSequenceNumber = 1;


        IndexBuffer->ThisBlock = RecordIndex * Scb->ScbType.Index.BlocksPerIndexBuffer;

        IndexBuffer->IndexHeader.FirstIndexEntry =
        IndexBuffer->IndexHeader.FirstFreeByte =
          QuadAlign((ULONG)IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset +
            (ULONG)IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize * sizeof(USHORT)) -
            FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader);;
        IndexBuffer->IndexHeader.BytesAvailable =
          Scb->ScbType.Index.BytesPerIndexBuffer -
          FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader);;

    } finally {

        DebugUnwind( GetIndexBuffer );

        NtfsCleanupAttributeContext( IrpContext, &BitMapContext );
    }

    DebugTrace( -1, Dbg, ("GetIndexBuffer -> %08lx\n", IndexBuffer) );
    return IndexBuffer;
}


VOID
DeleteIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN IndexBlockNumber
    )

/*++

Routine Description:

    This routine deletes the specified index buffer.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexBuffer - Pointer to the index buffer to delete.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT BitMapContext;
    LONGLONG RecordIndex;
    PATTRIBUTE_RECORD_HEADER BitmapAttribute;
    BOOLEAN AttributeWasResident = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DeleteIndexBuffer\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexBlockNumber = %08lx\n", IndexBlockNumber) );

    //
    //  Initialize the BitMap attribute context and insure cleanup on the
    //  way out.
    //

    NtfsInitializeAttributeContext( &BitMapContext );

    try {

        //
        //  Lookup the BITMAP attribute.
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Scb->Fcb,
                                        &Scb->Fcb->FileReference,
                                        $BITMAP,
                                        &Scb->AttributeName,
                                        NULL,
                                        FALSE,
                                        &BitMapContext )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Remember if the bitmap attribute is currently resident,
        //  in case it changes.
        //

        BitmapAttribute = NtfsFoundAttribute(&BitMapContext);
        AttributeWasResident = BitmapAttribute->FormCode == RESIDENT_FORM;

        //
        //  If the allocation for this index has not been initialized yet,
        //  then we must initialize it first.
        //

        if (!Scb->ScbType.Index.AllocationInitialized) {

            ULONG ExtendGranularity = 1;
            ULONG TruncateGranularity = 4;

            if (Scb->ScbType.Index.BytesPerIndexBuffer < Scb->Vcb->BytesPerCluster) {

                ExtendGranularity = Scb->Vcb->BytesPerCluster / Scb->ScbType.Index.BytesPerIndexBuffer;

                if (ExtendGranularity > 4) {

                    TruncateGranularity = ExtendGranularity;
                }
            }

            NtfsInitializeRecordAllocation( IrpContext,
                                            Scb,
                                            &BitMapContext,
                                            Scb->ScbType.Index.BytesPerIndexBuffer,
                                            ExtendGranularity,
                                            TruncateGranularity,
                                            &Scb->ScbType.Index.RecordAllocationContext );

            Scb->ScbType.Index.AllocationInitialized = TRUE;
        }

        //
        //  Calculate the record index for this buffer.
        //

        RecordIndex = IndexBlockNumber / Scb->ScbType.Index.BlocksPerIndexBuffer;


        if (((PLARGE_INTEGER)&RecordIndex)->HighPart != 0) {
            ASSERT( ((PLARGE_INTEGER)&RecordIndex)->HighPart == 0 );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Now deallocate the record.
        //

        NtfsDeallocateRecord( IrpContext,
                              &Scb->ScbType.Index.RecordAllocationContext,
                              (ULONG)RecordIndex,
                              &BitMapContext );

    } finally {

        DebugUnwind( DeleteIndexBuffer );

        //
        //  In the extremely rare case that the bitmap attribute was resident
        //  and now became nonresident, we will uninitialize it here so that
        //  the next time we will find the bitmap Scb, etc.
        //

        if (AttributeWasResident) {

            BitmapAttribute = NtfsFoundAttribute(&BitMapContext);

            if (BitmapAttribute->FormCode != RESIDENT_FORM) {

                NtfsUninitializeRecordAllocation( IrpContext,
                                                  &Scb->ScbType.Index.RecordAllocationContext );

                Scb->ScbType.Index.AllocationInitialized = FALSE;
            }
        }

        NtfsCleanupAttributeContext( IrpContext, &BitMapContext );
    }
    DebugTrace( -1, Dbg, ("DeleteIndexBuffer -> VOID\n") );
}


VOID
FindFirstIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine finds the the first entry in a leaf buffer of an Index Btree
    which could possibly be a match for the input value.  Another way to state
    this is that this routine establishes a position in the Btree from which a
    tree walk should begin to find the desired value or all desired values which
    match the input value specification.

    As stated, the context on return will always describe a pointer in a leaf
    buffer.  This is occassionally inefficient in the 2% case where a specific
    value is being looked up that happens to reside in an intermediate node buffer.
    However, for index adds and deletes, this pointer is always very interesting.
    For an add, this pointer always describes the exact spot at which the add should
    occur (adds must always occur in leafs).  For deletes, this pointer is either
    to the exact index entry which is to be deleted, or else it points to the best
    replacement for the target to delete, when the actual target is at an intermediate
    spot in the tree.

    So this routine descends from the root of the index to the correct leaf, doing
    a binary search in each index buffer along the way (via an external routine).

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Pointer to a value or value expression which should be used to position
            the IndexContext, or NULL to just describe the root for pushing.

    IndexContext - Address of the initialized IndexContext, to return the desired
                   position.

Return Value:

    None.

--*/

{
    PINDEX_LOOKUP_STACK Sp;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PINDEX_ROOT IndexRoot;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("FindFirstIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Lookup the attribute record from the Scb.
    //

    if (!NtfsLookupAttributeByName( IrpContext,
                                    Scb->Fcb,
                                    &Scb->Fcb->FileReference,
                                    $INDEX_ROOT,
                                    &Scb->AttributeName,
                                    NULL,
                                    FALSE,
                                    &IndexContext->AttributeContext )) {

        DebugTrace( -1, 0, ("FindFirstIndexEntry - Could *not* find attribute\n") );

        NtfsRaiseStatus( IrpContext, STATUS_OBJECT_PATH_NOT_FOUND, NULL, NULL );
    }

    //
    //  Save Lsn of file record containing Index Root so that later
    //  we can tell if we need to re-find it.
    //

    IndexContext->IndexRootFileRecordLsn =
        IndexContext->AttributeContext.FoundAttribute.FileRecord->Lsn;

    //
    //  Now Initialize some local pointers and the rest of the context
    //

    Sp = IndexContext->Base;
    Sp->StartOfBuffer = NtfsContainingFileRecord( &IndexContext->AttributeContext );
    Sp->CapturedLsn = ((PFILE_RECORD_SEGMENT_HEADER)Sp->StartOfBuffer)->Lsn;
    IndexContext->ScbChangeCount = Scb->ScbType.Index.ChangeCount;
    IndexContext->OldAttribute =
    Attribute = NtfsFoundAttribute( &IndexContext->AttributeContext );
    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue( Attribute );
    Sp->IndexHeader = &IndexRoot->IndexHeader;

    //
    //  The Index part of the Scb may not yet be initialized.  If so, do it
    //  here.
    //

    if (Scb->ScbType.Index.BytesPerIndexBuffer == 0) {

        NtfsUpdateIndexScbFromAttribute( IrpContext, Scb, Attribute, FALSE );
    }

    //
    //  If Value is not specified, this is a special call from NtfsPushIndexRoot.
    //

    if (!ARGUMENT_PRESENT(Value)) {

        Sp->IndexEntry = NtfsFirstIndexEntry(Sp->IndexHeader);
        IndexContext->Top =
        IndexContext->Current = Sp;
        DebugTrace( -1, 0, ("FindFirstIndexEntry - No Value specified\n") );
        return;
    }

    //
    //  Loop through the Lookup stack as we descend the binary tree doing an
    //  IgnoreCase lookup of the specified value.
    //

    while (TRUE) {

        //
        //  Binary search in the current buffer for the first entry <= value.
        //

        Sp->IndexEntry = BinarySearchIndex( IrpContext,
                                            Scb,
                                            Sp,
                                            Value );

        //
        //  If this entry is not a node, then we are done.
        //

        if (!FlagOn( Sp->IndexEntry->Flags, INDEX_ENTRY_NODE )) {

            IndexContext->Top =
            IndexContext->Current = Sp;

            //
            //  Check for and mark corrupt if we find an empty leaf.
            //

            if ((Sp != IndexContext->Base)

                    &&

                FlagOn(NtfsFirstIndexEntry(Sp->IndexHeader)->Flags, INDEX_ENTRY_END)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
            }

            DebugTrace( -1, Dbg, ("FindFirstIndexEntry -> VOID\n") );

            return;
        }

        //
        //  Check for special case where we preemptively push the root.
        //  Otherwise we can find ourselves recursively in NtfsAllocateRecord
        //  and NtfsAddAllocation, etc., on a buffer split which needs to push
        //  the root to add to the index allocation.
        //
        //  First off, we only need to check this the first time through
        //  the loop, and only if the caller has the Scb exclusive.
        //

        if ((Sp == IndexContext->Base) &&
            NtfsIsExclusiveScb(Scb) &&
            !FlagOn( Scb->Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS)) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            FileRecord = NtfsContainingFileRecord(&IndexContext->AttributeContext);

            //
            //  Only do the push if there are not enough bytes to allocate a
            //  record, and the root is already a node with down pointers, and
            //  the root is "big enough to move".
            //
            //  This means this path will typically only kick in with directories
            //  with at least 200 files or so!
            //

            if (((FileRecord->BytesAvailable - FileRecord->FirstFreeByte) < (sizeof( ATTRIBUTE_LIST_ENTRY ) - sizeof( WCHAR ) + Scb->AttributeName.Length)) &&
                FlagOn(IndexRoot->IndexHeader.Flags, INDEX_NODE) &&
                (Attribute->RecordLength >= Scb->Vcb->BigEnoughToMove)) {

                //
                //  Check if we want to defer pushing the root.
                //

                if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_FORCE_PUSH )) {

                    //
                    //  Our insertion point will now also be pushed, so we
                    //  have to increment the stack pointer.
                    //

                    Sp += 1;

                    if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {
                        NtfsGrowLookupStack( Scb,
                                             IndexContext,
                                             &Sp );
                    }

                    PushIndexRoot( IrpContext, Scb, IndexContext );

                } else {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_PUSH );
                }
            }
        }

        //
        //  If the lookup stack is exhausted, grow the lookup stack.
        //

        Sp += 1;
        if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {
            NtfsGrowLookupStack( Scb,
                                 IndexContext,
                                 &Sp );
        }

        //
        //  Otherwise, read the index buffer pointed to by the current
        //  Index Entry.
        //

        ReadIndexBuffer( IrpContext,
                         Scb,
                         NtfsIndexEntryBlock((Sp-1)->IndexEntry),
                         FALSE,
                         Sp );
    }
}


BOOLEAN
FindNextIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN ValueContainsWildcards,
    IN BOOLEAN IgnoreCase,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN BOOLEAN NextFlag,
    OUT PBOOLEAN MustRestart OPTIONAL
    )

/*++

Routine Description:

    This routine performs a pre-order traversal of an index, starting from the
    current position described by the index context, looking for the next match
    for the input value, or the first value that indicates no further matches are
    possible.  Pre-order refers to the fact that starting at any given index entry,
    we visit any descendents of that index entry first before visiting the index
    entry itself, since all descendent index entries are lexigraphically less than
    their parent index entry.  A visit to an index entry is defined as either
    detecting that the given index entry is the special end entry, or else testing
    whether the index entry is a match for the input value expression.

    The traversal either terminates successfully (returning TRUE) or unsuccessfully
    (returning FALSE).  It terminates successfully if a match is found and being
    returned; in this case FindNextIndexEntry may be called again to look for the
    next match.  It terminates unsuccessfully if either the End entry is encountered
    in the index root, or if an entry is found which is lexigraphically greater than
    the input value, when compared ignoring case (if relevant).

    The traversal is driven like a state machine driven by the index context, as
    initialized from the preceding call to FindFirstIndexEntry, or as left from the
    last call to this routine.  The traversal algorithm is explained in comments
    below.

    The caller may specify whether it wants the current match to be returned (or
    returned again), as described by the current state of the index context.  Or it
    may specify (with NextFlag TRUE) that it wishes to get the next match.  Even if
    NextFlag is FALSE, the currently described index entry will not be returned if
    it is not a match.

Arguments:

    Scb - Supplies the Scb for the index.

    Value - Pointer to a value or value expression which should be used to position
            the IndexContext.  This value is already upcased if we are doing
            an IgnoreCase compare and the value contains wildcards.  Otherwise
            the direct compare routine will upcase both values.

    ValueContainsWildCards - Indicates if the value expression contains wild
                             cards.  We can do a direct compare if it
                             doesn't.

    IgnoreCase - Specified as TRUE if a case-insensitive match is desired (if
                 relevant for the collation rule).

    IndexContext - Address of the initialized IndexContext, to return the desired
                   position.

    NextFlag - Specified as FALSE if the currently described entry should be returned
               if it is a match, or TRUE if the next entry should first be considered
               for a match.

    MustRestart - If specified and returning FALSE, returns TRUE if enumeration must
                  be restarted.

Return Value:

    FALSE - if no entry is being returned, and there are no more matches.
    TRUE - if an entry is being returned, and the caller may wish to call for further
           matches.

--*/

{
    PINDEX_ENTRY IndexEntry;
    PINDEX_LOOKUP_STACK Sp;
    FSRTL_COMPARISON_RESULT BlindResult;
    BOOLEAN LocalMustRestart;
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("FindNextIndexEntry\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );
    DebugTrace( 0, Dbg, ("NextFlag = %02lx\n", NextFlag) );

    if (!ARGUMENT_PRESENT(MustRestart)) {
        MustRestart = &LocalMustRestart;
    }

    *MustRestart = FALSE;

    if (IndexContext->ScbChangeCount != Scb->ScbType.Index.ChangeCount) {

        DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

        *MustRestart = TRUE;
        return FALSE;
    }

    Sp = IndexContext->Current;

    //
    //  If there is no Bcb for the current buffer, then we are continuing
    //  an enumeration.
    //

    if (Sp->Bcb == NULL) {

        //
        //  Index Root case.
        //

        if (Sp == IndexContext->Base) {

            //
            //  Lookup the attribute record from the Scb.
            //

            FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

            //
            //  Get out if someone has changed the file record.
            //

            if (Sp->CapturedLsn.QuadPart !=
                NtfsContainingFileRecord(&IndexContext->AttributeContext)->Lsn.QuadPart) {

                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                *MustRestart = TRUE;
                return FALSE;
            }

        //
        //  Index Buffer case.
        //

        } else {

            //
            //  If the index buffer is unpinned, then see if we can read it and if it is
            //  unchanged.
            //

            if (!ReadIndexBuffer( IrpContext, Scb, 0, TRUE, Sp )) {

                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                *MustRestart = TRUE;
                return FALSE;
            }
        }
    }

    //
    //  Load up some locals.
    //

    IndexEntry = Sp->IndexEntry;

    //
    //  Loop until we hit a non-end record which is case-insensitive
    //  lexicgraphically greater than the target string.  We also pop
    //  out the middle if we encounter the end record in the Index Root.
    //

    do {

        //
        //  We last left our hero potentially somewhere in the middle of the
        //  Btree.  If he is asking for the next record, we advance one entry
        //  in the current Index Buffer.  If we are in an intermediate
        //  Index Buffer (there is a Btree Vcn), then we must move down
        //  through the first record in each intermediate Buffer until we hit
        //  the first leaf buffer (no Btree Vcn).
        //

        if (NextFlag) {

            LONGLONG IndexBlock;

            if (IndexEntry->Length == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            Sp->IndexEntry =
            IndexEntry = NtfsNextIndexEntry( IndexEntry );

            NtfsCheckIndexBound( IndexEntry, Sp->IndexHeader );

            while (FlagOn(IndexEntry->Flags, INDEX_ENTRY_NODE)) {

                IndexBlock = NtfsIndexEntryBlock(IndexEntry);
                Sp += 1;

                //
                //  If the tree is balanced we cannot go too far here.
                //

                if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {

                    ASSERT(Sp < IndexContext->Base + (ULONG)IndexContext->NumberEntries);

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                NtfsUnpinBcb( IrpContext, &Sp->Bcb );

                ReadIndexBuffer( IrpContext,
                                 Scb,
                                 IndexBlock,
                                 FALSE,
                                 Sp );

                IndexEntry = Sp->IndexEntry;
                NtfsCheckIndexBound( IndexEntry, Sp->IndexHeader );
            }

            //
            //  Check for and mark corrupt if we find an empty leaf.
            //

            if ((Sp != IndexContext->Base)

                    &&

                FlagOn(NtfsFirstIndexEntry(Sp->IndexHeader)->Flags, INDEX_ENTRY_END)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
        }

        //
        //  We could be pointing to an end record, either because of
        //  FindFirstIndexEntry or because NextFlag was TRUE, and we
        //  bumped our pointer to an end record.  At any rate, if so, we
        //  move up the tree, rereading as required, until we find an entry
        //  which is not an end record, or until we hit the end record in the
        //  root, which means we hit the end of the Index.
        //

        while (FlagOn(IndexEntry->Flags, INDEX_ENTRY_END)) {

            if (Sp == IndexContext->Base) {

                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (End of Index)\n") );

                return FALSE;
            }

            Sp -= 1;

            //
            //  If there is no Bcb for the current buffer, then we are continuing
            //  an enumeration.
            //

            if (Sp->Bcb == NULL) {

                //
                //  Index Root case.
                //

                if (Sp == IndexContext->Base) {

                    //
                    //  Lookup the attribute record from the Scb.
                    //

                    FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

                    //
                    //  Get out if someone has changed the file record.
                    //

                    if (Sp->CapturedLsn.QuadPart !=
                        NtfsContainingFileRecord(&IndexContext->AttributeContext)->Lsn.QuadPart) {

                        DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                        *MustRestart = TRUE;
                        return FALSE;
                    }

                //
                //  Index Buffer case.
                //

                } else {

                    //
                    //  If the index buffer is unpinned, then see if we can read it and if it is
                    //  unchanged.
                    //

                    if (!ReadIndexBuffer( IrpContext, Scb, 0, TRUE, Sp )) {

                        DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (must restart)\n") );

                        *MustRestart = TRUE;
                        return FALSE;
                    }
                }
            }

            IndexEntry = Sp->IndexEntry;
            NtfsCheckIndexBound( IndexEntry, Sp->IndexHeader );
        }

        //
        //  For a view Index, we either need to call the MatchFunction in the Index
        //  Context (if ValueContainsWildCards is TRUE), or else we look for equality
        //  from the CollateFunction in the Scb.
        //

        if (FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

            INDEX_ROW IndexRow;
            NTSTATUS Status;

            IndexRow.KeyPart.Key = IndexEntry + 1;
            IndexRow.KeyPart.KeyLength = IndexEntry->AttributeLength;

            //
            //  Now, if ValueContainsWildcards is TRUE, then we are doing multiple
            //  returns via the match function (for NtOfsReadRecords).
            //

            if (ValueContainsWildcards) {

                IndexRow.DataPart.Data = Add2Ptr( IndexEntry, IndexEntry->DataOffset );
                IndexRow.DataPart.DataLength = IndexEntry->DataLength;

                if ((Status = IndexContext->MatchFunction(&IndexRow,
                                                          IndexContext->MatchData)) == STATUS_SUCCESS) {

                    IndexContext->Current = Sp;
                    Sp->IndexEntry = IndexEntry;

                    return TRUE;

                //
                //  Get out if no more matches.
                //

                } else if (Status == STATUS_NO_MORE_MATCHES) {
                    return FALSE;
                }
                BlindResult = GreaterThan;

            //
            //  Otherwise, we are looking for an exact match via the CollateFunction.
            //

            } else {

                if ((BlindResult =
                     Scb->ScbType.Index.CollationFunction((PINDEX_KEY)Value,
                                                          &IndexRow.KeyPart,
                                                          Scb->ScbType.Index.CollationData)) == EqualTo) {

                    IndexContext->Current = Sp;
                    Sp->IndexEntry = IndexEntry;

                    return TRUE;
                }
            }

        //
        //  At this point, we have a real live entry that we have to check
        //  for a match.  Describe its name, see if its a match, and return
        //  TRUE if it is.
        //

        } else if (ValueContainsWildcards) {

            if ((*NtfsIsInExpression[Scb->ScbType.Index.CollationRule])
                                     ( UpcaseTable,
                                       Value,
                                       IndexEntry,
                                       IgnoreCase )) {

                IndexContext->Current = Sp;
                Sp->IndexEntry = IndexEntry;

                DebugTrace( 0, Dbg, ("IndexEntry < %08lx\n", IndexEntry) );
                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> TRUE\n") );

                return TRUE;
            }

        } else {

            if ((*NtfsIsEqual[Scb->ScbType.Index.CollationRule])
                              ( UpcaseTable,
                                Value,
                                IndexEntry,
                                IgnoreCase )) {

                IndexContext->Current = Sp;
                Sp->IndexEntry = IndexEntry;

                DebugTrace( 0, Dbg, ("IndexEntry < %08lx\n", IndexEntry) );
                DebugTrace( -1, Dbg, ("FindNextIndexEntry -> TRUE\n") );

                return TRUE;
            }
        }

        //
        //  If we loop back up, we must set NextFlag to TRUE.  We are
        //  currently on a valid non-end entry now.  Before looping back,
        //  check to see if we are beyond end of Target string by doing
        //  a case blind compare (IgnoreCase == TRUE).
        //

        NextFlag = TRUE;

        //
        //  For enumerations in view indices, keep going and only terminate
        //  on the MatchFunction (BlindResult was set to GreaterThan above).
        //  If it is not an enumeration (no wild cards), we already set BlindResult
        //  when we called the colation routine above.
        //

        if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

            BlindResult = (*NtfsCompareValues[Scb->ScbType.Index.CollationRule])
                                              ( UpcaseTable,
                                                UpcaseTableSize,
                                                Value,
                                                IndexEntry,
                                                GreaterThan,
                                                TRUE );
        }

    //
    //  The following while clause is not as bad as it looks, and it will
    //  evaluate quickly for the IgnoreCase == TRUE case.  We have
    //  already done an IgnoreCase compare above, and stored the result
    //  in BlindResult.
    //
    //  If we are doing an IgnoreCase TRUE find, we should keep going if
    //  BlindResult is either GreaterThan or EqualTo.
    //
    //  If we are doing an IgnoreCase FALSE scan, then also continue if
    //  BlindResult is GreaterThan, but if BlindResult is EqualTo, we
    //  can only proceed if we are also GreaterThan or EqualTo case
    //  sensitive (i.e. != LessThan).  This means that the Compare Values
    //  call in the following expresssion will never occur in an IgnoreCase
    //  TRUE scan (Windows default).
    //

    } while ((BlindResult == GreaterThan)

                    ||

             ((BlindResult == EqualTo)

                        &&

                (IgnoreCase

                            ||

                ((*NtfsCompareValues[Scb->ScbType.Index.CollationRule])
                                                         ( UpcaseTable,
                                                           UpcaseTableSize,
                                                           Value,
                                                           IndexEntry,
                                                           GreaterThan,
                                                           FALSE ) != LessThan))));

    DebugTrace( -1, Dbg, ("FindNextIndexEntry -> FALSE (end of expression)\n") );

    return FALSE;
}


//
//  Internal routine
//

PATTRIBUTE_RECORD_HEADER
FindMoveableIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine looks up the index root attribute again after it has potentially
    moved.  As a side effect it reloads any other fields in the index context that
    could have changed, so callers should always call this routine first before
    accessing the other values.

Arguments:

    Scb - Scb for the index

    IndexContext - The index context assumed to already be pointing to the
                   active search path

Return Value:

    The address of the Index Root attribute record header.

--*/

{
    PATTRIBUTE_RECORD_HEADER OldAttribute, Attribute;
    PINDEX_ROOT IndexRoot;
    PBCB SavedBcb;
    BOOLEAN Found;

    PAGED_CODE();

    //
    //  Check to see if the captured Lsn in the IndexContext matches
    //  the one currently in the file record.  If it does match, then
    //  we know that the Index Root cannot possibly have moved and that
    //  the information in IndexContext->AttributeContext is up-to-date.
    //

    if (
        //
        //  There's a pointer to a file record
        //

        IndexContext->AttributeContext.FoundAttribute.FileRecord != NULL &&

        //
        //  Quad parts of Lsn match
        //

        IndexContext->IndexRootFileRecordLsn.QuadPart ==
            IndexContext->AttributeContext.FoundAttribute.FileRecord->Lsn.QuadPart) {

        return NtfsFoundAttribute(&IndexContext->AttributeContext);

    }

    OldAttribute = IndexContext->OldAttribute;

    //
    //  Temporarily save the Bcb for the index root, and unpin at the end,
    //  so that it does not get unexpectedly unmapped and remapped when our
    //  caller knows it can't actually move.
    //

    SavedBcb = IndexContext->AttributeContext.FoundAttribute.Bcb;
    IndexContext->AttributeContext.FoundAttribute.Bcb = NULL;

    NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
    NtfsInitializeAttributeContext( &IndexContext->AttributeContext );

    try {

        Found =
        NtfsLookupAttributeByName( IrpContext,
                                   Scb->Fcb,
                                   &Scb->Fcb->FileReference,
                                   $INDEX_ROOT,
                                   &Scb->AttributeName,
                                   NULL,
                                   FALSE,
                                   &IndexContext->AttributeContext );

        ASSERT(Found);

        //
        //  Now we have to reload our attribute pointer and point to the root
        //

        IndexContext->OldAttribute =
            Attribute = NtfsFoundAttribute(&IndexContext->AttributeContext);
        IndexRoot = (PINDEX_ROOT)NtfsAttributeValue(Attribute);

        //
        //  Reload start of buffer and index header appropriately.
        //

        IndexContext->Base->StartOfBuffer =
          (PVOID)NtfsContainingFileRecord(&IndexContext->AttributeContext);

        IndexContext->Base->IndexHeader = &IndexRoot->IndexHeader;

        //
        //  Relocate the index entry on the search path by moving its pointer the
        //  same number of bytes that the attribute moved.
        //

        IndexContext->Base->IndexEntry = (PINDEX_ENTRY)((PCHAR)IndexContext->Base->IndexEntry +
                                                        ((PCHAR)Attribute - (PCHAR)OldAttribute));
        //
        //  Save Lsn of file record containing Index Root so that later
        //  we can tell if we need to re-find it.
        //

        IndexContext->IndexRootFileRecordLsn =
            IndexContext->AttributeContext.FoundAttribute.FileRecord->Lsn;

    } finally {

        NtfsUnpinBcb( IrpContext, &SavedBcb );
    }

    return Attribute;
}


PINDEX_ENTRY
BinarySearchIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_LOOKUP_STACK Sp,
    IN PVOID Value
    )

/*++

Routine Description:

    This routine does a binary search of the current index buffer, for the first entry
    in the buffer which is lexigraphically less than or equal to the input value, when
    compared case-insensitive (if relevant).

Arguments:

    Scb - Supplies the Scb for the index.

    Sp - Supplies a pointer to a lookup stack entry describing the current buffer.

    Value - Pointer to a value or value expression which should be used to position
            the IndexContext.

Return Value:

    None.

--*/

{
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY IndexTemp, IndexLast;
    ULONG LowIndex, HighIndex, TryIndex;
    PINDEX_ENTRY LocalEntries[BINARY_SEARCH_ENTRIES];
    PINDEX_ENTRY *Table = LocalEntries;
    ULONG SizeOfTable = BINARY_SEARCH_ENTRIES;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("BinarySearchIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );

    //
    //  Set up to fill in our binary search vector.
    //

    IndexHeader = Sp->IndexHeader;
    IndexTemp = (PINDEX_ENTRY)((PCHAR)IndexHeader + IndexHeader->FirstIndexEntry);
    IndexLast = (PINDEX_ENTRY)((PCHAR)IndexHeader + IndexHeader->FirstFreeByte);

    //
    //  Check that there will be at least 1 entry in the index.
    //

    if (IndexHeader->FirstIndexEntry >= IndexHeader->FirstFreeByte) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Fill in the binary search vector, first trying our local vector, and
    //  allocating a larger one if we need to.
    //

    HighIndex = 0;
    while (TRUE) {

        while (IndexTemp < IndexLast) {

            //
            //  See if we are about to store off the end of the table.  If
            //  so we will have to go allocate a bigger one.
            //

            if (HighIndex >= SizeOfTable) {
                break;
            }

            Table[HighIndex] = IndexTemp;

            //
            //  Check for a corrupt IndexEntry where the length is zero.  Since
            //  Length is unsigned, we can't test for it being negative.
            //

            if (IndexTemp->Length == 0) {
                if (Table != LocalEntries) {
                    NtfsFreePool( Table );
                }
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            IndexTemp = (PINDEX_ENTRY)((PCHAR)IndexTemp + IndexTemp->Length);
            HighIndex += 1;
        }

        //
        //  If we got them all, then get out.
        //

        if (IndexTemp >= IndexLast) {
            break;
        }

        if (Table != LocalEntries) {

            ASSERT( Table != LocalEntries );
            NtfsFreePool( Table );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        //
        //  Otherwise we have to allocate one.  Calculate the worst case
        //  and allocate it.
        //

        SizeOfTable = (IndexHeader->BytesAvailable /
                        (sizeof(INDEX_ENTRY) + sizeof(LARGE_INTEGER))) + 2;
        Table = (PINDEX_ENTRY *)NtfsAllocatePool(PagedPool, SizeOfTable * sizeof(PINDEX_ENTRY));
        RtlMoveMemory( Table, LocalEntries, BINARY_SEARCH_ENTRIES * sizeof(PINDEX_ENTRY) );
    }

    //
    //  Now do a binary search of the buffer to find the lowest entry
    //  (ignoring case) that is <= to the search value.  During the
    //  binary search, LowIndex is always maintained as the lowest
    //  possible Index Entry that is <=, and HighIndex is maintained as
    //  the highest possible Index that could be the first <= match.
    //  Thus the loop exits when LowIndex == HighIndex.
    //

    ASSERT(HighIndex);

    HighIndex -= 1;
    LowIndex = 0;

    //
    //  For view indices, we collate via the CollationFunction in the Scb.
    //

    if (FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

        INDEX_KEY IndexKey;

        while (LowIndex != HighIndex) {

            TryIndex = LowIndex + (HighIndex - LowIndex) / 2;

            IndexKey.Key = Table[TryIndex] + 1;
            IndexKey.KeyLength = Table[TryIndex]->AttributeLength;

            if (!FlagOn( Table[TryIndex]->Flags, INDEX_ENTRY_END )

                    &&

                (Scb->ScbType.Index.CollationFunction((PINDEX_KEY)Value,
                                                      &IndexKey,
                                                      Scb->ScbType.Index.CollationData) == GreaterThan)) {
                LowIndex = TryIndex + 1;
            }
            else {
                HighIndex = TryIndex;
            }
        }

    } else {

        while (LowIndex != HighIndex) {

            PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
            ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;

            TryIndex = LowIndex + (HighIndex - LowIndex) / 2;

            if (!FlagOn( Table[TryIndex]->Flags, INDEX_ENTRY_END )

                    &&

                (*NtfsCompareValues[Scb->ScbType.Index.CollationRule])
                                    ( UpcaseTable,
                                      UpcaseTableSize,
                                      Value,
                                      Table[TryIndex],
                                      LessThan,
                                      TRUE ) == GreaterThan) {
                LowIndex = TryIndex + 1;
            }
            else {
                HighIndex = TryIndex;
            }
        }
    }

    //
    //  Capture the return pointer and free our binary search table.
    //

    IndexTemp = Table[LowIndex];

    if (Table != LocalEntries) {
        NtfsFreePool( Table );
    }

    //
    //  When we exit the loop, we have the answer.
    //

    DebugTrace( -1, Dbg, ("BinarySearchIndex -> %08lx\n", IndexTemp) );

    return IndexTemp;
}


BOOLEAN
AddToIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN BOOLEAN FindRoot
    )

/*++

Routine Description:

    This routine inserts an index entry into the Btree, possibly performing
    one or more buffer splits as required.

    The caller has positioned the index context to point to the correct
    insertion point in a leaf buffer, via calls to FindFirstIndexEntry and
    FindNextIndexEntry.  The index context thus not only points to the
    insertion point, but it also shows where index entries will have to be
    promoted in the event of buffer splits.

    This routine employs tail-end recursion, to eliminate the cost of nested
    calls.  For the first insert and all potential subsequent inserts due to
    bucket splits, all work is completed at the current level in the Btree,
    and then the InsertIndexEntry input parameter is reloaded (and the lookup
    stack pointer is adjusted), before looping back in the while loop to do
    any necessary insert at the next level in the tree.

    Each pass through the loop dispatches to one of four routines to handle
    the following cases:

        Simple insert in the root
        Push the root down (add one level to the tree) if the root is full
        Simple insert in an index allocation buffer
        Buffer split of a full index allocation buffer

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - pointer to the index entry to insert.

    IndexContext - Index context describing the path to the insertion point.

    QuickIndex - If specified we store the location of the index added.

    FindRoot - Supplies TRUE if the context cannot be trusted and we should find
               the root first.

Return Value:

    FALSE -- if the stack did not have to be pushed
    TRUE -- if the stack was pushed

--*/

{
    PFCB Fcb = Scb->Fcb;
    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;
    BOOLEAN DeleteIt = FALSE;
    BOOLEAN FirstPass = TRUE;
    BOOLEAN StackWasPushed = FALSE;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("AddToIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    try {

        //
        //  This routine uses "tail-end" recursion, so we just want to keep looping
        //  until we do an insert (either in the Index Root or the Index Allocation)
        //  that does not require a split.
        //

        while (TRUE) {

            IndexContext->Current = Sp;

            //
            //  First see if this is an insert in the root or a leaf.
            //

            if (Sp == IndexContext->Base) {

                PFILE_RECORD_SEGMENT_HEADER FileRecord;
                PATTRIBUTE_RECORD_HEADER Attribute;

                FileRecord = (PFILE_RECORD_SEGMENT_HEADER)Sp->StartOfBuffer;
                Attribute = NtfsFoundAttribute(&IndexContext->AttributeContext);

                //
                //  If the caller is telling us we need to look up the root again,
                //  then do so.
                //

                if (FindRoot) {
                    Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
                }

                //
                //  Now see if there is enough room to do a simple insert, or if
                //  there is not enough room, see if we are small enough ourselves
                //  to demand the room be made anyway.
                //

                if ((InsertIndexEntry->Length <=
                     (USHORT) (FileRecord->BytesAvailable - FileRecord->FirstFreeByte))

                        ||

                    ((InsertIndexEntry->Length + Attribute->RecordLength) <
                     Scb->Vcb->BigEnoughToMove)) {

                    //
                    //  If FALSE is returned, then the space was not allocated and
                    //  we have too loop back and try again.  Second time must work.
                    //

                    while (!NtfsChangeAttributeSize( IrpContext,
                                                     Fcb,
                                                     Attribute->RecordLength + InsertIndexEntry->Length,
                                                     &IndexContext->AttributeContext )) {

                        //
                        //  Lookup the attribute again.
                        //

                        Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
                    }

                    InsertSimpleRoot( IrpContext,
                                      Scb,
                                      InsertIndexEntry,
                                      IndexContext );

                    //
                    //  If we have a quick index then store a buffer offset of zero
                    //  to indicate the root index.
                    //

                    if (ARGUMENT_PRESENT( QuickIndex )) {

                        QuickIndex->BufferOffset = 0;
                    }

                    DebugTrace( -1, Dbg, ("AddToIndex -> VOID\n") );

                    ReturnValue = StackWasPushed;
                    leave;

                //
                //  Otherwise we have to push the current root down a level into
                //  the allocation, and try our insert again by looping back.
                //

                } else {

                    //
                    //  Our insertion point will now also be pushed, so we
                    //  have to increment the stack pointer.
                    //

                    Sp += 1;

                    if (Sp >= IndexContext->Base + (ULONG)IndexContext->NumberEntries) {
                        NtfsGrowLookupStack( Scb,
                                             IndexContext,
                                             &Sp );
                    }

                    PushIndexRoot( IrpContext, Scb, IndexContext );
                    StackWasPushed = TRUE;
                    continue;
                }

            //
            //  Otherwise this insert is in the Index Allocation, not the Index
            //  Root.
            //

            } else {

                //
                //  See if there is enough room to do a simple insert.
                //

                if (InsertIndexEntry->Length <=
                    (USHORT)(Sp->IndexHeader->BytesAvailable - Sp->IndexHeader->FirstFreeByte)) {

                    InsertSimpleAllocation( IrpContext,
                                            Scb,
                                            InsertIndexEntry,
                                            Sp,
                                            QuickIndex );

                    DebugTrace( -1, Dbg, ("AddToIndex -> VOID\n") );

                    ReturnValue = StackWasPushed;
                    leave;

                //
                //  Otherwise, we have to do a buffer split in the allocation.
                //

                } else {

                    //
                    //  Call this local routine to do the buffer split.  It
                    //  returns a pointer to a new entry to insert, which is
                    //  allocated in the nonpaged pool.
                    //

                    PINDEX_ENTRY NewInsertIndexEntry;

                    NewInsertIndexEntry =
                        InsertWithBufferSplit( IrpContext,
                                               Scb,
                                               InsertIndexEntry,
                                               IndexContext,
                                               QuickIndex );

                    //
                    //  Remove the old key being inserted if we've
                    //  allocated it.
                    //

                    if (DeleteIt) {

                        NtfsFreePool( InsertIndexEntry );

                    }

                    //
                    //  Clear the QuickIndex pointer so we don't corrupt the captured
                    //  information.
                    //

                    QuickIndex = NULL;

                    //
                    //  Now we have to delete this index entry, since it was dynamically
                    //  allocated by InsertWithBufferSplit.
                    //

                    InsertIndexEntry = NewInsertIndexEntry;
                    DeleteIt = TRUE;

                    //
                    //  The middle entry from the old buffer must now get
                    //  inserted at the insertion point in its parent.
                    //

                    Sp -= 1;
                    continue;
                }
            }
        }
    } finally {

        if (DeleteIt) {

            NtfsFreePool( InsertIndexEntry );

        }
    }

    return ReturnValue;
}


VOID
InsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine is called to do a simple insertion of a new index entry into the
    root, when it is known that it will fit.  It calls a routine common wiht
    restart to do the insert, and then logs the insert.

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - Pointer to the index entry to insert.

    IndexContext - Index context describing the position in the root at which
                   the insert is to occur.

Return Value:

    None

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PINDEX_ENTRY BeforeIndexEntry;
    PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext->AttributeContext;
    PVCB Vcb;
    BOOLEAN Inserted = FALSE;

    PAGED_CODE();

    Vcb = Scb->Vcb;

    DebugTrace( +1, Dbg, ("InsertSimpleRoot\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    try {

        //
        //  Extract all of the updates required by the restart routine we
        //  will call.
        //

        FileRecord = NtfsContainingFileRecord( Context );
        Attribute = NtfsFoundAttribute( Context );
        BeforeIndexEntry = IndexContext->Base->IndexEntry;

        //
        //  Pin the page
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, Context );

        //
        //  Call the same routine used by restart to actually apply the
        //  update.
        //

        NtfsRestartInsertSimpleRoot( IrpContext,
                                     InsertIndexEntry,
                                     FileRecord,
                                     Attribute,
                                     BeforeIndexEntry );

        Inserted = TRUE;

        CheckRoot();

        //
        //  Now that the Index Entry is guaranteed to be in place, log
        //  this update.  Note that the new record is now at the address
        //  we calculated in BeforeIndexEntry.
        //

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      NtfsFoundBcb(Context),
                      AddIndexEntryRoot,
                      BeforeIndexEntry,
                      BeforeIndexEntry->Length,
                      DeleteIndexEntryRoot,
                      NULL,
                      0,
                      NtfsMftOffset( Context ),
                      (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                      (ULONG)((PCHAR)BeforeIndexEntry - (PCHAR)Attribute),
                      Vcb->BytesPerFileRecordSegment );

    } finally {

        DebugUnwind( InsertSimpleRoot );

        //
        //  If we failed after inserting the record, it must be because we failed to write the
        //  log record.  If that happened, then the record will not be
        //  deleted by the transaction abort, so we have to do it here
        //  by hand.
        //

        if (AbnormalTermination() && Inserted) {

            NtfsRestartDeleteSimpleRoot( IrpContext,
                                         BeforeIndexEntry,
                                         FileRecord,
                                         Attribute );
        }

    }

    DebugTrace( -1, Dbg, ("InsertSimpleRoot -> VOID\n") );
}


VOID
NtfsRestartInsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PINDEX_ENTRY BeforeIndexEntry
    )

/*++

Routine Description:

    This is a restart routine used both in normal operation and during restart.
    It is called to do a simple insertion of a new index entry into the
    root, when it is known that it will fit.  It does no logging.

Arguments:

    InsertIndexEntry - Pointer to the index entry to insert.

    FileRecord - Pointer to the file record in which the insert is to occur.

    Attribute - Pointer to the attribute record header for the index root.

    BeforeIndexEntry - Pointer to the index entry which is currently sitting
                       at the point at which the insert is to occur.


Return Value:

    None

--*/

{
    PINDEX_ROOT IndexRoot;
    PINDEX_HEADER IndexHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartInsertSimpleRoot\n") );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );
    DebugTrace( 0, Dbg, ("BeforeIndexEntry = %08lx\n", BeforeIndexEntry) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue(Attribute);
    IndexHeader = &IndexRoot->IndexHeader;

    //
    //  Grow the space for our attribute record as required.
    //

    NtfsRestartChangeAttributeSize( IrpContext,
                                    FileRecord,
                                    Attribute,
                                    Attribute->RecordLength +
                                      InsertIndexEntry->Length );

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( (PCHAR)BeforeIndexEntry + InsertIndexEntry->Length,
                   BeforeIndexEntry,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                    (PCHAR)BeforeIndexEntry );

    //
    //  Move the new Index Entry into place.  The index entry may either
    //  be a complete index entry, or it may be in pointer form.
    //

    if (FlagOn(InsertIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM)) {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, sizeof(INDEX_ENTRY) );
        RtlMoveMemory( (PVOID)(BeforeIndexEntry + 1),
                       *(PVOID *)(InsertIndexEntry + 1),
                       InsertIndexEntry->AttributeLength );

        //
        //  In pointer form the Data Pointer follows the key pointer, but there is
        //  none for normal directory indices.
        //

        if (*(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)) != NULL) {
            RtlMoveMemory( (PVOID)((PCHAR)BeforeIndexEntry + InsertIndexEntry->DataOffset),
                           *(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)),
                           InsertIndexEntry->DataLength );
        }

        ClearFlag( BeforeIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM );

    } else {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, InsertIndexEntry->Length );
    }

    //
    //  Update the index header by the space we grew by.
    //

    Attribute->Form.Resident.ValueLength += InsertIndexEntry->Length;
    IndexHeader->FirstFreeByte += InsertIndexEntry->Length;
    IndexHeader->BytesAvailable += InsertIndexEntry->Length;

    DebugTrace( -1, Dbg, ("NtfsRestartInsertSimpleRoot -> VOID\n") );
}


VOID
PushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine is called to push the index root down a level, thus adding a
    level to the Btree.  If the Index Allocation and Bitmap attributes for this
    index do not already exist, then they are created here prior to pushing the
    root down.  This routine performs the push down and logs the changes (either
    directly or by calling routines which log their own changes).

Arguments:

    Scb - Supplies the Scb for the index.

    IndexContext - Index context describing the position in the root at which
                   the insert is to occur.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AllocationContext;
    ATTRIBUTE_ENUMERATION_CONTEXT BitMapContext;
    LARGE_MCB Mcb;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_HEADER IndexHeaderR, IndexHeaderA;
    PINDEX_LOOKUP_STACK Sp;
    ULONG SizeToMove;
    USHORT AttributeFlags;
    LONGLONG EndOfValidData;

    struct {
        INDEX_ROOT IndexRoot;
        INDEX_ENTRY IndexEntry;
        LONGLONG IndexBlock;
    } R;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("PushIndexRoot\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Initialize everything (only Mcb can fail), then set up to cleanup
    //  on the way out.
    //

    RtlZeroMemory( &R, sizeof(R) );
    FsRtlInitializeLargeMcb( &Mcb, NonPagedPool );
    NtfsInitializeAttributeContext( &AllocationContext );
    NtfsInitializeAttributeContext( &BitMapContext );

    //
    //  Allocate a buffer to save away the current index root, as we will
    //  have to start by deleting it.
    //

    SizeToMove = IndexContext->Base->IndexHeader->FirstFreeByte;
    IndexHeaderR = NtfsAllocatePool(PagedPool, SizeToMove );

    try {

        //
        //  Save away the current index root, then delete it.  This should
        //  insure that we have enough space to create/extend the index allocation
        //  and bitmap attributes.
        //

        AttributeFlags = NtfsFoundAttribute(&IndexContext->AttributeContext)->Flags;
        RtlMoveMemory( IndexHeaderR,
                       IndexContext->Base->IndexHeader,
                       SizeToMove );

        NtfsDeleteAttributeRecord( IrpContext,
                                   Scb->Fcb,
                                   DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION,
                                   &IndexContext->AttributeContext );

        //
        //  If the IndexAllocation isn't there, then we have to create both
        //  the Index Allocation and Bitmap attributes.
        //

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Scb->Fcb,
                                        &Scb->Fcb->FileReference,
                                        $INDEX_ALLOCATION,
                                        &Scb->AttributeName,
                                        NULL,
                                        FALSE,
                                        &AllocationContext )) {

            //
            //  Allocate the Index Allocation attribute.  Always allocate at
            //  least one cluster.
            //

            EndOfValidData = Scb->ScbType.Index.BytesPerIndexBuffer;

            if ((ULONG) EndOfValidData < Scb->Vcb->BytesPerCluster) {

                EndOfValidData = Scb->Vcb->BytesPerCluster;
            }

            NtfsAllocateAttribute( IrpContext,
                                   Scb,
                                   $INDEX_ALLOCATION,
                                   &Scb->AttributeName,
                                   0,
                                   TRUE,
                                   TRUE,
                                   EndOfValidData,
                                   NULL );

            Scb->Header.AllocationSize.QuadPart = EndOfValidData;

            SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

            //
            //  Now create the BitMap attribute.
            //

            NtfsCreateAttributeWithValue( IrpContext,
                                          Scb->Fcb,
                                          $BITMAP,
                                          &Scb->AttributeName,
                                          &Li0,
                                          sizeof(LARGE_INTEGER),
                                          0,
                                          NULL,
                                          TRUE,
                                          &BitMapContext );
        }

        //
        //  Take some pains here to preserve the IndexContext for the case that
        //  we are called from AddToIndex, when it is called from DeleteFromIndex,
        //  because we still need some of the stack then.  The caller must have
        //  insured the stack is big enough for him.  Move all but two entries,
        //  because we do not need to move the root, and we cannot move the last
        //  entry since it would go off the end of the structure!
        //

        ASSERT(IndexContext->NumberEntries > 2);

        //
        //  Do an unpin on the entry that will be overwritten.
        //

        NtfsUnpinBcb( IrpContext, &IndexContext->Base[IndexContext->NumberEntries - 1].Bcb );

        RtlMoveMemory( IndexContext->Base + 2,
                       IndexContext->Base + 1,
                       (IndexContext->NumberEntries - 2) * sizeof(INDEX_LOOKUP_STACK) );

        //
        //  Now point our local pointer to where the root will be pushed to, and
        //  clear the Bcb pointer in the stack there, since it was copied above.
        //  Advance top and current because of the move.
        //

        Sp = IndexContext->Base + 1;
        Sp->Bcb = NULL;
        IndexContext->Top += 1;
        IndexContext->Current += 1;

        //
        //  Allocate a buffer to hold the pushed down entries.
        //

        IndexBuffer = GetIndexBuffer( IrpContext, Scb, Sp, &EndOfValidData );

        //
        //  Point now to the new index header.
        //

        IndexHeaderA = Sp->IndexHeader;

        //
        //  Now do the push down and fix up the IndexEntry pointer for
        //  the new buffer.
        //

        SizeToMove = IndexHeaderR->FirstFreeByte - IndexHeaderR->FirstIndexEntry;
        RtlMoveMemory( NtfsFirstIndexEntry(IndexHeaderA),
                       NtfsFirstIndexEntry(IndexHeaderR),
                       SizeToMove );

        Sp->IndexEntry = (PINDEX_ENTRY)((PCHAR)(Sp-1)->IndexEntry +
                         ((PCHAR)IndexHeaderA - (PCHAR)((Sp-1)->IndexHeader)) +
                         (IndexHeaderA->FirstIndexEntry -
                           IndexHeaderR->FirstIndexEntry));

        IndexHeaderA->FirstFreeByte += SizeToMove;
        IndexHeaderA->Flags = IndexHeaderR->Flags;

        //
        //  Finally, log the pushed down buffer.
        //

        CheckBuffer(IndexBuffer);

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      UpdateNonresidentValue,
                      IndexBuffer,
                      FIELD_OFFSET( INDEX_ALLOCATION_BUFFER,IndexHeader ) +
                        IndexHeaderA->FirstFreeByte,
                      Noop,
                      NULL,
                      0,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      0,
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Remember if we extended the valid data for this Scb.
        //

        if (EndOfValidData > Scb->Header.ValidDataLength.QuadPart) {

            Scb->Header.ValidDataLength.QuadPart = EndOfValidData;

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Now initialize an image of the new root.
        //

        if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {
            R.IndexRoot.IndexedAttributeType = Scb->ScbType.Index.AttributeBeingIndexed;
        } else {
            R.IndexRoot.IndexedAttributeType = $UNUSED;
        }
        R.IndexRoot.CollationRule = (COLLATION_RULE)Scb->ScbType.Index.CollationRule;
        R.IndexRoot.BytesPerIndexBuffer = Scb->ScbType.Index.BytesPerIndexBuffer;
        R.IndexRoot.BlocksPerIndexBuffer = Scb->ScbType.Index.BlocksPerIndexBuffer;
        R.IndexRoot.IndexHeader.FirstIndexEntry = (ULONG)((PCHAR)&R.IndexEntry -
                                                  (PCHAR)&R.IndexRoot.IndexHeader);
        R.IndexRoot.IndexHeader.FirstFreeByte =
        R.IndexRoot.IndexHeader.BytesAvailable = QuadAlign(sizeof(INDEX_HEADER)) +
                                                 QuadAlign(sizeof(INDEX_ENTRY)) +
                                                 sizeof(LONGLONG);
        SetFlag( R.IndexRoot.IndexHeader.Flags, INDEX_NODE );

        R.IndexEntry.Length = sizeof(INDEX_ENTRY) + sizeof(LONGLONG);
        R.IndexEntry.Flags = INDEX_ENTRY_NODE | INDEX_ENTRY_END;
        R.IndexBlock = IndexBuffer->ThisBlock;

        //
        //  Now recreate the index root.
        //

        NtfsCleanupAttributeContext( IrpContext, &IndexContext->AttributeContext );
        NtfsCreateAttributeWithValue( IrpContext,
                                      Scb->Fcb,
                                      $INDEX_ROOT,
                                      &Scb->AttributeName,
                                      (PVOID)&R,
                                      sizeof(R),
                                      AttributeFlags,
                                      NULL,
                                      TRUE,
                                      &IndexContext->AttributeContext );

        //
        //  We just pushed the index root, so let's find it again and
        //  fix up the caller's context.  Note that he will try to
        //  recalculate the IndexEntry pointer, but we know that it
        //  has to change to point to the single entry in the new root.
        //

        FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
        (Sp-1)->IndexEntry = NtfsFirstIndexEntry((Sp-1)->IndexHeader);

    } finally {

        DebugUnwind( PushIndexRoot );

        NtfsFreePool( IndexHeaderR );
        FsRtlUninitializeLargeMcb( &Mcb );
        NtfsCleanupAttributeContext( IrpContext, &AllocationContext );
        NtfsCleanupAttributeContext( IrpContext, &BitMapContext );
    }

    DebugTrace( -1, Dbg, ("PushIndexRoot -> VOID\n") );
}


VOID
InsertSimpleAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_LOOKUP_STACK Sp,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine does a simple insert in an index buffer in the index
    allocation.  It calls a routine common with restart to do the insert,
    and then it logs the change.

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - Address of the index entry to be inserted.

    Sp - Pointer to the lookup stack location describing the insertion
         point.

    QuickIndex - If specified we store the location of the index added.

Return Value:

    None

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_ENTRY BeforeIndexEntry;
    BOOLEAN Inserted = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("InsertSimpleAllocation\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("Sp = %08lx\n", Sp) );

    try {

        //
        //  Extract all of the updates required by the restart routine we
        //  will call.
        //

        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
        BeforeIndexEntry = Sp->IndexEntry;

        //
        //  Pin the page
        //

        NtfsPinMappedData( IrpContext,
                           Scb,
                           LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                           Scb->ScbType.Index.BytesPerIndexBuffer,
                           &Sp->Bcb );

        //
        //  Call the same routine used by restart to actually apply the
        //  update.
        //

        NtfsRestartInsertSimpleAllocation( InsertIndexEntry,
                                           IndexBuffer,
                                           BeforeIndexEntry );
        Inserted = TRUE;

        CheckBuffer(IndexBuffer);

        //
        //  Now that the Index Entry is guaranteed to be in place, log
        //  this update.  Note that the new record is now at the address
        //  we calculated in BeforeIndexEntry.
        //

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      AddIndexEntryAllocation,
                      BeforeIndexEntry,
                      BeforeIndexEntry->Length,
                      DeleteIndexEntryAllocation,
                      NULL,
                      0,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      (ULONG)((PCHAR)BeforeIndexEntry - (PCHAR)IndexBuffer),
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Update the quick index buffer if we have it.
        //

        if (ARGUMENT_PRESENT( QuickIndex )) {

            QuickIndex->ChangeCount = Scb->ScbType.Index.ChangeCount;
            QuickIndex->BufferOffset = PtrOffset( Sp->StartOfBuffer, Sp->IndexEntry );
            QuickIndex->CapturedLsn = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->Lsn;
            QuickIndex->IndexBlock = ((PINDEX_ALLOCATION_BUFFER) Sp->StartOfBuffer)->ThisBlock;
        }

    } finally {

        DebugUnwind( InsertSimpleAllocation );

        //
        //  If we failed and already inserted the item,
        //  it must be because we failed to write the log record.  If that happened,
        //  then the record will not be deleted by the transaction abort,
        //  so we have to do it here by hand.
        //

        if (AbnormalTermination() && Inserted) {

            NtfsRestartDeleteSimpleAllocation( BeforeIndexEntry,
                                               IndexBuffer );
        }

    }

    DebugTrace( -1, Dbg, ("InsertSimpleAllocation -> VOID\n") );
}


VOID
NtfsRestartInsertSimpleAllocation (
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer,
    IN PINDEX_ENTRY BeforeIndexEntry
    )

/*++

Routine Description:

    This routine does a simple insert in an index buffer in the index
    allocation.  It performs this work either in the running system, or
    when called by restart.  It does no logging.

Arguments:

    InsertIndexEntry - Address of the index entry to be inserted.

    IndexBuffer - Pointer to the index buffer into which the insert is to
                  occur.

    BeforeIndexEntry - Pointer to the index entry currently residing at
                       the insertion point.

Return Value:

    None

--*/

{
    PINDEX_HEADER IndexHeader;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartInsertSimpleAllocation\n") );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexBuffer = %08lx\n", IndexBuffer) );
    DebugTrace( 0, Dbg, ("BeforeIndexEntry = %08lx\n", BeforeIndexEntry) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexHeader = &IndexBuffer->IndexHeader;

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( (PCHAR)BeforeIndexEntry + InsertIndexEntry->Length,
                   BeforeIndexEntry,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                    (PCHAR)BeforeIndexEntry );

    //
    //  Move the new Index Entry into place.  The index entry may either
    //  be a complete index entry, or it may be in pointer form.
    //

    if (FlagOn(InsertIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM)) {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, sizeof(INDEX_ENTRY) );
        RtlMoveMemory( (PVOID)(BeforeIndexEntry + 1),
                       *(PVOID *)(InsertIndexEntry + 1),
                       InsertIndexEntry->AttributeLength );

        //
        //  In pointer form the Data Pointer follows the key pointer, but there is
        //  none for normal directory indices.
        //

        if (*(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)) != NULL) {
            RtlMoveMemory( (PVOID)((PCHAR)BeforeIndexEntry + InsertIndexEntry->DataOffset),
                           *(PVOID *)((PCHAR)InsertIndexEntry + sizeof(INDEX_ENTRY) + sizeof(PVOID)),
                           InsertIndexEntry->DataLength );
        }

        ClearFlag( BeforeIndexEntry->Flags, INDEX_ENTRY_POINTER_FORM );

    } else {

        RtlMoveMemory( BeforeIndexEntry, InsertIndexEntry, InsertIndexEntry->Length );
    }

    //
    //  Update the index header by the space we grew by.
    //

    IndexHeader->FirstFreeByte += InsertIndexEntry->Length;

    DebugTrace( -1, Dbg, ("NtfsRestartInsertSimpleAllocation -> VOID\n") );
}


PINDEX_ENTRY
InsertWithBufferSplit (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform an insert in the index allocation, when
    it is known that a buffer split is necessary.  It splits the buffer in
    half, inserts the new entry in the appropriate half, fixes the Vcn pointer
    in the current parent, and returns a pointer to a new entry which is being
    promoted to insert at the next level up.

Arguments:

    Scb - Supplies the Scb for the index.

    InsertIndexEntry - Address of the index entry to be inserted.

    IndexContext - Index context describing the position in the stack at which
                   the insert with split is to occur.

    QuickIndex - If specified we store the location of the index added.

Return Value:

    Pointer to the index entry which must now be inserted at the next level.

--*/

{
    PINDEX_ALLOCATION_BUFFER IndexBuffer, IndexBuffer2;
    PINDEX_HEADER IndexHeader, IndexHeader2;
    PINDEX_ENTRY BeforeIndexEntry, MiddleIndexEntry, MovingIndexEntry;
    PINDEX_ENTRY ReturnIndexEntry = NULL;
    INDEX_LOOKUP_STACK Stack2;
    PINDEX_LOOKUP_STACK Sp;
    ULONG LengthToMove;
    ULONG Buffer2Length;
    LONGLONG EndOfValidData;

    struct {
        INDEX_ENTRY IndexEntry;
        LONGLONG IndexBlock;
    } NewEnd;

    PVCB Vcb;

    Vcb = Scb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("InsertWithBufferSplit\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("InsertIndexEntry = %08lx\n", InsertIndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    Stack2.Bcb = NULL;
    Sp = IndexContext->Current;

    try {

        //
        //  Extract all of the updates required by the restart routine we
        //  will call.
        //

        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
        IndexHeader = &IndexBuffer->IndexHeader;
        BeforeIndexEntry = Sp->IndexEntry;

        //
        //  Pin the page
        //

        NtfsPinMappedData( IrpContext,
                           Scb,
                           LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                           Scb->ScbType.Index.BytesPerIndexBuffer,
                           &Sp->Bcb );

        //
        //  Allocate an index buffer to take the second half of the splitting
        //  one.
        //

        IndexBuffer2 = GetIndexBuffer( IrpContext,
                                       Scb,
                                       &Stack2,
                                       &EndOfValidData );

        IndexHeader2 = &IndexBuffer2->IndexHeader;

        //
        //  Scan to find the middle index entry that we will promote to
        //  the next level up, and the next one after him.
        //

        MiddleIndexEntry = NtfsFirstIndexEntry(IndexHeader);
        NtfsCheckIndexBound( MiddleIndexEntry, IndexHeader );

        if (MiddleIndexEntry->Length == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }

        while (((ULONG)((PCHAR)MiddleIndexEntry - (PCHAR)IndexHeader) +
                 (ULONG)MiddleIndexEntry->Length) < IndexHeader->BytesAvailable / 2) {

            MovingIndexEntry = MiddleIndexEntry;
            MiddleIndexEntry = NtfsNextIndexEntry(MiddleIndexEntry);

            NtfsCheckIndexBound( MiddleIndexEntry, IndexHeader );

            if (MiddleIndexEntry->Length == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }
        }

        //
        //  We found an entry to elevate but if the next entry is the end
        //  record we want to go back one entry.
        //

        if (FlagOn( NtfsNextIndexEntry(MiddleIndexEntry)->Flags, INDEX_ENTRY_END )) {

            MiddleIndexEntry = MovingIndexEntry;
        }
        MovingIndexEntry = NtfsNextIndexEntry(MiddleIndexEntry);

        NtfsCheckIndexBound( MovingIndexEntry, IndexHeader );

        if (MovingIndexEntry->Length == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
        }
        //
        //  Allocate space to hold this middle entry, and copy it out.
        //

        ReturnIndexEntry = NtfsAllocatePool( NonPagedPool,
                                              MiddleIndexEntry->Length +
                                                sizeof(LONGLONG) );
        RtlMoveMemory( ReturnIndexEntry,
                       MiddleIndexEntry,
                       MiddleIndexEntry->Length );

        if (!FlagOn(ReturnIndexEntry->Flags, INDEX_ENTRY_NODE)) {
            SetFlag( ReturnIndexEntry->Flags, INDEX_ENTRY_NODE );
            ReturnIndexEntry->Length += sizeof(LONGLONG);
        }

        //
        //  Now move the second half of the splitting buffer over to the
        //  new one, and fix it up.
        //

        LengthToMove = IndexHeader->FirstFreeByte - (ULONG)((PCHAR)MovingIndexEntry -
                                                     (PCHAR)IndexHeader);

        RtlMoveMemory( NtfsFirstIndexEntry(IndexHeader2),
                       MovingIndexEntry,
                       LengthToMove );

        IndexHeader2->FirstFreeByte += LengthToMove;
        IndexHeader2->Flags = IndexHeader->Flags;

        //
        //  Now the new Index Buffer is done, so lets log its contents.
        //

        Buffer2Length = FIELD_OFFSET( INDEX_ALLOCATION_BUFFER,IndexHeader ) +
                        IndexHeader2->FirstFreeByte;

        CheckBuffer(IndexBuffer2);

        IndexBuffer2->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Stack2.Bcb,
                      UpdateNonresidentValue,
                      IndexBuffer2,
                      Buffer2Length,
                      Noop,
                      NULL,
                      0,
                      LlBytesFromIndexBlocks( IndexBuffer2->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      0,
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Remember if we extended the valid data for this Scb.
        //

        if (EndOfValidData > Scb->Header.ValidDataLength.QuadPart) {

            Scb->Header.ValidDataLength.QuadPart = EndOfValidData;

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Now let's create the image of the new end record for the
        //  splitting index buffer.
        //

        RtlZeroMemory( &NewEnd.IndexEntry, sizeof(INDEX_ENTRY) );
        NewEnd.IndexEntry.Length = sizeof(INDEX_ENTRY);
        NewEnd.IndexEntry.Flags = INDEX_ENTRY_END;

        if (FlagOn(MiddleIndexEntry->Flags, INDEX_ENTRY_NODE)) {
            NewEnd.IndexEntry.Length += sizeof(LONGLONG);
            SetFlag( NewEnd.IndexEntry.Flags, INDEX_ENTRY_NODE );
            NewEnd.IndexBlock = NtfsIndexEntryBlock(MiddleIndexEntry);
        }

        //
        //  Write a log record to set the new end of the splitting buffer.
        //

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      WriteEndOfIndexBuffer,
                      &NewEnd,
                      NewEnd.IndexEntry.Length,
                      WriteEndOfIndexBuffer,
                      MiddleIndexEntry,
                      MiddleIndexEntry->Length + LengthToMove,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      (ULONG)((PCHAR)MiddleIndexEntry - (PCHAR)IndexBuffer),
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Now call the restart routine to write the new end of the index
        //  buffer.
        //

        NtfsRestartWriteEndOfIndex( IndexHeader,
                                    MiddleIndexEntry,
                                    (PINDEX_ENTRY)&NewEnd,
                                    NewEnd.IndexEntry.Length );

        CheckBuffer(IndexBuffer);

        //
        //  Now that we are done splitting IndexBuffer and IndexBuffer2, we
        //  need to figure out which one our original entry was inserting into,
        //  and do the simple insert.  Going into the first half is trivial,
        //  and follows:
        //

        if (BeforeIndexEntry < MovingIndexEntry) {

            InsertSimpleAllocation( IrpContext, Scb, InsertIndexEntry, Sp, QuickIndex );

        //
        //  If it is going into the second half, we just have to fix up the
        //  stack descriptor for the buffer we allocated, and do the insert
        //  there.  To fix it up we just have to do a little arithmetic to
        //  find the insert position.
        //

        } else {

            Stack2.IndexEntry = (PINDEX_ENTRY)((PCHAR)BeforeIndexEntry +
                                  ((PCHAR)NtfsFirstIndexEntry(IndexHeader2) -
                                   (PCHAR)MovingIndexEntry));
            InsertSimpleAllocation( IrpContext,
                                    Scb,
                                    InsertIndexEntry,
                                    &Stack2,
                                    QuickIndex );
        }

        //
        //  Now we just have to set the correct Vcns in the two index entries
        //  that point to IndexBuffer and IndexBuffer2 after the split.  The
        //  first one is easy; its Vcn goes into the IndexEntry we are
        //  returning with to insert in our parent.  The second one we have
        //  have to fix up is the index entry pointing to the buffer that
        //  split, since it must now point to the new buffer.  It should look
        //  like this:
        //
        //      ParentIndexBuffer: ...(ReturnIndexEntry) (ParentIndexEntry)...
        //                                   |                  |
        //                                   |                  |
        //                                   V                  V
        //                               IndexBuffer        IndexBuffer2
        //

        NtfsSetIndexEntryBlock( ReturnIndexEntry, IndexBuffer->ThisBlock );

        //
        //  Decrement our stack pointer to point to the stack entry describing
        //  our parent.
        //

        Sp -= 1;

        //
        //  First handle the case where our parent is the Index Root.
        //

        if (Sp == IndexContext->Base) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;
            PATTRIBUTE_RECORD_HEADER Attribute;
            PATTRIBUTE_ENUMERATION_CONTEXT Context = &IndexContext->AttributeContext;

            Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

            //
            //  Pin the page
            //

            NtfsPinMappedAttribute( IrpContext, Vcb, Context );

            //
            //  Write a log record to change our ParentIndexEntry.
            //

            FileRecord = NtfsContainingFileRecord(Context);

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          SetIndexEntryVcnRoot,
                          &IndexBuffer2->ThisBlock,
                          sizeof(LONGLONG),
                          SetIndexEntryVcnRoot,
                          &IndexBuffer->ThisBlock,
                          sizeof(LONGLONG),
                          NtfsMftOffset( Context ),
                          (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                          (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)Attribute),
                          Vcb->BytesPerFileRecordSegment );

        //
        //  Otherwise, our parent is also an Index Buffer.
        //

        } else {

            PINDEX_ALLOCATION_BUFFER ParentIndexBuffer;

            ParentIndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

            //
            //  Pin the page
            //

            NtfsPinMappedData( IrpContext,
                               Scb,
                               LlBytesFromIndexBlocks( ParentIndexBuffer->ThisBlock,
                                                       Scb->ScbType.Index.IndexBlockByteShift ),
                               Scb->ScbType.Index.BytesPerIndexBuffer,
                               &Sp->Bcb );

            //
            //  Write a log record to change our ParentIndexEntry.
            //

            ParentIndexBuffer->Lsn =
            NtfsWriteLog( IrpContext,
                          Scb,
                          Sp->Bcb,
                          SetIndexEntryVcnAllocation,
                          &IndexBuffer2->ThisBlock,
                          sizeof(LONGLONG),
                          SetIndexEntryVcnAllocation,
                          &IndexBuffer->ThisBlock,
                          sizeof(LONGLONG),
                          LlBytesFromIndexBlocks( ParentIndexBuffer->ThisBlock,
                                                  Scb->ScbType.Index.IndexBlockByteShift ),
                          0,
                          (ULONG)((PCHAR)Sp->IndexEntry - (PCHAR)ParentIndexBuffer),
                          Scb->ScbType.Index.BytesPerIndexBuffer );
        }

        //
        //  Now call the Restart routine to do it.
        //

        NtfsRestartSetIndexBlock( Sp->IndexEntry,
                                  IndexBuffer2->ThisBlock );

    } finally {

        DebugUnwind( InsertWithBufferSplit );

        if (AbnormalTermination( )) {

            if (ReturnIndexEntry != NULL) {

                NtfsFreePool( ReturnIndexEntry );

            }

        }

        NtfsUnpinBcb( IrpContext, &Stack2.Bcb );

    }

    DebugTrace( -1, Dbg, ("InsertWithBufferSplit -> VOID\n") );

    return ReturnIndexEntry;
}


VOID
NtfsRestartWriteEndOfIndex (
    IN PINDEX_HEADER IndexHeader,
    IN PINDEX_ENTRY OverwriteIndexEntry,
    IN PINDEX_ENTRY FirstNewIndexEntry,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is used both in normal operation and at restart to
    update the end of an index buffer, as one of the consequences of
    a buffer split.  Since it is called at restart, it does no logging.

Arguments:

    IndexHeader - Supplies a pointer to the IndexHeader of the buffer
                  whose end is being rewritten.

    OverWriteIndexEntry - Points to the index entry in the buffer at which
                          the overwrite of the end is to occur.

    FirstNewIndexEntry - Points to the first entry in the buffer which is
                         to overwrite the end of the current buffer.

    Length - Supplies the length of the index entries being written to the
             end of the buffer, in bytes.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartWriteEndOfIndex\n") );
    DebugTrace( 0, Dbg, ("IndexHeader = %08lx\n", IndexHeader) );
    DebugTrace( 0, Dbg, ("OverwriteIndexEntry = %08lx\n", OverwriteIndexEntry) );
    DebugTrace( 0, Dbg, ("FirstNewIndexEntry = %08lx\n", FirstNewIndexEntry) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );

    IndexHeader->FirstFreeByte = (ULONG)((PCHAR)OverwriteIndexEntry - (PCHAR)IndexHeader) +
                                 Length;
    RtlMoveMemory( OverwriteIndexEntry, FirstNewIndexEntry, Length );

    DebugTrace( -1, Dbg, ("NtfsRestartWriteEndOfIndex -> VOID\n") );
}


VOID
NtfsRestartSetIndexBlock(
    IN PINDEX_ENTRY IndexEntry,
    IN LONGLONG IndexBlock
    )

/*++

Routine Description:

    This routine updates the IndexBlock in an index entry, for both normal operation and
    restart.  Therefore it does no logging.

Arguments:

    IndexEntry - Supplies a pointer to the index entry whose Vcn is to be overwritten.

    IndexBlock - The index block which is to be written to the index entry.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartSetIndexBlock\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("IndexBlock = %016I64x\n", IndexBlock) );

    NtfsSetIndexEntryBlock( IndexEntry, IndexBlock );

    DebugTrace( -1, Dbg, ("NtfsRestartSetIndexEntryBlock -> VOID\n") );
}


VOID
NtfsRestartUpdateFileName(
    IN PINDEX_ENTRY IndexEntry,
    IN PDUPLICATED_INFORMATION Info
    )

/*++

Routine Description:

    This routine updates the duplicated information in a file name index entry,
    for both normal operation and restart.  Therefore it does no logging.

Arguments:

    IndexEntry - Supplies a pointer to the index entry whose Vcn is to be overwritten.

    Info - Pointer to the duplicated information for the update.

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartUpdateFileName\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("Info = %08lx\n", Info) );

    RtlMoveMemory( &((PFILE_NAME)(IndexEntry + 1))->Info,
                   Info,
                   sizeof(DUPLICATED_INFORMATION) );

    DebugTrace( -1, Dbg, ("NtfsRestartUpdateFileName -> VOID\n") );
}


VOID
DeleteFromIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine deletes an entry from an index, deleting any empty index buffers
    as required.

    The steps are as follows:

        1.  If the entry to be deleted is not a leaf, then find a leaf entry to
            delete which can be used to replace the entry we want to delete.

        2.  Delete the desired index entry, or the replacement we found.  If we
            delete a replacement, remember it for reinsertion later, in step 4 or
            6 below.

        3.  Now prune empty buffers from the tree, if any, starting with the buffer
            we just deleted an entry from.

        4.  If the original target was an intermediate entry, then delete it now,
            and replace it with the entry we deleted in its place in 2 above.  As
            a special case, if all of the descendent buffers of the target went away,
            then we do not have to replace it, so we hang onto the replacement for
            reinsertion.

        5.  When we pruned the index back, we may have stopped on an entry which is
            now childless.  If this is the case, then we have to delete this childless
            entry and reinsert it in the next step.  (If this is the case, then we
            are guaranteed to not still have another entry to reinsert from 2 above!)

        6.  Finally, at this point we may have an entry that needs to be reinserted
            from either step 2 or 5 above.  If so, we do this reinsert now, and we
            are done.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexContext - Describes the entry to delete, including the entire path through
                   it from root to leaf.

Return Value:

    None

--*/

{
    //
    //  It is possible that one or two Index Entries will have to be reinserted.
    //  However, we need to remember at most one at once.
    //

    PINDEX_ENTRY ReinsertEntry = NULL;

    //
    //  A pointer to keep track of where we are in the Index Lookup Stack.
    //

    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;

    //
    //  Some Index entry pointers to remember the next entry to delete, and
    //  the original target if it is an intermediate node.
    //

    PINDEX_ENTRY TargetEntry = NULL;
    PINDEX_ENTRY DeleteEntry;

    //
    //  Two other Lookup Stack pointers we may have to remember.
    //

    PINDEX_LOOKUP_STACK TargetSp;
    PINDEX_LOOKUP_STACK DeleteSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DeleteFromIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Use try-finally to free pool on the way out.
    //

    try {

        //
        //  Step 1.
        //
        //  If we are supposed to delete an entry in an intermediate buffer,
        //  then we have to find in index entry lower in the tree to replace
        //  him.  (In fact we will delete the lower entry first, and get around
        //  to deleting the one we really want to delete later after possibly
        //  pruning the tree back.)  For right now just find the replacement
        //  to delete first, and save him away.
        //

        DeleteEntry = Sp->IndexEntry;
        if (FlagOn(DeleteEntry->Flags, INDEX_ENTRY_NODE)) {

            PINDEX_ALLOCATION_BUFFER IndexBuffer;
            PINDEX_HEADER IndexHeader;
            PINDEX_ENTRY NextEntry;

            //
            //  Remember the real target we need to delete.
            //

            TargetEntry = DeleteEntry;
            TargetSp = Sp;

            //
            //  Go to the top of the stack (bottom of the index) and find the
            //  largest index entry in that buffer to be our replacement.
            //

            Sp =
            IndexContext->Current = IndexContext->Top;

            IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
            IndexHeader = &IndexBuffer->IndexHeader;
            NextEntry = NtfsFirstIndexEntry(IndexHeader);
            NtfsCheckIndexBound( NextEntry, IndexHeader );

            do {

                DeleteEntry = NextEntry;
                NextEntry = NtfsNextIndexEntry(NextEntry);

                NtfsCheckIndexBound( NextEntry, IndexHeader );
                if (NextEntry->Length == 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } while (!FlagOn(NextEntry->Flags, INDEX_ENTRY_END));

            //
            //  Now we have to save this guy away because we will have to
            //  reinsert him later.
            //

            ReinsertEntry = (PINDEX_ENTRY)NtfsAllocatePool( NonPagedPool,
                                                             DeleteEntry->Length +
                                                               sizeof(LONGLONG) );

            RtlMoveMemory( ReinsertEntry, DeleteEntry, DeleteEntry->Length );
        }

        //
        //  Step 2.
        //
        //  Now it's time to delete either our target or replacement entry at
        //  DeleteEntry.
        //

        DeleteSimple( IrpContext, Scb, DeleteEntry, IndexContext );
        DeleteEntry = NULL;

        //
        //  Step 3.
        //
        //  Now we need to see if the tree has to be "pruned" back some to
        //  eliminate any empty buffers.  In the extreme case this routine
        //  returns the root to the state of being an empty directory.  This
        //  routine returns a pointer to DeleteEntry if it leaves an entry
        //  in the tree somewhere which is pointing to a deleted buffer, and
        //  has to be reinserted elsewhere.  We only have to prune if we are
        //  not currently in the root anyway.
        //
        //  Remember the DeleteSp, which is where PruneIndex left the stack
        //  pointer.
        //

        if (Sp != IndexContext->Base) {
            PruneIndex( IrpContext, Scb, IndexContext, &DeleteEntry );
            DeleteSp = IndexContext->Current;
        }

        //
        //  Step 4.
        //
        //  Now we have deleted someone, and possibly pruned the tree back.
        //  It is time to see if our original target has not yet been deleted
        //  yet and deal with that.  First we just delete it, then we see if
        //  we really need to replace it.  If the whole tree under it went
        //  empty (TargetEntry == DeleteEntry), then we do not have to replace
        //  it and we will reinsert its replacement below.  Otherwise, do the
        //  replace now.
        //

        if (TargetEntry != NULL) {

            LONGLONG SavedBlock;

            //
            //  Reload in case root moved
            //

            if (TargetSp == IndexContext->Base) {
                TargetEntry = TargetSp->IndexEntry;
            }

            //
            //  Save the Vcn in case we need it for the reinsert.
            //

            SavedBlock = NtfsIndexEntryBlock(TargetEntry);

            //
            //  Delete it.
            //

            IndexContext->Current = TargetSp;
            DeleteSimple( IrpContext, Scb, TargetEntry, IndexContext );

            //
            //  See if this is exactly the same guy who went childless anyway
            //  when we pruned the tree.  If not replace him now.
            //

            if (TargetEntry != DeleteEntry) {

                //
                //  We know the replacement entry was a leaf, so give him the
                //  block number now.
                //

                SetFlag( ReinsertEntry->Flags, INDEX_ENTRY_NODE );
                ReinsertEntry->Length += sizeof(LONGLONG);
                NtfsSetIndexEntryBlock( ReinsertEntry, SavedBlock );

                //
                //  Now we are all set up to just call our local routine to
                //  go insert our replacement.  If the stack gets pushed,
                //  we have to increment our DeleteSp.
                //

                if (AddToIndex( IrpContext, Scb, ReinsertEntry, IndexContext, NULL, TRUE )) {
                    DeleteSp += 1;
                }

                //
                //  We may need to save someone else away below, but it could
                //  be a different size anyway, so let's just delete the
                //  current ReinsertEntry now.
                //

                NtfsFreePool( ReinsertEntry );
                ReinsertEntry = NULL;

            //
            //  Otherwise, we just deleted the same index entry who went
            //  childless during pruning, so clear our pointer to show that we
            //  so not have to deal with him later.
            //

            } else {

                DeleteEntry = NULL;
            }
        }

        //
        //  Step 5.
        //
        //  Now there may still be a childless entry to deal with after the
        //  pruning above, if it did not turn out to be the guy we were deleting
        //  anyway.  Note that if we have to do this delete, the ReinsertEntry
        //  pointer is guaranteed to be NULL.  If our original target was not
        //  an intermediate node, then we never allocated one to begin with.
        //  Otherwise we passed through the preceding block of code, and either
        //  cleared ReinsertEntry or DeleteEntry.
        //

        if (DeleteEntry != NULL) {

            ASSERT( ReinsertEntry == NULL );

            //
            //  Now we have to save this guy away because we will have to
            //  reinsert him later.
            //

            ReinsertEntry = (PINDEX_ENTRY)NtfsAllocatePool( NonPagedPool,
                                                             DeleteEntry->Length );
            RtlMoveMemory( ReinsertEntry, DeleteEntry, DeleteEntry->Length );

            //
            //  We know the guy we are saving is an intermediate node, and that
            //  we no longer need his Vcn, since we deleted that buffer.  Make
            //  the guy a leaf entry now.  (We don't actually care about the
            //  Vcn, but we do this cleanup here in case the interface to
            //  NtfsAddIndexEntry were to change to take an initialized
            //  index entry.)
            //

            ClearFlag( ReinsertEntry->Flags, INDEX_ENTRY_NODE );
            ReinsertEntry->Length -= sizeof(LONGLONG);

            //
            //  Delete it.
            //

            IndexContext->Current = DeleteSp;
            DeleteSimple( IrpContext, Scb, DeleteEntry, IndexContext );
        }

        //
        //  Step 6.
        //
        //  Finally, we may have someone to reinsert now.  This will either be
        //  someone we deleted as a replacement for our actual target, and then
        //  found out we did not need, or it could be just some entry that we
        //  had to delete just above, because the index buffers below him went
        //  empty and got deleted.
        //
        //  In any case, we can no longer use the IndexContext we were called
        //  with because it no longer indicates where the replacement goes.  We
        //  solve this by calling our top most external entry to do the insert.
        //

        if (ReinsertEntry != NULL) {

            if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {

                NtfsAddIndexEntry( IrpContext,
                                   Scb,
                                   (PVOID)(ReinsertEntry + 1),
                                   NtfsFileNameSize((PFILE_NAME)(ReinsertEntry + 1)),
                                   &ReinsertEntry->FileReference,
                                   NULL,
                                   NULL );

            } else {

                INDEX_ROW IndexRow;

                IndexRow.KeyPart.Key = ReinsertEntry + 1;
                IndexRow.KeyPart.KeyLength = ReinsertEntry->AttributeLength;
                IndexRow.DataPart.Data = Add2Ptr(ReinsertEntry, ReinsertEntry->DataOffset);
                IndexRow.DataPart.DataLength = ReinsertEntry->DataLength;

                NtOfsAddRecords( IrpContext,
                                 Scb,
                                 1,
                                 &IndexRow,
                                 FALSE );
            }
        }

    //
    //  Use the finally clause to free a potential ReinsertEntry we may
    //  have allocated.
    //

    } finally {

        DebugUnwind( DeleteFromIndex );

        if (ReinsertEntry != NULL) {

            NtfsFreePool( ReinsertEntry );
        }
    }

    DebugTrace( -1, Dbg, ("DeleteFromIndex -> VOID\n") );
}


VOID
DeleteSimple (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    )

/*++

Routine Description:

    This routine does a simple insertion of an index entry, from either the
    root or from an index allocation buffer.  It writes the appropriate log
    record first and then calls a routine in common with restart.

Arguments:

    Scb - Supplies the Scb for the index.

    IndexEntry - Points to the index entry to delete.

    IndexContext - Describes the path to the index entry we are deleting.

Return Value:

    None

--*/

{
    PVCB Vcb = Scb->Vcb;
    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("DeleteSimple\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );

    //
    //  Our caller never checks if he is deleting in the root or in the
    //  index allocation, so the first thing we do is check that.
    //
    //  First we will handle the root case.
    //

    if (Sp == IndexContext->Base) {

        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER Attribute;
        PATTRIBUTE_ENUMERATION_CONTEXT Context;

        //
        //  Initialize pointers for the root case.
        //

        Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );

        Context = &IndexContext->AttributeContext;
        FileRecord = NtfsContainingFileRecord( Context );

        //
        //  Pin the page before we start to modify it.
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, Context );

        //
        //  Write the log record first while we can still see the attribute
        //  we are going to delete.
        //

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      NtfsFoundBcb(Context),
                      DeleteIndexEntryRoot,
                      NULL,
                      0,
                      AddIndexEntryRoot,
                      IndexEntry,
                      IndexEntry->Length,
                      NtfsMftOffset( Context ),
                      (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                      (ULONG)((PCHAR)IndexEntry - (PCHAR)Attribute),
                      Vcb->BytesPerFileRecordSegment );

        //
        //  Now call the same routine as Restart to actually delete it.
        //

        NtfsRestartDeleteSimpleRoot( IrpContext, IndexEntry, FileRecord, Attribute );

        CheckRoot();

    //
    //  Otherwise we are deleting in the index allocation, so do that here.
    //

    } else {

        PINDEX_ALLOCATION_BUFFER IndexBuffer;

        //
        //  Get the Index Buffer pointer from the stack.
        //

        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

        //
        //  Pin the page before we start to modify it.
        //

        NtfsPinMappedData( IrpContext,
                           Scb,
                           LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                           Scb->ScbType.Index.BytesPerIndexBuffer,
                           &Sp->Bcb );

        //
        //  Write the log record now while the entry we are deleting is still
        //  there.
        //

        IndexBuffer->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb,
                      Sp->Bcb,
                      DeleteIndexEntryAllocation,
                      NULL,
                      0,
                      AddIndexEntryAllocation,
                      IndexEntry,
                      IndexEntry->Length,
                      LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                      0,
                      (ULONG)((PCHAR)IndexEntry - (PCHAR)IndexBuffer),
                      Scb->ScbType.Index.BytesPerIndexBuffer );

        //
        //  Now call the same routine as Restart to delete the entry.
        //

        NtfsRestartDeleteSimpleAllocation( IndexEntry, IndexBuffer );

        CheckBuffer(IndexBuffer);
    }

    DebugTrace( -1, Dbg, ("DeleteSimple -> VOID\n") );
}


VOID
NtfsRestartDeleteSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY IndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    )

/*++

Routine Description:

    This is a restart routine which does a simple deletion of an index entry
    from the Index Root, without logging.  It is also used at run time.

Arguments:

    IndexEntry - Points to the index entry to delete.

    FileRecord - Points to the file record in which the index root resides.

    Attribute - Points to the attribute record header for the index root.

Return Value:

    None

--*/

{
    PINDEX_ROOT IndexRoot;
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY EntryAfter;
    ULONG SavedLength;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartDeleteSimpleRoot\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexRoot = (PINDEX_ROOT)NtfsAttributeValue(Attribute);
    IndexHeader = &IndexRoot->IndexHeader;
    SavedLength = (ULONG)IndexEntry->Length;
    EntryAfter = NtfsNextIndexEntry(IndexEntry);

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( IndexEntry,
                   EntryAfter,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                     (PCHAR)EntryAfter );

    //
    //  Update the index header by the space we grew by.
    //

    Attribute->Form.Resident.ValueLength -= SavedLength;
    IndexHeader->FirstFreeByte -= SavedLength;
    IndexHeader->BytesAvailable -= SavedLength;

    //
    //  Now shrink the attribute record.
    //

    NtfsRestartChangeAttributeSize( IrpContext,
                                    FileRecord,
                                    Attribute,
                                    Attribute->RecordLength - SavedLength );

    DebugTrace( -1, Dbg, ("NtfsRestartDeleteSimpleRoot -> VOID\n") );
}


VOID
NtfsRestartDeleteSimpleAllocation (
    IN PINDEX_ENTRY IndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    )

/*++

Routine Description:

    This is a restart routine which does a simple deletion of an index entry
    from an index allocation buffer, without logging.  It is also used at run time.

Arguments:

    IndexEntry - Points to the index entry to delete.

    IndexBuffer - Pointer to the index allocation buffer in which the delete is to
                  occur.

Return Value:

    None

--*/

{
    PINDEX_HEADER IndexHeader;
    PINDEX_ENTRY EntryAfter;
    ULONG SavedLength;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartDeleteSimpleAllocation\n") );
    DebugTrace( 0, Dbg, ("IndexEntry = %08lx\n", IndexEntry) );
    DebugTrace( 0, Dbg, ("IndexBuffer = %08lx\n", IndexBuffer) );

    //
    //  Form some pointers within the attribute value.
    //

    IndexHeader = &IndexBuffer->IndexHeader;
    EntryAfter = NtfsNextIndexEntry(IndexEntry);
    SavedLength = (ULONG)IndexEntry->Length;

    //
    //  Now move the tail end of the index to make room for the new entry.
    //

    RtlMoveMemory( IndexEntry,
                   EntryAfter,
                   ((PCHAR)IndexHeader + IndexHeader->FirstFreeByte) -
                    (PCHAR)EntryAfter );

    //
    //  Update the index header by the space we grew by.
    //

    IndexHeader->FirstFreeByte -= SavedLength;

    DebugTrace( -1, Dbg, ("NtfsRestartDeleteSimpleAllocation -> VOID\n") );
}


VOID
PruneIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PINDEX_ENTRY *DeleteEntry
    )

/*++

Routine Description:

    This routine checks if any index buffers need to be deallocated, as the result
    of just having deleted an entry.  The logic of the main loop is described in
    detail below.  All changes are logged.

Arguments:

    Scb - Supplies the Scb of the index.

    IndexContext - describes the path to the index buffer in which the delete just
                   occured.

    DeleteEntry - Returns a pointer to an entry which must be deleted, because all
                  of the buffers below it were deleted.

Return Value:

    None

--*/

{
    PATTRIBUTE_ENUMERATION_CONTEXT Context;
    PINDEX_ALLOCATION_BUFFER IndexBuffer;
    PINDEX_HEADER IndexHeader;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute = NULL;
    PINDEX_LOOKUP_STACK Sp = IndexContext->Current;
    PVCB Vcb = Scb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("PruneIndex\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("IndexContext = %08lx\n", IndexContext) );
    DebugTrace( 0, Dbg, ("DeleteEntry = %08lx\n", DeleteEntry) );

    //
    //  We do not allow ourselves to be called if the index has no
    //  allocation.
    //

    ASSERT( Sp != IndexContext->Base );

    IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;
    IndexHeader = &IndexBuffer->IndexHeader;

    //
    //  Initialize pointers for the root.
    //

    Context = &IndexContext->AttributeContext;

    //
    //  Assume returning NULL.
    //

    *DeleteEntry = NULL;

    //
    //  A pruning we will go...
    //

    while (TRUE) {

        //
        //  The Index Buffer is empty if its first entry is the end record.
        //  If so, delete it, otherwise get out.
        //

        if (FlagOn(NtfsFirstIndexEntry(IndexHeader)->Flags, INDEX_ENTRY_END)) {

            VCN IndexBlockNumber = IndexBuffer->ThisBlock;

            NtfsUnpinBcb( IrpContext, &Sp->Bcb );
            DeleteIndexBuffer( IrpContext, Scb, IndexBlockNumber );

        } else {
            break;
        }

        //
        // We just deleted an Index Buffer, so we have to go up a level
        // in the stack and take care of the Entry that was pointing to it.
        // There are these cases:
        //
        //      1.  If the Entry pointing to the one we deleted is not
        //          an End Entry, then we will remember its address in
        //          *DeleteEntry to cause it to be deleted and reinserted
        //          later.
        //      2.  If the Entry pointing to the one we deleted is an
        //          End Entry, and it is not the Index Root, then we
        //          cannot delete the End Entry, so we get the Vcn
        //          from the entry before the End, store it in the End
        //          record, and make the Entry before the End record
        //          the one returned in *DeleteEntry.
        //      3.  If the current Index Buffer has gone empty, and it is
        //          the index root, then we have an Index just gone
        //          empty.  We have to catch this special case and
        //          transition the Index root back to an empty leaf by
        //          by calling NtfsCreateIndex to reinitialize it.
        //      4.  If there is no Entry before the end record, then the
        //          current Index Buffer is empty.  If it is not the
        //          root, we just let ourselves loop back and delete the
        //          empty buffer in the while statement above.
        //

        Sp -= 1;

        //
        //  When we get back to the root, look it up again because it may
        //  have moved.
        //

        if (Sp == IndexContext->Base) {
            Attribute = FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
        }

        IndexHeader = Sp->IndexHeader;
        IndexBuffer = (PINDEX_ALLOCATION_BUFFER)Sp->StartOfBuffer;

        //
        //  Remember potential entry to delete.
        //

        IndexContext->Current = Sp;
        *DeleteEntry = Sp->IndexEntry;

        //
        //  If the current delete entry is not an end entry, then we have
        //  Case 1 above, and we can break out.
        //

        if (!FlagOn((*DeleteEntry)->Flags, INDEX_ENTRY_END)) {
            break;
        }

        //
        //  If we are pointing to the end record, but it is not the first in
        //  the buffer, then we have Case 2.  We need to find the predecessor
        //  index entry, choose it for deletion, and copy its Vcn to the end
        //  record.
        //

        if (*DeleteEntry != NtfsFirstIndexEntry(IndexHeader)) {

            PINDEX_ENTRY NextEntry;

            NextEntry = NtfsFirstIndexEntry(IndexHeader);
            NtfsCheckIndexBound( NextEntry, IndexHeader );
            do {
                *DeleteEntry = NextEntry;
                NextEntry = NtfsNextIndexEntry(NextEntry);

                NtfsCheckIndexBound( NextEntry, IndexHeader );
                if (NextEntry->Length == 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

            } while (!FlagOn(NextEntry->Flags, INDEX_ENTRY_END));

            //
            //  First handle the case where our parent is the Index Root.
            //

            if (Sp == IndexContext->Base) {

                //
                //  Pin the page
                //

                NtfsPinMappedAttribute( IrpContext, Vcb, Context );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                FileRecord = NtfsContainingFileRecord(Context);

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NtfsFoundBcb(Context),
                              SetIndexEntryVcnRoot,
                              &NtfsIndexEntryBlock(*DeleteEntry),
                              sizeof(LONGLONG),
                              SetIndexEntryVcnRoot,
                              &NtfsIndexEntryBlock(NextEntry),
                              sizeof(LONGLONG),
                              NtfsMftOffset( Context ),
                              (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                              (ULONG)((PCHAR)NextEntry - (PCHAR)Attribute),
                              Vcb->BytesPerFileRecordSegment );

            //
            //  Otherwise, our parent is also an Index Buffer.
            //

            } else {

                //
                //  Pin the page
                //

                NtfsPinMappedData( IrpContext,
                                   Scb,
                                   LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                                   Scb->ScbType.Index.BytesPerIndexBuffer,
                                   &Sp->Bcb );

                //
                //  Write a log record to change our ParentIndexEntry.
                //

                IndexBuffer->Lsn =
                NtfsWriteLog( IrpContext,
                              Scb,
                              Sp->Bcb,
                              SetIndexEntryVcnAllocation,
                              &NtfsIndexEntryBlock(*DeleteEntry),
                              sizeof(LONGLONG),
                              SetIndexEntryVcnAllocation,
                              &NtfsIndexEntryBlock(NextEntry),
                              sizeof(LONGLONG),
                              LlBytesFromIndexBlocks( IndexBuffer->ThisBlock, Scb->ScbType.Index.IndexBlockByteShift ),
                              0,
                              (ULONG)((PCHAR)NextEntry - (PCHAR)IndexBuffer),
                              Scb->ScbType.Index.BytesPerIndexBuffer );
            }

            //
            //  Now call the Restart routine to do it.
            //

            NtfsRestartSetIndexBlock( NextEntry,
                                      NtfsIndexEntryBlock(*DeleteEntry) );

            break;

        //
        //  Otherwise we are looking at an empty buffer.  If it is the root
        //  then we have Case 3.  We are returning an IndexRoot to the
        //  empty leaf case by reinitializing it.
        //

        } else if (Sp == IndexContext->Base) {

            ATTRIBUTE_TYPE_CODE IndexedAttributeType = $UNUSED;

            if (!FlagOn(Scb->ScbState, SCB_STATE_VIEW_INDEX)) {
                IndexedAttributeType = Scb->ScbType.Index.AttributeBeingIndexed;
            }

            NtfsCreateIndex( IrpContext,
                             Scb->Fcb,
                             IndexedAttributeType,
                             (COLLATION_RULE)Scb->ScbType.Index.CollationRule,
                             Scb->ScbType.Index.BytesPerIndexBuffer,
                             Scb->ScbType.Index.BlocksPerIndexBuffer,
                             Context,
                             Scb->AttributeFlags,
                             FALSE,
                             TRUE );

            //
            //  Nobody should use this context anymore, so set to crash
            //  if they try to use this index entry pointer.
            //

            IndexContext->OldAttribute = NtfsFoundAttribute(Context);
            IndexContext->Base->IndexEntry = (PINDEX_ENTRY)NULL;

            //
            //  In this case our caller has nothing to delete.
            //

            *DeleteEntry = NULL;

            break;

        //
        //  Otherwise, this is just some intermediate empty buffer, which
        //  is Case 4.  Just continue back and keep on pruning.
        //

        } else {
            continue;
        }
    }

    //
    //  If it looks like we did some work, and did not already find the root again,
    //  then make sure the stack is correct for return.
    //

    if ((*DeleteEntry != NULL) && (Attribute == NULL)) {
        FindMoveableIndexRoot( IrpContext, Scb, IndexContext );
    }

    DebugTrace( -1, Dbg, ("PruneIndex -> VOID\n") );
}


VOID
NtOfsRestartUpdateDataInIndex(
    IN PINDEX_ENTRY IndexEntry,
    IN PVOID IndexData,
    IN ULONG Length )

/*++

Routine Description:

    This is the restart routine used to apply updates to the data in a row,
    both in run time and at restart.

Arguments:

    IndexEntry - Supplies a pointer to the IndexEntry to be updated.

    IndexData - Supplies the data for the update.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    RtlMoveMemory( Add2Ptr(IndexEntry, IndexEntry->DataOffset),
                   IndexData,
                   Length );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\index.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Index.h

Abstract:

    This module contains definitions common to only indexsup.c and viewsup.c

Author:

    Tom Miller      [TomM]          8-Jan-1996

Revision History:

--*/

//
//  Define all private support routines.  Documentation of routine interface
//  is with the routine itself.
//

VOID
NtfsGrowLookupStack (
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN PINDEX_LOOKUP_STACK *Sp
    );

BOOLEAN
ReadIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG IndexBlock,
    IN BOOLEAN Reread,
    OUT PINDEX_LOOKUP_STACK Sp
    );

PINDEX_ALLOCATION_BUFFER
GetIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    OUT PINDEX_LOOKUP_STACK Sp,
    OUT PLONGLONG EndOfValidData
    );

VOID
DeleteIndexBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN IndexBlockNumber
    );

VOID
FindFirstIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN OUT PINDEX_CONTEXT IndexContext
    );

BOOLEAN
FindNextIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN ValueContainsWildcards,
    IN BOOLEAN IgnoreCase,
    IN OUT PINDEX_CONTEXT IndexContext,
    IN BOOLEAN NextFlag,
    OUT PBOOLEAN MustRestart OPTIONAL
    );

PATTRIBUTE_RECORD_HEADER
FindMoveableIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    );

PINDEX_ENTRY
BinarySearchIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_LOOKUP_STACK Sp,
    IN PVOID Value
    );

BOOLEAN
AddToIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN BOOLEAN FindRoot
    );

VOID
InsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
PushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
InsertSimpleAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_LOOKUP_STACK Sp,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

PINDEX_ENTRY
InsertWithBufferSplit (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

VOID
DeleteFromIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
DeleteSimple (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT IndexContext
    );

VOID
PruneIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PINDEX_CONTEXT IndexContext,
    OUT PINDEX_ENTRY *DeleteEntry
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\logsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    LogSup.c

Abstract:

    This module implements the Ntfs interfaces to the Log File Service (LFS).

Author:

    Tom Miller      [TomM]          24-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOGSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('LFtN')

#ifdef NTFSDBG

#define ASSERT_RESTART_TABLE(T) {                                           \
    PULONG _p = (PULONG)(((PCHAR)(T)) + sizeof(RESTART_TABLE));             \
    ULONG _Count = ((T)->EntrySize/4) * (T)->NumberEntries;                 \
    ULONG _i;                                                               \
    for (_i = 0; _i < _Count; _i += 1) {                                    \
        if (_p[_i] == 0xDAADF00D) {                                         \
            DbgPrint("DaadFood for table %08lx, At %08lx\n", (T), &_p[_i]); \
            ASSERTMSG("ASSERT_RESTART_TABLE ", FALSE);                      \
        }                                                                   \
    }                                                                       \
}

#else

#define ASSERT_RESTART_TABLE(T) {NOTHING;}

#endif

//
//  Local structure for use in DirtyPageRoutine
//

typedef struct {

    PRESTART_POINTERS DirtyPageTable;
    ULONG DirtyPageIndex;
    PFILE_OBJECT OldestFileObject;
    LSN OldestLsn;
    BOOLEAN Overflow;

} DIRTY_PAGE_CONTEXT, *PDIRTY_PAGE_CONTEXT;

//
//  Local procedure prototypes
//

typedef LCN UNALIGNED *PLCN_UNALIGNED;

VOID
DirtyPageRoutine (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PLSN OldestLsn,
    IN PLSN NewestLsn,
    IN PVOID Context1,
    IN PVOID Context2
    );

BOOLEAN
LookupLcns (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN Vcn,
    IN ULONG ClusterCount,
    IN BOOLEAN MustBeAllocated,
    OUT PLCN_UNALIGNED FirstLcn
    );

ULONG
NtfsCalculateNamedBytes (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

LONG
NtfsCatchOutOfMemoryExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

LONG
NtfsCheckpointExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LookupLcns)
#pragma alloc_text(PAGE, NtfsCheckpointCurrentTransaction)
#pragma alloc_text(PAGE, NtfsCheckpointForLogFileFull)
#pragma alloc_text(PAGE, NtfsCheckpointVolume)
#pragma alloc_text(PAGE, NtfsCleanCheckpoint)
#pragma alloc_text(PAGE, NtfsCleanupFailedTransaction)
#pragma alloc_text(PAGE, NtfsCommitCurrentTransaction)
#pragma alloc_text(PAGE, NtfsFreeRecentlyDeallocated)
#pragma alloc_text(PAGE, NtfsFreeRestartTable)
#pragma alloc_text(PAGE, NtfsGetFirstRestartTable)
#pragma alloc_text(PAGE, NtfsGetNextRestartTable)
#pragma alloc_text(PAGE, NtfsInitializeLogging)
#pragma alloc_text(PAGE, NtfsInitializeRestartTable)
#pragma alloc_text(PAGE, NtfsStartLogFile)
#pragma alloc_text(PAGE, NtfsStopLogFile)
#pragma alloc_text(PAGE, NtfsUpdateOatVersion)
#pragma alloc_text(PAGE, NtfsWriteLog)
#endif


LSN
NtfsWriteLog (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PBCB Bcb OPTIONAL,
    IN NTFS_LOG_OPERATION RedoOperation,
    IN PVOID RedoBuffer OPTIONAL,
    IN ULONG RedoLength,
    IN NTFS_LOG_OPERATION UndoOperation,
    IN PVOID UndoBuffer OPTIONAL,
    IN ULONG UndoLength,
    IN LONGLONG StreamOffset,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN ULONG StructureSize
    )

/*++

Routine Description:

    This routine implements an Ntfs-specific interface to LFS for the
    purpose of logging updates to file record segments and resident
    attributes.

    The caller creates one of the predefined log record formats as
    determined by the given LogOperation, and calls this routine with
    this log record and pointers to the respective file and attribute
    records.  The list of log operations along with the respective structure
    expected for the Log Buffer is present in ntfslog.h.

Arguments:

    Scb - Pointer to the Scb for the respective file or Mft.  The caller must
          have at least shared access to this Scb.

    Bcb - If specified, this Bcb will be set dirty specifying the Lsn of
          the log record written.

    RedoOperation - One of the log operation codes defined in ntfslog.h.

    RedoBuffer - A pointer to the structure expected for the given Redo operation,
                 as summarized in ntfslog.h.  This pointer should only be
                 omitted if and only if the table in ntfslog.h does not show
                 a log record for this log operation.

    RedoLength - Length of the Redo buffer in bytes.

    UndoOperation - One of the log operation codes defined in ntfslog.h.

                    Must be CompensationLogRecord if logging the Undo of
                    a previous operation, such as during transaction abort.
                    In this case, of course, the Redo information is from
                    the Undo information of the record being undone.  See
                    next parameter.

    UndoBuffer - A pointer to the structure expected for the given Undo operation,
                 as summarized in ntfslog.h.  This pointer should only be
                 omitted if and only if the table in ntfslog.h does not show
                 a log record for this log operation.  If this pointer is
                 identical to RedoBuffer, then UndoLength is ignored and
                 only a single copy of the RedoBuffer is made, but described
                 by both the Redo and Undo portions of the log record.

                 For a compensation log record (UndoOperation ==
                 CompensationLogRecord), this argument must point to the
                 UndoNextLsn of the log record being compensated.

    UndoLength - Length of the Undo buffer in bytes.  Ignored if RedoBuffer ==
                 UndoBuffer.

                 For a compensation log record, this argument must be the length
                 of the original redo record.  (Used during restart).

    StreamOffset - Offset within the stream for the start of the structure being
                   modified (Mft or Index), or simply the stream offset for the start
                   of the update.

    RecordOffset - Byte offset from StreamOffset above to update reference

    AttributeOffset - Offset within a value to which an update applies, if relevant.

    StructureSize - Size of the entire structure being logged.

Return Value:

    The Lsn of the log record written.  For most callers, this status may be ignored,
    because the Lsn is also correctly recorded in the transaction context.

    If an error occurs this procedure will raise.

--*/

{
    LFS_WRITE_ENTRY WriteEntries[3];

    struct {

        NTFS_LOG_RECORD_HEADER LogRecordHeader;
        LCN Runs[PAGE_SIZE/512 - 1];

    } LocalHeader;

    PNTFS_LOG_RECORD_HEADER MyHeader;
    PVCB Vcb;

    LSN UndoNextLsn;
    LSN ReturnLsn;
    PLSN DirtyLsn = NULL;

    ULONG WriteIndex = 0;
    ULONG UndoIndex = 0;
    ULONG RedoIndex = 0;
    LONG UndoBytes = 0;
    LONG UndoAdjustmentForLfs = 0;
    LONG UndoRecords = 0;

    PTRANSACTION_ENTRY TransactionEntry;
    ULONG OpenAttributeIndex = 0;
    ULONG OnDiskAttributeIndex = 0;
    POPEN_ATTRIBUTE_DATA AttributeData = NULL;
    BOOLEAN AttributeTableAcquired = FALSE;
    BOOLEAN TransactionTableAcquired = FALSE;

    ULONG LogClusterCount = ClustersFromBytes( Scb->Vcb, StructureSize );
    VCN LogVcn = LlClustersFromBytesTruncate( Scb->Vcb, StreamOffset );

    BOOLEAN DecrementLastTransactionLsnCount = FALSE;

    PAGED_CODE();

    Vcb = Scb->Vcb;

    //
    //  If the log handle is gone, then we noop this call.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE )) {

        return Li0; //**** LfsZeroLsn;
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY )) {

        //
        //  We'd like to have a chat with whoever sent the log write.
        //

        ASSERT(!FlagOn( Vcb->VcbState, VCB_STATE_MOUNT_READ_ONLY ));
        return Li0;
    }

    DebugTrace( +1, Dbg, ("NtfsWriteLog:\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Bcb = %08lx\n", Bcb) );
    DebugTrace( 0, Dbg, ("RedoOperation = %08lx\n", RedoOperation) );
    DebugTrace( 0, Dbg, ("RedoBuffer = %08lx\n", RedoBuffer) );
    DebugTrace( 0, Dbg, ("RedoLength = %08lx\n", RedoLength) );
    DebugTrace( 0, Dbg, ("UndoOperation = %08lx\n", UndoOperation) );
    DebugTrace( 0, Dbg, ("UndoBuffer = %08lx\n", UndoBuffer) );
    DebugTrace( 0, Dbg, ("UndoLength = %08lx\n", UndoLength) );
    DebugTrace( 0, Dbg, ("StreamOffset = %016I64x\n", StreamOffset) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("AttributeOffset = %08lx\n", AttributeOffset) );
    DebugTrace( 0, Dbg, ("StructureSize = %08lx\n", StructureSize) );

    //
    //  Check Redo and Undo lengths
    //

    ASSERT( ((RedoOperation == UpdateNonresidentValue) && (RedoLength <= PAGE_SIZE)) ||

            !ARGUMENT_PRESENT( Scb ) ||

            !ARGUMENT_PRESENT( Bcb ) ||

            ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
             (RedoLength <= Scb->ScbType.Index.BytesPerIndexBuffer)) ||

            (RedoLength <= Scb->Vcb->BytesPerFileRecordSegment) );

    ASSERT( ((UndoOperation == UpdateNonresidentValue) && (UndoLength <= PAGE_SIZE)) ||

           !ARGUMENT_PRESENT( Scb ) ||

           !ARGUMENT_PRESENT( Bcb ) ||

           ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
            (UndoLength <= Scb->ScbType.Index.BytesPerIndexBuffer)) ||

           (UndoLength <= Scb->Vcb->BytesPerFileRecordSegment) ||

           (UndoOperation == CompensationLogRecord) );

    //
    //  Initialize local pointers.
    //

    MyHeader = (PNTFS_LOG_RECORD_HEADER)&LocalHeader;

    try {

        //
        //  If the structure size is nonzero, then create an open attribute table
        //  entry.
        //

        if (StructureSize != 0) {

            //
            //  Allocate an entry in the open attribute table and initialize it,
            //  if it does not already exist.  If we subsequently fail, we do
            //  not have to clean this up.  It will go away on the next checkpoint.
            //

            if (Scb->NonpagedScb->OpenAttributeTableIndex == 0) {

                OPEN_ATTRIBUTE_ENTRY_V0 LocalOpenEntry;
                POPEN_ATTRIBUTE_ENTRY OpenAttributeEntry;
                POPEN_ATTRIBUTE_ENTRY_V0 OnDiskAttributeEntry;
                ULONG EntrySize;

                ASSERT( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ) >= sizeof( OPEN_ATTRIBUTE_ENTRY ));

                NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                AttributeTableAcquired = TRUE;

                //
                //  Check for a drain pending
                //

                if (Vcb->OpenAttributeTable.DrainPending) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ONLY_SYNCH_CHECKPOINT );
#ifdef PERF_STATS
                    IrpContext->LogFullReason = LF_TRANSACTION_DRAIN;
#endif

                    NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
                }

                //
                //  Only proceed if the OpenAttributeTableIndex is still 0.
                //  We may reach this point for the MftScb.  It may not be
                //  acquired when logging changes to file records.  We will
                //  use the OpenAttributeTable for final synchronization
                //  for the Mft open attribute table entry.
                //

                if (Scb->NonpagedScb->OpenAttributeTableIndex == 0) {

                    //
                    //  Our structures require tables to stay within 64KB, since
                    //  we use USHORT offsets.  Things are getting out of hand
                    //  at this point anyway.  Raise log file full to reset the
                    //  table sizes if we get to this point.
                    //

                    if (AllocatedSizeOfRestartTable( Vcb->OnDiskOat ) > MAX_RESTART_TABLE_SIZE) {

#ifdef PERF_STATS
                        IrpContext->LogFullReason = LF_OPEN_ATTRIBUTES;
#endif
                        NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
                    }

                    //
                    //  Allocate the indexes and then the Attribute data structure.  The
                    //  try-finally will handle any failures.
                    //

                    OpenAttributeIndex = NtfsAllocateRestartTableIndex( &Vcb->OpenAttributeTable, TRUE );
                    AttributeData = NtfsAllocatePool( PagedPool, sizeof( OPEN_ATTRIBUTE_DATA ) );
                    OpenAttributeEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                                   OpenAttributeIndex );

                    //
                    //  Initialize the entry and auxiliary data.
                    //

                    if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

                        OpenAttributeEntry->BytesPerIndexBuffer = Scb->ScbType.Index.BytesPerIndexBuffer;

                    } else {

                        OpenAttributeEntry->BytesPerIndexBuffer = 0;
                    }

                    //
                    //  Its good enough to use the last lsn for the lsnofopenrecord
                    //  since we're serialized on create attributes within a file
                    //

                    OpenAttributeEntry->AttributeTypeCode = Scb->AttributeTypeCode;
                    OpenAttributeEntry->FileReference = Scb->Fcb->FileReference;
                    OpenAttributeEntry->LsnOfOpenRecord = LfsQueryLastLsn( Vcb->LogHandle );

                    AttributeData->Overlay.Scb = Scb;
                    AttributeData->AttributeName = Scb->AttributeName;
                    AttributeData->AttributeNamePresent = FALSE;

                    //
                    //  Use the open attribute entry as the default table entry.
                    //

                    Scb->NonpagedScb->OnDiskOatIndex = OpenAttributeIndex;

                    //
                    //  If the on-disk structure is needed then get it now.
                    //

                    if (Vcb->RestartVersion == 0) {

                        NtfsAcquireExclusiveRestartTable( Vcb->OnDiskOat, TRUE );

                        try {
                            
                            OnDiskAttributeIndex = NtfsAllocateRestartTableIndex( Vcb->OnDiskOat, TRUE );
                            OnDiskAttributeEntry = GetRestartEntryFromIndex( Vcb->OnDiskOat,
                                                                             OnDiskAttributeIndex );

                            OnDiskAttributeEntry->OatIndex = OpenAttributeIndex;
                            OnDiskAttributeEntry->FileReference = Scb->Fcb->FileReference;
                            OnDiskAttributeEntry->LsnOfOpenRecord.QuadPart = 0;
                            OnDiskAttributeEntry->AttributeTypeCode = Scb->AttributeTypeCode;
                            OnDiskAttributeEntry->BytesPerIndexBuffer = OpenAttributeEntry->BytesPerIndexBuffer;
                            OnDiskAttributeEntry->LsnOfOpenRecord.QuadPart = OpenAttributeEntry->LsnOfOpenRecord.QuadPart;

                            //
                            //  Use this new index.
                            //

                            Scb->NonpagedScb->OnDiskOatIndex = OnDiskAttributeIndex;

                        } finally {
                            NtfsReleaseRestartTable( Vcb->OnDiskOat );
                        }
                        
                    //
                    //  We need to log this so store a copy in our local.
                    //

                    } else {

                        OnDiskAttributeIndex = OpenAttributeIndex;
                    }

                    //
                    //  Now store the table indexes.
                    //

                    AttributeData->OnDiskAttributeIndex = OnDiskAttributeIndex;
                    Scb->NonpagedScb->OpenAttributeTableIndex = OpenAttributeIndex;

                    //
                    //  Now connect the attribute data to the table entry and the Vcb.
                    //

                    OpenAttributeEntry->OatData = AttributeData;
                    InsertTailList( &Vcb->OpenAttributeData, &AttributeData->Links );

                    RtlCopyMemory( &LocalOpenEntry,
                                   GetRestartEntryFromIndex( Vcb->OnDiskOat, OnDiskAttributeIndex ),
                                   EntrySize = Vcb->OnDiskOat->Table->EntrySize );

                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                    AttributeTableAcquired = FALSE;
                    OpenAttributeIndex = 0;

                    //
                    //  Now log the new open attribute table entry before going on,
                    //  to insure that the application of the caller's log record
                    //  will have the information he needs on the attribute.  We will
                    //  use the Undo buffer to convey the attribute name.  We will
                    //  not infinitely recurse, because now this Scb already has an
                    //  open attribute table index.
                    //

                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  NULL,
                                  OpenNonresidentAttribute,
                                  &LocalOpenEntry,
                                  EntrySize,
                                  Noop,
                                  Scb->AttributeName.Length != 0 ?
                                    Scb->AttributeName.Buffer : NULL,
                                  Scb->AttributeName.Length,
                                  (LONGLONG)0,
                                  0,
                                  0,
                                  0 );

                } else {

                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                    AttributeTableAcquired = FALSE;
                }
            }
        }

        //
        //  Allocate a transaction ID and initialize it, if it does not already exist.
        //  If we subsequently fail, we clean it up when the current request is
        //  completed.
        //

        if (IrpContext->TransactionId == 0) {

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
            TransactionTableAcquired = TRUE;

            //
            //  Our structures require tables to stay within 64KB, since
            //  we use USHORT offsets.  Things are getting out of hand
            //  at this point anyway.  Raise log file full to reset the
            //  table sizes if we get to this point.
            //
            //  Also raise if we're synchronizing to wait for all transactions to
            //  finish
            //

            if ((SizeOfRestartTable( &Vcb->TransactionTable ) > MAX_RESTART_TABLE_SIZE) ||
                Vcb->TransactionTable.DrainPending) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ONLY_SYNCH_CHECKPOINT );
#ifdef PERF_STATS
                IrpContext->LogFullReason = LF_TRANSACTION_DRAIN;
#endif

                NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
            }

            IrpContext->TransactionId =
              NtfsAllocateRestartTableIndex( &Vcb->TransactionTable, TRUE );

            //
            //  Obtain the lsn now so that checkpoint code can calculate the BaseLsn correctly
            //  before we update the FirstLsn of this transaction after calling LfsWrite below.
            //  This closes the window where we started the transaction with an invalid Lsn till
            //  we actually write out the transaction and update the Lsn.
            //

            if (Vcb->LastTransactionLsnCount == 0) {

                //
                //  Since nobody should be updating LastTransactionLsn, just write out the last lsn
                //

                Vcb->LastTransactionLsn = LfsQueryLastLsn( Vcb->LogHandle );

            } else {

                //
                //  Since LastTransactionLsnCount is non-zero, LastTransactionLsn should also be non-zero.
                //  We should also be moving forward if someone is already ahead of us.
                //

                ASSERT( (Vcb->LastTransactionLsnCount != 0) &&
                        (Vcb->LastTransactionLsn.QuadPart != 0) &&
                        (Vcb->LastTransactionLsn.QuadPart <= LfsQueryLastLsn( Vcb->LogHandle ).QuadPart) );
            }

            //
            //  Bump the reference count by one and decrement it after we update the FirstLsn below
            //

            Vcb->LastTransactionLsnCount += 1;
            DecrementLastTransactionLsnCount = TRUE;

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG );

            TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                                &Vcb->TransactionTable,
                                IrpContext->TransactionId );
            TransactionEntry->TransactionState = TransactionActive;
            TransactionEntry->FirstLsn =
            TransactionEntry->PreviousLsn =
            TransactionEntry->UndoNextLsn = Li0; //**** LfsZeroLsn;

            //
            //  Remember that we will need a commit record even if we abort
            //  the transaction.
            //

            TransactionEntry->UndoBytes = QuadAlign( sizeof( NTFS_LOG_RECORD_HEADER ));
            TransactionEntry->UndoRecords = 1;

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
            TransactionTableAcquired = FALSE;

            //
            //  Remember the space for the commit record in our Lfs adjustment.
            //

            UndoAdjustmentForLfs += QuadAlign( sizeof( NTFS_LOG_RECORD_HEADER ));

            //
            //  If there is an undo operation for this log record, we reserve
            //  the space for another Lfs log record.
            //

            if (UndoOperation != Noop) {
                UndoAdjustmentForLfs += Vcb->LogHeaderReservation;
            }
        }

        //
        //  At least for now, assume update is contained in one physical page.
        //

        //ASSERT( (StructureSize == 0) || (StructureSize <= PAGE_SIZE) );

        //
        //  If there isn't enough room for this structure on the stack, we
        //  need to allocate an auxilary buffer.
        //

        if (LogClusterCount > (PAGE_SIZE / 512)) {

            MyHeader = (PNTFS_LOG_RECORD_HEADER)
                       NtfsAllocatePool(PagedPool, sizeof( NTFS_LOG_RECORD_HEADER )
                                              + (LogClusterCount - 1) * sizeof( LCN ));

        }

        //
        //  Now fill in the WriteEntries array and the log record header.
        //

        WriteEntries[0].Buffer = (PVOID)MyHeader;
        WriteEntries[0].ByteLength = sizeof(NTFS_LOG_RECORD_HEADER);
        WriteIndex += 1;

        //
        //  Lookup the Runs for this log record
        //

        MyHeader->LcnsToFollow = (USHORT)LogClusterCount;

        if (LogClusterCount != 0) {

            if (!LookupLcns( IrpContext,
                             Scb,
                             LogVcn,
                             LogClusterCount,
                             TRUE,
                             &MyHeader->LcnsForPage[0] )) {

                //
                //  It is possible that the allocation for this range is not allocated.
                //  This may happen in cases where a stream which descibes itself is
                //  being hotfixed (perhaps MoveFile in a later release).  In the
                //  hotfix case we will not write this log record.  Hotfix will mark
                //  the volume dirty so we know that the system will verify the volume
                //  at some point.
                //

                ASSERT( NtfsGetTopLevelHotFixScb() != NULL );

                //
                //  Cleanup the transaction entry if allocated here.
                //

                if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG ) &&
                    (IrpContext->TransactionId != 0)) {

                    NtfsCleanupFailedTransaction( IrpContext );
                }

                ReturnLsn = LfsQueryLastLsn( Vcb->LogHandle );
                DirtyLsn = &ReturnLsn;
                leave;
            }

            WriteEntries[0].ByteLength += (LogClusterCount - 1) * sizeof(LCN);
        }

        //
        //  If there is a Redo buffer, fill in its write entry.
        //

        if (RedoLength != 0) {

            WriteEntries[1].Buffer = RedoBuffer;
            WriteEntries[1].ByteLength = RedoLength;
            UndoIndex = RedoIndex = WriteIndex;
            WriteIndex += 1;
        }

        //
        //  If there is an undo buffer, and it is at a different address than
        //  the redo buffer, then fill in its write entry.
        //

        if ((RedoBuffer != UndoBuffer) && (UndoLength != 0) &&
            (UndoOperation != CompensationLogRecord)) {

            WriteEntries[WriteIndex].Buffer = UndoBuffer;
            WriteEntries[WriteIndex].ByteLength = UndoLength;
            UndoIndex = WriteIndex;
            WriteIndex += 1;
        }

        //
        //  Now fill in the rest of the header.  Assume Redo and Undo buffer is
        //  the same, then fix them up if they are not.
        //

        MyHeader->RedoOperation = (USHORT)RedoOperation;
        MyHeader->UndoOperation = (USHORT)UndoOperation;
        MyHeader->RedoOffset = (USHORT)WriteEntries[0].ByteLength;
        MyHeader->RedoLength = (USHORT)RedoLength;
        MyHeader->UndoOffset = MyHeader->RedoOffset;
        if (RedoBuffer != UndoBuffer) {
            MyHeader->UndoOffset += (USHORT)QuadAlign(MyHeader->RedoLength);
        }
        MyHeader->UndoLength = (USHORT)UndoLength;

        MyHeader->TargetAttribute = (USHORT)Scb->NonpagedScb->OnDiskOatIndex;
        MyHeader->RecordOffset = (USHORT)RecordOffset;
        MyHeader->AttributeOffset = (USHORT)AttributeOffset;
        MyHeader->Reserved = 0;

        MyHeader->TargetVcn = LogVcn;
        MyHeader->ClusterBlockOffset = (USHORT) LogBlocksFromBytesTruncate( ClusterOffset( Vcb, StreamOffset ));

        //
        //  Finally, get our current transaction entry and call Lfs.  We acquire
        //  the transaction table exclusive both to synchronize the Lsn updates
        //  on return from Lfs, and also to mark the Bcb dirty before any more
        //  log records are written.
        //
        //  If we do not do serialize the LfsWrite and CcSetDirtyPinnedData, here is
        //  what can happen:
        //
        //      We log an update for a page and get an Lsn back
        //
        //          Another thread writes a start of checkpoint record
        //          This thread then collects all of the dirty pages at that time
        //          Sometime it writes the dirty page table
        //
        //      The former thread which had been preempted, now sets the Bcb dirty
        //
        //  If we crash at this time, the page we updated is not in the dirty page
        //  table of the checkpoint, and it its update record is also not seen since
        //  it was written before the start of the checkpoint!
        //
        //  Note however, since the page being updated is pinned and cannot be written,
        //  updating the Lsn in the page may simply be considered part of the update.
        //  Whoever is doing this update (to the Mft or an Index buffer), must have the
        //  Mft or Index acquired exclusive anyway.
        //

        NtfsAcquireSharedStarveExRestartTable( &Vcb->TransactionTable, TRUE );
        TransactionTableAcquired = TRUE;

        TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                            &Vcb->TransactionTable,
                            IrpContext->TransactionId );

        //
        //  Set up the UndoNextLsn.  If this is a normal log record, then use
        //  the UndoNextLsn stored in the transaction entry; otherwise, use
        //  the one passed in as the Undo buffer.
        //

        if (UndoOperation != CompensationLogRecord) {

            UndoNextLsn = TransactionEntry->UndoNextLsn;

            //
            //  If there is undo information, calculate the number to pass to Lfs
            //  for undo bytes to reserve.
            //

            if (UndoOperation != Noop) {

                UndoBytes += QuadAlign(WriteEntries[0].ByteLength);

                if (UndoIndex != 0) {

                    UndoBytes += QuadAlign(WriteEntries[UndoIndex].ByteLength);
                }

                UndoRecords += 1;
            }

        } else {

            UndoNextLsn = *(PLSN)UndoBuffer;

            //
            //  We can reduce our Undo requirements, by the Redo data being
            //  logged.  This is either an abort record for a previous action
            //  or a commit record.  If it is a commit record we accounted
            //  for it above on the first NtfsWriteLog, and NtfsCommitTransaction
            //  will adjust for the rest.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

                UndoBytes -= QuadAlign(WriteEntries[0].ByteLength);

                if (RedoIndex != 0) {

                    UndoBytes -= QuadAlign(WriteEntries[RedoIndex].ByteLength);
                }

                UndoRecords -= 1;
            }
        }

#ifdef NTFS_LOG_FULL_TEST
        //
        //  Perform log-file-full fail checking.  We do not perform this check if
        //  we are writing an undo record (since we are guaranteed space to undo
        //  things).
        //

        if (UndoOperation != CompensationLogRecord &&
            (IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL ||
             IrpContext->MinorFunction != IRP_MN_MOUNT_VOLUME)) {

            LogFileFullFailCheck( IrpContext );

            if (NtfsFailFrequency != 0 &&
                (++NtfsPeriodicFail % NtfsFailFrequency) == 0) {

                ExRaiseStatus( STATUS_LOG_FILE_FULL );
            }
        }
#endif

        //
        //  Call Lfs to write the record.
        //

        LfsWrite( Vcb->LogHandle,
                  WriteIndex,
                  &WriteEntries[0],
                  LfsClientRecord,
                  &IrpContext->TransactionId,
                  UndoNextLsn,
                  TransactionEntry->PreviousLsn,
                  UndoBytes + UndoAdjustmentForLfs,
                  0,
                  &ReturnLsn );

        //
        //  Now that we are successful, update the transaction entry appropriately.
        //

        TransactionEntry->UndoBytes += UndoBytes;
        TransactionEntry->UndoRecords += UndoRecords;
        TransactionEntry->PreviousLsn = ReturnLsn;

        //
        //  The UndoNextLsn for the transaction depends on whether we are
        //  doing a compensation log record or not.
        //

        if (UndoOperation != CompensationLogRecord) {
            TransactionEntry->UndoNextLsn = ReturnLsn;
        } else {
            TransactionEntry->UndoNextLsn = UndoNextLsn;
        }

        //
        //  If this is the first Lsn, then we have to update that as
        //  well.
        //

        if (TransactionEntry->FirstLsn.QuadPart == 0) {

            TransactionEntry->FirstLsn = ReturnLsn;

            //
            //  Only decrement the LastTransactionLsnCount if we incremented it earlier as
            //  it is possible for the FirstLsn to be zero during restart or some other code path.
            //

            ASSERT( DecrementLastTransactionLsnCount ||
                    FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) );

            if (DecrementLastTransactionLsnCount) {

                //
                //  We cannot safely assert because we are acquiring the TransactionTable shared.
                //  Another NtfsWriteLog could be changing these values.
                //  That's why we have to use the InterlockedDecrement down below on LastTransactionLsnCount.
                //

                //  ASSERT( (Vcb->LastTransactionLsnCount != 0) &&
                //          (Vcb->LastTransactionLsn.QuadPart != 0)
                //          (Vcb->LastTransactionLsn.QuadPart <= ReturnLsn.QuadPart) );

                InterlockedDecrement(&Vcb->LastTransactionLsnCount);
                DecrementLastTransactionLsnCount = FALSE;
            }
        }

        //
        //  Set to use this Lsn when marking dirty below
        //

        DirtyLsn = &ReturnLsn;

        //
        //  Set the flag in the Irp Context which indicates we wrote
        //  a log record to disk.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG );

        //
        //  Now set the Bcb dirty if specified.  We want to set it no matter
        //  what happens, because our caller has modified the buffer and is
        //  counting on us to call the Cache Manager.
        //

        if (ARGUMENT_PRESENT( Bcb )) {

            TIMER_STATUS TimerStatus;

            CcSetDirtyPinnedData( Bcb, DirtyLsn );

            //
            //  Synchronize with the checkpoint timer and other instances of this routine.
            //
            //  Perform an interlocked exchange to indicate that a timer is being set.
            //
            //  If the previous value indicates that no timer was set, then we
            //  enable the volume checkpoint timer.  This will guarantee that a checkpoint
            //  will occur to flush out the dirty Bcb data.
            //
            //  If the timer was set previously, then it is guaranteed that a checkpoint
            //  will occur without this routine having to reenable the timer.
            //
            //  If the timer and checkpoint occurred between the dirtying of the Bcb and
            //  the setting of the timer status, then we will be queueing a single extra
            //  checkpoint on a clean volume.  This is not considered harmful.
            //

            //
            //  Atomically set the timer status to indicate a timer is being set and
            //  retrieve the previous value.
            //

            TimerStatus = InterlockedExchange( (PLONG)&NtfsData.TimerStatus, TIMER_SET );

            //
            //  If the timer is not currently set then we must start the checkpoint timer
            //  to make sure the above dirtying is flushed out.
            //

            if (TimerStatus == TIMER_NOT_SET) {

                LONGLONG FiveSecondsFromNow = -5*1000*1000*10;

                KeSetTimer( &NtfsData.VolumeCheckpointTimer,
                            *(PLARGE_INTEGER)&FiveSecondsFromNow,
                            &NtfsData.VolumeCheckpointDpc );
            }
        }

    } finally {

        DebugUnwind( NtfsWriteLog );

        if (DecrementLastTransactionLsnCount && !TransactionTableAcquired) {

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                              TRUE );
            TransactionTableAcquired = TRUE;
        }

        if (TransactionTableAcquired) {

            if (DecrementLastTransactionLsnCount) {

                //
                //  The TransacationTable could be acquired shared/exclusive at this point.
                //  That's why we need to use InterlockedDecrement.
                //

                InterlockedDecrement(&Vcb->LastTransactionLsnCount);
            }

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
        }

        //
        //  Lets cleanup any failed attempt to allocate an attribute entry.
        //  We only need to check the OpenAttributeIndex if the operation
        //  was successful.
        //

        if (OpenAttributeIndex != 0) {

            NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable, OpenAttributeIndex );

            if (AttributeData != NULL) {

                NtfsFreePool( AttributeData );
            }

            if (OnDiskAttributeIndex != 0) {

                NtfsFreeRestartTableIndex( Vcb->OnDiskOat, OnDiskAttributeIndex );
            }
        }

        if (AttributeTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
        }

        if (MyHeader != (PNTFS_LOG_RECORD_HEADER)&LocalHeader) {

            NtfsFreePool( MyHeader );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsWriteLog -> %016I64x\n", ReturnLsn ) );

    return ReturnLsn;
}


VOID
NtfsCheckpointVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OwnsCheckpoint,
    IN BOOLEAN CleanVolume,
    IN BOOLEAN FlushVolume,
    IN ULONG LfsFlags,
    IN LSN LastKnownLsn
    )

/*++

Routine Description:

    This routine is called periodically to perform a checkpoint on the volume
    with respect to the log file.  The checkpoint dumps a bunch of log file
    state information to the log file, and finally writes a summary of the
    dumped information in its Restart Area.

    This checkpoint dumps the following:

        Open Attribute Table
        (all of the attribute names for the Attribute Table)
        Dirty Pages Table
        Transaction Table

Arguments:

    Vcb - Pointer to the Vcb on which the checkpoint is to occur.

    OwnsCheckpoint - TRUE if the caller has already taken steps to insure
        that he may proceed with the checkpointing.  In this case we
        don't do any checks for other checkpoints and don't clear the
        checkpoint flag or notify any waiting checkpoint threads.

    CleanVolume - TRUE if the caller wishes to clean the volume before doing
        the checkpoint, or FALSE for a normal periodic checkpoint.

    FlushVolume - Applies only if CleanVolume is TRUE.  This indicates if we should
        should flush the volume or only Lsn streams. Only the shutdown thread
        can do a clean and flush checkpoint and avoid deadlocks between
        pagingio and main resources.

    LfsFlags - flags to pass to lfs when writing the restart areas

    LastKnownLsn - Applies only if CleanVolume is TRUE.  Only perform the
        clean checkpoint if this value is the same as the last restart area
        in the Vcb.  This will prevent us from doing unecesary clean
        checkpoints.

Return Value:

    None

--*/

{
    RESTART_AREA RestartArea;
    RESTART_POINTERS DirtyPages;
    RESTART_POINTERS Pointers;
    PRESTART_POINTERS NewTable = NULL;
    LSN BaseLsn;
    PATTRIBUTE_NAME_ENTRY NamesBuffer = NULL;
    PTRANSACTION_ENTRY TransactionEntry;
    LSN OldestDirtyPageLsn = Li0;
    KPRIORITY PreviousPriority;
    PSCB UsnJournal = NULL;
    LOGICAL LfsCleanShutdown = 0;
    USN LowestOpenUsn;
    volatile LARGE_INTEGER StartTime;

#ifdef PERF_STATS
    BOOLEAN Tracking = CleanVolume;
#endif

    BOOLEAN DirtyPageTableInitialized = FALSE;
    BOOLEAN OpenAttributeTableAcquired = FALSE;
    BOOLEAN TransactionTableAcquired = FALSE;
    BOOLEAN AcquireFiles = FALSE;
    BOOLEAN PostDefrag = FALSE;
    BOOLEAN RestorePreviousPriority = FALSE;
    BOOLEAN AcquiredVcb = FALSE;
    LOGICAL CheckpointInProgress = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCheckpointVolume:\n") );
    DebugTrace( 0, Dbg, ("Vcb = %08lx\n", Vcb) );

    //
    //  No checkpointing on readonly volumes.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        return;
    }

    if (!OwnsCheckpoint) {

        //
        //  Acquire the checkpoint event.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        //
        //  We will want to post a defrag if defragging is permitted and enabled
        //  and we have begun the defrag operation or have excess mapping.
        //  If the defrag hasn't been triggered then check the Mft free
        //  space.  We can skip defragging if a defrag operation is
        //  currently active.
        //

        if (!CleanVolume &&
            (FlagOn( Vcb->MftDefragState,
                     VCB_MFT_DEFRAG_PERMITTED | VCB_MFT_DEFRAG_ENABLED | VCB_MFT_DEFRAG_ACTIVE ) ==
                (VCB_MFT_DEFRAG_PERMITTED | VCB_MFT_DEFRAG_ENABLED))) {

            if (FlagOn( Vcb->MftDefragState,
                        VCB_MFT_DEFRAG_TRIGGERED | VCB_MFT_DEFRAG_EXCESS_MAP )) {

                PostDefrag = TRUE;

            } else {

                NtfsCheckForDefrag( Vcb );

                if (FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_TRIGGERED )) {

                    PostDefrag = TRUE;

                } else {

                    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
                }
            }
        }

        //
        //  If a checkpoint is already active, we either have to get out,
        //  or wait for it.
        //

        while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

            CheckpointInProgress = FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_IN_PROGRESS );

            //
            //  Release the checkpoint event because we cannot checkpoint now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );

            if (CleanVolume) {

                NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
                NtfsAcquireCheckpoint( IrpContext, Vcb );

                //
                //  If there prev. was a checkpoint in progress and the last one was
                //  clean then we don't need to do this clean checkpoint
                //

                if (CheckpointInProgress && FlagOn( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN )) {

                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                    return;
                }

            } else {

                return;
            }
        }

        //
        //  If the log file is gone then simply exit.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE )) {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            return;
        }

        //
        //  We now have the checkpoint event.  Check if there is still
        //  a need to perform the checkpoint.
        //

        if (CleanVolume &&
            (LastKnownLsn.QuadPart != Vcb->LastRestartArea.QuadPart)) {

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            return;
        }

        SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );

        //
        //  If this is a clean volume checkpoint then boost the priority of
        //  this thread.
        //

        if (CleanVolume) {

            PreviousPriority = KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                                    LOW_REALTIME_PRIORITY );

            if (PreviousPriority != LOW_REALTIME_PRIORITY) {

                RestorePreviousPriority = TRUE;
            }
        }
    }

    RtlZeroMemory( &RestartArea, sizeof( RESTART_AREA ) );
    RtlZeroMemory( &DirtyPages, sizeof( RESTART_POINTERS ) );

    //
    //  Remember if our caller wants to tell Lfs that this is a
    //  clean shutdown.  We will use the combination of the OwnsCheckpoint and
    //  CleanCheckpoint flags.  This will cover system shutdown and volume
    //  snapshot cases.  Both of these want the volume not to need any restart.
    //

    if (OwnsCheckpoint && CleanVolume) {

        LfsCleanShutdown = TRUE;
    }

    //
    //  Record the start time
    //

    KeQueryTickCount( &StartTime );

#ifdef PERF_STATS
    if (Tracking) {
        Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].StartTime = StartTime.QuadPart;
        Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].RestartArea = LastKnownLsn;
        Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].Reason = IrpContext->LogFullReason;
        Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].LogFileFulls = Vcb->UnhandledLogFileFullCount;

//        ASSERT( IrpContext->LogFullReason != 0 );
    }
#endif

    //
    //  Insure cleanup on the way out
    //

    try {

        POPEN_ATTRIBUTE_ENTRY AttributeEntry;
        ULONG NameBytes = 0;

        //
        //  Capture the lowest usn - we have checkpoint synchronization which keeps
        //  the journal from going away. This value may change but it will only monotically
        //  increase
        //

        if (Vcb->UsnJournal != NULL) {

            NtfsAcquireResourceShared( IrpContext, Vcb->UsnJournal, TRUE );
            NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );

            //
            //  Now we will correctly synchronize, test the list again and capture
            //  the LowestUsn.
            //

            if (!IsListEmpty(&Vcb->ModifiedOpenFiles)) {
                LowestOpenUsn = ((PFCB_USN_RECORD)CONTAINING_RECORD( Vcb->ModifiedOpenFiles.Flink,
                                                                     FCB_USN_RECORD,
                                                                     ModifiedOpenFilesLinks ))->Fcb->Usn;

            //
            //  If the list is empty, then use FileSize
            //

            } else {
                LowestOpenUsn = Vcb->UsnJournal->Header.FileSize.QuadPart;
            }

            NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
            NtfsReleaseResource( IrpContext, Vcb->UsnJournal );
        }

        //
        //  Now remember the current "last Lsn" value as the start of
        //  our checkpoint.  We acquire the transaction table to capture
        //  this value to synchronize with threads who are writing log
        //  records and setting pages dirty as atomic actions.
        //

        ASSERT( IrpContext->TransactionId == 0 );

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
        //
        //  If LfsFlags == LFS_WRITE_FLAG_WRITE_AT_FRONT then produce
        //  the dummy log record that resets the log. This allows us to
        //  keep the log in use only at the front so chkdsk can shrink it
        //

        if (FlagOn( LfsFlags, LFS_WRITE_FLAG_WRITE_AT_FRONT )) {
            LSN Lsn;
            LFS_WRITE_ENTRY WriteEntry;
            UCHAR Buffer[ sizeof( NTFS_LOG_RECORD_HEADER ) + 2 * sizeof( LSN )];
            TRANSACTION_ID TransactionId;

            RtlZeroMemory( Buffer, sizeof( Buffer ));

            WriteEntry.Buffer = Buffer;
            WriteEntry.ByteLength = sizeof( Buffer );

            TransactionId = NtfsAllocateRestartTableIndex( &Vcb->TransactionTable, TRUE );

            Lsn.QuadPart = 0;

            LfsGetActiveLsnRange( Vcb->LogHandle,
                                  Add2Ptr( Buffer, sizeof( NTFS_LOG_RECORD_HEADER )),
                                  Add2Ptr( Buffer, sizeof( NTFS_LOG_RECORD_HEADER ) + sizeof( LSN )) );

            LfsWrite( Vcb->LogHandle,
                      1,
                      &WriteEntry,
                      LfsClientRecord,
                      &TransactionId,
                      Lsn,
                      Lsn,
                      0,
                      LfsFlags,
                      &Lsn );

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable, TransactionId );

            //
            //  Commit the transaction so that we can release resources
            //

            NtfsCommitCurrentTransaction( IrpContext );
        }

        BaseLsn =
        RestartArea.StartOfCheckpoint = LfsQueryLastLsn( Vcb->LogHandle );
        NtfsReleaseRestartTable( &Vcb->TransactionTable );

        //
        //  Flush any dangling dirty pages from before the last restart.
        //  Note that it is arbitrary what Lsn we flush to here, and, in fact,
        //  it is not absolutely required that we flush anywhere at all - we
        //  could actually rely on the Lazy Writer.  All we are trying to do
        //  is reduce the amount of work that we will have to do at Restart,
        //  by not forcing ourselves to have to go too far back in the log.
        //  Presumably this can only happen for some reason the system is
        //  starting to produce dirty pages faster than the lazy writer is
        //  writing them.
        //
        //  (We may wish to play with taking this call out...)
        //
        //  This may be an appropriate place to worry about this, but, then
        //  again, the Lazy Writer is using (currently) five threads.  It may
        //  not be appropriate to hold up this one thread doing the checkpoint
        //  if the Lazy Writer is getting behind.  How many dirty pages we
        //  can even have is limited by the size of memory, so if the log file
        //  is large enough, this may not be an issue.  It seems kind of nice
        //  to just let the Lazy Writer keep writing dirty pages as he does
        //  now.
        //
        //  if (!FlagOn(Vcb->VcbState, VCB_STATE_LAST_CHECKPOINT_CLEAN)) {
        //      CcFlushPagesToLsn( Vcb->LogHandle, &Vcb->LastRestartArea );
        //  }
        //

        //
        //  Now we must clean the volume here if that is what the caller wants.
        //

        if (CleanVolume) {

#ifdef PERF_STATS
            if (Tracking) {
                SetFlag( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_TRACK_IOS );
            }
#endif

#ifdef BENL_DBG
            KdPrint(( "NTFS: clean checkpoint %x started %I64x\n", Vcb, StartTime ));
#endif

            //
            //  Update stats
            //

            NtfsCleanCheckpoints += 1;

            //
            //  We don't want to clear the pseudo clean bit because we don't want
            //  another pseudo clean checkpoint after a clean checkpoint.
            //

            //
            // ClearFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_PSEUDO_CLEAN );
            //

            //
            //  Lock down the volume if this is a clean checkpoint.
            //

            if (FlushVolume) {

                NtfsAcquireAllFiles( IrpContext, Vcb, FlushVolume, FALSE, FALSE );
                AcquireFiles = TRUE;

#ifdef NTFSDBG
                ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE );
#endif  //  NTFSDBG

            } else {

                BOOLEAN WaitOnTransactions = FALSE;

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                AcquiredVcb = TRUE;

                //
                //  Set the flag indicating we're waiting for all transactions to finish and
                //  then wait if necc.
                //

                NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );

                Vcb->TransactionTable.DrainPending = TRUE;

                ASSERT( IrpContext->TransactionId == 0 );

                if (Vcb->TransactionTable.Table->NumberAllocated > 0) {
                    KeClearEvent( &Vcb->TransactionsDoneEvent );
                    WaitOnTransactions = TRUE;
                }
                NtfsReleaseRestartTable( &Vcb->TransactionTable );
                if (WaitOnTransactions) {
                    KeWaitForSingleObject( &Vcb->TransactionsDoneEvent, Executive, KernelMode, FALSE, NULL );
                }

                //
                //  Set the flag to disallow new open attributes as well
                //

                NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                Vcb->OpenAttributeTable.DrainPending = TRUE;

#ifdef PERF_STATS
                if (Tracking) {
                    Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].NumAttributes =
                        Vcb->OpenAttributeTable.Table->NumberAllocated;
                }
#endif

                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            }

            //
            //  It isn't safe to checkpoint a dismounted volume, and
            //  it doesn't make much sense, either.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                leave;
            }

            //
            //  Now we will acquire the Open Attribute Table exclusive to delete
            //  all of the entries, since we want to write a clean checkpoint.
            //  This is OK, since we have the global resource and nothing else
            //  can be going on.  (Similarly we are writing an empty transaction
            //  table, while in fact we will be the only transaction, but there
            //  is no need to capture our guy, nor explicitly empty this table.)
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
            OpenAttributeTableAcquired = TRUE;

            //
            //  First reclaim the page we have reserved in the undo total, to
            //  guarantee that we can flush the log file.
            //

            LfsResetUndoTotal( Vcb->LogHandle, 1, -(LONG)(2 * PAGE_SIZE) );

            if (FlushVolume) {

                (VOID)NtfsFlushVolume( IrpContext, Vcb, TRUE, FALSE, FALSE, FALSE );

                //
                //  Loop through to deallocate all of the open attribute entries.  Any
                //  that point to an Scb need to get the index in the Scb zeroed.  If
                //  they do not point to an Scb, we have to see if there is a name to
                //  free.
                //

                AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );
                while (AttributeEntry != NULL) {

                    NtfsFreeAttributeEntry( Vcb, AttributeEntry );
                    AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                              AttributeEntry );
                }

            } else {

                //
                //  If we're only flushing out the open attributes rather than the
                //  whole volume we own the vcb shared at this point. We've set the
                //  drain pending flag  to prevent new transactions from being opened. Now
                //  start a cycle of finding an entry in the table / flushing it and removing
                //  it from the table - We must drop the table before acquiring any file since its
                //  an end resource. This will also free the attribute entries
                //

                NtfsFlushLsnStreams( IrpContext, Vcb, TRUE, FALSE );

            }

            SetFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN );

            //
            //  In a rare reuse path there may still be entries in the open attribute data
            //  list.  This can happen when we reuse a slot in the open attribute table
            //  during restart.
            //

            NtfsFreeAllOpenAttributeData( Vcb );

            //
            //  Initialize first in case we get an allocation failure.
            //

            ASSERT( IsRestartTableEmpty( &Vcb->OpenAttributeTable ));
            ASSERT( IsListEmpty( &Vcb->OpenAttributeData ));

            InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY ),
                                INITIAL_NUMBER_ATTRIBUTES,
                                &Pointers );

            NtfsFreePool( Vcb->OpenAttributeTable.Table );
            Vcb->OpenAttributeTable.Table = Pointers.Table;

            //
            //  Since we are doing a clean checkpoint we may be able to discard the
            //  second open attribute table.  We have three cases to consider.
            //
            //      1 - We want to use Version 0 on-disk but currently aren't.
            //      2 - We are currently using Version 0 but can free some space.
            //      3 - We are currently using Version 0 but don't want to.
            //

            if (NtfsDefaultRestartVersion != Vcb->RestartVersion) {

                NtfsUpdateOatVersion( Vcb, NtfsDefaultRestartVersion );

            } else if (NtfsDefaultRestartVersion == 0) {

                InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ),
                                    INITIAL_NUMBER_ATTRIBUTES,
                                    &Pointers );

                NtfsFreePool( Vcb->OnDiskOat->Table );
                Vcb->OnDiskOat->Table = Pointers.Table;
            }

            //
            //  Initialize first in case we get an allocation failure.
            //  Make sure we commit the current transaction.
            //

            NtfsCommitCurrentTransaction( IrpContext );

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );

            ASSERT( IsRestartTableEmpty( &Vcb->TransactionTable ));

            InitializeNewTable( sizeof( TRANSACTION_ENTRY ),
                                INITIAL_NUMBER_TRANSACTIONS,
                                &Pointers );

            NtfsFreePool( Vcb->TransactionTable.Table );
            Vcb->TransactionTable.Table = Pointers.Table;

            NtfsReleaseRestartTable( &Vcb->TransactionTable );

            //
            //  Make sure we do not process any log file before the restart
            //  area, because we did not dump the open attribute table.
            //

            RestartArea.StartOfCheckpoint = LfsQueryLastLsn( Vcb->LogHandle );

        //
        //  More work to do if this is not a clean checkpoint.
        //

        } else {

            DIRTY_PAGE_CONTEXT DirtyPageContext;
            PDIRTY_PAGE_ENTRY DirtyPage;
            POPEN_ATTRIBUTE_ENTRY OpenEntry;
            ULONG JustMe = 0;
            ULONG TempCount;
            BOOLEAN SkipCheckpoint;

            //
            //  Now we construct the dirty page table by calling the Cache Manager.
            //  For each dirty page on files tagged with our log handle, he will
            //  call us back at our DirtyPageRoutine.  We will allocate the initial
            //  Dirty Page Table, but we will let the call back routine grow it as
            //  necessary.
            //

            NtfsInitializeRestartTable( (((Vcb->RestartVersion == 0) ?
                                          sizeof( DIRTY_PAGE_ENTRY_V0 ) :
                                          sizeof( DIRTY_PAGE_ENTRY )) +
                                         ((Vcb->ClustersPerPage - 1) * sizeof(LCN))),
                                        Vcb->DirtyPageTableSizeHint,
                                        &DirtyPages );

            NtfsAcquireExclusiveRestartTable( &DirtyPages, TRUE );

            DirtyPageTableInitialized = TRUE;

            //
            //  Now we will acquire the Open Attribute Table shared to freeze changes.
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
            OpenAttributeTableAcquired = TRUE;

            NameBytes = NtfsCalculateNamedBytes( IrpContext, Vcb );

            //
            //  Now call the Cache Manager to give us all of our dirty pages
            //  via the DirtyPageRoutine callback, and remember what the oldest
            //  Lsn is for a dirty page.
            //

            RtlZeroMemory( &DirtyPageContext, sizeof( DirtyPageContext ) );
            DirtyPageContext.DirtyPageTable = &DirtyPages;
            DirtyPageContext.OldestLsn.QuadPart = MAXLONGLONG;

            CcGetDirtyPages( Vcb->LogHandle,
                             &DirtyPageRoutine,
                             (PVOID)IrpContext,
                             (PVOID)&DirtyPageContext );

            OldestDirtyPageLsn = DirtyPageContext.OldestLsn;

            //
            //  If we overflowed we can't contain the dirty pages in the dirty page
            //  table and need to do a clean checkpoint instead
            //

            if (DirtyPageContext.Overflow) {

                //
                //  We need the vcb shared for the flush which must be acquired
                //  before the OAT
                //

                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                OpenAttributeTableAcquired = FALSE;

                NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
                AcquiredVcb = TRUE;

                NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                OpenAttributeTableAcquired = TRUE;

                //
                //  Do a partial flush and see if the table no longer overflows afterwards
                //

                NtfsFlushLsnStreams( IrpContext,  Vcb, FALSE, TRUE );

                //
                //  Now call the Cache Manager to give us all of our dirty pages
                //  via the DirtyPageRoutine callback, and remember what the oldest
                //  Lsn is for a dirty page.
                //

                RtlZeroMemory( &DirtyPageContext, sizeof( DirtyPageContext ) );
                DirtyPageContext.DirtyPageTable = &DirtyPages;
                DirtyPageContext.OldestLsn.QuadPart = MAXLONGLONG;

                //
                //  Loop through to deallocate all of the prev dirty page entries
                //

                DirtyPage = NtfsGetFirstRestartTable( &DirtyPages );
                while (DirtyPage != NULL) {

                    NtfsFreeRestartTableIndex( &DirtyPages,
                                               GetIndexFromRestartEntry( &DirtyPages,
                                                                         DirtyPage ));
                    DirtyPage = NtfsGetNextRestartTable( &DirtyPages, DirtyPage );
                }

                NameBytes = NtfsCalculateNamedBytes( IrpContext, Vcb );

                CcGetDirtyPages( Vcb->LogHandle,
                                 &DirtyPageRoutine,
                                 (PVOID)IrpContext,
                                 (PVOID)&DirtyPageContext );

                OldestDirtyPageLsn = DirtyPageContext.OldestLsn;

                //
                //  If we still overflowed - give up and run a full clean checkpoint
                //

                if (DirtyPageContext.Overflow) {

#ifdef PERF_STATS
                    IrpContext->LogFullReason = LF_DIRTY_PAGES;
#endif

                    NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
                }
            }

            TempCount = DirtyPages.Table->NumberAllocated;

            Vcb->DirtyPageTableSizeHint = (TempCount & ~(INITIAL_DIRTY_TABLE_HINT - 1)) + INITIAL_DIRTY_TABLE_HINT;

            //
            //  Skip the fuzzy checkpoint if its not going to make restart any faster
            //  i.e the oldest lsn is still the same as the last time we did it
            //

            if (OldestDirtyPageLsn.QuadPart == Vcb->OldestDirtyLsn.QuadPart) {

                //
                //  Release any transaction tables
                //

                if (OpenAttributeTableAcquired) {
                    NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                    OpenAttributeTableAcquired = FALSE;
                }

                if (TransactionTableAcquired) {
                    NtfsReleaseRestartTable( &Vcb->TransactionTable );
                    TransactionTableAcquired = FALSE;
                }

                //
                //  Flush the  fileobject associated with the page if there is one
                //

                if (DirtyPageContext.OldestFileObject != NULL) {

                    PSCB Scb = (PSCB)DirtyPageContext.OldestFileObject->FsContext;
                    BOOLEAN AcquiredPaging;
                    IO_STATUS_BLOCK Iosb;
                    LARGE_INTEGER Offset;
                    ULONG Length;

                    DirtyPage = GetRestartEntryFromIndex( DirtyPageContext.DirtyPageTable, DirtyPageContext.DirtyPageIndex );

                    //
                    //  At this point the vcn in the dirty page entry is actually a raw offset
                    //

                    if (Vcb->RestartVersion == 0) {

                        Offset.QuadPart = ((PDIRTY_PAGE_ENTRY_V0)DirtyPage)->Vcn;
                        Length = ((PDIRTY_PAGE_ENTRY_V0)DirtyPage)->LengthOfTransfer;

                        ASSERT( ((PDIRTY_PAGE_ENTRY_V0)DirtyPage)->OldestLsn.QuadPart == DirtyPageContext.OldestLsn.QuadPart );

                    } else {

                        Offset.QuadPart = DirtyPage->Vcn;
                        Length = DirtyPage->LengthOfTransfer;

                        ASSERT( DirtyPage->OldestLsn.QuadPart == DirtyPageContext.OldestLsn.QuadPart );
                    }

                    //
                    //  Account for  UsnJournal biasing if necc.
                    //  note at this point the vcn is actually still a byte offset
                    //

                    if (Scb == Vcb->UsnJournal) {
                        Offset.QuadPart += Vcb->UsnCacheBias;
                    }

                    //
                    //  Acquire same synchronization as a normal lazy write before flushing
                    //

                    AcquiredPaging = NtfsAcquireScbForLazyWrite( Scb, TRUE );
                    CcFlushCache( &Scb->NonpagedScb->SegmentObject, &Offset, Length, &Iosb );

                    if (AcquiredPaging) {
                        NtfsReleaseScbFromLazyWrite( Scb );
                    }


                    ObDereferenceObject( DirtyPageContext.OldestFileObject );
                }

                leave;
            }

            //
            //  Deref the oldest file if there is any returned from DirtyPageRoutine
            //

            if (DirtyPageContext.OldestFileObject) {
                ObDereferenceObject( DirtyPageContext.OldestFileObject );
            }

            ASSERT( (OldestDirtyPageLsn.QuadPart > Vcb->OldestDirtyLsn.QuadPart) || (TempCount == 0) );

            if (OldestDirtyPageLsn.QuadPart != MAXLONGLONG) {
                Vcb->OldestDirtyLsn = OldestDirtyPageLsn;
            }

            if ((OldestDirtyPageLsn.QuadPart != 0) &&
                OldestDirtyPageLsn.QuadPart < Vcb->LastBaseLsn.QuadPart) {

                OldestDirtyPageLsn = Vcb->LastBaseLsn;
            }

            //
            //  Now loop through the dirty page table to extract all of the Vcn/Lcn
            //  Mapping that we have, and insert it into the appropriate Scb.
            //

            DirtyPage = NtfsGetFirstRestartTable( &DirtyPages );

            //
            //  The dirty page routine is called while holding spin locks,
            //  so it cannot take page faults.  Thus we must scan the dirty
            //  page table we just built and fill in the Lcns here.
            //

            while (DirtyPage != NULL) {

                PSCB Scb;

                //
                //  If we have Lcn's then look them up.
                //

                if (DirtyPage->LengthOfTransfer != 0) {

                    VCN Vcn;
                    PLCN LcnArray;

                    //
                    //  Get the in-memory AttributeEntry from the dirty page entry.
                    //  Then update the dirty page entry with the on-disk TargetAttribute.
                    //  Also mark the pages dirty now.
                    //

                    OpenEntry = GetRestartEntryFromIndex( &Vcb->OpenAttributeTable,
                                                          DirtyPage->TargetAttribute );

                    OpenEntry->DirtyPagesSeen = TRUE;
                    DirtyPage->TargetAttribute = OpenEntry->OatData->OnDiskAttributeIndex;

                    ASSERT( IsRestartTableEntryAllocated( OpenEntry ));

                    Scb = OpenEntry->OatData->Overlay.Scb;

                    //
                    //  Account for  UsnJournal biasing if necc.
                    //  note at this point the vcn is actually still a byte offset
                    //

                    if (Scb == Vcb->UsnJournal) {
                        if (Vcb->RestartVersion == 0 ) {
                            ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn = ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn + Vcb->UsnCacheBias;
                        } else {
                            DirtyPage->Vcn = DirtyPage->Vcn + Vcb->UsnCacheBias;
                        }
                    }

                    //
                    //  Fix up the count of Lcns.
                    //

                    DirtyPage->LcnsToFollow = ClustersFromBytes( Vcb, DirtyPage->LengthOfTransfer );

                    //
                    //  Now fix up the page entry to account for the differences in the
                    //  restart version structures and also make sure we don't have
                    //  an Lsn which precedes our current base Lsn.
                    //

                    if (Vcb->RestartVersion == 0) {

                        ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Reserved = 0;

                        if (((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->OldestLsn.QuadPart < Vcb->LastBaseLsn.QuadPart) {

                            ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->OldestLsn.QuadPart = Vcb->LastBaseLsn.QuadPart;
                        }

                        Vcn = ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn;
                        Vcn = Int64ShraMod32( Vcn, Vcb->ClusterShift );
                        ((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->Vcn = Vcn;

                        LcnArray = &((PDIRTY_PAGE_ENTRY_V0) DirtyPage)->LcnsForPage[0];

                    } else {

                        if (DirtyPage->OldestLsn.QuadPart < Vcb->LastBaseLsn.QuadPart) {

                            DirtyPage->OldestLsn.QuadPart = Vcb->LastBaseLsn.QuadPart;
                        }

                        DirtyPage->Vcn = Vcn = Int64ShraMod32( DirtyPage->Vcn, Vcb->ClusterShift );

                        LcnArray = &DirtyPage->LcnsForPage[0];
                    }

                    LookupLcns( IrpContext,
                                Scb,
                                Vcn,
                                DirtyPage->LcnsToFollow,
                                FALSE,
                                LcnArray );

                //
                //  Otherwise free this dirty page entry.
                //

                } else {

                    NtfsFreeRestartTableIndex( &DirtyPages,
                                               GetIndexFromRestartEntry( &DirtyPages,
                                                                         DirtyPage ));
                }

                //
                //  Point to next entry in table, or NULL.
                //

                DirtyPage = NtfsGetNextRestartTable( &DirtyPages, DirtyPage );
            }

            //
            //  If the followings are all true, we can return as we don't want to
            //  keep writing empty fuzzy checkpoints on idling volumes:
            //
            //  1) Last fuzzy checkpoint was clean (no dirty pages or no open transaction)
            //  2) No one has written to the log since last restart record
            //  3) Currently, there isn't any dirty page
            //  4) Currently, there isn't any transaction in the transaction table
            //

            if (FlagOn( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_PSEUDO_CLEAN ) &&
                (RestartArea.StartOfCheckpoint.QuadPart == Vcb->EndOfLastCheckpoint.QuadPart) &&
                IsRestartTableEmpty( &DirtyPages )) {

                NtfsAcquireSharedStarveExRestartTable( &Vcb->TransactionTable, TRUE );

                SkipCheckpoint = IsRestartTableEmpty( &Vcb->TransactionTable );

                NtfsReleaseRestartTable( &Vcb->TransactionTable );

            } else {

                SkipCheckpoint = FALSE;
            }

            if (SkipCheckpoint) {

                //
                //  Let's take this opportunity to shrink the Open Attribute and Transaction
                //  table back if they have gotten large.
                //

                //
                //  First the Open Attribute Table
                //

                if (!OpenAttributeTableAcquired) {

                    NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                    OpenAttributeTableAcquired = TRUE;
                } else {

                    ASSERT( ExIsResourceAcquiredExclusive( &Vcb->OpenAttributeTable.Resource ) );
                }

                if (IsRestartTableEmpty( &Vcb->OpenAttributeTable ) &&
                    (Vcb->OpenAttributeTable.Table->NumberEntries > HIGHWATER_ATTRIBUTE_COUNT)) {

                    //
                    //  Initialize first in case we get an allocation failure.
                    //

                    InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY ),
                                        INITIAL_NUMBER_ATTRIBUTES,
                                        &Pointers );

                    NtfsFreePool( Vcb->OpenAttributeTable.Table );
                    Vcb->OpenAttributeTable.Table = Pointers.Table;

                    //
                    //  Also reinitialize the OnDisk table if different.
                    //

                    if (Vcb->OnDiskOat != &Vcb->OpenAttributeTable) {

                        //
                        //  Initialize first in case we get an allocation failure.
                        //

                        InitializeNewTable( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ),
                                            INITIAL_NUMBER_ATTRIBUTES,
                                            &Pointers );

                        NtfsFreePool( Vcb->OnDiskOat->Table );
                        Vcb->OnDiskOat->Table = Pointers.Table;
                    }
                }

                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
                OpenAttributeTableAcquired = FALSE;

                //
                //  Now check the transaction table (freeing in the finally clause).
                //

                if (!TransactionTableAcquired) {

                    NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
                    TransactionTableAcquired = TRUE;

                } else {

                    ASSERT( ExIsResourceAcquiredExclusive( &Vcb->TransactionTable.Resource ) );
                }

                if (IsRestartTableEmpty( &Vcb->TransactionTable )) {

                    LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );

                    if (Vcb->TransactionTable.Table->NumberEntries > HIGHWATER_TRANSACTION_COUNT) {

                        //
                        //  Initialize first in case we get an allocation failure.
                        //

                        InitializeNewTable( sizeof(TRANSACTION_ENTRY),
                                            INITIAL_NUMBER_TRANSACTIONS,
                                            &Pointers );

                        NtfsFreePool( Vcb->TransactionTable.Table );
                        Vcb->TransactionTable.Table = Pointers.Table;
                    }
                }

                leave;

            } else {

                //
                //  Take this opportunity to clear this flag first since we now know
                //  this is not a pseudo clean checkpoint.
                //

                ClearFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_PSEUDO_CLEAN );
            }

            //
            //  If there were any names, then allocate space for them and copy
            //  them out.
            //

            if (NameBytes != 0) {

                PATTRIBUTE_NAME_ENTRY Name;

                //
                //  Allocate the buffer, with space for two terminating 0's on
                //  the end.
                //

                NameBytes += 4;
                Name =
                NamesBuffer = NtfsAllocatePool( NonPagedPool, NameBytes );

                //
                //  Now loop to copy the names.
                //

                AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

                while (AttributeEntry != NULL) {

                    //
                    //  Free the Open Attribute Entry if there were no
                    //  dirty pages and the Scb is gone.  This is the only
                    //  place they are deleted.  (Yes, I know we allocated
                    //  space for its name, but I didn't want to make three
                    //  passes through the open attribute table.  Permeter
                    //  is running as we speak, and showing 407 open files
                    //  on NT/IDW5.)
                    //

                    if (!AttributeEntry->DirtyPagesSeen

                            &&

                        (AttributeEntry->OatData->Overlay.Scb == NULL)) {

                        ULONG Index;

                        //
                        //  Get the index for the entry.
                        //

                        Index = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                                          AttributeEntry );

                        //
                        //  Delete its name and free it up.
                        //

                        NtfsFreeScbAttributeName( AttributeEntry->OatData->AttributeName.Buffer );

                        if (Vcb->RestartVersion == 0) {

                            NtfsFreeRestartTableIndex( Vcb->OnDiskOat,
                                                       AttributeEntry->OatData->OnDiskAttributeIndex );
                        }

                        NtfsFreeOpenAttributeData( AttributeEntry->OatData );
                        NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable, Index );

                    //
                    //  Otherwise, if we are not deleting it, we have to
                    //  copy its name into the buffer we allocated.
                    //

                    } else if (AttributeEntry->OatData->AttributeName.Length != 0) {

                        //
                        //  Prefix each name in the buffer with the attribute index
                        //  and name length.  Be sure to use the index that will
                        //  be on-disk.
                        //

                        Name->Index = (USHORT) AttributeEntry->OatData->OnDiskAttributeIndex;

                        Name->NameLength = AttributeEntry->OatData->AttributeName.Length;
                        RtlCopyMemory( &Name->Name[0],
                                       AttributeEntry->OatData->AttributeName.Buffer,
                                       AttributeEntry->OatData->AttributeName.Length );

                        Name->Name[Name->NameLength / sizeof( WCHAR )] = 0;

                        Name = (PATTRIBUTE_NAME_ENTRY)((PCHAR)Name +
                                                       sizeof(ATTRIBUTE_NAME_ENTRY) +
                                                       Name->NameLength);

                        ASSERT( (PCHAR)Name <= ((PCHAR)NamesBuffer + NameBytes - 4) );
                    }

                    AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                              AttributeEntry );
                }

                //
                //  Terminate the Names Buffer.
                //

                Name->Index = 0;
                Name->NameLength = 0;
            }

            //
            //  Now write all of the non-empty tables to the log.
            //

            //
            //  Write the Open Attribute Table
            //
            //  Make sure the tables are in sync.
            //

            ASSERT( (IsRestartTableEmpty( Vcb->OnDiskOat ) && IsRestartTableEmpty( &Vcb->OpenAttributeTable )) ||
                    (!IsRestartTableEmpty( Vcb->OnDiskOat ) && !IsRestartTableEmpty( &Vcb->OpenAttributeTable )));

            if (!IsRestartTableEmpty( Vcb->OnDiskOat )) {
                RestartArea.OpenAttributeTableLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              OpenAttributeTableDump,
                              Vcb->OnDiskOat->Table,
                              SizeOfRestartTable( Vcb->OnDiskOat ),
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.OpenAttributeTableLength = SizeOfRestartTable( Vcb->OnDiskOat );
                JustMe = 1;
            }

            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            OpenAttributeTableAcquired = FALSE;

            //
            //  Write the Open Attribute Names
            //

            if (NameBytes != 0) {
                RestartArea.AttributeNamesLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              AttributeNamesDump,
                              NamesBuffer,
                              NameBytes,
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.AttributeNamesLength = NameBytes;
                JustMe = 1;
            }

            //
            //  Write the Dirty Page Table
            //

            if (!IsRestartTableEmpty( &DirtyPages )) {
                RestartArea.DirtyPageTableLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              DirtyPageTableDump,
                              DirtyPages.Table,
                              SizeOfRestartTable(&DirtyPages),
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.DirtyPageTableLength = SizeOfRestartTable(&DirtyPages);
                JustMe = 1;
            }

            //
            //  Write the Transaction Table if there is more than just us.  We
            //  are a transaction if we wrote any log records above.
            //

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
            TransactionTableAcquired = TRUE;

            //
            //  Assume we will want to do at least one more checkpoint.
            //

            ClearFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_CLEAN );

            if ((ULONG)Vcb->TransactionTable.Table->NumberAllocated > JustMe) {
                RestartArea.TransactionTableLsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NULL,
                              TransactionTableDump,
                              Vcb->TransactionTable.Table,
                              SizeOfRestartTable(&Vcb->TransactionTable),
                              Noop,
                              NULL,
                              0,
                              (LONGLONG)0,
                              0,
                              0,
                              0 );

                RestartArea.TransactionTableLength =
                  SizeOfRestartTable(&Vcb->TransactionTable);

                //
                //  Loop to see if the oldest Lsn comes from the transaction table.
                //

                TransactionEntry = NtfsGetFirstRestartTable( &Vcb->TransactionTable );

                while (TransactionEntry != NULL) {

                    if ((TransactionEntry->FirstLsn.QuadPart != 0) &&

                        (TransactionEntry->FirstLsn.QuadPart < BaseLsn.QuadPart)) {

                        BaseLsn = TransactionEntry->FirstLsn;
                    }

                    TransactionEntry = NtfsGetNextRestartTable( &Vcb->TransactionTable,
                                                                TransactionEntry );
                }

                //
                //  If LastTransactionLsnCount is non-zero, we should check to see if it's smaller than BaseLsn.
                //  This is due to the window between creating a transaction to the point where we update
                //  the FirstLsn in NtfsWriteLog.
                //

                if (Vcb->LastTransactionLsnCount != 0) {

                    if (Vcb->LastTransactionLsn.QuadPart < BaseLsn.QuadPart) {

                        BaseLsn = Vcb->LastTransactionLsn;
                    }
                }

            //
            //  If the transaction table is otherwise empty, then this is a good
            //  time to reset our totals with Lfs, in case our counts get off a bit.
            //

            } else {

                //
                //  If we are a transaction, then we have to add in our counts.
                //

                if (IrpContext->TransactionId != 0) {

                    TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                                        &Vcb->TransactionTable, IrpContext->TransactionId );

                    LfsResetUndoTotal( Vcb->LogHandle,
                                       TransactionEntry->UndoRecords + 2,
                                       TransactionEntry->UndoBytes +
                                         QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );

                //
                //  Otherwise, we reset to our "idle" requirements.
                //

                } else {
                    LfsResetUndoTotal( Vcb->LogHandle,
                                       2,
                                       QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
                }

                //
                //  If the DirtyPage table is empty then mark this as a clean checkpoint.
                //

                if (IsRestartTableEmpty( &DirtyPages )) {

                    //
                    //  Remember the fact that this fuzzy checkpoint is pseudo clean
                    //  in the sense that the dirty page and transaction tables are empty.
                    //  It's ok if the other two tables are not empty as they are not important
                    //  in this case and will be cleaned up later on.
                    //

                    SetFlag( Vcb->CheckpointFlags, VCB_LAST_CHECKPOINT_PSEUDO_CLEAN );
                }
            }

            NtfsReleaseRestartTable( &Vcb->TransactionTable );
            TransactionTableAcquired = FALSE;
        }

        //
        //  So far BaseLsn holds the minimum of the start Lsn for the checkpoint,
        //  or any of the FirstLsn fields for active transactions.  Now we see
        //  if the oldest Lsn we need in the log should actually come from the
        //  oldest page in the dirty page table.
        //

        if ((OldestDirtyPageLsn.QuadPart != 0) &&

            (OldestDirtyPageLsn.QuadPart < BaseLsn.QuadPart)) {

            BaseLsn = OldestDirtyPageLsn;
        }

        //
        //  Now fill in the LowestOpenUsn in the RestartArea.  This is an unsafe
        //  test, but if we think we see an empty list, that is ok.  In case no
        //  files are open yet, make sure we do not backtrack from the number we got
        //  at restart.
        //

        RestartArea.MajorVersion = Vcb->RestartVersion;
        RestartArea.CurrentLsnAtMount = Vcb->CurrentLsnAtMount;
        RestartArea.BytesPerCluster = Vcb->BytesPerCluster;

        RestartArea.Reserved = 0;
        RestartArea.UsnJournalReference = Vcb->UsnJournalReference;
        RestartArea.UsnCacheBias = Vcb->UsnCacheBias;

        UsnJournal = Vcb->UsnJournal;
        if (UsnJournal != NULL) {

            //
            //  Continue to advance the Usn in the Vcb on checkpoints, so that
            //  if the list goes empty we do not get a restart that has to go
            //  back to where we were at boot time. We use the value we captured at
            //  the beginning - we own end resources (the transaction tables)
            //  here so we can't reacquire the usn journal
            //

            RestartArea.LowestOpenUsn = Vcb->LowestOpenUsn = LowestOpenUsn;
        }

        //
        //  BaseLsn must be monotonically increasing or we'll throw away recently
        //  deallocatedclusters erroneously before they can be reused
        //

        ASSERT( Vcb->LastBaseLsn.QuadPart <= BaseLsn.QuadPart );
        Vcb->LastBaseLsn = Vcb->LastRestartArea = BaseLsn;

        //
        //  Finally, write our Restart Area to describe all of the above, and
        //  give Lfs our new BaseLsn.
        //

        LfsWriteRestartArea( Vcb->LogHandle,
                             sizeof( RESTART_AREA ),
                             &RestartArea,
                             LfsCleanShutdown,
                             &Vcb->LastRestartArea );

        //
        //  Extra work at the end of a clean checkpoint
        //

        if (CleanVolume) {

            //
            //  Mark the fact that we've done a clean checkpoint at this time.
            //

            Vcb->CleanCheckpointMark = Vcb->LogFileFullCount;
            Vcb->UnhandledLogFileFullCount = 0;
            Vcb->LastRestartAreaAtNonTopLevelLogFull.QuadPart = 0;

            //
            //  Initialize our reserved area.
            //  Also set the LastBaseLsn to the restart area itself.  This will
            //  prevent us from generating future dirty page table entries
            //  which go back prior to the restart area.
            //

            Vcb->LastBaseLsn = Vcb->LastRestartArea;
            LfsResetUndoTotal( Vcb->LogHandle, 2, QuadAlign(sizeof(RESTART_AREA)) + (2 * PAGE_SIZE) );
            Vcb->DirtyPageTableSizeHint = INITIAL_DIRTY_TABLE_HINT;
        }

        //
        //  Now remember where the log file is at now, so we know when to
        //  go idle above.
        //

        Vcb->EndOfLastCheckpoint = LfsQueryLastLsn( Vcb->LogHandle );

    } finally {

        DebugUnwind( NtfsCheckpointVolume );

        //
        //  If the Dirty Page Table got initialized, free it up.
        //

        if (DirtyPageTableInitialized) {
            NtfsFreeRestartTable( &DirtyPages );
        }

        //
        //  Release any resources
        //

        if (OpenAttributeTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
        }

        if (TransactionTableAcquired) {
            NtfsReleaseRestartTable( &Vcb->TransactionTable );
        }

        //
        //  Release any names buffer.
        //

        if (NamesBuffer != NULL) {
            NtfsFreePool( NamesBuffer );
        }

        //
        //  Free any partial table we allocated.
        //

        if (NewTable != NULL) {

            NtfsFreePool( NewTable );
        }

        //
        //  If this checkpoint created a transaction, free the index now.
        //

        if (IrpContext->TransactionId != 0) {

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                              TRUE );

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                       IrpContext->TransactionId );

            NtfsReleaseRestartTable( &Vcb->TransactionTable );

            IrpContext->TransactionId = 0;
        }

        if (AcquireFiles) {

#ifdef NTFSDBG
            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
            DebugDoit( ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_CHECKPOINT_ACTIVE ));
#endif  //  NTFSDBG

            NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
        }

        if (AcquiredVcb) {

            if (CleanVolume) {

                //
                //  If we acquire the vcb we also set the drain pending for the transaction table
                //  and open attribute table. Turn that off now
                //

                NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable, TRUE );
                Vcb->TransactionTable.DrainPending = FALSE;
                NtfsReleaseRestartTable( &Vcb->TransactionTable );

                NtfsAcquireExclusiveRestartTable( &Vcb->OpenAttributeTable, TRUE );
                Vcb->OpenAttributeTable.DrainPending = FALSE;
                NtfsReleaseRestartTable( &Vcb->OpenAttributeTable );
            }

            NtfsReleaseVcb( IrpContext, Vcb );
        }

#ifdef PERF_STATS

        if (Tracking) {
            KeQueryTickCount( (PLARGE_INTEGER)&Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].ElapsedTime );
            Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].ElapsedTime -=
                Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].StartTime;
            Vcb->ChkPointEntry[ Vcb->CurrentCheckpoint % NUM_CHECKPOINT_ENTRIES ].NumIos = IrpContext->Ios;

            Vcb->CurrentCheckpoint += 1;
        }
#endif

        //
        //  Capture the current base lsn before potentially giving up chkpt synchrnonization
        //  

        BaseLsn = Vcb->LastBaseLsn;

        //
        //  If we didn't own the checkpoint operation then indicate
        //  that someone else is free to checkpoint.  Hold the checkpoint
        //  flags if we plan to trim the usn journal.  The checkpoint
        //  flags serialize the journal with the delete journal operation.
        //

        ASSERT( !OwnsCheckpoint || CleanVolume );

        if (!OwnsCheckpoint) {

            if ((UsnJournal == NULL) || CleanVolume || AbnormalTermination()) {

                NtfsAcquireCheckpoint( IrpContext, Vcb );
                ClearFlag( Vcb->CheckpointFlags,
                           VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED );

                NtfsSetCheckpointNotify( IrpContext, Vcb );
                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }
        }

        if (RestorePreviousPriority) {

            KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                 PreviousPriority );
        }
    }

    //
    //  We shouldn't have the OAT acquired anymore and the base lsn we're using to
    //  trim the  deallocated cluster list must not be > than the last base lsn in the
    //  vcb
    //  

    ASSERT( !ExIsResourceAcquiredSharedLite( &Vcb->OpenAttributeTable.Resource ) && 
            (BaseLsn.QuadPart <= Vcb->LastBaseLsn.QuadPart) );

    NtfsFreeRecentlyDeallocated( IrpContext, Vcb, &BaseLsn, CleanVolume );

    //
    //  If there is a Usn Journal, call to perform possible trimming on a periodic checkpoint.
    //

    if (!CleanVolume && (UsnJournal != NULL)) {
        NtfsTrimUsnJournal( IrpContext, Vcb );
    }

    //
    //  If we need to post a defrag request then do so now.
    //

    if (PostDefrag) {

        PDEFRAG_MFT DefragMft;

        //
        //  Use a try-except to ignore allocation errors.
        //

        try {

            NtfsAcquireCheckpoint( IrpContext, Vcb );

            if (!FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE )) {

                SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE );
                NtfsReleaseCheckpoint( IrpContext, Vcb );

                DefragMft = NtfsAllocatePool( NonPagedPool, sizeof( DEFRAG_MFT ));

                DefragMft->Vcb = Vcb;
                DefragMft->DeallocateWorkItem = TRUE;

                //
                //  Send it off.....
                //

                ExInitializeWorkItem( &DefragMft->WorkQueueItem,
                                      (PWORKER_THREAD_ROUTINE)NtfsDefragMft,
                                      (PVOID)DefragMft );

                ExQueueWorkItem( &DefragMft->WorkQueueItem, CriticalWorkQueue );

            } else {

                NtfsReleaseCheckpoint( IrpContext, Vcb );
            }

        } except( FsRtlIsNtstatusExpected( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH ) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ACTIVE );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCheckpointVolume -> VOID\n") );
}


VOID
NtfsCheckpointForLogFileFull (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to perform the clean checkpoint generated after
    a log file full.  This routine will call the clean checkpoint routine
    and then release all of the resources acquired.


Arguments:

Return Value:

    None.

--*/

{
    LSN LastKnownLsn;

    PAGED_CODE();
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    IrpContext->ExceptionStatus = 0;

    //
    //  Call the checkpoint routine to do the actual work.  Skip this in the case where there is no
    //  longer a Vcb in the IrpContext.  This can happen if doing some long running operation at
    //  mount time (i.e. Usn scan).  In that case the long running operation should periodically
    //  checkpoint.  Then Ntfs will do a clean checkpoint after restart and the remaining work
    //  to do in the long-running operation will decrease.  At some point it will decrease enough
    //  to finish the mount.
    //
    //  All of the other work is required since this IrpContext will be used to retry the mount.
    //

    if (IrpContext->Vcb != NULL) {

        //
        //  If we're only trying to synchronize with a clean checkpoint use Li0 for
        //  the lastknownLsn which will guarantee after NtfsCheckpointvolume gets
        //  checkpoint synchronization it won't do anymore work. Otherwise use
        //  the last restart area we recorded in NtfsProcessException at the raise point
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ONLY_SYNCH_CHECKPOINT )) {
            LastKnownLsn = IrpContext->LastRestartArea;
        } else {
            LastKnownLsn = Li0;
        }

        //
        //  This can raise. However, in the case of dismounts, we do want this to
        //  plough on and succeed the dismount. For example, cluster service marks
        //  the volume offline first and sends the dismount afterward, but still expects it to succeed.
        //

        try {

            NtfsCheckpointVolume( IrpContext,
                                  IrpContext->Vcb,
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  0,
                                  LastKnownLsn );

        } except (NtfsCheckpointExceptionFilter( IrpContext,
                                                 GetExceptionInformation(),
                                                 GetExceptionCode() )) {

            //
            //  This is a LOG_FILE_FULL raise coming via dismount. Ignore errors
            //  because we want the dismount to succeed.
            //

            NtfsMinimumExceptionProcessing( IrpContext );
            if (IrpContext->TransactionId != 0) {

                NtfsCleanupFailedTransaction( IrpContext );
            }
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ONLY_SYNCH_CHECKPOINT );
    }

    ASSERT( IrpContext->TransactionId == 0 );
    ASSERT( !ExIsResourceAcquiredSharedLite( &IrpContext->Vcb->OpenAttributeTable.Resource ) );

    //
    //  Cleanup the IrpContext but don't delete it.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
    NtfsCleanupIrpContext( IrpContext, TRUE );

    //
    //  Make sure we restore the RestartArea.
    //

    IrpContext->LastRestartArea = Li0;
    return;
}


NTSTATUS
NtfsCheckpointForVolumeSnapshot (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to perform a volume flush and a
    clean checkpoint before a snapshot of the volume is taken.
    Since we need to keep the volume quiescent, we make it a
    point to leave the file resources acquired on exit.

Arguments:
    IrpContext.

Return Value:

    Status.

--*/

{
    LOGICAL AcquiredCheckpoint;
    LOGICAL AcquiredFiles = FALSE;
    LOGICAL AcquiredVcb = FALSE;
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    LOGICAL DefragPermitted;
    KPRIORITY PreviousPriority;
    BOOLEAN RestorePreviousPriority = FALSE;

    PAGED_CODE();

    //
    //  Clear the Mft defrag flag to stop any actions behind our backs.
    //

    Vcb = IrpContext->Vcb;

    //
    //  If this is a readonly volume, then there's nothing we need to do.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        ASSERT( Status == STATUS_SUCCESS );
        DebugTrace( -1, Dbg, ("NtfsCheckpointForVolumeSnapshot -> %08lx\n", Status) );

        return Status;
    }

    NtfsAcquireCheckpoint( IrpContext, Vcb );
    DefragPermitted = FlagOn( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
    NtfsReleaseCheckpoint( IrpContext, Vcb );
    AcquiredCheckpoint = FALSE;

    try {

        //
        //  Then lock out all other checkpoint operations.
        //

        NtfsAcquireCheckpoint( IrpContext, Vcb );

        while (FlagOn( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS )) {

            //
            //  Release the checkpoint event because we cannot checkpoint now.
            //

            NtfsReleaseCheckpoint( IrpContext, Vcb );
            NtfsWaitOnCheckpointNotify( IrpContext, Vcb );
            NtfsAcquireCheckpoint( IrpContext, Vcb );
        }

        SetFlag( Vcb->CheckpointFlags, VCB_CHECKPOINT_SYNC_FLAGS );
        NtfsResetCheckpointNotify( IrpContext, Vcb );
        NtfsReleaseCheckpoint( IrpContext, Vcb );
        AcquiredCheckpoint = TRUE;

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        AcquiredVcb = TRUE;

        //
        //  Check that the volume is still mounted.
        //

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Start by flushing the volume, because we can't call FlushVolume later
        //  while holding only the Main resources without their corresponding
        //  pagingio resources. Flushing the userdata doesn't really need to be
        //  atomic with the rest of the operation; we just have to make sure that
        //  the volume is consistent and restartable without log recovery.
        //

        NtfsFlushVolume( IrpContext,
                         Vcb,
                         TRUE,
                         FALSE,
                         TRUE,
                         FALSE );

        //
        //  Give ourselves some juice. We'll need it.
        //

        PreviousPriority = KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                                LOW_REALTIME_PRIORITY );

        if (PreviousPriority != LOW_REALTIME_PRIORITY) {

            RestorePreviousPriority = TRUE;
        }

        //
        //  Lock, stock, clean checkpoint, volume flush and
        //  two smoking barrels. No chance of acquiring PagingIo
        //  here; pretty much only shutdown has that luxury.
        //

        NtfsAcquireAllFiles( IrpContext, Vcb, TRUE, FALSE, FALSE );
        AcquiredFiles = TRUE;

        //
        //  Generate usn CLOSE records. We don't bother to get the FcbMutex because
        //  we already have the Fcb main resource exclusively.
        //

        if (Vcb->UsnJournal != NULL) {

            PLIST_ENTRY Links;
            PFCB_USN_RECORD UsnRecord;

            while (TRUE) {

                NtfsLockFcb( IrpContext, Vcb->UsnJournal->Fcb );

                Links = Vcb->ModifiedOpenFiles.Flink;
                if (Links == &Vcb->ModifiedOpenFiles) {

                    NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );
                    break;
                }

                UsnRecord = (PFCB_USN_RECORD)CONTAINING_RECORD( Links,
                                                                FCB_USN_RECORD,
                                                                ModifiedOpenFilesLinks );

                NtfsUnlockFcb( IrpContext, Vcb->UsnJournal->Fcb );

                //
                //  Post the CLOSE record. Checkpointing takes this UsnRecord
                //  off the ModifiedOpenFiles list.
                //

                NtfsPostUsnChange( IrpContext, UsnRecord->Fcb, USN_REASON_CLOSE );
                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );

            }
        }

        SetFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

#ifdef PERF_STATS
        IrpContext->LogFullReason = LF_SNAPSHOT;
#endif

        NtfsCheckpointVolume( IrpContext, Vcb, TRUE, TRUE, FALSE, 0, Vcb->LastRestartArea );
        NtfsCommitCurrentTransaction( IrpContext );

        ClearFlag( Vcb->VcbState, VCB_STATE_VOL_PURGE_IN_PROGRESS );

    } finally {

        //
        //  Restore DEFRAG_PERMITTED flag if we need to.
        //

        if (DefragPermitted) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        //
        //  Release the checkpoint, if we got it, but we aren't releasing
        //  all the files unless there was an error.
        //

        if (AcquiredCheckpoint) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->CheckpointFlags,
                       VCB_CHECKPOINT_SYNC_FLAGS | VCB_DUMMY_CHECKPOINT_POSTED);
            NtfsSetCheckpointNotify( IrpContext, Vcb );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

        //
        //  Release the file resources only if we hit an error.
        //  We normally do this in the completion routine for the IOCTL.
        //

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            if (AcquiredFiles) {

                NtfsReleaseAllFiles( IrpContext, Vcb, FALSE );
            }

            if (AcquiredVcb) {

                NtfsReleaseVcb( IrpContext, Vcb );
            }
        }

        if (RestorePreviousPriority) {

            KeSetPriorityThread( (PKTHREAD)PsGetCurrentThread(),
                                 PreviousPriority );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCheckpointForVolsnap -exit\n") );

    return Status;
}


VOID
NtfsCleanCheckpoint (
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to perform a single clean checkpoint at the top level
    and return.  It is used when the lazy writer gets a log file full in order
    to perform the clean checkpoint within the thread doing the lazy write.

Arguments:

Return Value:

    None.

--*/
{
    IRP_CONTEXT LocalIrpContext;
    PIRP_CONTEXT IrpContext = &LocalIrpContext;
    PAGED_CODE();

    try {

        //
        //  Allocate an Irp Context for the request.
        //

        NtfsInitializeIrpContext( NULL, TRUE, &IrpContext );
        IrpContext->Vcb = Vcb;

        if (Vcb->LastRestartAreaAtNonTopLevelLogFull.QuadPart != 0) {
            IrpContext->LastRestartArea = Vcb->LastRestartAreaAtNonTopLevelLogFull;
        }  else {
            IrpContext->LastRestartArea = Vcb->LastRestartArea;
        }

        //
        //  There is no point in posting any dummy requests.
        //

        NtfsAcquireCheckpoint( IrpContext, IrpContext->Vcb );
        SetFlag( IrpContext->Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED );
        NtfsReleaseCheckpoint( IrpContext, IrpContext->Vcb );

        //
        //  Send this off to the FspDispatch routine.  It will handle all of the
        //  top level logic as well as deleting the IrpContext.
        //

        NtfsFspDispatch( IrpContext );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        NOTHING;
    }

    return;
}


VOID
NtfsCommitCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine commits the current transaction by writing a final record
    to the log and deallocating the transaction Id.

Arguments:

Return Value:

    None.

--*/

{
    PTRANSACTION_ENTRY TransactionEntry;
    PVCB Vcb = IrpContext->Vcb;
    PFCB UsnFcb;
    PUSN_FCB ThisUsn, LastUsn;

    PAGED_CODE();

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    try {
#endif

    //
    //  Walk through the queue of usn records.  We want to remove any effect of this operation.
    //

    ThisUsn = &IrpContext->Usn;

    do {

        //
        //  If we log the close for a file, then it is time to reset the
        //  Usn reasons for the file.  Nothing to do here unless we
        //  wrote new reasons.
        //

        if (ThisUsn->CurrentUsnFcb != NULL ) {

            PSCB UsnJournal = Vcb->UsnJournal;
            PFCB_USN_RECORD FcbUsnRecord;


            UsnFcb = ThisUsn->CurrentUsnFcb;

            NtfsLockFcb( IrpContext, UsnFcb );

            if (UsnJournal != NULL) {
                NtfsLockFcb( IrpContext, UsnJournal->Fcb );
            }

            FcbUsnRecord = UsnFcb->FcbUsnRecord;

            //
            //  After locking the fcb test for the presence of the fcb record again
            //  DeleteUsnJournal may have already removed it
            //

            if (FcbUsnRecord) {

                UsnFcb->Usn = FcbUsnRecord->UsnRecord.Usn;

                //
                //  Now add or move the Fcb in the ModifiedOpenFiles list.
                //

                if (FlagOn( FcbUsnRecord->UsnRecord.Reason, USN_REASON_CLOSE )) {

                    //
                    //  Clean up the UsnRecord in the Fcb.
                    //

                    FcbUsnRecord->UsnRecord.Reason = 0;
                    FcbUsnRecord->UsnRecord.SourceInfo = 0;

                    if (UsnJournal != NULL) {

                        if( FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL ) {

                            RemoveEntryList( &FcbUsnRecord->ModifiedOpenFilesLinks );
                            FcbUsnRecord->ModifiedOpenFilesLinks.Flink = NULL;

                            if (FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                                RemoveEntryList( &FcbUsnRecord->TimeOutLinks );
                                FcbUsnRecord->TimeOutLinks.Flink = NULL;
                            }
                        }
                    }

                } else {

                    if (UsnJournal != NULL) {

                        if (FcbUsnRecord->ModifiedOpenFilesLinks.Flink != NULL) {

                            RemoveEntryList( &FcbUsnRecord->ModifiedOpenFilesLinks );
                            if (FcbUsnRecord->TimeOutLinks.Flink != NULL) {

                                RemoveEntryList( &FcbUsnRecord->TimeOutLinks );
                                FcbUsnRecord->TimeOutLinks.Flink = NULL;
                            }
                        }

                        InsertTailList( &Vcb->ModifiedOpenFiles, &FcbUsnRecord->ModifiedOpenFilesLinks );

                        if (UsnFcb->CleanupCount == 0) {

                            InsertTailList( Vcb->CurrentTimeOutFiles, &FcbUsnRecord->TimeOutLinks );
                        }
                    }
                }
            }

            //
            //  Cleanup the UsnFcb in the IrpContext.  It's possible that
            //  we might want to reuse the UsnFcb later in this request.
            //


            if (ThisUsn != &IrpContext->Usn) {

                LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                NtfsFreePool( ThisUsn );
                ThisUsn = LastUsn;

            } else {

                RtlZeroMemory( &ThisUsn->CurrentUsnFcb,
                               sizeof( USN_FCB ) - FIELD_OFFSET( USN_FCB, CurrentUsnFcb ));
            }

            if (UsnJournal != NULL) {
                NtfsUnlockFcb( IrpContext, UsnJournal->Fcb );
            }
            NtfsUnlockFcb( IrpContext, UsnFcb );
        }

        if (ThisUsn->NextUsnFcb == NULL) { break; }

        //
        //  Move to the next entry.
        //

        LastUsn = ThisUsn;
        ThisUsn = ThisUsn->NextUsnFcb;
    } while (TRUE);

    //
    //  If this request created a transaction, complete it now.
    //

    if (IrpContext->TransactionId != 0) {

        LSN CommitLsn;

        //
        //  It is possible to get a LOG_FILE_FULL before writing
        //  out the first log record of a transaction.  In that
        //  case there is a transaction Id but we haven't reserved
        //  space in the log file.  It is wrong to write the
        //  commit record in this case because we can get an
        //  unexpected LOG_FILE_FULL.  We can also test the UndoRecords
        //  count in the transaction entry but don't want to acquire
        //  the restart table to make this check.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WROTE_LOG )) {

            //
            //  Write the log record to "forget" this transaction,
            //  because it should not be aborted.  Until if/when we
            //  do real TP, commit and forget are atomic.
            //

            CommitLsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NULL,
                          ForgetTransaction,
                          NULL,
                          0,
                          CompensationLogRecord,
                          (PVOID)&Li0,
                          sizeof( IrpContext->ExceptionStatus ),  //  final exception status
                          (LONGLONG)IrpContext->ExceptionStatus,
                          0,
                          0,
                          0 );
        }

        //
        //  We can now free the transaction table index, because we are
        //  done with it now.
        //

        NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                          TRUE );

        TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                            &Vcb->TransactionTable,
                            IrpContext->TransactionId );

        //
        //  Call Lfs to free our undo space.
        //

        if ((TransactionEntry->UndoRecords != 0) &&
            (!FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ))) {

            LfsResetUndoTotal( Vcb->LogHandle,
                               TransactionEntry->UndoRecords,
                               -TransactionEntry->UndoBytes );
        }

        NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                   IrpContext->TransactionId );

        //
        //  Mark that there is no transaction for the irp and signal
        //  any waiters if there are no transactions left
        //

        if (Vcb->TransactionTable.Table->NumberAllocated == 0) {

            KeSetEvent( &Vcb->TransactionsDoneEvent, 0, FALSE );
        }

        NtfsReleaseRestartTable( &Vcb->TransactionTable );

        IrpContext->TransactionId = 0;

        //
        //  One way we win by being recoverable, is that we do not really
        //  have to do write-through - flushing the updates to the log
        //  is enough.  We don't make this call if we are in the abort
        //  transaction path.  Otherwise we could get a log file full
        //  while aborting.
        //

        if (FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_WRITE_THROUGH ) &&
            (IrpContext == IrpContext->TopLevelIrpContext) &&
            (IrpContext->TopLevelIrpContext->ExceptionStatus == STATUS_SUCCESS)) {

            NtfsUpdateScbSnapshots( IrpContext );
            LfsFlushToLsn( Vcb->LogHandle, CommitLsn );
        }
    }

    //
    //  Signal any waiters for the new length.
    //

    if (IrpContext->CheckNewLength != NULL) {

        NtfsProcessNewLengthQueue( IrpContext, FALSE );
    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    } except( ASSERT( GetExceptionCode() != STATUS_LOG_FILE_FULL ), EXCEPTION_CONTINUE_SEARCH ) {
    }
#endif

}


VOID
NtfsCheckpointCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine checkpoints the current transaction by commiting it
    to the log and deallocating the transaction Id.  The current request
    cann keep running, but changes to date are committed and will not be
    backed out.

Arguments:

Return Value:

    None.

--*/

{
    PVCB Vcb = IrpContext->Vcb;
    PAGED_CODE();

    //
    //  If there are new UsnReasons in the IrpContext, then we should write the journal
    //  now.  Note that it is ok for a checkpoint to get logfile full, but in general commit
    //  should not.
    //

    if ((IrpContext->Usn.NewReasons | IrpContext->Usn.RemovedSourceInfo) != 0) {
        NtfsWriteUsnJournalChanges( IrpContext );
    }

    NtfsCommitCurrentTransaction( IrpContext );

    //
    //  Cleanup any recently deallocated record information for this transaction.
    //

    NtfsDeallocateRecordsComplete( IrpContext );
    IrpContext->DeallocatedClusters = 0;
    IrpContext->FreeClusterChange = 0;

    //
    //  The following resources may have been flagged for immediate release on commit.
    //

    if (Vcb->AcquireFilesCount == 0) {

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL )) {
            NtfsReleaseScb( IrpContext, Vcb->UsnJournal );
        }

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT )) {
            NtfsReleaseScb( IrpContext, Vcb->MftScb );
        }
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                  IRP_CONTEXT_FLAG_RELEASE_MFT );

    NtfsUpdateScbSnapshots( IrpContext );
}


VOID
NtfsInitializeLogging (
    )

/*

Routine Description:

    This routine is to be called once during startup of Ntfs (not once
    per volume), to initialize the logging support.

Parameters:

    None

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeLogging:\n") );
    LfsInitializeLogFileService();
    DebugTrace( -1, Dbg, ("NtfsInitializeLogging -> VOID\n") );
}


VOID
NtfsStartLogFile (
    IN PSCB LogFileScb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the log file for a volume by calling Lfs.  The returned
    LogHandle is stored in the Vcb.  If the log file has not been initialized,
    Lfs detects this and initializes it automatically.

Arguments:

    LogFileScb - The Scb for the log file

    Vcb - Pointer to the Vcb for this volume

Return Value:

    None.

--*/

{
    UNICODE_STRING UnicodeName;
    LFS_INFO LfsInfo;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsStartLogFile:\n") );

    RtlInitUnicodeString( &UnicodeName, L"NTFS" );

    //
    //  LfsInfo structure acts as a information conduit between
    //  LFS and the NTFS client.
    //

    if (Vcb->MajorVersion >= 3) {

        LfsInfo.LfsClientInfo = LfsFixedPageSize;

    } else {

        LfsInfo.LfsClientInfo = LfsPackLog;
    }

    LfsInfo.ReadOnly = (LOGICAL)NtfsIsVolumeReadOnly( Vcb );
    LfsInfo.InRestart = (LOGICAL)FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS );
    LfsInfo.BadRestart = (LOGICAL)FlagOn( Vcb->VcbState, VCB_STATE_BAD_RESTART );

    //
    //  Slam the allocation size into file size and valid data in case there
    //  is some error.
    //

    LogFileScb->Header.FileSize = LogFileScb->Header.AllocationSize;
    LogFileScb->Header.ValidDataLength = LogFileScb->Header.AllocationSize;

    //
    //  Now call into LFS and Open/Restart the log file. This could raise
    //  for various reasons, one of which is an attempt to do restart
    //  on a write protected volume. Vcb wont have the VALID_LOG_HANDLE flag then.
    //

    Vcb->LogHeaderReservation = LfsOpenLogFile( LogFileScb->FileObject,
                                                UnicodeName,
                                                1,
                                                0,
                                                LogFileScb->Header.AllocationSize.QuadPart,
                                                &LfsInfo,
                                                &Vcb->LogHandle,
                                                &Vcb->LfsWriteData );

    SetFlag( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE );

    DebugTrace( -1, Dbg, ("NtfsStartLogFile -> VOID\n") );
}


VOID
NtfsStopLogFile (
    IN PVCB Vcb
    )

/*

Routine Description:

    This routine should be called during volume dismount to close the volume's
    log file with the log file service.

Arguments:

    Vcb - Pointer to the Vcb for the volume

Return Value:

    None

--*/

{
    LFS_LOG_HANDLE LogHandle = Vcb->LogHandle;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsStopLogFile:\n") );

    if (FlagOn( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE )) {

        ASSERT( LogHandle != NULL );

        //
        //  We don't do any logfile flushing if the volume
        //  is mounted read only or if the device is already gone.
        //

        if (!NtfsIsVolumeReadOnly( Vcb )) {

            //
            //  Proceed even if this call fails.  There is nothing
            //  more we can do at this point.
            //

            try {

                LfsFlushToLsn( LogHandle, LiMax );

            } except( (FsRtlIsNtstatusExpected( GetExceptionCode() )) ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH ) {

                NOTHING;
            }
        }

        ClearFlag( Vcb->VcbState, VCB_STATE_VALID_LOG_HANDLE );

        //
        //  Allow LFS to close its books. We do this even for readonly
        //  mounts, although we filter writes at the LFS level for those.
        //

        LfsCloseLogFile( LogHandle );
    }

    DebugTrace( -1, Dbg, ("NtfsStopLogFile -> VOID\n") );
}


VOID
NtfsInitializeRestartTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine is called to allocate and initialize a new Restart Table,
    and return a pointer to it.

Arguments:

    EntrySize - Size of the table entries, in bytes.

    NumberEntries - Number of entries to allocate for the table.

    TablePointer - Returns a pointer to the table.

Return Value:

    None

--*/

{
    PAGED_CODE();

    try {

        NtfsInitializeRestartPointers( TablePointer );

        //
        //  Call common routine to allocate the actual table.
        //

        InitializeNewTable( EntrySize, NumberEntries, TablePointer );

    } finally {

        DebugUnwind( NtfsInitializeRestartTable );

        //
        //  On error, clean up any partial work that was done.
        //

        if (AbnormalTermination()) {

            NtfsFreeRestartTable( TablePointer );
        }
    }
}


VOID
NtfsFreeRestartTable (
    IN PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine frees a previously allocated Restart Table.

Arguments:

    TablePointer - Pointer to the Restart Table to delete.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if (TablePointer->Table != NULL) {
        NtfsFreePool( TablePointer->Table );
        TablePointer->Table = NULL;
    }

    if (TablePointer->ResourceInitialized) {
        ExDeleteResourceLite( &TablePointer->Resource );
        TablePointer->ResourceInitialized = FALSE;
    }
}


VOID
NtfsExtendRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG NumberNewEntries,
    IN ULONG FreeGoal
    )

/*++

Routine Description:

    This routine extends a previously allocated Restart Table, by
    creating and initializing a new one, and copying over the the
    table entries from the old one.  The old table is then deallocated.
    On return, the table pointer points to the new Restart Table.

Arguments:

    TablePointer - Address of the pointer to the previously created table.

    NumberNewEntries - The number of addtional entries to be allocated
                       in the new table.

    FreeGoal - A hint as to what point the caller would like to truncate
               the table back to, when sufficient entries are deleted.
               If truncation is not desired, then MAXULONG may be specified.

Return Value:

    None.

--*/

{
    PRESTART_TABLE NewTable, OldTable;
    ULONG OldSize;

    OldSize = SizeOfRestartTable( TablePointer );

    //
    //  Get pointer to old table.
    //

    OldTable = TablePointer->Table;
    ASSERT_RESTART_TABLE( OldTable );

    //
    //  Start by initializing a table for the new size.
    //

    InitializeNewTable( OldTable->EntrySize,
                        OldTable->NumberEntries + NumberNewEntries,
                        TablePointer );

    //
    //  Copy body of old table in place to new table.
    //

    NewTable = TablePointer->Table;
    RtlMoveMemory( (NewTable + 1),
                   (OldTable + 1),
                   OldTable->EntrySize * OldTable->NumberEntries );

    //
    //  Fix up new table's header, and fix up free list.
    //

    NewTable->FreeGoal = MAXULONG;
    if (FreeGoal != MAXULONG) {
        NewTable->FreeGoal = sizeof(RESTART_TABLE) + FreeGoal * NewTable->EntrySize;
    }

    if (OldTable->FirstFree != 0) {

        NewTable->FirstFree = OldTable->FirstFree;
        *(PULONG)GetRestartEntryFromIndex( TablePointer, OldTable->LastFree ) =
            OldSize;;
    } else {

        NewTable->FirstFree = OldSize;
    }

    //
    //  Copy number allocated
    //

    NewTable->NumberAllocated = OldTable->NumberAllocated;

    ASSERT( NewTable->NumberAllocated >= 0 );
    ASSERT( NewTable->FirstFree != RESTART_ENTRY_ALLOCATED );
    //
    //  Free the old table and return the new one.
    //

    NtfsFreePool( OldTable );

    ASSERT_RESTART_TABLE( NewTable );
}


ULONG
NtfsAllocateRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Exclusive
    )

/*++

Routine Description:

    This routine allocates an index from within a previously initialized
    Restart Table.  If the table is empty, it is extended.

    Note that the table must already be acquired either shared or exclusive,
    and if it must be extended, then the table is released and will be
    acquired exclusive on return.

Arguments:

    TablePointer - Pointer to the Restart Table in which an index is to
                   be allocated.

    Exclusive - Indicates if we have the table exclusive (or if we know that
        synchronization is not a problem).

Return Value:

    The allocated index.

--*/

{
    PRESTART_TABLE Table;
    ULONG EntryIndex;
    KLOCK_QUEUE_HANDLE LockHandle;
    PULONG Entry;

    DebugTrace( +1, Dbg, ("NtfsAllocateRestartTableIndex:\n") );
    DebugTrace( 0, Dbg, ("TablePointer = %08lx\n", TablePointer) );

    Table = TablePointer->Table;
    ASSERT_RESTART_TABLE(Table);

    //
    //  Acquire the spin lock to synchronize the allocation.
    //

    KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );

    //
    //  If the table is empty, then we have to extend it.
    //

    if (Table->FirstFree == 0) {

        //
        //  First release the spin lock and the table resource, and get
        //  the resource exclusive.
        //

        KeReleaseInStackQueuedSpinLock( &LockHandle );

        if (!Exclusive) {

            NtfsReleaseRestartTable( TablePointer );
            NtfsAcquireExclusiveRestartTable( TablePointer, TRUE );
        }

        //
        //  Now extend the table.  Note that if this routine raises, we have
        //  nothing to release.
        //

        NtfsExtendRestartTable( TablePointer, 16, MAXULONG );

        //
        //  And re-get our pointer to the restart table
        //

        Table = TablePointer->Table;

        //
        //  Now get the spin lock again and proceed.
        //

        KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );
    }

    //
    //  Get First Free to return it.
    //

    EntryIndex = Table->FirstFree;

    ASSERT( EntryIndex != 0 );

    //
    //  Dequeue this entry and zero it.
    //

    Entry = (PULONG)GetRestartEntryFromIndex( TablePointer, EntryIndex );

    Table->FirstFree = *Entry;
    ASSERT( Table->FirstFree != RESTART_ENTRY_ALLOCATED );

    RtlZeroMemory( Entry, Table->EntrySize );

    //
    //  Show that it's allocated.
    //

    *Entry = RESTART_ENTRY_ALLOCATED;

    //
    //  If list is going empty, then we fix the LastFree as well.
    //

    if (Table->FirstFree == 0) {

        Table->LastFree = 0;
    }

    Table->NumberAllocated += 1;

    //
    //  Now just release the spin lock before returning.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    DebugTrace( -1, Dbg, ("NtfsAllocateRestartTableIndex -> %08lx\n", EntryIndex) );

    return EntryIndex;
}


PVOID
NtfsAllocateRestartTableFromIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine allocates a specific index from within a previously
    initialized Restart Table.  If the index does not exist within the
    existing table, the table is extended.

    Note that the table must already be acquired either shared or exclusive,
    and if it must be extended, then the table is released and will be
    acquired exclusive on return.

Arguments:

    TablePointer - Pointer to the Restart Table in which an index is to
                   be allocated.

    Index - The index to be allocated.

Return Value:

    The table entry allocated.

--*/

{
    PULONG Entry;
    PULONG LastEntry;

    PRESTART_TABLE Table;
    KLOCK_QUEUE_HANDLE LockHandle;

    ULONG ThisIndex;
    ULONG LastIndex;

    DebugTrace( +1, Dbg, ("NtfsAllocateRestartTableFromIndex\n") );
    DebugTrace( 0, Dbg, ("TablePointer  = %08lx\n", TablePointer) );
    DebugTrace( 0, Dbg, ("Index         = %08lx\n", Index) );

    Table = TablePointer->Table;
    ASSERT_RESTART_TABLE(Table);

    //
    //  Acquire the spin lock to synchronize the allocation.
    //

    KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );

    //
    //  If the entry is not in the table, we will have to extend the table.
    //

    if (!IsRestartIndexWithinTable( TablePointer, Index )) {

        ULONG TableSize;
        ULONG BytesToIndex;
        ULONG AddEntries;

        //
        //  We extend the size by computing the number of entries
        //  between the existing size and the desired index and
        //  adding 1 to that.
        //

        TableSize = SizeOfRestartTable( TablePointer );;
        BytesToIndex = Index - TableSize;

        AddEntries = BytesToIndex / Table->EntrySize + 1;

        //
        //  There should always be an integral number of entries being added.
        //

        ASSERT( BytesToIndex % Table->EntrySize == 0 );

        //
        //  First release the spin lock and the table resource, and get
        //  the resource exclusive.
        //

        KeReleaseInStackQueuedSpinLock( &LockHandle );
        NtfsReleaseRestartTable( TablePointer );
        NtfsAcquireExclusiveRestartTable( TablePointer, TRUE );

        //
        //  Now extend the table.  Note that if this routine raises, we have
        //  nothing to release.
        //

        NtfsExtendRestartTable( TablePointer,
                                AddEntries,
                                TableSize );

        Table = TablePointer->Table;
        ASSERT_RESTART_TABLE(Table);

        //
        //  Now get the spin lock again and proceed.
        //

        KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );
    }

    //
    //  Now see if the entry is already allocated, and just return if it is.
    //

    Entry = (PULONG)GetRestartEntryFromIndex( TablePointer, Index );

    if (!IsRestartTableEntryAllocated( Entry )) {

        //
        //  We now have to walk through the table, looking for the entry
        //  we're interested in and the previous entry.  Start by looking at the
        //  first entry.
        //

        ThisIndex = Table->FirstFree;

        //
        //  Get the Entry from the list.
        //

        Entry = (PULONG) GetRestartEntryFromIndex( TablePointer, ThisIndex );

        //
        //  If this is a match, then we pull it out of the list and are done.
        //

        if (ThisIndex == Index) {

            //
            //  Dequeue this entry.
            //

            Table->FirstFree = *Entry;
            ASSERT( Table->FirstFree != RESTART_ENTRY_ALLOCATED );

        //
        //  Otherwise we need to walk through the list looking for the
        //  predecessor of our entry.
        //

        } else {

            while (TRUE) {

                //
                //  Remember the entry just found.
                //

                LastIndex = ThisIndex;
                LastEntry = Entry;

                //
                //  We should never run out of entries.
                //

                ASSERT( *LastEntry != 0 );

                //
                //  Lookup up the next entry in the list.
                //

                ThisIndex = *LastEntry;
                Entry = (PULONG) GetRestartEntryFromIndex( TablePointer, ThisIndex );

                //
                //  If this is our match we are done.
                //

                if (ThisIndex == Index) {

                    //
                    //  Dequeue this entry.
                    //

                    *LastEntry = *Entry;

                    //
                    //  If this was the last entry, we update that in the
                    //  table as well.
                    //

                    if (Table->LastFree == ThisIndex) {

                        Table->LastFree = LastIndex;
                    }

                    break;
                }
            }
        }

        //
        //  If the list is now empty, we fix the LastFree as well.
        //

        if (Table->FirstFree == 0) {

            Table->LastFree = 0;
        }

        //
        //  Zero this entry.  Then show that this is allocated and increment the
        //  allocated count.
        //

        RtlZeroMemory( Entry, Table->EntrySize );
        *Entry = RESTART_ENTRY_ALLOCATED;

        Table->NumberAllocated += 1;
    }


    //
    //  Now just release the spin lock before returning.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    DebugTrace( -1, Dbg, ("NtfsAllocateRestartTableFromIndex -> %08lx\n", Entry) );

    return (PVOID)Entry;
}


VOID
NtfsFreeRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine frees a previously allocated index in a Restart Table.
    If the index is before FreeGoal for the table, it is simply deallocated to
    the front of the list for immediate reuse.  If the index is beyond
    FreeGoal, then it is deallocated to the end of the list, to facilitate
    truncation of the list in the event that all of the entries beyond
    FreeGoal are freed.  However, this routine does not automatically
    truncate the list, as this would cause too much overhead.  The list
    is checked during periodic checkpoint processing.

Arguments:

    TablePointer - Pointer to the Restart Table to which the index is to be
                   deallocated.

    Index - The index being deallocated.

Return Value:

    None.

--*/

{
    PRESTART_TABLE Table;
    PULONG Entry, OldLastEntry;
    KLOCK_QUEUE_HANDLE LockHandle;

    DebugTrace( +1, Dbg, ("NtfsFreeRestartTableIndex:\n") );
    DebugTrace( 0, Dbg, ("TablePointer = %08lx\n", TablePointer) );
    DebugTrace( 0, Dbg, ("Index = %08lx\n", Index) );

    //
    //  Get pointers to table and the entry we are freeing.
    //

    Table = TablePointer->Table;
    ASSERT_RESTART_TABLE(Table);

    ASSERT( (Table->FirstFree == 0) ||
            ((Table->FirstFree >= 0x18) &&
             (((Table->FirstFree - 0x18) % Table->EntrySize) == 0)) );

    ASSERT( (Index >= 0x18) &&
            ((Index - 0x18) % Table->EntrySize) == 0 );

    Entry = GetRestartEntryFromIndex( TablePointer, Index );

    //
    //  Acquire the spinlock to synchronize the allocation.
    //

    KeAcquireInStackQueuedSpinLock( &TablePointer->SpinLock, &LockHandle );

    //
    //  If the index is before FreeGoal, then do a normal deallocation at
    //  the front of the list.
    //

    if (Index < Table->FreeGoal) {

        *Entry = Table->FirstFree;

        ASSERT( Index != RESTART_ENTRY_ALLOCATED );

        Table->FirstFree = Index;
        if (Table->LastFree == 0) {
            Table->LastFree = Index;
        }

    //
    //  Otherwise we will deallocate this guy to the end of the list.
    //

    } else {

        if (Table->LastFree != 0) {
            OldLastEntry = GetRestartEntryFromIndex( TablePointer,
                                                     Table->LastFree );
            *OldLastEntry = Index;
        } else {

            ASSERT( Index != RESTART_ENTRY_ALLOCATED );

            Table->FirstFree = Index;
        }
        Table->LastFree = Index;
        *Entry = 0;
    }

    ASSERT( Table->NumberAllocated != 0 );
    Table->NumberAllocated -= 1;

    //
    //  Now just release the spin lock before returning.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    DebugTrace( -1, Dbg, ("NtfsFreeRestartTableIndex -> VOID\n") );
}


PVOID
NtfsGetFirstRestartTable (
    IN PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine returns the first allocated entry from a Restart Table.

Arguments:

    TablePointer - Pointer to the respective Restart Table Pointers structure.

Return Value:

    Pointer to the first entry, or NULL if none are allocated.

--*/

{
    PCHAR Entry;

    PAGED_CODE();

    //
    //  If we know the table is empty, we can return immediately.
    //

    if (IsRestartTableEmpty( TablePointer )) {

        return NULL;
    }

    //
    //  Otherwise point to the first table entry.
    //

    Entry = (PCHAR)(TablePointer->Table + 1);

    //
    //  Loop until we hit the first one allocated, or the end of the list.
    //

    while ((ULONG)(Entry - (PCHAR)TablePointer->Table) <
           SizeOfRestartTable(TablePointer)) {

        if (IsRestartTableEntryAllocated(Entry)) {
            return (PVOID)Entry;
        }

        Entry += TablePointer->Table->EntrySize;
    }

    return NULL;
}


PVOID
NtfsGetNextRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN PVOID Current
    )

/*++

Routine Description:

    This routine returns the next allocated entry from a Restart Table.

Arguments:

    TablePointer - Pointer to the respective Restart Table Pointers structure.

    Current - Current entry pointer.

Return Value:

    Pointer to the next entry, or NULL if none are allocated.

--*/


{
    PCHAR Entry = (PCHAR)Current;

    PAGED_CODE();

    //
    //  Point to the next entry.
    //

    Entry += TablePointer->Table->EntrySize;

    //
    //  Loop until we hit the first one allocated, or the end of the list.
    //

    while ((ULONG)(Entry - (PCHAR)TablePointer->Table) <
           SizeOfRestartTable(TablePointer)) {

        if (IsRestartTableEntryAllocated(Entry)) {
            return (PVOID)Entry;
        }

        Entry += TablePointer->Table->EntrySize;
    }

    return NULL;
}


VOID
NtfsUpdateOatVersion (
    IN PVCB Vcb,
    IN ULONG NewRestartVersion
    )

/*++

Routine Description:

    This routine is called when we are switching the restart version for a volume.  This can happen
    either after a clean checkpoint or at mount when we encounter a restart area with a non-default
    version number.

Arguments:

    Vcb - Pointer to the Vcb for the volume.

    NewRestartVersion - Restart version to start using for this volume.

Return Value:

    None

--*/

{
    PRESTART_POINTERS NewTable = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateOatVersion\n") );

    ASSERT( (Vcb->RestartVersion != NewRestartVersion) || (Vcb->OnDiskOat == NULL) );

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        if (NewRestartVersion == 0) {

            //
            //  If we are moving to version 0 then allocate a new table and
            //  initialize it with the initial number of entries.
            //

            NewTable = NtfsAllocatePool( NonPagedPool, sizeof( RESTART_POINTERS ));
            NtfsInitializeRestartTable( sizeof( OPEN_ATTRIBUTE_ENTRY_V0 ),
                                        INITIAL_NUMBER_ATTRIBUTES,
                                        NewTable );

            Vcb->RestartVersion = 0;
            Vcb->OatEntrySize = SIZEOF_OPEN_ATTRIBUTE_ENTRY_V0;
            Vcb->OnDiskOat = NewTable;
            NewTable = NULL;

        } else {

            if (Vcb->OnDiskOat != NULL) {

                NtfsFreeRestartTable( Vcb->OnDiskOat );
                NtfsFreePool( Vcb->OnDiskOat );
            }

            Vcb->OnDiskOat = &Vcb->OpenAttributeTable;
            Vcb->RestartVersion = 1;
            Vcb->OatEntrySize = sizeof( OPEN_ATTRIBUTE_ENTRY );
        }

    } finally {

        DebugUnwind( NtfsUpdateOatVersion );

        if (NewTable != NULL) {

            NtfsFreePool( NewTable );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsUpdateOatVersion -> VOID\n") );

    return;
}


//
//  Internal support routine
//

VOID
DirtyPageRoutine (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PLSN OldestLsn,
    IN PLSN NewestLsn,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    This routine is used as the call back routine for retrieving dirty pages
    from the Cache Manager.  It adds them to the Dirty Table list whose
    pointer is pointed to by the Context parameter.

Arguments:

    FileObject - Pointer to the file object which has the dirty page

    FileOffset - File offset for start of dirty page

    Length - Length recorded for the dirty page

    OldestLsn - Oldest Lsn of an update not written through stored for that page
                (Can be zero if set dirty in paths that don't use lsns)

    Context1 - IrpContext

    Context2 - Pointer to the pointer to the Restart Table

Return Value:

    None

--*/

{
    PDIRTY_PAGE_ENTRY PageEntry;
    PDIRTY_PAGE_CONTEXT DirtyPageContext = (PDIRTY_PAGE_CONTEXT)Context2;
    PRESTART_POINTERS DirtyPageTable = DirtyPageContext->DirtyPageTable;
    PSCB_NONPAGED NonpagedScb;
    ULONG PageIndex;

    DebugTrace( +1, Dbg, ("DirtyPageRoutine:\n") );
    DebugTrace( 0, Dbg, ("FileObject = %08lx\n", FileObject) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", *FileOffset) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("OldestLsn = %016I64x\n", *OldestLsn) );
    DebugTrace( 0, Dbg, ("Context2 = %08lx\n", Context2) );

    //
    //  Get the Vcb out of the file object.
    //

    NonpagedScb = CONTAINING_RECORD( FileObject->SectionObjectPointer,
                                     SCB_NONPAGED,
                                     SegmentObject );

    //
    //  We noop this call if the open attribute entry for this Scb is 0.  We assume
    //  there was a clean volume checkpoint which cleared this field.
    //

    if (NonpagedScb->OpenAttributeTableIndex == 0 ) {

        DebugTrace( -1, Dbg, ("DirtyPageRoutine -> VOID\n") );
        return;
    }

    //
    //  Check for an overrun in the table and stop processing in that case
    //  The restart table format can't accomodate tables greater than 64k in size
    //  due to the ushort used for the attribute index
    //

    if (AllocatedSizeOfRestartTable( DirtyPageTable ) > MAX_RESTART_TABLE_SIZE ){

        DirtyPageContext->Overflow = TRUE;

    } else {

        //
        //  Get a pointer to the entry we just allocated.
        //

        PageIndex = NtfsAllocateRestartTableIndex( DirtyPageTable, TRUE );
        PageEntry = GetRestartEntryFromIndex( DirtyPageTable, PageIndex );

        //
        //  Now fill in the Dirty Page Entry, except for the Lcns, because
        //  we are not allowed to take page faults now.
        //  Use the index for the in-memory table now.  We will update
        //  this to the on-disk index back in CheckpointVolume.
        //

        PageEntry->TargetAttribute = NonpagedScb->OpenAttributeTableIndex;
        ASSERT( NonpagedScb->OnDiskOatIndex != 0 );

        PageEntry->LengthOfTransfer = Length;

        //
        //  Put the Vcn (FileOffset) and OldestLsn into the page at this point.  Note
        //  we don't want to put an Lsn into the table which is older than the current
        //  BaseLsn.  Store it here for now and we will fix it up when we process the
        //  DiryPage table back in the checkpoint code.
        //

        if (NonpagedScb->Vcb->RestartVersion == 0) {

            ((PDIRTY_PAGE_ENTRY_V0) PageEntry)->Vcn = FileOffset->QuadPart;
            ((PDIRTY_PAGE_ENTRY_V0) PageEntry)->OldestLsn = *OldestLsn;

        } else {

            PageEntry->Vcn = FileOffset->QuadPart;
            PageEntry->OldestLsn = *OldestLsn;
        }

        //
        //  Update the oldest lsn info if this is the new oldest lsn
        //

        if ((OldestLsn->QuadPart != 0) &&
            (OldestLsn->QuadPart < DirtyPageContext->OldestLsn.QuadPart)) {

            if (DirtyPageContext->OldestFileObject != NULL) {
                ObDereferenceObject( DirtyPageContext->OldestFileObject );
            }

            DirtyPageContext->DirtyPageIndex = PageIndex;
            DirtyPageContext->OldestFileObject = FileObject;
            DirtyPageContext->OldestLsn.QuadPart = OldestLsn->QuadPart;

            ObReferenceObject( FileObject );
        }
    }


    DebugTrace( -1, Dbg, ("DirtyPageRoutine -> VOID\n") );
    return;

    UNREFERENCED_PARAMETER( Context1 );
    UNREFERENCED_PARAMETER( NewestLsn );
}


//
//  Internal support routine
//

BOOLEAN
LookupLcns (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN VCN Vcn,
    IN ULONG ClusterCount,
    IN BOOLEAN MustBeAllocated,
    OUT PLCN_UNALIGNED FirstLcn
    )

/*++

Routine Description:

    This routine looks up the Lcns for a range of Vcns, and stores them in
    an output array.  One Lcn is stored for each Vcn in the range, even
    if the Lcns are contiguous.

Arguments:

    Scb - Scb for stream on which lookup should occur.

    Vcn - Start of range of Vcns to look up.

    ClusterCount - Number of Vcns to look up.

    MustBeAllocated - FALSE - if need not be allocated, and should check Mcb only
                      TRUE - if it must be allocated as far as caller knows (i.e.,
                             NtfsLookupAllocation also has checks)

    FirstLcn - Pointer to storage for first Lcn.  The caller must guarantee
               that there is enough space to store ClusterCount Lcns.

Return Value:

    BOOLEAN - TRUE if we found the clusters, FALSE otherwise.

--*/

{
    BOOLEAN Allocated;
    LONGLONG Clusters;
    LCN Lcn;
    ULONG i;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("LookupLcns:\n") );
    DebugTrace( 0, Dbg, ("Scb = %08l\n", Scb) );
    DebugTrace( 0, Dbg, ("Vcn = %016I64x\n", Vcn) );
    DebugTrace( 0, Dbg, ("ClusterCount = %08l\n", ClusterCount) );
    DebugTrace( 0, Dbg, ("FirstLcn = %08lx\n", FirstLcn) );

    //
    //  Loop until we have looked up all of the clusters
    //

    while (ClusterCount != 0) {

        if (MustBeAllocated) {

            //
            //  Lookup the next run.
            //

            Allocated = NtfsLookupAllocation( IrpContext,
                                              Scb,
                                              Vcn,
                                              &Lcn,
                                              &Clusters,
                                              NULL,
                                              NULL );

            ASSERT( Lcn != 0 );

            //
            //  Raise if this case not met.  Otherwise we could walk off the end
            //  of the LCN array.
            //

            if (!Allocated) {

                return FALSE;

            } else if (Lcn == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

        } else {

           Allocated = NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, &Lcn, &Clusters, NULL, NULL, NULL, NULL );

           //
           //   If we are off the end of the Mcb, then set up to just return
           //   Li0 for as many Lcns as are being looked up.
           //

           if (!Allocated ||
               (Lcn == UNUSED_LCN)) {
               Lcn = 0;
               Clusters = ClusterCount;
               Allocated = FALSE;
           }
        }

        //
        //  If we got as many clusters as we were looking for, then just
        //  take the number we were looking for.
        //

        if (Clusters > ClusterCount) {

            Clusters = ClusterCount;
        }

        //
        //  Fill in the Lcns in the header.
        //

        for (i = 0; i < (ULONG)Clusters; i++) {

            *(FirstLcn++) = Lcn;

            if (Allocated) {
                Lcn = Lcn + 1;
            }
        }

        //
        //  Adjust loop variables for the number Lcns we just received.
        //

        Vcn = Vcn + Clusters;
        ClusterCount -= (ULONG)Clusters;
    }

    DebugTrace( -1, Dbg, ("LookupLcns -> VOID\n") );

    return TRUE;
}


VOID
InitializeNewTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    )

/*++

Routine Description:

    This routine is called to allocate and initialize a new table when the
    associated Restart Table is being allocated or extended.

Arguments:

    EntrySize - Size of the table entries, in bytes.

    NumberEntries - Number of entries to allocate for the table.

    TablePointer - Returns a pointer to the table.

Return Value:

    None

--*/

{
    PRESTART_TABLE Table;
    PULONG Entry;
    ULONG Size;
    ULONG Offset;

    ASSERT( EntrySize != 0 );

    //
    //  Calculate size of table to allocate.
    //

    Size = EntrySize * NumberEntries + sizeof(RESTART_TABLE);

    //
    //  Allocate and zero out the table.
    //

    Table =
    TablePointer->Table = NtfsAllocatePool( NonPagedPool, Size );

    RtlZeroMemory( Table, Size );

    //
    //  Initialize the table header.
    //

    Table->EntrySize = (USHORT)EntrySize;
    Table->NumberEntries = (USHORT)NumberEntries;
    Table->FreeGoal = MAXULONG;
    Table->FirstFree = sizeof( RESTART_TABLE );
    Table->LastFree = Table->FirstFree + (NumberEntries - 1) * EntrySize;

    //
    //  Initialize the free list.
    //

    for (Entry = (PULONG)(Table + 1), Offset = sizeof(RESTART_TABLE) + EntrySize;
         Entry < (PULONG)((PCHAR)Table + Table->LastFree);
         Entry = (PULONG)((PCHAR)Entry + EntrySize), Offset += EntrySize) {

        *Entry = Offset;
    }

    ASSERT_RESTART_TABLE(Table);
}



VOID
NtfsFreeRecentlyDeallocated (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLSN BaseLsn,
    IN ULONG CleanVolume
    )
/*++

Routine Description:

    Free up recently deallocated clusters for reuse

Arguments:

    IrpContext -

    Vcb -  volume to clean up

    BaseLsn - the lsn we're up to now in the logfile, used to determine what can be freed
              and the new threshold for future frees

    CleanVolume - if true the volume is being clean checkpointed and all the clusters can be freed

Return Value:

    None

--*/
{
    PDEALLOCATED_CLUSTERS Clusters;
    BOOLEAN RemovedClusters = FALSE;

    PAGED_CODE();

    //
    //  Quick exit if the list is empty
    //

    if (IsListEmpty( &Vcb->DeallocatedClusterListHead ) || (Vcb->BitmapScb == NULL)) {
        return;
    }

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    Clusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Blink;

    //
    //  Now we want to check if we can release any of the clusters in the
    //  deallocated cluster arrays.  We know we can look at the
    //  fields in the PriorDeallocatedClusters structure because they
    //  are never modified in the running system.
    //
    //  We will continue from the oldest in the list list until
    //
    //   1) there are no more dealloc lists
    //   2) there are no clusters in the dealloc list (it must be the only one at this point)
    //   3) the lsn == 0 and we're dirty which means we're at the front
    //   4) the lsn is newer in deallocated cluster list
    //

    try {

        while ((!IsListEmpty( &Vcb->DeallocatedClusterListHead )) &&
               (((Clusters->Lsn.QuadPart != 0) && (BaseLsn->QuadPart > Clusters->Lsn.QuadPart)) ||
                CleanVolume)) {

            RemovedClusters = TRUE;

            //
            //  For all deallocated during clean checkpoints and non-most recent
            //  ones during fuzzy ones:
            //  Remove all of the mappings in the Mcb.  Protect this with
            //  a try-except.
            //

            try {

                try {
                    ULONG i;
                    ULONGLONG StartingVcn;
                    ULONGLONG StartingLcn;
                    ULONGLONG ClusterCount;

                    if (Clusters->ClusterCount > 0) {

                        for (i = 0; FsRtlGetNextLargeMcbEntry( &Clusters->Mcb, i, &StartingVcn, &StartingLcn, &ClusterCount ); i += 1) {

                            if (StartingVcn == StartingLcn) {

                                if (NtfsAddCachedRun( IrpContext,
                                                      Vcb,
                                                      StartingLcn,
                                                      ClusterCount,
                                                      RunStateFree ) <= 0) break;
                            }
                        }
                    }

                } finally {

                    PDEALLOCATED_CLUSTERS NextClusters = (PDEALLOCATED_CLUSTERS)Clusters->Link.Blink;

                    //
                    //  We are committed to freeing the clusters out of the PriorDeallocatedClusters
                    //  in any case.
                    //

                    Vcb->DeallocatedClusters -= Clusters->ClusterCount;

                    //
                    //  Move this cluster list out of the vcb
                    //

                    RemoveEntryList( &Clusters->Link );

                    //
                    //  delete dynamic clusters lists / reset static ones
                    //

                    if ((Clusters != &Vcb->DeallocatedClusters1) && (Clusters != &Vcb->DeallocatedClusters2 )) {

                        FsRtlUninitializeLargeMcb( &Clusters->Mcb );
                        NtfsFreePool( Clusters );
                    } else {
                        Clusters->Link.Flink = NULL;
                        Clusters->ClusterCount = 0;
                        FsRtlResetLargeMcb( &Clusters->Mcb, TRUE );
                    }
                    ASSERT( Vcb->DeallocatedClusters >= 0 );

                    Clusters = NextClusters;
                }

            } except( NtfsCatchOutOfMemoryExceptionFilter( IrpContext, GetExceptionInformation() )) {

                //
                //  Keep going even if out of memory
                //

                NtfsMinimumExceptionProcessing( IrpContext );
                NOTHING;
            }
        }

        //
        //  If we removed any clusters on a fuzzy checkpoint lets make a new active one so
        //  the current active one can be cleaned up eventually
        //  On a clean checkpoint if we removed all the nodes add a blank one back
        //

        if (!CleanVolume) {

            ASSERT( !IsListEmpty( &Vcb->DeallocatedClusterListHead ) );

            if (RemovedClusters && (Clusters->ClusterCount > 0)) {
                Clusters = NtfsGetDeallocatedClusters( IrpContext, Vcb );
            }

        } else if (IsListEmpty( &Vcb->DeallocatedClusterListHead )) {

            ASSERT( Vcb->DeallocatedClusters1.Link.Flink == NULL );

            Vcb->DeallocatedClusters1.Lsn.QuadPart = 0;
            InsertHeadList( &Vcb->DeallocatedClusterListHead, &Vcb->DeallocatedClusters1.Link );
        }

    } finally {

        NtfsReleaseScb( IrpContext, Vcb->BitmapScb );

    }
}



VOID
NtfsCleanupFailedTransaction (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to cleanup the IrpContext and free structures
    in the event a transaction fails to commit or abort.

Arguments:

Return Value:

    None

--*/

{
    PUSN_FCB ThisUsn;
    PUSN_FCB LastUsn;

    PAGED_CODE();

    //
    //  Clear the flags indicating a transaction is underway.
    //

    ClearFlag( IrpContext->Flags,
               IRP_CONTEXT_FLAG_WROTE_LOG | IRP_CONTEXT_FLAG_RAISED_STATUS | IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

    //
    //  Make sure the recently deallocated queue is empty.
    //

    try {

        if (!IsListEmpty( &IrpContext->RecentlyDeallocatedQueue )) {

            NtfsDeallocateRecordsComplete( IrpContext );
        }

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Show that we haven't deallocated any clusters.
    //

    IrpContext->DeallocatedClusters = 0;
    IrpContext->FreeClusterChange = 0;

    //
    //  Don't rollback any size changes.
    //

    try {

        NtfsUpdateScbSnapshots( IrpContext );

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Make sure the last restart area is zeroed.
    //

    IrpContext->LastRestartArea.QuadPart = 0;

    //
    //  Pull the Usn Fcb fields.
    //

    ThisUsn = &IrpContext->Usn;

    try {

        do {

            if (ThisUsn->CurrentUsnFcb != NULL) {

                PFCB UsnFcb = ThisUsn->CurrentUsnFcb;

                NtfsLockFcb( IrpContext, UsnFcb );

                //
                //  If any rename flags are part of the new reasons then
                //  make sure to look the name up again.
                //

                if (FlagOn( ThisUsn->NewReasons,
                            USN_REASON_RENAME_NEW_NAME | USN_REASON_RENAME_OLD_NAME )) {

                    ClearFlag( UsnFcb->FcbState, FCB_STATE_VALID_USN_NAME );
                }

                //
                //  Now restore the reason and source info fields.
                //

                ClearFlag( UsnFcb->FcbUsnRecord->UsnRecord.Reason,
                           ThisUsn->NewReasons );
                if (UsnFcb->FcbUsnRecord->UsnRecord.Reason == 0) {

                    UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo = 0;

                } else {

                    SetFlag( UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo,
                             ThisUsn->RemovedSourceInfo );
                }

                NtfsUnlockFcb( IrpContext, UsnFcb );

                //
                //  Zero out the structure.
                //

                ThisUsn->CurrentUsnFcb = NULL;
                ThisUsn->NewReasons = 0;
                ThisUsn->RemovedSourceInfo = 0;
                ThisUsn->UsnFcbFlags = 0;

                //
                //  If not the first pass through the loop then update
                //  the last usn structure with what we point to here.
                //

                if (ThisUsn != &IrpContext->Usn) {

                    LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                    NtfsFreePool( ThisUsn );
                    ThisUsn = LastUsn;
                }
            }

            if (ThisUsn->NextUsnFcb == NULL) { break; }

            LastUsn = ThisUsn;
            ThisUsn = ThisUsn->NextUsnFcb;

        } while (TRUE);

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Don't wake any waiters for this failed operation.
    //

    try {

        if (IrpContext->CheckNewLength != NULL) {

            NtfsProcessNewLengthQueue( IrpContext, TRUE );
        }

    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH) {

        NOTHING;
    }

    //
    //  Remove this from the transaction table if present.
    //

    if (IrpContext->TransactionId != 0) {

        NtfsAcquireExclusiveRestartTable( &IrpContext->Vcb->TransactionTable,
                                          TRUE );

        NtfsFreeRestartTableIndex( &IrpContext->Vcb->TransactionTable,
                                   IrpContext->TransactionId );

        //
        //  Notify any waiters if there are no more transactions
        //

        if (IrpContext->Vcb->TransactionTable.Table->NumberAllocated == 0) {

            KeSetEvent( &IrpContext->Vcb->TransactionsDoneEvent, 0, FALSE );
        }

        NtfsReleaseRestartTable( &IrpContext->Vcb->TransactionTable );

        IrpContext->TransactionId = 0;
    }

    IrpContext->ExceptionStatus = STATUS_SUCCESS;
    return;
}


//
//  Local support routine
//

LONG
NtfsCatchOutOfMemoryExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    Exception filter for out of memory errors. This will swallow 0xC0000009A's and let
    all other exceptions filter on

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.


Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    if (ExceptionPointer->ExceptionRecord->ExceptionCode != STATUS_INSUFFICIENT_RESOURCES) {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


//
//  Local support routine
//

LONG
NtfsCheckpointExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS ExceptionCode
    )

{
    //
    //  Swallow all expected errors if this is a dismount doing a log file full.
    //

    if ((FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH )) &&
        (FsRtlIsNtstatusExpected( ExceptionCode ))) {

        return EXCEPTION_EXECUTE_HANDLER;

    } else {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    UNREFERENCED_PARAMETER( ExceptionPointer );
}


VOID
NtfsFreeAttributeEntry (
    IN PVCB Vcb,
    IN POPEN_ATTRIBUTE_ENTRY AttributeEntry
    )

/*++

Routine Description:

    Free an attribute entry and all the connected entries in the other tables
    + any memory associated with it

Arguments:

    IrpContext  - IrpContext

    AttributeEntry - Entry to free


Return Value:

    NONE

--*/

{

    ULONG Index;

    if (AttributeEntry->OatData->AttributeNamePresent) {

        //
        //  Delete its name, if it has one.  Check that we aren't
        //  using the hardcode $I30 name.
        //

        NtfsFreeScbAttributeName( AttributeEntry->OatData->AttributeName.Buffer );

    } else if (AttributeEntry->OatData->Overlay.Scb != NULL) {

        AttributeEntry->OatData->Overlay.Scb->NonpagedScb->OpenAttributeTableIndex =
        AttributeEntry->OatData->Overlay.Scb->NonpagedScb->OnDiskOatIndex = 0;
    }

    //
    //  Get the index for the entry.
    //

    Index = GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
                                      AttributeEntry );

    if (Vcb->RestartVersion == 0) {

        NtfsAcquireExclusiveRestartTable( Vcb->OnDiskOat, TRUE );
        NtfsFreeRestartTableIndex( Vcb->OnDiskOat, AttributeEntry->OatData->OnDiskAttributeIndex );
        NtfsReleaseRestartTable( Vcb->OnDiskOat );
    }

    NtfsFreeOpenAttributeData( AttributeEntry->OatData );
    NtfsFreeRestartTableIndex( &Vcb->OpenAttributeTable, Index );
}


ULONG
NtfsCalculateNamedBytes (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    Calculated number of named bytes necc. to hold all the open attributes

Arguments:

    IrpContext  - IrpContext

    Vcb -

Return Value:

    Number of bytes needed to write all the names of the open attributes

--*/

{
    POPEN_ATTRIBUTE_ENTRY AttributeEntry;
    ULONG NameBytes = 0;

    //
    //  Loop to see how much we will have to allocate for attribute names.
    //

    AttributeEntry = NtfsGetFirstRestartTable( &Vcb->OpenAttributeTable );

    while (AttributeEntry != NULL) {

        //
        //  This checks for one type of aliasing.
        //

        //  ASSERT( (AttributeEntry->Overlay.Scb == NULL) ||
        //          (AttributeEntry->Overlay.Scb->OpenAttributeTableIndex ==
        //           GetIndexFromRestartEntry( &Vcb->OpenAttributeTable,
        //                                    AttributeEntry )));

        //
        //  Clear the DirtyPageSeen flag prior to collecting the dirty pages,
        //  to help us figure out which Open Attribute Entries we still need.
        //

        AttributeEntry->DirtyPagesSeen = FALSE;

        if (AttributeEntry->OatData->AttributeName.Length != 0) {

            //
            //  Add to our name total, the size of an Attribute Entry,
            //  which includes the size of the terminating UNICODE_NULL.
            //

            NameBytes += AttributeEntry->OatData->AttributeName.Length +
                         sizeof(ATTRIBUTE_NAME_ENTRY);
        }

        AttributeEntry = NtfsGetNextRestartTable( &Vcb->OpenAttributeTable,
                                                  AttributeEntry );
    }

    return NameBytes;

    UNREFERENCED_PARAMETER( IrpContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\namesup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Ntfs Name support routines

Author:

    Gary Kimura [GaryKi] & Tom Miller [TomM]    20-Feb-1990

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg                              (DEBUG_TRACE_NAMESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCollateNames)
#pragma alloc_text(PAGE, NtfsIsFatNameValid)
#pragma alloc_text(PAGE, NtfsIsFileNameValid)
#pragma alloc_text(PAGE, NtfsParseName)
#pragma alloc_text(PAGE, NtfsParsePath)
#pragma alloc_text(PAGE, NtfsUpcaseName)
#endif

#define MAX_CHARS_IN_8_DOT_3    (12)


PARSE_TERMINATION_REASON
NtfsParsePath (
    IN UNICODE_STRING Path,
    IN BOOLEAN WildCardsPermissible,
    OUT PUNICODE_STRING FirstPart,
    OUT PNTFS_NAME_DESCRIPTOR Name,
    OUT PUNICODE_STRING RemainingPart
    )

/*++

Routine Description:

    This routine takes as input a path.  Each component of the path is
    checked until either:

        - The end of the path has been reached, or

        - A well formed complex name is excountered, or

        - An illegal character is encountered, or

        - A complex name component is malformed

    At this point the return value is set to one of the three reasons
    above, and the arguments are set as follows:

        FirstPart:     All the components up to one containing an illegal
                       character or colon character.  May be the whole path.

        Name:          The "pieces" of a component containing an illegal
                       character or colon character.  This name is actually
                       a struncture containing the four pieces of a name,
                       "file name, attribute type, attribute name, version
                       number."  In the example below, they are shown
                       separated by plus signs.

        RemainingPart: All the remaining components.

    A preceding or trailing backslash is ignored during processing and
    stripped in either FirstPart or RemainingPart.  Following are some
    examples of this routine's actions.

    Path                         FirstPart Name                   Remaining
    ================             ========= ============           =========

    \nt\pri\os                   \nt\pri\os                        <empty>

    \nt\pri\os\                  \nt\pri\os                        <empty>

    nt\pri\os                    \nt\pri\os                        <empty>

    \nt\pr"\os                   \nt        pr"                    os

    \nt\pri\os:contr::3\ntfs     \nt\pri    os + contr + + 3       ntfs

    \nt\pri\os\circle:pict:circ  \nt\pri\os circle + pict + circ   <empty>

Arguments:

    Path - This unicode string descibes the path to parse.  Note that path
        here may only describe a single component.

    WildCardsPermissible - This parameter tells us if wild card characters
        should be considered legal.

    FirstPart - This unicode string will receive portion of the path, up to
        a component boundry,  successfully parsed before the parse terminated.
        Note that store for this string comes from the Path parameter.

    Name - This is the name we were parsing when we reached our termination
        condition.  It is a srtucture of strings that receive the file name,
        attribute type, attribute name, and version number respectively.
        It wil be filled in only to the extent that the parse succeeded.  For
        example, in the case we encounter an illegal character in the
        attribute type field, only the file name field will be filled in.
        This may signal a special control file, and this possibility must be
        investigated by the file system.

    RemainingPart - This string will receive any portion of the path, starting
        at the first component boundry after the termination name, not parsed.
        It will often be an empty string.

ReturnValue:

    An enumerated type with one of the following values:

        EndOfPathReached       - The path was fully parsed.  Only first part
                                 is filled in.
        NonSimpleName          - A component of the path containing a legal,
                                 well formed non-simple name was encountered.
        IllegalCharacterInName - An illegal character was encountered.  Parsing
                                 stops immediately.
        MalFormedName          - A non-simple name did not conform to the
                                 correct format.  This may be a result of too
                                 many fields, or a malformed version number.
        AttributeOnly          - A component of the path containing a legal
                                 well formed non-simple name was encountered
                                 which does not have a file name.
        VersionNumberPresent   - A component of the path containing a legal
                                 well formed non-simple name was encountered
                                 which contains a version number.

--*/

{
    UNICODE_STRING FirstName;

    BOOLEAN WellFormed;
    BOOLEAN MoreNamesInPath;
    BOOLEAN FirstIteration;
    BOOLEAN FoundIllegalCharacter;

    PARSE_TERMINATION_REASON TerminationReason;

    PAGED_CODE();

    //
    //  Initialize some loacal variables and OUT parameters.
    //

    FirstIteration = TRUE;
    MoreNamesInPath = TRUE;

    //
    //  Clear the fieldspresent flag in the name descriptor.
    //

    Name->FieldsPresent = 0;

    //
    //  By default, set the returned first part to start at the beginning of
    //  the input buffer and include a leading backslash.
    //

    FirstPart->Buffer = Path.Buffer;

    if (Path.Buffer[0] == L'\\') {

        FirstPart->Length = 2;
        FirstPart->MaximumLength = 2;

    } else {

        FirstPart->Length = 0;
        FirstPart->MaximumLength = 0;
    }

    //
    //  Do the first check outside the loop in case we are given a backslash
    //  by itself.
    //

    if (FirstPart->Length == Path.Length) {

        RemainingPart->Length = 0;
        RemainingPart->Buffer = &Path.Buffer[Path.Length >> 1];

        return EndOfPathReached;
    }

    //
    //  Crack the path, checking each componant
    //

    while (MoreNamesInPath) {

        FsRtlDissectName( Path, &FirstName, RemainingPart );

        MoreNamesInPath = (BOOLEAN)(RemainingPart->Length != 0);

        //
        //  If this is not the last name in the path, then attributes
        //  and version numbers are not allowed.  If this is the last
        //  name then propagate the callers arguments.
        //

        WellFormed = NtfsParseName( FirstName,
                                    WildCardsPermissible,
                                    &FoundIllegalCharacter,
                                    Name );

        //
        //  Check the cases when we will break out of this loop, ie. if the
        //  the name was not well formed or it was non-simple.
        //

        if ( !WellFormed ||
             (Name->FieldsPresent != FILE_NAME_PRESENT_FLAG)

             //
             // TEMPCODE    TRAILING_DOT
             //

             || (Name->FileName.Length != Name->FileName.MaximumLength)

             ) {

            break;
        }

        //
        //  We will continue parsing this string, so consider the current
        //  FirstName to be parsed and add it to FirstPart.  Also reset
        //  the Name->FieldsPresent variable.
        //

        if ( FirstIteration ) {

            FirstPart->Length += FirstName.Length;
            FirstIteration = FALSE;

        } else {

            FirstPart->Length += (sizeof(WCHAR) + FirstName.Length);
        }

        FirstPart->MaximumLength = FirstPart->Length;

        Path = *RemainingPart;
    }

    //
    //  At this point FirstPart, Name, and RemainingPart should all be set
    //  correctly.  It remains, only to generate the correct return value.
    //

    if ( !WellFormed ) {

        if ( FoundIllegalCharacter ) {

            TerminationReason = IllegalCharacterInName;

        } else {

            TerminationReason = MalFormedName;
        }

    } else {

        if ( Name->FieldsPresent == FILE_NAME_PRESENT_FLAG ) {

            //
            //  TEMPCODE    TRAILING_DOT
            //

            if (Name->FileName.Length != Name->FileName.MaximumLength) {

                TerminationReason = NonSimpleName;

            } else {

                TerminationReason = EndOfPathReached;
            }

        } else if (FlagOn( Name->FieldsPresent, VERSION_NUMBER_PRESENT_FLAG )) {

            TerminationReason = VersionNumberPresent;

        } else if (!FlagOn( Name->FieldsPresent, FILE_NAME_PRESENT_FLAG )) {

            TerminationReason = AttributeOnly;

        } else {

            TerminationReason = NonSimpleName;
        }

    }

    return TerminationReason;
}


BOOLEAN
NtfsParseName (
    IN const UNICODE_STRING Name,
    IN BOOLEAN WildCardsPermissible,
    OUT PBOOLEAN FoundIllegalCharacter,
    OUT PNTFS_NAME_DESCRIPTOR ParsedName
    )

/*++

Routine Description:

    This routine takes as input a single name component.  It is processed into
    file name, attribute type, attribute name, and version number fields.

    If the name is well formed according to the following rules:

        A. An NTFS name may not contain any of the following characters:

           0x0000-0x001F " / < > ? | *

        B. An Ntfs name can take any of the following forms:

            ::T
            :A
            :A:T
            N
            N:::V
            N::T
            N::T:V
            N:A
            N:A::V
            N:A:T
            N:A:T:V

           If a version number is present, there must be a file name.
           We specifically note the legal names without a filename
           component (AttributeOnly) and any name with a version number
           (VersionNumberPresent).

           Incidently, N corresponds to file name, T to attribute type, A to
           attribute name, and V to version number.

    TRUE is returned.  If FALSE is returned, then the OUT parameter
    FoundIllegalCharacter will be set appropriatly.  Note that the buffer
    space for ParsedName comes from Name.

Arguments:

    Name - This is the single path element input name.

    WildCardsPermissible - This determines if wild cards characters should be
        considered legal

    FoundIllegalCharacter - This parameter will receive a TRUE if the the
        function returns FALSE because of encountering an illegal character.

    ParsedName - Recieves the pieces of the processed name.  Note that the
        storage for all the string from the input Name.

ReturnValue:

    TRUE if the Name is well formed, and FALSE otherwise.


--*/

{
    ULONG Index;
    ULONG NameLength;
    ULONG FieldCount;
    ULONG FieldIndexes[5];
    UCHAR ValidCharFlags = FSRTL_NTFS_LEGAL;

    PULONG Fields;

    BOOLEAN IsNameValid = TRUE;

    PAGED_CODE();

    //
    // Initialize some OUT parameters and local variables.
    //

    *FoundIllegalCharacter = FALSE;

    Fields = &ParsedName->FieldsPresent;

    *Fields = 0;

    FieldCount = 1;

    FieldIndexes[0] = 0xFFFFFFFF;   //  We add on to this later...

    //
    //  For starters, zero length names are invalid.
    //

    NameLength = Name.Length / sizeof(WCHAR);

    if ( NameLength == 0 ) {

        return FALSE;
    }

    //
    //  Now name must correspond to a legal single Ntfs Name.
    //

    for (Index = 0; Index < NameLength; Index += 1) {

        WCHAR Char;

        Char = Name.Buffer[Index];

        //
        //  First check that file names are well formed in terms of colons.
        //

        if ( Char == L':' ) {

            //
            //  A colon can't be the last character, and we can't have
            //  more than three colons.
            //

            if ( (Index == NameLength - 1) ||
                 (FieldCount >= 4) ) {

                IsNameValid = FALSE;
                break;
            }

            FieldIndexes[FieldCount] = Index;

            FieldCount += 1;
            ValidCharFlags = FSRTL_NTFS_STREAM_LEGAL;

            continue;
        }

        //
        //  Now check for wild card characters if they weren't allowed,
        //  and other illegal characters.
        //

        if ((Char <= 0xff) &&
            !FsRtlTestAnsiCharacter( Char, TRUE, WildCardsPermissible, ValidCharFlags )) {

            IsNameValid = FALSE;
            *FoundIllegalCharacter = TRUE;
            break;
        }
    }

    //
    //  If we ran into a problem with one of the fields, don't try to load
    //  up that field into the out parameter.
    //

    if ( !IsNameValid ) {

        FieldCount -= 1;

    //
    //  Set the end of the last field to the current Index.
    //

    } else {

        FieldIndexes[FieldCount] = Index;
    }

    //
    //  Now we load up the OUT parmeters
    //

    while ( FieldCount != 0 ) {

        ULONG StartIndex;
        ULONG EndIndex;
        USHORT Length;

        //
        //  Add one here since this is actually the position of the colon.
        //

        StartIndex = FieldIndexes[FieldCount - 1] + 1;

        EndIndex = FieldIndexes[FieldCount];

        Length = (USHORT)((EndIndex - StartIndex) * sizeof(WCHAR));

        //
        //  If this field is empty, skip it
        //

        if ( Length == 0 ) {

            FieldCount -= 1;
            continue;
        }

        //
        //  Now depending of the field, extract the appropriate information.
        //

        if ( FieldCount == 1 ) {

            UNICODE_STRING TempName;

            TempName.Buffer = &Name.Buffer[StartIndex];
            TempName.Length = Length;
            TempName.MaximumLength = Length;

            //
            //  If the resulting length is 0, forget this entry.
            //

            if (TempName.Length == 0) {

                FieldCount -= 1;
                continue;
            }

            SetFlag(*Fields, FILE_NAME_PRESENT_FLAG);

            ParsedName->FileName = TempName;

        } else if ( FieldCount == 2) {

            SetFlag(*Fields, ATTRIBUTE_NAME_PRESENT_FLAG);

            ParsedName->AttributeName.Buffer = &Name.Buffer[StartIndex];
            ParsedName->AttributeName.Length = Length;
            ParsedName->AttributeName.MaximumLength = Length;

        } else if ( FieldCount == 3) {

            SetFlag(*Fields, ATTRIBUTE_TYPE_PRESENT_FLAG);

            ParsedName->AttributeType.Buffer = &Name.Buffer[StartIndex];
            ParsedName->AttributeType.Length = Length;
            ParsedName->AttributeType.MaximumLength = Length;

        } else if ( FieldCount == 4) {

            ULONG VersionNumber;
            STRING VersionNumberA;
            UNICODE_STRING VersionNumberU;

            NTSTATUS Status;
            UCHAR *endp = NULL;

            VersionNumberU.Buffer = &Name.Buffer[StartIndex];
            VersionNumberU.Length = Length;
            VersionNumberU.MaximumLength = Length;

            //
            //  Note that the resulting Ansi string is null terminated.
            //

            Status = RtlUnicodeStringToCountedOemString( &VersionNumberA,
                                                  &VersionNumberU,
                                                  TRUE );

            //
            //  If something went wrong (most likely ran out of pool), raise.
            //

            if ( !NT_SUCCESS(Status) ) {

                ExRaiseStatus( Status );
            }

            VersionNumber = 0; //**** strtoul( VersionNumberA.Buffer, &endp, 0 );

            RtlFreeOemString( &VersionNumberA );

            if ( (VersionNumber == MAXULONG) || (endp != NULL) ) {

                IsNameValid = FALSE;

            } else {

                SetFlag( *Fields, VERSION_NUMBER_PRESENT_FLAG );
                ParsedName->VersionNumber = VersionNumber;
            }
        }

        FieldCount -= 1;
    }

    //
    //  Check for special malformed cases.
    //

    if (FlagOn( *Fields, VERSION_NUMBER_PRESENT_FLAG )
        && !FlagOn( *Fields, FILE_NAME_PRESENT_FLAG )) {

        IsNameValid = FALSE;
    }

    return IsNameValid;
}


VOID
NtfsUpcaseName (
    IN PWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN OUT PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine upcases a string.

Arguments:

    UpcaseTable - Pointer to an array of Unicode upcased characters indexed by
                  the Unicode character to be upcased.

    UpcaseTableSize - Size of the Upcase table in unicode characters

    Name - Supplies the string to upcase

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpcaseName\n") );
    DebugTrace( 0, Dbg, ("Name = %Z\n", Name) );

    Length = Name->Length / sizeof(WCHAR);

    for (i=0; i < Length; i += 1) {

        if ((ULONG)Name->Buffer[i] < UpcaseTableSize) {
            Name->Buffer[i] = UpcaseTable[ (ULONG)Name->Buffer[i] ];
        }
    }

    DebugTrace( 0, Dbg, ("Upcased Name = %Z\n", Name) );
    DebugTrace( -1, Dbg, ("NtfsUpcaseName -> VOID\n") );

    return;
}


FSRTL_COMPARISON_RESULT
NtfsCollateNames (
    IN PCWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN PCUNICODE_STRING Expression,
    IN PCUNICODE_STRING Name,
    IN FSRTL_COMPARISON_RESULT WildIs,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine compares an expression with a name lexigraphically for
    LessThan, EqualTo, or GreaterThan.  If the expression does not contain
    any wildcards, this procedure does a complete comparison.  If the
    expression does contain wild cards, then the comparison is only done up
    to the first wildcard character.  Name may not contain wild cards.
    The wildcard character compares as less then all other characters.  So
    the wildcard name "*.*" will always compare less than all all strings.

Arguments:

    UpcaseTable - Pointer to an array of Unicode upcased characters indexed by
                  the Unicode character to be upcased.

    UpcaseTableSize - Size of the Upcase table in unicode characters

    Expression - Supplies the first name expression to compare, optionally with
                 wild cards.  Note that caller must have already upcased
                 the name (this will make lookup faster).

    Name - Supplies the second name to compare - no wild cards allowed.
           The caller must have already upcased the name.

    WildIs - Determines what Result is returned if a wild card is encountered
             in the Expression String.  For example, to find the start of
             an expression in the Btree, LessThan should be supplied; then
             GreaterThan should be supplied to find the end of the expression
             in the tree.

    IgnoreCase - TRUE if case should be ignored for the comparison

Return Value:

    FSRTL_COMPARISON_RESULT - LessThan    if Expression <  Name
                              EqualTo     if Expression == Name
                              GreaterThan if Expression >  Name

--*/

{
    WCHAR ConstantChar;
    WCHAR ExpressionChar;

    ULONG i;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCollateNames\n") );
    DebugTrace( 0, Dbg, ("Expression = %Z\n", Expression) );
    DebugTrace( 0, Dbg, ("Name       = %Z\n", Name) );
    DebugTrace( 0, Dbg, ("WildIs     = %08lx\n", WildIs) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );

    //
    //  Calculate the length in wchars that we need to compare.  This will
    //  be the smallest length of the two strings.
    //

    if (Expression->Length < Name->Length) {

        Length = Expression->Length / sizeof(WCHAR);

    } else {

        Length = Name->Length / sizeof(WCHAR);
    }

    //
    //  Now we'll just compare the elements in the names until we can decide
    //  their lexicagrahical ordering, checking for wild cards in
    //  LocalExpression (from Expression).
    //
    //  If an upcase table was specified, the compare is done case insensitive.
    //

    for (i = 0; i < Length; i += 1) {

        ConstantChar = Name->Buffer[i];
        ExpressionChar = Expression->Buffer[i];

        if ( IgnoreCase ) {

            if (ConstantChar < UpcaseTableSize) {
                ConstantChar = UpcaseTable[(ULONG)ConstantChar];
            }
            if (ExpressionChar < UpcaseTableSize) {
                ExpressionChar = UpcaseTable[(ULONG)ExpressionChar];
            }
        }

        if ( FsRtlIsUnicodeCharacterWild(ExpressionChar) ) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> %08lx (Wild)\n", WildIs) );
            return WildIs;
        }

        if ( ExpressionChar < ConstantChar ) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> LessThan\n") );
            return LessThan;
        }

        if ( ExpressionChar > ConstantChar ) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> GreaterThan\n") );
            return GreaterThan;
        }
    }

    //
    //  We've gone through the entire short match and they're equal
    //  so we need to now check which one is shorter, or, if
    //  LocalExpression is longer, we need to see if the next character is
    //  wild!  (For example, an enumeration of "ABC*", must return
    //  "ABC".
    //

    if (Expression->Length < Name->Length) {

        DebugTrace( -1, Dbg, ("NtfsCollateNames -> LessThan (length)\n") );
        return LessThan;
    }

    if (Expression->Length > Name->Length) {

        if (FsRtlIsUnicodeCharacterWild(Expression->Buffer[i])) {

            DebugTrace( -1, Dbg, ("NtfsCollateNames -> %08lx (trailing wild)\n", WildIs) );
            return WildIs;
        }

        DebugTrace( -1, Dbg, ("NtfsCollateNames -> GreaterThan (length)\n") );
        return GreaterThan;
    }

    DebugTrace( -1, Dbg, ("NtfsCollateNames -> EqualTo\n") );
    return EqualTo;
}

BOOLEAN
NtfsIsFileNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    )

/*++

Routine Description:

    This routine checks if the specified file name is valid.  Note that
    only the file name part of the name is allowed, ie. no colons are
    permitted.

Arguments:

    FileName - Supplies the name to check.

    WildCardsPermissible - Tells us if wild card characters are ok.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    ULONG Index;
    ULONG NameLength;
    BOOLEAN AllDots = TRUE;
    BOOLEAN IsNameValid = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsIsFileNameValid\n") );
    DebugTrace( 0, Dbg, ("FileName             = %Z\n", FileName) );
    DebugTrace( 0, Dbg, ("WildCardsPermissible = %s\n",
                         WildCardsPermissible ? "TRUE" : "FALSE") );

    //
    //  It better be a valid unicode string.
    //

    if ((FileName->Length == 0) || FlagOn( FileName->Length, 1 )) {

        IsNameValid = FALSE;

    } else {

        //
        //  Check if corresponds to a legal single Ntfs Name.
        //

        NameLength = FileName->Length / sizeof(WCHAR);

        for (Index = 0; Index < NameLength; Index += 1) {

            WCHAR Char;

            Char = FileName->Buffer[Index];

            //
            //  Check for wild card characters if they weren't allowed, and
            //  check for the other illegal characters including the colon and
            //  backslash characters since this can only be a single component.
            //

            if ( ((Char <= 0xff) &&
                  !FsRtlIsAnsiCharacterLegalNtfs(Char, WildCardsPermissible)) ||
                 (Char == L':') ||
                 (Char == L'\\') ) {

                IsNameValid = FALSE;
                break;
            }

            //
            //  Remember if this is not a '.' character.
            //

            if (Char != L'.') {

                AllDots = FALSE;
            }
        }

        //
        //  The names '.' and '..' are also invalid.
        //

        if (AllDots
            && (NameLength == 1
                || NameLength == 2)) {

            IsNameValid = FALSE;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsIsFileNameValid -> %s\n", IsNameValid ? "TRUE" : "FALSE") );

    return IsNameValid;
}


BOOLEAN
NtfsIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    )

/*++

Routine Description:

    This routine checks if the specified file name is conformant to the
    Fat 8.3 file naming rules.

Arguments:

    FileName - Supplies the name to check.

    WildCardsPermissible - Tells us if wild card characters are ok.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

--*/

{
    BOOLEAN Results;
    STRING DbcsName;
    USHORT i;
    CHAR Buffer[24];
    WCHAR wc;

    PAGED_CODE();

    //
    //  If the name is more than 24 bytes then it can't be a valid Fat name.
    //

    if (FileName->Length > 24) {

        return FALSE;
    }

    //
    //  We will do some extra checking ourselves because we really want to be
    //  fairly restrictive of what an 8.3 name contains.  That way
    //  we will then generate an 8.3 name for some nomially valid 8.3
    //  names (e.g., names that contain DBCS characters).  The extra characters
    //  we'll filter off are those characters less than and equal to the space
    //  character and those beyond lowercase z.
    //

    if (FlagOn( NtfsData.Flags,NTFS_FLAGS_ALLOW_EXTENDED_CHAR )) {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc == 0x007c)) { return FALSE; }
        }

    } else {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc >= 0x007f) || (wc == 0x007c)) { return FALSE; }
        }
    }

    //
    //  The characters match up okay so now build up the dbcs string to call
    //  the fsrtl routine to check for legal 8.3 formation
    //

    Results = FALSE;

    DbcsName.MaximumLength = 24;
    DbcsName.Buffer = Buffer;

    if (NT_SUCCESS(RtlUnicodeStringToCountedOemString( &DbcsName, FileName, FALSE))) {

        if (FsRtlIsFatDbcsLegal( DbcsName, WildCardsPermissible, FALSE, FALSE )) {

            Results = TRUE;
        }
    }

    //
    //  And return to our caller
    //

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\nodetype.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define NTFS_NTC_DATA_HEADER             ((NODE_TYPE_CODE)0x0700)
#define NTFS_NTC_VCB                     ((NODE_TYPE_CODE)0x0701)
#define NTFS_NTC_FCB                     ((NODE_TYPE_CODE)0x0702)
#define NTFS_NTC_SCB_INDEX               ((NODE_TYPE_CODE)0x0703)
#define NTFS_NTC_SCB_ROOT_INDEX          ((NODE_TYPE_CODE)0x0704)
#define NTFS_NTC_SCB_DATA                ((NODE_TYPE_CODE)0x0705)
#define NTFS_NTC_SCB_MFT                 ((NODE_TYPE_CODE)0x0706)
#define NTFS_NTC_SCB_NONPAGED            ((NODE_TYPE_CODE)0x0707)
#define NTFS_NTC_CCB_INDEX               ((NODE_TYPE_CODE)0x0708)
#define NTFS_NTC_CCB_DATA                ((NODE_TYPE_CODE)0x0709)
#define NTFS_NTC_IRP_CONTEXT             ((NODE_TYPE_CODE)0x070A)
#define NTFS_NTC_LCB                     ((NODE_TYPE_CODE)0x070B)
#define NTFS_NTC_PREFIX_ENTRY            ((NODE_TYPE_CODE)0x070C)
#define NTFS_NTC_QUOTA_CONTROL           ((NODE_TYPE_CODE)0x070D)
#define NTFS_NTC_USN_RECORD              ((NODE_TYPE_CODE)0x070E)



typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(P) ((P) != NULL ? (*((PNODE_TYPE_CODE)(P))) : NTC_UNDEFINED)
#define SafeNodeType(P) (*((PNODE_TYPE_CODE)(P)))


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  NTFS_BUG_CHECK_ values defined below and then use NtfsBugCheck to bugcheck
//  the system.
//

#define NTFS_BUG_CHECK_ALLOCSUP          (0x00010000)
#define NTFS_BUG_CHECK_ATTRDATA          (0x00020000)
#define NTFS_BUG_CHECK_ATTRSUP           (0x00030000)
#define NTFS_BUG_CHECK_BITMPSUP          (0x00040000)
#define NTFS_BUG_CHECK_CACHESUP          (0x00050000)
#define NTFS_BUG_CHECK_CHECKSUP          (0x00060000)
#define NTFS_BUG_CHECK_CLEANUP           (0x00070000)
#define NTFS_BUG_CHECK_CLOST             (0x00080000)
#define NTFS_BUG_CHECK_COLATSUP          (0x00090000)
#define NTFS_BUG_CHECK_CREATE            (0x000a0000)
#define NTFS_BUG_CHECK_DEVCTRL           (0x000b0000)
#define NTFS_BUG_CHECK_DEVIOSUP          (0x000c0000)
#define NTFS_BUG_CHECK_DIRCTRL           (0x000d0000)
#define NTFS_BUG_CHECK_EA                (0x000e0000)
#define NTFS_BUG_CHECK_FILEINFO          (0x000f0000)
#define NTFS_BUG_CHECK_FILOBSUP          (0x00100000)
#define NTFS_BUG_CHECK_FLUSH             (0x00110000)
#define NTFS_BUG_CHECK_FSCTRL            (0x00120000)
#define NTFS_BUG_CHECK_FSPDISP           (0x00130000)
#define NTFS_BUG_CHECK_HASHSUP           (0x00280000)
#define NTFS_BUG_CHECK_INDEXSUP          (0x00140000)
#define NTFS_BUG_CHECK_LOCKCTRL          (0x00150000)
#define NTFS_BUG_CHECK_LOGSUP            (0x00160000)
#define NTFS_BUG_CHECK_MFTSUP            (0x00170000)
#define NTFS_BUG_CHECK_NAMESUP           (0x00180000)
#define NTFS_BUG_CHECK_NTFSDATA          (0x00190000)
#define NTFS_BUG_CHECK_NTFSINIT          (0x001a0000)
#define NTFS_BUG_CHECK_PNP               (0x00270000)
#define NTFS_BUG_CHECK_PREFXSUP          (0x001b0000)
#define NTFS_BUG_CHECK_READ              (0x001c0000)
#define NTFS_BUG_CHECK_RESRCSUP          (0x001d0000)
#define NTFS_BUG_CHECK_RESTRSUP          (0x001e0000)
#define NTFS_BUG_CHECK_SECURSUP          (0x001f0000)
#define NTFS_BUG_CHECK_SEINFO            (0x00200000)
#define NTFS_BUG_CHECK_SHUTDOWN          (0x00210000)
#define NTFS_BUG_CHECK_STRUCSUP          (0x00220000)
#define NTFS_BUG_CHECK_VERFYSUP          (0x00230000)
#define NTFS_BUG_CHECK_VOLINFO           (0x00240000)
#define NTFS_BUG_CHECK_WORKQUE           (0x00250000)
#define NTFS_BUG_CHECK_WRITE             (0x00260000)

#define NTFS_LAST_BUG_CHECK              NTFS_BUG_CHECK_HASHSUP

#define NtfsBugCheck(A,B,C) { KeBugCheckEx(NTFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfsexp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Ntfsexp.c

Abstract:

    This module implements the exported routines for Ntfs

Author:

    Jeff Havens     [JHavens]        20-Dec-1995

Revision History:

--*/

#include "NtfsProc.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsLoadAddOns)
#pragma alloc_text(PAGE, NtOfsRegisterCallBacks)
#endif

NTSTATUS
EfsInitialization(
    void
    );


VOID
NtfsLoadAddOns (
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Context,
    IN ULONG Count
    )

/*++

Routine Description:

    This routine attempts to initialize the efs support library.

Arguments:

    DriverObject - Driver object for NTFS

    Context - Unused, required by I/O system.

    Count - Unused, required by I/O system.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Count);
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // do any efs initialization
    // we ignore the status return bedcause there really
    // isn't anything we can do about it and ntfs will work
    // fine without it.
    //

    if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_PERSONAL )) {
        Status = EfsInitialization();
    }

    //
    // return to caller
    //

    return;
}


NTSTATUS
NtOfsRegisterCallBacks (
    NTFS_ADDON_TYPES NtfsAddonType,
    PVOID CallBackTable
    )

/*++

Routine Description:

    This routine is called by one of the NTFS add-ons to register its
    callback routines. These routines are call by NTFS at the appropriate
    times.

Arguments:

    NtfsAddonType - Indicates the type of callback table.

    CallBackTable - Pointer to call back routines for addon.

Return Value:

    Returns a status indicating if the callbacks were accepted.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    switch (NtfsAddonType) {

    case Encryption :

        {
            Status = STATUS_INVALID_PARAMETER;

            //
            //  Bail if Ntfs has not been initialized.
            //

            if (SafeNodeType( &NtfsData ) != NTFS_NTC_DATA_HEADER) {

                return STATUS_DEVICE_DOES_NOT_EXIST;

            } else {

                //
                //  Only allow one encryption driver to register.
                //

                NtfsLockNtfsData();

                if (!FlagOn( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER )) {

                    ENCRYPTION_CALL_BACK *EncryptionCallBackTable = CallBackTable;

                    //
                    //  The caller must pass a callback table and the version must be correct.
                    //

                    if ((EncryptionCallBackTable != NULL) &&
                        (EncryptionCallBackTable->InterfaceVersion == ENCRYPTION_CURRENT_INTERFACE_VERSION)) {

                        //
                        // Save the call back values.
                        //

                        RtlCopyMemory( &NtfsData.EncryptionCallBackTable,
                                       EncryptionCallBackTable,
                                       sizeof( ENCRYPTION_CALL_BACK ));
#ifdef EFSDBG
                        NtfsData.EncryptionCallBackTable.AfterReadProcess = NtfsDummyEfsRead;
                        NtfsData.EncryptionCallBackTable.BeforeWriteProcess = NtfsDummyEfsWrite;
#endif
                        SetFlag( NtfsData.Flags, NTFS_FLAGS_ENCRYPTION_DRIVER );
                        Status = STATUS_SUCCESS;
                    }
                }

                NtfsUnlockNtfsData();
                return Status;
            }
        }

    default :

        return STATUS_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfsdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsData.c

Abstract:

    This module declares the global data used by the Ntfs file system.

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_NTFSDATA)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

//
//  Debugging control variables
//

PUCHAR NtfsPageInAddress = NULL;
LONGLONG NtfsMapOffset = -1;

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('NFtN')

#define CollectExceptionStats(VCB,EXCEPTION_CODE) {                                         \
    if ((VCB) != NULL) {                                                                    \
        PFILE_SYSTEM_STATISTICS FsStat = &(VCB)->Statistics[KeGetCurrentProcessorNumber()]; \
        if ((EXCEPTION_CODE) == STATUS_LOG_FILE_FULL) {                                     \
            FsStat->Ntfs.LogFileFullExceptions += 1;                                        \
        } else {                                                                            \
            FsStat->Ntfs.OtherExceptions += 1;                                              \
        }                                                                                   \
    }                                                                                       \
}

//
//  The global fsd data record
//

NTFS_DATA NtfsData;

//
//  Mutex to synchronize creation of stream files.
//

KMUTANT StreamFileCreationMutex;

//
//  Notification event for creation of encrypted files.
//

KEVENT NtfsEncryptionPendingEvent;
#ifdef KEITHKA
ULONG EncryptionPendingCount = 0;
#endif

//
//  A mutex and queue of NTFS MCBS that will be freed
//  if we reach over a certain threshold
//

FAST_MUTEX NtfsMcbFastMutex;
LIST_ENTRY NtfsMcbLruQueue;

ULONG NtfsMcbHighWaterMark;
ULONG NtfsMcbLowWaterMark;
ULONG NtfsMcbCurrentLevel;

BOOLEAN NtfsMcbCleanupInProgress;
WORK_QUEUE_ITEM NtfsMcbWorkItem;

//
//  The global large integer constants
//

LARGE_INTEGER NtfsLarge0 = {0x00000000,0x00000000};
LARGE_INTEGER NtfsLarge1 = {0x00000001,0x00000000};
LARGE_INTEGER NtfsLargeMax = {0xffffffff,0x7fffffff};
LARGE_INTEGER NtfsLargeEof = {0xffffffff,0xffffffff};

//
//  The granularity for updating last access times
//  

LONGLONG NtfsLastAccess;

//
//   The following fields are used to allocate nonpaged structures
//  using a lookaside list, and other fixed sized structures from a
//  small cache.
//

NPAGED_LOOKASIDE_LIST NtfsIoContextLookasideList;
NPAGED_LOOKASIDE_LIST NtfsIrpContextLookasideList;
NPAGED_LOOKASIDE_LIST NtfsKeventLookasideList;
NPAGED_LOOKASIDE_LIST NtfsScbNonpagedLookasideList;
NPAGED_LOOKASIDE_LIST NtfsScbSnapshotLookasideList;
NPAGED_LOOKASIDE_LIST NtfsCompressSyncLookasideList;

PAGED_LOOKASIDE_LIST NtfsCcbLookasideList;
PAGED_LOOKASIDE_LIST NtfsCcbDataLookasideList;
PAGED_LOOKASIDE_LIST NtfsDeallocatedRecordsLookasideList;
PAGED_LOOKASIDE_LIST NtfsFcbDataLookasideList;
PAGED_LOOKASIDE_LIST NtfsFcbIndexLookasideList;
PAGED_LOOKASIDE_LIST NtfsIndexContextLookasideList;
PAGED_LOOKASIDE_LIST NtfsLcbLookasideList;
PAGED_LOOKASIDE_LIST NtfsNukemLookasideList;
PAGED_LOOKASIDE_LIST NtfsScbDataLookasideList;

//
//  Useful constant Unicode strings.
//

//
//  This is the string for the name of the index allocation attributes.
//

const UNICODE_STRING NtfsFileNameIndex = CONSTANT_UNICODE_STRING( L"$I30" );

//
//  This is the string for the attribute code for index allocation.
//  $INDEX_ALLOCATION.
//

const UNICODE_STRING NtfsIndexAllocation = CONSTANT_UNICODE_STRING( L"$INDEX_ALLOCATION" );

//
//  This is the string for the data attribute, $DATA.
//

const UNICODE_STRING NtfsDataString = CONSTANT_UNICODE_STRING( L"$DATA" );

//
//  This is the string for the bitmap attribute
//

const UNICODE_STRING NtfsBitmapString = CONSTANT_UNICODE_STRING( L"$BITMAP" );

//
//  This is the string for the attribute list attribute
//

const UNICODE_STRING NtfsAttrListString = CONSTANT_UNICODE_STRING( L"$ATTRIBUTE_LIST" );

//
//  This is the string for the attribute list attribute
//

const UNICODE_STRING NtfsReparsePointString = CONSTANT_UNICODE_STRING( L"$REPARSE_POINT" );

//
//  These strings are used as the Scb->AttributeName for
//  user-opened general indices.  Declaring them here avoids
//  having to marshal allocating & freeing them.
//

const UNICODE_STRING NtfsObjId = CONSTANT_UNICODE_STRING( L"$O" );
const UNICODE_STRING NtfsQuota = CONSTANT_UNICODE_STRING( L"$Q" );

//
//  The following is the name of the data stream for the Usn journal.
//

const UNICODE_STRING JournalStreamName = CONSTANT_UNICODE_STRING( L"$J" );

//
//  These are the strings for the files in the extend directory.
//

const UNICODE_STRING NtfsExtendName = CONSTANT_UNICODE_STRING( L"$Extend" );
const UNICODE_STRING NtfsUsnJrnlName = CONSTANT_UNICODE_STRING( L"$UsnJrnl" );
const UNICODE_STRING NtfsQuotaName = CONSTANT_UNICODE_STRING( L"$Quota" );
const UNICODE_STRING NtfsObjectIdName = CONSTANT_UNICODE_STRING( L"$ObjId" );
const UNICODE_STRING NtfsMountTableName = CONSTANT_UNICODE_STRING( L"$Reparse" );

//
//  This strings are used for informational popups.
//

const UNICODE_STRING NtfsSystemFiles[] = {

    CONSTANT_UNICODE_STRING( L"\\$Mft" ),
    CONSTANT_UNICODE_STRING( L"\\$MftMirr" ),
    CONSTANT_UNICODE_STRING( L"\\$LogFile" ),
    CONSTANT_UNICODE_STRING( L"\\$Volume" ),
    CONSTANT_UNICODE_STRING( L"\\$AttrDef" ),
    CONSTANT_UNICODE_STRING( L"\\" ),
    CONSTANT_UNICODE_STRING( L"\\$BitMap" ),
    CONSTANT_UNICODE_STRING( L"\\$Boot" ),
    CONSTANT_UNICODE_STRING( L"\\$BadClus" ),
    CONSTANT_UNICODE_STRING( L"\\$Secure" ),
    CONSTANT_UNICODE_STRING( L"\\$UpCase" ),
    CONSTANT_UNICODE_STRING( L"\\$Extend" ),
};

const UNICODE_STRING NtfsInternalUseFile[] = {
    CONSTANT_UNICODE_STRING( L"\\$ChangeAttributeValue" ),
    CONSTANT_UNICODE_STRING( L"\\$ChangeAttributeValue2" ),
    CONSTANT_UNICODE_STRING( L"\\$CommonCleanup" ),
    CONSTANT_UNICODE_STRING( L"\\$ConvertToNonresident" ),
    CONSTANT_UNICODE_STRING( L"\\$CreateNonresidentWithValue" ),
    CONSTANT_UNICODE_STRING( L"\\$DeallocateRecord" ),
    CONSTANT_UNICODE_STRING( L"\\$DeleteAllocationFromRecord" ),
    CONSTANT_UNICODE_STRING( L"\\$Directory" ),
    CONSTANT_UNICODE_STRING( L"\\$InitializeRecordAllocation" ),
    CONSTANT_UNICODE_STRING( L"\\$MapAttributeValue" ),
    CONSTANT_UNICODE_STRING( L"\\$NonCachedIo" ),
    CONSTANT_UNICODE_STRING( L"\\$PerformHotFix" ),
    CONSTANT_UNICODE_STRING( L"\\$PrepareToShrinkFileSize" ),
    CONSTANT_UNICODE_STRING( L"\\$ReplaceAttribute" ),
    CONSTANT_UNICODE_STRING( L"\\$ReplaceAttribute2" ),
    CONSTANT_UNICODE_STRING( L"\\$SetAllocationInfo" ),
    CONSTANT_UNICODE_STRING( L"\\$SetEndOfFileInfo" ),
    CONSTANT_UNICODE_STRING( L"\\$ZeroRangeInStream" ),
    CONSTANT_UNICODE_STRING( L"\\$ZeroRangeInStream2" ),
    CONSTANT_UNICODE_STRING( L"\\$ZeroRangeInStream3" ),
};

const UNICODE_STRING NtfsUnknownFile =
    CONSTANT_UNICODE_STRING( L"\\????" );

const UNICODE_STRING NtfsRootIndexString =
    CONSTANT_UNICODE_STRING( L"." );

//
//  This is the empty string.  This can be used to pass a string with
//  no length.
//

const UNICODE_STRING NtfsEmptyString =
    CONSTANT_UNICODE_STRING( L"" );

//
//  The following file references are used to identify system files.
//

const FILE_REFERENCE MftFileReference = { MASTER_FILE_TABLE_NUMBER, 0, MASTER_FILE_TABLE_NUMBER };
const FILE_REFERENCE Mft2FileReference = { MASTER_FILE_TABLE2_NUMBER, 0, MASTER_FILE_TABLE2_NUMBER };
const FILE_REFERENCE LogFileReference = { LOG_FILE_NUMBER, 0, LOG_FILE_NUMBER };
const FILE_REFERENCE VolumeFileReference = { VOLUME_DASD_NUMBER, 0, VOLUME_DASD_NUMBER };
const FILE_REFERENCE AttrDefFileReference = { ATTRIBUTE_DEF_TABLE_NUMBER, 0, ATTRIBUTE_DEF_TABLE_NUMBER };
const FILE_REFERENCE RootIndexFileReference = { ROOT_FILE_NAME_INDEX_NUMBER, 0, ROOT_FILE_NAME_INDEX_NUMBER };
const FILE_REFERENCE BitmapFileReference = { BIT_MAP_FILE_NUMBER, 0, BIT_MAP_FILE_NUMBER };
const FILE_REFERENCE BootFileReference = { BOOT_FILE_NUMBER, 0, BOOT_FILE_NUMBER };
const FILE_REFERENCE ExtendFileReference = { EXTEND_NUMBER, 0, EXTEND_NUMBER };
const FILE_REFERENCE FirstUserFileReference = { FIRST_USER_FILE_NUMBER, 0, 0 };

//
//  The following are used to determine what level of protection to attach
//  to system files and attributes.
//

BOOLEAN NtfsProtectSystemFiles = TRUE;
BOOLEAN NtfsProtectSystemAttributes = TRUE;

//
//  The following is used to indicate the multiplier value for the Mft zone.
//

ULONG NtfsMftZoneMultiplier;

//
//  Debug code for finding corruption.
//

#if (DBG || defined( NTFS_FREE_ASSERTS ))
BOOLEAN NtfsBreakOnCorrupt = TRUE;
#else
BOOLEAN NtfsBreakOnCorrupt = FALSE;
#endif

//#endif

//
//  Enable compression on the wire.
//

BOOLEAN NtfsEnableCompressedIO = FALSE;

//
//  FsRtl fast I/O call backs
//

FAST_IO_DISPATCH NtfsFastIoDispatch;

#ifdef BRIANDBG
ULONG NtfsIgnoreReserved = FALSE;
#endif

#ifdef NTFS_LOG_FULL_TEST
LONG NtfsFailCheck = 0;
LONG NtfsFailFrequency = 0;
LONG NtfsPeriodicFail = 0;
#endif

#ifdef NTFSDBG

LONG NtfsDebugTraceLevel = DEBUG_TRACE_ERROR;
LONG NtfsDebugTraceIndent = 0;

ULONG NtfsFsdEntryCount = 0;
ULONG NtfsFspEntryCount = 0;
ULONG NtfsIoCallDriverCount = 0;
LONG NtfsReturnStatusFilter = 0xf0ffffffL; // just an non-existent error code

#endif // NTFSDBG

#ifdef SYSCACHE_DEBUG
ULONG NtfsSyscacheTrackingActive = 1;
#endif

//
//  Default restart version.
//

#ifdef _WIN64
ULONG NtfsDefaultRestartVersion = 1;
#else
ULONG NtfsDefaultRestartVersion = 0;
#endif

//
//  Performance statistics
//

ULONG NtfsMaxDelayedCloseCount;
ULONG NtfsMinDelayedCloseCount;
ULONG NtfsThrottleCreates;
ULONG NtfsFailedHandedOffPagingFileOps = 0;
ULONG NtfsFailedPagingFileOps = 0;
ULONG NtfsFailedAborts = 0;
ULONG NtfsFailedPagingReads = 0;
ULONG NtfsFailedHandedOffPagingReads = 0;
ULONG NtfsFailedLfsRestart = 0;

ULONG NtfsCleanCheckpoints = 0;
ULONG NtfsPostRequests = 0;

const UCHAR BaadSignature[4] = {'B', 'A', 'A', 'D'};
const UCHAR IndexSignature[4] = {'I', 'N', 'D', 'X'};
const UCHAR FileSignature[4] = {'F', 'I', 'L', 'E'};
const UCHAR HoleSignature[4] = {'H', 'O', 'L', 'E'};
const UCHAR ChkdskSignature[4] = {'C', 'H', 'K', 'D'};

//
//  Large Reserved Buffer Context
//

ULONG NtfsReservedInUse = 0;
PVOID NtfsReserved1 = NULL;
PVOID NtfsReserved2 = NULL;
ULONG NtfsReserved2Count = 0;
PVOID NtfsReserved3 = NULL;
PVOID NtfsReserved1Thread = NULL;
PVOID NtfsReserved2Thread = NULL;
PVOID NtfsReserved3Thread = NULL;
PFCB NtfsReserved12Fcb = NULL;
PFCB NtfsReserved3Fcb = NULL;
PVOID NtfsReservedBufferThread = NULL;
BOOLEAN NtfsBufferAllocationFailure = FALSE;
FAST_MUTEX NtfsReservedBufferMutex;
ERESOURCE NtfsReservedBufferResource;
LARGE_INTEGER NtfsShortDelay = {(ULONG)-100000, -1};    // 10 milliseconds

FAST_MUTEX NtfsScavengerLock;
PIRP_CONTEXT NtfsScavengerWorkList;
BOOLEAN NtfsScavengerRunning;
ULONGLONG NtfsMaxQuotaNotifyRate = MIN_QUOTA_NOTIFY_TIME;
ULONG NtfsAsyncPostThreshold;

UCHAR NtfsZeroExtendedInfo[48];

typedef struct _VOLUME_ERROR_PACKET {
    NTSTATUS Status;
    UNICODE_STRING FileName;
    PKTHREAD Thread;
} VOLUME_ERROR_PACKET, *PVOLUME_ERROR_PACKET;

#ifdef NTFS_RWC_DEBUG
//
//  Range to include in COW checks.
//

LONGLONG NtfsRWCLowThreshold = 0;
LONGLONG NtfsRWCHighThreshold = 0x7fffffffffffffff;
#endif

VOID
NtfsResolveVolumeAndRaiseErrorSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    );

NTSTATUS
NtfsFsdDispatchSwitch (
    IN PIRP_CONTEXT StackIrpContext OPTIONAL,
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

//
//  Locals used to track specific failures.
//

BOOLEAN NtfsTestStatus = FALSE;
BOOLEAN NtfsTestFilter = FALSE;
NTSTATUS NtfsTestStatusCode = STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsFastIoCheckIfPossible)
#pragma alloc_text(PAGE, NtfsFastQueryBasicInfo)
#pragma alloc_text(PAGE, NtfsFastQueryStdInfo)
#pragma alloc_text(PAGE, NtfsFastQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, NtfsFastIoQueryCompressionInfo)
#pragma alloc_text(PAGE, NtfsFastIoQueryCompressedSize)
#pragma alloc_text(PAGE, NtfsFsdDispatch)
#pragma alloc_text(PAGE, NtfsFsdDispatchWait)
#pragma alloc_text(PAGE, NtfsFsdDispatchSwitch)
#pragma alloc_text(PAGE, NtfsResolveVolumeAndRaiseErrorSpecial)
#endif

//
//  Internal support routines
//

LONG
NtfsProcessExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    UNREFERENCED_PARAMETER( ExceptionPointer );

    ASSERT( !NtfsBreakOnCorrupt ||
            (ExceptionPointer->ExceptionRecord->ExceptionCode != STATUS_LOG_FILE_FULL) );

#ifndef LFS_CLUSTER_CHECK
    ASSERT( !NtfsBreakOnCorrupt ||
            NT_SUCCESS( ExceptionPointer->ExceptionRecord->ExceptionCode ));
#endif

    return EXCEPTION_EXECUTE_HANDLER;
}

ULONG
NtfsRaiseStatusFunction (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is only required by the NtfsDecodeFileObject macro.  It is
    a function wrapper around NtfsRaiseStatus.

Arguments:

    Status - Status to raise

Return Value:

    0 - but no one will see it!

--*/

{
    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    return 0;
}


VOID
NtfsCorruptionBreakPointTest (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG ExceptionCode
    )
/*++

Routine Description:

    The corruption breakpoint routine. Breakin when NtfsBreakOnCorrupt is set
    and we encounter corruption. This is currently active only on checked builds.

Arguments:

    ExceptionCode - the exception that occured

Return Value:

    none

--*/

{
    if (NtfsBreakOnCorrupt &&
        ((ExceptionCode == STATUS_FILE_CORRUPT_ERROR) ||
         (ExceptionCode == STATUS_DISK_CORRUPT_ERROR))) {

        if (*KdDebuggerEnabled) {
            DbgPrint("*******************************************\n");
            DbgPrint("NTFS detected corruption on your volume\n");
            DbgPrint("IrpContext=0x%08x, VCB=0x%08x\n",IrpContext,IrpContext->Vcb);
            DbgPrint("Send email to NTFSDEV\n");
            DbgPrint("*******************************************\n");
            DbgBreakPoint();

            while (NtfsPageInAddress) {

                volatile CHAR test;

                if (NtfsMapOffset != -1) {

                    PBCB Bcb;
                    PVOID Buffer;

                    if ((NtfsMapOffset > 0) && (NtfsMapOffset < ((PSCB)(IrpContext->Vcb->LogFileObject->FsContext))->Header.FileSize.QuadPart)) {
                        CcMapData( IrpContext->Vcb->LogFileObject, (PLARGE_INTEGER)&NtfsMapOffset, PAGE_SIZE, TRUE, &Bcb, &Buffer );
                    } else {
                        KdPrint(( "Offset out of range to be mapped: 0x%I64x logfilesize: %I64x\n", NtfsMapOffset, ((PSCB)(IrpContext->Vcb->LogFileObject->FsContext))->Header.FileSize.QuadPart ));
                    }

                }

                test = *NtfsPageInAddress;
                DbgBreakPoint();
            }
        }
    }
}


VOID
NtfsRaiseStatus (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    )

{
    //
    //  If the caller is declaring corruption, then let's mark the
    //  the volume corrupt appropriately, and maybe generate a popup.
    //

    if ((Status == STATUS_DISK_CORRUPT_ERROR) ||
        (Status == STATUS_FILE_CORRUPT_ERROR) ||
        (Status == STATUS_EA_CORRUPT_ERROR)) {

        //
        //  Let's not bugcheck just because of logfile corruption during
        //  restart when mounting volume.  Just mark the volume dirty.
        //  Autochk should be able to fix it.
        //

        if ((IrpContext->Vcb != NULL) &&
            (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
            (IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) &&
            FlagOn( IrpContext->Vcb->Vpb->RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION ) &&
            !FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

            NtfsBugCheck( (ULONG_PTR)IrpContext, (ULONG_PTR)Status, 0 );
        }

        NtfsPostVcbIsCorrupt( IrpContext, Status, FileReference, Fcb );
    }

    //
    //  Set a flag to indicate that we raised this status code and store
    //  it in the IrpContext.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS );

    if (NT_SUCCESS( IrpContext->ExceptionStatus )) {

        //
        //  If this is a paging io request and we got a Quota Exceeded error
        //  then translate the status to FILE_LOCK_CONFLICT so that this
        //  is a retryable condition in the write path.
        //

        if ((Status == STATUS_QUOTA_EXCEEDED) &&
            (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (IrpContext->OriginatingIrp != NULL) &&
            FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO )) {

            Status = STATUS_FILE_LOCK_CONFLICT;
        }

        IrpContext->ExceptionStatus = Status;
    }

    //
    //  Now finally raise the status, and make sure we do not come back.
    //

    ExRaiseStatus( IrpContext->ExceptionStatus );
}


LONG
NtfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It inserts the status
    into the IrpContext and either indicates that we should handle
    the exception or bug check the system.

Arguments:

    ExceptionPointer - Supplies the exception record to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );

    DebugTrace( 0, DEBUG_TRACE_UNWIND, ("NtfsExceptionFilter %X\n", ExceptionCode) );

    //
    //  Check if this status is the status we are watching for.
    //

    if (NtfsTestFilter && (NtfsTestStatusCode == ExceptionCode)) {

        NtfsTestStatusProc();
    }

#if (DBG || defined( NTFS_FREE_ASSERTS ))
    //
    //  We should not raise insufficient resources during paging file reads
    //

    if (ARGUMENT_PRESENT( IrpContext ) && (IrpContext->OriginatingIrp != NULL)) {

        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );
        PSCB Scb = NULL;

        if (IrpSp && (IrpSp->FileObject != NULL)) {
            Scb = (PSCB)IrpSp->FileObject->FsContext;
        }

        ASSERT( (IrpContext->MajorFunction != IRP_MJ_READ) ||
                (ExceptionCode != STATUS_INSUFFICIENT_RESOURCES) ||
                (Scb == NULL) ||
                (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) );
    }
#endif

    //
    //  If the exception is an in page error, then get the real I/O error code
    //  from the exception record
    //

    if ((ExceptionCode == STATUS_IN_PAGE_ERROR) &&
        (ExceptionPointer->ExceptionRecord->NumberParameters >= 3)) {

        ExceptionCode = (NTSTATUS) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];

        //
        //  If we got FILE_LOCK_CONFLICT from a paging request then change it
        //  to STATUS_CANT_WAIT.  This means that we couldn't wait for a
        //  reserved buffer or some other retryable condition.  In the write
        //  case the correct error is already in the IrpContext.  The read
        //  case doesn't pass the error back via the top-level irp context
        //  however.
        //

        if (ExceptionCode == STATUS_FILE_LOCK_CONFLICT) {

            ExceptionCode = STATUS_CANT_WAIT;
        }
    }

    //
    //  If there is not an irp context, we must have had insufficient resources
    //

    if (!ARGUMENT_PRESENT(IrpContext)) {

        //
        //  Check whether this is a fatal error and bug check if so.
        //  Typically the only error is insufficient resources but
        //  it is possible that pool has been corrupted.
        //

        if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

            NtfsBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                          (ULONG_PTR)ExceptionPointer->ContextRecord,
                          (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

        return EXCEPTION_EXECUTE_HANDLER;
    }

    //
    //  Assert if we have caught an exception beyond a point at which we assumed we
    //  wouldn't raise anymore
    //  

    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_NO_FAILURES_EXPECTED ) );

    NtfsCorruptionBreakPointTest( IrpContext, ExceptionCode );

    //
    //  When processing any exceptions we always can wait.  Remember the
    //  current state of the wait flag so we can restore while processing
    //  the exception.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
    }

    SetFlag(IrpContext->State, IRP_CONTEXT_STATE_WAIT);

    //
    //  If someone got STATUS_LOG_FILE_FULL or STATUS_CANT_WAIT, let's
    //  handle that.  Note any other error that also happens will
    //  probably not go away and will just reoccur.  If it does go
    //  away, that's ok too.
    //

    if (IrpContext->TopLevelIrpContext == IrpContext) {

        if ((IrpContext->ExceptionStatus == STATUS_LOG_FILE_FULL) ||
            (IrpContext->ExceptionStatus == STATUS_CANT_WAIT)) {

            ExceptionCode = IrpContext->ExceptionStatus;
        }

    }

    //
    //  If we didn't raise this status code then we need to check if
    //  we should handle this exception.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS )) {

#ifdef PERF_STATS
        if (ExceptionCode == STATUS_LOG_FILE_FULL) {
            IrpContext->LogFullReason = LF_LOG_SPACE;
        }
#endif

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {

            //
            //  If we got an allocation failure doing paging Io then convert
            //  this to FILE_LOCK_CONFLICT.
            //

            if ((ExceptionCode == STATUS_QUOTA_EXCEEDED) &&
                (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                (IrpContext->OriginatingIrp != NULL) &&
                FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO )) {

                ExceptionCode = STATUS_FILE_LOCK_CONFLICT;
            }

            IrpContext->ExceptionStatus = ExceptionCode;

        } else {

            NtfsBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                          (ULONG_PTR)ExceptionPointer->ContextRecord,
                          (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( ExceptionCode == IrpContext->ExceptionStatus );
        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

#ifdef LFS_CLUSTER_CHECK
    ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DISMOUNT_LOG_FLUSH ) ||
            ((IrpContext->ExceptionStatus != STATUS_NO_SUCH_DEVICE) &&
             (IrpContext->ExceptionStatus != STATUS_DEVICE_BUSY) &&
             (IrpContext->ExceptionStatus != STATUS_DEVICE_OFF_LINE) ));
#endif

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS );

    //
    //  If the exception code is log file full, then remember the current
    //  RestartAreaLsn in the Vcb, so we can see if we are the ones to flush
    //  the log file later.  Note, this does not have to be synchronized,
    //  because we are just using it to arbitrate who must do the flush, but
    //  eventually someone will anyway.
    //

    if (ExceptionCode == STATUS_LOG_FILE_FULL) {

        IrpContext->TopLevelIrpContext->LastRestartArea = IrpContext->Vcb->LastRestartArea;
        IrpContext->Vcb->LogFileFullCount += 1;
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
NtfsProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine process an exception.  It either completes the request
    with the saved exception status or it sends the request off to the Fsp

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PVCB Vcb;
    PIRP_CONTEXT PostIrpContext = NULL;
    BOOLEAN Retry = FALSE;
    PUSN_FCB ThisUsn, LastUsn;
    BOOLEAN ReleaseBitmap = FALSE;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_OPTIONAL_IRP( Irp );

    DebugTrace( 0, Dbg, ("NtfsProcessException\n") );

    //
    //  If there is not an irp context, we must have had insufficient resources
    //

    if (IrpContext == NULL) {

        NtfsCompleteRequest( NULL, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Get the real exception status from the Irp Context.
    //

    ExceptionCode = IrpContext->ExceptionStatus;

    //
    //  All errors which could possibly have started a transaction must go
    //  through here.  Abort the transaction.
    //

    //
    //  Increment the appropriate performance counters.
    //

    Vcb = IrpContext->Vcb;
    CollectExceptionStats( Vcb, ExceptionCode );

    try {

        //
        //  If this is an Mdl write request, then take care of the Mdl
        //  here so that things get cleaned up properly, and in the
        //  case of log file full we will just create a new Mdl.  By
        //  getting rid of this Mdl now, the pages will not be locked
        //  if we try to truncate the file while restoring snapshots.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
            (FlagOn( IrpContext->MinorFunction, IRP_MN_MDL | IRP_MN_COMPLETE ) == IRP_MN_MDL) &&
            (Irp->MdlAddress != NULL)) {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

            CcMdlWriteAbort( IrpSp->FileObject, Irp->MdlAddress );
            Irp->MdlAddress = NULL;
        }

        //
        //  On a failed mount this value will be NULL.  Don't perform the
        //  abort in that case or we will fail when looking at the Vcb
        //  in the Irp COntext.
        //

        if (Vcb != NULL) {

            //
            //  To make sure that we can access all of our streams correctly,
            //  we first restore all of the higher sizes before aborting the
            //  transaction.  Then we restore all of the lower sizes after
            //  the abort, so that all Scbs are finally restored.
            //

            NtfsRestoreScbSnapshots( IrpContext, TRUE );

            //
            //  If we modified the volume bitmap during this transaction we
            //  want to acquire it and hold it throughout the abort process.
            //  Otherwise this abort could constantly be setting the rescan
            //  bitmap flag at the same time as some interleaved transaction
            //  is performing bitmap operations and we will thrash performing
            //  bitmap scans.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP ) &&
                (IrpContext->TransactionId != 0)) {

                //
                //  Acquire the resource and remember we need to release it.
                //

                NtfsAcquireResourceExclusive( IrpContext, Vcb->BitmapScb, TRUE );

                //
                //  Restore the free cluster count in the Vcb.
                //

                Vcb->FreeClusters -= IrpContext->FreeClusterChange;

                ReleaseBitmap = TRUE;
            }

            //
            //  If we are aborting a transaction, then it is important to clear out the
            //  Usn reasons, so we do not try to write a Usn Journal record for
            //  somthing that did not happen!  Worse yet if we get a log file full
            //  we fail the abort, which is not allowed.
            //
            //  First, reset the bits in the Fcb, so we will not fail to allow posting
            //  and writing these bits later.  Note that all the reversible changes are
            //  done with the Fcb exclusive, and they are actually backed out anyway.
            //  All the nonreversible ones (only unnamed and named data overwrite) are
            //  forced out first anyway before the data is actually modified.
            //

            ThisUsn = &IrpContext->Usn;
            do {

                PFCB UsnFcb;

                if (ThisUsn->CurrentUsnFcb != NULL) {

                    UsnFcb = ThisUsn->CurrentUsnFcb;

                    NtfsLockFcb( IrpContext, UsnFcb );

                    //
                    //  We may hold nothing here (write path) so we have to retest for the usn
                    //  after locking it down in case of the deleteusnjournal worker
                    //

                    if (UsnFcb->FcbUsnRecord != NULL) {

                        //
                        //  If any rename flags are part of the new reasons then
                        //  make sure to look the name up again.
                        //

                        if (FlagOn( ThisUsn->NewReasons,
                                    USN_REASON_RENAME_NEW_NAME | USN_REASON_RENAME_OLD_NAME )) {

                            ClearFlag( UsnFcb->FcbState, FCB_STATE_VALID_USN_NAME );
                        }

                        //
                        //  Now restore the reason and source info fields.
                        //

                        ClearFlag( UsnFcb->FcbUsnRecord->UsnRecord.Reason,
                                   ThisUsn->NewReasons );
                        if (UsnFcb->FcbUsnRecord->UsnRecord.Reason == 0) {

                            UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo = 0;

                        } else {

                            SetFlag( UsnFcb->FcbUsnRecord->UsnRecord.SourceInfo,
                                     ThisUsn->RemovedSourceInfo );
                        }

                        //
                        //  Restore the old fcb state - if we attempted to grow std info
                        //  

                        if (FlagOn( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_FCB_STATE )) {

                            UsnFcb->FcbState = ThisUsn->OldFcbState;
                            ClearFlag( ThisUsn->UsnFcbFlags, USN_FCB_FLAG_NEW_FCB_STATE );
                        }
                    }

                    NtfsUnlockFcb( IrpContext, UsnFcb );

                    //
                    //  Zero out the structure.
                    //

                    ThisUsn->CurrentUsnFcb = NULL;
                    ThisUsn->NewReasons = 0;
                    ThisUsn->RemovedSourceInfo = 0;
                    ThisUsn->UsnFcbFlags = 0;

                    if (ThisUsn != &IrpContext->Usn) {

                        LastUsn->NextUsnFcb = ThisUsn->NextUsnFcb;
                        NtfsFreePool( ThisUsn );
                        ThisUsn = LastUsn;
                    }
                }

                if (ThisUsn->NextUsnFcb == NULL) {
                    break;
                }

                LastUsn = ThisUsn;
                ThisUsn = ThisUsn->NextUsnFcb;

            } while (TRUE);

            //
            //  Only abort the transaction if the volume is still mounted.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                NtfsAbortTransaction( IrpContext, Vcb, NULL );
            }

            if (ReleaseBitmap) {

                NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
                ReleaseBitmap = FALSE;
            }

            NtfsRestoreScbSnapshots( IrpContext, FALSE );

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            SetFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_ENABLED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );

            //
            //  It is a rare path where the user is extending a volume and has hit
            //  an exception.  In that case we need to roll back the total clusters
            //  in the Vcb.  We detect this case is possible by comparing the
            //  snapshot value for total clusters in the Vcb.
            //

            if (Vcb->TotalClusters != Vcb->PreviousTotalClusters) {

                //
                //  Someone is changing this value but is it us.
                //

                if ((Vcb->BitmapScb != NULL) &&
                    NtfsIsExclusiveScb( Vcb->BitmapScb )) {

                    Vcb->TotalClusters = Vcb->PreviousTotalClusters;
                }
            }
        }

    //
    //  Exceptions at this point are pretty bad, we failed to undo everything.
    //

    } except(NtfsProcessExceptionFilter( GetExceptionInformation() )) {

        PSCB_SNAPSHOT ScbSnapshot;
        PSCB NextScb;
        PTRANSACTION_ENTRY TransactionEntry;

        //
        //  Update counter
        //

        NtfsFailedAborts += 1;

        //
        //  If we get an exception doing this then things are in really bad
        //  shape but we still don't want to bugcheck the system so we
        //  need to protect ourselves
        //

        try {

            NtfsPostVcbIsCorrupt( IrpContext, 0, NULL, NULL );

        } except(NtfsProcessExceptionFilter( GetExceptionInformation() )) {

            NOTHING;
        }

        if (ReleaseBitmap) {

            //
            //  Since we had an unexpected failure and we know that
            //  we have modified the bitmap we need to do a complete
            //  scan to accurately know the free cluster count.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS );
            NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
            ReleaseBitmap = FALSE;
        }

        //
        //  We have taken all the steps possible to cleanup the current
        //  transaction and it has failed.  Any of the Scb's involved in
        //  this transaction could now be out of ssync with the on-disk
        //  structures.  We can't go to disk to restore this so we will
        //  clean up the in-memory structures as best we can so that the
        //  system won't crash.
        //
        //  We will go through the Scb snapshot list and knock down the
        //  sizes to the lower of the two values.  We will also truncate
        //  the Mcb to that allocation.  If this is a normal data stream
        //  we will actually empty the Mcb.
        //

        ScbSnapshot = &IrpContext->ScbSnapshot;


        //
        //  Loop to retore first the Scb data from the snapshot in the
        //  IrpContext, and then 0 or more additional snapshots linked
        //  to the IrpContext.
        //

        do {

            NextScb = ScbSnapshot->Scb;

            if (NextScb == NULL) {

                ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;
                continue;
            }

            //
            //  Unload all information from memory and force future references to resynch to disk
            //  for all regular files. For system files / paging files truncate all sizes
            //  and unload based on the snapshot
            //

            if (!FlagOn( NextScb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE | FCB_STATE_PAGING_FILE )) {

                ClearFlag( NextScb->ScbState, SCB_STATE_HEADER_INITIALIZED | SCB_STATE_FILE_SIZE_LOADED );
                NextScb->Header.AllocationSize.QuadPart =
                NextScb->Header.FileSize.QuadPart =
                NextScb->Header.ValidDataLength.QuadPart = 0;

                //
                //  Remove all of the mappings in the Mcb.
                //

                NtfsUnloadNtfsMcbRange( &NextScb->Mcb, (LONGLONG)0, MAXLONGLONG, FALSE, FALSE );

                //
                //  If there is any caching tear it down so that we reinit it with values off disk
                //

                if (NextScb->FileObject) {
                    NtfsDeleteInternalAttributeStream( NextScb, TRUE, FALSE );
                }

            } else {

                //
                //  Go through each of the sizes and use the lower value for system files.
                //

                if (ScbSnapshot->AllocationSize < NextScb->Header.AllocationSize.QuadPart) {

                    NextScb->Header.AllocationSize.QuadPart = ScbSnapshot->AllocationSize;
                }

                if (ScbSnapshot->FileSize < NextScb->Header.FileSize.QuadPart) {

                    NextScb->Header.FileSize.QuadPart = ScbSnapshot->FileSize;
                }

                if (ScbSnapshot->ValidDataLength < NextScb->Header.ValidDataLength.QuadPart) {

                    NextScb->Header.ValidDataLength.QuadPart = ScbSnapshot->ValidDataLength;
                }

                NtfsUnloadNtfsMcbRange( &NextScb->Mcb,
                                        Int64ShraMod32(NextScb->Header.AllocationSize.QuadPart, NextScb->Vcb->ClusterShift),
                                        MAXLONGLONG,
                                        TRUE,
                                        FALSE );

                //
                //  For the mft set the record allocation context size so that it
                //  will be reininitialized the next time its used
                //

                if (NextScb->Header.NodeTypeCode == NTFS_NTC_SCB_MFT) {

                    NextScb->ScbType.Mft.RecordAllocationContext.CurrentBitmapSize = MAXULONG;
                }
            }

            //
            //  Update the FastIoField.
            //

            NtfsAcquireFsrtlHeader( NextScb );
            NextScb->Header.IsFastIoPossible = FastIoIsNotPossible;
            NtfsReleaseFsrtlHeader( NextScb );

            ScbSnapshot = (PSCB_SNAPSHOT)ScbSnapshot->SnapshotLinks.Flink;

        } while (ScbSnapshot != &IrpContext->ScbSnapshot);

        //
        //  It is a rare path where the user is extending a volume and has hit
        //  an exception.  In that case we need to roll back the total clusters
        //  in the Vcb.  We detect this case is possible by comparing the
        //  snapshot value for total clusters in the Vcb.
        //

        if ((Vcb != NULL) && (Vcb->TotalClusters != Vcb->PreviousTotalClusters)) {

            //
            //  Someone is changing this value but is it us.
            //

            if ((Vcb->BitmapScb != NULL) &&
                NtfsIsExclusiveScb( Vcb->BitmapScb )) {

                Vcb->TotalClusters = Vcb->PreviousTotalClusters;
            }
        }

        //ASSERTMSG( "***Failed to abort transaction, volume is corrupt", FALSE );

        //
        //  If this is part of a transaction delete the transaction and then 
        //  clear the transaction Id in the IrpContext to make sure we don't
        //  try to write any log records in the complete request.
        //

        if (IrpContext->TransactionId) {

            NtfsAcquireExclusiveRestartTable( &Vcb->TransactionTable,
                                              TRUE );

            TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
                                &Vcb->TransactionTable,
                                IrpContext->TransactionId );

            //
            //  We may leak a little reservation here - that will be recoverved at
            //  clean checkpoints
            //

            NtfsFreeRestartTableIndex( &Vcb->TransactionTable,
                                       IrpContext->TransactionId );

            //
            //  Mark that there is no transaction for the irp and signal
            //  any waiters if there are no transactions left
            //

            if (Vcb->TransactionTable.Table->NumberAllocated == 0) {

                KeSetEvent( &Vcb->TransactionsDoneEvent, 0, FALSE );
            }

            NtfsReleaseRestartTable( &Vcb->TransactionTable );

            IrpContext->TransactionId = 0;
        }
    }

    //
    //  If this isn't the top-level request then make sure to pass the real
    //  error back to the top level.
    //

    if (IrpContext != IrpContext->TopLevelIrpContext) {

        //
        //  Make sure this error is returned to the top level guy.
        //  If the status is FILE_LOCK_CONFLICT then we are using this
        //  value to stop some lower level request.  Convert it to
        //  STATUS_CANT_WAIT so the top-level request will retry.
        //

        if (NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus )) {

            //
            //  Tracking where a recursive error occurs during a file rename 
            //  

            ASSERT( (IrpContext->TopLevelIrpContext->MajorFunction != IRP_MJ_SET_INFORMATION) ||
                    (IoGetCurrentIrpStackLocation( IrpContext->TopLevelIrpContext->OriginatingIrp )->Parameters.SetFile.FileInformationClass != FileRenameInformation) );

            if (ExceptionCode == STATUS_FILE_LOCK_CONFLICT) {

                IrpContext->TopLevelIrpContext->ExceptionStatus = STATUS_CANT_WAIT;

            } else {

                IrpContext->TopLevelIrpContext->ExceptionStatus = ExceptionCode;
            }
        }
    }

    //
    //  We want to look at the LOG_FILE_FULL or CANT_WAIT cases and consider
    //  if we want to post the request.  We only post requests at the top
    //  level.
    //

    if (ExceptionCode == STATUS_LOG_FILE_FULL ||
        ExceptionCode == STATUS_CANT_WAIT) {

        //
        //  If we are top level, we will either post it or retry.  Also, make
        //  sure we always take this path for close, because we should never delete
        //  his IrpContext.
        //

        if (NtfsIsTopLevelRequest( IrpContext ) || (IrpContext->MajorFunction == IRP_MJ_CLOSE)) {

            //
            //  See if we are supposed to post the request.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST )) {

                PostIrpContext = IrpContext;

            //
            //  Otherwise we will retry this request in the original thread.
            //

            } else {

                Retry = TRUE;
            }

        //
        //  Otherwise we will complete the request, see if there is any
        //  related processing to do.
        //

        } else {

            if (ExceptionCode == STATUS_LOG_FILE_FULL) {

                //
                //  Increment the unhandled logfile full count and restart area at this
                //  point for tracking with dummy checkpoints
                //  

                Vcb->UnhandledLogFileFullCount += 1;

                //
                //  Unsafe test of value before recording the current restart area
                //  if this is the first logfull. We'd prefer an extra comparison
                //  over an interlocked operation.
                //  

                if (Vcb->LastRestartAreaAtNonTopLevelLogFull.QuadPart == Li0.QuadPart) {
                    InterlockedCompareExchange64( &Vcb->LastRestartAreaAtNonTopLevelLogFull.QuadPart, 
                                                  Vcb->LastRestartArea.QuadPart, 
                                                  Li0.QuadPart );

                }

                //
                //  We are the top level Ntfs call.  If we are processing a
                //  LOG_FILE_FULL condition then there may be no one above us
                //  who can do the checkpoint.  Go ahead and fire off a dummy
                //  request.  Do an unsafe test on the flag since it won't hurt
                //  to generate an occasional additional request.
                //

                if ((IrpContext->TopLevelIrpContext == IrpContext) &&
                    !FlagOn( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED ) &&
                    !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ONLY_SYNCH_CHECKPOINT )) {

                    //
                    //  If this is the lazy writer then we will just set a flag
                    //  in the top level field to signal ourselves to perform
                    //  the clean checkpoint when the cache manager releases
                    //  the Scb.
                    //

                    if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_LAZY_WRITE ) &&
                        (NtfsGetTopLevelContext()->SavedTopLevelIrp == (PIRP) FSRTL_CACHE_TOP_LEVEL_IRP)) {

                        SetFlag( (ULONG_PTR) NtfsGetTopLevelContext()->SavedTopLevelIrp, 0x80000000 );

                    } else if (!FlagOn( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED )) {

                        //
                        //  Create a dummy IrpContext but protect this request with
                        //  a try-except to catch any allocation failures.
                        //

                        try {

                            PostIrpContext = NULL;
                            NtfsInitializeIrpContext( NULL, TRUE, &PostIrpContext );
                            PostIrpContext->Vcb = Vcb;
                            PostIrpContext->LastRestartArea = PostIrpContext->Vcb->LastRestartArea;

#ifdef PERF_STATS
                            PostIrpContext->LogFullReason = IrpContext->LogFullReason;
#endif

                            NtfsAcquireCheckpoint( IrpContext, Vcb );
                            if (!FlagOn( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED )) {
                                SetFlag( Vcb->CheckpointFlags, VCB_DUMMY_CHECKPOINT_POSTED );
                            } else {
                                NtfsCleanupIrpContext( PostIrpContext, FALSE );
                                PostIrpContext = NULL;
                            }
                            NtfsReleaseCheckpoint( IrpContext, Vcb );

                        } except( EXCEPTION_EXECUTE_HANDLER ) {

                            NOTHING;
                        }
                    }
                }
            }

            //
            //  If this is a paging write and we are not the top level
            //  request then we need to return STATUS_FILE_LOCk_CONFLICT
            //  to make MM happy (and keep the pages dirty) and to
            //  prevent this request from retrying the request.
            //

            ExceptionCode = STATUS_FILE_LOCK_CONFLICT;

        }
    }

    if (PostIrpContext) {

        NTSTATUS PostStatus;

        //
        //  Clear the current error code.
        //

        PostIrpContext->ExceptionStatus = 0;

        //
        //  We need a try-except in case the Lock buffer call fails.
        //

        try {

            PostStatus = NtfsPostRequest( PostIrpContext, PostIrpContext->OriginatingIrp );

            //
            //  If we posted the original request we don't have any
            //  completion work to do.
            //

            if (PostIrpContext == IrpContext) {

                Irp = NULL;
                IrpContext = NULL;
                ExceptionCode = PostStatus;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            //  If we don't have an error in the IrpContext then
            //  generate a generic IO error.  We can't use the
            //  original status code if either LOG_FILE_FULL or
            //  CANT_WAIT.  We would complete the Irp yet retry the
            //  request.
            //

            if (IrpContext == PostIrpContext) {

                if (PostIrpContext->ExceptionStatus == 0) {

                    if ((ExceptionCode == STATUS_LOG_FILE_FULL) ||
                        (ExceptionCode == STATUS_CANT_WAIT)) {

                        ExceptionCode = STATUS_UNEXPECTED_IO_ERROR;
                    }

                } else {

                    ExceptionCode = PostIrpContext->ExceptionStatus;
                }
            }
        }
    }

    //
    //  If this is a top level Ntfs request and we still have the Irp
    //  it means we will be retrying the request.  In that case
    //  mark the Irp Context so it doesn't go away.
    //

    if (Retry) {

        //
        //  Cleanup but don't delete the IrpContext.  Don't delete the Irp.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE );
        Irp = NULL;

        //
        //  Clear the status code in the IrpContext, because we'll be retrying.
        //

        IrpContext->ExceptionStatus = 0;

    //
    //  If this is a create then sometimes we want to complete the Irp.  Otherwise
    //  save the Irp.  Save the Irp by clearing it here.
    //

    } else if ((IrpContext != NULL) &&
               !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP ) &&
               FlagOn( IrpContext->State, IRP_CONTEXT_STATE_EFS_CREATE )) {

        Irp = NULL;
    }

    //
    //  If this is an Mdl write complete request which we are completing, 
    //  then take care of the Mdl here so that things get cleaned up properly. 
    //  Cc owns the mdl and needs to clean it up rather than i/o. For example 
    //  it may be unlocked already. Note: if there is still an irp there must
    //  still also be an irpcontext
    //

    if ((Irp != NULL) &&
        (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
        (FlagOn( IrpContext->MinorFunction, IRP_MN_MDL | IRP_MN_COMPLETE ) == (IRP_MN_MDL | IRP_MN_COMPLETE)) &&
        (Irp->MdlAddress != NULL)) {

        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

        CcMdlWriteAbort( IrpSp->FileObject, Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    NtfsCompleteRequest( IrpContext, Irp, ExceptionCode );
    return ExceptionCode;
}


VOID
NtfsCompleteRequest (
    IN OUT PIRP_CONTEXT IrpContext OPTIONAL,
    IN OUT PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes an IRP and deallocates the IrpContext

Arguments:

    IrpContext - Supplies the IrpContext being completed

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    //
    //  If we have an Irp Context then unpin all of the repinned bcbs
    //  we might have collected, and delete the Irp context.  Delete Irp
    //  Context will zero out our pointer for us.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        ASSERT_IRP_CONTEXT( IrpContext );

        //
        //  If we have posted any Usn journal changes, then they better be written,
        //  because commit is not supposed to fail for log file full.
        //

        ASSERT( (IrpContext->Usn.NewReasons == 0) &&
                (IrpContext->Usn.RemovedSourceInfo == 0) );

        if (IrpContext->TransactionId != 0) {
            NtfsCommitCurrentTransaction( IrpContext );
        }

        //
        //  Always store the status in the top level Irp Context unless
        //  there is already an error code.
        //

        if ((IrpContext != IrpContext->TopLevelIrpContext) &&
            NT_SUCCESS( IrpContext->TopLevelIrpContext->ExceptionStatus )) {

            IrpContext->TopLevelIrpContext->ExceptionStatus = Status;
        }

        NtfsCleanupIrpContext( IrpContext, TRUE );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
        PSCB Scb = NULL;

        if (IrpSp->FileObject) {
            Scb = (PSCB) IrpSp->FileObject->FsContext;
        }

        ASSERT_IRP( Irp );

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

#ifdef NTFS_RWC_DEBUG
        ASSERT( (Status != STATUS_FILE_LOCK_CONFLICT) ||
                (IrpSp->MajorFunction != IRP_MJ_READ) ||
                !FlagOn( Irp->Flags, IRP_PAGING_IO ));
#endif

        //
        //  Update counter for any failed paging file reads or writes
        //

        if (((IrpSp->MajorFunction == IRP_MJ_READ) ||
             (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&

            (Status == STATUS_INSUFFICIENT_RESOURCES) &&

            (Scb != NULL) &&

            FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

            ASSERTMSG( "NTFS: Failed pagingfile read for insufficient resources\n", FALSE );

            NtfsFailedPagingFileOps++;
        }

        //
        //  Update counter for any failed paging reads
        //

        if ((IrpSp->MajorFunction == IRP_MJ_READ) &&
            (Status == STATUS_INSUFFICIENT_RESOURCES) &&
            FlagOn( Irp->Flags, IRP_PAGING_IO )) {

            NtfsFailedPagingReads++;
        }

        ASSERT( (IrpSp->MajorFunction != IRP_MJ_READ) ||
                (Status != STATUS_INSUFFICIENT_RESOURCES) ||
                (Scb == NULL) ||
                (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) );

        //
        //  We should never return STATUS_CANT_WAIT on a create.
        //

        ASSERT( (Status != STATUS_CANT_WAIT ) ||
                (IrpSp->MajorFunction != IRP_MJ_CREATE) );

#ifdef LFS_CLUSTER_CHECK

      ASSERT( (IrpSp->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
              (IrpSp->MinorFunction != IRP_MN_USER_FS_REQUEST) ||
              (IrpSp->Parameters.FileSystemControl.FsControlCode != FSCTL_DISMOUNT_VOLUME) ||
              ((Status != STATUS_NO_SUCH_DEVICE) &&
               (Status != STATUS_DEVICE_BUSY) &&
               (Status != STATUS_DEVICE_OFF_LINE)) );
#endif
        //
        //  Check if this status is the status we are watching for.
        //

        if (NtfsTestStatus && (NtfsTestStatusCode == Status)) {

            NtfsTestStatusProc();
        }

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
    }

    return;
}


BOOLEAN
NtfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route

--*/

{
    PSCB Scb;
    PFCB Fcb;

    LARGE_INTEGER LargeLength;
    ULONG Extend, Overwrite;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( IoStatus );
    UNREFERENCED_PARAMETER( Wait );

    PAGED_CODE();

#ifdef NTFS_NO_FASTIO

    UNREFERENCED_PARAMETER( FileObject );
    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( CheckForReadOperation );

    return FALSE;

#endif

    //
    //  Decode the file object to get our fcb, the only one we want
    //  to deal with is a UserFileOpen
    //

#ifdef  COMPRESS_ON_WIRE
    if (((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) ||
        ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) && (Scb->Header.FileObjectC == NULL))) {

        return FALSE;
    }
#else
    if ((Scb = NtfsFastDecodeUserFileOpen( FileObject )) == NULL) {

        return FALSE;
    }
#endif

    LargeLength = RtlConvertUlongToLargeInteger( Length );

    //
    //  Based on whether this is a read or write operation we call
    //  fsrtl check for read/write
    //

    if (CheckForReadOperation) {

        if ((Scb->ScbType.Data.FileLock == NULL) || 
            FsRtlFastCheckLockForRead( Scb->ScbType.Data.FileLock,
                                       FileOffset,
                                       &LargeLength,
                                       LockKey,
                                       FileObject,
                                       PsGetCurrentProcess() )) {

            return TRUE;
        }

    } else {

        ULONG Reason = 0;

        Overwrite = (FileOffset->QuadPart < Scb->Header.FileSize.QuadPart);
        Extend = ((FileOffset->QuadPart + Length) > Scb->Header.FileSize.QuadPart);

        if ((Scb->ScbType.Data.FileLock == NULL) || 
            FsRtlFastCheckLockForWrite( Scb->ScbType.Data.FileLock,
                                        FileOffset,
                                        &LargeLength,
                                        LockKey,
                                        FileObject,
                                        PsGetCurrentProcess() )) {

            //
            //  Make sure we don't have to post a Usn change.
            //

            Fcb = Scb->Fcb;
            NtfsLockFcb( NULL, Fcb );
            if (Fcb->FcbUsnRecord != NULL) {
                Reason = Fcb->FcbUsnRecord->UsnRecord.Reason;
            }
            NtfsUnlockFcb( NULL, Fcb );

            if (((Scb->AttributeName.Length != 0) ?
                ((!Overwrite || FlagOn(Reason, USN_REASON_NAMED_DATA_OVERWRITE)) &&
                 (!Extend || FlagOn(Reason, USN_REASON_NAMED_DATA_EXTEND))) :
                ((!Overwrite || FlagOn(Reason, USN_REASON_DATA_OVERWRITE)) &&
                 (!Extend || FlagOn(Reason, USN_REASON_DATA_EXTEND)))) &&

              //
              //  If the file is compressed, reserve clusters for it.
              //

              ((Scb->CompressionUnit == 0) ||
               NtfsReserveClusters( NULL, Scb, FileOffset->QuadPart, Length))) {

                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOLEAN
NtfsFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN _ TRUE if the operation is successful and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    if (Wait) {
        SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    } else {
        ClearFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    }

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    FsRtlEnterFileSystem();

    try {

        switch (TypeOfOpen) {

        case UserFileOpen:
        case UserDirectoryOpen:
        case StreamFileOpen:

            if (ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

                FcbAcquired = TRUE;

                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                    FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    leave;
                }

            } else {

                leave;
            }

            NtfsFillBasicInfo( Buffer, Scb );
            Results = TRUE;

            IoStatus->Information = sizeof(FILE_BASIC_INFORMATION);

            IoStatus->Status = STATUS_SUCCESS;

            break;

        default:

            NOTHING;
        }

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  Return to our caller
    //

    return Results;
    UNREFERENCED_PARAMETER( DeviceObject );
}


BOOLEAN
NtfsFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN _ TRUE if the operation is successful and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN FsRtlHeaderLocked = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    if (Wait) {
        SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    } else {
        ClearFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    }

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    FsRtlEnterFileSystem();

    try {

        switch (TypeOfOpen) {

        case UserFileOpen:
        case UserDirectoryOpen:
        case StreamFileOpen:

            if (Scb->Header.PagingIoResource != NULL) {
                ExAcquireResourceSharedLite( Scb->Header.PagingIoResource, TRUE );
            }

            FsRtlLockFsRtlHeader( &Scb->Header );
            FsRtlHeaderLocked = TRUE;

            if (ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

                FcbAcquired = TRUE;

                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                    FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    leave;
                }

            } else {

                leave;
            }

            //
            //  Fill in the standard information fields.  If the
            //  Scb is not initialized then take the long route
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED) &&
                (Scb->AttributeTypeCode != $INDEX_ALLOCATION)) {

                NOTHING;

            } else {

                NtfsFillStandardInfo( Buffer, Scb, Ccb );

                IoStatus->Information = sizeof(FILE_STANDARD_INFORMATION);

                IoStatus->Status = STATUS_SUCCESS;

                Results = TRUE;
            }

            break;

        default:

            NOTHING;
        }

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Resource ); }

        if (FsRtlHeaderLocked) {
            FsRtlUnlockFsRtlHeader( &Scb->Header );
            if (Scb->Header.PagingIoResource != NULL) {
                ExReleaseResourceLite( Scb->Header.PagingIoResource );
            }
        }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
    UNREFERENCED_PARAMETER( DeviceObject );
}


BOOLEAN
NtfsFastQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query network open call.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN _ TRUE if the operation is successful and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    if (Wait) {
        SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    } else {
        ClearFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);
    }

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    FsRtlEnterFileSystem();

    try {

        switch (TypeOfOpen) {

        case UserFileOpen:
        case UserDirectoryOpen:
        case StreamFileOpen:

            if (ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

                FcbAcquired = TRUE;

                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                    FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ) ||
                    (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED) &&
                     (Scb->AttributeTypeCode != $INDEX_ALLOCATION))) {

                    leave;
                }

            } else {

                leave;
            }

            NtfsFillNetworkOpenInfo( Buffer, Scb );
            IoStatus->Information = sizeof(FILE_NETWORK_OPEN_INFORMATION);

            IoStatus->Status = STATUS_SUCCESS;

            Results = TRUE;

            break;

        default:

            NOTHING;
        }

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
    UNREFERENCED_PARAMETER( DeviceObject );
}


VOID
NtfsFastIoQueryCompressionInfo (
    IN PFILE_OBJECT FileObject,
    OUT PFILE_COMPRESSION_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine is a fast call for returning the comprssion information
    for a file.  It assumes that the caller has an exception handler and
    will treat exceptions as an error.  Therefore, this routine only uses
    a finally clause to cleanup any resources, and it does not worry about
    returning errors in the IoStatus.

Arguments:

    FileObject - FileObject for the file on which the compressed information
        is desired.

    Buffer - Buffer to receive the compressed data information (as defined
        in ntioapi.h)

    IoStatus - Returns STATUS_SUCCESS and the size of the information being
        returned.

Return Value:

    None.

--*/

{
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    BOOLEAN ScbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);

    //
    //  Assume success (otherwise caller should see the exception)
    //

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = sizeof(FILE_COMPRESSION_INFORMATION);

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE);

    if (TypeOfOpen == UnopenedFileObject) {

        ExRaiseStatus( STATUS_INVALID_PARAMETER );
    }

    FsRtlEnterFileSystem();

    try {

        NtfsAcquireSharedScb( &IrpContext, Scb );
        ScbAcquired = TRUE;

        //
        //  Now return the compressed data information.
        //

        Buffer->CompressedFileSize.QuadPart = Scb->TotalAllocated;
        Buffer->CompressionFormat = (USHORT)(Scb->AttributeFlags & ATTRIBUTE_FLAG_COMPRESSION_MASK);
        if (Buffer->CompressionFormat != 0) {
            Buffer->CompressionFormat += 1;
        }
        Buffer->CompressionUnitShift = (UCHAR)(Scb->CompressionUnitShift + Vcb->ClusterShift);
        Buffer->ChunkShift = NTFS_CHUNK_SHIFT;
        Buffer->ClusterShift = (UCHAR)Vcb->ClusterShift;
        Buffer->Reserved[0] = Buffer->Reserved[1] = Buffer->Reserved[2] = 0;

    } finally {

        if (ScbAcquired) {NtfsReleaseScb( &IrpContext, Scb );}
        FsRtlExitFileSystem();
    }
}


VOID
NtfsFastIoQueryCompressedSize (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    OUT PULONG CompressedSize
    )

/*++

Routine Description:

    This routine is a fast call for returning the the size of a specified
    compression unit.  It assumes that the caller has an exception handler and
    will treat exceptions as an error.  Therefore, this routine does not even
    have a finally clause, since it does not acquire any resources directly.

Arguments:

    FileObject - FileObject for the file on which the compressed information
        is desired.

    FileOffset - FileOffset for a compression unit for which the allocated size
        is desired.

    CompressedSize - Returns the allocated size of the compression unit.

Return Value:

    None.

--*/

{
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    VCN Vcn;
    LCN Lcn;
    LONGLONG SizeInBytes;
    LONGLONG ClusterCount = 0;

    PAGED_CODE();

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = NTFS_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);
    SetFlag(IrpContext.State, IRP_CONTEXT_STATE_WAIT);

    //
    //  Determine the type of open for the input file object.  The callee really
    //  ignores the irp context for us.
    //

    TypeOfOpen = NtfsDecodeFileObject( &IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE);

    IrpContext.Vcb = Vcb;

    ASSERT(Scb->CompressionUnit != 0);
    ASSERT((FileOffset->QuadPart & (Scb->CompressionUnit - 1)) == 0);

    //
    //  Calculate the Vcn the caller wants, and initialize our output.
    //

    Vcn = LlClustersFromBytes( Vcb, FileOffset->QuadPart );
    *CompressedSize = 0;

    //
    //  Loop as long as we are looking up allocated Vcns.
    //

    while (NtfsLookupAllocation(&IrpContext, Scb, Vcn, &Lcn, &ClusterCount, NULL, NULL)) {

        SizeInBytes = LlBytesFromClusters( Vcb, ClusterCount );

        //
        //  If this allocated run goes beyond the end of the compresion unit, then
        //  we know it is fully allocated.
        //

        if ((SizeInBytes + *CompressedSize) > Scb->CompressionUnit) {
            *CompressedSize = Scb->CompressionUnit;
            break;
        }

        *CompressedSize += (ULONG)SizeInBytes;
        Vcn += ClusterCount;
    }
}


VOID
NtfsRaiseInformationHardError (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    )

/*++

Routine Description:

    This routine is used to generate a popup in the event a corrupt file
    or disk is encountered.  The main purpose of the routine is to find
    a name to pass to the popup package.  If there is no Fcb we will take
    the volume name out of the Vcb.  If the Fcb has an Lcb in its Lcb list,
    we will construct the name by walking backwards through the Lcb's.
    If the Fcb has no Lcb but represents a system file, we will return
    a default system string.  If the Fcb represents a user file, but we
    have no Lcb, we will use the name in the file object for the current
    request.

Arguments:

    Status - Error status.

    FileReference - File reference being accessed in Mft when error occurred.

    Fcb - If specified, this is the Fcb being used when the error was encountered.

Return Value:

    None.

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Entry = NULL;

    PKTHREAD Thread;
    UNICODE_STRING Name;
    ULONG NameLength = 0;

    PFILE_OBJECT FileObject;

    WCHAR *NewBuffer = NULL;

    PIRP Irp = NULL;
    PIO_STACK_LOCATION IrpSp;

    PUNICODE_STRING FileName = NULL;
    PUNICODE_STRING RelatedFileName = NULL;

    BOOLEAN UseLcb = FALSE;
    PVOLUME_ERROR_PACKET VolumeErrorPacket = NULL;
    ULONG OldCount;

    //
    //  Return if there is no originating Irp, for example when originating
    //  from NtfsPerformHotFix or if the originating irp type doesn't match an irp
    //

    if ((IrpContext->OriginatingIrp == NULL) ||
        (IrpContext->OriginatingIrp->Type != IO_TYPE_IRP)) {
        return;
    }

    Irp = IrpContext->OriginatingIrp;
    IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );
    FileObject = IrpSp->FileObject;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the Fcb isn't specified and the file reference is, then
        //  try to get the Fcb from the Fcb table.
        //

        if (!ARGUMENT_PRESENT( Fcb )
            && ARGUMENT_PRESENT( FileReference )) {

            Key.FileReference = *FileReference;

            NtfsAcquireFcbTable( IrpContext, IrpContext->Vcb );
            Entry = RtlLookupElementGenericTable( &IrpContext->Vcb->FcbTable,
                                                  &Key );
            NtfsReleaseFcbTable( IrpContext, IrpContext->Vcb );

            if (Entry != NULL) {

                Fcb = Entry->Fcb;
            }
        }

        if (Irp == NULL ||

            IoIsSystemThread( IrpContext->OriginatingIrp->Tail.Overlay.Thread )) {
            Thread = NULL;

        } else {

            Thread = (PKTHREAD)IrpContext->OriginatingIrp->Tail.Overlay.Thread;
        }

        //
        //  If there is no fcb  assume the error occurred in a system file.
        //  if its fileref is outside of this range default to $MFT
        //

        if (!ARGUMENT_PRESENT( Fcb )) {

            if (ARGUMENT_PRESENT( FileReference )) {
                if (NtfsSegmentNumber( FileReference ) <= UPCASE_TABLE_NUMBER) {
                    FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[NtfsSegmentNumber( FileReference )]));
                } else  {
                    FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[0]));
                }
            }

        //
        //  If the name has an Lcb, we will contruct a name with a chain of Lcb's.
        //

        } else if (!IsListEmpty( &Fcb->LcbQueue )) {

            UseLcb = TRUE;

        //
        //  Check if this is a system file.
        //

        } else if (NtfsSegmentNumber( &Fcb->FileReference ) < FIRST_USER_FILE_NUMBER) {


            if (NtfsSegmentNumber( &Fcb->FileReference ) <= UPCASE_TABLE_NUMBER) {
                FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[NtfsSegmentNumber( &Fcb->FileReference )]));
            } else  {
                FileName = (PUNICODE_STRING)(&(NtfsSystemFiles[0]));
            }

        //
        //  In this case we contruct a name out of the file objects in the
        //  Originating Irp.  If there is no file object or file object buffer
        //  we generate an unknown file message.
        //

        } else if (FileObject == NULL
                   || (IrpContext->MajorFunction == IRP_MJ_CREATE
                       && FlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID ))
                   || (FileObject->FileName.Length == 0
                       && (FileObject->RelatedFileObject == NULL
                           || IrpContext->MajorFunction != IRP_MJ_CREATE))) {

            FileName = (PUNICODE_STRING)&(NtfsUnknownFile);
        //
        //  If there is a valid name in the file object we use that.
        //

        } else if ((FileObject->FileName.Length != 0) &&
                   (FileObject->FileName.Buffer[0] == L'\\')) {

            FileName = &(FileObject->FileName);
        //
        //  We have to construct the name from filename + related fileobject.
        //

        } else {

            if (FileObject->FileName.Length != 0) {
                FileName = &(FileObject->FileName);
            }

            if ((FileObject->RelatedFileObject) &&
                (FileObject->RelatedFileObject->FileName.Length != 0)) {
                RelatedFileName = &(FileObject->RelatedFileObject->FileName);
            }
        }

        if (FileName) {
            NameLength += FileName->Length;
        }

        if (RelatedFileName) {
            NameLength += RelatedFileName->Length;
        }

        if (UseLcb) {
            BOOLEAN LeadingBackslash;
            NameLength += NtfsLookupNameLengthViaLcb( Fcb, &LeadingBackslash );
        }

        //
        //  Either append what info we found or default to the volume label
        //

        if (NameLength > 0) {

            NewBuffer = NtfsAllocatePool(PagedPool, NameLength );
            Name.Buffer = NewBuffer;

            //
            //  For super long names truncate buffer size to 64k.
            //  RtlAppendUnicodeString handles the rest of the work
            //

            if (NameLength > 0xFFFF) {
                NameLength = 0xFFFF;
            }

            Name.MaximumLength = (USHORT) NameLength;
            Name.Length = 0;

            if (RelatedFileName) {
                RtlAppendUnicodeStringToString( &Name, RelatedFileName );
            }

            if (FileName) {
                RtlAppendUnicodeStringToString( &Name, FileName );
            }

            if (UseLcb) {
                NtfsFileNameViaLcb( Fcb, NewBuffer, NameLength, NameLength);
                Name.Length = (USHORT) NameLength;
            }

        } else {

            Name.Length = Name.MaximumLength = 0;
            Name.Buffer = NULL;
        }

        //
        //  Only allow 1 post to resolve the volume name to occur at a time
        //

        OldCount = InterlockedCompareExchange( &(NtfsData.VolumeNameLookupsInProgress), 1, 0 );
        if (OldCount == 0) {

            VolumeErrorPacket = NtfsAllocatePool( PagedPool, sizeof( VOLUME_ERROR_PACKET ) );
            VolumeErrorPacket->Status = Status;
            VolumeErrorPacket->Thread = Thread;
            RtlCopyMemory( &(VolumeErrorPacket->FileName), &Name, sizeof( UNICODE_STRING ) );

            //
            //  Reference the thread to keep it around during the resolveandpost
            //

            if (Thread) {
                ObReferenceObject( Thread );
            }

            //
            //  Now post to generate the popup. After posting ResolveVolume will free the newbuffer
            //

            NtfsPostSpecial( IrpContext, IrpContext->Vcb, NtfsResolveVolumeAndRaiseErrorSpecial, VolumeErrorPacket );
            NewBuffer = NULL;
            VolumeErrorPacket = NULL;

        } else {

            //
            //  Lets use what we have
            //

            IoRaiseInformationalHardError( Status, &Name, Thread );
        }

    } finally {

        //
        //  Cleanup any remaining buffers we still own
        //

        if (NewBuffer) {
            NtfsFreePool( NewBuffer );
        }

        if (VolumeErrorPacket) {

            if (VolumeErrorPacket->Thread) {
                ObDereferenceObject( VolumeErrorPacket->Thread );
            }
            NtfsFreePool( VolumeErrorPacket );
        }
    }

    return;
}


VOID
NtfsResolveVolumeAndRaiseErrorSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    Resolve Vcb's win32 devicename and raise an io hard error. This is done in
    a separate thread in order to have enough stack to re-enter the filesys if necc.
    Also because we may reenter. Starting from here means we own no resources other than
    having inc'ed the close count on the underlying vcb to prevent its going away

Arguments:

    IrpContext - IrpContext containing vcb we're interested in

    Context - String to append to volume win32 name


Return Value:

    None.

--*/

{
    UNICODE_STRING VolumeName;
    NTSTATUS Status;
    PVOLUME_ERROR_PACKET VolumeErrorPacket;
    UNICODE_STRING FullName;
    WCHAR *NewBuffer = NULL;
    ULONG NameLength;

    ASSERT( Context != NULL );
    ASSERT( IrpContext->Vcb->NodeTypeCode == NTFS_NTC_VCB );
    ASSERT( IrpContext->Vcb->Vpb->RealDevice != NULL );

    VolumeErrorPacket = (PVOLUME_ERROR_PACKET) Context;
    VolumeName.Length = 0;
    VolumeName.Buffer = NULL;

    try {

        //
        //  Only use the target device if we haven't stopped it and deref'ed it
        //

        Status = IoVolumeDeviceToDosName( IrpContext->Vcb->TargetDeviceObject, &VolumeName );
        ASSERT( STATUS_SUCCESS == Status );

        NameLength = VolumeName.Length + VolumeErrorPacket->FileName.Length;

        if (NameLength > 0) {
            NewBuffer = NtfsAllocatePool( PagedPool, NameLength );
            FullName.Buffer = NewBuffer;

            //
            //  For super long names truncate buffer size to 64k.
            //  RtlAppendUnicodeString handles the rest of the work
            //

            if (NameLength > 0xFFFF) {
                NameLength = 0xFFFF;
            }
            FullName.MaximumLength = (USHORT) NameLength;
            FullName.Length = 0;
            if (VolumeName.Length) {
                RtlCopyUnicodeString( &FullName, &VolumeName );
            }
            if (VolumeErrorPacket->FileName.Length) {
                RtlAppendUnicodeStringToString( &FullName, &(VolumeErrorPacket->FileName) );
            }
        } else {

            FullName.MaximumLength = FullName.Length = IrpContext->Vcb->Vpb->VolumeLabelLength;
            FullName.Buffer = (PWCHAR) IrpContext->Vcb->Vpb->VolumeLabel;
        }

        //
        //  Now generate a popup.
        //

        IoRaiseInformationalHardError( VolumeErrorPacket->Status, &FullName, VolumeErrorPacket->Thread );

    } finally {

        //
        //  Indicate we're done and other lookups can occur
        //

        InterlockedDecrement( &(NtfsData.VolumeNameLookupsInProgress) );

        //
        //  deref the thread
        //

        if (VolumeErrorPacket->Thread) {
            ObDereferenceObject( VolumeErrorPacket->Thread );
        }

        if (NewBuffer != NULL) {
            NtfsFreePool( NewBuffer );
        }

        if (VolumeName.Buffer != NULL) {
            NtfsFreePool( VolumeName.Buffer );
        }

        if (VolumeErrorPacket->FileName.Buffer != NULL) {
            NtfsFreePool( VolumeErrorPacket->FileName.Buffer );
        }

        if (Context != NULL) {
            NtfsFreePool( VolumeErrorPacket );
        }
    }
}




PTOP_LEVEL_CONTEXT
NtfsInitializeTopLevelIrp (
    IN PTOP_LEVEL_CONTEXT TopLevelContext,
    IN BOOLEAN ForceTopLevel,
    IN BOOLEAN SetTopLevel
    )

/*++

Routine Description:

    This routine is called to initializethe top level context to be used in the
    thread local storage. Ntfs always puts its own context in this location and restores
    the previous value on exit.  This routine will determine if this request is
    top level and top level ntfs.  It will return a pointer to the top level ntfs
    context which is to be stored in the local storage and associated with the
    IrpContext for this request.  The return value may be the existing stack location
    or a new one for a recursive request.  If we will use the new one we will initialize
    it but let our caller actually put it on the stack when the IrpContext is initialized.
    The ThreadIrpContext field in the TopLevelContext indicates if this is already on
    the stack.  A NULL value indicates that this is not on the stack yet.

Arguments:

    TopLevelContext - This is the local top level context for our caller.

    ForceTopLevel - Always use the input top level context.

    SetTopLevel - Only applies if the ForceTopLevel value is TRUE.  Indicates
        if we should make this look like the top level request.

Return Value:

    PTOP_LEVEL_CONTEXT - Pointer to the top level ntfs context for this thread.
        It may be the same as passed in by the caller.  In that case the fields
        will be initialized except it won't be stored on the stack and wont'
        have an IrpContext field.

--*/

{
    PTOP_LEVEL_CONTEXT CurrentTopLevelContext;
    ULONG_PTR StackBottom;
    ULONG_PTR StackTop;
    BOOLEAN TopLevelRequest = TRUE;
    BOOLEAN TopLevelNtfs = TRUE;

    BOOLEAN ValidCurrentTopLevel = FALSE;

    //
    //  Get the current value out of the thread local storage.  If it is a zero
    //  value or not a pointer to a valid ntfs top level context or a valid
    //  Fsrtl value then we are the top level request.
    //

    CurrentTopLevelContext = NtfsGetTopLevelContext();

    //
    //  Check if this is a valid Ntfs top level context.
    //

    IoGetStackLimits( &StackTop, &StackBottom);

    if (((ULONG_PTR) CurrentTopLevelContext <= StackBottom - sizeof( TOP_LEVEL_CONTEXT )) &&
        ((ULONG_PTR) CurrentTopLevelContext >= StackTop) &&
        !FlagOn( (ULONG_PTR) CurrentTopLevelContext, 0x3 ) &&
        (CurrentTopLevelContext->Ntfs == 0x5346544e)) {

        ValidCurrentTopLevel = TRUE;
    }

    //
    //  If we are to force this request to be top level then set the
    //  TopLevelRequest flag according to the SetTopLevel input.
    //

    if (ForceTopLevel) {

        TopLevelRequest = SetTopLevel;

    //
    //  If the value is NULL then we are top level everything.
    //

    } else if (CurrentTopLevelContext == NULL) {

        NOTHING;

    //
    //  If this has one of the Fsrtl magic numbers then we were called from
    //  either the fast io path or the mm paging io path.
    //

    } else if ((ULONG_PTR) CurrentTopLevelContext <= FSRTL_MAX_TOP_LEVEL_IRP_FLAG) {

        TopLevelRequest = FALSE;

    } else if (ValidCurrentTopLevel &&
               !FlagOn( CurrentTopLevelContext->ThreadIrpContext->Flags,
                        IRP_CONTEXT_FLAG_CALL_SELF )) {

        TopLevelRequest = FALSE;
        TopLevelNtfs = FALSE;

    //
    //  Handle the case where we have returned FILE_LOCK_CONFLICT to CC and
    //  want to perform a clean checkpoint when releasing the resource.
    //

    } else if ((ULONG_PTR) CurrentTopLevelContext == (0x80000000 | FSRTL_CACHE_TOP_LEVEL_IRP)) {

        TopLevelRequest = FALSE;
    }

    //
    //  If we are the top level ntfs then initialize the caller's structure.
    //  Leave the Ntfs signature and ThreadIrpContext NULL to indicate this is
    //  not in the stack yet.
    //

    if (TopLevelNtfs) {

        TopLevelContext->Ntfs = 0;
        TopLevelContext->SavedTopLevelIrp = (PIRP) CurrentTopLevelContext;
        TopLevelContext->ThreadIrpContext = NULL;
        TopLevelContext->TopLevelRequest = TopLevelRequest;

        if (ValidCurrentTopLevel) {

            TopLevelContext->VboBeingHotFixed = CurrentTopLevelContext->VboBeingHotFixed;
            TopLevelContext->ScbBeingHotFixed = CurrentTopLevelContext->ScbBeingHotFixed;
            TopLevelContext->ValidSavedTopLevel = TRUE;
            TopLevelContext->OverflowReadThread = CurrentTopLevelContext->OverflowReadThread;

        } else {

            TopLevelContext->VboBeingHotFixed = 0;
            TopLevelContext->ScbBeingHotFixed = NULL;
            TopLevelContext->ValidSavedTopLevel = FALSE;
            TopLevelContext->OverflowReadThread = FALSE;
        }

        return TopLevelContext;
    }

    return CurrentTopLevelContext;
}


//
//  Non-paged routines to set up and tear down Irps for cancel.
//

BOOLEAN
NtfsSetCancelRoutine (
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN ULONG_PTR IrpInformation,
    IN ULONG Async
    )

/*++

Routine Description:

    This routine is called to set up an Irp for cancel.  We will set the cancel routine
    and initialize the Irp information we use during cancel.

Arguments:

    Irp - This is the Irp we need to set up for cancel.

    CancelRoutine - This is the cancel routine for this irp.

    IrpInformation - This is the context information to store in the irp
        for the cancel routine.

    Async - Indicates if this request is synchronous or asynchronous.

Return Value:

    BOOLEAN - TRUE if we initialized the Irp, FALSE if the Irp has already
        been marked cancelled.  It will be marked cancelled if the user
        has cancelled the irp before we could put it in the queue.

--*/

{
    KIRQL Irql;

    //
    //  Assume that the Irp has not been cancelled.
    //

    IoAcquireCancelSpinLock( &Irql );
    if (!Irp->Cancel) {

        Irp->IoStatus.Information = (ULONG_PTR) IrpInformation;

        IoSetCancelRoutine( Irp, CancelRoutine );
        IoReleaseCancelSpinLock( Irql );

        if (Async) {

            IoMarkIrpPending( Irp );
        }

        return TRUE;

    } else {

        IoReleaseCancelSpinLock( Irql );
        return FALSE;
    }
}

BOOLEAN
NtfsClearCancelRoutine (
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to clear an Irp from cancel.  It is called when Ntfs is
    internally ready to continue processing the Irp.  We need to know if cancel
    has already been called on this Irp.  In that case we allow the cancel routine
    to complete the Irp.

Arguments:

    Irp - This is the Irp we want to process further.

Return Value:

    BOOLEAN - TRUE if we can proceed with processing the Irp,  FALSE if the cancel
        routine will process the Irp.

--*/

{
    KIRQL Irql;

    IoAcquireCancelSpinLock( &Irql );

    //
    //  Check if the cancel routine has been called.
    //

    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {

        //
        //  Let our cancel routine handle the Irp.
        //

        IoReleaseCancelSpinLock( Irql );
        return FALSE;

    } else {

        IoReleaseCancelSpinLock( Irql );

        Irp->IoStatus.Information = 0;
        return TRUE;
    }
}


NTSTATUS
NtfsFsdDispatchWait (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the driver entry to most of the NTFS Fsd dispatch points.
    IrpContext is initialized on the stack and passed from here.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    IRP_CONTEXT LocalIrpContext;
    NTSTATUS Status;

    Status = NtfsFsdDispatchSwitch( &LocalIrpContext, Irp, TRUE );

    //
    //  If we ever catch ourselves using an IrpContext of this
    //  type, we know we are doing something wrong.
    //

    LocalIrpContext.NodeTypeCode = (NODE_TYPE_CODE)-1;

    return Status;

    UNREFERENCED_PARAMETER( VolumeDeviceObject );
}


NTSTATUS
NtfsFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the driver entry to NTFS Fsd dispatch IRPs that may
    or may not be synchronous.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/


{
    //
    //  We'd rather create the IrpContext on the stack.
    //

    if (CanFsdWait( Irp )) {

        return NtfsFsdDispatchWait( VolumeDeviceObject, Irp );

    } else {

        return NtfsFsdDispatchSwitch( NULL, Irp, FALSE );
    }
}


//
//  Local support routine.
//

NTSTATUS
NtfsFsdDispatchSwitch (
    IN PIRP_CONTEXT StackIrpContext OPTIONAL,
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This is the common switch for all the FsdEntry points
    that don't need special pre-processing. This simply initializes
    the IrpContext and calls the 'Common*' code.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

    Wait - Can this request be posted or not?

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsFsdDispatch\n") );

    //
    //  Call the common query Information routine
    //

    FsRtlEnterFileSystem();

    //
    //  Always make these requests look top level.
    //

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  The optional IrpContext could reside on the caller's stack.
                //

                if (ARGUMENT_PRESENT( StackIrpContext )) {

                    IrpContext = StackIrpContext;
                }

                NtfsInitializeIrpContext( Irp, Wait, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );
            }


            switch (IrpContext->MajorFunction) {

                case IRP_MJ_QUERY_EA:

                    Status = NtfsCommonQueryEa( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_EA:

                    Status = NtfsCommonSetEa( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_QUOTA:

                    Status = NtfsCommonQueryQuota( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_QUOTA:

                    Status = NtfsCommonSetQuota( IrpContext, Irp );
                    break;

                case IRP_MJ_DEVICE_CONTROL:

                    Status = NtfsCommonDeviceControl( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_INFORMATION:

                    Status = NtfsCommonQueryInformation( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_SECURITY:

                    Status = NtfsCommonQuerySecurityInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_SECURITY:

                    Status = NtfsCommonSetSecurityInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_VOLUME_INFORMATION:

                    Status = NtfsCommonQueryVolumeInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_VOLUME_INFORMATION:

                    Status = NtfsCommonSetVolumeInfo( IrpContext, Irp );
                    break;

                default:

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    NtfsCompleteRequest( IrpContext, Irp, Status );
                    ASSERT(FALSE);
                    break;
            }

            break;

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdDispatch -> %08lx\n", Status) );

    return Status;
}

#ifdef NTFS_CHECK_BITMAP
BOOLEAN NtfsForceBitmapBugcheck = FALSE;
BOOLEAN NtfsDisableBitmapCheck = FALSE;

VOID
NtfsBadBitmapCopy (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BadBit,
    IN ULONG Length
    )
{
    if (!NtfsDisableBitmapCheck) {

        DbgPrint("%s:%d %s\n",__FILE__,__LINE__,"Invalid bitmap");
        DbgBreakPoint();

        if (!NtfsDisableBitmapCheck && NtfsForceBitmapBugcheck) {

            KeBugCheckEx( NTFS_FILE_SYSTEM, (ULONG) IrpContext, BadBit, Length, 0 );
        }
    }
    return;
}

BOOLEAN
NtfsCheckBitmap (
    IN PVCB Vcb,
    IN ULONG Lcn,
    IN ULONG Count,
    IN BOOLEAN Set
    )
{
    ULONG BitmapPage;
    ULONG LastBitmapPage;
    ULONG BitOffset;
    ULONG BitsThisPage;
    BOOLEAN Valid = FALSE;

    BitmapPage = Lcn / (PAGE_SIZE * 8);
    LastBitmapPage = (Lcn + Count + (PAGE_SIZE * 8) - 1) / (PAGE_SIZE * 8);
    BitOffset = Lcn & ((PAGE_SIZE * 8) - 1);

    if (LastBitmapPage > Vcb->BitmapPages) {

        return Valid;
    }

    do {

        BitsThisPage = Count;

        if (BitOffset + Count > (PAGE_SIZE * 8)) {

            BitsThisPage = (PAGE_SIZE * 8) - BitOffset;
        }

        if (Set) {

            Valid = RtlAreBitsSet( Vcb->BitmapCopy + BitmapPage,
                                   BitOffset,
                                   BitsThisPage );

        } else {

            Valid = RtlAreBitsClear( Vcb->BitmapCopy + BitmapPage,
                                     BitOffset,
                                     BitsThisPage );
        }

        BitOffset = 0;
        Count -= BitsThisPage;
        BitmapPage += 1;

    } while (Valid && (BitmapPage < LastBitmapPage));

    if (Count != 0) {

        Valid = FALSE;
    }

    return Valid;
}
#endif

//
//  Debugging support routines used for pool verification.  Alas, this works only
//  on checked X86.
//

#if DBG && i386 && defined (NTFSPOOLCHECK)
//
//  Number of backtrace items retrieved on X86


#define BACKTRACE_DEPTH 9

typedef struct _BACKTRACE
{
    ULONG State;
    ULONG Size;
    PVOID Allocate[BACKTRACE_DEPTH];
    PVOID Free[BACKTRACE_DEPTH];
} BACKTRACE, *PBACKTRACE;


#define STATE_ALLOCATED 'M'
#define STATE_FREE      'Z'

//
//  WARNING!  The following depends on pool allocations being either
//      0 mod PAGE_SIZE (for large blocks)
//  or  8 mod 0x20 (for all other requests)
//

#define PAGE_ALIGNED(pv)      (((ULONG)(pv) & (PAGE_SIZE - 1)) == 0)
#define IsKernelPoolBlock(pv) (PAGE_ALIGNED(pv) || (((ULONG)(pv) % 0x20) == 8))

ULONG NtfsDebugTotalPoolAllocated = 0;
ULONG NtfsDebugCountAllocated = 0;
ULONG NtfsDebugSnapshotTotal = 0;
ULONG NtfsDebugSnapshotCount = 0;

PVOID
NtfsDebugAllocatePoolWithTagNoRaise (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag)
{
    ULONG Ignore;
    PBACKTRACE BackTrace =
        ExAllocatePoolWithTag( Pool, Length + sizeof (BACKTRACE), Tag );

    if (PAGE_ALIGNED(BackTrace))
    {
        return BackTrace;
    }

    RtlZeroMemory( BackTrace, sizeof (BACKTRACE) );
    if (RtlCaptureStackBackTrace( 0, BACKTRACE_DEPTH, BackTrace->Allocate, &Ignore ) == 0)
        BackTrace->Allocate[0] = (PVOID)-1;

    BackTrace->State = STATE_ALLOCATED;
    BackTrace->Size = Length;

    NtfsDebugCountAllocated++;
    NtfsDebugTotalPoolAllocated += Length;

    return BackTrace + 1;
}

PVOID
NtfsDebugAllocatePoolWithTag (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag)
{
    ULONG Ignore;
    PBACKTRACE BackTrace =
        FsRtlAllocatePoolWithTag( Pool, Length + sizeof (BACKTRACE), Tag );

    if (PAGE_ALIGNED(BackTrace))
    {
        return BackTrace;
    }

    RtlZeroMemory( BackTrace, sizeof (BACKTRACE) );
    if (RtlCaptureStackBackTrace( 0, BACKTRACE_DEPTH, BackTrace->Allocate, &Ignore ) == 0)
        BackTrace->Allocate[0] = (PVOID)-1;

    BackTrace->State = STATE_ALLOCATED;
    BackTrace->Size = Length;

    NtfsDebugCountAllocated++;
    NtfsDebugTotalPoolAllocated += Length;

    return BackTrace + 1;
}

VOID
NtfsDebugFreePool (
    PVOID pv)
{
    if (IsKernelPoolBlock( pv ))
    {
        ExFreePool( pv );
    }
    else
    {
        ULONG Ignore;
        PBACKTRACE BackTrace = (PBACKTRACE)pv - 1;

        if (BackTrace->State != STATE_ALLOCATED)
        {
            DbgBreakPoint( );
        }

        if (RtlCaptureStackBackTrace( 0, BACKTRACE_DEPTH, BackTrace->Free, &Ignore ) == 0)
            BackTrace->Free[0] = (PVOID)-1;

        BackTrace->State = STATE_FREE;

        NtfsDebugCountAllocated--;
        NtfsDebugTotalPoolAllocated -= BackTrace->Size;

        ExFreePool( BackTrace );
    }
}

VOID
NtfsDebugHeapDump (
    PUNICODE_STRING UnicodeString )
{

    UNREFERENCED_PARAMETER( UnicodeString );

    DbgPrint( "Cumulative %8x bytes in %8x blocks\n",
               NtfsDebugTotalPoolAllocated, NtfsDebugCountAllocated );
    DbgPrint( "Snapshot   %8x bytes in %8x blocks\n",
               NtfsDebugTotalPoolAllocated - NtfsDebugSnapshotTotal,
               NtfsDebugCountAllocated - NtfsDebugSnapshotCount );

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfs.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Ntfs.h

Current Version Numbers:

    Major.Minor Version:  3.1

Abstract:

    This module defines the on-disk structure of the Ntfs file system.

    An Ntfs volume consists of sectors of data allocated on a granularity
    called a cluster.  The cluster factor is the number of sectors per
    cluster.  Valid cluster factors are 1, 2, 4, 8, etc.

    The Ntfs volume starts with a boot sector at LBN=0, and a duplicate
    boot sector at LBN=(number of sectors on the partition div 2).  So
    a disk with N sectors start with two boot sectors as illustrated.

         0             ...   N/2            ...   N
        +-----------+-------+------------+-------+------------+
        |BootSector |  ...  | BootSector |  ...  |            |
        +-----------+-------+------------+-------+------------+

    The boot sector gives you the standard Bios Parameter Block, and
    tells you how many sectors are in the volume, and gives you the starting
    LCNs of the master file table (mft) and the duplicate master file table
    (mft2).

    The master file table contains the file record segments for all of
    the volume.  The first 16 or so file record segments are reserved for
    special files.  Mft2 only mirrors the first three record segments.

          0   1   2   3   4   5   6   7   8   9   ...
        +---+---+---+---+---+---+---+---+---+---+-----+
        | M | M | L | V | A | R | B | B | B | Q |     |
        | f | f | o | o | t | o | i | o | a | u |     |
        | t | t | g | l | t | o | t | o | d | o |     |
        |   | 2 | F | D | r | t | M | t | C | t | ... |
        |   |   | i | a | D | D | a |   | l | a |     |
        |   |   | l | s | e | i | p |   | u |   |     |
        |   |   | e | d | f | r |   |   | s |   |     |
        +---+---+---+---+---+---+---+---+---+---+-----+


    Each file record segment starts with a file record segment header, and
    is followed by one or more attributes.  Each attribute starts with an
    attribute record header.  The attribute record denotes the attribute type,
    optional name, and value for the attribute.  If the attribute is resident
    the value is contained in the file record and immediately follows the
    attribute record header.  If the attribute is non-resident the value
    value is off in some other sectors on the disk.

        +---------+-----------------+-------+
        | File    | Attrib : Name   |       |
        | Record  | Record : and/or |  ...  |
        | Segment | Header : Attrib |       |
        | Header  |        : Data   |       |
        +---------+-----------------+-------+

    Now if we run out of space for storing attributes in the file record
    segment we allocate additional file record segments and insert in the
    first (or base) file record segment an attribute called the Attribute
    List.  The attribute list indicates for every attribute associated
    with the file where the attribute can be found.  This includes
    those in the base file record.

    The value part of the attribute we're calling the attribute list is
    a list of sorted attribute list entries.  Though illustrated
    here as resident the attribute list can be nonresident.

        +---------+---------------------------+-----------------+-------+
        | File    | Attrib : Attrib   :       | Attrib : Name   |       |
        | Record  | Record : List     :  ...  | Record : and/or |  ...  |
        | Segment | Header : Entry    :       | Header : Attrib |       |
        | Header  |        :          :       |        : Data   |       |
        +---------+---------------------------+-----------------+-------+

                               |
                               V

                           +---------+-----------------+-------+
                           | File    | Attrib : Name   |       |
                           | Record  | Record : and/or |  ...  |
                           | Segment | Header : Attrib |       |
                           | Header  |        : Data   |       |
                           +---------+-----------------+-------+

    This file defines all of the above structures and also lays out the
    structures for some predefined attributes values (e.g., standard
    information, etc).

    Attributes are stored in ascending order in the file record and
    attribute list.  The sorting is done by first sorting according to
    attribute type code, then attribute name, and lastly attribute value.
    NTFS guarantees that if two attributes of the same type code and
    name exist on a file then they must have different values, and the
    values must be resident.

    The indexing attributes are the last interesting attribute.  The data
    component of an index root attribute must always be resident and contains
    an index header followed by a list of index list entries.

        +--------+------------------------+
        | Attrib |        : Index :       |
        | Record | Index  : List  :  ...  |
        | Header | Header : Entry :       |
        |        |        :       :       |
        +--------+------------------------+

    Each index list entry contains the key for the index and a reference
    to the file record segment for the index.  If ever we need to spill
    out of the file record segment we allocate an additional cluster from
    the disk (not file record segments).  The storage for the additional
    clusters is the data part of an index allocation attribute.  So what
    we wind up with is an index allocation attribute (non-resident) consisting
    of Index Allocation Buffers which are referenced by the b-tree used in in
    the index.

        +--------+------------------------+-----+---------------------+
        | Attrib | Index  : Index :       |     | Attrib : Index      |
        | Record | List   : List  :  ...  | ... | Record : Allocation |
        | Header | Header : Entry :       |     | Header :            |
        |        |        :       :       |     |        :            |
        +--------+------------------------+-----+---------------------+

                              |
                              | (VCN within index allocation)
                              V

                          +------------+------------------------------+
                          | Index      |       : Index : Index :      |
                          | Allocation | Index : List  : List  : ...  |
                          | Buffer     | Header: Entry : Entry :      |
                          |            |       :       :       :      |
                          +------------+------------------------------+

    Resident attributes are straight forward.  Non-resident attributes require
    a little more work.  If the attribute is non-resident then following
    the attribute record header is a list of retrieval information giving a
    VCN to LCN mapping for the attribute.  In the figure above the
    Index allocation attribute is a a non-resident attribute

        +---------+----------------------+-------+
        | File    | Attrib : Retrieval   |       |
        | Record  | Record : Information |  ...  |
        | Segment | Header :             |       |
        | Header  |        :             |       |
        +---------+----------------------+-------+

    If the retrieval information does not fit in the base file segment then
    it can be stored in an external file record segment all by itself, and
    if in the still doesn't fit in one external file record segment then
    there is a provision in the attribute list to contain multiple
    entries for an attribute that needs additional retrieval information.

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:


IMPORTANT NOTE:

    The NTFS on-disk structure must guarantee natural alignment of all
    arithmetic quantities on disk up to and including quad-word (64-bit)
    numbers.  Therefore, all attribute records are quad-word aligned, etc.

--*/

#ifndef _NTFS_
#define _NTFS_

#pragma pack(4)


//
//  The fundamental unit of allocation on an Ntfs volume is the
//  cluster.  Format guarantees that the cluster size is an integral
//  power of two times the physical sector size of the device.  Ntfs
//  reserves 64-bits to describe a cluster, in order to support
//  large disks.  The LCN represents a physical cluster number on
//  the disk, and the VCN represents a virtual cluster number within
//  an attribute.
//

typedef LONGLONG LCN;
typedef LCN *PLCN;

typedef LONGLONG VCN;
typedef VCN *PVCN;

typedef LONGLONG LBO;
typedef LBO *PLBO;

typedef LONGLONG VBO;
typedef VBO *PVBO;

//
//  Current Versions
//  

#define NTFS_MAJOR_VERSION 3
#define NTFS_MINOR_VERSION 1


//
//  Temporary definitions ****
//

typedef ULONG COLLATION_RULE;
typedef ULONG DISPLAY_RULE;

//
//  The compression chunk size is constant for now, at 4KB.
//

#define NTFS_CHUNK_SIZE                  (0x1000)
#define NTFS_CHUNK_SHIFT                 (12)

//
//  This number is actually the log of the number of clusters per compression
//  unit to be stored in a nonresident attribute record header.
//

#define NTFS_CLUSTERS_PER_COMPRESSION    (4)

//
//  This is the sparse file unit. This is the unit we use for generating holes
//  in sparse files.
//

#define NTFS_SPARSE_FILE_UNIT            (0x10000)

//
//  Collation Rules
//

//
//  For binary collation, values are collated by a binary compare of
//  their bytes, with the first byte being most significant.
//

#define COLLATION_BINARY                 (0)

//
//  For collation of Ntfs file names, file names are collated as
//  Unicode strings.  See below.
//

#define COLLATION_FILE_NAME              (1)

//
//  For collation of Unicode strings, the strings are collated by
//  their binary Unicode value, with the exception that for
//  characters which may be upcased, the lower case value for that
//  character collates immediately after the upcased value.
//

#define COLLATION_UNICODE_STRING         (2)

//
//  Total number of collation rules
//

#define COLLATION_NUMBER_RULES           (3)

//
//  Define the NtOfs Collation Rules
//

#define COLLATION_NTOFS_FIRST            (16)
#define COLLATION_NTOFS_ULONG            (16)
#define COLLATION_NTOFS_SID              (17)
#define COLLATION_NTOFS_SECURITY_HASH    (18)
#define COLLATION_NTOFS_ULONGS           (19)
#define COLLATION_NTOFS_LAST             (19)

//
//  The following macros are used to set and query with respect to
//  the update sequence arrays.
//

#define UpdateSequenceStructureSize(MSH) (                         \
    ((((PMULTI_SECTOR_HEADER)(MSH))->UpdateSequenceArraySize-1) *  \
                                           SEQUENCE_NUMBER_STRIDE) \
)

#define UpdateSequenceArraySize(STRUCT_SIZE) (   \
    ((STRUCT_SIZE) / SEQUENCE_NUMBER_STRIDE + 1) \
)


//
//  The MFT Segment Reference is an address in the MFT tagged with
//  a circularly reused sequence number set at the time that the MFT
//  Segment Reference was valid.  Note that this format limits the
//  size of the Master File Table to 2**48 segments.  So, for
//  example, with a 1KB segment size the maximum size of the master
//  file would be 2**58 bytes, or 2**28 gigabytes.
//

typedef struct _MFT_SEGMENT_REFERENCE {

    //
    //  First a 48 bit segment number.
    //

    ULONG SegmentNumberLowPart;                                    //  offset = 0x000
    USHORT SegmentNumberHighPart;                                  //  offset = 0x004

    //
    //  Now a 16 bit nonzero sequence number.  A value of 0 is
    //  reserved to allow the possibility of a routine accepting
    //  0 as a sign that the sequence number check should be
    //  repressed.
    //

    USHORT SequenceNumber;                                          //  offset = 0x006

} MFT_SEGMENT_REFERENCE, *PMFT_SEGMENT_REFERENCE;                   //  sizeof = 0x008

//
//  A file reference in NTFS is simply the MFT Segment Reference of
//  the Base file record.
//

typedef MFT_SEGMENT_REFERENCE FILE_REFERENCE, *PFILE_REFERENCE;

//
//  While the format allows 48 bits worth of segment number, the current
//  implementation restricts this to 32 bits.  Using NtfsUnsafeSegmentNumber
//  results in a performance win.  When the implementation changes, the
//  unsafe segment numbers must be cleaned up.  NtfsFullSegmentNumber is
//  used in a few spots to guarantee integrity of the disk.
//

#define NtfsSegmentNumber(fr)       NtfsUnsafeSegmentNumber( fr )
#define NtfsFullSegmentNumber(fr)   ( (*(ULONGLONG UNALIGNED *)(fr)) & 0xFFFFFFFFFFFF )
#define NtfsUnsafeSegmentNumber(fr) ((fr)->SegmentNumberLowPart)

#define NtfsSetSegmentNumber(fr,high,low)   \
    ((fr)->SegmentNumberHighPart = (high), (fr)->SegmentNumberLowPart = (low))

#define NtfsEqualMftRef(X,Y)    ( NtfsSegmentNumber( X ) == NtfsSegmentNumber( Y ) )

#define NtfsLtrMftRef(X,Y)      ( NtfsSegmentNumber( X ) <  NtfsSegmentNumber( Y ) )

#define NtfsGtrMftRef(X,Y)      ( NtfsSegmentNumber( X ) >  NtfsSegmentNumber( Y ) )                                               \

#define NtfsLeqMftRef(X,Y)      ( NtfsSegmentNumber( X ) <= NtfsSegmentNumber( Y ) )

#define NtfsGeqMftRef(X,Y)      ( NtfsSegmentNumber( X ) >= NtfsSegmentNumber( Y ) )

//
//  System File Numbers.  The following file numbers are a fixed
//  part of the volume number.  For the system files, the
//  SequenceNumber is always equal to the File Number.  So to form a
//  File Reference for a given System File, set LowPart and
//  SequenceNumber to the File Number, and set HighPart to 0.  Any
//  unused file numbers prior to FIRST_USER_FILE_NUMBER should not
//  be used.  They are reserved to allow the potential for easy
//  upgrade of existing volumes from future versions of the file
//  system.
//
//  Each definition below is followed by a comment containing
//  the file name for the file:
//
//                                      Number     Name
//                                      ------     ----

#define MASTER_FILE_TABLE_NUMBER         (0)   //  $Mft

#define MASTER_FILE_TABLE2_NUMBER        (1)   //  $MftMirr

#define LOG_FILE_NUMBER                  (2)   //  $LogFile

#define VOLUME_DASD_NUMBER               (3)   //  $Volume

#define ATTRIBUTE_DEF_TABLE_NUMBER       (4)   //  $AttrDef

#define ROOT_FILE_NAME_INDEX_NUMBER      (5)   //  .

#define BIT_MAP_FILE_NUMBER              (6)   //  $BitMap

#define BOOT_FILE_NUMBER                 (7)   //  $Boot

#define BAD_CLUSTER_FILE_NUMBER          (8)   //  $BadClus

#define SECURITY_FILE_NUMBER             (9)   //  $Secure

#define UPCASE_TABLE_NUMBER              (10)  //  $UpCase

#define EXTEND_NUMBER                    (11)  //  $Extend

#define LAST_SYSTEM_FILE_NUMBER          (11)
#define FIRST_USER_FILE_NUMBER           (16)

//
//  The number of bits to extend the Mft and bitmap.  We round these up to a
//  cluster boundary for a large cluster volume
//

#define BITMAP_EXTEND_GRANULARITY               (64)
#define MFT_HOLE_GRANULARITY                    (32)
#define MFT_EXTEND_GRANULARITY                  (16)

//
//  The shift values for determining the threshold for the Mft defragging.
//

#define MFT_DEFRAG_UPPER_THRESHOLD      (3)     //  Defrag if 1/8 of free space
#define MFT_DEFRAG_LOWER_THRESHOLD      (4)     //  Stop at 1/16 of free space


//
//  Attribute Type Code.  Attribute Types also have a Unicode Name,
//  and the correspondence between the Unicode Name and the
//  Attribute Type Code is stored in the Attribute Definition File.
//

typedef ULONG ATTRIBUTE_TYPE_CODE;
typedef ATTRIBUTE_TYPE_CODE *PATTRIBUTE_TYPE_CODE;

//
//  System-defined Attribute Type Codes.  For the System-defined
//  attributes, the Unicode Name is exactly equal to the name of the
//  following symbols.  For this reason, all of the system-defined
//  attribute names start with "$", to always distinguish them when
//  attribute names are listed, and to reserve a namespace for
//  attributes defined in the future.  I.e., a User-Defined
//  attribute name will never collide with a current or future
//  system-defined attribute name if it does not start with "$".
//  User attribute numbers should not start until
//  $FIRST_USER_DEFINED_ATTRIBUTE, to allow the potential for
//  upgrading existing volumes with new user-defined attributes in
//  future versions of NTFS.  The tagged attribute list is
//  terminated with a lone-standing 0 ($END) - the rest of the
//  attribute record does not exist.
//
//  The type code value of 0 is reserved for convenience of the
//  implementation.
//

#define $UNUSED                          (0X0)

#define $STANDARD_INFORMATION            (0x10)
#define $ATTRIBUTE_LIST                  (0x20)
#define $FILE_NAME                       (0x30)
#define $OBJECT_ID                       (0x40)
#define $SECURITY_DESCRIPTOR             (0x50)
#define $VOLUME_NAME                     (0x60)
#define $VOLUME_INFORMATION              (0x70)
#define $DATA                            (0x80)
#define $INDEX_ROOT                      (0x90)
#define $INDEX_ALLOCATION                (0xA0)
#define $BITMAP                          (0xB0)
#define $REPARSE_POINT                   (0xC0)
#define $EA_INFORMATION                  (0xD0)
#define $EA                              (0xE0)
// #define $LOGGED_UTILITY_STREAM           (0x100) // defined in ntfsexp.h
#define $FIRST_USER_DEFINED_ATTRIBUTE    (0x1000)
#define $END                             (0xFFFFFFFF)


//
//  The boot sector is duplicated on the partition.  The first copy
//  is on the first physical sector (LBN == 0) of the partition, and
//  the second copy is at <number sectors on partition> / 2.  If the
//  first copy can not be read when trying to mount the disk, the
//  second copy may be read and has the identical contents.  Format
//  must figure out which cluster the second boot record belongs in,
//  and it must zero all of the other sectors that happen to be in
//  the same cluster.  The boot file minimally contains with two
//  clusters, which are the two clusters which contain the copies of
//  the boot record.  If format knows that some system likes to put
//  code somewhere, then it should also align this requirement to
//  even clusters, and add that to the boot file as well.
//
//  Part of the sector contains a BIOS Parameter Block.  The BIOS in
//  the sector is packed (i.e., unaligned) so we'll supply an
//  unpacking macro to translate a packed BIOS into its unpacked
//  equivalent.  The unpacked BIOS structure is already defined in
//  ntioapi.h so we only need to define the packed BIOS.
//

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {

    UCHAR  BytesPerSector[2];                               //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                            //  offset = 0x002
    UCHAR  ReservedSectors[2];                              //  offset = 0x003 (zero)
    UCHAR  Fats[1];                                         //  offset = 0x005 (zero)
    UCHAR  RootEntries[2];                                  //  offset = 0x006 (zero)
    UCHAR  Sectors[2];                                      //  offset = 0x008 (zero)
    UCHAR  Media[1];                                        //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                                //  offset = 0x00B (zero)
    UCHAR  SectorsPerTrack[2];                              //  offset = 0x00D
    UCHAR  Heads[2];                                        //  offset = 0x00F
    UCHAR  HiddenSectors[4];                                //  offset = 0x011 (zero)
    UCHAR  LargeSectors[4];                                 //  offset = 0x015 (zero)

} PACKED_BIOS_PARAMETER_BLOCK;                              //  sizeof = 0x019

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {

    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;

} BIOS_PARAMETER_BLOCK;

typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;

//
//  This macro takes a Packed BIOS and fills in its Unpacked
//  equivalent
//

#define NtfsUnpackBios(Bios,Pbios) {                                       \
    CopyUchar2(&((Bios)->BytesPerSector),    &(Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), &(Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   &(Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              &(Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       &(Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           &(Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             &(Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     &(Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   &(Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             &(Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     &(Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      &(Pbios)->LargeSectors     ); \
}

//
//  Define the boot sector.  Note that MFT2 is exactly three file
//  record segments long, and it mirrors the first three file record
//  segments from the MFT, which are MFT, MFT2 and the Log File.
//
//  The Oem field contains the ASCII characters "NTFS    ".
//
//  The Checksum field is a simple additive checksum of all of the
//  ULONGs which precede the Checksum ULONG.  The rest of the sector
//  is not included in this Checksum.
//

typedef struct _PACKED_BOOT_SECTOR {

    UCHAR Jump[3];                                                              //  offset = 0x000
    UCHAR Oem[8];                                                               //  offset = 0x003
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;                                      //  offset = 0x00B
    UCHAR Unused[4];                                                            //  offset = 0x024
    LONGLONG NumberSectors;                                                     //  offset = 0x028
    LCN MftStartLcn;                                                            //  offset = 0x030
    LCN Mft2StartLcn;                                                           //  offset = 0x038
    CHAR ClustersPerFileRecordSegment;                                          //  offset = 0x040
    UCHAR Reserved0[3];
    CHAR DefaultClustersPerIndexAllocationBuffer;                               //  offset = 0x044
    UCHAR Reserved1[3];
    LONGLONG SerialNumber;                                                      //  offset = 0x048
    ULONG Checksum;                                                             //  offset = 0x050
    UCHAR BootStrap[0x200-0x054];                                               //  offset = 0x054

} PACKED_BOOT_SECTOR;                                                           //  sizeof = 0x200

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;


//
//  File Record Segment.  This is the header that begins every File
//  Record Segment in the Master File Table.
//

typedef struct _FILE_RECORD_SEGMENT_HEADER {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "FILE" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;                          //  offset = 0x000

    //
    //  Log File Sequence Number of last logged update to this File
    //  Record Segment.
    //

    LSN Lsn;                                                        //  offset = 0x008

    //
    //  Sequence Number.  This is incremented each time that a File
    //  Record segment is freed, and 0 is not used.  The
    //  SequenceNumber field of a File Reference must match the
    //  contents of this field, or else the File Reference is
    //  incorrect (presumably stale).
    //

    USHORT SequenceNumber;                                          //  offset = 0x010

    //
    //  This is the count of the number of references which exist
    //  for this segment, from an INDEX_xxx attribute.  In File
    //  Records Segments other than the Base File Record Segment,
    //  this field is 0.
    //

    USHORT ReferenceCount;                                          //  offset = 0x012

    //
    //  Offset to the first Attribute record in bytes.
    //

    USHORT FirstAttributeOffset;                                    //  offset = 0x014

    //
    //  FILE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x016

    //
    //  First free byte available for attribute storage, from start
    //  of this header.  This value should always be aligned to a
    //  quad-word boundary, since attributes are quad-word aligned.
    //

    ULONG FirstFreeByte;                                            //  offset = x0018

    //
    //  Total bytes available in this file record segment, from the
    //  start of this header.  This is essentially the file record
    //  segment size.
    //

    ULONG BytesAvailable;                                           //  offset = 0x01C

    //
    //  This is a File Reference to the Base file record segment for
    //  this file.  If this is the Base, then the value of this
    //  field is all 0's.
    //

    FILE_REFERENCE BaseFileRecordSegment;                           //  offset = 0x020

    //
    //  This is the attribute instance number to be used when
    //  creating an attribute.  It is zeroed when the base file
    //  record is created, and captured for each new attribute as it
    //  is created and incremented afterwards for the next
    //  attribute.  Instance numbering must also occur for the
    //  initial attributes.  Zero is a valid attribute instance
    //  number, and typically used for standard information.
    //

    USHORT NextAttributeInstance;                                   //  offset = 0x028

    //
    //  Current FRS record - this is here for recovery alone and added in 5.1
    //  Note: this is not aligned
    // 

    USHORT SegmentNumberHighPart;                                  //  offset = 0x02A
    ULONG SegmentNumberLowPart;                                    //  offset = 0x02C

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the File Record Segment.  Accesses to already initialized
    //  File Record Segments should go through the offset above, for
    //  upwards compatibility.
    //

    UPDATE_SEQUENCE_ARRAY UpdateArrayForCreateOnly;                 //  offset = 0x030

} FILE_RECORD_SEGMENT_HEADER;
typedef FILE_RECORD_SEGMENT_HEADER *PFILE_RECORD_SEGMENT_HEADER;


//
//  earlier version of FRS from 5.0
//  

typedef struct _FILE_RECORD_SEGMENT_HEADER_V0 {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "FILE" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;                          //  offset = 0x000

    //
    //  Log File Sequence Number of last logged update to this File
    //  Record Segment.
    //

    LSN Lsn;                                                        //  offset = 0x008

    //
    //  Sequence Number.  This is incremented each time that a File
    //  Record segment is freed, and 0 is not used.  The
    //  SequenceNumber field of a File Reference must match the
    //  contents of this field, or else the File Reference is
    //  incorrect (presumably stale).
    //

    USHORT SequenceNumber;                                          //  offset = 0x010

    //
    //  This is the count of the number of references which exist
    //  for this segment, from an INDEX_xxx attribute.  In File
    //  Records Segments other than the Base File Record Segment,
    //  this field is 0.
    //

    USHORT ReferenceCount;                                          //  offset = 0x012

    //
    //  Offset to the first Attribute record in bytes.
    //

    USHORT FirstAttributeOffset;                                    //  offset = 0x014

    //
    //  FILE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x016

    //
    //  First free byte available for attribute storage, from start
    //  of this header.  This value should always be aligned to a
    //  quad-word boundary, since attributes are quad-word aligned.
    //

    ULONG FirstFreeByte;                                            //  offset = x0018

    //
    //  Total bytes available in this file record segment, from the
    //  start of this header.  This is essentially the file record
    //  segment size.
    //

    ULONG BytesAvailable;                                           //  offset = 0x01C

    //
    //  This is a File Reference to the Base file record segment for
    //  this file.  If this is the Base, then the value of this
    //  field is all 0's.
    //

    FILE_REFERENCE BaseFileRecordSegment;                           //  offset = 0x020

    //
    //  This is the attribute instance number to be used when
    //  creating an attribute.  It is zeroed when the base file
    //  record is created, and captured for each new attribute as it
    //  is created and incremented afterwards for the next
    //  attribute.  Instance numbering must also occur for the
    //  initial attributes.  Zero is a valid attribute instance
    //  number, and typically used for standard information.
    //

    USHORT NextAttributeInstance;                                   //  offset = 0x028

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the File Record Segment.  Accesses to already initialized
    //  File Record Segments should go through the offset above, for
    //  upwards compatibility.
    //

    UPDATE_SEQUENCE_ARRAY UpdateArrayForCreateOnly;                 //  offset = 0x02A

} FILE_RECORD_SEGMENT_HEADER_V0;

//
//  FILE_xxx flags.
//

#define FILE_RECORD_SEGMENT_IN_USE       (0x0001)
#define FILE_FILE_NAME_INDEX_PRESENT     (0x0002)
#define FILE_SYSTEM_FILE                 (0x0004)
#define FILE_VIEW_INDEX_PRESENT          (0x0008)

//
//  Define a macro to determine the maximum space available for a
//  single attribute.  For example, this is required when a
//  nonresident attribute has to split into multiple file records -
//  we need to know how much we can squeeze into a single file
//  record.  If this macro has any inaccurracy, it must be in the
//  direction of returning a slightly smaller number than actually
//  required.
//
//      ULONG
//      NtfsMaximumAttributeSize (
//          IN ULONG FileRecordSegmentSize
//          );
//

#define NtfsMaximumAttributeSize(FRSS) (                                               \
    (FRSS) - QuadAlign(sizeof(FILE_RECORD_SEGMENT_HEADER)) -                           \
    QuadAlign((((FRSS) / SEQUENCE_NUMBER_STRIDE) * sizeof(UPDATE_SEQUENCE_NUMBER))) -  \
    QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE))                                             \
)


//
//  Attribute Record.  Logically an attribute has a type, an
//  optional name, and a value, however the storage details make it
//  a little more complicated.  For starters, an attribute's value
//  may either be resident in the file record segment itself, on
//  nonresident in a separate data stream.  If it is nonresident, it
//  may actually exist multiple times in multiple file record
//  segments to describe different ranges of VCNs.
//
//  Attribute Records are always aligned on a quad word (64-bit)
//  boundary.
//

typedef struct _ATTRIBUTE_RECORD_HEADER {

    //
    //  Attribute Type Code.
    //

    ATTRIBUTE_TYPE_CODE TypeCode;                                   //  offset = 0x000

    //
    //  Length of this Attribute Record in bytes.  The length is
    //  always rounded to a quad word boundary, if necessary.  Also
    //  the length only reflects the size necessary to store the
    //  given record variant.
    //

    ULONG RecordLength;                                             //  offset = 0x004

    //
    //  Attribute Form Code (see below)
    //

    UCHAR FormCode;                                                 //  offset = 0x008

    //
    //  Length of the optional attribute name in characters, or 0 if
    //  there is none.
    //

    UCHAR NameLength;                                               //  offset = 0x009

    //
    //  Offset to the attribute name from start of attribute record,
    //  in bytes, if it exists.  This field is undefined if
    //  NameLength is 0.
    //

    USHORT NameOffset;                                              //  offset = 0x00A

    //
    //  ATTRIBUTE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x00C

    //
    //  The file-record-unique attribute instance number for this
    //  attribute.
    //

    USHORT Instance;                                                //  offset = 0x00E

    //
    //  The following union handles the cases distinguished by the
    //  Form Code.
    //

    union {

        //
        //  Resident Form.  Attribute resides in file record segment.
        //

        struct {

            //
            //  Length of attribute value in bytes.
            //

            ULONG ValueLength;                                      //  offset = 0x010

            //
            //  Offset to value from start of attribute record, in
            //  bytes.
            //

            USHORT ValueOffset;                                     //  offset = 0x014

            //
            //  RESIDENT_FORM_xxx Flags.
            //

            UCHAR ResidentFlags;                                    //  offset = 0x016

            //
            //  Reserved.
            //

            UCHAR Reserved;                                         //  offset = 0x017

        } Resident;

        //
        //  Nonresident Form.  Attribute resides in separate stream.
        //

        struct {

            //
            //  Lowest VCN covered by this attribute record.
            //

            VCN LowestVcn;                                          //  offset = 0x010

            //
            //  Highest VCN covered by this attribute record.
            //

            VCN HighestVcn;                                         //  offset = 0x018

            //
            //  Offset to the Mapping Pairs Array  (defined below),
            //  in bytes, from the start of the attribute record.
            //

            USHORT MappingPairsOffset;                              //  offset = 0x020

            //
            //  Unit of Compression size for this stream, expressed
            //  as a log of the cluster size.
            //
            //      0 means file is not compressed
            //      1, 2, 3, and 4 are potentially legal values if the
            //          stream is compressed, however the implementation
            //          may only choose to use 4, or possibly 3.  Note
            //          that 4 means cluster size time 16.  If convenient
            //          the implementation may wish to accept a
            //          reasonable range of legal values here (1-5?),
            //          even if the implementation only generates
            //          a smaller set of values itself.
            //

            UCHAR CompressionUnit;                                  //  offset = 0x022

            //
            //  Reserved to get to quad word boundary.
            //

            UCHAR Reserved[5];                                      //  offset = 0x023

            //
            //  Allocated Length of the file in bytes.  This is
            //  obviously an even multiple of the cluster size.
            //  (Not present if LowestVcn != 0.)
            //

            LONGLONG AllocatedLength;                               //  offset = 0x028

            //
            //  File Size in bytes (highest byte which may be read +
            //  1).  (Not present if LowestVcn != 0.)
            //

            LONGLONG FileSize;                                      //  offset = 0x030

            //
            //  Valid Data Length (highest initialized byte + 1).
            //  This field must also be rounded to a cluster
            //  boundary, and the data must always be initialized to
            //  a cluster boundary. (Not present if LowestVcn != 0.)
            //

            LONGLONG ValidDataLength;                               //  offset = 0x038

            //
            //  Totally allocated.  This field is only present for the first
            //  file record of a compressed stream.  It represents the sum of
            //  the allocated clusters for a file.
            //

            LONGLONG TotalAllocated;                                //  offset = 0x040

            //
            //
            //  Mapping Pairs Array, starting at the offset stored
            //  above.
            //
            //  The Mapping Pairs Array is stored in a compressed
            //  form, and assumes that this information is
            //  decompressed and cached by the system.  The reason
            //  for compressing this information is clear, it is
            //  done in the hopes that all of the retrieval
            //  information always fits in a single file record
            //  segment.
            //
            //  Logically, the MappingPairs Array stores a series of
            //  NextVcn/CurrentLcn pairs.  So, for example, given
            //  that we know the first Vcn (from LowestVcn above),
            //  the first Mapping Pair tells us what the next Vcn is
            //  (for the next Mapping Pair), and what Lcn the
            //  current Vcn is mapped to, or 0 if the Current Vcn is
            //  not allocated.  (This is exactly the FsRtl MCB
            //  structure).
            //
            //  For example, if a file has a single run of 8
            //  clusters, starting at Lcn 128, and the file starts
            //  at LowestVcn=0, then the Mapping Pairs array has
            //  just one entry, which is:
            //
            //    NextVcn = 8
            //    CurrentLcn = 128
            //
            //  The compression is implemented with the following
            //  algorithm.  Assume that you initialize two "working"
            //  variables as follows:
            //
            //    NextVcn = LowestVcn (from above)
            //    CurrentLcn = 0
            //
            //  The MappingPairs array is byte stream, which simply
            //  store the changes to the working variables above,
            //  when processed sequentially.  The byte stream is to
            //  be interpreted as a zero-terminated stream of
            //  triples, as follows:
            //
            //    count byte = v + (l * 16)
            //
            //      where v = number of changed low-order Vcn bytes
            //            l = number of changed low-order Lcn bytes
            //
            //    v Vcn change bytes
            //    l Lcn change bytes
            //
            //  The byte stream terminates when a count byte of 0 is
            //  encountered.
            //
            //  The decompression algorithm goes as follows,
            //  assuming that Attribute is a pointer to the
            //  attribute record.
            //
            //  1.  Initialize:
            //          NextVcn = Attribute->LowestVcn;
            //          CurrentLcn = 0;
            //
            //  2.  Initialize byte stream pointer to: (PCHAR)Attribute +
            //      Attribute->AttributeForm->Nonresident->MappingPairsOffset
            //
            //  3.  CurrentVcn = NextVcn;
            //
            //  4.  Read next byte from stream.  If it is 0, then
            //      break, else extract v and l (see above).
            //
            //  5.  Interpret the next v bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to NextVcn.
            //      (It can really only be positive, but the Lcn
            //      change can be positive or negative.)
            //
            //  6.  Interpret the next l bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to
            //      CurrentLcn.  Remember, if this produces a
            //      CurrentLcn of 0, then the Vcns from the
            //      CurrentVcn to NextVcn-1 are unallocated.
            //
            //  7.  Update cached mapping information from
            //      CurrentVcn, NextVcn and CurrentLcn.
            //
            //  8.  Loop back to 3.
            //
            //  The compression algorithm should now be obvious, as
            //  it is the reverse of the above.  The compression and
            //  decompression algorithms will be available as common
            //  RTL routines, available to NTFS and file utilities.
            //
            //  In defense of this algorithm, not only does it
            //  provide compression of the on-disk storage
            //  requirements, but it results in a single
            //  representation, independent of disk size and file
            //  size.  Contrast this with solutions which are in use
            //  which define multiple sizes for virtual and logical
            //  cluster sizes, depending on the size of the disk,
            //  etc.  For example, two byte cluster numbers might
            //  suffice for a floppy, while four bytes would be
            //  required for most hard disks today, and five or six
            //  bytes are required after a certain number of
            //  gigabytes, etc.  This eventually results in more
            //  complex code than above (because of the cases) and
            //  worse yet - untested cases.  So, more important than
            //  the compression, the above algorithm provides one
            //  case which efficiently handles any size disk.
            //

        } Nonresident;

    } Form;

} ATTRIBUTE_RECORD_HEADER;
typedef ATTRIBUTE_RECORD_HEADER *PATTRIBUTE_RECORD_HEADER;

//
//  Attribute Form Codes
//

#define RESIDENT_FORM                    (0x00)
#define NONRESIDENT_FORM                 (0x01)

//
//  Define Attribute Flags
//

//
//  The first range of flag bits is reserved for
//  storing the compression method.  This constant
//  defines the mask of the bits reserved for
//  compression method.  It is also the first
//  illegal value, since we increment it to calculate
//  the code to pass to the Rtl routines.  Thus it is
//  impossible for us to store COMPRESSION_FORMAT_DEFAULT.
//

#define ATTRIBUTE_FLAG_COMPRESSION_MASK  (0x00FF)
#define ATTRIBUTE_FLAG_SPARSE            (0x8000)
#define ATTRIBUTE_FLAG_ENCRYPTED         (0x4000)

//
//  RESIDENT_FORM_xxx flags
//

//
//  This attribute is indexed.
//

#define RESIDENT_FORM_INDEXED            (0x01)

//
//  The maximum attribute name length is 255 (in chars)
//

#define NTFS_MAX_ATTR_NAME_LEN           (255)

//
//  Define macros for the size of resident and nonresident headers.
//

#define SIZEOF_RESIDENT_ATTRIBUTE_HEADER (                         \
    FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER,Form.Resident.Reserved)+1 \
)

#define SIZEOF_FULL_NONRES_ATTR_HEADER (    \
    sizeof(ATTRIBUTE_RECORD_HEADER)         \
)

#define SIZEOF_PARTIAL_NONRES_ATTR_HEADER (                                 \
    FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER,Form.Nonresident.TotalAllocated)   \
)


//
//  Standard Information Attribute.  This attribute is present in
//  every base file record, and must be resident.
//

typedef struct _STANDARD_INFORMATION {

    //
    //  File creation time.
    //

    LONGLONG CreationTime;                                          //  offset = 0x000

    //
    //  Last time the DATA attribute was modified.
    //

    LONGLONG LastModificationTime;                                  //  offset = 0x008

    //
    //  Last time any attribute was modified.
    //

    LONGLONG LastChangeTime;                                        //  offset = 0x010

    //
    //  Last time the file was accessed.  This field may not always
    //  be updated (write-protected media), and even when it is
    //  updated, it may only be updated if the time would change by
    //  a certain delta.  It is meant to tell someone approximately
    //  when the file was last accessed, for purposes of possible
    //  file migration.
    //

    LONGLONG LastAccessTime;                                        //  offset = 0x018

    //
    //  File attributes.  The first byte is the standard "Fat"
    //  flags for this file.
    //

    ULONG FileAttributes;                                           //  offset = 0x020

    //
    //  Maximum file versions allowed for this file.  If this field
    //  is 0, then versioning is not enabled for this file.  If
    //  there are multiple files with the same version, then the
    //  value of Maximum file versions in the file with the highest
    //  version is the correct one.
    //

    ULONG MaximumVersions;                                          //  offset = 0x024

    //
    //  Version number for this file.
    //

    ULONG VersionNumber;                                            //  offset = 0x028

    //
    //  Class Id from the bidirectional Class Id index
    //

    ULONG ClassId;                                                  //  offset = 0x02c

    //
    //  Id for file owner, from bidir security index
    //

    ULONG OwnerId;                                                  //  offset = 0x030

    //
    //  SecurityId for the file - translates via bidir index to
    //  granted access Acl.
    //

    ULONG SecurityId;                                               //  offset = 0x034

    //
    //  Current amount of quota that has been charged for all the
    //  streams of this file.  Changed in same transaction with the
    //  quota file itself.
    //

    ULONGLONG QuotaCharged;                                         //  offset = 0x038

    //
    //  Update sequence number for this file.
    //

    ULONGLONG Usn;                                                  //  offset = 0x040

} STANDARD_INFORMATION;                                             //  sizeof = 0x048
typedef STANDARD_INFORMATION *PSTANDARD_INFORMATION;

//
//  Large Standard Information Attribute.  We use this to find the
//  security ID field.
//

typedef struct LARGE_STANDARD_INFORMATION {

    //
    //  File creation time.
    //

    LONGLONG CreationTime;                                          //  offset = 0x000

    //
    //  Last time the DATA attribute was modified.
    //

    LONGLONG LastModificationTime;                                  //  offset = 0x008

    //
    //  Last time any attribute was modified.
    //

    LONGLONG LastChangeTime;                                        //  offset = 0x010

    //
    //  Last time the file was accessed.  This field may not always
    //  be updated (write-protected media), and even when it is
    //  updated, it may only be updated if the time would change by
    //  a certain delta.  It is meant to tell someone approximately
    //  when the file was last accessed, for purposes of possible
    //  file migration.
    //

    LONGLONG LastAccessTime;                                        //  offset = 0x018

    //
    //  File attributes.  The first byte is the standard "Fat"
    //  flags for this file.
    //

    ULONG FileAttributes;                                           //  offset = 0x020

    //
    //  Maximum file versions allowed for this file.  If this field
    //  is 0, then versioning is not enabled for this file.  If
    //  there are multiple files with the same version, then the
    //  value of Maximum file versions in the file with the highest
    //  version is the correct one.
    //

    ULONG MaximumVersions;                                          //  offset = 0x024

    //
    //  Version number for this file.
    //

    ULONG VersionNumber;                                            //  offset = 0x028

    ULONG UnusedUlong;

    //
    //  Id for file owner, from bidir security index
    //

    ULONG OwnerId;                                                  //  offset = 0x030

    //
    //  SecurityId for the file - translates via bidir index to
    //  granted access Acl.
    //

    ULONG SecurityId;                                               //  offset = 0x034

} LARGE_STANDARD_INFORMATION;
typedef LARGE_STANDARD_INFORMATION *PLARGE_STANDARD_INFORMATION;

//
//  This was the size of standard information prior to NT4.0
//

#define SIZEOF_OLD_STANDARD_INFORMATION  (0x30)

//
//  Define the file attributes, starting with the Fat attributes.
//

#define FAT_DIRENT_ATTR_READ_ONLY        (0x01)
#define FAT_DIRENT_ATTR_HIDDEN           (0x02)
#define FAT_DIRENT_ATTR_SYSTEM           (0x04)
#define FAT_DIRENT_ATTR_VOLUME_ID        (0x08)
#define FAT_DIRENT_ATTR_ARCHIVE          (0x20)
#define FAT_DIRENT_ATTR_DEVICE           (0x40)


//
//  Attribute List.  Because there is not a special header that goes
//  before the list of attribute list entries we do not need to
//  declare an attribute list header
//

//
//  The Attributes List attribute is an ordered-list of quad-word
//  aligned ATTRIBUTE_LIST_ENTRY records.  It is ordered first by
//  Attribute Type Code, and then by Attribute Name (if present).
//  No two attributes may exist with the same type code, name and
//  LowestVcn.  This also means that at most one occurrence of a
//  given Attribute Type Code without a name may exist.
//
//  To binary search this attribute, it is first necessary to make a
//  quick pass through it and form a list of pointers, since the
//  optional name makes it variable-length.
//

typedef struct _ATTRIBUTE_LIST_ENTRY {

    //
    //  Attribute Type Code, the first key on which this list is
    //  ordered.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;                          //  offset = 0x000

    //
    //  Size of this record in bytes, including the optional name
    //  appended to this structure.
    //

    USHORT RecordLength;                                            //  offset = 0x004

    //
    //  Length of attribute name, if there is one.  If a name exists
    //  (AttributeNameLength != 0), then it is a Unicode string of
    //  the specified number of characters immediately following
    //  this record.  This is the second key on which this list is
    //  ordered.
    //

    UCHAR AttributeNameLength;                                      //  offset = 0x006

    //
    //  Reserved to get to quad-word boundary
    //

    UCHAR AttributeNameOffset;                                      //  offset = 0x007

    //
    //  Lowest Vcn for this attribute.  This field is always zero
    //  unless the attribute requires multiple file record segments
    //  to describe all of its runs, and this is a reference to a
    //  segment other than the first one.  The field says what the
    //  lowest Vcn is that is described by the referenced segment.
    //

    VCN LowestVcn;                                                  //  offset = 0x008

    //
    //  Reference to the MFT segment in which the attribute resides.
    //

    MFT_SEGMENT_REFERENCE SegmentReference;                         //  offset = 0x010

    //
    //  The file-record-unique attribute instance number for this
    //  attribute.
    //

    USHORT Instance;                                                //  offset = 0x018

    //
    //  When creating an attribute list entry, start the name here.
    //  (When reading one, use the AttributeNameOffset field.)
    //

    WCHAR AttributeName[1];                                         //  offset = 0x01A

} ATTRIBUTE_LIST_ENTRY;
typedef ATTRIBUTE_LIST_ENTRY *PATTRIBUTE_LIST_ENTRY;


typedef struct _DUPLICATED_INFORMATION {

    //
    //  File creation time.
    //

    LONGLONG CreationTime;                                          //  offset = 0x000

    //
    //  Last time the DATA attribute was modified.
    //

    LONGLONG LastModificationTime;                                  //  offset = 0x008

    //
    //  Last time any attribute was modified.
    //

    LONGLONG LastChangeTime;                                        //  offset = 0x010

    //
    //  Last time the file was accessed.  This field may not always
    //  be updated (write-protected media), and even when it is
    //  updated, it may only be updated if the time would change by
    //  a certain delta.  It is meant to tell someone approximately
    //  when the file was last accessed, for purposes of possible
    //  file migration.
    //

    LONGLONG LastAccessTime;                                        //  offset = 0x018

    //
    //  Allocated Length of the file in bytes.  This is obviously
    //  an even multiple of the cluster size.  (Not present if
    //  LowestVcn != 0.)
    //

    LONGLONG AllocatedLength;                                       //  offset = 0x020

    //
    //  File Size in bytes (highest byte which may be read + 1).
    //  (Not present if LowestVcn != 0.)
    //

    LONGLONG FileSize;                                              //  offset = 0x028

    //
    //  File attributes.  The first byte is the standard "Fat"
    //  flags for this file.
    //

    ULONG FileAttributes;                                           //  offset = 0x030

    //
    //  This union enables the retrieval of the tag in reparse
    //  points when there are no Ea's.
    //

    union {

        struct {

            //
            //  The size of buffer needed to pack these Ea's
            //

            USHORT  PackedEaSize;                                   //  offset = 0x034

            //
            //  Reserved for quad word alignment
            //

            USHORT  Reserved;                                       //  offset = 0x036
        };

        //
        //  The tag of the data in a reparse point. It represents
        //  the type of a reparse point. It enables different layered
        //  filters to operate on their own reparse points.
        //

        ULONG  ReparsePointTag;                                     //  offset = 0x034
    };

} DUPLICATED_INFORMATION;                                           //  sizeof = 0x038
typedef DUPLICATED_INFORMATION *PDUPLICATED_INFORMATION;

//
//  This bit is duplicated from the file record, to indicate that
//  this file has a file name index present (is a "directory").
//

#define DUP_FILE_NAME_INDEX_PRESENT      (0x10000000)

//
//  This bit is duplicated from the file record, to indicate that
//  this file has a view index present, such as the quota or
//  object id index.
//

#define DUP_VIEW_INDEX_PRESENT        (0x20000000)

//
//  The following macros examine fields of the duplicated structure.
//

#define IsDirectory( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             DUP_FILE_NAME_INDEX_PRESENT ))

#define IsViewIndex( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             DUP_VIEW_INDEX_PRESENT ))

#define IsReadOnly( DUPLICATE )                                         \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_READONLY ))

#define IsHidden( DUPLICATE )                                           \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_HIDDEN ))

#define IsSystem( DUPLICATE )                                           \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_SYSTEM ))

#define IsEncrypted( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_ENCRYPTED ))

#define IsCompressed( DUPLICATE )                                       \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_COMPRESSED ))

#define BooleanIsDirectory( DUPLICATE )                                        \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    DUP_FILE_NAME_INDEX_PRESENT ))

#define BooleanIsReadOnly( DUPLICATE )                                         \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    FILE_ATTRIBUTE_READONLY ))

#define BooleanIsHidden( DUPLICATE )                                           \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    FILE_ATTRIBUTE_HIDDEN ))

#define BooleanIsSystem( DUPLICATE )                                           \
    (BooleanFlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
                    FILE_ATTRIBUTE_SYSTEM ))

#define HasReparsePoint( DUPLICATE )                                        \
    (FlagOn( ((PDUPLICATED_INFORMATION) (DUPLICATE))->FileAttributes,   \
             FILE_ATTRIBUTE_REPARSE_POINT ))


//
//  File Name attribute.  A file has one File Name attribute for
//  every directory it is entered into (hard links).
//

typedef struct _FILE_NAME {

    //
    //  This is a File Reference to the directory file which indexes
    //  to this name.
    //

    FILE_REFERENCE ParentDirectory;                                 //  offset = 0x000

    //
    //  Information for faster directory operations.
    //

    DUPLICATED_INFORMATION Info;                                    //  offset = 0x008

    //
    //  Length of the name to follow, in (Unicode) characters.
    //

    UCHAR FileNameLength;                                           //  offset = 0x040

    //
    //  FILE_NAME_xxx flags
    //

    UCHAR Flags;                                                    //  offset = 0x041

    //
    //  First character of Unicode File Name
    //

    WCHAR FileName[1];                                              //  offset = 0x042

} FILE_NAME;
typedef FILE_NAME *PFILE_NAME;

//
//  File Name flags
//

#define FILE_NAME_NTFS                   (0x01)
#define FILE_NAME_DOS                    (0x02)

//
//  The maximum file name length is 255 (in chars)
//

#define NTFS_MAX_FILE_NAME_LENGTH       (255)

//
//  The maximum number of links on a file is 1024
//

#define NTFS_MAX_LINK_COUNT             (1024)

//
//  This flag is not part of the disk structure, but is defined here
//  to explain its use and avoid possible future collisions.  For
//  enumerations of "directories" this bit may be set to convey to
//  the collating routine that it should not match file names that
//  only have the FILE_NAME_DOS bit set.
//

#define FILE_NAME_IGNORE_DOS_ONLY        (0x80)

#define NtfsFileNameSizeFromLength(LEN) (                   \
    (sizeof( FILE_NAME ) + LEN - sizeof( WCHAR ))           \
)

#define NtfsFileNameSize(PFN) (                                             \
    (sizeof( FILE_NAME ) + ((PFN)->FileNameLength - 1) * sizeof( WCHAR ))   \
)


//
//  Object id attribute.
//

//
//  On disk representation of an object id.
//

#define OBJECT_ID_KEY_LENGTH      16
#define OBJECT_ID_EXT_INFO_LENGTH 48

typedef struct _NTFS_OBJECTID_INFORMATION {

    //
    //  Data the filesystem needs to identify the file with this object id.
    //

    FILE_REFERENCE FileSystemReference;

    //
    //  This portion of the object id is not indexed, it's just
    //  some metadata for the user's benefit.
    //

    UCHAR ExtendedInfo[OBJECT_ID_EXT_INFO_LENGTH];

} NTFS_OBJECTID_INFORMATION, *PNTFS_OBJECTID_INFORMATION;

#define OBJECT_ID_FLAG_CORRUPT           (0x00000001)


//
//  Security Descriptor attribute.  This is just a normal attribute
//  stream containing a security descriptor as defined by NT
//  security and is really treated pretty opaque by NTFS.
//

//
//  Security descriptors are stored only once on a volume since there may be
//  many files that share the same descriptor bits.  Typically each principal
//  will create files with a single descriptor.
//
//  The descriptors themselves are stored in a stream, packed on double quad word
//  boundaries. No descriptor will span a 256K cache boundary.  The descriptors are
//  assigned a ULONG Id each time a unique descriptor is stored.  Prefixing each
//  descriptor in the stream is the hash of the descriptor, the assigned security 
//  ID, the length, and the offset within the stream to the beginning of the structure.
//
//  For robustness, all security descriptors are written to the stream in two
//  different places, with a fixed offset between them.  The fixed offset is the
//  size of the VACB_MAPPING_GRANULARITY.
//
//  An index is used to map from a security Id to offset within the stream.  This
//  is used to retrieve the security descriptor bits for access validation.  The key
//  format is simply the ULONG security Id.  The data portion of the index record
//  is the header of the security descriptor in the stream (see above paragraph).
//
//  Another index is used to map from a hash to offset within the stream.  To
//  simplify the job of the indexing package, the key used in this index is the
//  hash followed by the assigned Id.  When a security descriptor is stored,
//  a hash is computed and an approximate seek is made on this index.  As entries
//  are enumerated in the index, the descriptor stream is mapped and the security
//  descriptor bits are compared.  The key format is a structure that contains
//  the hash and then the Id.  The collation routine tests the hash before the Id.
//  The data portion of the index record is the header of the security descriptor.
//

//
//  Key structure for Security Hash index
//

typedef struct _SECURITY_HASH_KEY
{
    ULONG   Hash;                           //  Hash value for descriptor
    ULONG   SecurityId;                     //  Security Id (guaranteed unique)
} SECURITY_HASH_KEY, *PSECURITY_HASH_KEY;

//
//  Key structure for Security Id index is simply the SECURITY_ID itself
//

//
//  Header for security descriptors in the security descriptor stream.  This
//  is the data format for all indexes and is part of SharedSecurity
//

typedef struct _SECURITY_DESCRIPTOR_HEADER
{
    SECURITY_HASH_KEY HashKey;              //  Hash value for the descriptor
    ULONGLONG Offset;                       //  offset to beginning of header
    ULONG   Length;                         //  Length in bytes
} SECURITY_DESCRIPTOR_HEADER, *PSECURITY_DESCRIPTOR_HEADER;

#define GETSECURITYDESCRIPTORLENGTH(HEADER)         \
    ((HEADER)->Length - sizeof( SECURITY_DESCRIPTOR_HEADER ))

#define SetSecurityDescriptorLength(HEADER,LENGTH)  \
    ((HEADER)->Length = (LENGTH) + sizeof( SECURITY_DESCRIPTOR_HEADER ))

//
//  Define standard values for well-known security IDs
//

#define SECURITY_ID_INVALID              (0x00000000)
#define SECURITY_ID_FIRST                (0x00000100)


//
//  Volume Name attribute.  This attribute is just a normal
//  attribute stream containing the unicode characters that make up
//  the volume label.  It is an attribute of the Mft File.
//


//
//  Volume Information attribute.  This attribute is only intended
//  to be used on the Volume DASD file.
//

typedef struct _VOLUME_INFORMATION {

    LONGLONG Reserved;

    //
    //  Major and minor version number of NTFS on this volume,
    //  starting with 1.0.  The major and minor version numbers are
    //  set from the major and minor version of the Format and NTFS
    //  implementation for which they are initialized.  The policy
    //  for incementing major and minor versions will always be
    //  decided on a case by case basis, however, the following two
    //  paragraphs attempt to suggest an approximate strategy.
    //
    //  The major version number is incremented if/when a volume
    //  format change is made which requires major structure changes
    //  (hopefully never?).  If an implementation of NTFS sees a
    //  volume with a higher major version number, it should refuse
    //  to mount the volume.  If a newer implementation of NTFS sees
    //  an older major version number, it knows the volume cannot be
    //  accessed without performing a one-time conversion.
    //
    //  The minor version number is incremented if/when minor
    //  enhancements are made to a major version, which potentially
    //  support enhanced functionality through additional file or
    //  attribute record fields, or new system-defined files or
    //  attributes.  If an older implementation of NTFS sees a newer
    //  minor version number on a volume, it may issue some kind of
    //  warning, but it will proceed to access the volume - with
    //  presumably some degradation in functionality compared to the
    //  version of NTFS which initialized the volume.  If a newer
    //  implementation of NTFS sees a volume with an older minor
    //  version number, it may issue a warning and proceed.  In this
    //  case, it may choose to increment the minor version number on
    //  the volume and begin full or incremental upgrade of the
    //  volume on an as-needed basis.  It may also leave the minor
    //  version number unchanged, until some sort of explicit
    //  directive from the user specifies that the minor version
    //  should be updated.
    //

    UCHAR MajorVersion;                                             //  offset = 0x008

    UCHAR MinorVersion;                                             //  offset = 0x009

    //
    //  VOLUME_xxx flags.
    //

    USHORT VolumeFlags;                                             //  offset = 0x00A

    //
    //  The following fields will only exist on version 4 and greater
    //

    UCHAR LastMountedMajorVersion;                                  //  offset = 0x00C
    UCHAR LastMountedMinorVersion;                                  //  offset = 0x00D

    USHORT Reserved2;                                               //  offset = 0x00E

    USN LowestOpenUsn;                                              //  offset = 0x010

} VOLUME_INFORMATION;                                               //  sizeof = 0xC or 0x18
typedef VOLUME_INFORMATION *PVOLUME_INFORMATION;




//
//  Volume is Dirty
//

#define VOLUME_DIRTY                     (0x0001)
#define VOLUME_RESIZE_LOG_FILE           (0x0002)
#define VOLUME_UPGRADE_ON_MOUNT          (0x0004)
#define VOLUME_MOUNTED_ON_40             (0x0008)
#define VOLUME_DELETE_USN_UNDERWAY       (0x0010)
#define VOLUME_REPAIR_OBJECT_ID          (0x0020)

#define VOLUME_CHKDSK_RAN_ONCE           (0x4000)   // this bit is used by autochk/chkdsk only
#define VOLUME_MODIFIED_BY_CHKDSK        (0x8000)


//
//  Common Index Header for Index Root and Index Allocation Buffers.
//  This structure is used to locate the Index Entries and describe
//  the free space in either of the two structures above.
//

typedef struct _INDEX_HEADER {

    //
    //  Offset from the start of this structure to the first Index
    //  Entry.
    //

    ULONG FirstIndexEntry;                                          //  offset = 0x000

    //
    //  Offset from the start of the first index entry to the first
    //  (quad-word aligned) free byte.
    //

    ULONG FirstFreeByte;                                            //  offset = 0x004

    //
    //  Total number of bytes available, from the start of the first
    //  index entry.  In the Index Root, this number must always be
    //  equal to FirstFreeByte, as the total attribute record will
    //  be grown and shrunk as required.
    //

    ULONG BytesAvailable;                                           //  offset = 0x008

    //
    //  INDEX_xxx flags.
    //

    UCHAR Flags;                                                    //  offset = 0x00C

    //
    //  Reserved to round up to quad word boundary.
    //

    UCHAR Reserved[3];                                              //  offset = 0x00D

} INDEX_HEADER;                                                     //  sizeof = 0x010
typedef INDEX_HEADER *PINDEX_HEADER;

//
//  INDEX_xxx flags
//

//
//  This Index or Index Allocation buffer is an intermediate node,
//  as opposed to a leaf in the Btree.  All Index Entries will have
//  a block down pointer.
//

#define INDEX_NODE                       (0x01)

//
//  Index Root attribute.  The index attribute consists of an index
//  header record followed by one or more index entries.
//

typedef struct _INDEX_ROOT {

    //
    //  Attribute Type Code of the attribute being indexed.
    //

    ATTRIBUTE_TYPE_CODE IndexedAttributeType;                       //  offset = 0x000

    //
    //  Collation rule for this index.
    //

    COLLATION_RULE CollationRule;                                   //  offset = 0x004

    //
    //  Size of Index Allocation Buffer in bytes.
    //

    ULONG BytesPerIndexBuffer;                                      //  offset = 0x008

    //
    //  Size of Index Allocation Buffers in units of blocks.
    //  Blocks will be clusters when index buffer is equal or
    //  larger than clusters and log blocks for large
    //  cluster systems.
    //

    UCHAR BlocksPerIndexBuffer;                                     //  offset = 0x00C

    //
    //  Reserved to round to quad word boundary.
    //

    UCHAR Reserved[3];                                              //  offset = 0x00D

    //
    //  Index Header to describe the Index Entries which follow
    //

    INDEX_HEADER IndexHeader;                                       //  offset = 0x010

} INDEX_ROOT;                                                       //  sizeof = 0x020
typedef INDEX_ROOT *PINDEX_ROOT;

//
//  Index Allocation record is used for non-root clusters of the
//  b-tree.  Each non root cluster is contained in the data part of
//  the index allocation attribute.  Each cluster starts with an
//  index allocation list header and is followed by one or more
//  index entries.
//

typedef struct _INDEX_ALLOCATION_BUFFER {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "INDX" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    MULTI_SECTOR_HEADER MultiSectorHeader;                          //  offset = 0x000

    //
    //  Log File Sequence Number of last logged update to this Index
    //  Allocation Buffer.
    //

    LSN Lsn;                                                        //  offset = 0x008

    //
    //  We store the index block of this Index Allocation buffer for
    //  convenience and possible consistency checking.
    //

    VCN ThisBlock;                                                  //  offset = 0x010

    //
    //  Index Header to describe the Index Entries which follow
    //

    INDEX_HEADER IndexHeader;                                       //  offset = 0x018

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the Index Allocation Buffer.
    //

    UPDATE_SEQUENCE_ARRAY UpdateSequenceArray;                      //  offset = 0x028

} INDEX_ALLOCATION_BUFFER;
typedef INDEX_ALLOCATION_BUFFER *PINDEX_ALLOCATION_BUFFER;

//
//  Default size of index buffer and index blocks.
//

#define DEFAULT_INDEX_BLOCK_SIZE        (0x200)
#define DEFAULT_INDEX_BLOCK_BYTE_SHIFT  (9)

//
//  Index Entry.  This structure is common to both the resident
//  index list attribute and the Index Allocation records
//

typedef struct _INDEX_ENTRY {

    //
    //  Define a union to distinguish directory indices from view indices
    //

    union {

        //
        //  Reference to file containing the attribute with this
        //  attribute value.
        //

        FILE_REFERENCE FileReference;                               //  offset = 0x000

        //
        //  For views, describe the Data Offset and Length in bytes
        //

        struct {

            USHORT DataOffset;                                      //  offset = 0x000
            USHORT DataLength;                                      //  offset = 0x001
            ULONG ReservedForZero;                                  //  offset = 0x002
        };
    };

    //
    //  Length of this index entry, in bytes.
    //

    USHORT Length;                                                  //  offset = 0x008

    //
    //  Length of attribute value, in bytes.  The attribute value
    //  immediately follows this record.
    //

    USHORT AttributeLength;                                         //  offset = 0x00A

    //
    //  INDEX_ENTRY_xxx Flags.
    //

    USHORT Flags;                                                   //  offset = 0x00C

    //
    //  Reserved to round to quad-word boundary.
    //

    USHORT Reserved;                                                //  offset = 0x00E

    //
    //  If this Index Entry is an intermediate node in the tree, as
    //  determined by the INDEX_xxx flags, then a VCN  is stored at
    //  the end of this entry at Length - sizeof(VCN).
    //

} INDEX_ENTRY;                                                      //  sizeof = 0x010
typedef INDEX_ENTRY *PINDEX_ENTRY;

//
//  INDEX_ENTRY_xxx flags
//

//
//  This entry is currently in the intermediate node form, i.e., it
//  has a Vcn at the end.
//

#define INDEX_ENTRY_NODE                 (0x0001)

//
//  This entry is the special END record for the Index or Index
//  Allocation buffer.
//

#define INDEX_ENTRY_END                  (0x0002)

//
//  This flag is *not* part of the on-disk structure.  It is defined
//  and reserved here for the convenience of the implementation to
//  help avoid allocating buffers from the pool and copying.
//

#define INDEX_ENTRY_POINTER_FORM         (0x8000)

#define NtfsIndexEntryBlock(IE) (                                       \
    *(PLONGLONG)((PCHAR)(IE) + (ULONG)(IE)->Length - sizeof(LONGLONG))  \
    )

#define NtfsSetIndexEntryBlock(IE,IB) {                                         \
    *(PLONGLONG)((PCHAR)(IE) + (ULONG)(IE)->Length - sizeof(LONGLONG)) = (IB);  \
    }

#define NtfsFirstIndexEntry(IH) (                       \
    (PINDEX_ENTRY)((PCHAR)(IH) + (IH)->FirstIndexEntry) \
    )

#define NtfsNextIndexEntry(IE) (                        \
    (PINDEX_ENTRY)((PCHAR)(IE) + (ULONG)(IE)->Length)   \
    )

#define NtfsCheckIndexBound(IE, IH) {                                                               \
    if (((PCHAR)(IE) < (PCHAR)(IH)) ||                                                              \
        (((PCHAR)(IE) + sizeof( INDEX_ENTRY )) > ((PCHAR)Add2Ptr((IH), (IH)->BytesAvailable)))) {   \
        NtfsRaiseStatus(IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );                        \
    }                                                                                               \
}


//
//  MFT Bitmap attribute
//
//  The MFT Bitmap is simply a normal attribute stream in which
//  there is one bit to represent the allocation state of each File
//  Record Segment in the MFT.  Bit clear means free, and bit set
//  means allocated.
//
//  Whenever the MFT Data attribute is extended, the MFT Bitmap
//  attribute must also be extended.  If the bitmap is still in a
//  file record segment for the MFT, then it must be extended and
//  the new bits cleared.  When the MFT Bitmap is in the Nonresident
//  form, then the allocation should always be sufficient to store
//  enough bits to describe the MFT, however ValidDataLength insures
//  that newly allocated space to the MFT Bitmap has an initial
//  value of all 0's.  This means that if the MFT Bitmap is extended,
//  the newly represented file record segments are automatically in
//  the free state.
//
//  No structure definition is required; the positional offset of
//  the file record segment is exactly equal to the bit offset of
//  its corresponding bit in the Bitmap.
//


//
//  USN Journal Instance
//
//  The following describe the current instance of the Usn journal.
//

typedef struct _USN_JOURNAL_INSTANCE {

#ifdef __cplusplus
    CREATE_USN_JOURNAL_DATA JournalData;
#else   // __cplusplus
    CREATE_USN_JOURNAL_DATA;
#endif  // __cplusplus

    ULONGLONG JournalId;
    USN LowestValidUsn;

} USN_JOURNAL_INSTANCE, *PUSN_JOURNAL_INSTANCE;

//
//  Reparse point index keys.
//
//  The index with all the reparse points that exist in a volume at a
//  given time contains entries with keys of the form
//                        <reparse tag, file record id>.
//  The data part of these records is empty.
//

typedef struct _REPARSE_INDEX_KEY {

    //
    //  The tag of the reparse point.
    //

    ULONG FileReparseTag;

    //
    //  The file record Id where the reparse point is set.
    //

    LARGE_INTEGER FileId;

} REPARSE_INDEX_KEY, *PREPARSE_INDEX_KEY;



//
//  Ea Information attribute
//
//  This attribute is only present if the file/directory also has an
//  EA attribute.  It is used to store common EA query information.
//

typedef struct _EA_INFORMATION {

    //
    //  The size of buffer needed to pack these Ea's
    //

    USHORT PackedEaSize;                                            //  offset = 0x000

    //
    //  This is the count of Ea's with their NEED_EA
    //  bit set.
    //

    USHORT NeedEaCount;                                             //  offset = 0x002

    //
    //  The size of the buffer needed to return all Ea's
    //  in their unpacked form.
    //

    ULONG UnpackedEaSize;                                           //  offset = 0x004

}  EA_INFORMATION;                                                  //  sizeof = 0x008
typedef EA_INFORMATION *PEA_INFORMATION;


//
//  Define the struture of the quota data in the quota index.  The key for
//  the quota index is the 32 bit owner id.
//

typedef struct _QUOTA_USER_DATA {
    ULONG QuotaVersion;
    ULONG QuotaFlags;
    ULONGLONG QuotaUsed;
    ULONGLONG QuotaChangeTime;
    ULONGLONG QuotaThreshold;
    ULONGLONG QuotaLimit;
    ULONGLONG QuotaExceededTime;
    SID QuotaSid;
} QUOTA_USER_DATA, *PQUOTA_USER_DATA;

//
//  Define the size of the quota user data structure without the quota SID.
//

#define SIZEOF_QUOTA_USER_DATA FIELD_OFFSET(QUOTA_USER_DATA, QuotaSid)

//
//  Define the current version of the quote user data.
//

#define QUOTA_USER_VERSION 2

//
//  Define the quota flags.
//

#define QUOTA_FLAG_DEFAULT_LIMITS           (0x00000001)
#define QUOTA_FLAG_LIMIT_REACHED            (0x00000002)
#define QUOTA_FLAG_ID_DELETED               (0x00000004)
#define QUOTA_FLAG_USER_MASK                (0x00000007)

//
//  The following flags are only stored in the quota defaults index entry.
//

#define QUOTA_FLAG_TRACKING_ENABLED         (0x00000010)
#define QUOTA_FLAG_ENFORCEMENT_ENABLED      (0x00000020)
#define QUOTA_FLAG_TRACKING_REQUESTED       (0x00000040)
#define QUOTA_FLAG_LOG_THRESHOLD            (0x00000080)
#define QUOTA_FLAG_LOG_LIMIT                (0x00000100)
#define QUOTA_FLAG_OUT_OF_DATE              (0x00000200)
#define QUOTA_FLAG_CORRUPT                  (0x00000400)
#define QUOTA_FLAG_PENDING_DELETES          (0x00000800)

//
//  Define special quota owner ids.
//

#define QUOTA_INVALID_ID        0x00000000
#define QUOTA_DEFAULTS_ID       0x00000001
#define QUOTA_FISRT_USER_ID     0x00000100


//
//  Attribute Definition Table
//
//  The following struct defines the columns of this table.
//  Initially they will be stored as simple records, and ordered by
//  Attribute Type Code.
//

typedef struct _ATTRIBUTE_DEFINITION_COLUMNS {

    //
    //  Unicode attribute name.
    //

    WCHAR AttributeName[64];                                        //  offset = 0x000

    //
    //  Attribute Type Code.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;                          //  offset = 0x080

    //
    //  Default Display Rule for this attribute
    //

    DISPLAY_RULE DisplayRule;                                       //  offset = 0x084

    //
    //  Default Collation rule
    //

    COLLATION_RULE CollationRule;                                   //  offset = 0x088

    //
    //  ATTRIBUTE_DEF_xxx flags
    //

    ULONG Flags;                                                    //  offset = 0x08C

    //
    //  Minimum Length for attribute, if present.
    //

    LONGLONG MinimumLength;                                         //  offset = 0x090

    //
    //  Maximum Length for attribute.
    //

    LONGLONG MaximumLength;                                         //  offset = 0x098

} ATTRIBUTE_DEFINITION_COLUMNS;                                     //  sizeof = 0x0A0
typedef ATTRIBUTE_DEFINITION_COLUMNS *PATTRIBUTE_DEFINITION_COLUMNS;

//
//  ATTRIBUTE_DEF_xxx flags
//

//
//  This flag is set if the attribute may be indexed.
//

#define ATTRIBUTE_DEF_INDEXABLE          (0x00000002)

//
//  This flag is set if the attribute may occur more than once, such
//  as is allowed for the File Name attribute.
//

#define ATTRIBUTE_DEF_DUPLICATES_ALLOWED (0x00000004)

//
//  This flag is set if the value of the attribute may not be
//  entirely null, i.e., all binary 0's.
//

#define ATTRIBUTE_DEF_MAY_NOT_BE_NULL    (0x00000008)

//
//  This attribute must be indexed, and no two attributes may exist
//  with the same value in the same file record segment.
//

#define ATTRIBUTE_DEF_MUST_BE_INDEXED    (0x00000010)

//
//  This attribute must be named, and no two attributes may exist
//  with the same name in the same file record segment.
//

#define ATTRIBUTE_DEF_MUST_BE_NAMED      (0x00000020)

//
//  This attribute must be in the Resident Form.
//

#define ATTRIBUTE_DEF_MUST_BE_RESIDENT   (0x00000040)

//
//  Modifications to this attribute should be logged even if the
//  attribute is nonresident.
//

#define ATTRIBUTE_DEF_LOG_NONRESIDENT    (0X00000080)



//
//  MACROS
//
//  Define some macros that are helpful for manipulating NTFS on
//  disk structures.
//

//
//  The following macro returns the first attribute record in a file
//  record segment.
//
//      PATTRIBUTE_RECORD_HEADER
//      NtfsFirstAttribute (
//          IN PFILE_RECORD_SEGMENT_HEADER FileRecord
//          );
//
//  The following macro takes a pointer to an attribute record (or
//  attribute list entry) and returns a pointer to the next
//  attribute record (or attribute list entry) in the list
//
//      PVOID
//      NtfsGetNextRecord (
//          IN PATTRIB_RECORD or PATTRIB_LIST_ENTRY Struct
//          );
//
//
//  The following macro takes as input a attribute record or
//  attribute list entry and initializes a string variable to the
//  name found in the record or entry.  The memory used for the
//  string buffer is the memory found in the attribute.
//
//      VOID
//      NtfsInitializeStringFromAttribute (
//          IN OUT PUNICODE_STRING Name,
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//      VOID
//      NtfsInitializeStringFromEntry (
//          IN OUT PUNICODE_STRING Name,
//          IN PATTRIBUTE_LIST_ENTRY Entry
//          );
//
//
//  The following two macros assume resident form and should only be
//  used when that state is known.  They return a pointer to the
//  value a resident attribute or a pointer to the byte one beyond
//  the value.
//
//      PVOID
//      NtfsGetValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//      PVOID
//      NtfsGetBeyondValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//  The following two macros return a boolean value indicating if
//  the input attribute record is of the specified type code, or the
//  indicated value.  The equivalent routine to comparing attribute
//  names cannot be defined as a macro and is declared in AttrSup.c
//
//      BOOLEAN
//      NtfsEqualAttributeTypeCode (
//          IN PATTRIBUTE_RECORD_HEADER Attribute,
//          IN ATTRIBUTE_TYPE_CODE Code
//          );
//
//      BOOLEAN
//      NtfsEqualAttributeValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute,
//          IN PVOID Value,
//          IN ULONG Length
//          );
//

#define NtfsFirstAttribute(FRS) (                                          \
    (PATTRIBUTE_RECORD_HEADER)((PCHAR)(FRS) + (FRS)->FirstAttributeOffset) \
)

#define NtfsGetNextRecord(STRUCT) (                    \
    (PVOID)((PUCHAR)(STRUCT) + (STRUCT)->RecordLength) \
)

#define NtfsCheckRecordBound(PTR, SPTR, SIZ) {                                          \
    if (((PCHAR)(PTR) < (PCHAR)(SPTR)) || ((PCHAR)(PTR) >= ((PCHAR)(SPTR) + (SIZ)))) {  \
        NtfsRaiseStatus(IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );            \
    }                                                                                   \
}

#define NtfsInitializeStringFromAttribute(NAME,ATTRIBUTE) {                \
    (NAME)->Length = (USHORT)(ATTRIBUTE)->NameLength << 1;                 \
    (NAME)->MaximumLength = (NAME)->Length;                                \
    (NAME)->Buffer = (PWSTR)Add2Ptr((ATTRIBUTE), (ATTRIBUTE)->NameOffset); \
}

#define NtfsInitializeStringFromEntry(NAME,ENTRY) {                        \
    (NAME)->Length = (USHORT)(ENTRY)->AttributeNameLength << 1;            \
    (NAME)->MaximumLength = (NAME)->Length;                                \
    (NAME)->Buffer = (PWSTR)((ENTRY) + 1);                                 \
}

#define NtfsGetValue(ATTRIBUTE) (                                \
    Add2Ptr((ATTRIBUTE), (ATTRIBUTE)->Form.Resident.ValueOffset) \
)

#define NtfsGetBeyondValue(ATTRIBUTE) (                                      \
    Add2Ptr(NtfsGetValue(ATTRIBUTE), (ATTRIBUTE)->Form.Resident.ValueLength) \
)

#define NtfsEqualAttributeTypeCode(A,C) ( \
    (C) == (A)->TypeCode                  \
)

#define NtfsEqualAttributeValue(A,V,L) (     \
    NtfsIsAttributeResident(A) &&            \
    (A)->Form.Resident.ValueLength == (L) && \
    RtlEqualMemory(NtfsGetValue(A),(V),(L))  \
)

#pragma pack()

#endif //  _NTFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfsdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsData.h

Abstract:

    This module declares the global data used by the Ntfs file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#ifndef _NTFSDATA_
#define _NTFSDATA_

//
//  The following are used to determine what level of protection to attach
//  to system files and attributes.
//

extern BOOLEAN NtfsProtectSystemFiles;
extern BOOLEAN NtfsProtectSystemAttributes;

//
//  The following is used to indicate the multiplier value for the Mft zone.
//

extern ULONG NtfsMftZoneMultiplier;

//
//  Debug code for finding corruption.
//

/*
#if (DBG || defined( NTFS_FREE_ASSERTS ))
*/
extern BOOLEAN NtfsBreakOnCorrupt;
/*
#endif
*/

//
//  Enable compression on the wire.
//

extern BOOLEAN NtfsEnableCompressedIO;

//
//  Default restart version.
//

extern ULONG NtfsDefaultRestartVersion;

//
//  Performance statistics
//

extern ULONG NtfsMaxDelayedCloseCount;
extern ULONG NtfsMinDelayedCloseCount;
extern ULONG NtfsThrottleCreates;
extern ULONG NtfsFailedHandedOffPagingFileOps;
extern ULONG NtfsFailedPagingFileOps;
extern ULONG NtfsFailedHandedOffPagingReads;
extern ULONG NtfsFailedPagingReads;
extern ULONG NtfsFailedLfsRestart;

extern ULONG NtfsCleanCheckpoints;
extern ULONG NtfsPostRequests;

//
//  The global fsd data record
//

extern NTFS_DATA NtfsData;

//
//  Mutant to synchronize creation of stream files. This can be acquired recursively
//  which we need in this case
//

extern KMUTANT StreamFileCreationMutex;

//
//  Notification event for creation of encrypted files.
//

extern KEVENT NtfsEncryptionPendingEvent;
#ifdef KEITHKA
extern ULONG EncryptionPendingCount;
#endif

//
//  A mutex and queue of NTFS MCBS that will be freed
//  if we reach over a certain threshold
//

extern FAST_MUTEX NtfsMcbFastMutex;
extern LIST_ENTRY NtfsMcbLruQueue;

extern ULONG NtfsMcbHighWaterMark;
extern ULONG NtfsMcbLowWaterMark;
extern ULONG NtfsMcbCurrentLevel;

extern BOOLEAN NtfsMcbCleanupInProgress;
extern WORK_QUEUE_ITEM NtfsMcbWorkItem;

//
//  The following are global large integer constants used throughout ntfs
//  We declare the actual name using Ntfs prefixes to avoid any linking
//  conflicts but internally in the file system we'll use smaller Li prefixes
//  to denote the values.
//

extern LARGE_INTEGER NtfsLarge0;
extern LARGE_INTEGER NtfsLarge1;
extern LARGE_INTEGER NtfsLargeMax;
extern LARGE_INTEGER NtfsLargeEof;

extern LONGLONG NtfsLastAccess;

#define Li0                              (NtfsLarge0)
#define Li1                              (NtfsLarge1)
#define LiMax                            (NtfsLargeMax)
#define LiEof                            (NtfsLargeEof)

#define MAXULONGLONG                     (0xffffffffffffffff)
#define UNUSED_LCN                       ((LONGLONG)(-1))

//
//  Maximum file size is limited by MM's shift from file size to number of pages.
//

#define MAXFILESIZE                      (0xfffffff0000)

//
//  Maximum clusters per Ntfs Mcb range.  We currently only support (2^32 - 1)
//  clusters in an Mcb.
//

#define MAX_CLUSTERS_PER_RANGE          (0x100000000 - 1)

//
//   The following fields are used to allocate nonpaged structures
//  using a lookaside list, and other fixed sized structures from a
//  small cache.
//

extern NPAGED_LOOKASIDE_LIST NtfsIoContextLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsIrpContextLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsKeventLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsScbNonpagedLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsScbSnapshotLookasideList;
extern NPAGED_LOOKASIDE_LIST NtfsCompressSyncLookasideList;

extern PAGED_LOOKASIDE_LIST NtfsCcbLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsCcbDataLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsDeallocatedRecordsLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsFcbDataLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsFcbIndexLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsIndexContextLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsLcbLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsNukemLookasideList;
extern PAGED_LOOKASIDE_LIST NtfsScbDataLookasideList;

//
//  This is the string for the name of the index allocation attributes.
//

extern const UNICODE_STRING NtfsFileNameIndex;

//
//  This is the string for the attribute code for index allocation.
//  $INDEX_ALLOCATION.
//

extern const UNICODE_STRING NtfsIndexAllocation;

//
//  This is the string for the data attribute, $DATA.
//

extern const UNICODE_STRING NtfsDataString;

//
//  This is the string for the bitmap attribute, $BITMAP.
//

extern const UNICODE_STRING NtfsBitmapString;

//
//  This is the string for the attribute list attribute, $ATTRIBUTE_LIST.
//

extern const UNICODE_STRING NtfsAttrListString;

//
//  This is the string for the reparse pt. attribute, $REPARSE_POINT
//

extern const UNICODE_STRING NtfsReparsePointString;


//
//  These strings are used as the Scb->AttributeName for
//  user-opened general indices.
//

extern const UNICODE_STRING NtfsObjId;
extern const UNICODE_STRING NtfsQuota;

extern const UNICODE_STRING JournalStreamName;

//
//  These are the strings for the files in the extend directory.
//

extern const UNICODE_STRING NtfsExtendName;
extern const UNICODE_STRING NtfsUsnJrnlName;
extern const UNICODE_STRING NtfsQuotaName;
extern const UNICODE_STRING NtfsObjectIdName;
extern const UNICODE_STRING NtfsMountTableName;

//
//  This strings are used for informational popups.
//

extern const UNICODE_STRING NtfsSystemFiles[];

//
//  This is the '.' string to use to lookup the parent entry.
//

extern const UNICODE_STRING NtfsRootIndexString;

extern const UNICODE_STRING NtfsInternalUseFile[];

#define CHANGEATTRIBUTEVALUE_FILE_NUMBER            (0)     //  $ChangeAttributeValue
#define CHANGEATTRIBUTEVALUE2_FILE_NUMBER           (1)     //  $ChangeAttributeValue2
#define COMMONCLEANUP_FILE_NUMBER                   (2)     //  $CommonCleanup
#define CONVERTTONONRESIDENT_FILE_NUMBER            (3)     //  $ConvertToNonresident
#define CREATENONRESIDENTWITHVALUE_FILE_NUMBER      (4)     //  $CreateNonresidentWithValue
#define DEALLOCATERECORD_FILE_NUMBER                (5)     //  $DeallocateRecord
#define DELETEALLOCATIONFROMRECORD_FILE_NUMBER      (6)     //  $DeleteAllocationFromRecord
#define DIRECTORY_FILE_NUMBER                       (7)     //  $Directory
#define INITIALIZERECORDALLOCATION_FILE_NUMBER      (8)     //  $InitializeRecordAllocation
#define MAPATTRIBUTEVALUE_FILE_NUMBER               (9)     //  $MapAttributeValue
#define NONCACHEDIO_FILE_NUMBER                     (10)    //  $NonCachedIo
#define PERFORMHOTFIX_FILE_NUMBER                   (11)    //  $PerformHotFix
#define PREPARETOSHRINKFILESIZE_FILE_NUMBER         (12)    //  $PrepareToShrinkFileSize
#define REPLACEATTRIBUTE_FILE_NUMBER                (13)    //  $ReplaceAttribute
#define REPLACEATTRIBUTE2_FILE_NUMBER               (14)    //  $ReplaceAttribute2
#define SETALLOCATIONINFO_FILE_NUMBER               (15)    //  $SetAllocationInfo
#define SETENDOFFILEINFO_FILE_NUMBER                (16)    //  $SetEndOfFileInfo
#define ZERORANGEINSTREAM_FILE_NUMBER               (17)    //  $ZeroRangeInStream
#define ZERORANGEINSTREAM2_FILE_NUMBER              (18)    //  $ZeroRangeInStream2
#define ZERORANGEINSTREAM3_FILE_NUMBER              (19)    //  $ZeroRangeInStream3

//
//  This is the empty string.  This can be used to pass a string with
//  no length.
//

extern const UNICODE_STRING NtfsEmptyString;

//
//  The following file references are used to identify system files.
//

extern const FILE_REFERENCE MftFileReference;
extern const FILE_REFERENCE Mft2FileReference;
extern const FILE_REFERENCE LogFileReference;
extern const FILE_REFERENCE VolumeFileReference;
extern const FILE_REFERENCE AttrDefFileReference;
extern const FILE_REFERENCE RootIndexFileReference;
extern const FILE_REFERENCE BitmapFileReference;
extern const FILE_REFERENCE BootFileReference;
extern const FILE_REFERENCE ExtendFileReference;
extern const FILE_REFERENCE FirstUserFileReference;

//
//  The number of attributes in the attribute definition table, including the end record
//

extern ULONG NtfsAttributeDefinitionsCount;

//
//  The global structure used to contain our fast I/O callbacks
//

extern FAST_IO_DISPATCH NtfsFastIoDispatch;

#ifdef BRIANDBG
extern ULONG NtfsIgnoreReserved;
#endif

#ifdef SYSCACHE_DEBUG
extern ULONG NtfsSyscacheTrackingActive;
#endif

extern const UCHAR BaadSignature[4];
extern const UCHAR IndexSignature[4];
extern const UCHAR FileSignature[4];
extern const UCHAR HoleSignature[4];
extern const UCHAR ChkdskSignature[4];

//
//  Reserved buffers needed.
//
//      RESERVED_BUFFER_ONE_NEEDED - User only needs one buffer to complete request, any buffer will do.
//      RESERVED_BUFFER_TWO_NEEDED - User may need a second buffer after this one.
//      RESERVED_BUFFER_WORKSPACE_NEEDED - This is second buffer of two needed.
//

#define RESERVED_BUFFER_ONE_NEEDED          (0x0)
#define RESERVED_BUFFER_TWO_NEEDED          (0x1)
#define RESERVED_BUFFER_WORKSPACE_NEEDED    (0x2)

//
//  Large Reserved Buffer Context
//

extern ULONG NtfsReservedInUse;
extern PVOID NtfsReserved1;
extern PVOID NtfsReserved2;
extern ULONG NtfsReserved2Count;
extern PVOID NtfsReserved3;
extern PVOID NtfsReserved1Thread;
extern PVOID NtfsReserved2Thread;
extern PVOID NtfsReserved3Thread;
extern PFCB NtfsReserved12Fcb;
extern PFCB NtfsReserved3Fcb;
extern PVOID NtfsReservedBufferThread;
extern BOOLEAN NtfsBufferAllocationFailure;
extern FAST_MUTEX NtfsReservedBufferMutex;
extern ERESOURCE NtfsReservedBufferResource;
extern LARGE_INTEGER NtfsShortDelay;
extern FAST_MUTEX NtfsScavengerLock;
extern PIRP_CONTEXT NtfsScavengerWorkList;
extern BOOLEAN NtfsScavengerRunning;
extern ULONGLONG NtfsMaxQuotaNotifyRate;
extern ULONG NtfsAsyncPostThreshold;

#define LARGE_BUFFER_SIZE                (0x10000)

#ifdef _WIN64
#define WORKSPACE_BUFFER_SIZE           (LARGE_BUFFER_SIZE + PAGE_SIZE)
#else
#define WORKSPACE_BUFFER_SIZE           (LARGE_BUFFER_SIZE)
#endif

extern UCHAR NtfsZeroExtendedInfo[48];

#ifdef NTFS_RWC_DEBUG
//
//  Range to include in COW checks.
//

extern LONGLONG NtfsRWCLowThreshold;
extern LONGLONG NtfsRWCHighThreshold;
#endif

//
//  The following is the number of minutes for the last access increment
//

#define LAST_ACCESS_INCREMENT_MINUTES   (60)

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define NTFS_MAX_PARALLEL_IOS            ((ULONG)8)

//
//  Define a symbol which states the maximum number of runs that will be
//  added or deleted in one transaction per attribute.  Note that the per-run
//  cost of deleting a run is 8-bytes in the BITMAP_RANGE, an average of
//  four bytes in the mapping array, and 16 bytes in the LCN_RANGE - for a total
//  of 28-bytes.  Allocations do not log an LCN_RANGE, so their per-run cost is
//  12 bytes.  The worst problem is deleteing large fragmented files, where you
//  must add the cost of the rest of the log records for deleting all the attributes.
//

#define MAXIMUM_RUNS_AT_ONCE             (128)



//
//  Turn on pseudo-asserts if NTFS_FREE_ASSERTS is defined.
//

#if (!DBG && defined( NTFS_FREE_ASSERTS )) || defined( NTFSDBG )
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)                                             \
    ((exp) ? TRUE :                                             \
             (DbgPrint( "%s:%d %s\n",__FILE__,__LINE__,#exp ),  \
              DbgBreakPoint(),                                  \
              TRUE))
#define ASSERTMSG(msg,exp)                                              \
    ((exp) ? TRUE :                                                     \
             (DbgPrint( "%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp ),   \
              DbgBreakPoint(),                                          \
              TRUE))
#endif

#ifdef NTFS_LOG_FULL_TEST
extern LONG NtfsFailCheck;
extern LONG NtfsFailFrequency;
extern LONG NtfsPeriodicFail;

//
//  Perform log-file-full testing.
//

#define FailCheck(I,S) {                                    \
    PIRP_CONTEXT FailTopContext = (I)->TopLevelIrpContext;  \
    if (FailTopContext->NextFailCount != 0) {               \
        if (--FailTopContext->CurrentFailCount == 0) {      \
            FailTopContext->NextFailCount++;                \
            FailTopContext->CurrentFailCount = FailTopContext->NextFailCount; \
            ExRaiseStatus( S );                             \
        }                                                   \
    }                                                       \
}

#define LogFileFullFailCheck(I) FailCheck( I, STATUS_LOG_FILE_FULL )
#endif

//
//  The following debug macros are used in ntfs and defined in this module
//
//      DebugTrace( Indent, Level, (DbgPrint list) );
//
//      DebugUnwind( NonquotedString );
//
//      DebugDoit( Statement );
//
//      DbgDoit( Statement );
//
//  The following assertion macros ensure that the indicated structure
//  is valid
//
//      ASSERT_VCB( IN PVCB Vcb );
//      ASSERT_OPTIONAL_VCB( IN PVCB Vcb OPTIONAL );
//
//      ASSERT_FCB( IN PFCB Fcb );
//      ASSERT_OPTIONAL_FCB( IN PFCB Fcb OPTIONAL );
//
//      ASSERT_SCB( IN PSCB Scb );
//      ASSERT_OPTIONAL_SCB( IN PSCB Scb OPTIONAL );
//
//      ASSERT_CCB( IN PSCB Ccb );
//      ASSERT_OPTIONAL_CCB( IN PSCB Ccb OPTIONAL );
//
//      ASSERT_LCB( IN PLCB Lcb );
//      ASSERT_OPTIONAL_LCB( IN PLCB Lcb OPTIONAL );
//
//      ASSERT_PREFIX_ENTRY( IN PPREFIX_ENTRY PrefixEntry );
//      ASSERT_OPTIONAL_PREFIX_ENTRY( IN PPREFIX_ENTRY PrefixEntry OPTIONAL );
//
//      ASSERT_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext );
//      ASSERT_OPTIONAL_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext OPTIONAL );
//
//      ASSERT_IRP( IN PIRP Irp );
//      ASSERT_OPTIONAL_IRP( IN PIRP Irp OPTIONAL );
//
//      ASSERT_FILE_OBJECT( IN PFILE_OBJECT FileObject );
//      ASSERT_OPTIONAL_FILE_OBJECT( IN PFILE_OBJECT FileObject OPTIONAL );
//
//  The following macros are used to check the current thread owns
//  the indicated resource
//
//      ASSERT_EXCLUSIVE_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_SHARED_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_RESOURCE_NOT_MINE( IN PERESOURCE Resource );
//
//  The following macros are used to check whether the current thread
//  owns the resoures in the given structures.
//
//      ASSERT_EXCLUSIVE_FCB( IN PFCB Fcb );
//
//      ASSERT_SHARED_FCB( IN PFCB Fcb );
//
//      ASSERT_EXCLUSIVE_SCB( IN PSCB Scb );
//
//      ASSERT_SHARED_SCB( IN PSCB Scb );
//
//  The following macro is used to check that we are not trying to
//  manipulate an lcn that does not exist
//
//      ASSERT_LCN_RANGE( IN PVCB Vcb, IN LCN Lcn );
//

#ifdef NTFSDBG

extern LONG NtfsDebugTraceLevel;
extern LONG NtfsDebugTraceIndent;
extern LONG NtfsReturnStatusFilter;

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_QUOTA                (0x00000002)
#define DEBUG_TRACE_OBJIDSUP             (0x00000002) // shared with Quota
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_UNWIND               (0x00000008)

#define DEBUG_TRACE_CLEANUP              (0x00000010)
#define DEBUG_TRACE_CLOSE                (0x00000020)
#define DEBUG_TRACE_CREATE               (0x00000040)
#define DEBUG_TRACE_DIRCTRL              (0x00000080)
#define DEBUG_TRACE_VIEWSUP              (0x00000080) // shared with DirCtrl

#define DEBUG_TRACE_EA                   (0x00000100)
#define DEBUG_TRACE_PROP_FSCTL           (0x00000100) // shared with EA
#define DEBUG_TRACE_FILEINFO             (0x00000200)
#define DEBUG_TRACE_SEINFO               (0x00000200) // shared with FileInfo
#define DEBUG_TRACE_FSCTRL               (0x00000400)
#define DEBUG_TRACE_SHUTDOWN             (0x00000400) // shared with FsCtrl
#define DEBUG_TRACE_LOCKCTRL             (0x00000800)

#define DEBUG_TRACE_READ                 (0x00001000)
#define DEBUG_TRACE_VOLINFO              (0x00002000)
#define DEBUG_TRACE_WRITE                (0x00004000)
#define DEBUG_TRACE_FLUSH                (0x00008000)

#define DEBUG_TRACE_DEVCTRL              (0x00010000)
#define DEBUG_TRACE_PNP                  (0x00010000) // shared with DevCtrl
#define DEBUG_TRACE_LOGSUP               (0x00020000)
#define DEBUG_TRACE_BITMPSUP             (0x00040000)
#define DEBUG_TRACE_ALLOCSUP             (0x00080000)

#define DEBUG_TRACE_MFTSUP               (0x00100000)
#define DEBUG_TRACE_INDEXSUP             (0x00200000)
#define DEBUG_TRACE_ATTRSUP              (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)

#define DEBUG_TRACE_NAMESUP              (0x01000000)
#define DEBUG_TRACE_SECURSUP             (0x01000000) // shared with NameSup
#define DEBUG_TRACE_VERFYSUP             (0x02000000)
#define DEBUG_TRACE_CACHESUP             (0x04000000)
#define DEBUG_TRACE_PREFXSUP             (0x08000000)
#define DEBUG_TRACE_HASHSUP              (0x08000000) // shared with PrefxSup

#define DEBUG_TRACE_DEVIOSUP             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER       (0x40000000)
#define DEBUG_TRACE_ACLINDEX             (0x80000000)

__inline BOOLEAN
NtfsDebugTracePre(LONG Indent, LONG Level)
{
    if (Level == 0 || (NtfsDebugTraceLevel & Level) != 0) {
        DbgPrint( "%08lx:", PsGetCurrentThread( ));
        if (Indent < 0) {
            NtfsDebugTraceIndent += Indent;
            if (NtfsDebugTraceIndent < 0) {
                NtfsDebugTraceIndent = 0;
            }
        }

        DbgPrint( "%*s", NtfsDebugTraceIndent, "" );

        return TRUE;
    } else {
        return FALSE;
    }
}

__inline void
NtfsDebugTracePost( LONG Indent )
{
    if (Indent > 0) {
        NtfsDebugTraceIndent += Indent;
    }
}

#define DebugTrace(INDENT,LEVEL,M) {                \
    if (NtfsDebugTracePre( (INDENT), (LEVEL))) {    \
        DbgPrint M;                                 \
        NtfsDebugTracePost( (INDENT) );             \
    }                                               \
}

#define DebugUnwind(X) {                                                        \
    if (AbnormalTermination()) {                                                \
        DebugTrace( 0, DEBUG_TRACE_UNWIND, (#X ", Abnormal termination.\n") );  \
    }                                                                           \
}

#define DebugDoit(X)    X
#define DebugPrint(X)   (DbgPrint X, TRUE)

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG NtfsFsdEntryCount;
extern ULONG NtfsFspEntryCount;
extern ULONG NtfsIoCallDriverCount;

#else

#define DebugTrace(INDENT,LEVEL,M)  {NOTHING;}
#define DebugUnwind(X)              {NOTHING;}
#define DebugDoit(X)                 NOTHING
#define DebugPrint(X)                NOTHING

#endif // NTFSDBG

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just  NTFSDBG users
//

#ifdef NTFSDBG

#define DbgDoit(X)                       {X;}

#define ASSERT_VCB(V) {                    \
    ASSERT((NodeType(V) == NTFS_NTC_VCB)); \
}

#define ASSERT_OPTIONAL_VCB(V) {           \
    ASSERT(((V) == NULL) ||                \
           (NodeType(V) == NTFS_NTC_VCB)); \
}

#define ASSERT_FCB(F) {                    \
    ASSERT((NodeType(F) == NTFS_NTC_FCB)); \
}

#define ASSERT_OPTIONAL_FCB(F) {           \
    ASSERT(((F) == NULL) ||                \
           (NodeType(F) == NTFS_NTC_FCB)); \
}

#define ASSERT_SCB(S) {                                 \
    ASSERT((NodeType(S) == NTFS_NTC_SCB_DATA) ||        \
           (NodeType(S) == NTFS_NTC_SCB_MFT)  ||        \
           (NodeType(S) == NTFS_NTC_SCB_INDEX) ||       \
           (NodeType(S) == NTFS_NTC_SCB_ROOT_INDEX));   \
}

#define ASSERT_OPTIONAL_SCB(S) {                        \
    ASSERT(((S) == NULL) ||                             \
           (NodeType(S) == NTFS_NTC_SCB_DATA) ||        \
           (NodeType(S) == NTFS_NTC_SCB_MFT)  ||        \
           (NodeType(S) == NTFS_NTC_SCB_INDEX) ||       \
           (NodeType(S) == NTFS_NTC_SCB_ROOT_INDEX));   \
}

#define ASSERT_CCB(C) {                                 \
    ASSERT((NodeType(C) == NTFS_NTC_CCB_DATA) ||        \
           (NodeType(C) == NTFS_NTC_CCB_INDEX));        \
}

#define ASSERT_OPTIONAL_CCB(C) {                        \
    ASSERT(((C) == NULL) ||                             \
           ((NodeType(C) == NTFS_NTC_CCB_DATA) ||       \
            (NodeType(C) == NTFS_NTC_CCB_INDEX)));      \
}

#define ASSERT_LCB(L) {                    \
    ASSERT((NodeType(L) == NTFS_NTC_LCB)); \
}

#define ASSERT_OPTIONAL_LCB(L) {           \
    ASSERT(((L) == NULL) ||                \
           (NodeType(L) == NTFS_NTC_LCB)); \
}

#define ASSERT_PREFIX_ENTRY(P) {                    \
    ASSERT((NodeType(P) == NTFS_NTC_PREFIX_ENTRY)); \
}

#define ASSERT_OPTIONAL_PREFIX_ENTRY(P) {           \
    ASSERT(((P) == NULL) ||                         \
           (NodeType(P) == NTFS_NTC_PREFIX_ENTRY)); \
}

#define ASSERT_IRP_CONTEXT(I) {                    \
    ASSERT((NodeType(I) == NTFS_NTC_IRP_CONTEXT)); \
}

#define ASSERT_OPTIONAL_IRP_CONTEXT(I) {           \
    ASSERT(((I) == NULL) ||                        \
           (NodeType(I) == NTFS_NTC_IRP_CONTEXT)); \
}

#define ASSERT_IRP(I) {                 \
    ASSERT(((I)->Type == IO_TYPE_IRP)); \
}

#define ASSERT_OPTIONAL_IRP(I) {        \
    ASSERT(((I) == NULL) ||             \
           ((I)->Type == IO_TYPE_IRP)); \
}

#define ASSERT_FILE_OBJECT(F) {          \
    ASSERT(((F)->Type == IO_TYPE_FILE)); \
}

#define ASSERT_OPTIONAL_FILE_OBJECT(F) { \
    ASSERT(((F) == NULL) ||              \
           ((F)->Type == IO_TYPE_FILE)); \
}

#define ASSERT_EXCLUSIVE_RESOURCE(R) {   \
    ASSERTMSG("ASSERT_EXCLUSIVE_RESOURCE ", ExIsResourceAcquiredExclusiveLite(R)); \
}

#define ASSERT_SHARED_RESOURCE(R)        \
    ASSERTMSG( "ASSERT_RESOURCE_NOT_MINE ", ExIsResourceAcquiredSharedLite(R));

#define ASSERT_RESOURCE_NOT_MINE(R)     \
    ASSERTMSG( "ASSERT_RESOURCE_NOT_MINE ", !ExIsResourceAcquiredSharedLite(R));

#define ASSERT_EXCLUSIVE_FCB(F) {                                    \
    if (NtfsSegmentNumber( &(F)->FileReference )                     \
            >= FIRST_USER_FILE_NUMBER) {                             \
        ASSERT_EXCLUSIVE_RESOURCE(F->Resource);                      \
    }                                                                \
}                                                                    \

#define ASSERT_SHARED_FCB(F) {                                       \
    if (NtfsSegmentNumber( &(F)->FileReference )                     \
            >= FIRST_USER_FILE_NUMBER) {                             \
        ASSERT_SHARED_RESOURCE(F->Resource);                         \
    }                                                                \
}                                                                    \

#define ASSERT_EXCLUSIVE_SCB(S)     ASSERT_EXCLUSIVE_FCB(S->Fcb)

#define ASSERT_SHARED_SCB(S)        ASSERT_SHARED_FCB(S->Fcb)

#define ASSERT_LCN_RANGE_CHECKING(V,L) {                                             \
    ASSERTMSG("ASSERT_LCN_RANGE_CHECKING ",                                          \
        ((V)->TotalClusters == 0) || ((L) <= (V)->TotalClusters));                   \
}

#else

#define DbgDoit(X)                       {NOTHING;}
#define ASSERT_VCB(V)                    {DBG_UNREFERENCED_PARAMETER(V);}
#define ASSERT_OPTIONAL_VCB(V)           {DBG_UNREFERENCED_PARAMETER(V);}
#define ASSERT_FCB(F)                    {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_OPTIONAL_FCB(F)           {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_SCB(S)                    {DBG_UNREFERENCED_PARAMETER(S);}
#define ASSERT_OPTIONAL_SCB(S)           {DBG_UNREFERENCED_PARAMETER(S);}
#define ASSERT_CCB(C)                    {DBG_UNREFERENCED_PARAMETER(C);}
#define ASSERT_OPTIONAL_CCB(C)           {DBG_UNREFERENCED_PARAMETER(C);}
#define ASSERT_LCB(L)                    {DBG_UNREFERENCED_PARAMETER(L);}
#define ASSERT_OPTIONAL_LCB(L)           {DBG_UNREFERENCED_PARAMETER(L);}
#define ASSERT_PREFIX_ENTRY(P)           {DBG_UNREFERENCED_PARAMETER(P);}
#define ASSERT_OPTIONAL_PREFIX_ENTRY(P)  {DBG_UNREFERENCED_PARAMETER(P);}
#define ASSERT_IRP_CONTEXT(I)            {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_OPTIONAL_IRP_CONTEXT(I)   {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_IRP(I)                    {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_OPTIONAL_IRP(I)           {DBG_UNREFERENCED_PARAMETER(I);}
#define ASSERT_FILE_OBJECT(F)            {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_OPTIONAL_FILE_OBJECT(F)   {DBG_UNREFERENCED_PARAMETER(F);}
#define ASSERT_EXCLUSIVE_RESOURCE(R)     {NOTHING;}
#define ASSERT_SHARED_RESOURCE(R)        {NOTHING;}
#define ASSERT_RESOURCE_NOT_MINE(R)      {NOTHING;}
#define ASSERT_EXCLUSIVE_FCB(F)          {NOTHING;}
#define ASSERT_SHARED_FCB(F)             {NOTHING;}
#define ASSERT_EXCLUSIVE_SCB(S)          {NOTHING;}
#define ASSERT_SHARED_SCB(S)             {NOTHING;}
#define ASSERT_LCN_RANGE_CHECKING(V,L)   {NOTHING;}

#endif // DBG

#endif // _NTFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfslog.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsLog.h

Abstract:

    This module defines the Ntfs-specific log file structures.

Author:

    Tom Miller      [TomM]          21-Jul-1991

Revision History:

--*/

#ifndef _NTFSLOG_
#define _NTFSLOG_


//
//  The following type defines the Ntfs log operations.
//
//  The comment specifies the record type which follows the record.
//  These record types are defined either here or in ntfs.h.
//

typedef enum _NTFS_LOG_OPERATION {

    Noop =                         0x00, //
    CompensationLogRecord =        0x01, //
    InitializeFileRecordSegment =  0x02, //  FILE_RECORD_SEGMENT_HEADER
    DeallocateFileRecordSegment =  0x03, //
    WriteEndOfFileRecordSegment =  0x04, //  ATTRIBUTE_RECORD_HEADER
    CreateAttribute =              0x05, //  ATTRIBUTE_RECORD_HEADER
    DeleteAttribute =              0x06, //
    UpdateResidentValue =          0x07, //  (value)
    UpdateNonresidentValue =       0x08, //  (value)
    UpdateMappingPairs =           0x09, //  (value = mapping pairs bytes)
    DeleteDirtyClusters =          0x0A, //  array of LCN_RANGE
    SetNewAttributeSizes =         0x0B, //  NEW_ATTRIBUTE_SIZES
    AddIndexEntryRoot =            0x0C, //  INDEX_ENTRY
    DeleteIndexEntryRoot =         0x0D, //  INDEX_ENTRY
    AddIndexEntryAllocation =      0x0E, //  INDEX_ENTRY
    DeleteIndexEntryAllocation =   0x0F, //  INDEX_ENTRY
    WriteEndOfIndexBuffer =        0x10, //  INDEX_ENTRY
    SetIndexEntryVcnRoot =         0x11, //  VCN
    SetIndexEntryVcnAllocation =   0x12, //  VCN
    UpdateFileNameRoot =           0x13, //  DUPLICATED_INFORMATION
    UpdateFileNameAllocation =     0x14, //  DUPLICATED_INFORMATION
    SetBitsInNonresidentBitMap =   0x15, //  BITMAP_RANGE
    ClearBitsInNonresidentBitMap = 0x16, //  BITMAP_RANGE
    HotFix =                       0x17, //
    EndTopLevelAction =            0x18, //
    PrepareTransaction =           0x19, //
    CommitTransaction =            0x1A, //
    ForgetTransaction =            0x1B, //
    OpenNonresidentAttribute =     0x1C, //  OPEN_ATTRIBUTE_ENTRY+ATTRIBUTE_NAME_ENTRY
    OpenAttributeTableDump =       0x1D, //  OPEN_ATTRIBUTE_ENTRY array
    AttributeNamesDump =           0x1E, //  (all attribute names)
    DirtyPageTableDump =           0x1F, //  DIRTY_PAGE_ENTRY array
    TransactionTableDump =         0x20, //  TRANSACTION_ENTRY array
    UpdateRecordDataRoot =         0x21, //  (value)
    UpdateRecordDataAllocation =   0x22  //  (value)

} NTFS_LOG_OPERATION, *PNTFS_LOG_OPERATION;


//
//  The Ntfs log record header precedes every log record written to
//  disk by Ntfs.
//

//
//  Log record header.
//

typedef struct _NTFS_LOG_RECORD_HEADER {

    //
    //  Log Operations (LOG_xxx codes)
    //

    USHORT RedoOperation;
    USHORT UndoOperation;

    //
    //  Offset to Redo record, and its length
    //

    USHORT RedoOffset;
    USHORT RedoLength;

    //
    //  Offset to Undo record, and its length.  Note, for some Redo/Undo
    //  combinations, the expected records may be the same, and thus
    //  these two values will be identical to the above values.
    //

    USHORT UndoOffset;
    USHORT UndoLength;

    //
    //  Open attribute table index to which this update applies.  Index 0 is
    //  always reserved for the MFT itself.  The value of this field
    //  essentially distinguishes two cases for this update, which will be
    //  referred to as MFT update and nonresident attribute update.
    //
    //  MFT updates are for initialization and deletion of file record
    //  segments and updates to resident attributes.
    //
    //  Nonresident attribute updates are used to update attributes which
    //  have been allocated externally to the MFT.
    //

    USHORT TargetAttribute;

    //
    //  Number of Lcns in use at end of header.
    //

    USHORT LcnsToFollow;

    //
    //  Byte offset and Vcn for which this update is to be applied.  If the
    //  TargetAttribute is the MFT, then the Vcn will always be the exact
    //  Vcn of the start of the file record segment being modified, even
    //  if the modification happens to be in a subsequent cluster of the
    //  same file record.  The byte offset in this case is the offset to
    //  the attribute being changed.  For the Mft, AttributeOffset may be used
    //  to represent the offset from the start of the attribute record
    //  at which an update is to be applied.
    //
    //  If the update is to some other (nonresident) attribute, then
    //  TargetVcn and RecordOffset may be used to calculate the reference
    //  point for the update.  The ClusterBlockOffset refers to the number
    //  of 512 byte blocks this structure is from the beginning of the
    //  logged Vcn.
    //
    //  As a bottom line, the exact use of these fields is up to the
    //  writer of this particular log operation, and the associated
    //  restart routines for this attribute.
    //

    USHORT RecordOffset;
    USHORT AttributeOffset;
    USHORT ClusterBlockOffset;
    USHORT Reserved;
    VCN TargetVcn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes log records according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

    //
    //  Immediately following the last run is a log-operation-specific record
    //  whose length may be calculated by subtracting the length of this header
    //  from the length of the entire record returned by LFS.  These records
    //  are defined below.
    //

} NTFS_LOG_RECORD_HEADER, *PNTFS_LOG_RECORD_HEADER;


//
//  RESTART AREA STRUCTURES
//
//  The following structures are present in the Restart Area.
//

//
//  Generic Restart Table
//
//  This is a generic table definition for the purpose of describing one
//  of the three table structures used at Restart: the Open Attribute Table,
//  the Dirty Pages Table, and the Transaction Table.  This simple structure
//  allows for common initialization and free list management.  Allocation
//  and Deallocation and lookup by index are extremely fast, while lookup
//  by value (only performed in the Dirty Pages Table during Restart) is
//  a little slower.  I.e., all accesses to these tables during normal
//  operation are extremely fast.
//
//  If fast access to a table entry by value becomes an issue, then the
//  table may be supplemented by an external Generic Table - it is probably
//  not a good idea to make the Generic Table be part of the structure
//  written to the Log File.
//
//  Entries in a Restart Table should start with:
//
//      ULONG AllocatedOrNextFree;
//
//  An allocated entry will have the pattern RESTART_ENTRY_ALLOCATED
//  in this field.
//

#define RESTART_ENTRY_ALLOCATED          (0xFFFFFFFF)

typedef struct _RESTART_TABLE {

    //
    //  Entry size, in bytes
    //

    USHORT EntrySize;

    //
    //  Total number of entries in table
    //

    USHORT NumberEntries;

    //
    //  Number entries that are allocated
    //

    USHORT NumberAllocated;

    //
    //  Reserved for alignment
    //

    USHORT Reserved[3];

    //
    //  Free goal - Offset after which entries should be freed to end of
    //  list, as opposed to front.  At each checkpoint, the table may be
    //  truncated if there are enough free entries at the end of the list.
    //  Expressed as an offset from the start of this structure.
    //

    ULONG FreeGoal;

    //
    //  First Free entry (head of list) and Last Free entry (used to deallocate
    //  beyond Free Goal).  Expressed as an offset from the start of this
    //  structure.
    //

    ULONG FirstFree;
    ULONG LastFree;

    //
    //  The table itself starts here.
    //

} RESTART_TABLE, *PRESTART_TABLE;

//
//  Macro to get a pointer to an entry in a Restart Table, from the Table
//  pointer and entry index.  NOTE - Don't generate the index in a call
//  to NtfsAllocateRestartTableIndex within this macro.  The macro code
//  tends to capture the Table pointer before generating the index.  If the
//  table needs to grow then the captured value may be invalid.
//

#define GetRestartEntryFromIndex(TBL,INDX) (    \
    (PVOID)((PCHAR)(TBL)->Table + (INDX))       \
)

//
//  Macro to get an index for an entry in a Restart Table, from the Table
//  pointer and entry pointer.
//

#define GetIndexFromRestartEntry(TBL,ENTRY) (           \
    (ULONG)((PCHAR)(ENTRY) - (PCHAR)(TBL)->Table)       \
)

//
//  Macro to see if an entry in a Restart Table is allocated.
//

#define IsRestartTableEntryAllocated(PTR) (                 \
    (BOOLEAN)(*(PULONG)(PTR) == RESTART_ENTRY_ALLOCATED)    \
)

//
//  Macro to retrieve the size of a Restart Table in bytes.
//

#define SizeOfRestartTable(TBL) (                                   \
    (ULONG)(((TBL)->Table->NumberEntries *                          \
     (TBL)->Table->EntrySize) +                                     \
    sizeof(RESTART_TABLE))                                          \
)

#define AllocatedSizeOfRestartTable(TBL) (                          \
    (ULONG)(((TBL)->Table->NumberAllocated *                        \
     (TBL)->Table->EntrySize) +                                     \
    sizeof(RESTART_TABLE))                                          \
)


//
//  Macro to see if Restart Table is empty.  It is empty if the
//  number allocated is zero.
//

#define IsRestartTableEmpty(TBL) (!(TBL)->Table->NumberAllocated)

//
//  Macro to see if an index is within the current range and entry
//  boundary of the table.
//

#define IsRestartIndexWithinTable(TBL,INDX) (                                       \
    (BOOLEAN)(((INDX) >= sizeof(RESTART_TABLE)) &&                                  \
              ((INDX) < SizeOfRestartTable(TBL)) &&                                 \
              ((((INDX) - sizeof(RESTART_TABLE)) % (TBL)->Table->EntrySize) == 0))  \
)

//
//  Macros to acquire and release a Restart Table.
//

#define NtfsAcquireExclusiveRestartTable(TBL,WAIT) {        \
    ExAcquireResourceExclusiveLite( &(TBL)->Resource,(WAIT));   \
}

#define NtfsAcquireSharedStarveExRestartTable(TBL,WAIT) {        \
    ExAcquireSharedStarveExclusive( &(TBL)->Resource,(WAIT));   \
}

#define NtfsAcquireSharedRestartTable(TBL,WAIT) {           \
    ExAcquireResourceSharedLite( &(TBL)->Resource,(WAIT));      \
}

#define NtfsReleaseRestartTable(TBL) {                      \
    ExReleaseResourceLite(&(TBL)->Resource);                    \
}

//
//  Define some tuning parameters to keep the restart tables a
//  reasonable size.
//

#define INITIAL_NUMBER_TRANSACTIONS      (5)
#define HIGHWATER_TRANSACTION_COUNT      (10)
#define INITIAL_NUMBER_ATTRIBUTES        (8)
#define HIGHWATER_ATTRIBUTE_COUNT        (16)

//
//  Attribute Name Entry.  This is a simple structure used to store
//  all of the attribute names for the Open Attribute Table during
//  checkpoint processing.  The Attribute Names record written to the log
//  is a series of Attribute Name Entries terminated by an entry with
//  Index == NameLength == 0.  The end of the table may be tested for by
//  looking for either of these fields to be 0, as 0 is otherwise invalid
//  for both.
//
//  Note that the size of this structure is equal to the overhead for storing
//  an attribute name in the table, including the UNICODE_NULL.
//

typedef struct _ATTRIBUTE_NAME_ENTRY {

    //
    //  Index for Attibute with this name in the Open Attribute Table.
    //

    USHORT Index;

    //
    //  Length of attribute name to follow in bytes, including a terminating
    //  UNICODE_NULL.
    //

    USHORT NameLength;

    //
    //  Start of attribute name
    //

    WCHAR Name[1];

} ATTRIBUTE_NAME_ENTRY, *PATTRIBUTE_NAME_ENTRY;

//
//  Open Attribute Table.  This is the on-disk structure for version 0.
//
//  One entry exists in the Open Attribute Table for each nonresident
//  attribute of each file that is open with modify access.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_ATTRIBUTE_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

#pragma pack(4)

typedef struct _OPEN_ATTRIBUTE_ENTRY_V0 {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Placeholder for Scb in V0.  We use it to point to the index
    //  in the in-memory structure.
    //

    ULONG OatIndex;

    //
    //  File Reference of file containing attribute.
    //

    FILE_REFERENCE FileReference;

    //
    //  Lsn of OpenNonresidentAttribute log record, to distinguish reuses
    //  of this open file record.  Log records referring to this Open
    //  Attribute Entry Index, but with Lsns  older than this field, can
    //  only occur when the attribute was subsequently deleted - these
    //  log records can be ignored.
    //

    LSN LsnOfOpenRecord;

    //
    //  Flag to say if dirty pages seen for this attribute during dirty
    //  page scan.
    //

    BOOLEAN DirtyPagesSeen;

    //
    //  Flag to indicate if the pointer in Overlay above is to an Scb or
    //  attribute name.  It is only used during restart when cleaning up
    //  the open attribute table.
    //

    BOOLEAN AttributeNamePresent;

    //
    //  Reserved for alignment
    //

    UCHAR Reserved[2];

    //
    //  The following two fields identify the actual attribute
    //  with respect to its file.   We identify the attribute by
    //  its type code and name.  When the Restart Area is written,
    //  all of the names for all of the open attributes are temporarily
    //  copied to the end of the Restart Area.
    //  The name is not used on disk but must be a 64-bit value.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    LONGLONG AttributeName;

    //
    //  This field is only relevant to indices, i.e., if AttributeTypeCode
    //  above is $INDEX_ALLOCATION.
    //

    ULONG BytesPerIndexBuffer;

} OPEN_ATTRIBUTE_ENTRY_V0, *POPEN_ATTRIBUTE_ENTRY_V0;

#pragma pack()

#define SIZEOF_OPEN_ATTRIBUTE_ENTRY_V0 (                                \
    FIELD_OFFSET( OPEN_ATTRIBUTE_ENTRY_V0, BytesPerIndexBuffer ) + 4    \
)

//
//  Auxiliary OpenAttribute data.  This is the data that doesn't need to be
//  logged.
//

typedef struct OPEN_ATTRIBUTE_DATA {

    //
    //  Queue of these structures attached to the Vcb.
    //  NOTE - This must be the first entry in this structure.
    //

    LIST_ENTRY Links;

    //
    //  Index for this entry in the On-disk open attribute table.
    //

    ULONG OnDiskAttributeIndex;

    BOOLEAN AttributeNamePresent;

    //
    //  The following overlay either contains an optional pointer to an
    //  Attribute Name Entry from the Analysis Phase of Restart, or a
    //  pointer to an Scb once attributes have been open and in the normal
    //  running system.
    //
    //  Specifically, after the Analysis Phase of Restart:
    //
    //      AttributeName == NULL if there is no attribute name, or the
    //                       attribute name was captured in the Attribute
    //                       Names Dump in the last successful checkpoint.
    //      AttributeName != NULL if an OpenNonresidentAttribute log record
    //                       was encountered, and an Attribute Name Entry
    //                       was allocated at that time (and must be
    //                       deallocated when no longer needed).
    //
    //  Once the Nonresident Attributes have been opened during Restart,
    //  and in the running system, this is an Scb pointer.
    //

    union {
        PWSTR AttributeName;
        PSCB Scb;
    } Overlay;

    //
    //  Store the unicode string for the attribute name.
    //

    UNICODE_STRING AttributeName;

} OPEN_ATTRIBUTE_DATA, *POPEN_ATTRIBUTE_DATA;

//
//  Open Attribute Table.  This is the on-disk structure for version 1 and
//  it is the version we always use in-memory.
//
//  One entry exists in the Open Attribute Table for each nonresident
//  attribute of each file that is open with modify access.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_ATTRIBUTE_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _OPEN_ATTRIBUTE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  This field is only relevant to indices, i.e., if AttributeTypeCode
    //  above is $INDEX_ALLOCATION.
    //

    ULONG BytesPerIndexBuffer;

    //
    //  The following two fields identify the actual attribute
    //  with respect to its file.   We identify the attribute by
    //  its type code and name.  When the Restart Area is written,
    //  all of the names for all of the open attributes are temporarily
    //  copied to the end of the Restart Area.
    //

    ATTRIBUTE_TYPE_CODE AttributeTypeCode;

    //
    //  Flag to say if dirty pages seen for this attribute during dirty
    //  page scan.
    //

    BOOLEAN DirtyPagesSeen;
    CHAR Unused[3];

    //
    //  File Reference of file containing attribute.
    //

    FILE_REFERENCE FileReference;

    //
    //  Lsn of OpenNonresidentAttribute log record, to distinguish reuses
    //  of this open file record.  Log records referring to this Open
    //  Attribute Entry Index, but with Lsns  older than this field, can
    //  only occur when the attribute was subsequently deleted - these
    //  log records can be ignored.
    //

    LSN LsnOfOpenRecord;

    //
    //  Point to the OpenAttribute data.
    //

    union {

        POPEN_ATTRIBUTE_DATA OatData;
        ULONGLONG Alignment;
    };

} OPEN_ATTRIBUTE_ENTRY, *POPEN_ATTRIBUTE_ENTRY;

//
//  VOID
//  NtfsFreeAllOpenAttributeData (
//      IN PVCB vCB
//      );
//

#define NtfsFreeAllOpenAttributeData(V) {                                               \
    while (!IsListEmpty( &(V)->OpenAttributeData )) {                                   \
        POPEN_ATTRIBUTE_DATA _Next = CONTAINING_RECORD( (V)->OpenAttributeData.Flink,   \
                                                        OPEN_ATTRIBUTE_DATA,            \
                                                        Links );                        \
        NtfsFreeOpenAttributeData( _Next );                                             \
    }                                                                                   \
}

//
//  Dirty Pages Table - Version 0
//
//  This entry is for restart version 0.  It is inadvertently misaligned.
//
//  One entry exists in the Dirty Pages Table for each page which is
//  dirty at the time the Restart Area is written.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_DIRTY_PAGES_TABLE_SIZE or the size of the table in the log file.
//  It is *not* maintained in the running system.
//

#pragma pack(4)

typedef struct _DIRTY_PAGE_ENTRY_V0 {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Target attribute index.  This is the index into the Open Attribute
    //  Table to which this dirty page entry applies.
    //

    ULONG TargetAttribute;

    //
    //  Length of transfer, in case this is the end of file, and we cannot
    //  write an entire page.
    //

    ULONG LengthOfTransfer;

    //
    //  Number of Lcns in the array at end of this structure.  See comment
    //  with this array.
    //

    ULONG LcnsToFollow;

    //
    //  Reserved for alignment
    //

    ULONG Reserved;

    //
    //  Vcn of dirty page.
    //

    VCN Vcn;

    //
    //  OldestLsn for log record for which the update has not yet been
    //  written through to disk.
    //

    LSN OldestLsn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes pages according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

} DIRTY_PAGE_ENTRY_V0, *PDIRTY_PAGE_ENTRY_V0;

#pragma pack()

//
//  Dirty Pages Table - Version 1
//
//  This version correctly aligns the 64-bit fields.
//
//  One entry exists in the Dirty Pages Table for each page which is
//  dirty at the time the Restart Area is written.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_DIRTY_PAGES_TABLE_SIZE or the size of the table in the log file.
//  It is *not* maintained in the running system.
//

typedef struct _DIRTY_PAGE_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Target attribute index.  This is the index into the Open Attribute
    //  Table to which this dirty page entry applies.
    //

    ULONG TargetAttribute;

    //
    //  Length of transfer, in case this is the end of file, and we cannot
    //  write an entire page.
    //

    ULONG LengthOfTransfer;

    //
    //  Number of Lcns in the array at end of this structure.  See comment
    //  with this array.
    //

    ULONG LcnsToFollow;

    //
    //  Vcn of dirty page.
    //

    VCN Vcn;

    //
    //  OldestLsn for log record for which the update has not yet been
    //  written through to disk.
    //

    LSN OldestLsn;

    //
    //  Run information.  This is a variable-length array of LcnsToFollow
    //  entries, only the first of which is declared.  Note that the writer
    //  always writes pages according to the physical page size on his
    //  machine, however whenever the log file is being read, no assumption
    //  is made about page size.  This is to facilitate moving disks between
    //  systems with different page sizes.
    //

    LCN LcnsForPage[1];

} DIRTY_PAGE_ENTRY, *PDIRTY_PAGE_ENTRY;

//
//  Transaction Table
//
//  One transaction entry exists for each existing transaction at the time
//  the Restart Area is written.
//
//  Currently only local transactions are supported, and the transaction
//  ID is simply used to index into this table.
//
//  This table is initialized at Restart to the maximum of
//  DEFAULT_TRANSACTION_TABLE_SIZE or the size of the table in the log file.
//  It is maintained in the running system.
//

typedef struct _TRANSACTION_ENTRY {

    //
    //  Entry is allocated if this field contains RESTART_ENTRY_ALLOCATED.
    //  Otherwise, it is a free link.
    //

    ULONG AllocatedOrNextFree;

    //
    //  Transaction State
    //

    UCHAR TransactionState;

    //
    //  Reserved for proper alignment
    //

    UCHAR Reserved[3];

    //
    //  First Lsn for transaction.  This tells us how far back in the log
    //  we may have to read to abort the transaction.
    //

    LSN FirstLsn;

    //
    //  PreviousLsn written for the transaction and UndoNextLsn (next record
    //  which should be undone in the event of a rollback.
    //

    LSN PreviousLsn;
    LSN UndoNextLsn;

    //
    //  Number of of undo log records pending abort, and total undo size.
    //

    ULONG UndoRecords;
    LONG UndoBytes;

} TRANSACTION_ENTRY, *PTRANSACTION_ENTRY;

//
//  Restart record
//
//  The Restart record used by NTFS is small, and it only describes where
//  the above information has been written to the log.  The above records
//  may be considered logically part of NTFS's restart area.
//

typedef struct _RESTART_AREA {

    //
    //  Version numbers of NTFS Restart Implementation
    //

    ULONG MajorVersion;
    ULONG MinorVersion;

    //
    //  Lsn of Start of Checkpoint.  This is the Lsn at which the Analysis
    //  Phase of Restart must begin.
    //

    LSN StartOfCheckpoint;

    //
    //  Lsns at which the four tables above plus the attribute names reside.
    //

    LSN OpenAttributeTableLsn;
    LSN AttributeNamesLsn;
    LSN DirtyPageTableLsn;
    LSN TransactionTableLsn;

    //
    //  Lengths of the above structures in bytes.
    //

    ULONG OpenAttributeTableLength;
    ULONG AttributeNamesLength;
    ULONG DirtyPageTableLength;
    ULONG TransactionTableLength;

    //
    //  Oldest Usn from which scan must occur to pickup all files which
    //  have not been through cleanup.
    //

    USN LowestOpenUsn;

    LSN CurrentLsnAtMount;
    ULONG BytesPerCluster;

    ULONG Reserved;

    //
    //  Keep some additional information about the Usn journal so we
    //  can reduce the amount of caching we do.
    //

    FILE_REFERENCE UsnJournalReference;
    LONGLONG UsnCacheBias;

} RESTART_AREA, *PRESTART_AREA;

//
//  This symbols is used to accept Restart Areas with or without the OldestUsn
//

#define SIZEOF_OLD_RESTART_AREA          (FIELD_OFFSET( RESTART_AREA, LowestOpenUsn ))


//
//  RECORD STRUCTURES USED BY LOG RECORDS
//

//
//  Set new attribute sizes
//

typedef struct _NEW_ATTRIBUTE_SIZES {

    LONGLONG AllocationSize;
    LONGLONG ValidDataLength;
    LONGLONG FileSize;
    LONGLONG TotalAllocated;

} NEW_ATTRIBUTE_SIZES, *PNEW_ATTRIBUTE_SIZES;

#define SIZEOF_FULL_ATTRIBUTE_SIZES (                   \
    sizeof( NEW_ATTRIBUTE_SIZES )                       \
)

#define SIZEOF_PARTIAL_ATTRIBUTE_SIZES (                \
    FIELD_OFFSET( NEW_ATTRIBUTE_SIZES, TotalAllocated ) \
)

//
//  Describe a bitmap range
//

typedef struct _BITMAP_RANGE {

    ULONG BitMapOffset;
    ULONG NumberOfBits;

} BITMAP_RANGE, *PBITMAP_RANGE;

//
//  Describe a range of Lcns
//

typedef struct _LCN_RANGE {

    LCN StartLcn;
    LONGLONG Count;

} LCN_RANGE, *PLCN_RANGE;


#define MAX_RESTART_TABLE_SIZE 0xF000 

#endif //  _NTFSLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfsinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Ntfs

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg         (DEBUG_TRACE_FSP_DISPATCHER)

//
//  Reference our local attribute definitions
//

extern ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[];

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
NtfsInitializeNtfsData (
    IN PDRIVER_OBJECT DriverObject,
    IN USHORT MemoryMultiplier
    );

NTSTATUS
NtfsQueryValueKey (
    IN PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG ValueLength,
    IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
    IN OUT PBOOLEAN DeallocateKeyValue
    );

BOOLEAN
NtfsRunningOnWhat(
    IN USHORT SuiteMask,
    IN UCHAR ProductType
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, NtfsInitializeNtfsData)
#pragma alloc_text(INIT, NtfsQueryValueKey)
#pragma alloc_text(INIT, NtfsRunningOnWhat)
#endif

#define UPGRADE_SETUPDD_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Setupdd"
#define UPGRADE_SETUPDD_VALUE_NAME L"Start"

#define UPGRADE_CHECK_SETUP_KEY_NAME L"\\Registry\\Machine\\System\\Setup"
#define UPGRADE_CHECK_SETUP_VALUE_NAME L"SystemSetupInProgress"

#define UPGRADE_CHECK_SETUP_CMDLINE_NAME L"CmdLine"
#define UPGRADE_CHECK_SETUP_ASR L"-asr"
#define UPGRADE_CHECK_SETUP_NEWSETUP L"-newsetup"

#define COMPATIBILITY_MODE_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define COMPATIBILITY_MODE_VALUE_NAME L"NtfsDisable8dot3NameCreation"

#define EXTENDED_CHAR_MODE_VALUE_NAME L"NtfsAllowExtendedCharacterIn8dot3Name"

#define DISABLE_LAST_ACCESS_VALUE_NAME L"NtfsDisableLastAccessUpdate"

#define QUOTA_NOTIFY_RATE L"NtfsQuotaNotifyRate"

#define MFT_ZONE_SIZE_VALUE_NAME L"NtfsMftZoneReservation"

#define MEMORY_USAGE_VALUE_NAME L"NtfsMemoryUsage"

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 128)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Ntfs file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT DeviceObject;

    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;

    ULONG Value;
    ULONG KeyValueLength;
    UCHAR Buffer[KEY_WORK_AREA];
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    BOOLEAN DeallocateKeyValue;

    ULONG MemoryMultiplier;
    USHORT NtfsDataFlags = 0;

    UNREFERENCED_PARAMETER( RegistryPath );

    PAGED_CODE();

    //
    //  Check to make sure structure overlays are correct.
    //

    ASSERT( FIELD_OFFSET( FILE_NAME, ParentDirectory) == FIELD_OFFSET(OVERLAY_LCB, OverlayParentDirectory ));
    ASSERT( FIELD_OFFSET( FILE_NAME, FileNameLength) == FIELD_OFFSET(OVERLAY_LCB, OverlayFileNameLength ));
    ASSERT( FIELD_OFFSET( FILE_NAME, Flags) == FIELD_OFFSET(OVERLAY_LCB, OverlayFlags ));
    ASSERT( FIELD_OFFSET( FILE_NAME, FileName) == FIELD_OFFSET(OVERLAY_LCB, OverlayFileName ));
    ASSERT( sizeof( DUPLICATED_INFORMATION ) >= (sizeof( QUICK_INDEX ) + (sizeof( ULONG ) * 4) + sizeof( PFILE_NAME )));

    //
    //  The open attribute table entries should be 64-bit aligned.
    //

    ASSERT( sizeof( OPEN_ATTRIBUTE_ENTRY ) == QuadAlign( sizeof( OPEN_ATTRIBUTE_ENTRY )));

    //
    //  The first entry in an open attribute data should be the links.
    //

    ASSERT( FIELD_OFFSET( OPEN_ATTRIBUTE_DATA, Links ) == 0 );

    //
    //  Compute the last access increment.  We convert the number of
    //  minutes to number of 1/100 of nanoseconds.  We have to be careful
    //  not to overrun 32 bits for any multiplier.
    //
    //  To reach 1/100 of nanoseconds per minute we take
    //
    //      1/100 nanoseconds * 10      = 1 microsecond
    //                        * 1000    = 1 millesecond
    //                        * 1000    = 1 second
    //                        * 60      = 1 minute
    //
    //  Then multiply this by the last access increment in minutes.
    //

    NtfsLastAccess = Int32x32To64( ( 10 * 1000 * 1000 * 60 ), LAST_ACCESS_INCREMENT_MINUTES );

    //
    //  Allocate the reserved buffers for USA writes - do this early so we don't have any
    //  teardown to do.
    //

    NtfsReserved1 = NtfsAllocatePoolNoRaise( NonPagedPool, LARGE_BUFFER_SIZE );
    if (NULL == NtfsReserved1) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Buffer 2 is used for the workspace.  It may require a slightly larger buffer on
    //  a Win64 system.
    //

    NtfsReserved2 = NtfsAllocatePoolNoRaise( NonPagedPool, WORKSPACE_BUFFER_SIZE );
    if (NULL == NtfsReserved2) {
        NtfsFreePool( NtfsReserved1 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NtfsReserved3 = NtfsAllocatePoolNoRaise( NonPagedPool, LARGE_BUFFER_SIZE );
    if (NULL == NtfsReserved3) {
        NtfsFreePool( NtfsReserved1 );
        NtfsFreePool( NtfsReserved2 );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Create the device object.
    //

    RtlInitUnicodeString( &UnicodeString, L"\\Ntfs" );


    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &DeviceObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Note that because of the way data caching is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not in the cache, or the request is not buffered, we may,
    //  set up for Direct I/O by hand.
    //

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_QUERY_EA]                 =
    DriverObject->MajorFunction[IRP_MJ_SET_EA]                   =
    DriverObject->MajorFunction[IRP_MJ_QUERY_QUOTA]              =
    DriverObject->MajorFunction[IRP_MJ_SET_QUOTA]                =
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        = (PDRIVER_DISPATCH)NtfsFsdDispatchWait;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]           =
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY]           =
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY]             =
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] =
    DriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION]   = (PDRIVER_DISPATCH)NtfsFsdDispatch;

    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]             = (PDRIVER_DISPATCH)NtfsFsdLockControl;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]        = (PDRIVER_DISPATCH)NtfsFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          = (PDRIVER_DISPATCH)NtfsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_CREATE]                   = (PDRIVER_DISPATCH)NtfsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    = (PDRIVER_DISPATCH)NtfsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ]                     = (PDRIVER_DISPATCH)NtfsFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    = (PDRIVER_DISPATCH)NtfsFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]            = (PDRIVER_DISPATCH)NtfsFsdFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      = (PDRIVER_DISPATCH)NtfsFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  = (PDRIVER_DISPATCH)NtfsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                 = (PDRIVER_DISPATCH)NtfsFsdShutdown;
    DriverObject->MajorFunction[IRP_MJ_PNP]                      = (PDRIVER_DISPATCH)NtfsFsdPnp;

    DriverObject->FastIoDispatch = &NtfsFastIoDispatch;

    NtfsFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    NtfsFastIoDispatch.FastIoCheckIfPossible =   NtfsFastIoCheckIfPossible;  //  CheckForFastIo
    NtfsFastIoDispatch.FastIoRead =              NtfsCopyReadA;              //  Read
    NtfsFastIoDispatch.FastIoWrite =             NtfsCopyWriteA;             //  Write
    NtfsFastIoDispatch.FastIoQueryBasicInfo =    NtfsFastQueryBasicInfo;     //  QueryBasicInfo
    NtfsFastIoDispatch.FastIoQueryStandardInfo = NtfsFastQueryStdInfo;       //  QueryStandardInfo
    NtfsFastIoDispatch.FastIoLock =              NtfsFastLock;               //  Lock
    NtfsFastIoDispatch.FastIoUnlockSingle =      NtfsFastUnlockSingle;       //  UnlockSingle
    NtfsFastIoDispatch.FastIoUnlockAll =         NtfsFastUnlockAll;          //  UnlockAll
    NtfsFastIoDispatch.FastIoUnlockAllByKey =    NtfsFastUnlockAllByKey;     //  UnlockAllByKey
    NtfsFastIoDispatch.FastIoDeviceControl =     NULL;                       //  IoDeviceControl
    NtfsFastIoDispatch.FastIoDetachDevice            = NULL;
    NtfsFastIoDispatch.FastIoQueryNetworkOpenInfo    = NtfsFastQueryNetworkOpenInfo;
    NtfsFastIoDispatch.AcquireFileForNtCreateSection =  NtfsAcquireForCreateSection;
    NtfsFastIoDispatch.ReleaseFileForNtCreateSection =  NtfsReleaseForCreateSection;
    NtfsFastIoDispatch.AcquireForModWrite =          NtfsAcquireFileForModWrite;
    NtfsFastIoDispatch.MdlRead =                     NtfsMdlReadA;
    NtfsFastIoDispatch.MdlReadComplete =             FsRtlMdlReadCompleteDev;
    NtfsFastIoDispatch.PrepareMdlWrite =             NtfsPrepareMdlWriteA;
    NtfsFastIoDispatch.MdlWriteComplete =            FsRtlMdlWriteCompleteDev;
#ifdef  COMPRESS_ON_WIRE
    NtfsFastIoDispatch.FastIoReadCompressed =        NtfsCopyReadC;
    NtfsFastIoDispatch.FastIoWriteCompressed =       NtfsCopyWriteC;
    NtfsFastIoDispatch.MdlReadCompleteCompressed =   NtfsMdlReadCompleteCompressed;
    NtfsFastIoDispatch.MdlWriteCompleteCompressed =  NtfsMdlWriteCompleteCompressed;
#endif
    NtfsFastIoDispatch.FastIoQueryOpen =             NtfsNetworkOpenCreate;
    NtfsFastIoDispatch.AcquireForCcFlush =           NtfsAcquireFileForCcFlush;
    NtfsFastIoDispatch.ReleaseForCcFlush =           NtfsReleaseFileForCcFlush;

    //
    //  Read the registry to determine if we should upgrade the volumes.
    //

    DeallocateKeyValue = FALSE;
    KeyValueLength = KEY_WORK_AREA;
    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    KeyName.Buffer = UPGRADE_CHECK_SETUP_KEY_NAME;
    KeyName.Length = sizeof( UPGRADE_CHECK_SETUP_KEY_NAME ) - sizeof( WCHAR );
    KeyName.MaximumLength = sizeof( UPGRADE_CHECK_SETUP_KEY_NAME );

    ValueName.Buffer = UPGRADE_CHECK_SETUP_VALUE_NAME;
    ValueName.Length = sizeof( UPGRADE_CHECK_SETUP_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( UPGRADE_CHECK_SETUP_VALUE_NAME );

    //
    //  Look for the SystemSetupInProgress flag.
    //

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    if (NT_SUCCESS( Status )) {

        if (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 1) {

            SetFlag( NtfsDataFlags, NTFS_FLAGS_DISABLE_UPGRADE );
        }

    //
    //  Otherwise look to see if the setupdd value is present.
    //

    } else {

        if (KeyValueInformation == NULL) {

            DeallocateKeyValue = FALSE;
            KeyValueLength = KEY_WORK_AREA;
            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
        }

        KeyName.Buffer = UPGRADE_SETUPDD_KEY_NAME;
        KeyName.Length = sizeof( UPGRADE_SETUPDD_KEY_NAME ) - sizeof( WCHAR );
        KeyName.MaximumLength = sizeof( UPGRADE_SETUPDD_KEY_NAME );

        ValueName.Buffer = UPGRADE_SETUPDD_VALUE_NAME;
        ValueName.Length = sizeof( UPGRADE_SETUPDD_VALUE_NAME ) - sizeof( WCHAR );
        ValueName.MaximumLength = sizeof( UPGRADE_SETUPDD_VALUE_NAME );

        Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

        //
        //  The presence of this flag says "Don't upgrade"
        //

        if (NT_SUCCESS( Status )) {

            SetFlag( NtfsDataFlags, NTFS_FLAGS_DISABLE_UPGRADE );
        }
    }

    //
    //  Read the registry to determine if we are to create short names.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
    }

    KeyName.Buffer = COMPATIBILITY_MODE_KEY_NAME;
    KeyName.Length = sizeof( COMPATIBILITY_MODE_KEY_NAME ) - sizeof( WCHAR );
    KeyName.MaximumLength = sizeof( COMPATIBILITY_MODE_KEY_NAME );

    ValueName.Buffer = COMPATIBILITY_MODE_VALUE_NAME;
    ValueName.Length = sizeof( COMPATIBILITY_MODE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( COMPATIBILITY_MODE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero then create the 8.3
    //  names.
    //

    if (!NT_SUCCESS( Status ) ||
        (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 0)) {

        SetFlag( NtfsDataFlags, NTFS_FLAGS_CREATE_8DOT3_NAMES );
    }

    //
    //  Read the registry to determine if we allow extended character in short name.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
    }

    ValueName.Buffer = EXTENDED_CHAR_MODE_VALUE_NAME;
    ValueName.Length = sizeof( EXTENDED_CHAR_MODE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( EXTENDED_CHAR_MODE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero then do not allow
    //  extended character in 8.3 names.
    //

    if (NT_SUCCESS( Status ) &&
        (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 1)) {

        SetFlag( NtfsDataFlags, NTFS_FLAGS_ALLOW_EXTENDED_CHAR );
    }

    //
    //  Read the registry to determine if we should disable last access updates.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
    }

    ValueName.Buffer = DISABLE_LAST_ACCESS_VALUE_NAME;
    ValueName.Length = sizeof( DISABLE_LAST_ACCESS_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( DISABLE_LAST_ACCESS_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero then don't update last access times.
    //

    if (NT_SUCCESS( Status ) &&
        (*((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset )) == 1)) {

        SetFlag( NtfsDataFlags, NTFS_FLAGS_DISABLE_LAST_ACCESS );
    }

    //
    //  Read the registry to determine if we should change the Mft
    //  Zone reservation.
    //

    NtfsMftZoneMultiplier = 1;

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
    }

    ValueName.Buffer = MFT_ZONE_SIZE_VALUE_NAME;
    ValueName.Length = sizeof( MFT_ZONE_SIZE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( MFT_ZONE_SIZE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero or greater than 4 then
    //  use the default.
    //

    if (NT_SUCCESS( Status )) {

        ULONG NewMultiplier = *((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset ));

        if ((NewMultiplier != 0) && (NewMultiplier <= 4)) {

            NtfsMftZoneMultiplier = NewMultiplier;
        }
    }

    //
    //  Read the registry to determine if we should change the Mft
    //  Zone reservation.
    //

    MemoryMultiplier = 1;

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
    }

    ValueName.Buffer = MEMORY_USAGE_VALUE_NAME;
    ValueName.Length = sizeof( MEMORY_USAGE_VALUE_NAME ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( MEMORY_USAGE_VALUE_NAME );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    //
    //  If we didn't find the value or the value is zero or greater than 2 then
    //  use the default.
    //

    if (NT_SUCCESS( Status )) {

        ULONG NewMultiplier = *((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset ));

        if ((NewMultiplier != 0) && (NewMultiplier <= 2)) {

            MemoryMultiplier = NewMultiplier;
        }
    }

    //
    //  Read the registry to determine if the quota notification rate has been
    //  change from the default.
    //

    if (KeyValueInformation == NULL) {

        DeallocateKeyValue = FALSE;
        KeyValueLength = KEY_WORK_AREA;
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION) Buffer;
    }

    ValueName.Buffer = QUOTA_NOTIFY_RATE;
    ValueName.Length = sizeof( QUOTA_NOTIFY_RATE ) - sizeof( WCHAR );
    ValueName.MaximumLength = sizeof( QUOTA_NOTIFY_RATE );

    Status = NtfsQueryValueKey( &KeyName, &ValueName, &KeyValueLength, &KeyValueInformation, &DeallocateKeyValue );

    if (NT_SUCCESS( Status )) {

        Value = *((PULONG) Add2Ptr( KeyValueInformation, KeyValueInformation->DataOffset ));

        //
        //  Value is in second, convert it to 100ns.
        //

        NtfsMaxQuotaNotifyRate = (ULONGLONG) Value * 1000 * 1000 * 10;
    }

    //
    //  Initialize the global ntfs data structure
    //

    NtfsInitializeNtfsData( DriverObject, (USHORT) MemoryMultiplier );

    //
    //  Remember the flags we collected from the registry above.
    //

    SetFlag( NtfsData.Flags, NtfsDataFlags );

    if (NtfsRunningOnWhat( VER_SUITE_PERSONAL, VER_NT_WORKSTATION )) {
        SetFlag( NtfsData.Flags, NTFS_FLAGS_PERSONAL );
    }

    KeInitializeMutant( &StreamFileCreationMutex, FALSE );
    KeInitializeEvent( &NtfsEncryptionPendingEvent, NotificationEvent, TRUE );

    //
    //  Initialize the Ntfs Mcb global data queue and variables
    //

    ExInitializeFastMutex( &NtfsMcbFastMutex );
    InitializeListHead( &NtfsMcbLruQueue );
    NtfsMcbCleanupInProgress = FALSE;

    switch (MmQuerySystemSize()) {

    case MmSmallSystem:

        NtfsMcbHighWaterMark = 1000;
        NtfsMcbLowWaterMark = 500;
        NtfsMcbCurrentLevel = 0;
        break;

    case MmMediumSystem:

        NtfsMcbHighWaterMark = 4000;
        NtfsMcbLowWaterMark = 2000;
        NtfsMcbCurrentLevel = 0;
        break;

    case MmLargeSystem:
    default:

        NtfsMcbHighWaterMark = 16000;
        NtfsMcbLowWaterMark = 8000;
        NtfsMcbCurrentLevel = 0;
        break;
    }

    //
    //  Bias by the memory multiplier value from the registry.
    //

    NtfsMcbHighWaterMark *= MemoryMultiplier;
    NtfsMcbLowWaterMark *= MemoryMultiplier;
    NtfsMcbCurrentLevel *= MemoryMultiplier;

    //
    //  Allocate and initialize the free Eresource array
    //

    if ((NtfsData.FreeEresourceArray =
         NtfsAllocatePoolWithTagNoRaise( NonPagedPool, (NtfsData.FreeEresourceTotal * sizeof( PERESOURCE )), 'rftN')) == NULL) {

        KeBugCheck( NTFS_FILE_SYSTEM );
    }

    RtlZeroMemory( NtfsData.FreeEresourceArray, NtfsData.FreeEresourceTotal * sizeof( PERESOURCE ));

    //
    //  Keep a zeroed out object id extended info around for comparisons in objidsup.c.
    //

    RtlZeroMemory( NtfsZeroExtendedInfo, sizeof( NtfsZeroExtendedInfo ));

    //
    //  Register the file system with the I/O system
    //

    IoRegisterFileSystem( DeviceObject );

    //
    //  Initialize logging.
    //

    NtfsInitializeLogging();

    //
    //  Initialize global variables.  (ntfsdata.c assumes 2-digit value for
    //  $FILE_NAME)
    //

    ASSERT(($FILE_NAME >= 0x10) && ($FILE_NAME < 0x100));

    ASSERT( ((BOOLEAN) IRP_CONTEXT_STATE_WAIT) != FALSE );

    //
    //  Some big assumptions are made when these bits are set in create.  Let's
    //  make sure those assumptions are still valid.
    //

    ASSERT( (READ_DATA_ACCESS == FILE_READ_DATA) &&
            (WRITE_DATA_ACCESS == FILE_WRITE_DATA) &&
            (APPEND_DATA_ACCESS == FILE_APPEND_DATA) &&
            (WRITE_ATTRIBUTES_ACCESS == FILE_WRITE_ATTRIBUTES) &&
            (EXECUTE_ACCESS == FILE_EXECUTE) &&
            (BACKUP_ACCESS == (TOKEN_HAS_BACKUP_PRIVILEGE << 2)) &&
            (RESTORE_ACCESS == (TOKEN_HAS_RESTORE_PRIVILEGE << 2)) );

    //
    //  Let's make sure the number of attributes in the table is correct.
    //

#ifdef NTFSDBG
    {
        ULONG Count = 0;

        while (NtfsAttributeDefinitions[Count].AttributeTypeCode != $UNUSED) {

            Count += 1;
        }

        //
        //  We want to add one for the empty end record.
        //

        Count += 1;

        ASSERTMSG( "Update NtfsAttributeDefinitionsCount in attrdata.c",
                   (Count == NtfsAttributeDefinitionsCount) );
    }
#endif

    //
    //  Setup the CheckPointAllVolumes callback item, timer, dpc, and
    //  status.
    //

    ExInitializeWorkItem( &NtfsData.VolumeCheckpointItem,
                          NtfsCheckpointAllVolumes,
                          (PVOID)NULL );

    KeInitializeTimer( &NtfsData.VolumeCheckpointTimer );

    NtfsData.VolumeCheckpointStatus = 0;

    KeInitializeDpc( &NtfsData.VolumeCheckpointDpc,
                     NtfsVolumeCheckpointDpc,
                     NULL );
    NtfsData.TimerStatus = TIMER_NOT_SET;

    //
    //  Setup the UsnTimeout callback item, timer, dpc, and
    //  status.
    //

    ExInitializeWorkItem( &NtfsData.UsnTimeOutItem,
                          NtfsCheckUsnTimeOut,
                          (PVOID)NULL );

    KeInitializeTimer( &NtfsData.UsnTimeOutTimer );

    KeInitializeDpc( &NtfsData.UsnTimeOutDpc,
                     NtfsUsnTimeOutDpc,
                     NULL );

    {
        LONGLONG FiveMinutesFromNow = -5*1000*1000*10;

        FiveMinutesFromNow *= 60;

        KeSetTimer( &NtfsData.UsnTimeOutTimer,
                    *(PLARGE_INTEGER)&FiveMinutesFromNow,
                    &NtfsData.UsnTimeOutDpc );
    }

    //
    //  Initialize sync objects for reserved buffers
    //

    ExInitializeFastMutex( &NtfsReservedBufferMutex );
    ExInitializeResource( &NtfsReservedBufferResource );

    //
    //  Zero out the global upcase table, that way we'll fill it in on
    //  our first successful mount
    //

    NtfsData.UpcaseTable = NULL;
    NtfsData.UpcaseTableSize = 0;

    ExInitializeFastMutex( &NtfsScavengerLock );
    NtfsScavengerWorkList = NULL;
    NtfsScavengerRunning = FALSE;

    //
    // Initialize the EFS driver
    //

    IoRegisterDriverReinitialization( DriverObject, NtfsLoadAddOns, NULL );

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}


VOID
NtfsInitializeNtfsData (
    IN PDRIVER_OBJECT DriverObject,
    IN USHORT MemoryMultiplier
    )

/*++

Routine Description:

    This routine initializes the global ntfs data record

Arguments:

    DriverObject - Supplies the driver object for NTFS.

    MemoryMultiplier - Amount to multiply the memory usage.

Return Value:

    None.

--*/

{
    USHORT FileLockMaxDepth;
    USHORT IoContextMaxDepth;
    USHORT IrpContextMaxDepth;
    USHORT KeventMaxDepth;
    USHORT ScbNonpagedMaxDepth;
    USHORT ScbSnapshotMaxDepth;

    USHORT CcbDataMaxDepth;
    USHORT CcbMaxDepth;
    USHORT DeallocatedRecordsMaxDepth;
    USHORT FcbDataMaxDepth;
    USHORT FcbIndexMaxDepth;
    USHORT IndexContextMaxDepth;
    USHORT LcbMaxDepth;
    USHORT NukemMaxDepth;
    USHORT ScbDataMaxDepth;
    USHORT CompSyncMaxDepth;

    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;
    BOOLEAN CapturedSubjectContext = FALSE;

    PACL SystemDacl = NULL;
    ULONG SystemDaclLength;

    PSID AdminSid = NULL;
    PSID SystemSid = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Zero the record.
    //

    RtlZeroMemory( &NtfsData, sizeof(NTFS_DATA));

    //
    //  Initialize the queue of mounted Vcbs
    //

    InitializeListHead(&NtfsData.VcbQueue);

    //
    //  This list head keeps track of closes yet to be done.
    //

    InitializeListHead( &NtfsData.AsyncCloseList );
    InitializeListHead( &NtfsData.DelayedCloseList );

    ExInitializeWorkItem( &NtfsData.NtfsCloseItem,
                          (PWORKER_THREAD_ROUTINE)NtfsFspClose,
                          NULL );

    //
    //  Set the driver object, device object, and initialize the global
    //  resource protecting the file system
    //

    NtfsData.DriverObject = DriverObject;

    ExInitializeResource( &NtfsData.Resource );

    ExInitializeFastMutex( &NtfsData.NtfsDataLock );

    //
    //  Now allocate and initialize the s-list structures used as our pool
    //  of IRP context records.  The size of the zone is based on the
    //  system memory size.  We also initialize the spin lock used to protect
    //  the zone.
    //

    {

        switch ( MmQuerySystemSize() ) {

        case MmSmallSystem:

            NtfsData.FreeEresourceTotal = 14;

            //
            //  Nonpaged Lookaside list maximum depths
            //

            FileLockMaxDepth           = 8;
            IoContextMaxDepth          = 8;
            IrpContextMaxDepth         = 4;
            KeventMaxDepth             = 8;
            ScbNonpagedMaxDepth        = 8;
            ScbSnapshotMaxDepth        = 8;
            CompSyncMaxDepth           = 4;

            //
            //  Paged Lookaside list maximum depths
            //

            CcbDataMaxDepth            = 4;
            CcbMaxDepth                = 4;
            DeallocatedRecordsMaxDepth = 8;
            FcbDataMaxDepth            = 8;
            FcbIndexMaxDepth           = 4;
            IndexContextMaxDepth       = 8;
            LcbMaxDepth                = 4;
            NukemMaxDepth              = 8;
            ScbDataMaxDepth            = 4;

            SetFlag( NtfsData.Flags, NTFS_FLAGS_SMALL_SYSTEM );
            NtfsMaxDelayedCloseCount = MAX_DELAYED_CLOSE_COUNT;
            NtfsAsyncPostThreshold = ASYNC_CLOSE_POST_THRESHOLD;

            break;

        case MmMediumSystem:

            NtfsData.FreeEresourceTotal = 30;

            //
            //  Nonpaged Lookaside list maximum depths
            //

            FileLockMaxDepth           = 8;
            IoContextMaxDepth          = 8;
            IrpContextMaxDepth         = 8;
            KeventMaxDepth             = 8;
            ScbNonpagedMaxDepth        = 30;
            ScbSnapshotMaxDepth        = 8;
            CompSyncMaxDepth           = 8;

            //
            //  Paged Lookaside list maximum depths
            //

            CcbDataMaxDepth            = 12;
            CcbMaxDepth                = 6;
            DeallocatedRecordsMaxDepth = 8;
            FcbDataMaxDepth            = 30;
            FcbIndexMaxDepth           = 12;
            IndexContextMaxDepth       = 8;
            LcbMaxDepth                = 12;
            NukemMaxDepth              = 8;
            ScbDataMaxDepth            = 12;

            SetFlag( NtfsData.Flags, NTFS_FLAGS_MEDIUM_SYSTEM );
            NtfsMaxDelayedCloseCount = 4 * MAX_DELAYED_CLOSE_COUNT;
            NtfsAsyncPostThreshold = 4 * ASYNC_CLOSE_POST_THRESHOLD;

            break;

        case MmLargeSystem:

            SetFlag( NtfsData.Flags, NTFS_FLAGS_LARGE_SYSTEM );
            NtfsMaxDelayedCloseCount = 16 * MAX_DELAYED_CLOSE_COUNT;
            NtfsAsyncPostThreshold = 16 * ASYNC_CLOSE_POST_THRESHOLD;

            if (MmIsThisAnNtAsSystem()) {

                NtfsData.FreeEresourceTotal = 256;

                //
                //  Nonpaged Lookaside list maximum depths
                //

                FileLockMaxDepth           = 8;
                IoContextMaxDepth          = 8;
                IrpContextMaxDepth         = 256;
                KeventMaxDepth             = 8;
                ScbNonpagedMaxDepth        = 128;
                ScbSnapshotMaxDepth        = 8;
                CompSyncMaxDepth           = 32;

                //
                //  Paged Lookaside list maximum depths
                //

                CcbDataMaxDepth            = 40;
                CcbMaxDepth                = 20;
                DeallocatedRecordsMaxDepth = 8;
                FcbDataMaxDepth            = 128;
                FcbIndexMaxDepth           = 40;
                IndexContextMaxDepth       = 8;
                LcbMaxDepth                = 40;
                NukemMaxDepth              = 8;
                ScbDataMaxDepth            = 40;

            } else {

                NtfsData.FreeEresourceTotal = 128;

                //
                //  Nonpaged Lookaside list maximum depths
                //

                FileLockMaxDepth           = 8;
                IoContextMaxDepth          = 8;
                IrpContextMaxDepth         = 64;
                KeventMaxDepth             = 8;
                ScbNonpagedMaxDepth        = 64;
                ScbSnapshotMaxDepth        = 8;
                CompSyncMaxDepth           = 16;

                //
                //  Paged Lookaside list maximum depths
                //

                CcbDataMaxDepth            = 20;
                CcbMaxDepth                = 10;
                DeallocatedRecordsMaxDepth = 8;
                FcbDataMaxDepth            = 64;
                FcbIndexMaxDepth           = 20;
                IndexContextMaxDepth       = 8;
                LcbMaxDepth                = 20;
                NukemMaxDepth              = 8;
                ScbDataMaxDepth            = 20;
            }

            break;
        }

        NtfsMinDelayedCloseCount = NtfsMaxDelayedCloseCount * 4 / 5;
        NtfsThrottleCreates = NtfsMinDelayedCloseCount * 2;

        //
        //  Now bias by the memory multiplier value.
        //

        NtfsMaxDelayedCloseCount *= MemoryMultiplier;
        NtfsAsyncPostThreshold *= MemoryMultiplier;
        NtfsData.FreeEresourceTotal *= MemoryMultiplier;
        FileLockMaxDepth           *= MemoryMultiplier;
        IoContextMaxDepth          *= MemoryMultiplier;
        IrpContextMaxDepth         *= MemoryMultiplier;
        KeventMaxDepth             *= MemoryMultiplier;
        ScbNonpagedMaxDepth        *= MemoryMultiplier;
        ScbSnapshotMaxDepth        *= MemoryMultiplier;
        CompSyncMaxDepth           *= MemoryMultiplier;
        CcbDataMaxDepth            *= MemoryMultiplier;
        CcbMaxDepth                *= MemoryMultiplier;
        DeallocatedRecordsMaxDepth *= MemoryMultiplier;
        FcbDataMaxDepth            *= MemoryMultiplier;
        FcbIndexMaxDepth           *= MemoryMultiplier;
        IndexContextMaxDepth       *= MemoryMultiplier;
        LcbMaxDepth                *= MemoryMultiplier;
        NukemMaxDepth              *= MemoryMultiplier;
        ScbDataMaxDepth            *= MemoryMultiplier;
        NtfsMinDelayedCloseCount *= MemoryMultiplier;
        NtfsThrottleCreates *= MemoryMultiplier;
    }

    //
    //  Initialize our various lookaside lists.  To make it a bit more readable we'll
    //  define two quick macros to do the initialization
    //

#if DBG && i386 && defined (NTFSPOOLCHECK)
#define NPagedInit(L,S,T,D) { ExInitializeNPagedLookasideList( (L), NtfsDebugAllocatePoolWithTag, NtfsDebugFreePool, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#define PagedInit(L,S,T,D)  { ExInitializePagedLookasideList(  (L), NtfsDebugAllocatePoolWithTag, NtfsDebugFreePool, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#else   //  DBG && i386
#define NPagedInit(L,S,T,D) { ExInitializeNPagedLookasideList( (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#define PagedInit(L,S,T,D)  { ExInitializePagedLookasideList(  (L), NULL, NULL, POOL_RAISE_IF_ALLOCATION_FAILURE, S, T, D); }
#endif  //  DBG && i386

    NPagedInit( &NtfsIoContextLookasideList,   sizeof(NTFS_IO_CONTEXT), 'IftN', IoContextMaxDepth );
    NPagedInit( &NtfsIrpContextLookasideList,  sizeof(IRP_CONTEXT),     'iftN', IrpContextMaxDepth );
    NPagedInit( &NtfsKeventLookasideList,      sizeof(KEVENT),          'KftN', KeventMaxDepth );
    NPagedInit( &NtfsScbNonpagedLookasideList, sizeof(SCB_NONPAGED),    'nftN', ScbNonpagedMaxDepth );
    NPagedInit( &NtfsScbSnapshotLookasideList, sizeof(SCB_SNAPSHOT),    'TftN', ScbSnapshotMaxDepth );

    //
    //  The compresson sync routine needs its own allocate and free routine in order to initialize and
    //  cleanup the embedded resource.
    //

    ExInitializeNPagedLookasideList( &NtfsCompressSyncLookasideList,
                                     NtfsAllocateCompressionSync,
                                     NtfsDeallocateCompressionSync,
                                     0,
                                     sizeof( COMPRESSION_SYNC ),
                                     'vftN',
                                     CompSyncMaxDepth );

    PagedInit(  &NtfsCcbLookasideList,                sizeof(CCB),                 'CftN', CcbMaxDepth );
    PagedInit(  &NtfsCcbDataLookasideList,            sizeof(CCB_DATA),            'cftN', CcbDataMaxDepth );
    PagedInit(  &NtfsDeallocatedRecordsLookasideList, sizeof(DEALLOCATED_RECORDS), 'DftN', DeallocatedRecordsMaxDepth );
    PagedInit(  &NtfsFcbDataLookasideList,            sizeof(FCB_DATA),            'fftN', FcbDataMaxDepth );
    PagedInit(  &NtfsFcbIndexLookasideList,           sizeof(FCB_INDEX),           'FftN', FcbIndexMaxDepth );
    PagedInit(  &NtfsIndexContextLookasideList,       sizeof(INDEX_CONTEXT),       'EftN', IndexContextMaxDepth );
    PagedInit(  &NtfsLcbLookasideList,                sizeof(LCB),                 'lftN', LcbMaxDepth );
    PagedInit(  &NtfsNukemLookasideList,              sizeof(NUKEM),               'NftN', NukemMaxDepth );
    PagedInit(  &NtfsScbDataLookasideList,            SIZEOF_SCB_DATA,             'sftN', ScbDataMaxDepth );

    //
    //  Initialize the cache manager callback routines,  First are the routines
    //  for normal file manipulations, followed by the routines for
    //  volume manipulations.
    //

    {
        PCACHE_MANAGER_CALLBACKS Callbacks = &NtfsData.CacheManagerCallbacks;

        Callbacks->AcquireForLazyWrite = &NtfsAcquireScbForLazyWrite;
        Callbacks->ReleaseFromLazyWrite = &NtfsReleaseScbFromLazyWrite;
        Callbacks->AcquireForReadAhead = &NtfsAcquireScbForReadAhead;
        Callbacks->ReleaseFromReadAhead = &NtfsReleaseScbFromReadAhead;
    }

    {
        PCACHE_MANAGER_CALLBACKS Callbacks = &NtfsData.CacheManagerVolumeCallbacks;

        Callbacks->AcquireForLazyWrite = &NtfsAcquireVolumeFileForLazyWrite;
        Callbacks->ReleaseFromLazyWrite = &NtfsReleaseVolumeFileFromLazyWrite;
        Callbacks->AcquireForReadAhead = NULL;
        Callbacks->ReleaseFromReadAhead = NULL;
    }

    //
    //  Initialize the queue of read ahead threads
    //

    InitializeListHead(&NtfsData.ReadAheadThreads);

    //
    //  Set up global pointer to our process.
    //

    NtfsData.OurProcess = PsGetCurrentProcess();

    //
    //  Use a try-finally to cleanup on errors.
    //

    try {

        SECURITY_DESCRIPTOR NewDescriptor;
        SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;

        SubjectContext = NtfsAllocatePool( PagedPool, sizeof( SECURITY_SUBJECT_CONTEXT ));
        SeCaptureSubjectContext( SubjectContext );
        CapturedSubjectContext = TRUE;

        //
        //  Build the default security descriptor which gives full access to
        //  system and administrator.
        //

        AdminSid = (PSID) NtfsAllocatePool( PagedPool, RtlLengthRequiredSid( 2 ));
        RtlInitializeSid( AdminSid, &Authority, 2 );
        *(RtlSubAuthoritySid( AdminSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid( AdminSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

        SystemSid = (PSID) NtfsAllocatePool( PagedPool, RtlLengthRequiredSid( 1 ));
        RtlInitializeSid( SystemSid, &Authority, 1 );
        *(RtlSubAuthoritySid( SystemSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

        SystemDaclLength = sizeof( ACL ) +
                           (2 * sizeof( ACCESS_ALLOWED_ACE )) +
                           SeLengthSid( AdminSid ) +
                           SeLengthSid( SystemSid ) +
                           8; // The 8 is just for good measure

        SystemDacl = NtfsAllocatePool( PagedPool, SystemDaclLength );

        Status = RtlCreateAcl( SystemDacl, SystemDaclLength, ACL_REVISION2 );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlAddAccessAllowedAce( SystemDacl,
                                         ACL_REVISION2,
                                         GENERIC_ALL,
                                         SystemSid );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlAddAccessAllowedAce( SystemDacl,
                                         ACL_REVISION2,
                                         GENERIC_ALL,
                                         AdminSid );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlCreateSecurityDescriptor( &NewDescriptor,
                                              SECURITY_DESCRIPTOR_REVISION1 );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = RtlSetDaclSecurityDescriptor( &NewDescriptor,
                                               TRUE,
                                               SystemDacl,
                                               FALSE );

        if (!NT_SUCCESS( Status )) { leave; }

        Status = SeAssignSecurity( NULL,
                                   &NewDescriptor,
                                   &NtfsData.DefaultDescriptor,
                                   FALSE,
                                   SubjectContext,
                                   IoGetFileObjectGenericMapping(),
                                   PagedPool );

        if (!NT_SUCCESS( Status )) { leave; }

        NtfsData.DefaultDescriptorLength = RtlLengthSecurityDescriptor( NtfsData.DefaultDescriptor );

        ASSERT( SeValidSecurityDescriptor( NtfsData.DefaultDescriptorLength,
                                           NtfsData.DefaultDescriptor ));

    } finally {

        if (CapturedSubjectContext) {

            SeReleaseSubjectContext( SubjectContext );
        }

        if (SubjectContext != NULL) { NtfsFreePool( SubjectContext ); }

        if (SystemDacl != NULL) { NtfsFreePool( SystemDacl ); }

        if (AdminSid != NULL) { NtfsFreePool( AdminSid ); }

        if (SystemSid != NULL) { NtfsFreePool( SystemSid ); }
    }

    //
    //  Raise if we hit an error building the security descriptor.
    //

    if (!NT_SUCCESS( Status )) { ExRaiseStatus( Status ); }

    //
    //  Set its node type code and size.  We do this last as a flag to indicate that the structure is
    //  initialized.
    //

    NtfsData.NodeTypeCode = NTFS_NTC_DATA_HEADER;
    NtfsData.NodeByteSize = sizeof(NTFS_DATA);

#ifdef SYSCACHE_DEBUG
    {
        int Index;

        for (Index=0; Index < NUM_SC_LOGSETS; Index++) {
            NtfsSyscacheLogSet[Index].SyscacheLog = 0;
            NtfsSyscacheLogSet[Index].Scb = 0;
        }
        NtfsCurrentSyscacheLogSet = -1;
        NtfsCurrentSyscacheOnDiskEntry = -1;
    }
#endif

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support routine
//

NTSTATUS
NtfsQueryValueKey (
    IN PUNICODE_STRING KeyName,
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG ValueLength,
    IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
    IN OUT PBOOLEAN DeallocateKeyValue
    )

/*++

Routine Description:

    Given a unicode value name this routine will return the registry
    information for the given key and value.

Arguments:

    KeyName - the unicode name for the key being queried.

    ValueName - the unicode name for the registry value located in the registry.

    ValueLength - On input it is the length of the allocated buffer.  On output
        it is the length of the buffer.  It may change if the buffer is
        reallocated.

    KeyValueInformation - On input it points to the buffer to use to query the
        the value information.  On output it points to the buffer used to
        perform the query.  It may change if a larger buffer is needed.

    DeallocateKeyValue - Indicates if the KeyValueInformation buffer is on the
        stack or needs to be deallocated.

Return Value:

    NTSTATUS - indicates the status of querying the registry.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID NewKey;

    InitializeObjectAttributes( &ObjectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    Status = ZwOpenKey( &Handle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    RequestLength = *ValueLength;


    while (TRUE) {

        Status = ZwQueryValueKey( Handle,
                                  ValueName,
                                  KeyValueFullInformation,
                                  *KeyValueInformation,
                                  RequestLength,
                                  &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (*DeallocateKeyValue) {

                NtfsFreePool( *KeyValueInformation );
                *ValueLength = 0;
                *KeyValueInformation = NULL;
                *DeallocateKeyValue = FALSE;
            }

            RequestLength += 256;

            NewKey = (PKEY_VALUE_FULL_INFORMATION)
                     NtfsAllocatePoolWithTagNoRaise( PagedPool,
                                                     RequestLength,
                                                     'xftN');

            if (NewKey == NULL) {
                return STATUS_NO_MEMORY;
            }

            *KeyValueInformation = NewKey;
            *ValueLength = RequestLength;
            *DeallocateKeyValue = TRUE;

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        //
        // Treat as if no value was found if the data length is zero.
        //

        if ((*KeyValueInformation)->DataLength == 0) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    return Status;
}

BOOLEAN
NtfsRunningOnWhat(
    IN USHORT SuiteMask,
    IN UCHAR ProductType
    )

/*++

Routine Description:

    This function checks the system to see if
    NTFS is running on a specified version of
    the operating system.

    The different versions are denoted by the product
    id and the product suite.

Arguments:

    SuiteMask - The mask that specifies the requested suite(s)
    ProductType - The product type that specifies the requested product type

Return Value:

    TRUE if NTFS is running on the requested version
    FALSE otherwise.

--*/

{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    PAGED_CODE();

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = SuiteMask;
    OsVer.wProductType = ProductType;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_SUITENAME, VER_AND );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE | VER_SUITENAME,
                                 ConditionMask) == STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\prefxsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Ntfs Prefix support routines

Author:

    Gary Kimura     [GaryKi]        21-May-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_PREFXSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_PREFXSUP)

//
//  Local procedures
//

#ifdef NTFS_CHECK_SPLAY
VOID
NtfsCheckSplay (
    IN PRTL_SPLAY_LINKS Root
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsFindPrefix)
#pragma alloc_text(PAGE, NtfsFindNameLink)
#pragma alloc_text(PAGE, NtfsInsertNameLink)
#pragma alloc_text(PAGE, NtfsInsertPrefix)
#pragma alloc_text(PAGE, NtfsRemovePrefix)

#ifdef NTFS_CHECK_SPLAY
#pragma alloc_text(PAGE, NtfsCheckSplay)
#endif
#endif


VOID
NtfsInsertPrefix (
    IN PLCB Lcb,
    IN ULONG CreateFlags
    )

/*++

Routine Description:

    This routine inserts the names in the given Lcb into the links for the
    parent.

Arguments:

    Lcb - This is the link to insert.

    CreateFlags - Indicates if we should insert the case-insensitive name.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT( (Lcb->Scb == NULL) ||
            NtfsIsExclusiveScb( Lcb->Scb ) );
    //
    //  Attempt to insert the case-insensitive name.  It is possible that
    //  we can't enter this name.
    //

    if (FlagOn( CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

        if (!FlagOn( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE ) &&
            NtfsInsertNameLink( &Lcb->Scb->ScbType.Index.IgnoreCaseNode,
                                &Lcb->IgnoreCaseLink )) {

            SetFlag( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE );
        }

    } else if (!FlagOn( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE )) {

        if (!NtfsInsertNameLink( &Lcb->Scb->ScbType.Index.ExactCaseNode,
                                 &Lcb->ExactCaseLink )) {

            NtfsBugCheck( 0, 0, 0 );
        }

        SetFlag( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE );
    }

    return;
}


VOID
NtfsRemovePrefix (
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine deletes all of the Prefix entries that exist for the input
    Lcb.

Arguments:

    Lcb - Supplies the Lcb whose prefixes are to be removed

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Remove the case-insensitive link.
    //

    if (FlagOn( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE )) {

        NtfsRemoveNameLink( &Lcb->Scb->ScbType.Index.IgnoreCaseNode,
                            &Lcb->IgnoreCaseLink );

        ClearFlag( Lcb->LcbState, LCB_STATE_IGNORE_CASE_IN_TREE );
    }

    //
    //  Now do the same for the exact case name.
    //

    if (FlagOn( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE )) {

        NtfsRemoveNameLink( &Lcb->Scb->ScbType.Index.ExactCaseNode,
                            &Lcb->ExactCaseLink );

        ClearFlag( Lcb->LcbState, LCB_STATE_EXACT_CASE_IN_TREE );
    }

    return;
}


PLCB
NtfsFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB StartingScb,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    IN OUT UNICODE_STRING FullFileName,
    IN OUT PULONG CreateFlags,
    OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine begins from the given Scb and walks through all of
    components of the name looking for the longest match in the prefix
    splay trees.  The search is relative to the starting Scb so the
    full name may not begin with a '\'.  On return this routine will
    update Current Fcb with the lowest point it has travelled in the
    tree.  It will also hold only that resource on return and it must
    hold that resource.

Arguments:

    StartingScb - Supplies the Scb to start the search from.

    CurrentFcb - Address to store the lowest Fcb we find on this search.
        On return we will have acquired this Fcb.

    LcbForTeardown - If we encounter an Lcb we must teardown on error we
        store it here.

    FullFileName - Supplies the input string to search for.  After the search the
        buffer for this string will be modified so that for the characters that did
        match will be the exact case of what we found.
        
    CreateFlags - Flags for the create option - we are interested in whether
        this is a case-insensitive compare and we also will set the dos only component flag

    RemainingName - Returns the string when the prefix no longer matches.
        For example, if the input string is "alpha\beta" only matches the
        root directory then the remaining string is "alpha\beta".  If the
        same string matches an LCB for "alpha" then the remaining string is
        "beta".

Return Value:

    PLCB - Returns a pointer to the Lcb corresponding to the longest match
        in the splay tree.  NULL if we didn't even find one entry.

--*/

{
    PSCB LastScb = NULL;
    PLCB LastLcb = NULL;
    PLCB ThisLcb;
    PNAME_LINK NameLink;
    UNICODE_STRING NextComponent;
    UNICODE_STRING Tail;
    NTSTATUS Status;
    BOOLEAN DroppedParent;
    BOOLEAN NeedSnapShot = FALSE;

    PAGED_CODE();

    //
    //  Start by setting the remaining name to the full name to be parsed.
    //

    *RemainingName = FullFileName;

    //
    //  If there are no characters left or the starting Scb is not an index
    //  or the name begins with a ':' or the Fcb denotes a reparse point
    //  then return without looking up the name.
    //

    if (RemainingName->Length == 0 ||
        StartingScb->AttributeTypeCode != $INDEX_ALLOCATION ||
        RemainingName->Buffer[0] == L':' ||
        FlagOn( (StartingScb->Fcb)->Info.FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT )) {

        return NULL;
    }

    //
    //  Loop until we find the longest matching prefix.
    //

    while (TRUE) {

        ASSERT( NtfsIsExclusiveScb( StartingScb ) );

        //
        //  Get the next component off of the list.
        //

        Status = NtfsDissectName( *RemainingName,
                                  &NextComponent,
                                  &Tail );
        if (!NT_SUCCESS( Status )) {
            return NULL;
        }

        //
        //  Check if this name is in the splay tree for this Scb.
        //

        if (FlagOn( *CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

            NameLink = NtfsFindNameLink( &StartingScb->ScbType.Index.IgnoreCaseNode,
                                         &NextComponent );

            ThisLcb = CONTAINING_RECORD( NameLink, LCB, IgnoreCaseLink );

        } else {

            NameLink = NtfsFindNameLink( &StartingScb->ScbType.Index.ExactCaseNode,
                                         &NextComponent );

            ThisLcb = CONTAINING_RECORD( NameLink, LCB, ExactCaseLink );
        }

        //
        //  If we didn't find a match then return the Fcb for the current Scb.
        //

        if (NameLink == NULL) {

            if (NeedSnapShot) {

                //
                // NtfsCreateScb was not called on the StartingScb so take a
                // snapshot now.
                //

                NtfsSnapshotScb( IrpContext, StartingScb );
            }

            return LastLcb;
        }

        //
        //  If this is a case-insensitive match then copy the exact case of the name into
        //  the input buffer.
        //

        if (FlagOn( *CreateFlags, CREATE_FLAG_IGNORE_CASE )) {

            RtlCopyMemory( NextComponent.Buffer,
                           ThisLcb->ExactCaseLink.LinkName.Buffer,
                           NextComponent.Length );
        }

        //
        //  Update the caller's remaining name string to reflect the fact that we found
        //  a match.
        //

        *RemainingName = Tail;

        //
        //  Before we give up the previous Lcb check if the name was a DOS-ONLY
        //  name and set the return boolean if so.
        //

        if (LastLcb != NULL &&
            LastLcb->FileNameAttr->Flags == FILE_NAME_DOS) {

            SetFlag( *CreateFlags, CREATE_FLAG_DOS_ONLY_COMPONENT );
        }

        //
        //  Update the pointers to the Lcb.
        //

        LastLcb = ThisLcb;

        DroppedParent = FALSE;

        //
        //  We want to acquire the next Fcb and release the one we currently
        //  have.  Try to do a fast acquire.
        //

        if (!NtfsAcquireFcbWithPaging( IrpContext, ThisLcb->Fcb, ACQUIRE_DONT_WAIT )) {

            //
            //  Reference the link and Fcb so they don't go away.
            //

            ThisLcb->ReferenceCount += 1;

            NtfsAcquireFcbTable( IrpContext, StartingScb->Vcb );
            ThisLcb->Fcb->ReferenceCount += 1;
            NtfsReleaseFcbTable( IrpContext, StartingScb->Vcb );

            //
            //  Set the IrpContext to acquire paging io resources if our target
            //  has one.  This will lock the MappedPageWriter out of this file.
            //

            if (ThisLcb->Fcb->PagingIoResource != NULL) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
            }

            NtfsReleaseScbWithPaging( IrpContext, StartingScb );

            NtfsAcquireFcbWithPaging( IrpContext, ThisLcb->Fcb, 0 );

            NtfsAcquireExclusiveScb( IrpContext, StartingScb );
            ThisLcb->ReferenceCount -= 1;
            NtfsReleaseScb( IrpContext, StartingScb );

            NtfsAcquireFcbTable( IrpContext, StartingScb->Vcb );
            ThisLcb->Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, StartingScb->Vcb );

            DroppedParent = TRUE;

        } else {

            //
            //  Don't forget to release the starting Scb.
            //

            NtfsReleaseScbWithPaging( IrpContext, StartingScb );
        }

        *LcbForTeardown = ThisLcb;
        *CurrentFcb = ThisLcb->Fcb;

        //
        //  It is possible that the Lcb we just found could have been removed
        //  from the prefix table in the window where we dropped the parent Scb.
        //  In that case we need to check that it is still in the prefix
        //  table.  If not then raise CANT_WAIT to force a rescan through the
        //  prefix table.
        //

        if (DroppedParent &&
            !FlagOn( ThisLcb->LcbState,
                     LCB_STATE_IGNORE_CASE_IN_TREE | LCB_STATE_EXACT_CASE_IN_TREE )) {

            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  If we found a match but the Fcb is uninitialized or is not a directory
        //  then we are done.  Also finished if the remaining name length is 0.
        //

        if (!FlagOn( ThisLcb->Fcb->FcbState, FCB_STATE_DUP_INITIALIZED ) ||
            !IsDirectory( &ThisLcb->Fcb->Info ) ||
            RemainingName->Length == 0) {

            return LastLcb;
        }

        //
        //  Get the Scb for the $INDEX_ALLOCATION for this Fcb.
        //

        LastScb = StartingScb;

        // Since the SCB is usually track on the end of the SCB look
        // for it in the FCB first.

        if (FlagOn( ThisLcb->Fcb->FcbState, FCB_STATE_COMPOUND_INDEX ) &&
            (SafeNodeType( &((PFCB_INDEX) ThisLcb->Fcb)->Scb ) == NTFS_NTC_SCB_INDEX)) {

            NeedSnapShot = TRUE;

            StartingScb = (PSCB) &((PFCB_INDEX) ThisLcb->Fcb)->Scb;

            ASSERT(!FlagOn( StartingScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED) &&
                   (StartingScb->AttributeTypeCode == $INDEX_ALLOCATION) &&
                   NtfsAreNamesEqual( IrpContext->Vcb->UpcaseTable, &StartingScb->AttributeName, &NtfsFileNameIndex, FALSE ));

        } else {

            NeedSnapShot = FALSE;

            StartingScb = NtfsCreateScb( IrpContext,
                                         ThisLcb->Fcb,
                                         $INDEX_ALLOCATION,
                                         &NtfsFileNameIndex,
                                         FALSE,
                                         NULL );
        }

        //
        //  If there is no normalized name in this Scb, find it now.
        //

        if ((StartingScb->ScbType.Index.NormalizedName.Length == 0) &&
            (LastScb->ScbType.Index.NormalizedName.Length != 0)) {

            NtfsUpdateNormalizedName( IrpContext, LastScb, StartingScb, NULL, FALSE, FALSE );
        }
    }
}


BOOLEAN
NtfsInsertNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

    The name could already exist in this tree for a case-insensitive tree.
    In that case we simply return FALSE and do nothing.

Arguments:

    RootNode - Supplies a pointer to the table.

    NameLink - Contains the new link to enter.

Return Value:

    BOOLEAN - TRUE if the name is inserted, FALSE otherwise.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PNAME_LINK Node;

    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    RtlInitializeSplayLinks( &NameLink->Links );

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &NameLink->Links;

        return TRUE;
    }

#ifdef NTFS_CHECK_SPLAY
    NtfsCheckSplay( *RootNode );      
#endif

    Node = CONTAINING_RECORD( *RootNode, NAME_LINK, Links );

    while (TRUE) {

        //
        //  Lets assume that we are appending to a directory and are greater than
        //  all entries.
        //

        Comparison = LessThan;

        //
        //  If the first characters match then we need to do a full string compare.
        //

        if (Node->LinkName.Buffer[0] == NameLink->LinkName.Buffer[0]) {

            //
            //  Figure out the minimum of the two lengths
            //

            if (Node->LinkName.Length < NameLink->LinkName.Length) {

                MinLength = Node->LinkName.Length;

            } else {

                MinLength = NameLink->LinkName.Length;
            }

            //
            //  Loop through looking at all of the characters in both strings
            //  testing for equalilty, less than, and greater than
            //

            i = (ULONG) RtlCompareMemory( Node->LinkName.Buffer, NameLink->LinkName.Buffer, MinLength );

            //
            //  Check if we didn't match up to the length of the shorter name.
            //

            if (i < MinLength) {

                if (Node->LinkName.Buffer[i / sizeof( WCHAR )] > NameLink->LinkName.Buffer[i / sizeof( WCHAR )]) {

                    Comparison = GreaterThan;
                }

            //
            //  We match up to the length of the shorter string.  If the lengths are different
            //  then move down the splay tree.
            //

            } else if (Node->LinkName.Length > NameLink->LinkName.Length) {

                Comparison = GreaterThan;

            //
            //  Exit if the strings are the same length.
            //

            } else if (Node->LinkName.Length == NameLink->LinkName.Length) {

                return FALSE;
            }

        //
        //  Compare the first characters to figure out the comparison value.
        //

        } else if (Node->LinkName.Buffer[0] > NameLink->LinkName.Buffer[0]) {

            Comparison = GreaterThan;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == GreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild( &Node->Links ) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                *RootNode = RtlSplay( &NameLink->Links );

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases as less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild( &Node->Links ) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                *RootNode = RtlSplay( &NameLink->Links );

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }
        }
    }

#ifdef NTFS_CHECK_SPLAY
    NtfsCheckSplay( *RootNode );      
#endif
    return TRUE;
}


PNAME_LINK
NtfsFindNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine searches through a splay link tree looking for a match for the
    input name.  If we find the corresponding name we will rebalance the
    tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - This is the name to search for.  Note if we are doing a case
        insensitive search the name would have been upcased already.

Return Value:

    PNAME_LINK - The name link found or NULL if there is no match.

--*/

{
    PNAME_LINK Node;
    PRTL_SPLAY_LINKS Links;

    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    Links = *RootNode;

#ifdef NTFS_CHECK_SPLAY
    if (Links != NULL) {

        NtfsCheckSplay( Links );      
    }
#endif

    while (Links != NULL) {

        Node = CONTAINING_RECORD( Links, NAME_LINK, Links );

        //
        //  If the first characters are equal then compare the full strings.
        //

        if (Node->LinkName.Buffer[0] == Name->Buffer[0]) {

            //
            //  Figure out the minimum of the two lengths
            //

            if (Node->LinkName.Length < Name->Length) {

                MinLength = Node->LinkName.Length;

            } else {

                MinLength = Name->Length;
            }

            //
            //  Loop through looking at all of the characters in both strings
            //  testing for equalilty, less than, and greater than
            //

            i = (ULONG) RtlCompareMemory( Node->LinkName.Buffer, Name->Buffer, MinLength );

            //
            //  Check if we didn't match up to the length of the shorter name.
            //

            if (i < MinLength) {

                if (Node->LinkName.Buffer[i / sizeof( WCHAR )] < Name->Buffer[i / sizeof( WCHAR )]) {

                    //
                    //  The prefix is less than the full name
                    //  so we go down the right child
                    //

                    Links = RtlRightChild( Links );

                } else {

                    //
                    //  The prefix is greater than the full name
                    //  so we go down the left child
                    //

                    Links = RtlLeftChild( Links );
                }

            //
            //  We match up to the length of the shorter string.  If the lengths are different
            //  then move down the splay tree.
            //

            } else if (Node->LinkName.Length < Name->Length) {

                //
                //  The prefix is less than the full name
                //  so we go down the right child
                //

                Links = RtlRightChild( Links );

            } else if (Node->LinkName.Length > Name->Length) {

                //
                //  The prefix is greater than the full name
                //  so we go down the left child
                //

                Links = RtlLeftChild( Links );

            //
            //  The strings are of equal lengths.
            //

            } else {

                *RootNode = RtlSplay( Links );

#ifdef NTFS_CHECK_SPLAY
                NtfsCheckSplay( *RootNode );      
#endif
                return Node;
            }

        //
        //  The first characters are different.  Use them as a key for which
        //  way to branch.
        //

        } else if (Node->LinkName.Buffer[0] < Name->Buffer[0]) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild( Links );

        } else {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild( Links );
        }
    }

    //
    //  We didn't find the Link.
    //

    return NULL;
}



//
//  Local support routine
//

FSRTL_COMPARISON_RESULT
NtfsFullCompareNames (
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive we can do a direct memory comparison.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        LessThan    if NameA < NameB lexicalgraphically,
        GreaterThan if NameA > NameB lexicalgraphically,
        EqualTo     if NameA is equal to NameB

--*/

{
    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    //
    //  Figure out the minimum of the two lengths
    //

    if (NameA->Length < NameB->Length) {

        MinLength = NameA->Length;

    } else {

        MinLength = NameB->Length;
    }

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = (ULONG) RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );


    if (i < MinLength) {

        return (NameA->Buffer[i / sizeof( WCHAR )] < NameB->Buffer[i / sizeof( WCHAR )] ?
                LessThan :
                GreaterThan);
    }

    if (NameA->Length < NameB->Length) {

        return LessThan;
    }

    if (NameA->Length > NameB->Length) {

        return GreaterThan;
    }

    return EqualTo;
}

#ifdef NTFS_CHECK_SPLAY

VOID
NtfsCheckSplay (
    IN PRTL_SPLAY_LINKS Root
    )

{
    PRTL_SPLAY_LINKS Current;

    PAGED_CODE();

    Current = Root;

    //
    //  Root must point to itself.
    //

    if (Current->Parent != Current) {

        KdPrint(("NTFS: Bad splay root\n", 0));
        DbgBreakPoint();
    }

    goto LeftChild;
    while (TRUE) {

    LeftChild:

        //
        //  If there is a left child then verify it. 
        //

        if (Current->LeftChild != NULL) {

            //
            //  The child can't point to itself and
            //  the current node must be the parent of the
            //  child.
            //

            if ((Current->LeftChild == Current) ||
                (Current->LeftChild->Parent != Current)) {

                KdPrint(("NTFS: Bad left child\n", 0));
                DbgBreakPoint();
            }

            //
            //  Go to the left child and verify it.
            //

            Current = Current->LeftChild;
            goto LeftChild;
        }

        //
        //  If there is no left child then check for a right child.
        //

        goto RightChild;

    RightChild:

        //
        //  If there is a right child then verify it.
        //

        if (Current->RightChild != NULL) {

            //
            //  The child can't point to itself and
            //  the current node must be the parent of the
            //  child.
            //

            if ((Current->RightChild == Current) ||
                (Current->RightChild->Parent != Current)) {

                KdPrint(("NTFS: Bad Right child\n", 0));
                DbgBreakPoint();
            }

            //
            //  Go to the right child and verify it.  We always
            //  start in the left child of a new node.
            //

            Current = Current->RightChild;
            goto LeftChild;
        }

        //
        //  There is no right child.  If we are a right child then move up to
        //  the parent and keep going until we reach the root or reach a left child.
        //

        goto Parent;

    Parent:

        //
        //  We may be in the root now.
        //

        if (Current == Root) {

            return;
        }

        //
        //  If we are a left child then go to the parent and look for a right child.
        //

        if (Current == Current->Parent->LeftChild) {

            Current = Current->Parent;
            goto RightChild;
        }

        //
        //  We are a right child.  Go to the parent and check again.
        //

        Current = Current->Parent;
        goto Parent;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\objidsup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ObjIdSup.c

Abstract:

    This module implements the object id support routines for Ntfs

Author:

    Keith Kaplan     [KeithKa]        27-Jun-1996

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_OBJIDSUP)


//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('OFtN')

//
//  Local define for number of times to attempt to generate a unique object id.
//

#define NTFS_MAX_OBJID_RETRIES  16

NTSTATUS
NtfsSetObjectIdExtendedInfoInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PUCHAR ExtendedInfoBuffer
    );

VOID
NtfsGetIdFromGenerator (
    OUT PFILE_OBJECTID_BUFFER ObjectId
    );

NTSTATUS
NtfsSetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

NTSTATUS
NtfsDeleteObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN BOOLEAN DeleteFileAttribute
    );

VOID
NtfsGetIdFromGenerator (
    OUT PFILE_OBJECTID_BUFFER ObjectId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCreateOrGetObjectId)
#pragma alloc_text(PAGE, NtfsDeleteObjectId)
#pragma alloc_text(PAGE, NtfsDeleteObjectIdInternal)
#pragma alloc_text(PAGE, NtfsGetIdFromGenerator)
#pragma alloc_text(PAGE, NtfsGetObjectId)
#pragma alloc_text(PAGE, NtfsGetObjectIdExtendedInfo)
#pragma alloc_text(PAGE, NtfsGetObjectIdInternal)
#pragma alloc_text(PAGE, NtfsInitializeObjectIdIndex)
#pragma alloc_text(PAGE, NtfsSetObjectId)
#pragma alloc_text(PAGE, NtfsSetObjectIdExtendedInfo)
#pragma alloc_text(PAGE, NtfsSetObjectIdExtendedInfoInternal)
#pragma alloc_text(PAGE, NtfsSetObjectIdInternal)
#endif


VOID
NtfsInitializeObjectIdIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the object id index for the volume.  If the index does not
    exist it is created and initialized.  We also look up the volume's object id,
    if any, in this routine.

Arguments:

    Fcb - Pointer to Fcb for the object id file.

    Vcb - Volume control block for volume being mounted.

Return Value:

    None

--*/

{
    NTSTATUS Status;
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$O" );
    FILE_OBJECTID_BUFFER ObjectId;

    PAGED_CODE();

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        Status = NtOfsCreateIndex( IrpContext,
                                   Fcb,
                                   IndexName,
                                   CREATE_OR_OPEN,
                                   0,
                                   COLLATION_NTOFS_ULONGS,
                                   NtOfsCollateUlongs,
                                   NULL,
                                   &Vcb->ObjectIdTableScb );

        if (NT_SUCCESS( Status )) {

            //
            //  We were able to create the index, now let's see if the volume has an object id.
            //

            Status = NtfsGetObjectIdInternal( IrpContext,
                                              Vcb->VolumeDasdScb->Fcb,
                                              FALSE,
                                              &ObjectId );

            if (NT_SUCCESS( Status )) {

                //
                //  The volume does indeed have an object id, so copy it into the Vcb
                //  and set the appropriate flag.
                //

                RtlCopyMemory( Vcb->VolumeObjectId,
                               &ObjectId.ObjectId,
                               OBJECT_ID_KEY_LENGTH );

                SetFlag( Vcb->VcbState, VCB_STATE_VALID_OBJECT_ID );
            }
        }

    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );
    }
}


NTSTATUS
NtfsSetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine associates an object id with a file.  If the object id is already
    in use on the volume we return STATUS_DUPLICATE_NAME.  If the file already has
    an object id, we return STATUS_OBJECT_NAME_COLLISION.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status = STATUS_OBJECT_NAME_INVALID;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    if (!(((TypeOfOpen == UserFileOpen) || (TypeOfOpen == UserDirectoryOpen)) &&
          (IrpSp->Parameters.FileSystemControl.InputBufferLength == sizeof( FILE_OBJECTID_BUFFER )))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Only a restore operator or the I/O system (using its private irp minor code)
        //  is allowed to set an arbitrary object id.
        //

        if (FlagOn( Ccb->AccessFlags, RESTORE_ACCESS ) ||
            (IrpSp->MinorFunction == IRP_MN_KERNEL_CALL)) {

            Status = NtfsSetObjectIdInternal( IrpContext,
                                              Fcb,
                                              Vcb,
                                              (PFILE_OBJECTID_BUFFER) Irp->AssociatedIrp.SystemBuffer );

            //
            //  Remember to update the timestamps.
            //

            if (NT_SUCCESS( Status )) {
                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
            }

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

    } finally {

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsSetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the extended info for a file which already has an object
    id.  If the file does not yet have an object id, we return a status other
    than STATUS_SUCCESS.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_INVALID;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );
    if (!(((TypeOfOpen == UserFileOpen) || (TypeOfOpen == UserDirectoryOpen)) &&
          (IrpSp->Parameters.FileSystemControl.InputBufferLength == OBJECT_ID_EXT_INFO_LENGTH))) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Setting extended info requires either write access or else it has
        //  to be the I/O system using its private irp minor code.
        //

        if ((FlagOn( Ccb->AccessFlags, WRITE_DATA_ACCESS | WRITE_ATTRIBUTES_ACCESS )) ||
            (IrpSp->MinorFunction == IRP_MN_KERNEL_CALL)) {

            Status = NtfsSetObjectIdExtendedInfoInternal( IrpContext,
                                                          Fcb,
                                                          Vcb,
                                                          (PUCHAR) Irp->AssociatedIrp.SystemBuffer );

            //
            //  Remember to update the timestamps.
            //

            if (NT_SUCCESS( Status )) {
                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
            }

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

    } finally {

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsSetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PFILE_OBJECTID_BUFFER ObjectIdBuffer
    )

/*++

Routine Description:

    This routine associates an object id with a file.  If the object id is already
    in use on the volume we return STATUS_DUPLICATE_NAME.  If the file already has
    an object id, we return STATUS_OBJECT_NAME_COLLISION.

Arguments:

    Fcb - The file to associate with the object id.

    Vcb - The volume whose object id index the entry should be added to.

    ObjectIdBuffer - Supplies both the object id and the extended info.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_INVALID;

    NTFS_OBJECTID_INFORMATION ObjectIdInfo;
    FILE_OBJECTID_INFORMATION FileObjectIdInfo;

    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN InitializedAttributeContext = FALSE;
    BOOLEAN AcquiredPaging = FALSE;

    try {

        RtlZeroMemory( &ObjectIdInfo,
                       sizeof( NTFS_OBJECTID_INFORMATION ) );

        RtlCopyMemory( &ObjectIdInfo.FileSystemReference,
                       &Fcb->FileReference,
                       sizeof( FILE_REFERENCE ) );

        RtlCopyMemory( ObjectIdInfo.ExtendedInfo,
                       ObjectIdBuffer->ExtendedInfo,
                       OBJECT_ID_EXT_INFO_LENGTH );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        return STATUS_INVALID_ADDRESS;
    }

    //
    //  Acquire the file we're setting the object id on.  Main blocks
    //  anybody else from deleting the file or setting another object
    //  id behind our backs.  Paging blocks collided flushes if we have to convert
    //  another (data) attribute to be non-resident.
    //
    //  Don't use AcquireFcbWithPaging because
    //  it can't recursively acquire paging and we come in often with it
    //  preacquired
    //

    if (Fcb->PagingIoResource != NULL) {
        ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
        AcquiredPaging = TRUE;
    }
    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  if there is now a paging resource release main and grab both
        //  This is the case for a named data stream in a directory created between our
        //  unsafe test and owning the main
        //  Note: if we already owned main before entrance this could never happen. So we can just drop
        //  and not worry about still owning main and taking paging
        //

        if (!AcquiredPaging && (Fcb->PagingIoResource != NULL)) {
            NtfsReleaseFcb( IrpContext, Fcb );
            ExAcquireResourceExclusiveLite( Fcb->PagingIoResource, TRUE );
            AcquiredPaging = TRUE;
            NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
        }

        if (!IsListEmpty( &Fcb->ScbQueue )) {
            PSCB Scb;

            Scb = CONTAINING_RECORD( Fcb->ScbQueue.Flink, SCB, FcbLinks );
            ASSERT( Scb->Header.Resource == Fcb->Resource );
            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                try_return( Status = STATUS_VOLUME_DISMOUNTED );
            }
        }

        //
        //  Post the change to the Usn Journal (on errors change is backed out).
        //  We dont' want to do this if we've been called because create is
        //  trying to set an object id from the tunnel cache, since we can't
        //  call the Usn package yet, since the file record doesn't have a file
        //  name yet.
        //

        if (IrpContext->MajorFunction != IRP_MJ_CREATE) {

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_OBJECT_ID_CHANGE );
        }

        //
        //  Make sure the file doesn't already have an object id.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        InitializedAttributeContext = TRUE;

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $OBJECT_ID,
                                       &AttributeContext )) {

            try_return( Status = STATUS_OBJECT_NAME_COLLISION );
        }

        //
        //  Add ObjectId to the index, associate it with this file.
        //

        IndexKey.Key = ObjectIdBuffer->ObjectId;
        IndexKey.KeyLength = OBJECT_ID_KEY_LENGTH;
        IndexRow.KeyPart = IndexKey;

        IndexRow.DataPart.DataLength = sizeof( ObjectIdInfo );
        IndexRow.DataPart.Data = &ObjectIdInfo;

        //
        //  NtOfsAddRecords may raise if the object id isn't unique.
        //

        NtOfsAddRecords( IrpContext,
                         Vcb->ObjectIdTableScb,
                         1,          // adding one record to the index
                         &IndexRow,
                         FALSE );    // sequential insert

        //
        //  Now add the objectid attribute to the file.  Notice that
        //  we do _not_ log this operation if we're within a create
        //  operation, i.e. if we're restoring an object id from the
        //  tunnel cache.  The create path has its own logging scheme
        //  that we don't want to interfere with.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttributeContext );

        NtfsCreateAttributeWithValue( IrpContext,
                                      Fcb,
                                      $OBJECT_ID,
                                      NULL,
                                      ObjectIdBuffer->ObjectId,
                                      OBJECT_ID_KEY_LENGTH,
                                      0,
                                      NULL,
                                      (BOOLEAN)(IrpContext->MajorFunction != IRP_MJ_CREATE),
                                      &AttributeContext );


        ASSERT( IrpContext->TransactionId != 0 );

        //
        //  Notify anybody who's interested.
        //

        if (Vcb->ViewIndexNotifyCount != 0) {

            //
            //  The FRS field is only populated for the notification of a failed
            //  object id restore from the tunnel cache.
            //

            FileObjectIdInfo.FileReference = 0L;

            RtlCopyMemory( FileObjectIdInfo.ObjectId,
                           ObjectIdBuffer->ObjectId,
                           OBJECT_ID_KEY_LENGTH );

            RtlCopyMemory( FileObjectIdInfo.ExtendedInfo,
                           ObjectIdBuffer->ExtendedInfo,
                           OBJECT_ID_EXT_INFO_LENGTH );

            NtfsReportViewIndexNotify( Vcb,
                                       Vcb->ObjectIdTableScb->Fcb,
                                       FILE_NOTIFY_CHANGE_FILE_NAME,
                                       FILE_ACTION_ADDED,
                                       &FileObjectIdInfo,
                                       sizeof(FILE_OBJECTID_INFORMATION) );
        }

        //
        //  If we made it this far and didn't have to jump into the
        //  finally clause yet, all must have gone well.
        //

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        if (AcquiredPaging) {
            ExReleaseResourceLite( Fcb->PagingIoResource );
        }
        NtfsReleaseFcb( IrpContext, Fcb );

        if (InitializedAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return Status;
}


NTSTATUS
NtfsCreateOrGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine generates a new object id, if possible, for a given file.  It is
    different from NtfsSetObjectId in that it does not take an object id as an
    input, rather it calls a routine to generate one.  If the file already has
    an object id, that existing object id is returned.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.
               STATUS_DUPLICATE_NAME if we are unable to generate a unique id
                 in NTFS_MAX_OBJID_RETRIES retries.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_OBJECTID_BUFFER ObjectId;
    FILE_OBJECTID_BUFFER *OutputBuffer;

    ULONG RetryCount = 0;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This only works for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first, then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        OutputBuffer = (FILE_OBJECTID_BUFFER *)Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        OutputBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (OutputBuffer == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ObjectId)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Get this file exlusively so we know nobody else is trying
        //  to do this at the same time.  At this point the irpcontext flag
        //  is not set so paging is not acquired.
        //

        NtfsAcquireFcbWithPaging( IrpContext, Fcb, 0 );

        //
        //  Let's make sure the volume is still mounted.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        DebugTrace( +1, Dbg, ("NtfsCreateOrGetObjectId\n") );

        //
        //  If this file already has an object id, let's return it.  Doing this
        //  first saves a (possibly expensive) call to NtfsGetIdFromGenerator.
        //

        Status = NtfsGetObjectIdInternal( IrpContext, Fcb, TRUE, OutputBuffer );

        if (Status == STATUS_OBJECTID_NOT_FOUND) {

            DebugTrace( 0, Dbg, ("File has no oid, we have to generate one\n") );

            //
            //  We want to keep retrying if the object id generator returns a
            //  duplicate name.  If we have success, or any other error, we
            //  should stop trying.  For instance, if we fail because the file
            //  already has an object id, retrying is just a waste of time.
            //  We also need some sane limit on the number of times we retry
            //  this operation.
            //

            do {

                RetryCount += 1;

                //
                //  Drop this file so we don't deadlock in the guid generator.
                //

                ASSERT( 0 == IrpContext->TransactionId );
                NtfsReleaseFcbWithPaging( IrpContext, Fcb );

                DebugTrace( 0, Dbg, ("Calling oid generator\n") );
                NtfsGetIdFromGenerator( &ObjectId );

                //
                //  Reacquire the file so we know nobody else is trying to do
                //  this at the same time. SetObjIdInternal acquires both so we need to
                //  do the same
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ACQUIRE_PAGING );
                NtfsAcquireFcbWithPaging( IrpContext, Fcb, 0 );

                //
                //  Make sure we didn't miss a dismount.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                    try_return( Status = STATUS_VOLUME_DISMOUNTED );
                }

                //
                //  Let's make sure this file didn't get an object id assigned to it
                //  while we weren't holding the Fcb above.
                //

                Status = NtfsGetObjectIdInternal( IrpContext, Fcb, TRUE, OutputBuffer );

                if (Status == STATUS_OBJECTID_NOT_FOUND) {

                    if (NtfsIsVolumeReadOnly( Vcb )) {

                        try_return( Status = STATUS_MEDIA_WRITE_PROTECTED );
                    }

                    DebugTrace( 0, Dbg, ("File still has no oid, attempting to set generated one\n") );

                    //
                    //  The object id generator only generates the indexed part, so
                    //  we need to fill in the rest of the 'birth id' now.  Note that if
                    //  the volume has no object id, we're relying on the Vcb creation
                    //  code to zero init the Vcb->VolumeObjectId for us.  The net result
                    //  is right -- we get zeroes in the volume id part of the extended
                    //  info if the volume has no object id.
                    //

                    RtlCopyMemory( &ObjectId.BirthVolumeId,
                                   Vcb->VolumeObjectId,
                                   OBJECT_ID_KEY_LENGTH );

                    RtlCopyMemory( &ObjectId.BirthObjectId,
                                   &ObjectId.ObjectId,
                                   OBJECT_ID_KEY_LENGTH );

                    RtlZeroMemory( &ObjectId.DomainId,
                                   OBJECT_ID_KEY_LENGTH );

                    Status = NtfsSetObjectIdInternal( IrpContext,
                                                      Fcb,
                                                      Vcb,
                                                      &ObjectId );

                    if (Status == STATUS_SUCCESS) {

                        DebugTrace( 0, Dbg, ("Successfully set generated oid\n") );

                        //
                        //  We have successfully generated and set an object id for this
                        //  file, so we need to tell our caller what that id is.
                        //

                        RtlCopyMemory( OutputBuffer,
                                       &ObjectId,
                                       sizeof(ObjectId) );

                        //
                        //  Let's also remember to update the timestamps.
                        //

                        SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
                    }
                }

            } while ((Status == STATUS_DUPLICATE_NAME) &&
                     (RetryCount <= NTFS_MAX_OBJID_RETRIES));

        } else if (Status == STATUS_SUCCESS) {

            //
            //  If we found an ID, make sure it isn't a partially formed id with
            //  an all zero extended info.  If it's partially formed, we'll generate
            //  extended info now.
            //

            if (RtlCompareMemory( (PUCHAR)&OutputBuffer->ExtendedInfo, &NtfsZeroExtendedInfo, sizeof(ObjectId.ExtendedInfo)) == sizeof(ObjectId.ExtendedInfo)) {

                RtlCopyMemory( &OutputBuffer->BirthVolumeId,
                               Vcb->VolumeObjectId,
                               OBJECT_ID_KEY_LENGTH );

                RtlCopyMemory( &OutputBuffer->BirthObjectId,
                               &OutputBuffer->ObjectId,
                               OBJECT_ID_KEY_LENGTH );

                Status = NtfsSetObjectIdExtendedInfoInternal( IrpContext,
                                                              Fcb,
                                                              Vcb,
                                                              (PUCHAR) &OutputBuffer->ExtendedInfo );
            }
        }

        if (Status == STATUS_SUCCESS) {

            //
            //  If we found an existing id for the file, or managed to generate one
            //  ourselves, we need to set the size in the information field so the
            //  rdr can handle this operation correctly.
            //

            IrpContext->OriginatingIrp->IoStatus.Information = sizeof( ObjectId );
        }

    try_exit: NOTHING;
    } finally {
    }

    NtfsCompleteRequest( IrpContext, Irp, Status );

    DebugTrace( -1, Dbg, ("NtfsCreateOrGetObjectId -> %08lx\n", Status) );
    return Status;
}


NTSTATUS
NtfsGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine finds the object id, if any, for a given file.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    FILE_OBJECTID_BUFFER *OutputBuffer;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This only works for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first, then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        OutputBuffer = (FILE_OBJECTID_BUFFER *)Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        OutputBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (OutputBuffer == NULL) {

            NtfsCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(FILE_OBJECTID_BUFFER)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    try {

        //
        //  Call the function that does the real work.
        //

        Status = NtfsGetObjectIdInternal( IrpContext, Fcb, TRUE, OutputBuffer );

        if (NT_SUCCESS( Status )) {

            //
            //  And set the size in the information field so the rdr
            //  can handle this correctly.
            //

            IrpContext->OriginatingIrp->IoStatus.Information = sizeof( FILE_OBJECTID_BUFFER );
        }

    } finally {

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsGetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN GetExtendedInfo,
    OUT FILE_OBJECTID_BUFFER *OutputBuffer
    )

/*++

Routine Description:

    Internal function to find the object id, if any, for a given file.  Called
    in response to the user's ioctl and by NtfsDeleteObjectIdInternal.

Arguments:

    Fcb - The file whose object id we need to look up.

    GetExtendedInfo - If TRUE, we also copy the object id's extended information
                      to the OutputBuffer, otherwise we only copy the object id
                      itself.  For instance, NtfsDeleteObjectIdInternal is not
                      interested in the extended info -- it only needs to know
                      which object id to delete from the index.

    OutputBuffer - Where to store the object id (and optionally, extended info)
                   if an object id is found.

Return Value:

    NTSTATUS - The return status for the operation.
               STATUS_OBJECT_NAME_NOT_FOUND if the file does not have an object id.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    UCHAR *ObjectId;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN InitializedAttributeContext = FALSE;

    if ((OutputBuffer == NULL) ||
        (OutputBuffer->ObjectId == NULL)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the file we're getting the object id for.  We don't
    //  want anybody else deleting the file or setting an object
    //  id behind our backs.
    //

    NtfsAcquireSharedFcb( IrpContext, Fcb, NULL, 0 );


    try {

        if (!IsListEmpty( &Fcb->ScbQueue )) {
            PSCB Scb;

            Scb = CONTAINING_RECORD( Fcb->ScbQueue.Flink, SCB, FcbLinks );
            ASSERT( Scb->Header.Resource == Fcb->Resource );
            if (FlagOn( Scb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }
        }

        //
        //  Make sure the file has an object id.
        //

        NtfsInitializeAttributeContext( &AttributeContext );
        InitializedAttributeContext = TRUE;

        if (NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $OBJECT_ID,
                                       &AttributeContext )) {
            //
            //  Prepare the object id to be returned
            //

            ObjectId = (UCHAR *) NtfsAttributeValue( NtfsFoundAttribute( &AttributeContext ));

            RtlCopyMemory( &OutputBuffer->ObjectId,
                           ObjectId,
                           OBJECT_ID_KEY_LENGTH );

            if (GetExtendedInfo) {

                Status = NtfsGetObjectIdExtendedInfo( IrpContext,
                                                      Fcb->Vcb,
                                                      ObjectId,
                                                      OutputBuffer->ExtendedInfo );
            }

        } else {

            //
            //  This file has no object id.
            //

            Status = STATUS_OBJECTID_NOT_FOUND;
        }

    } finally {

        NtfsReleaseFcb( IrpContext, Fcb );

        if (InitializedAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return Status;
}


NTSTATUS
NtfsGetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR *ObjectId,
    IN OUT UCHAR *ExtendedInfo
    )

/*++

Routine Description:

    This routine finds the extended info stored with a given object id.

Arguments:

    Vcb - Supplies the volume whose object id index should be searched.

    ObjectId - Supplies the object id to lookup in the index.

    ExtendedInfo - Where to store the extended info.  Must be a buffer with
                   room for OBJECT_ID_EXT_INFO_LENGTH UCHARs.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    MAP_HANDLE MapHandle;

    BOOLEAN InitializedMapHandle = FALSE;
    BOOLEAN IndexAcquired = FALSE;

    try {

        //
        //  Now look for object id in the index so we can return the
        //  extended info.
        //

        IndexKey.Key = ObjectId;
        IndexKey.KeyLength = OBJECT_ID_KEY_LENGTH;

        NtOfsInitializeMapHandle( &MapHandle );
        InitializedMapHandle = TRUE;

        //
        //  Acquire the object id index before doing the lookup.
        //  We need to make sure the file is acquired first to prevent
        //  a possible deadlock.
        //

        // **** ASSERT_EXCLUSIVE_FCB( Fcb ); ****

        //
        //  We shouldn't try to get the object id index while holding the Mft.
        //

        ASSERT( !NtfsIsExclusiveScb( Vcb->MftScb ) ||
                NtfsIsSharedScb( Vcb->ObjectIdTableScb ) );

        NtfsAcquireSharedScb( IrpContext, Vcb->ObjectIdTableScb );
        IndexAcquired = TRUE;

        if ( NtOfsFindRecord( IrpContext,
                              Vcb->ObjectIdTableScb,
                              &IndexKey,
                              &IndexRow,
                              &MapHandle,
                              NULL) != STATUS_SUCCESS ) {

            //
            //  If the object id attribute exists for the file,
            //  but it isn't in the index, the object id index
            //  for this volume is corrupt.
            //

            SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_CORRUPT );

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        RtlCopyMemory( ExtendedInfo,
                       ((NTFS_OBJECTID_INFORMATION *)IndexRow.DataPart.Data)->ExtendedInfo,
                       OBJECT_ID_EXT_INFO_LENGTH );

    try_exit: NOTHING;
    } finally {

        if (IndexAcquired) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
        }

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }
    }

    return Status;
}



NTSTATUS
NtfsDeleteObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deletes the object id attribute from a file
    and removes that object id from the index.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, IrpSp->FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This only works for files and directories.
    //

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Read only volumes stay read only.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_VOLUME_NOT_UPGRADED );
        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Capture the source information.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    try {

        //
        //  Only a restore operator or the I/O system (using its private irp minor code)
        //  is allowed to delete an object id.
        //

        if (FlagOn( Ccb->AccessFlags, RESTORE_ACCESS | WRITE_DATA_ACCESS) ||
            (IrpSp->MinorFunction == IRP_MN_KERNEL_CALL)) {

            Status = NtfsDeleteObjectIdInternal( IrpContext,
                                                 Fcb,
                                                 Vcb,
                                                 TRUE );

        } else {

            Status = STATUS_ACCESS_DENIED;
        }

    } finally {

        //
        //  Update the last change timestamp
        //

        if (NT_SUCCESS( Status )) {
            SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
        }

        //
        //  If there was no object id - just return success
        //

        if (STATUS_OBJECTID_NOT_FOUND == Status) {
            Status = STATUS_SUCCESS;
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


NTSTATUS
NtfsDeleteObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN BOOLEAN DeleteFileAttribute
    )

/*++

Routine Description:

    Internal function to (optionally) delete the object id attribute from
    a file and remove that object id from the index.

Arguments:

    Fcb - The file from which to delete the object id.

    Vcb - The volume whose object id index the object id should be removed from.

    DeleteFileAttribute - Specifies whether to delete the object id file attribute
                          from the file in addition to removing the id from the index.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    FILE_OBJECTID_INFORMATION FileObjectIdInfo;

    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    MAP_HANDLE MapHandle;

    ATTRIBUTE_ENUMERATION_CONTEXT AttributeContext;
    BOOLEAN InitializedAttributeContext = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;
    BOOLEAN IndexAcquired = FALSE;

    //
    //  Cleanly exit for volumes without oid indices, such as non-upgraded
    //  version 1.x volumes.
    //

    if (Vcb->ObjectIdTableScb == NULL) {

        return STATUS_VOLUME_NOT_UPGRADED;
    }

    //
    //  Acquire the file we're deleting the object id from.  We don't
    //  want anybody else deleting the file or object id behind
    //  our backs.
    //

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );

    try {

        //
        //  We need to look up the object id.  It's quite possible that
        //  this file has no object id, so we'll treat that as success.
        //

        Status = NtfsGetObjectIdInternal( IrpContext,
                                          Fcb,
                                          FALSE,
                                          &ObjectIdBuffer );

        if (Status != STATUS_SUCCESS) {

            try_return( NOTHING );
        }

        //
        //  Look for object id in the index.
        //

        IndexKey.Key = ObjectIdBuffer.ObjectId;
        IndexKey.KeyLength = sizeof( ObjectIdBuffer.ObjectId );

        NtOfsInitializeMapHandle( &MapHandle );
        InitializedMapHandle = TRUE;

        //
        //  Acquire the object id index before doing the lookup.
        //  We need to make sure the file is acquired first to prevent
        //  a possible deadlock.
        //

        ASSERT_EXCLUSIVE_FCB( Fcb );
        NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
        IndexAcquired = TRUE;

        if ( NtOfsFindRecord( IrpContext,
                              Vcb->ObjectIdTableScb,
                              &IndexKey,
                              &IndexRow,
                              &MapHandle,
                              NULL) != STATUS_SUCCESS ) {

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        ASSERT( IndexRow.DataPart.DataLength == sizeof( NTFS_OBJECTID_INFORMATION ) );

        //
        //  Copy objectid info into the correct buffer if we need it for the notify
        //  below.
        //

        if ((Vcb->ViewIndexNotifyCount != 0) &&
            (IndexRow.DataPart.DataLength == sizeof( NTFS_OBJECTID_INFORMATION ))) {

            //
            //  The FRS field is only populated for the notification of a failed
            //  object id restore from the tunnel cache.
            //

            FileObjectIdInfo.FileReference = 0L;

            RtlCopyMemory( &FileObjectIdInfo.ObjectId,
                           ObjectIdBuffer.ObjectId,
                           OBJECT_ID_KEY_LENGTH );

            RtlCopyMemory( &FileObjectIdInfo.ExtendedInfo,
                           ((NTFS_OBJECTID_INFORMATION *)IndexRow.DataPart.Data)->ExtendedInfo,
                           OBJECT_ID_EXT_INFO_LENGTH );
        }

        //
        //  Remove ObjectId from the index.
        //

        NtOfsDeleteRecords( IrpContext,
                            Vcb->ObjectIdTableScb,
                            1,    // deleting one record from the index
                            &IndexKey );

        //
        //  Notify anybody who's interested.  We use a different action if the
        //  object id is being deleted by the fsctl versus a delete file.
        //

        if (Vcb->ViewIndexNotifyCount != 0) {

            NtfsReportViewIndexNotify( Vcb,
                                       Vcb->ObjectIdTableScb->Fcb,
                                       FILE_NOTIFY_CHANGE_FILE_NAME,
                                       (DeleteFileAttribute ?
                                        FILE_ACTION_REMOVED :
                                        FILE_ACTION_REMOVED_BY_DELETE),
                                       &FileObjectIdInfo,
                                       sizeof(FILE_OBJECTID_INFORMATION) );
        }

        if (DeleteFileAttribute) {

            //
            //  Post the change to the Usn Journal (on errors change is backed out)
            //

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_OBJECT_ID_CHANGE );

            //
            //  Now remove the object id attribute from the file.
            //

            NtfsInitializeAttributeContext( &AttributeContext );
            InitializedAttributeContext = TRUE;

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $OBJECT_ID,
                                           &AttributeContext )) {

                NtfsDeleteAttributeRecord( IrpContext,
                                           Fcb,
                                           DELETE_LOG_OPERATION |
                                            DELETE_RELEASE_FILE_RECORD |
                                            DELETE_RELEASE_ALLOCATION,
                                           &AttributeContext );
            } else {

                //
                //  If the object id was in the index, but the attribute
                //  isn't on the file, then the object id index for this
                //  volume is corrupt.  We can repair this corruption in
                //  the background, so let's start doing that now.
                //

                NtfsPostSpecial( IrpContext, Vcb, NtfsRepairObjectId, NULL );
            }

            NtfsCleanupTransaction( IrpContext, Status, FALSE );
        }

    try_exit: NOTHING;
    } finally {

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        if (InitializedAttributeContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttributeContext );
        }
    }

    return Status;
}


VOID
NtfsRepairObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called to repair the object Id index.  This is called when
    the system detects that the object Id index may be out of date.  For example
    after the volume was mounted on 4.0.

Arguments:

    IrpContext - context of the call

    Context - NULL

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN SetRepairFlag = FALSE;
    BOOLEAN IncrementedCloseCounts = FALSE;
    PBCB Bcb = NULL;
    PVCB Vcb = IrpContext->Vcb;
    PSCB ObjectIdScb;
    PREAD_CONTEXT ReadContext = NULL;
    PINDEX_ROW IndexRow = NULL;
    PINDEX_ROW ObjectIdRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    PNTFS_OBJECTID_INFORMATION ObjectIdInfo;
    PVOID RowBuffer = NULL;
    ULONG Count;
    ULONG i;
    BOOLEAN IndexAcquired = FALSE;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONGLONG MftOffset;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( Context );

    ASSERT( Vcb->MajorVersion >= NTFS_OBJECT_ID_VERSION );

    //
    //  Use a try-except to catch errors.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
    AcquiredVcb = TRUE;

    try {

        //
        //  Now that we're holding the Vcb, we can safely test for the presence
        //  of the ObjectId index, as well as whether the volume is mounted.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) &&
            (Vcb->ObjectIdTableScb != NULL) &&
            (!FlagOn( Vcb->ObjectIdTableScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED ))) {

            ObjectIdScb = Vcb->ObjectIdTableScb;
            NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
            IndexAcquired = TRUE;

            //
            //  Since we'll be dropping the ObjectIdScb periodically, and we're
            //  not holding anything else, there's a chance that a dismount could
            //  happen, and make it unsafe for us to reacquire the ObjectIdScb.
            //  By incrementing the close counts, we keep it around as long as
            //  we need it.
            //

            NtfsIncrementCloseCounts( ObjectIdScb, TRUE, FALSE );
            IncrementedCloseCounts = TRUE;

            NtfsReleaseVcb( IrpContext, Vcb );
            AcquiredVcb = FALSE;

        } else {

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  The volume could've gotten write-protected by now.
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {

            NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
        }

        if (!FlagOn( Vcb->ObjectIdState, VCB_OBJECT_ID_REPAIR_RUNNING )) {

            SetFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_REPAIR_RUNNING );
            SetRepairFlag = TRUE;

            //
            //  Check the object id index.  Periodically release all resources.
            //  See NtfsClearAndVerifyQuotaIndex
            //

            NtOfsInitializeMapHandle( &MapHandle );

            //
            //  Allocate a buffer large enough for several rows.
            //

            RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

            try {

                //
                //  Allocate a bunch of index row entries.
                //

                Count = PAGE_SIZE / sizeof( NTFS_OBJECTID_INFORMATION );

                IndexRow = NtfsAllocatePool( PagedPool,
                                             Count * sizeof( INDEX_ROW ) );

                //
                //  Iterate through the object id entries.  Start at the beginning.
                //

                RtlZeroMemory( &ObjectIdBuffer, sizeof(ObjectIdBuffer) );

                IndexKey.Key = ObjectIdBuffer.ObjectId;
                IndexKey.KeyLength = sizeof( ObjectIdBuffer.ObjectId );

                Status = NtOfsReadRecords( IrpContext,
                                           ObjectIdScb,
                                           &ReadContext,
                                           &IndexKey,
                                           NtOfsMatchAll,
                                           NULL,
                                           &Count,
                                           IndexRow,
                                           PAGE_SIZE,
                                           RowBuffer );

                while (NT_SUCCESS( Status )) {

                    //
                    //  Acquire the VCB shared and check whether we should
                    //  continue.
                    //

                    if (!NtfsIsVcbAvailable( Vcb )) {

                        //
                        //  The volume is going away, bail out.
                        //

                        Status = STATUS_VOLUME_DISMOUNTED;
                        leave;
                    }

                    ObjectIdRow = IndexRow;

                    for (i = 0; i < Count; i++, ObjectIdRow++) {

                        ObjectIdInfo = ObjectIdRow->DataPart.Data;

                        //
                        //  Make sure the mft record referenced in the index
                        //  row still exists and hasn't been deleted, etc.
                        //
                        //  We start by reading the disk and checking that the file record
                        //  sequence number matches and that the file record is in use.  If
                        //  we find an invalid entry, we will simply delete it from the
                        //  object id index.
                        //

                        MftOffset = NtfsFullSegmentNumber( &ObjectIdInfo->FileSystemReference );

                        MftOffset = Int64ShllMod32(MftOffset, Vcb->MftShift);

                        if (MftOffset >= Vcb->MftScb->Header.FileSize.QuadPart) {

                            DebugTrace( 0, Dbg, ("File Id doesn't lie within Mft FRS %04x:%08lx\n",
                                                 ObjectIdInfo->FileSystemReference.SequenceNumber,
                                                 ObjectIdInfo->FileSystemReference.SegmentNumberLowPart) );

                            NtOfsDeleteRecords( IrpContext,
                                                ObjectIdScb,
                                                1,    // deleting one record from the index
                                                &ObjectIdRow->KeyPart );

                        } else {

                            NtfsReadMftRecord( IrpContext,
                                               Vcb,
                                               &ObjectIdInfo->FileSystemReference,
                                               FALSE,
                                               &Bcb,
                                               &FileRecord,
                                               NULL );

                            //
                            //  This file record better be in use, have a matching sequence number and
                            //  be the primary file record for this file.
                            //

                            if ((*((PULONG) FileRecord->MultiSectorHeader.Signature) != *((PULONG) FileSignature)) ||
                                !FlagOn( FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE ) ||
                                (FileRecord->SequenceNumber != ObjectIdInfo->FileSystemReference.SequenceNumber) ||
                                (*((PLONGLONG) &FileRecord->BaseFileRecordSegment) != 0)) {

                                DebugTrace( 0, Dbg, ("RepairOID removing an orphaned OID\n") );

                                NtOfsDeleteRecords( IrpContext,
                                                    ObjectIdScb,
                                                    1,    // deleting one record from the index
                                                    &ObjectIdRow->KeyPart );

                            } else {

                                DebugTrace( 0, Dbg, ("RepairOID happy with OID %08lx on FRS %04x:%08lx\n",
                                                     *((PULONG) ObjectIdRow->KeyPart.Key),
                                                     ObjectIdInfo->FileSystemReference.SequenceNumber,
                                                     ObjectIdInfo->FileSystemReference.SegmentNumberLowPart) );
                            }

                            NtfsUnpinBcb( IrpContext, &Bcb );
                        }
                    }

                    //
                    //  Release the index and commit what has been done so far.
                    //

                    ASSERT( IndexAcquired );
                    NtfsReleaseScb( IrpContext, ObjectIdScb );
                    IndexAcquired = FALSE;

                    //
                    //  Complete the request which commits the pending
                    //  transaction if there is one and releases of the
                    //  acquired resources.  The IrpContext will not
                    //  be deleted because the no delete flag is set.
                    //

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
                    NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

                    //
                    //  Remember how far we got so we can restart correctly. **** ??? ****
                    //

                    //  Vcb->QuotaFileReference.SegmentNumberLowPart =
                    //  *((PULONG) IndexRow[Count - 1].KeyPart.Key);

                    //
                    //  Reacquire the object id index for the next pass.
                    //

                    NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
                    IndexAcquired = TRUE;

                    //
                    //  Make sure a dismount didn't occur while we weren't holding any
                    //  resources.
                    //

                    if (FlagOn( ObjectIdScb->ScbState, SCB_STATE_VOLUME_DISMOUNTED )) {

                        NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
                    }

                    //
                    //  Look up the next set of entries in the object id index.
                    //

                    Count = PAGE_SIZE / sizeof( NTFS_OBJECTID_INFORMATION );
                    Status = NtOfsReadRecords( IrpContext,
                                               ObjectIdScb,
                                               &ReadContext,
                                               NULL,
                                               NtOfsMatchAll,
                                               NULL,
                                               &Count,
                                               IndexRow,
                                               PAGE_SIZE,
                                               RowBuffer );
                }

                ASSERT( (Status == STATUS_NO_MORE_MATCHES) ||
                        (Status == STATUS_NO_MATCH) );

            } finally {

                NtfsUnpinBcb( IrpContext, &Bcb );

                NtfsFreePool( RowBuffer );
                NtOfsReleaseMap( IrpContext, &MapHandle );

                if (IndexAcquired) {
                    NtfsReleaseScb( IrpContext, ObjectIdScb );
                    IndexAcquired = FALSE;
                }

                if (IndexRow != NULL) {
                    NtfsFreePool( IndexRow );
                }

                if (ReadContext != NULL) {
                    NtOfsFreeReadContext( ReadContext );
                }
            }

            //
            //  Acquire the Vcb to clear the object ID flag on disk.  Since we got the
            //  Vcb shared before, we better not still be holding it when we try to
            //  get it exclusively now or else we'll have a one thread deadlock.
            //

            ASSERT( !AcquiredVcb );
            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            AcquiredVcb = TRUE;

            if (!NtfsIsVcbAvailable( Vcb )) {

                NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
            }

            //
            //  Clear the on-disk flag indicating the repair is underway.
            //

            NtfsSetVolumeInfoFlagState( IrpContext,
                                        Vcb,
                                        VOLUME_REPAIR_OBJECT_ID,
                                        FALSE,
                                        TRUE );

            //
            //  Make sure we don't own any resources at this point.
            //

            NtfsPurgeFileRecordCache( IrpContext );
            NtfsCheckpointCurrentTransaction( IrpContext );
        }

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation())) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    //
    //  Clear the repair_running flag if we're the ones who set it, making sure
    //  to only change the ObjectIdState bits while holding the ObjectId index.
    //

    if (SetRepairFlag) {

        if (!IndexAcquired) {

            NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
            IndexAcquired = TRUE;
        }

        ClearFlag( Vcb->ObjectIdState, VCB_OBJECT_ID_REPAIR_RUNNING );
    }

    if (IncrementedCloseCounts) {

        if (!IndexAcquired) {

            NtfsAcquireExclusiveScb( IrpContext, ObjectIdScb );
            IndexAcquired = TRUE;
        }

        NtfsDecrementCloseCounts( IrpContext, ObjectIdScb, NULL, TRUE, FALSE, FALSE, NULL );
    }

    //
    //  Drop the index and the Vcb.
    //

    if (IndexAcquired) {

        NtfsReleaseScb( IrpContext, ObjectIdScb );
    }

    if (AcquiredVcb) {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    //
    //  If this is a fatal failure then do any final cleanup.
    //

    if (!NT_SUCCESS( Status )) {

        //
        //  If we will not be called back then clear the running state bits.
        //

        if ((Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL)) {

            //
            //  Do we want to log this error?  Some may be expected (i.e. STATUS_VOLUME_DISMOUNTED ).
            //

            //  NtfsLogEvent( IrpContext, NULL, IO_FILE_OBJECTID_REPAIR_FAILED, Status );
        }

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }
}

//
//  Local support routine
//


NTSTATUS
NtfsSetObjectIdExtendedInfoInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PUCHAR ExtendedInfoBuffer
    )

/*++

Routine Description:

    This routine sets the extended info for a file which already has an object
    id.  If the file does not yet have an object id, we return a status other
    than STATUS_SUCCESS.

Arguments:

    Fcb - The file whose extended info is to be set.

    Vcb - The volume whose object id index the entry should be modified in.

    ExtendedInfoBuffer - Supplies the new extended info.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status;
    NTFS_OBJECTID_INFORMATION ObjectIdInfo;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    INDEX_ROW IndexRow;

    PAGED_CODE();

    Status = NtfsGetObjectIdInternal( IrpContext,
                                      Fcb,
                                      FALSE,        //  GetExtendedInfo
                                      &ObjectIdBuffer );

    if (Status != STATUS_SUCCESS) {

        //
        //  This file may not have an object id yet.
        //

        return Status;
    }

    //
    //  Setup the index row for updating.  Since part of the data
    //  is passed into this function (the new extended info) and
    //  the rest can be determined easily (the file reference), we
    //  don't need to look up any of the existing data before
    //  proceeding.  If the NTFS_OBJECTID_INFORMATION structure
    //  ever changes, this code may have to be changed to include
    //  a lookup of the data currently in the object id index.
    //

    RtlCopyMemory( &ObjectIdInfo.FileSystemReference,
                   &Fcb->FileReference,
                   sizeof( ObjectIdInfo.FileSystemReference ) );

    RtlCopyMemory( &ObjectIdInfo.ExtendedInfo,
                   ExtendedInfoBuffer,
                   OBJECT_ID_EXT_INFO_LENGTH );

    IndexRow.DataPart.Data = &ObjectIdInfo;
    IndexRow.DataPart.DataLength = sizeof( NTFS_OBJECTID_INFORMATION );

    IndexRow.KeyPart.Key = &ObjectIdBuffer;
    IndexRow.KeyPart.KeyLength = OBJECT_ID_KEY_LENGTH;

    //
    //  Acquire the file and the object id index before doing the modification.
    //

    NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
    NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );

    //
    //  Post the change to the Usn Journal (on errors change is backed out)
    //

    NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_OBJECT_ID_CHANGE );

    //
    //  Update the ObjectId index record's data in place.
    //

    NtOfsUpdateRecord( IrpContext,
                       Vcb->ObjectIdTableScb,
                       1,           //  Count
                       &IndexRow,
                       NULL,        //  QuickIndexHint
                       NULL );      //  MapHandle

    NtfsCleanupTransaction( IrpContext, Status, FALSE );

    return Status;
}

//
//  Local support routine
//


VOID
NtfsGetIdFromGenerator (
    OUT PFILE_OBJECTID_BUFFER ObjectId
    )

/*++

Routine Description:

    This function conjures up a random object id.

Arguments:

    ObjectId - The location where the generated object id will be stored.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    //  Cal the id generator.
    //

    ExUuidCreate( (UUID *)ObjectId->ObjectId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\pnp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Pnp routines for Ntfs called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]        29-Aug-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_PNP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_PNP)

//
//  Local procedure prototypes
//

NTSTATUS
NtfsCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP *Irp,
    IN OUT PBOOLEAN CallerDecrementCloseCount
    );

NTSTATUS
NtfsPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PNTFS_COMPLETION_CONTEXT CompletionContext
    );

VOID
NtfsPerformSurpriseRemoval(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonPnp)
#pragma alloc_text(PAGE, NtfsFsdPnp)
#pragma alloc_text(PAGE, NtfsPerformSurpriseRemoval)
#endif

NTSTATUS
NtfsFsdPnp (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD entry point for plug and play (Pnp).

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN DecrementCloseCount = FALSE;

    ASSERT_IRP( Irp );

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

#ifdef NTFSPNPDBG
    if (NtfsDebugTraceLevel != 0) SetFlag( NtfsDebugTraceLevel, DEBUG_TRACE_PNP );
#endif

    DebugTrace( +1, Dbg, ("NtfsFsdPnp\n") );

    //
    //  Call the common Pnp routine
    //

    FsRtlEnterFileSystem();

    switch( IoGetCurrentIrpStackLocation( Irp )->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );
        break;

    default:

        ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, TRUE, TRUE );
        break;
    }

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (NT_SUCCESS( Status ) &&
                (IrpContext == NULL)) {

                //
                //  Allocate and initialize the Irp.
                //

                NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );

            } else if (Status != STATUS_CANT_WAIT) {

                //
                // As long as Status is not STATUS_CANT_WAIT or STATUS_LOG_FILE_FULL,
                // we want to exit the loop.
                //

                if (DecrementCloseCount) {

                    NtfsAcquireExclusiveVcb( IrpContext, IrpContext->Vcb, TRUE );

                    IrpContext->Vcb->CloseCount -= 1;

                    NtfsReleaseVcbCheckDelete( IrpContext, IrpContext->Vcb, IrpContext->MajorFunction, NULL );

                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );

                    NtfsCompleteRequest( IrpContext, NULL, Status );
                }

                break;
            }

            Status = NtfsCommonPnp( IrpContext, &Irp, &DecrementCloseCount );

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (TRUE);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdPnp -> %08lx\n", Status) );

    return Status;
}


NTSTATUS
NtfsCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP *Irp,
    IN OUT PBOOLEAN CallerDecrementCloseCount
    )

/*++

Routine Description:

    This is the common routine for PnP called by the fsd thread.

Arguments:

    Irp - Supplies the Irp to process.  WARNING!  THIS IRP HAS NO
          FILE OBJECT IN OUR IRP STACK LOCATION!!!

    CallerDecrementCloseCount - Returns TRUE if the caller needs to decrement
                                the Vcb CloseCount.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    NTSTATUS FlushStatus;
    PIO_STACK_LOCATION IrpSp;
    NTFS_COMPLETION_CONTEXT CompletionContext;
    PVOLUME_DEVICE_OBJECT OurDeviceObject;

    PVCB Vcb;
    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN CheckpointAcquired = FALSE;

#ifdef SYSCACHE_DEBUG
    ULONG SystemHandleCount = 0;
#endif

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    if (*Irp != NULL) {

        ASSERT_IRP( *Irp );

        //
        //  Get the current Irp stack location.
        //

        IrpSp = IoGetCurrentIrpStackLocation( *Irp );

        //
        //  Find our Vcb.  This is tricky since we have no file object in the Irp.
        //

        OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;

        //
        //  Make sure this device object really is big enough to be a volume device
        //  object.  If it isn't, we need to get out before we try to reference some
        //  field that takes us past the end of an ordinary device object.  Then we
        //  check if it is actually one of ours, just to be perfectly paranoid.
        //

        if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
            NodeType(&OurDeviceObject->Vcb) != NTFS_NTC_VCB) {

            NtfsCompleteRequest( IrpContext, *Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        Vcb = &OurDeviceObject->Vcb;
        KeInitializeEvent( &CompletionContext.Event, NotificationEvent, FALSE );

    } else {

        Vcb = IrpContext->Vcb;
    }

    //
    //  Anyone who is flushing the volume or setting Vcb bits needs to get the
    //  vcb exclusively.
    //

    switch ( IrpContext->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:

        //
        //  Lock volume / dismount synchs with checkpoint - we need to do this first before
        //  acquiring the vcb to preserve locking order since we're going to do a lock in
        //  the query remove case and a dismount in the surprise removal
        //

        NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );
        CheckpointAcquired = TRUE;

        // fall through

    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        VcbAcquired = TRUE;
        break;
    }

    try {

        if (*Irp != NULL) {

            switch ( IrpContext->MinorFunction ) {

            case IRP_MN_QUERY_REMOVE_DEVICE:

                DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE\n") );

                if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                    Status = STATUS_VOLUME_DISMOUNTED;
                    break;
                }

                //
                //  If we already know we don't want to dismount this volume, don't bother
                //  flushing now.  If there's a nonzero cleanup count, flushing won't get
                //  the close count down to zero, so we might as well get out now.
                //

    #ifdef SYSCACHE_DEBUG
                if (Vcb->SyscacheScb != NULL) {
                    SystemHandleCount = Vcb->SyscacheScb->CleanupCount;
                }
                if ((Vcb->CleanupCount > SystemHandleCount) ||
    #else
                if ((Vcb->CleanupCount > 0) ||
    #endif
                    FlagOn(Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT)) {

                    DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE --> cleanup count still %x \n", Vcb->CleanupCount) );

                    //
                    //  We don't want the device to get removed or stopped if this volume has files
                    //  open.  We'll fail this query, and we won't bother calling the driver(s) below us.
                    //

                    Status = STATUS_UNSUCCESSFUL;

                } else {

                    //
                    //  We might dismount this volume soon, so let's try to flush and purge
                    //  everything we can right now.
                    //

                    FlushStatus = NtfsFlushVolume( IrpContext,
                                                   Vcb,
                                                   TRUE,
                                                   TRUE,
                                                   TRUE,
                                                   FALSE );

                    //
                    //  We need to make sure the cache manager is done with any lazy writes
                    //  that might be keeping the close count up.  Since Cc might need to
                    //  close some streams, we need to release the vcb.  We'd hate to have
                    //  the Vcb go away, so we'll bias the close count temporarily.
                    //

                    Vcb->CloseCount += 1;

                    NtfsReleaseVcb( IrpContext, Vcb );
                    CcWaitForCurrentLazyWriterActivity();

                    ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

                    NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );

                    Vcb->CloseCount -= 1;

                    //
                    //  Since we dropped the Vcb, we need to redo any tests we've done.
                    //

                    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                        Status = STATUS_VOLUME_DISMOUNTED;
                        break;
                    }


    #ifdef SYSCACHE_DEBUG
                    if (Vcb->SyscacheScb != NULL) {
                        SystemHandleCount = Vcb->SyscacheScb->CleanupCount;
                    }

                    if ((Vcb->CleanupCount > SystemHandleCount) ||
    #else
                    if ((Vcb->CleanupCount > 0) ||
    #endif
                        FlagOn(Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT)) {

                        Status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                    if ((Vcb->CloseCount - (Vcb->SystemFileCloseCount + Vcb->QueuedCloseCount)) > 0) {

                        DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE --> %x user files still open \n", (Vcb->CloseCount - Vcb->SystemFileCloseCount)) );

                        //
                        //  We don't want the device to get removed or stopped if this volume has files
                        //  open.  We'll fail this query, and we won't bother calling the driver(s) below us.
                        //

                        Status = STATUS_UNSUCCESSFUL;

                    } else {

                        //
                        //  We've already done all we can to clear up any open files, so there's
                        //  no point in retrying if this lock volume fails.  We'll just tell
                        //  NtfsLockVolumeInternal we're already retrying.
                        //

                        ULONG Retrying = 1;

                        DebugTrace( 0, Dbg, ("IRP_MN_QUERY_REMOVE_DEVICE --> No user files, Locking volume \n") );

                        Status = NtfsLockVolumeInternal( IrpContext,
                                                         Vcb,
                                                         ((PFILE_OBJECT) 1),
                                                         &Retrying );

                        //
                        //  Remember not to send any irps to the target device now.
                        //

                        if (NT_SUCCESS( Status )) {

                            ASSERT_EXCLUSIVE_RESOURCE( &Vcb->Resource );
                            SetFlag( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED );
                        }
                    }
                }

                break;

            case IRP_MN_REMOVE_DEVICE:

                DebugTrace( 0, Dbg, ("IRP_MN_REMOVE_DEVICE\n") );

                //
                //  If remove_device is preceded by query_remove, we treat this just
                //  like a cancel_remove and unlock the volume and pass the irp to
                //  the driver(s) below the filesystem.
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {

                    DebugTrace( 0, Dbg, ("IRP_MN_REMOVE_DEVICE --> Volume locked \n") );
                    Status = NtfsUnlockVolumeInternal( IrpContext, Vcb );

                } else {

                    //
                    //  The only other possibility is for remove_device to be prededed
                    //  by surprise_remove, in which case we treat this as a failed verify.
                    //

                    // **** TODO **** ADD CODE TO TREAT THIS LIKE A FAILED VERIFY

                    DebugTrace( 0, Dbg, ("IRP_MN_REMOVE_DEVICE --> Volume _not_ locked \n") );
                    Status = STATUS_SUCCESS;
                }

                break;

            case IRP_MN_SURPRISE_REMOVAL:

                DebugTrace( 0, Dbg, ("IRP_MN_SURPRISE_REMOVAL\n") );

                //
                //  For surprise removal, we call the driver(s) below us first, then do
                //  our processing. Let us also remember that we can't send any more
                //  IRPs to the target device.
                //

                SetFlag( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED );

                Status = STATUS_SUCCESS;
                break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:

                Status = STATUS_SUCCESS;
                break;

            default:

                DebugTrace( 0, Dbg, ("Some other PnP IRP_MN_ %x\n", IrpContext->MinorFunction) );
                Status = STATUS_SUCCESS;
                break;
            }

            //
            //  We only pass this irp down if we didn't have some reason to fail it ourselves.
            //  We want to keep the IrpContext around for our own cleanup.
            //

            if (!NT_SUCCESS( Status )) {

                NtfsCompleteRequest( NULL, *Irp, Status );
                try_return( NOTHING );
            }

            //
            //  Get the next stack location, and copy over the stack location
            //

            IoCopyCurrentIrpStackLocationToNext( *Irp );

            //
            //  Set up the completion routine
            //

            CompletionContext.IrpContext = IrpContext;
            IoSetCompletionRoutine( *Irp,
                                    NtfsPnpCompletionRoutine,
                                    &CompletionContext,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Send the request to the driver(s) below us. - We don't own it anymore
            //  so null it out
            //

            Status = IoCallDriver( Vcb->TargetDeviceObject, *Irp );
            *Irp = IrpContext->OriginatingIrp = NULL;

            //
            //   Wait for the driver to definitely complete
            //

            if (Status == STATUS_PENDING) {

                KeWaitForSingleObject( &CompletionContext.Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL );
                KeClearEvent( &CompletionContext.Event );
            }
        }

        //
        //  Post processing - these are items that need to be done after the lower
        //  storage stack has processed the request.
        //

        switch (IrpContext->MinorFunction) {

        case IRP_MN_SURPRISE_REMOVAL:

            //
            //  Start the tear-down process irrespective of the status
            //  the driver below us sent back. There's no turning back here.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

                if (!*CallerDecrementCloseCount) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
                    Vcb->CloseCount += 1;
                    *CallerDecrementCloseCount = TRUE;
                }

                NtfsPerformSurpriseRemoval( IrpContext, Vcb );
            }
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            //
            //  Since we cancelled and have told the driver we can now safely unlock
            //  the volume and send ioctls to the drive (unlock media)
            //

            ClearFlag( Vcb->VcbState, VCB_STATE_TARGET_DEVICE_STOPPED );

            if (FlagOn( Vcb->VcbState, VCB_STATE_EXPLICIT_LOCK )) {

                if (!*CallerDecrementCloseCount) {

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_PERSISTENT );
                    Vcb->CloseCount += 1;
                    *CallerDecrementCloseCount = TRUE;
                }

                DebugTrace( 0, Dbg, ("IRP_MN_CANCEL_REMOVE_DEVICE --> Volume locked \n") );
                NtfsUnlockVolumeInternal( IrpContext, Vcb );

            }
            break;
        }

    try_exit: NOTHING;
    } finally {

        if (VcbAcquired) {

            //
            //  All 4 paths query / remove / surprise remove / cancel remove
            //  come through here. For the 3 except query we want the vcb to go away
            //  if possible. In the query remove path - dismount won't be complete
            //  even if the close count is 0 (since the dismount is incomplete)
            //  so this will only release
            //

            NtfsReleaseVcbCheckDelete( IrpContext, Vcb, IrpContext->MajorFunction, NULL );
        }

        if (CheckpointAcquired) {
            NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
        }
    }

    //
    //  Cleanup our IrpContext;  The underlying driver completed the Irp.
    //

    DebugTrace( -1, Dbg, ("NtfsCommonPnp -> %08lx\n", Status ) );
    NtfsCompleteRequest( IrpContext, NULL, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
NtfsPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PNTFS_COMPLETION_CONTEXT CompletionContext
    )
{
    PIO_STACK_LOCATION IrpSp;
    PIRP_CONTEXT IrpContext;
    PVOLUME_DEVICE_OBJECT OurDeviceObject;

    PVCB Vcb;
    BOOLEAN VcbAcquired = FALSE;

    ASSERT_IRP( Irp );

    IrpContext = CompletionContext->IrpContext;
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) DeviceObject;

    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.  Then we
    //  check if it is actually one of ours, just to be perfectly paranoid.
    //

    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType(&OurDeviceObject->Vcb) != NTFS_NTC_VCB) {

        return STATUS_INVALID_PARAMETER;
    }

    Vcb = &OurDeviceObject->Vcb;

    KeSetEvent( &CompletionContext->Event, 0, FALSE );

    //
    //  Propagate the Irp pending state.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}

//
// Local utility routine
//


VOID
NtfsPerformSurpriseRemoval (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

    Performs further processing on SURPRISE_REMOVAL notifications.

--*/

{
    ASSERT(ExIsResourceAcquiredExclusiveLite( &Vcb->Resource ));

    //
    //  Flush and purge and mark all files as dismounted.
    //  Since there may be outstanding handles, we could still see any
    //  operation (read, write, set info, etc.) happen for files on the
    //  volume after surprise_remove.  Since all the files will be marked
    //  for dismount, we will fail these operations gracefully.  All
    //  operations besides cleanup & close on the volume will fail from
    //  this time on.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_DISALLOW_DISMOUNT )) {

        (VOID)NtfsFlushVolume( IrpContext,
                               Vcb,
                               FALSE,
                               TRUE,
                               TRUE,
                               TRUE );

        NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\quota.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Quota.c

Abstract:

    This module implements the File set and query Quota routines for Ntfs called
    by the dispatch driver.

Author:

    Jeff Havens       [Jhavens]         12-Jul-1996

Revision History:

--*/

#include "NtfsProc.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_QUOTA)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('QFtN')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonQueryQuota)
#pragma alloc_text(PAGE, NtfsCommonSetQuota)
#endif


NTSTATUS
NtfsCommonQueryQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query Quota called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_GET_QUOTA_INFORMATION UserSidList;
    PFILE_QUOTA_INFORMATION QuotaBuffer = NULL;
    PFILE_QUOTA_INFORMATION MappedQuotaBuffer = NULL;
    PFILE_QUOTA_INFORMATION OriginalQuotaBuffer;
    ULONG OriginalBufferLength;
    ULONG UserBufferLength;
    ULONG UserSidListLength;
    PSID UserStartSid;
    ULONG OwnerId;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;
    BOOLEAN TempBufferAllocated = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonQueryQuota\n") );
    DebugTrace( 0, Dbg, ("IrpContext         = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp                = %08lx\n", Irp) );
    DebugTrace( 0, Dbg, ("SystemBuffer       = %08lx\n", Irp->AssociatedIrp.SystemBuffer) );
    DebugTrace( 0, Dbg, ("Length             = %08lx\n", IrpSp->Parameters.QueryQuota.Length) );
    DebugTrace( 0, Dbg, ("SidList            = %08lx\n", IrpSp->Parameters.QueryQuota.SidList) );
    DebugTrace( 0, Dbg, ("SidListLength      = %08lx\n", IrpSp->Parameters.QueryQuota.SidListLength) );
    DebugTrace( 0, Dbg, ("StartSid           = %08lx\n", IrpSp->Parameters.QueryQuota.StartSid) );
    DebugTrace( 0, Dbg, ("RestartScan        = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN)) );
    DebugTrace( 0, Dbg, ("ReturnSingleEntry  = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY)) );
    DebugTrace( 0, Dbg, ("IndexSpecified     = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED)) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    UserBufferLength = IrpSp->Parameters.QueryQuota.Length;
    UserSidList = IrpSp->Parameters.QueryQuota.SidList;
    UserSidListLength = IrpSp->Parameters.QueryQuota.SidListLength;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  This must be a user file or directory and the Ccb must indicate that
    //  the caller opened the entire file. We don't like zero length user buffers or SidLists either.
    //

    if (((TypeOfOpen != UserFileOpen) &&
         (TypeOfOpen != UserDirectoryOpen) &&
         (TypeOfOpen != UserVolumeOpen) &&
         (TypeOfOpen != UserViewIndexOpen)) ||
         (UserBufferLength == 0) ||
         ((UserSidList != NULL) && (UserSidListLength == 0)) ||
        (Ccb == NULL) ||
        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryQuota -> %08lx\n", STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Return nothing if quotas are not enabled.
    //

    if (Vcb->QuotaTableScb == NULL) {

        NtfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Acquire the Vcb Shared.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Reference our input parameters to make things easier
        //

        UserStartSid = IrpSp->Parameters.QueryQuota.StartSid;
        RestartScan = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
        ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
        IndexSpecified = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

        //
        //  Initialize our local variables.
        //

        Status = STATUS_SUCCESS;

        //
        //  Map the user's buffer.
        //

        QuotaBuffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

        //
        //  Allocate our own output buffer out of paranoia.
        //

        if (Irp->RequestorMode != KernelMode) {

            MappedQuotaBuffer = QuotaBuffer;
            QuotaBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );
            TempBufferAllocated = TRUE;
        }

        OriginalBufferLength = UserBufferLength;
        OriginalQuotaBuffer = QuotaBuffer;

        //
        //  Let's clear the output buffer.
        //

        RtlZeroMemory( QuotaBuffer, UserBufferLength );

        //
        //  We now satisfy the user's request depending on whether he
        //  specified an Quota name list, an Quota index or restarting the
        //  search.
        //

        //
        //  The user has supplied a list of Quota names.
        //

        if (UserSidList != NULL) {

            Status = NtfsQueryQuotaUserSidList( IrpContext,
                                                Vcb,
                                                UserSidList,
                                                QuotaBuffer,
                                                &UserBufferLength,
                                                ReturnSingleEntry );

        } else {

            //
            //  The user supplied an index into the Quota list.
            //

            if (IndexSpecified) {

                OwnerId = NtfsGetOwnerId( IrpContext,
                                          UserStartSid,
                                          FALSE,
                                          NULL );

                if (OwnerId == QUOTA_INVALID_ID) {

                    //
                    //  Fail the request.
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    leave;
                }

            } else {

                //
                //  Start at the begining of the list if restart specified.
                //

                OwnerId = RestartScan ? QUOTA_FISRT_USER_ID - 1 : Ccb->LastOwnerId;

            }

            Status = NtfsFsQuotaQueryInfo( IrpContext,
                                           Vcb,
                                           OwnerId,
                                           ReturnSingleEntry,
                                           &QuotaBuffer,
                                           &UserBufferLength,
                                           Ccb );

            //
            //  If we specified SingleEntry, NextEntryOffset would still be uninitialized.
            //

            if (NT_SUCCESS( Status ) && ReturnSingleEntry) {

                QuotaBuffer->NextEntryOffset = 0;
            }

        }

        //
        //  Copy the data onto the user buffer if we ended up allocating
        //  a temporary buffer to work on. Check if there's anything to copy, too.
        //  UserBufferLength reflects how much of the buffer is left.
        //

        if (TempBufferAllocated &&
            (UserBufferLength < OriginalBufferLength)) {

            try {

                RtlCopyMemory( MappedQuotaBuffer, OriginalQuotaBuffer,
                               OriginalBufferLength - UserBufferLength );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                try_return( Status = STATUS_INVALID_USER_BUFFER );
            }
        }

        if (UserBufferLength <= OriginalBufferLength) {

            Irp->IoStatus.Information = OriginalBufferLength - UserBufferLength;

        } else {

            ASSERT( FALSE );
            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsCommonQueryQuota );

        //
        //  Release the Vcb.
        //

        NtfsReleaseVcb( IrpContext, Vcb );

        if (TempBufferAllocated) {

            NtfsFreePool( OriginalQuotaBuffer );
        }

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsCommonQueryQuota -> %08lx\n", Status) );
    }

    return Status;
}


NTSTATUS
NtfsCommonSetQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set Quota called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;

    PFILE_QUOTA_INFORMATION Buffer;
    PFILE_QUOTA_INFORMATION SafeBuffer = NULL;
    ULONG UserBufferLength;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonSetQuota\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, TRUE );

    //
    //  Initialize the IoStatus values.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    UserBufferLength = IrpSp->Parameters.SetQuota.Length;

    //
    //  Check that the file object is associated with either a user file or
    //  user directory open or an open by file ID.
    //

    if ((Ccb == NULL) ||

        (!FlagOn( Ccb->AccessFlags, MANAGE_VOLUME_ACCESS) &&
         ((TypeOfOpen != UserViewIndexOpen) || (Fcb != Vcb->QuotaTableScb->Fcb))) ||

        (UserBufferLength == 0) ||

        !FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

        if (UserBufferLength != 0) {

            Status = STATUS_ACCESS_DENIED;

        } else {

            Status = STATUS_INVALID_PARAMETER;
        }

        NtfsCompleteRequest( IrpContext, Irp, Status );
        DebugTrace( -1, Dbg, ("NtfsCommonQueryQuota -> %08lx\n", Status) );

        return Status;
    }

    //
    //  We must be writable.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        Status = STATUS_MEDIA_WRITE_PROTECTED;
        NtfsCompleteRequest( IrpContext, Irp, Status );

        DebugTrace( -1, Dbg, ("NtfsCommonSetQuota -> %08lx\n", Status) );
        return Status;
    }

    //
    //  We must be waitable.
    //

    if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT )) {

        Status = NtfsPostRequest( IrpContext, Irp );

        DebugTrace( -1, Dbg, ("NtfsCommonSetQuota -> %08lx\n", Status) );
        return Status;
    }

    //
    //  Acquire the vcb shared.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        //
        //  Map the user's Quota buffer.
        //

        Buffer = NtfsMapUserBuffer( Irp, NormalPagePriority );

        //
        // Be paranoid and copy the user buffer into kernel space.
        //

        if (Irp->RequestorMode != KernelMode) {

            SafeBuffer = NtfsAllocatePool( PagedPool, UserBufferLength );

            try {

                RtlCopyMemory( SafeBuffer, Buffer, UserBufferLength );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = STATUS_INVALID_USER_BUFFER;
                leave;
            }

            Buffer = SafeBuffer;
        }

        //
        //  Update the caller's Iosb.
        //

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;

        Status = NtfsFsQuotaSetInfo( IrpContext,
                                     Vcb,
                                     Buffer,
                                     UserBufferLength );

        //
        //  Check if there are transactions to cleanup.
        //

        NtfsCleanupTransaction( IrpContext, Status, FALSE );

    } finally {

        DebugUnwind( NtfsCommonSetQuota );

        //
        //  Release the Vcb.
        //

        NtfsReleaseVcb( IrpContext, Vcb );

        //
        // If we allocated a temporary buffer, free it.
        //

        if (SafeBuffer != NULL) {

            NtfsFreePool( SafeBuffer );
        }

        //
        //  Complete the Irp.
        //

        if (!AbnormalTermination()) {

            NtfsCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace( -1, Dbg, ("NtfsCommonSetQuota -> %08lx\n", Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfsproc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsProc.h

Abstract:

    This module defines all of the globally used procedures in the Ntfs
    file system.

Author:

    Brian Andrew    [BrianAn]       21-May-1991
    David Goebel    [DavidGoe]
    Gary Kimura     [GaryKi]
    Tom Miller      [TomM]

Revision History:

--*/

#ifndef _NTFSPROC_
#define _NTFSPROC_

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable
#pragma warning(error:4705)   // Statement has no effect
#pragma warning(disable:4116) // unnamed type definition in parentheses

#define RTL_USE_AVL_TABLES 0

#ifndef KDEXTMODE

#include <ntifs.h>

#else

#include <ntos.h>
#include <zwapi.h>
#include <FsRtl.h>
#include <ntrtl.h>

#endif

#include <string.h>
#include <lfs.h>
#include <ntdddisk.h>
#include <NtIoLogc.h>
#include <elfmsg.h>

#include "nodetype.h"
#include "Ntfs.h"

#ifndef INLINE
// definition of inline
#define INLINE __inline
#endif

#include <ntfsexp.h>

#include "NtfsStru.h"
#include "NtfsData.h"
#include "NtfsLog.h"

//
//  Tag all of our allocations if tagging is turned on
//

//
//  Default module pool tag
//

#define MODULE_POOL_TAG ('0ftN')

#if 0
#define NtfsVerifySizes(s)  (ASSERT( (s)->ValidDataLength.QuadPart <= (s)->FileSize.QuadPart && (s)->FileSize.QuadPart <= (s)->AllocationSize.QuadPart ))
#define NtfsVerifySizesLongLong(s)  (ASSERT( (s)->ValidDataLength <= (s)->FileSize && (s)->FileSize <= (s)->AllocationSize ))
#else   //  !DBG
#define NtfsVerifySizes(s)
#define NtfsVerifySizesLongLong(s)
#endif  //  !DBG

#if !(DBG && i386 && defined (NTFSPOOLCHECK))

//
//  Non-debug allocate and free goes directly to the FsRtl routines
//

#define NtfsAllocatePoolWithTagNoRaise(a,b,c)   ExAllocatePoolWithTag((a),(b),(c))
#define NtfsAllocatePoolWithTag(a,b,c)          FsRtlAllocatePoolWithTag((a),(b),(c))
#define NtfsAllocatePoolNoRaise(a,b)            ExAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define NtfsAllocatePool(a,b)                   FsRtlAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define NtfsFreePool(pv)                        ExFreePool(pv)

#else   //  !DBG

//
//  Debugging routines capture the stack backtrace for allocates and frees
//

#define NtfsAllocatePoolWithTagNoRaise(a,b,c)   NtfsDebugAllocatePoolWithTagNoRaise((a),(b),(c))
#define NtfsAllocatePoolWithTag(a,b,c)          NtfsDebugAllocatePoolWithTag((a),(b),(c))
#define NtfsAllocatePoolNoRaise(a,b)            NtfsDebugAllocatePoolWithTagNoRaise((a),(b),MODULE_POOL_TAG)
#define NtfsAllocatePool(a,b)                   NtfsDebugAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)
#define NtfsFreePool(pv)                        NtfsDebugFreePool(pv)

PVOID
NtfsDebugAllocatePoolWithTagNoRaise (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag);

PVOID
NtfsDebugAllocatePoolWithTag (
    POOL_TYPE Pool,
    ULONG Length,
    ULONG Tag);

VOID
NtfsDebugFreePool (
    PVOID pv);

VOID
NtfsDebugHeapDump (
    PUNICODE_STRING UnicodeString );

#endif  //  !DBG

//
//  Local character comparison macros that we might want to later move to ntfsproc
//

#define IsCharZero(C)    (((C) & 0x000000ff) == 0x00000000)
#define IsCharMinus1(C)  (((C) & 0x000000ff) == 0x000000ff)
#define IsCharLtrZero(C) (((C) & 0x00000080) == 0x00000080)
#define IsCharGtrZero(C) (!IsCharLtrZero(C) && !IsCharZero(C))

//
//  The following two macro are used to find the first byte to really store
//  in the mapping pairs.  They take as input a pointer to the LargeInteger we are
//  trying to store and a pointer to a character pointer.  The character pointer
//  on return points to the first byte that we need to output.  That's we skip
//  over the high order 0x00 or 0xff bytes.
//

typedef struct _SHORT2 {
    USHORT LowPart;
    USHORT HighPart;
} SHORT2, *PSHORT2;

typedef struct _CHAR2 {
    UCHAR LowPart;
    UCHAR HighPart;
} CHAR2, *PCHAR2;

#define GetPositiveByte(LI,CP) {                           \
    *(CP) = (PCHAR)(LI);                                   \
    if ((LI)->HighPart != 0) { *(CP) += 4; }               \
    if (((PSHORT2)(*(CP)))->HighPart != 0) { *(CP) += 2; } \
    if (((PCHAR2)(*(CP)))->HighPart != 0) { *(CP) += 1; }  \
    if (IsCharLtrZero(*(*CP))) { *(CP) += 1; }             \
}

#define GetNegativeByte(LI,CP) {                                \
    *(CP) = (PCHAR)(LI);                                        \
    if ((LI)->HighPart != 0xffffffff) { *(CP) += 4; }           \
    if (((PSHORT2)(*(CP)))->HighPart != 0xffff) { *(CP) += 2; } \
    if (((PCHAR2)(*(CP)))->HighPart != 0xff) { *(CP) += 1; }    \
    if (!IsCharLtrZero(*(*CP))) { *(CP) += 1; }                 \
}


//
//  Flag macros
//
//      ULONG
//      FlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      BOOLEAN
//      BooleanFlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//

#ifdef KDEXTMODE

#ifndef FlagOn
#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)
#endif

#endif

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(F,SF) { \
//    (F) |= (SF);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(F,SF) { \
//    (F) &= ~(SF);         \
//}
//#endif



//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  NtfsFsdXxx(..)
//  {
//      try {
//
//          ..
//
//      } except(NtfsExceptionFilter( IrpContext, GetExceptionRecord() )) {
//
//          Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  STATUS_FILE_INVALID, use the below macro NtfsRaiseStatus).  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  NtfsNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise STATUS_UNEXPECTED_IO_ERROR if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  IrpContext->ExceptionStatus, signaling NtfsExceptionFilter and
//  NtfsProcessException that the status we actually raise is by definition
//  expected.
//

VOID
NtfsCorruptionBreakPointTest (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG ExceptionCode
    );

LONG
NtfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
NtfsProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS ExceptionCode
    );

VOID
DECLSPEC_NORETURN
NtfsRaiseStatus (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    );

ULONG
NtfsRaiseStatusFunction (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status
    );

//
//      VOID
//      NtfsNormalAndRaiseStatus (
//          IN PRIP_CONTEXT IrpContext,
//          IN NT_STATUS Status
//          IN NT_STATUS NormalStatus
//          );
//

#define NtfsNormalizeAndRaiseStatus(IC,STAT,NOR_STAT) {                          \
    (IC)->ExceptionStatus = (STAT);                                              \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STAT),NOR_STAT));                      \
}

//
//  Informational popup routine.
//

VOID
NtfsRaiseInformationHardError (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS  Status,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    );


//
//  Allocation support routines, implemented in AllocSup.c
//
//  These routines are for querying, allocating and truncating clusters
//  for individual data streams.
//

//
//   Syscache debugging support - Main current define these are triggered on is
//   SYSCACHE_DEBUG
//

#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG) || defined(SYSCACHE_DEBUG) || defined(SYSCACHE_DEBUG_ALLOC))

BOOLEAN
FsRtlIsSyscacheFile (
    IN PFILE_OBJECT FileObject
    );

//
//  Depreciated verification routine leftover from tomm's original debugging code
//

VOID
FsRtlVerifySyscacheData (
    IN PFILE_OBJECT FileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Offset
    );

ULONG
FsRtlLogSyscacheEvent (
    IN PSCB Scb,
    IN ULONG Event,
    IN ULONG Flags,
    IN LONGLONG Start,
    IN LONGLONG Range,
    IN LONGLONG Result
    );

VOID
FsRtlUpdateSyscacheEvent (
    IN PSCB Scb,
    IN ULONG EntryNumber,
    IN LONGLONG Result,
    IN ULONG NewFlag
    );

#define ScbIsBeingLogged( S )  (((S)->SyscacheLogEntryCount != 0) && (NtfsSyscacheLogSet[(S)->LogSetNumber].Scb == (S)))

#define FSCTL_ENABLE_SYSCACHE CTL_CODE( FILE_DEVICE_FILE_SYSTEM, 0x4545, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA )

#endif

//
//  The following routine takes an Vbo and returns the lbo and size of
//  the run corresponding to the Vbo.  It function result is TRUE if
//  the Vbo has a valid Lbo mapping and FALSE otherwise.
//

ULONG
NtfsPreloadAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    );

BOOLEAN
NtfsLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN Vcn,
    OUT PLCN Lcn,
    OUT PLONGLONG ClusterCount,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    );

BOOLEAN
NtfsIsRangeAllocated (
    IN PSCB Scb,
    IN VCN StartVcn,
    IN VCN FinalCluster,
    IN BOOLEAN RoundToSparseUnit,
    OUT PLONGLONG ClusterCount
    );

//
//  The following two routines modify the allocation of a data stream
//  represented by an Scb.
//

BOOLEAN
NtfsAllocateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN AllocateAll,
    IN BOOLEAN LogIt,
    IN LONGLONG Size,
    IN PATTRIBUTE_ENUMERATION_CONTEXT NewLocation OPTIONAL
    );

VOID
NtfsAddAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN LONGLONG ClusterCount,
    IN LOGICAL AskForMore,
    IN OUT PCCB CcbForWriteExtend OPTIONAL
    );

VOID
NtfsAddSparseAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN LONGLONG StartingOffset,
    IN LONGLONG ByteCount
    );

VOID
NtfsDeleteAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt,
    IN BOOLEAN BreakupAllowed
    );

VOID
NtfsReallocateRange (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN DeleteVcn,
    IN LONGLONG DeleteCount,
    IN VCN AllocateVcn,
    IN LONGLONG AllocateCount,
    IN PLCN TargetLcn OPTIONAL
    );

//
//  Routines for Mcb to Mapping Pairs operations
//

ULONG
NtfsGetSizeForMappingPairs (
    IN PNTFS_MCB Mcb,
    IN ULONG BytesAvailable,
    IN VCN LowestVcn,
    IN PVCN StopOnVcn OPTIONAL,
    OUT PVCN StoppedOnVcn
    );

BOOLEAN
NtfsBuildMappingPairs (
    IN PNTFS_MCB Mcb,
    IN VCN LowestVcn,
    IN OUT PVCN HighestVcn,
    OUT PCHAR MappingPairs
    );

VCN
NtfsGetHighestVcn (
    IN PIRP_CONTEXT IrpContext,
    IN VCN LowestVcn,
    IN PCHAR EndOfMappingPairs,
    IN PCHAR MappingPairs
    );

BOOLEAN
NtfsReserveClusters (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    );

VOID
NtfsFreeReservedClusters (
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    );

BOOLEAN
NtfsCheckForReservedClusters (
    IN PSCB Scb,
    IN LONGLONG StartingVcn,
    IN OUT PLONGLONG ClusterCount
    );

VOID
NtfsDeleteReservedBitmap (
    IN PSCB Scb
    );


//
//  Attribute lookup routines, implemented in AttrSup.c
//

//
//  This macro detects if we are enumerating through base or external
//  attributes, and calls the appropriate function.
//
//  BOOLEAN
//  LookupNextAttribute (
//      IN PRIP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE Code,
//      IN PUNICODE_STRING Name OPTIONAL,
//      IN BOOLEAN IgnoreCase,
//      IN PVOID Value OPTIONAL,
//      IN ULONG ValueLength,
//      IN PVCN Vcn OPTIONAL,
//      IN PATTRIBUTE_ENUMERATION_CONTEXT Context
//      );
//

#define LookupNextAttribute(IRPCTXT,FCB,CODE,NAME,IC,VALUE,LENGTH,V,CONTEXT)    \
    ( (CONTEXT)->AttributeList.Bcb == NULL                                      \
      ?   NtfsLookupInFileRecord( (IRPCTXT),                                    \
                                  (FCB),                                        \
                                  NULL,                                         \
                                  (CODE),                                       \
                                  (NAME),                                       \
                                  (V),                                          \
                                  (IC),                                         \
                                  (VALUE),                                      \
                                  (LENGTH),                                     \
                                  (CONTEXT))                                    \
      :   NtfsLookupExternalAttribute((IRPCTXT),                                \
                                      (FCB),                                    \
                                      (CODE),                                   \
                                      (NAME),                                   \
                                      (V),                                      \
                                      (IC),                                     \
                                      (VALUE),                                  \
                                      (LENGTH),                                 \
                                      (CONTEXT)) )

BOOLEAN
NtfsLookupExternalAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );



//
//  The following two routines do lookups based on the attribute definitions.
//

ATTRIBUTE_TYPE_CODE
NtfsGetAttributeTypeCode (
    IN PVCB Vcb,
    IN PUNICODE_STRING AttributeTypeName
    );


//
//  PATTRIBUTE_DEFINITION_COLUMNS
//  NtfsGetAttributeDefinition (
//      IN PVCB Vcb,
//      IN ATTRIBUTE_TYPE_CODE AttributeTypeCode
//      )
//

#define NtfsGetAttributeDefinition(Vcb,AttributeTypeCode)   \
    (&Vcb->AttributeDefinitions[(AttributeTypeCode / 0x10) - 1])

//
//  This routine looks up the attribute uniquely-qualified by the specified
//  Attribute Code and case-sensitive name.  The attribute may not be unique
//  if IgnoreCase is specified.
//


BOOLEAN
NtfsLookupInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_REFERENCE BaseFileReference OPTIONAL,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );


//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode and the specified QueriedName in the
//  specified BaseFileReference.  If we find one, its attribute record is
//  pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttributeByName (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PUNICODE_STRING QueriedName OPTIONAL,
//      IN PVCN Vcn OPTIONAL,
//      IN BOOLEAN IgnoreCase,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeByName(IrpContext,Fcb,BaseFileReference,QueriedTypeCode,QueriedName,Vcn,IgnoreCase,Context)  \
    NtfsLookupInFileRecord( IrpContext,             \
                            Fcb,                    \
                            BaseFileReference,      \
                            QueriedTypeCode,        \
                            QueriedName,            \
                            Vcn,                    \
                            IgnoreCase,             \
                            NULL,                   \
                            0,                      \
                            Context )


//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttributeByName (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PUNICODE_STRING QueriedName OPTIONAL,
//      IN BOOLEAN IgnoreCase,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//
#define NtfsLookupNextAttributeByName(IrpContext,Fcb,QueriedTypeCode,QueriedName,IgnoreCase,Context)    \
    LookupNextAttribute( IrpContext,                \
                         Fcb,                       \
                         QueriedTypeCode,           \
                         QueriedName,               \
                         IgnoreCase,                \
                         NULL,                      \
                         0,                         \
                         NULL,                      \
                         Context )

//
//  The following does a search based on a VCN.
//
//
//  BOOLEAN
//  NtfsLookupNextAttributeByVcn (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PVCN Vcn OPTIONAL,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT
//      );
//

#define NtfsLookupNextAttributeByVcn(IC,F,V,C)  \
    LookupNextAttribute( (IC),                  \
                         (F),                   \
                         $UNUSED,               \
                         NULL,                  \
                         FALSE,                 \
                         NULL,                  \
                         FALSE,                 \
                         (V),                   \
                         (C) )

//
//  The following routines find the attribute record for a given Scb.
//  And also update the scb from the attribute
//
//  VOID
//  NtfsLookupAttributeForScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb,
//      IN PVCN Vcn OPTIONAL,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeForScb(IrpContext,Scb,Vcn,Context)                           \
    if (!NtfsLookupAttributeByName( IrpContext,                                         \
                                    Scb->Fcb,                                           \
                                    &Scb->Fcb->FileReference,                           \
                                    Scb->AttributeTypeCode,                             \
                                    &Scb->AttributeName,                                \
                                    Vcn,                                                \
                                    FALSE,                                              \
                                    Context ) &&                                        \
        !FlagOn( Scb->ScbState, SCB_STATE_VIEW_INDEX )) {                               \
                                                                                        \
            DebugTrace( 0, 0, ("Could not find attribute for Scb @ %08lx\n", Scb ));    \
            ASSERTMSG("Could not find attribute for Scb\n", FALSE);                     \
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );   \
    }


//
//  This routine looks up and returns the next attribute for a given Scb.
//
//  BOOLEAN
//  NtfsLookupNextAttributeForScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttributeForScb(IrpContext,Scb,Context)   \
    NtfsLookupNextAttributeByName( IrpContext,                  \
                                   Scb->Fcb,                    \
                                   Scb->AttributeTypeCode,      \
                                   &Scb->AttributeName,         \
                                   FALSE,                       \
                                   Context )

VOID
NtfsUpdateScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER AttrHeader OPTIONAL
    );

//
//  The following routines deal with the Fcb and the duplicated information field.
//

BOOLEAN
NtfsUpdateFcbInfoFromDisk (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN LoadSecurity,
    IN OUT PFCB Fcb,
    OUT POLD_SCB_SNAPSHOT UnnamedDataSizes OPTIONAL
    );

//
//  These routines looks up the first/next attribute, i.e., they may be used
//  to retrieve all atributes for a file record.
//
//  If the Bcb in the Found Attribute structure changes in the Next call, then
//  the previous Bcb is autmatically unpinned and the new one pinned.
//

//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode in the specified BaseFileReference.  If we
//  find one, its attribute record is pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttribute (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttribute(IrpContext,Fcb,BaseFileReference,Context)   \
    NtfsLookupInFileRecord( IrpContext,                                 \
                            Fcb,                                        \
                            BaseFileReference,                          \
                            $UNUSED,                                    \
                            NULL,                                       \
                            NULL,                                       \
                            FALSE,                                      \
                            NULL,                                       \
                            0,                                          \
                            Context )

//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttribute (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttribute(IrpContext,Fcb,Context) \
    LookupNextAttribute( IrpContext,                    \
                         Fcb,                           \
                         $UNUSED,                       \
                         NULL,                          \
                         FALSE,                         \
                         NULL,                          \
                         0,                             \
                         NULL,                          \
                         Context )


//
//  These routines looks up the first/next attribute of the given type code.
//
//  If the Bcb in the Found Attribute structure changes in the Next call, then
//  the previous Bcb is autmatically unpinned and the new one pinned.
//


//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode in the specified BaseFileReference.  If we
//  find one, its attribute record is pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttributeByCode (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeByCode(IrpContext,Fcb,BaseFileReference,QueriedTypeCode,Context) \
    NtfsLookupInFileRecord( IrpContext,             \
                            Fcb,                    \
                            BaseFileReference,      \
                            QueriedTypeCode,        \
                            NULL,                   \
                            NULL,                   \
                            FALSE,                  \
                            NULL,                   \
                            0,                      \
                            Context )


//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttributeByCode (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttributeByCode(IC,F,CODE,C)  \
    LookupNextAttribute( (IC),                      \
                         (F),                       \
                         (CODE),                    \
                         NULL,                      \
                         FALSE,                     \
                         NULL,                      \
                         0,                         \
                         NULL,                      \
                         (C) )

//
//  These routines looks up the first/next occurrence of an attribute by its
//  Attribute Code and exact attribute value (consider using RtlCompareMemory).
//  The value contains everything outside of the standard attribute header,
//  so for example, to look up the File Name attribute by value, the caller
//  must form a record with not only the file name in it, but with the
//  ParentDirectory filled in as well.  The length should be exact, and not
//  include any unused (such as in DOS_NAME) or reserved characters.
//
//  If the Bcb changes in the Next call, then the previous Bcb is autmatically
//  unpinned and the new one pinned.
//


//
//  This routine attempts to find the fist occurrence of an attribute with
//  the specified AttributeTypeCode and the specified QueriedValue in the
//  specified BaseFileReference.  If we find one, its attribute record is
//  pinned and returned.
//
//  BOOLEAN
//  NtfsLookupAttributeByValue (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_REFERENCE BaseFileReference,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PVOID QueriedValue,
//      IN ULONG QueriedValueLength,
//      OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupAttributeByValue(IrpContext,Fcb,BaseFileReference,QueriedTypeCode,QueriedValue,QueriedValueLength,Context)    \
    NtfsLookupInFileRecord( IrpContext,             \
                            Fcb,                    \
                            BaseFileReference,      \
                            QueriedTypeCode,        \
                            NULL,                   \
                            NULL,                   \
                            FALSE,                  \
                            QueriedValue,           \
                            QueriedValueLength,     \
                            Context )

//
//  This function continues where the prior left off.
//
//  BOOLEAN
//  NtfsLookupNextAttributeByValue (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
//      IN PVOID QueriedValue,
//      IN ULONG QueriedValueLength,
//      IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
//      )
//

#define NtfsLookupNextAttributeByValue(IC,F,CODE,V,VL,C)    \
    LookupNextAttribute( (IC),                              \
                         (F),                               \
                         (CODE),                            \
                         NULL,                              \
                         FALSE,                             \
                         (V),                               \
                         (VL),                              \
                         (C) )


VOID
NtfsCleanupAttributeContext(
    IN OUT PIRP_CONTEXT IrpContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
    );

//
//
//
//  Here are some routines/macros for dealing with Attribute Enumeration
//  Contexts.
//
//      VOID
//      NtfsInitializeAttributeContext(
//          OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      VOID
//      NtfsPinMappedAttribute(
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      PATTRIBUTE_RECORD_HEADER
//      NtfsFoundAttribute(
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      PBCB
//      NtfsFoundBcb(
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      PFILE_RECORD
//      NtfsContainingFileRecord (
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//
//      LONGLONG
//      NtfsMftOffset (
//          IN PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
//          );
//

#define NtfsInitializeAttributeContext(CTX) {                      \
    RtlZeroMemory( (CTX), sizeof(ATTRIBUTE_ENUMERATION_CONTEXT) ); \
}

#define NtfsPinMappedAttribute(IC,V,CTX) {                  \
    NtfsPinMappedData( (IC),                                \
                       (V)->MftScb,                         \
                       (CTX)->FoundAttribute.MftFileOffset, \
                       (V)->BytesPerFileRecordSegment,      \
                       &(CTX)->FoundAttribute.Bcb );        \
}

#define NtfsFoundAttribute(CTX) (   \
    (CTX)->FoundAttribute.Attribute \
)

#define NtfsFoundBcb(CTX) (   \
    (CTX)->FoundAttribute.Bcb \
)

#define NtfsContainingFileRecord(CTX) ( \
    (CTX)->FoundAttribute.FileRecord    \
)

#define NtfsMftOffset(CTX) (                \
    (CTX)->FoundAttribute.MftFileOffset     \
)

//
//  This routine returns whether an attribute is resident or not.
//
//      BOOLEAN
//      NtfsIsAttributeResident (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//
//      PVOID
//      NtfsAttributeValue (
//          IN PATTRIBUTE_RECORD_HEADER Attribute
//          );
//

#define NtfsIsAttributeResident(ATTR) ( \
    ((ATTR)->FormCode == RESIDENT_FORM) \
)

#define NtfsAttributeValue(ATTR) (                             \
    ((PCHAR)(ATTR) + (ULONG)(ATTR)->Form.Resident.ValueOffset) \
)

//
//  This routine modifies the valid data length and file size on disk for
//  a given Scb.
//

BOOLEAN
NtfsWriteFileSizes (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG ValidDataLength,
    IN BOOLEAN AdvanceOnly,
    IN BOOLEAN LogIt,
    IN BOOLEAN RollbackMemStructures
    );

//
//  This routine updates the standard information attribute from the
//  information in the Fcb.
//

VOID
NtfsUpdateStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

//
//  This routine grows and updates the standard information attribute from
//  the information in the Fcb.
//

VOID
NtfsGrowStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

//
//  Attribute FILE_NAME routines.  These routines deal with filename attributes.
//

//      VOID
//      NtfsBuildFileNameAttribute (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFILE_REFERENCE ParentDirectory,
//          IN UNICODE_STRING FileName,
//          IN UCHAR Flags,
//          OUT PFILE_NAME FileNameValue
//          );
//

#define NtfsBuildFileNameAttribute(IC,PD,FN,FL,PFNA) {                  \
    (PFNA)->ParentDirectory = *(PD);                                    \
    (PFNA)->FileNameLength = (UCHAR)((FN).Length >> 1);                 \
    (PFNA)->Flags = FL;                                                 \
    RtlMoveMemory( (PFNA)->FileName, (FN).Buffer, (ULONG)(FN).Length ); \
}

BOOLEAN
NtfsLookupEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN BOOLEAN IgnoreCase,
    IN OUT PUNICODE_STRING Name,
    IN OUT PFILE_NAME *FileNameAttr,
    IN OUT PUSHORT FileNameAttrLength,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PBCB *IndexEntryBcb,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    );

//
//  Macro to decide when to create an attribute resident.
//
//      BOOLEAN
//      NtfsShouldAttributeBeResident (
//          IN PVCB Vcb,
//          IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
//          IN ULONG Size
//          );
//

#define RS(S) ((S) + SIZEOF_RESIDENT_ATTRIBUTE_HEADER)

#define NtfsShouldAttributeBeResident(VC,FR,S) (                         \
    (BOOLEAN)((RS(S) <= ((FR)->BytesAvailable - (FR)->FirstFreeByte)) || \
              (RS(S) < (VC)->BigEnoughToMove))                           \
)

//
//  Attribute creation/modification routines
//
//  These three routines do *not* presuppose either the Resident or Nonresident
//  form, with the single exception that if the attribute is indexed, then
//  it must be Resident.
//
//  NtfsMapAttributeValue and NtfsChangeAttributeValue implement transparent
//  access to small to medium sized attributes (such as $ACL and $EA), and
//  work whether the attribute is resident or nonresident.  The design target
//  is 0-64KB in size.  Attributes larger than 256KB (or more accurrately,
//  whatever the virtual mapping granularity is in the Cache Manager) will not
//  work correctly.
//

VOID
NtfsCreateAttributeWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN PFILE_REFERENCE WhereIndexed OPTIONAL,
    IN BOOLEAN LogIt,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsMapAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    OUT PBCB *Bcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsChangeAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG ValueOffset,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN BOOLEAN SetNewLength,
    IN BOOLEAN LogNonresidentToo,
    IN BOOLEAN CreateSectionUnderway,
    IN BOOLEAN PreserveContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsConvertToNonresident (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_RECORD_HEADER Attribute,
    IN BOOLEAN CreateSectionUnderway,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL
    );

#define DELETE_LOG_OPERATION        0x00000001
#define DELETE_RELEASE_FILE_RECORD  0x00000002
#define DELETE_RELEASE_ALLOCATION   0x00000004

VOID
NtfsDeleteAttributeRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsDeleteAllocationFromRecord (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN BreakupAllowed,
    IN BOOLEAN LogIt
    );

BOOLEAN
NtfsChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsAddToAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN MFT_SEGMENT_REFERENCE SegmentReference,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsDeleteFromAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

BOOLEAN
NtfsRewriteMftMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsSetTotalAllocatedField (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT TotalAllocatedNeeded
    );

VOID
NtfsSetSparseStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb OPTIONAL,
    IN PSCB Scb
    );

NTSTATUS
NtfsZeroRangeInStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PSCB Scb,
    IN PLONGLONG StartingOffset,
    IN LONGLONG FinalZero
    );

BOOLEAN
NtfsModifyAttributeFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT NewAttributeFlags
    );

PFCB
NtfsInitializeFileInExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCUNICODE_STRING FileName,
    IN BOOLEAN ViewIndex,
    IN ULONG CreateIfNotExist
    );

//
//  Use common routines to fill the common query buffers.
//

VOID
NtfsFillBasicInfo (
    OUT PFILE_BASIC_INFORMATION Buffer,
    IN PSCB Scb
    );

VOID
NtfsFillStandardInfo (
    OUT PFILE_STANDARD_INFORMATION Buffer,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    );

VOID
NtfsFillNetworkOpenInfo (
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PSCB Scb
    );

//
//  The following three routines dealing with allocation are to be
//  called by allocsup.c only.  Other software must call the routines
//  in allocsup.c
//

BOOLEAN
NtfsCreateAttributeWithAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN LogIt,
    IN BOOLEAN UseContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
NtfsAddAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN PVCN StartingVcn OPTIONAL,
    IN PVCN ClusterCount OPTIONAL
    );

VOID
NtfsDeleteAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN LogIt,
    IN PVCN StopOnVcn,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN TruncateToVcn
    );

//
//  To delete a file, you must first ask if it is deleteable from the ParentScb
//  used to get there for your caller, and then you can delete it if it is.
//

//
//      BOOLEAN
//      NtfsIsLinkDeleteable (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb,
//          OUT PBOOLEAN NonEmptyIndex,
//          OUT PBOOLEAN LastLink
//          );
//

#define NtfsIsLinkDeleteable(IC,FC,NEI,LL) ((BOOLEAN)                     \
    (((*(LL) = ((BOOLEAN) (FC)->LinkCount == 1)), (FC)->LinkCount > 1) || \
     (NtfsIsFileDeleteable( (IC), (FC), (NEI) )))                         \
)

BOOLEAN
NtfsIsFileDeleteable (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBOOLEAN NonEmptyIndex
    );

VOID
NtfsDeleteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN OUT PBOOLEAN AcquiredParentScb,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    );

VOID
NtfsPrepareForUpdateDuplicate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PLCB *Lcb,
    IN OUT PSCB *ParentScb,
    IN BOOLEAN AcquireShared
    );

VOID
NtfsUpdateDuplicateInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN PSCB ParentScb OPTIONAL
    );

VOID
NtfsUpdateLcbDuplicateInfo (
    IN PFCB Fcb,
    IN PLCB Lcb
    );

VOID
NtfsUpdateFcb (
    IN PFCB Fcb,
    IN ULONG ChangeFlags
    );

//
//  The following routines add and remove links.  They also update the name
//  flags in particular links.
//

VOID
NtfsAddLink (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CreatePrimaryLink,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN PBOOLEAN LogIt OPTIONAL,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    );

VOID
NtfsRemoveLink (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UNICODE_STRING LinkName,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    );

VOID
NtfsRemoveLinkViaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN UCHAR FileNameFlags,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    OUT PUNICODE_STRING FileName OPTIONAL
    );

VOID
NtfsUpdateFileNameFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UCHAR FileNameFlags,
    IN PFILE_NAME FileNameLink
    );

//
//  These routines are intended for low-level attribute access, such as within
//  attrsup, or for applying update operations from the log during restart.
//

VOID
NtfsRestartInsertAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID ValueOrMappingPairs OPTIONAL,
    IN ULONG Length
    );

VOID
NtfsRestartRemoveAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset
    );

VOID
NtfsRestartChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG NewRecordLength
    );

VOID
NtfsRestartChangeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN SetNewLength
    );

VOID
NtfsRestartChangeMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data,
    IN ULONG Length
    );

VOID
NtfsRestartWriteEndOfFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER OldAttribute,
    IN PATTRIBUTE_RECORD_HEADER NewAttributes,
    IN ULONG SizeOfNewAttributes
    );


//
//  Bitmap support routines.  Implemented in BitmpSup.c
//

//
//  The following routines are used for allocating and deallocating clusters
//  on the disk.  The first routine initializes the allocation support
//  routines and must be called for each newly mounted/verified volume.
//  The next two routines allocate and deallocate clusters via Mcbs.
//  The last three routines are simple query routines.
//

VOID
NtfsInitializeClusterAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN BOOLEAN AllocateAll,
    IN LONGLONG ClusterCount,
    IN PLCN TargetLcn OPTIONAL,
    IN OUT PLONGLONG DesiredClusterCount
    );

VOID
NtfsAddBadCluster (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn
    );

BOOLEAN
NtfsDeallocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PLONGLONG TotalAllocated OPTIONAL
    );

VOID
NtfsPreAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    OUT PBOOLEAN AcquiredBitmap,
    OUT PBOOLEAN AcquiredMft
    );

VOID
NtfsCleanupClusterAllocationHints (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PNTFS_MCB Mcb
    );

VOID
NtfsScanEntireBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LOGICAL CachedRunsOnly
    );

VOID
NtfsModifyBitsInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG FirstBit,
    IN LONGLONG BeyondFinalBit,
    IN ULONG RedoOperation,
    IN ULONG UndoOperation
    );

typedef enum _NTFS_RUN_STATE {
    RunStateUnknown = 1,
    RunStateFree,
    RunStateAllocated
} NTFS_RUN_STATE;
typedef NTFS_RUN_STATE *PNTFS_RUN_STATE;

BOOLEAN
NtfsAddCachedRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN NTFS_RUN_STATE RunState
    );

//
//  The following two routines are called at Restart to make bitmap
//  operations in the volume bitmap recoverable.
//

VOID
NtfsRestartSetBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    );

VOID
NtfsRestartClearBitsInBitMap (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_BITMAP Bitmap,
    IN ULONG BitMapOffset,
    IN ULONG NumberOfBits
    );

//
//  The following routines are for allocating and deallocating records
//  based on a bitmap attribute (e.g., allocating mft file records based on
//  the bitmap attribute of the mft).  If necessary the routines will
//  also extend/truncate the data and bitmap attributes to satisfy the
//  operation.
//

VOID
NtfsInitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB DataScb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute,
    IN ULONG BytesPerRecord,
    IN ULONG ExtendGranularity,         // In terms of records
    IN ULONG TruncateGranularity,       // In terms of records
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    );

VOID
NtfsUninitializeRecordAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PRECORD_ALLOCATION_CONTEXT RecordAllocationContext
    );

ULONG
NtfsAllocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsDeallocateRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsReserveMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

ULONG
NtfsAllocateMftReservedRecord (
    IN OUT PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsDeallocateRecordsComplete (
    IN PIRP_CONTEXT IrpContext
    );

BOOLEAN
NtfsIsRecordAllocated (
    IN PIRP_CONTEXT IrpContext,
    IN PRECORD_ALLOCATION_CONTEXT RecordAllocationContext,
    IN ULONG Index,
    IN PATTRIBUTE_ENUMERATION_CONTEXT BitmapAttribute
    );

VOID
NtfsScanMftBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

BOOLEAN
NtfsCreateMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsFindMftFreeTail (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PLONGLONG FileOffset
    );

//
//  Routines to handle the cached runs.
//

VOID
NtfsInitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );

VOID
NtfsReinitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );

VOID
NtfsUninitializeCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );


//
//  Buffer control routines for data caching using internal attribute
//  streams implemented in CacheSup.c
//

#define NtfsCreateInternalAttributeStream(IC,S,U,NM) {          \
    NtfsCreateInternalStreamCommon((IC),(S),(U),FALSE,(NM));    \
}

#define NtfsCreateInternalCompressedStream(IC,S,U,NM) {         \
    NtfsCreateInternalStreamCommon((IC),(S),(U),TRUE,(NM));     \
}

#define NtfsClearInternalFilename(_FileObject) {                \
    (_FileObject)->FileName.MaximumLength = 0;                  \
    (_FileObject)->FileName.Length = 0;                         \
    (_FileObject)->FileName.Buffer = NULL;                      \
}

VOID
NtfsCreateInternalStreamCommon (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN UpdateScb,
    IN BOOLEAN CompressedStream,
    IN UNICODE_STRING const *StreamName
    );

BOOLEAN
NtfsDeleteInternalAttributeStream (
    IN PSCB Scb,
    IN ULONG ForceClose,
    IN ULONG CompressedStreamOnly
    );

//
//  The following routines provide direct access to data in an attribute.
//

VOID
NtfsMapStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

VOID
NtfsPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN OUT PVOID *Bcb
    );

VOID
NtfsPinStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

VOID
NtfsPreparePinWriteStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN Zero,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

NTSTATUS
NtfsCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
NtfsZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN LONGLONG StartingZero,
    IN LONGLONG ByteCount,
    IN OUT PLONGLONG CommittedFileSize OPTIONAL
    );

//
//  The following is needed when biasing the SetFileSizes call for the Usn Journal.
//
//  VOID
//  NtfsSetCcFileSizes (
//      IN PFILE_OBJECT FileObject,
//      IN PSCB Scb,
//      IN PCC_FILE_SIZES CcSizes
//      );
//

#define NtfsSetCcFileSizes(FO,S,CC) {                               \
    if (FlagOn( (S)->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {       \
        CC_FILE_SIZES _CcSizes;                                     \
        RtlCopyMemory( &_CcSizes, (CC), sizeof( CC_FILE_SIZES ));   \
        _CcSizes.AllocationSize.QuadPart -= (S)->Vcb->UsnCacheBias; \
        _CcSizes.FileSize.QuadPart -= (S)->Vcb->UsnCacheBias;       \
        CcSetFileSizes( (FO), &_CcSizes );                          \
    } else {                                                        \
        CcSetFileSizes( (FO), (CC) );                               \
    }                                                               \
}

//
//  VOID
//  NtfsFreeBcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb
//      );
//
//  VOID
//  NtfsUnpinBcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb,
//      );
//

#define NtfsFreeBcb(IC,BC) {                        \
    ASSERT_IRP_CONTEXT(IC);                         \
    if (*(BC) != NULL)                              \
    {                                               \
        CcFreePinnedData(*(BC));                    \
        *(BC) = NULL;                               \
    }                                               \
}


#ifdef MAPCOUNT_DBG
#define NtfsUnpinBcb(IC,BC) {                       \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinData(*(BC));                         \
        (IC)->MapCount--;                           \
        *(BC) = NULL;                               \
    }                                               \
}
#else
#define NtfsUnpinBcb(IC,BC) {                       \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinData(*(BC));                         \
        *(BC) = NULL;                               \
    }                                               \
}
#endif

#ifdef MAPCOUNT_DBG
#define NtfsUnpinBcbForThread(IC,BC,T) {            \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinDataForThread(*(BC), (T));           \
        (IC)->MapCount--;                           \
        *(BC) = NULL;                               \
    }                                               \
}
#else
#define NtfsUnpinBcbForThread(IC,BC,T) {            \
    if (*(BC) != NULL)                              \
    {                                               \
        CcUnpinDataForThread(*(BC), (T));           \
        *(BC) = NULL;                               \
    }                                               \
}
#endif

INLINE
PBCB
NtfsRemapBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb
    )
{
    UNREFERENCED_PARAMETER( IrpContext );
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif
    return CcRemapBcb( Bcb );
}



//
//  Ntfs structure check routines in CheckSup.c
//

BOOLEAN
NtfsCheckFileRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    OUT PULONG CorruptionHint
    );

BOOLEAN
NtfsCheckAttributeRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG CheckHeaderOnly,
    OUT PULONG CorruptionHint
    );

BOOLEAN
NtfsCheckIndexRoot (
    IN PVCB Vcb,
    IN PINDEX_ROOT IndexRoot,
    IN ULONG AttributeSize
    );

BOOLEAN
NtfsCheckIndexBuffer (
    IN PSCB Scb,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    );

BOOLEAN
NtfsCheckIndexHeader (
    IN PINDEX_HEADER IndexHeader,
    IN ULONG BytesAvailable
    );

BOOLEAN
NtfsCheckLogRecord (
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG LogRecordLength,
    IN TRANSACTION_ID TransactionId,
    IN ULONG AttributeEntrySize
    );

BOOLEAN
NtfsCheckRestartTable (
    IN PRESTART_TABLE RestartTable,
    IN ULONG TableSize
    );


//
//  Collation routines, implemented in ColatSup.c
//
//  These routines perform low-level collation operations, primarily
//  for IndexSup.  All of these routines are dispatched to via dispatch
//  tables indexed by the collation rule.  The dispatch tables are
//  defined here, and the actual implementations are in colatsup.c
//

typedef
FSRTL_COMPARISON_RESULT
(*PCOMPARE_VALUES) (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN FSRTL_COMPARISON_RESULT WildCardIs,
    IN BOOLEAN IgnoreCase
    );

typedef
BOOLEAN
(*PIS_IN_EXPRESSION) (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

typedef
BOOLEAN
(*PARE_EQUAL) (
    IN PWCH UnicodeTable,
    IN PVOID Value,
    IN PINDEX_ENTRY IndexEntry,
    IN BOOLEAN IgnoreCase
    );

typedef
BOOLEAN
(*PCONTAINS_WILDCARD) (
    IN PVOID Value
    );

typedef
VOID
(*PUPCASE_VALUE) (
    IN PWCH UnicodeTable,
    IN ULONG UnicodeTableSize,
    IN OUT PVOID Value
    );

extern PCOMPARE_VALUES    NtfsCompareValues[COLLATION_NUMBER_RULES];
extern PIS_IN_EXPRESSION  NtfsIsInExpression[COLLATION_NUMBER_RULES];
extern PARE_EQUAL         NtfsIsEqual[COLLATION_NUMBER_RULES];
extern PCONTAINS_WILDCARD NtfsContainsWildcards[COLLATION_NUMBER_RULES];
extern PUPCASE_VALUE      NtfsUpcaseValue[COLLATION_NUMBER_RULES];

BOOLEAN
NtfsFileNameIsInExpression (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    );

BOOLEAN
NtfsFileNameIsEqual (
    IN PWCH UnicodeTable,
    IN PFILE_NAME ExpressionName,
    IN PFILE_NAME FileName,
    IN BOOLEAN IgnoreCase
    );


//
//  Compression on the wire routines in CowSup.c
//

BOOLEAN
NtfsCopyReadC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsCompressedCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize
    );

BOOLEAN
NtfsMdlReadCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
NtfsCopyWriteC (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsCompressedCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN ULONG CompressionUnitSize,
    IN ULONG ChunkSize,
    IN ULONG EngineMatches
    );

BOOLEAN
NtfsMdlWriteCompleteCompressed (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

NTSTATUS
NtfsSynchronizeUncompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    );

NTSTATUS
NtfsSynchronizeCompressedIo (
    IN PSCB Scb,
    IN PLONGLONG FileOffset,
    IN ULONG Length,
    IN ULONG WriteAccess,
    IN OUT PCOMPRESSION_SYNC *CompressionSync
    );

PCOMPRESSION_SYNC
NtfsAcquireCompressionSync (
    IN LONGLONG FileOffset,
    IN PSCB Scb,
    IN ULONG WriteAccess
    );

VOID
NtfsReleaseCompressionSync (
    IN PCOMPRESSION_SYNC CompressionSync
    );

INLINE
VOID
NtfsSetBothCacheSizes (
    IN PFILE_OBJECT FileObject,
    IN PCC_FILE_SIZES FileSizes,
    IN PSCB Scb
    )

{
    if (Scb->NonpagedScb->SegmentObject.SharedCacheMap != NULL) {
        NtfsSetCcFileSizes( FileObject, Scb, FileSizes );
    }

#ifdef  COMPRESS_ON_WIRE
    if (Scb->Header.FileObjectC != NULL) {
        CcSetFileSizes( Scb->Header.FileObjectC, FileSizes );
    }
#endif
}

//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device read and writes.  They only affect
//  the on disk structure and do not alter any other data structures.
//

VOID
NtfsLockUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
NtfsMapUserBuffer (
    IN OUT PIRP Irp,
    IN MM_PAGE_PRIORITY Priority
    );

PVOID
NtfsMapUserBufferNoRaise (
    IN OUT PIRP Irp,
    IN MM_PAGE_PRIORITY Priority
    );

VOID
NtfsFillIrpBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN ULONG ByteCount,
    IN ULONG Offset,
    IN UCHAR Pattern
    );

VOID
NtfsZeroEndOfSector (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN LONGLONG Offset,
    IN BOOLEAN Cached
    );

NTSTATUS
NtfsVolumeDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB DasdScb,
    IN PCCB Ccb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    );

VOID
NtfsPagingFileIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    );

BOOLEAN
NtfsIsReadAheadThread (
    );

//
//  Values for StreamFlags passed to NtfsNonCachedIo, etc.
//

#define COMPRESSED_STREAM   0x00000001
#define ENCRYPTED_STREAM    0x00000002

NTSTATUS
NtfsNonCachedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN ULONG StreamFlags
    );

VOID
NtfsNonCachedNonAlignedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN ULONG ByteCount
    );

#ifdef EFSDBG
NTSTATUS
NtfsDummyEfsRead (
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    );

NTSTATUS
NtfsDummyEfsWrite (
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    );
#endif

VOID
NtfsTransformUsaBlock (
    IN PSCB Scb,
    IN OUT PVOID SystemBuffer,
    IN OUT PVOID Buffer,
    IN ULONG Length
    );

VOID
NtfsCreateMdlAndBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ThisScb,
    IN UCHAR NeedTwoBuffers,
    IN OUT PULONG Length,
    OUT PMDL *Mdl OPTIONAL,
    OUT PVOID *Buffer
    );

VOID
NtfsDeleteMdlAndBuffer (
    IN PMDL Mdl OPTIONAL,
    IN PVOID Buffer OPTIONAL
    );

VOID
NtfsWriteClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VBO StartingVbo,
    IN PVOID Buffer,
    IN ULONG ClusterCount
    );

BOOLEAN
NtfsVerifyAndRevertUsaBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PIRP Irp OPTIONAL,
    IN PVOID SystemBuffer OPTIONAL,
    IN ULONG Offset,
    IN ULONG Length,
    IN LONGLONG FileOffset
    );

NTSTATUS
NtfsDefragFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsReadFromPlex(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following support routines are contained int Ea.c
//

PFILE_FULL_EA_INFORMATION
NtfsMapExistingEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBCB *EaBcb,
    OUT PULONG EaLength
    );

NTSTATUS
NtfsBuildEaList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PEA_LIST_HEADER EaListHeader,
    IN PFILE_FULL_EA_INFORMATION UserEaList,
    OUT PULONG_PTR ErrorOffset
    );

VOID
NtfsReplaceFileEas (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PEA_LIST_HEADER EaList
    );


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 1,
    UserFileOpen,
    UserDirectoryOpen,
    UserVolumeOpen,
    StreamFileOpen,
    UserViewIndexOpen

} TYPE_OF_OPEN;

VOID
NtfsSetFileObject (
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    );

//
//  TYPE_OF_OPEN
//  NtfsDecodeFileObject (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFILE_OBJECT FileObject,
//      OUT PVCB *Vcb,
//      OUT PFCB *Fcb,
//      OUT PSCB *Scb,
//      OUT PCCB *Ccb,
//      IN BOOLEAN RaiseOnError
//      );
//

#ifdef _DECODE_MACRO_
#define NtfsDecodeFileObject(IC,FO,V,F,S,C,R) (                                     \
    ( *(S) = (PSCB)(FO)->FsContext),                                                \
      ((*(S) != NULL)                                                               \
        ?   ((*(V) = (*(S))->Vcb),                                                  \
             (*(C) = (PCCB)(FO)->FsContext2),                                       \
             (*(F) = (*(S))->Fcb),                                                  \
             ((R)                                                                   \
              && !FlagOn((*(V))->VcbState, VCB_STATE_VOLUME_MOUNTED)                \
              && ((*(C) == NULL)                                                    \
                  || ((*(C))->TypeOfOpen != UserVolumeOpen)                         \
                  || !FlagOn((*(V))->VcbState, VCB_STATE_LOCKED))                   \
              && NtfsRaiseStatusFunction((IC), (STATUS_VOLUME_DISMOUNTED))),        \
             ((*(C) == NULL)                                                        \
              ? StreamFileOpen                                                      \
              : (*(C))->TypeOfOpen))                                                \
        : (*(C) = NULL,                                                             \
           UnopenedFileObject))                                                     \
)
#else //   _DECODE_MACRO_

INLINE TYPE_OF_OPEN
NtfsDecodeFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    OUT PVCB *Vcb,
    OUT PFCB *Fcb,
    OUT PSCB *Scb,
    OUT PCCB *Ccb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine decodes a file object into a Vcb, Fcb, Scb, and Ccb.

Arguments:

    IrpContext - The Irp context to use for raising on an error.

    FileObject - The file object to decode.

    Vcb - Where to store the Vcb.

    Fcb - Where to store the Fcb.

    Scb - Where to store the Scb.

    Ccb - Where to store the Ccb.

    RaiseOnError - If FALSE, we do not raise if we encounter an error.
                   Otherwise we do raise if we encounter an error.

Return Value:

    Type of open

--*/

{
    *Scb = (PSCB)FileObject->FsContext;

    if (*Scb != NULL) {

        *Vcb = (*Scb)->Vcb;
        *Ccb = (PCCB)FileObject->FsContext2;
        *Fcb = (*Scb)->Fcb;

        //
        //  If the caller wants us to raise, let's see if there's anything
        //  we should raise.
        //

        if (RaiseOnError &&
            !FlagOn((*Vcb)->VcbState, VCB_STATE_VOLUME_MOUNTED) &&
            ((*Ccb == NULL) ||
             ((*Ccb)->TypeOfOpen != UserVolumeOpen) ||
             !FlagOn((*Vcb)->VcbState, VCB_STATE_LOCKED))) {

            NtfsRaiseStatusFunction( IrpContext, STATUS_VOLUME_DISMOUNTED );
        }

        //
        //  Every open except a StreamFileOpen has a Ccb.
        //

        if (*Ccb == NULL) {

            return StreamFileOpen;

        } else {

            return (*Ccb)->TypeOfOpen;
        }

    } else {

        //
        //  No Scb, we assume the file wasn't open.
        //

        *Ccb = NULL;
        return UnopenedFileObject;
    }
}
#endif //  _DECODE_MACRO_

//
//  PSCB
//  NtfsFastDecodeUserFileOpen (
//      IN PFILE_OBJECT FileObject
//      );
//

#define NtfsFastDecodeUserFileOpen(FO) (                                                        \
    (((FO)->FsContext2 != NULL) && (((PCCB)(FO)->FsContext2)->TypeOfOpen == UserFileOpen)) ?    \
    (PSCB)(FO)->FsContext : NULL                                                                \
)

VOID
NtfsUpdateScbFromFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PSCB Scb,
    IN BOOLEAN CheckTimeStamps
    );

//
//  Ntfs-private FastIo routines.
//

BOOLEAN
NtfsCopyReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsCopyWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsMdlReadA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsPrepareMdlWriteA (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsWaitForIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header,
    IN OUT PLARGE_INTEGER FileOffset,
    IN ULONG Length
    );

VOID
NtfsFinishIoAtEof (
    IN PNTFS_ADVANCED_FCB_HEADER Header
    );

//
//  VOID
//  FsRtlLockFsRtlHeader (
//      IN PNTFS_ADVANCED_FCB_HEADER FsRtlHeader
//      );
//
//  VOID
//  FsRtlUnlockFsRtlHeader (
//      IN PNTFS_ADVANCED_FCB_HEADER FsRtlHeader
//      );
//

#define FsRtlLockFsRtlHeader(H) {                           \
    ExAcquireFastMutex( (H)->FastMutex );                   \
    if (((H)->Flags & FSRTL_FLAG_EOF_ADVANCE_ACTIVE)) {     \
        NtfsWaitForIoAtEof( (H), &LiEof, 0 );               \
    }                                                       \
    (H)->Flags |= FSRTL_FLAG_EOF_ADVANCE_ACTIVE;            \
    ExReleaseFastMutex( (H)->FastMutex );                   \
}

#define FsRtlUnlockFsRtlHeader(H) {                         \
    ExAcquireFastMutex( (H)->FastMutex );                   \
    NtfsFinishIoAtEof( (H) );                               \
    ExReleaseFastMutex( (H)->FastMutex );                   \
}


//
//  Volume locking/unlocking routines, implemented in FsCtrl.c.
//

NTSTATUS
NtfsLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObjectWithVcbLocked,
    IN OUT PULONG Retrying
    );

NTSTATUS
NtfsUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );


//
//  Indexing routine interfaces, implemented in IndexSup.c.
//

VOID
NtfsCreateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE IndexedAttributeType,
    IN COLLATION_RULE CollationRule,
    IN ULONG BytesPerIndexBuffer,
    IN UCHAR BlocksPerIndexBuffer,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN NewIndex,
    IN BOOLEAN LogIt
    );

VOID
NtfsUpdateIndexScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER IndexRootAttr,
    IN ULONG MustBeFileName
    );

BOOLEAN
NtfsFindIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PBCB *Bcb,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    );

VOID
NtfsUpdateFileNameInIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN PDUPLICATED_INFORMATION Info,
    IN OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

VOID
NtfsAddIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN PFILE_REFERENCE FileReference,
    IN PINDEX_CONTEXT IndexContext OPTIONAL,
    OUT PQUICK_INDEX QuickIndex OPTIONAL
    );

VOID
NtfsDeleteIndexEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PVOID Value,
    IN PFILE_REFERENCE FileReference
    );

VOID
NtfsPushIndexRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

BOOLEAN
NtfsRestartIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PVOID Value,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry,
    IN PFCB AcquiredFcb OPTIONAL
    );

BOOLEAN
NtfsContinueIndexEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN BOOLEAN NextFlag,
    OUT PINDEX_ENTRY *IndexEntry
    );

PFILE_NAME
NtfsRetrieveOtherFileName (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN PSCB Scb,
    IN PINDEX_ENTRY IndexEntry,
    IN OUT PINDEX_CONTEXT OtherContext,
    IN PFCB AcquiredFcb OPTIONAL,
    OUT PBOOLEAN SynchronizationError
    );

VOID
NtfsCleanupAfterEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

BOOLEAN
NtfsIsIndexEmpty (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    );

VOID
NtfsDeleteIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING AttributeName
    );

VOID
NtfsInitializeIndexContext (
    OUT PINDEX_CONTEXT IndexContext
    );

VOID
NtfsCleanupIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    );

VOID
NtfsReinitializeIndexContext (
    IN PIRP_CONTEXT IrpContext,
    OUT PINDEX_CONTEXT IndexContext
    );

//
//      PVOID
//      NtfsFoundIndexEntry (
//          IN PIRP_CONTEXT IrpContext,
//          IN PINDEX_ENTRY IndexEntry
//          );
//

#define NtfsFoundIndexEntry(IE) ((PVOID)    \
    ((PUCHAR) (IE) + sizeof( INDEX_ENTRY )) \
)

//
//  Restart routines for IndexSup
//

VOID
NtfsRestartInsertSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PINDEX_ENTRY BeforeIndexEntry
    );

VOID
NtfsRestartInsertSimpleAllocation (
    IN PINDEX_ENTRY InsertIndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer,
    IN PINDEX_ENTRY BeforeIndexEntry
    );

VOID
NtfsRestartWriteEndOfIndex (
    IN PINDEX_HEADER IndexHeader,
    IN PINDEX_ENTRY OverwriteIndexEntry,
    IN PINDEX_ENTRY FirstNewIndexEntry,
    IN ULONG Length
    );

VOID
NtfsRestartSetIndexBlock(
    IN PINDEX_ENTRY IndexEntry,
    IN LONGLONG IndexBlock
    );

VOID
NtfsRestartUpdateFileName(
    IN PINDEX_ENTRY IndexEntry,
    IN PDUPLICATED_INFORMATION Info
    );

VOID
NtfsRestartDeleteSimpleRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PINDEX_ENTRY IndexEntry,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute
    );

VOID
NtfsRestartDeleteSimpleAllocation (
    IN PINDEX_ENTRY IndexEntry,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    );

VOID
NtOfsRestartUpdateDataInIndex(
    IN PINDEX_ENTRY IndexEntry,
    IN PVOID IndexData,
    IN ULONG Length );


//
//  Ntfs hashing routines, implemented in HashSup.c
//

VOID
NtfsInitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    );

VOID
NtfsUninitializeHashTable (
    IN OUT PNTFS_HASH_TABLE Table
    );

PLCB
NtfsFindPrefixHashEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_HASH_TABLE Table,
    IN PSCB ParentScb,
    IN OUT PULONG CreateFlags,
    IN OUT PFCB *CurrentFcb,
    OUT PULONG FileHashValue,
    OUT PULONG FileNameLength,
    OUT PULONG ParentHashValue,
    OUT PULONG ParentNameLength,
    IN OUT PUNICODE_STRING RemainingName
    );

VOID
NtfsInsertHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb,
    IN ULONG NameLength,
    IN ULONG HashValue
    );

VOID
NtfsRemoveHashEntry (
    IN PNTFS_HASH_TABLE Table,
    IN PLCB HashLcb
    );

//
//  VOID
//  NtfsRemoveHashEntriesForLcb (
//      IN PLCB Lcb
//      );
//

#define NtfsRemoveHashEntriesForLcb(L) {                            \
    if (FlagOn( (L)->LcbState, LCB_STATE_VALID_HASH_VALUE )) {      \
        NtfsRemoveHashEntry( &(L)->Fcb->Vcb->HashTable,             \
                             (L) );                                 \
    }                                                               \
}


//
//  Ntfs Logging Routine interfaces in LogSup.c
//

LSN
NtfsWriteLog (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PBCB Bcb OPTIONAL,
    IN NTFS_LOG_OPERATION RedoOperation,
    IN PVOID RedoBuffer OPTIONAL,
    IN ULONG RedoLength,
    IN NTFS_LOG_OPERATION UndoOperation,
    IN PVOID UndoBuffer OPTIONAL,
    IN ULONG UndoLength,
    IN LONGLONG StreamOffset,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN ULONG StructureSize
    );

VOID
NtfsCheckpointVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OwnsCheckpoint,
    IN BOOLEAN CleanVolume,
    IN BOOLEAN FlushVolume,
    IN ULONG LfsFlags,
    IN LSN LastKnownLsn
    );

VOID
NtfsCheckpointForLogFileFull (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NtfsCheckpointForVolumeSnapshot (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsCleanCheckpoint (
    IN PVCB Vcb
    );

VOID
NtfsCommitCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsCheckpointCurrentTransaction (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsInitializeLogging (
    );

VOID
NtfsStartLogFile (
    IN PSCB LogFileScb,
    IN PVCB Vcb
    );

VOID
NtfsStopLogFile (
    IN PVCB Vcb
    );

VOID
NtfsInitializeRestartTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    );

VOID
InitializeNewTable (
    IN ULONG EntrySize,
    IN ULONG NumberEntries,
    OUT PRESTART_POINTERS TablePointer
    );

VOID
NtfsFreeRestartTable (
    IN PRESTART_POINTERS TablePointer
    );

VOID
NtfsExtendRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG NumberNewEntries,
    IN ULONG FreeGoal
    );

ULONG
NtfsAllocateRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Exclusive
    );

PVOID
NtfsAllocateRestartTableFromIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    );

VOID
NtfsFreeRestartTableIndex (
    IN PRESTART_POINTERS TablePointer,
    IN ULONG Index
    );

PVOID
NtfsGetFirstRestartTable (
    IN PRESTART_POINTERS TablePointer
    );

PVOID
NtfsGetNextRestartTable (
    IN PRESTART_POINTERS TablePointer,
    IN PVOID Current
    );

VOID
NtfsUpdateOatVersion (
    IN PVCB Vcb,
    IN ULONG NewRestartVersion
    );

VOID
NtfsFreeRecentlyDeallocated (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLSN BaseLsn,
    IN ULONG CleanVolume
    );

//
//
//  VOID
//  NtfsFreeOpenAttributeData (
//  IN POPEN_ATTRIBUTE_DATA Entry
//  );
//

#define NtfsFreeOpenAttributeData(E) {  \
    RemoveEntryList( &(E)->Links );     \
    NtfsFreePool( E );                  \
}

VOID
NtfsFreeAttributeEntry (
    IN PVCB Vcb,
    IN POPEN_ATTRIBUTE_ENTRY AttributeEntry
    );

//
//      VOID
//      NtfsNormalizeAndCleanupTransaction (
//          IN PIRP_CONTEXT IrpContext,
//          IN NTSTATUS *Status,
//          IN BOOLEAN AlwaysRaise,
//          IN NTSTATUS NormalizeStatus
//          );
//

#define NtfsNormalizeAndCleanupTransaction(IC,PSTAT,RAISE,NORM_STAT) {                  \
    if (!NT_SUCCESS( (IC)->TopLevelIrpContext->ExceptionStatus )) {                     \
        NtfsRaiseStatus( (IC), (IC)->TopLevelIrpContext->ExceptionStatus, NULL, NULL ); \
    } else if (!NT_SUCCESS( *(PSTAT) )) {                                               \
        *(PSTAT) = FsRtlNormalizeNtstatus( *(PSTAT), (NORM_STAT) );                     \
        if ((RAISE) || ((IC)->TopLevelIrpContext->TransactionId != 0)) {                \
            NtfsRaiseStatus( (IC), *(PSTAT), NULL, NULL );                              \
        }                                                                               \
    }                                                                                   \
}

//
//      VOID
//      NtfsCleanupTransaction (
//          IN PIRP_CONTEXT IrpContext,
//          IN NTSTATUS Status,
//          IN BOOLEAN AlwaysRaise
//          );
//


#define NtfsCleanupTransaction(IC,STAT,RAISE) {                                         \
    if (!NT_SUCCESS( (IC)->TopLevelIrpContext->ExceptionStatus )) {                     \
        NtfsRaiseStatus( (IC), (IC)->TopLevelIrpContext->ExceptionStatus, NULL, NULL ); \
    } else if (!NT_SUCCESS( STAT ) &&                                                   \
              ((RAISE) || ((IC)->TopLevelIrpContext->TransactionId != 0))) {            \
        NtfsRaiseStatus( (IC), (STAT), NULL, NULL );                                    \
    } else if (((IC)->Usn.NewReasons != 0) || ((IC)->Usn.RemovedSourceInfo != 0)) {     \
        NtfsWriteUsnJournalChanges( (IC) );                                             \
        NtfsCommitCurrentTransaction( (IC) );                                           \
    }                                                                                   \
}

//
//      VOID
//      NtfsCleanupTransactionAndCommit (
//          IN PIRP_CONTEXT IrpContext,
//          IN NTSTATUS Status,
//          IN BOOLEAN AlwaysRaise
//          );
//

#define NtfsCleanupTransactionAndCommit(IC,STAT,RAISE) {                                \
    if (!NT_SUCCESS( (IC)->TopLevelIrpContext->ExceptionStatus )) {                     \
        NtfsRaiseStatus( (IC), (IC)->TopLevelIrpContext->ExceptionStatus, NULL, NULL ); \
    } else if (!NT_SUCCESS( STAT ) &&                                                   \
              ((RAISE) || ((IC)->TopLevelIrpContext->TransactionId != 0))) {            \
        NtfsRaiseStatus( (IC), (STAT), NULL, NULL );                                    \
    } else if (((IC)->Usn.NewReasons != 0) || ((IC)->Usn.RemovedSourceInfo != 0)) {     \
        NtfsWriteUsnJournalChanges( (IC) );                                             \
        NtfsCheckpointCurrentTransaction( (IC) );                                           \
    } else {                                                                            \
        NtfsCheckpointCurrentTransaction( (IC) );                                           \
    }                                                                                   \
}

VOID
NtfsCleanupFailedTransaction (
    IN PIRP_CONTEXT IrpContext
    );


//
//  NTFS MCB support routine, implemented in McbSup.c
//

//
//  An Ntfs Mcb is a superset of the regular mcb package.  In
//  addition to the regular Mcb functions it will unload mapping
//  information to keep it overall memory usage down
//

VOID
NtfsInitializeNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN PNTFS_ADVANCED_FCB_HEADER FcbHeader,
    IN PNTFS_MCB_INITIAL_STRUCTS McbStructs,
    IN POOL_TYPE PoolType
    );

VOID
NtfsUninitializeNtfsMcb (
    IN PNTFS_MCB Mcb
    );

VOID
NtfsRemoveNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Count
    );

VOID
NtfsUnloadNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN TruncateOnly,
    IN BOOLEAN AlreadySynchronized
    );

ULONG
NtfsNumberOfRangesInNtfsMcb (
    IN PNTFS_MCB Mcb
    );

BOOLEAN
NtfsNumberOfRunsInRange(
    IN PNTFS_MCB Mcb,
    IN PVOID RangePtr,
    OUT PULONG NumberOfRuns
    );

BOOLEAN
NtfsLookupLastNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn
    );

ULONG
NtfsMcbLookupArrayIndex (
    IN PNTFS_MCB Mcb,
    IN VCN Vcn
    );

BOOLEAN
NtfsSplitNtfsMcb (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Amount
    );

BOOLEAN
NtfsAddNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    IN LONGLONG Lcn,
    IN LONGLONG RunCount,
    IN BOOLEAN AlreadySynchronized
    );

BOOLEAN
NtfsLookupNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN LONGLONG Vcn,
    OUT PLONGLONG Lcn OPTIONAL,
    OUT PLONGLONG CountFromLcn OPTIONAL,
    OUT PLONGLONG StartingLcn OPTIONAL,
    OUT PLONGLONG CountFromStartingLcn OPTIONAL,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    );

BOOLEAN
NtfsGetNextNtfsMcbEntry (
    IN PNTFS_MCB Mcb,
    IN PVOID *RangePtr,
    IN ULONG RunIndex,
    OUT PLONGLONG Vcn,
    OUT PLONGLONG Lcn,
    OUT PLONGLONG Count
    );

//
//  BOOLEAN
//  NtfsGetSequentialMcbEntry (
//      IN PNTFS_MCB Mcb,
//      IN PVOID *RangePtr,
//      IN ULONG RunIndex,
//      OUT PLONGLONG Vcn,
//      OUT PLONGLONG Lcn,
//      OUT PLONGLONG Count
//      );
//

#define NtfsGetSequentialMcbEntry(MC,RGI,RNI,V,L,C) (   \
    NtfsGetNextNtfsMcbEntry(MC,RGI,RNI,V,L,C) ||        \
    (RNI = 0) ||                                        \
    NtfsGetNextNtfsMcbEntry(MC,RGI,MAXULONG,V,L,C) ||   \
    ((RNI = MAXULONG) == 0)                             \
    )


VOID
NtfsDefineNtfsMcbRange (
    IN PNTFS_MCB Mcb,
    IN LONGLONG StartingVcn,
    IN LONGLONG EndingVcn,
    IN BOOLEAN AlreadySynchronized
    );

VOID
NtfsSwapMcbs (
    IN PNTFS_MCB McbTarget,
    IN PNTFS_MCB McbSource
    );

//
//  VOID
//  NtfsAcquireNtfsMcbMutex (
//      IN PNTFS_MCB Mcb
//      );
//
//  VOID
//  NtfsReleaseNtfsMcbMutex (
//      IN PNTFS_MCB Mcb
//      );
//

#define NtfsAcquireNtfsMcbMutex(M) {    \
    ExAcquireFastMutex((M)->FastMutex); \
}

#define NtfsReleaseNtfsMcbMutex(M) {    \
    ExReleaseFastMutex((M)->FastMutex); \
}


//
//  MFT access routines, implemented in MftSup.c
//

//
//  Mft map cache routines.  We maintain a cache of active maps in the
//  IRP_CONTEXT and consult this if we need to map a file record.
//

INLINE
PIRP_FILE_RECORD_CACHE_ENTRY
NtfsFindFileRecordCacheEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber
    )
{
#if (IRP_FILE_RECORD_MAP_CACHE_SIZE <= 4)
#define PROBECACHE(ic,sn,i)                                     \
    ASSERT((ic)->FileRecordCache[(i)].FileRecordBcb != NULL);   \
    if ((ic)->FileRecordCache[(i)].UnsafeSegmentNumber == (sn)) \
    {                                                           \
        return IrpContext->FileRecordCache + (i);               \
    }

//    DebugTrace( 0, 0, ("Context %08x finding %x\n", IrpContext, UnsafeSegmentNumber ));
    ASSERT(IrpContext->CacheCount <= 4);
    switch (IrpContext->CacheCount) {
    case 4:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 3 );
        //  Fallthru

    case 3:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 2 );
        //  Fallthru

    case 2:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 1 );
        //  Fallthru

    case 1:
        PROBECACHE( IrpContext, UnsafeSegmentNumber, 0 );
        //  Fallthru

    case 0:

        //
        // redundant default case (and matching assert above) added to quiet
        // warning 4715:
        //
        //  "not all control paths return a value."
        //

    default:
        return NULL;
    }
#else
    PIRP_FILE_RECORD_CACHE_ENTRY Entry;

    for (Entry = IrpContext->FileRecordCache;
         Entry < IrpContext->FileRecordCache + IrpContext->CacheCount;
         Entry++) {
        ASSERT( Entry->FileRecordBcb != NULL);
        if (Entry->UnsafeSegmentNumber == UnsafeSegmentNumber) {
            return Entry;
        }
    }

    return NULL;

#endif
}


INLINE
VOID
NtfsRemoveFromFileRecordCache (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber
    )
{
    PIRP_FILE_RECORD_CACHE_ENTRY Entry =
        NtfsFindFileRecordCacheEntry( IrpContext, UnsafeSegmentNumber );

//    DebugTrace( 0, 0, ("Context %08x removing %x\n", IrpContext, Entry ));
    if (Entry != NULL) {

        ASSERT( Entry->FileRecordBcb != NULL );

        //
        //  We delete the entry at position [i] by dereferencing the Bcb and
        //  copying the entire structure from [IrpContext->CacheCount]
        //

        NtfsUnpinBcb( IrpContext, &Entry->FileRecordBcb );

        //
        //  Decrement the active count.  If there are no more cache entries,
        //  then we're done.
        //

        IrpContext->CacheCount--;
        if (IrpContext->FileRecordCache + IrpContext->CacheCount != Entry) {
            *Entry = IrpContext->FileRecordCache[IrpContext->CacheCount];
        }
    }
}

#ifndef KDEXT

INLINE
VOID
NtfsAddToFileRecordCache (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber,
    IN PBCB FileRecordBcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    )
{
    PAGED_CODE( );

    if (IrpContext->CacheCount < IRP_FILE_RECORD_MAP_CACHE_SIZE) {
//        DebugTrace( 0, 0, ("Context %08x adding %x at %x\n", IrpContext, UnsafeSegmentNumber,
//                   IrpContext->FileRecordCache + IrpContext->CacheCount ));
        IrpContext->FileRecordCache[IrpContext->CacheCount].UnsafeSegmentNumber =
            UnsafeSegmentNumber;
        IrpContext->FileRecordCache[IrpContext->CacheCount].FileRecordBcb =
            NtfsRemapBcb( IrpContext, FileRecordBcb );
        IrpContext->FileRecordCache[IrpContext->CacheCount].FileRecord = FileRecord;
        IrpContext->CacheCount++;
    }
}

#endif

INLINE
VOID
NtfsPurgeFileRecordCache (
    IN PIRP_CONTEXT IrpContext
    )
{
    while (IrpContext->CacheCount) {

        IrpContext->CacheCount --;
//        DebugTrace( 0, 0, ("Context %08x purging %x\n", IrpContext, IrpContext->FileRecordCache + IrpContext->CacheCount ));
        NtfsUnpinBcb( IrpContext, &IrpContext->FileRecordCache[IrpContext->CacheCount].FileRecordBcb );
    }
}

#if DBG
extern ULONG FileRecordCacheHitArray[IRP_FILE_RECORD_MAP_CACHE_SIZE];
#endif  //  DBG

INLINE
BOOLEAN
NtfsFindCachedFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG UnsafeSegmentNumber,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord
    )
{
    PIRP_FILE_RECORD_CACHE_ENTRY Entry =
        NtfsFindFileRecordCacheEntry( IrpContext, UnsafeSegmentNumber );

//    DebugTrace( 0, 0, ("Context %x finding %x = %x\n", IrpContext, UnsafeSegmentNumber, Entry ));

    if (Entry == NULL) {

        return FALSE;

    }

    *Bcb = NtfsRemapBcb( IrpContext, Entry->FileRecordBcb );
    *FileRecord = Entry->FileRecord;

     return TRUE;
}


//
//  This routine may only be used to read the Base file record segment, and
//  it checks that this is true.
//

VOID
NtfsReadFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *BaseFileRecord,
    OUT PATTRIBUTE_RECORD_HEADER *FirstAttribute,
    OUT PLONGLONG MftFileOffset OPTIONAL
    );

//
//  These routines can read/pin any record in the MFT.
//

VOID
NtfsReadMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN CheckRecord,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    );

VOID
NtfsPinMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PMFT_SEGMENT_REFERENCE SegmentReference,
    IN BOOLEAN PreparingToWrite,
    OUT PBCB *Bcb,
    OUT PFILE_RECORD_SEGMENT_HEADER *FileRecord,
    OUT PLONGLONG MftFileOffset OPTIONAL
    );

//
//  The following routines are used to setup, allocate, and deallocate
//  file records in the Mft.
//

MFT_SEGMENT_REFERENCE
NtfsAllocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN MftData
    );

VOID
NtfsInitializeMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PMFT_SEGMENT_REFERENCE MftSegment,
    IN OUT PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB Bcb,
    IN BOOLEAN Directory
    );

VOID
NtfsDeallocateMftRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FileNumber
    );

BOOLEAN
NtfsIsMftIndexInHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index,
    OUT PULONG HoleLength OPTIONAL
    );

VOID
NtfsFillMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Index
    );

VOID
NtfsLogMftFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN LONGLONG MftOffset,
    IN PBCB FileRecordBcb,
    IN BOOLEAN RedoOperation
    );

BOOLEAN
NtfsDefragMft (
    IN PDEFRAG_MFT DefragMft
    );

VOID
NtfsCheckForDefrag (
    IN OUT PVCB Vcb
    );

VOID
NtfsInitializeMftHoleRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FirstIndex,
    IN ULONG RecordCount
    );


//
//  Name support routines, implemented in NameSup.c
//

typedef enum _PARSE_TERMINATION_REASON {

    EndOfPathReached,
    NonSimpleName,
    IllegalCharacterInName,
    MalFormedName,
    AttributeOnly,
    VersionNumberPresent

} PARSE_TERMINATION_REASON;


INLINE
NTSTATUS
NtfsDissectName(
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    )
{
    FsRtlDissectName( Path, FirstName, RemainingName );

    //
    //  Remaining name cannot start with a slash
    //

    if ((RemainingName->Length != 0) && (RemainingName->Buffer[0] == L'\\')) {
        return STATUS_OBJECT_NAME_INVALID;
    } else {
        return STATUS_SUCCESS;
    }
}

BOOLEAN
NtfsParseName (
    IN const UNICODE_STRING Name,
    IN BOOLEAN WildCardsPermissible,
    OUT PBOOLEAN FoundIllegalCharacter,
    OUT PNTFS_NAME_DESCRIPTOR ParsedName
    );

PARSE_TERMINATION_REASON
NtfsParsePath (
    IN UNICODE_STRING Path,
    IN BOOLEAN WildCardsPermissible,
    OUT PUNICODE_STRING FirstPart,
    OUT PNTFS_NAME_DESCRIPTOR Name,
    OUT PUNICODE_STRING RemainingPart
    );

VOID
NtfsPreprocessName (
    IN UNICODE_STRING InputString,
    OUT PUNICODE_STRING FirstPart,
    OUT PUNICODE_STRING AttributeCode,
    OUT PUNICODE_STRING AttributeName,
    OUT PBOOLEAN TrailingBackslash
    );

VOID
NtfsUpcaseName (
    IN PWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN OUT PUNICODE_STRING InputString
    );

FSRTL_COMPARISON_RESULT
NtfsCollateNames (
    IN PCWCH UpcaseTable,
    IN ULONG UpcaseTableSize,
    IN PCUNICODE_STRING Expression,
    IN PCUNICODE_STRING Name,
    IN FSRTL_COMPARISON_RESULT WildIs,
    IN BOOLEAN IgnoreCase
    );

#define NtfsIsNameInExpression(UC,EX,NM,IC)         \
    FsRtlIsNameInExpression( (EX), (NM), (IC), (UC) )

BOOLEAN
NtfsIsFileNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    );

BOOLEAN
NtfsIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    );

//
//  Ntfs works very hard to make sure that all names are kept in upper case
//  so that most comparisons are done case SENSITIVE.  Name testing for
//  case SENSITIVE can be very quick since RtlEqualMemory is an inline operation
//  on several processors.
//
//  NtfsAreNamesEqual is used when the caller does not know for sure whether
//  or not case is important.  In the case where IgnoreCase is a known value,
//  the compiler can easily optimize the relevant clause.
//

#define NtfsAreNamesEqual(UpcaseTable,Name1,Name2,IgnoreCase)                           \
    ((IgnoreCase) ? FsRtlAreNamesEqual( (Name1), (Name2), (IgnoreCase), (UpcaseTable) ) \
                  : ((Name1)->Length == (Name2)->Length &&                              \
                     RtlEqualMemory( (Name1)->Buffer, (Name2)->Buffer, (Name1)->Length )))


//
//  Object id support routines, implemented in ObjIdSup.c
//

VOID
NtfsInitializeObjectIdIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    );

NTSTATUS
NtfsSetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsSetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

NTSTATUS
NtfsCreateOrGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsGetObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN GetExtendedInfo,
    OUT FILE_OBJECTID_BUFFER *OutputBuffer
    );

NTSTATUS
NtfsGetObjectIdExtendedInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR *ObjectId,
    IN OUT UCHAR *ExtendedInfo
    );

NTSTATUS
NtfsDeleteObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeleteObjectIdInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb,
    IN BOOLEAN DeleteFileAttribute
    );

VOID
NtfsRepairObjectId (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );


//
//  Mount point support routines, implemented in MountSup.c
//

VOID
NtfsInitializeReparsePointIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    );

NTSTATUS
NtfsValidateReparsePointBuffer (
    IN ULONG BufferLength,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    );


//
//  Largest matching prefix searching routines, implemented in PrefxSup.c
//

VOID
NtfsInsertPrefix (
    IN PLCB Lcb,
    IN ULONG CreateFlags
    );

VOID
NtfsRemovePrefix (
    IN PLCB Lcb
    );

PLCB
NtfsFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB StartingScb,
    OUT PFCB *CurrentFcb,
    OUT PLCB *LcbForTeardown,
    IN OUT UNICODE_STRING FullFileName,
    IN OUT PULONG CreateFlags,
    OUT PUNICODE_STRING RemainingName
    );

BOOLEAN
NtfsInsertNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    );

//
//  VOID
//  NtfsRemoveNameLink (
//      IN PRTL_SPLAY_LINKS *RootNode,
//      IN PNAME_LINK NameLink
//      );
//

#define NtfsRemoveNameLink(RN,NL) {      \
    *(RN) = RtlDelete( &(NL)->Links );      \
}

PNAME_LINK
NtfsFindNameLink (
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    );

//
//  The following macro is useful for traversing the queue of Prefixes
//  attached to a given Lcb
//
//      PPREFIX_ENTRY
//      NtfsGetNextPrefix (
//          IN PIRP_CONTEXT IrpContext,
//          IN PLCB Lcb,
//          IN PPREFIX_ENTRY PreviousPrefixEntry
//          );
//

#define NtfsGetNextPrefix(IC,LC,PPE) ((PPREFIX_ENTRY)                                               \
    ((PPE) == NULL ?                                                                                \
        (IsListEmpty(&(LC)->PrefixQueue) ?                                                          \
            NULL                                                                                    \
        :                                                                                           \
            CONTAINING_RECORD((LC)->PrefixQueue.Flink, PREFIX_ENTRY, LcbLinks.Flink)                \
        )                                                                                           \
    :                                                                                               \
        ((PVOID)((PPREFIX_ENTRY)(PPE))->LcbLinks.Flink == &(LC)->PrefixQueue.Flink ?                \
            NULL                                                                                    \
        :                                                                                           \
            CONTAINING_RECORD(((PPREFIX_ENTRY)(PPE))->LcbLinks.Flink, PREFIX_ENTRY, LcbLinks.Flink) \
        )                                                                                           \
    )                                                                                               \
)


//
//  Resources support routines/macros, implemented in ResrcSup.c
//

//
//  Flags used in the acquire routines
//

#define ACQUIRE_NO_DELETE_CHECK         (0x00000001)
#define ACQUIRE_DONT_WAIT               (0x00000002)
#define ACQUIRE_HOLD_BITMAP             (0x00000004)
#define ACQUIRE_WAIT                    (0x00000008)

//
//  VOID
//  NtfsAcquireExclusiveGlobal (
//      IN PIRP_CONTEXT IrpContext,
//      IN BOOLEAN Wait
//      );
//
//  BOOLEAN
//  NtfsAcquireSharedGlobal (
//      IN PIRP_CONTEXT IrpContext,
//      IN BOOLEAN Wait
//      );
//


#define NtfsAcquireSharedGlobal( I, W ) ExAcquireResourceSharedLite( &NtfsData.Resource, (W) )

#define NtfsAcquireExclusiveGlobal( I, W ) ExAcquireResourceExclusiveLite( &NtfsData.Resource, (W) )

VOID
NtfsAcquireCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsReleaseCheckpointSynchronization (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  VOID
//  NtfsLockNtfsData (
//      );
//
//  VOID
//  NtfsUnlockNtfsData (
//      );
//

#define NtfsLockNtfsData() {                        \
    ExAcquireFastMutex( &NtfsData.NtfsDataLock );   \
}

#define NtfsUnlockNtfsData() {                      \
    ExReleaseFastMutex( &NtfsData.NtfsDataLock );   \
}

VOID
NtfsAcquireAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Exclusive,
    IN ULONG AcquirePagingIo,
    IN ULONG AcquireAndDrop
    );

VOID
NtfsReleaseAllFiles (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN ReleasePagingIo
    );

BOOLEAN
NtfsAcquireExclusiveVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    );

BOOLEAN
NtfsAcquireSharedVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN RaiseOnCantWait
    );

#define NtfsAcquireExclusivePagingIo(IC,FCB) {                          \
    ASSERT((IC)->CleanupStructure == NULL);                             \
    NtfsAcquirePagingResourceExclusive( IC, FCB, TRUE );                \
    (IC)->CleanupStructure = (FCB);                                     \
}

#define NtfsReleasePagingIo(IC,FCB) {                                   \
    ASSERT((IC)->CleanupStructure == (FCB));                            \
    NtfsReleasePagingResource( IC, FCB );                               \
    (IC)->CleanupStructure = NULL;                                      \
}

BOOLEAN
NtfsAcquireFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    );

VOID
NtfsReleaseFcbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsReleaseScbWithPaging (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

BOOLEAN
NtfsAcquireExclusiveFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    );

VOID
NtfsAcquireSharedFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb OPTIONAL,
    IN ULONG AcquireFlags
    );

BOOLEAN
NtfsAcquireSharedFcbCheckWait (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG AcquireFlags
    );

VOID
NtfsReleaseFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsAcquireExclusiveScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

#ifdef NTFSDBG

BOOLEAN
NtfsAcquireResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    );

#else

INLINE
BOOLEAN
NtfsAcquireResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )
{
    BOOLEAN Result;

    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Result = ExAcquireResourceExclusiveLite( ((PFCB)FcbOrScb)->Resource, Wait );
    } else {
        Result = ExAcquireResourceExclusiveLite( ((PSCB)(FcbOrScb))->Header.Resource, Wait );
    }
    return Result;
}

#endif

INLINE
BOOLEAN
NtfsAcquirePagingResourceExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )
{
    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        return ExAcquireResourceExclusive( ((PFCB)FcbOrScb)->PagingIoResource, Wait );
    } else {
        return ExAcquireResourceExclusive( ((PSCB)(FcbOrScb))->Header.PagingIoResource, Wait );
    }
}

INLINE
BOOLEAN
NtfsAcquirePagingResourceSharedWaitForExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )
{
    BOOLEAN Result;

    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Result = ExAcquireSharedWaitForExclusive( ((PFCB)FcbOrScb)->PagingIoResource, Wait );
    } else {
        Result = ExAcquireSharedWaitForExclusive( ((PSCB)(FcbOrScb))->Header.PagingIoResource, Wait );
    }
    return Result;
}

INLINE
BOOLEAN
NtfsAcquirePagingResourceSharedStarveExclusive (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb,
    IN BOOLEAN Wait
    )
{
    BOOLEAN Result;

    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Result = ExAcquireSharedStarveExclusive( ((PFCB)FcbOrScb)->PagingIoResource, Wait );
    } else {
        Result = ExAcquireSharedStarveExclusive( ((PSCB)(FcbOrScb))->Header.PagingIoResource, Wait );
    }
    return Result;
}

#ifdef NTFSDBG

BOOLEAN
NtfsAcquireResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   );


BOOLEAN
NtfsAcquireResourceSharedWaitForEx (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   );

#else

INLINE
BOOLEAN
NtfsAcquireResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )
{
    PFCB Fcb;

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {

        Fcb = (PFCB)FcbOrScb;

    } else {

        ASSERT_SCB( FcbOrScb );

        Fcb = ((PSCB)FcbOrScb)->Fcb;
    }

    return ExAcquireResourceSharedLite( Fcb->Resource, Wait );

    UNREFERENCED_PARAMETER( IrpContext );
}

INLINE
BOOLEAN
NtfsAcquireResourceSharedWaitForEx (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )
{
    PFCB Fcb;

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {

        Fcb = (PFCB)FcbOrScb;

    } else {

        ASSERT_SCB( FcbOrScb );

        Fcb = ((PSCB)FcbOrScb)->Fcb;

        ASSERT( ((PSCB)FcbOrScb)->Header.Resource == Fcb->Resource );
    }

    return ExAcquireSharedWaitForExclusive( Fcb->Resource, Wait );

    UNREFERENCED_PARAMETER( IrpContext );
}

#endif

INLINE
BOOLEAN
NtfsAcquirePagingResourceShared (
   IN PIRP_CONTEXT IrpContext OPTIONAL,
   IN PVOID FcbOrScb,
   IN BOOLEAN Wait
   )
{
    BOOLEAN Result;

    UNREFERENCED_PARAMETER( IrpContext );

    if (NTFS_NTC_FCB == ((PFCB)FcbOrScb)->NodeTypeCode) {
        Result =  ExAcquireResourceShared( ((PFCB)FcbOrScb)->PagingIoResource, Wait );
    } else {

        ASSERT_SCB( FcbOrScb );

        Result = ExAcquireResourceShared( ((PSCB)(FcbOrScb))->Header.PagingIoResource, Wait );
    }

    return Result;
}


//
//  VOID
//  NtfsReleaseResource(
//      IN PIRP_CONTEXT IrpContext OPTIONAL,
//      IN PVOID FcbOrScb
//      };
//

#ifdef NTFSDBG

VOID
NtfsReleaseResource (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PVOID FcbOrScb
    );

#else

#define NtfsReleaseResource( IC, F ) {                                        \
        if (NTFS_NTC_FCB == ((PFCB)(F))->NodeTypeCode) {                      \
            ExReleaseResourceLite( ((PFCB)(F))->Resource );                       \
        } else {                                                              \
            ExReleaseResourceLite( ((PSCB)(F))->Header.Resource );                \
        }                                                                     \
    }

#endif

#define NtfsReleasePagingResource( IC, F ) {                                  \
        if (NTFS_NTC_FCB == ((PFCB)(F))->NodeTypeCode) {                      \
            ExReleaseResource( ((PFCB)(F))->PagingIoResource );               \
        } else {                                                              \
            ExReleaseResource( ((PSCB)(F))->Header.PagingIoResource );        \
        }                                                                      \
    }

VOID
NtfsAcquireSharedScbForTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NtfsReleaseSharedResources (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsReleaseAllResources (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsAcquireIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb,
    IN PEOF_WAIT_BLOCK EofWaitBlock
    );

VOID
NtfsReleaseIndexCcb (
    IN PSCB Scb,
    IN PCCB Ccb
    );

//
//  VOID
//  NtfsAcquireSharedScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsReleaseScb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsReleaseGlobal (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  NtfsAcquireFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      );
//
//  VOID
//  NtfsReleaseFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsLockVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsUnlockVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsLockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  NtfsUnlockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  NtfsAcquireFcbSecurity (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      );
//
//  VOID
//  NtfsReleaseFcbSecurity (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireHashTable (
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsReleaseHashTable (
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireCheckpoint (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      );
//
//  VOID
//  NtfsReleaseCheckpoint (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsWaitOnCheckpointNotify (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsSetCheckpointNotify (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsResetCheckpointNotify (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireReservedClusters (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsReleaseReservedClusters (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsAcquireUsnNotify (
//      IN PVCB Vcb
//      );
//
//  VOID
//  NtfsDeleteUsnNotify (
//      IN PVCB Vcb
//      );
//
//  VOID NtfsAcquireFsrtlHeader (
//      IN PSCB Scb
//      );
//
//  VOID NtfsReleaseFsrtlHeader (
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//

VOID
NtfsReleaseVcbCheckDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR MajorCode,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

#define NtfsAcquireSharedScb(IC,S) {                \
    NtfsAcquireSharedFcb((IC),(S)->Fcb, S, 0);      \
}

#define NtfsAcquireSharedScbWaitForEx(IC,S)                  \
    NtfsAcquireResourceSharedWaitForEx( IC, S, BooleanFlagOn( (IC)->State, IRP_CONTEXT_STATE_WAIT ) )


#define NtfsReleaseScb(IC,S) {     \
    NtfsReleaseFcb((IC),(S)->Fcb); \
}

#define NtfsReleaseGlobal(IC) {              \
    ExReleaseResourceLite( &NtfsData.Resource ); \
}

#define NtfsAcquireFcbTable(IC,V) {                         \
    ExAcquireFastMutexUnsafe( &(V)->FcbTableMutex );        \
}

#define NtfsReleaseFcbTable(IC,V) {                         \
    ExReleaseFastMutexUnsafe( &(V)->FcbTableMutex );        \
}

#define NtfsLockVcb(IC,V) {                                 \
    ExAcquireFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsUnlockVcb(IC,V) {                               \
    ExReleaseFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsLockFcb(IC,F) {                                 \
    ExAcquireFastMutex( (F)->FcbMutex );                    \
}

#define NtfsUnlockFcb(IC,F) {                               \
    ExReleaseFastMutex( (F)->FcbMutex );                    \
}

#define NtfsAcquireFcbSecurity(V) {                         \
    ExAcquireFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsReleaseFcbSecurity(V) {                         \
    ExReleaseFastMutexUnsafe( &(V)->FcbSecurityMutex );     \
}

#define NtfsAcquireHashTable(V) {                           \
    ExAcquireFastMutexUnsafe( &(V)->HashTableMutex );       \
}

#define NtfsReleaseHashTable(V) {                           \
    ExReleaseFastMutexUnsafe( &(V)->HashTableMutex );       \
}

#define NtfsAcquireCheckpoint(IC,V) {                       \
    ExAcquireFastMutexUnsafe( &(V)->CheckpointMutex );      \
}

#define NtfsReleaseCheckpoint(IC,V) {                       \
    ExReleaseFastMutexUnsafe( &(V)->CheckpointMutex );      \
}

#define NtfsWaitOnCheckpointNotify(IC,V) {                          \
    NTSTATUS _Status;                                               \
    _Status = KeWaitForSingleObject( &(V)->CheckpointNotifyEvent,   \
                                     Executive,                     \
                                     KernelMode,                    \
                                     FALSE,                         \
                                     NULL );                        \
    if (!NT_SUCCESS( _Status )) {                                   \
        NtfsRaiseStatus( IrpContext, _Status, NULL, NULL );         \
    }                                                               \
}

#define NtfsSetCheckpointNotify(IC,V) {                             \
    (V)->CheckpointOwnerThread = NULL;                              \
    KeSetEvent( &(V)->CheckpointNotifyEvent, 0, FALSE );            \
}

#define NtfsResetCheckpointNotify(IC,V) {                           \
    (V)->CheckpointOwnerThread = (PVOID) PsGetCurrentThread();      \
    KeClearEvent( &(V)->CheckpointNotifyEvent );                    \
}

#define NtfsAcquireUsnNotify(V) {                           \
    ExAcquireFastMutex( &(V)->CheckpointMutex );            \
}

#define NtfsReleaseUsnNotify(V) {                           \
    ExReleaseFastMutex( &(V)->CheckpointMutex );            \
}

#define NtfsAcquireReservedClusters(V) {                    \
    ExAcquireFastMutexUnsafe( &(V)->ReservedClustersMutex );\
}

#define NtfsReleaseReservedClusters(V) {                    \
    ExReleaseFastMutexUnsafe( &(V)->ReservedClustersMutex );\
}

#define NtfsAcquireFsrtlHeader(S) {                         \
    ExAcquireFastMutex((S)->Header.FastMutex);              \
}

#define NtfsReleaseFsrtlHeader(S) {                         \
    ExReleaseFastMutex((S)->Header.FastMutex);              \
}

#ifdef NTFSDBG

VOID NtfsReleaseVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

#else

#define NtfsReleaseVcb(IC,V) {                              \
    ExReleaseResourceLite( &(V)->Resource );                    \
}

#endif

//
//  Macros to test resources for exclusivity.
//

#define NtfsIsExclusiveResource(R) (                            \
    ExIsResourceAcquiredExclusiveLite(R)                        \
)

#define NtfsIsExclusiveFcb(F) (                                 \
    (NtfsIsExclusiveResource((F)->Resource))                    \
)

#define NtfsIsExclusiveFcbPagingIo(F) (                         \
    (NtfsIsExclusiveResource((F)->PagingIoResource))            \
)

#define NtfsIsExclusiveScbPagingIo(S) (                         \
    (NtfsIsExclusiveFcbPagingIo((S)->Fcb))                      \
)

#define NtfsIsExclusiveScb(S) (                                 \
    (NtfsIsExclusiveFcb((S)->Fcb))                              \
)

#define NtfsIsExclusiveVcb(V) (                                 \
    (NtfsIsExclusiveResource(&(V)->Resource))                   \
)

//
//  Macros to test resources for shared acquire
//

#define NtfsIsSharedResource(R) (                               \
    ExIsResourceAcquiredSharedLite(R)                           \
)

#define NtfsIsSharedFcb(F) (                                    \
    (NtfsIsSharedResource((F)->Resource))                       \
)

#define NtfsIsSharedFcbPagingIo(F) (                            \
    (NtfsIsSharedResource((F)->PagingIoResource))               \
)

#define NtfsIsSharedScbPagingIo(S) (                            \
    (NtfsIsSharedFcbPagingIo((S)->Fcb))                         \
)

#define NtfsIsSharedScb(S) (                                    \
    (NtfsIsSharedFcb((S)->Fcb))                                 \
)

#define NtfsIsSharedVcb(V) (                                    \
    (NtfsIsSharedResource(&(V)->Resource))                      \
)

__inline
VOID
NtfsReleaseExclusiveScbIfOwned(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )
/*++

Routine Description:

    This routine is called release an Scb that may or may not be currently
    owned exclusive.

Arguments:

    IrpContext - Context of call

    Scb - Scb to be released

Return Value:

    None.

--*/
{
    if (Scb->Fcb->ExclusiveFcbLinks.Flink != NULL &&
        NtfsIsExclusiveScb( Scb )) {

        NtfsReleaseScb( IrpContext, Scb );
    }
}

//
//  The following are cache manager call backs.  They return FALSE
//  if the resource cannot be acquired with waiting and wait is false.
//

BOOLEAN
NtfsAcquireScbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
NtfsReleaseScbFromLazyWrite (
    IN PVOID Null
    );

NTSTATUS
NtfsAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
NtfsReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
NtfsAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
NtfsReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    );


BOOLEAN
NtfsAcquireScbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
NtfsReleaseScbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
NtfsAcquireVolumeFileForLazyWrite (
    IN PVOID Vcb,
    IN BOOLEAN Wait
    );

VOID
NtfsReleaseVolumeFileFromLazyWrite (
    IN PVOID Vcb
    );


//
//  Ntfs Logging Routine interfaces in RestrSup.c
//

BOOLEAN
NtfsRestartVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PBOOLEAN UnrecognizedRestart
    );

VOID
NtfsAbortTransaction (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PTRANSACTION_ENTRY Transaction OPTIONAL
    );

NTSTATUS
NtfsCloseAttributesFromRestart (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );


//
//  Security support routines, implemented in SecurSup.c
//

//
//  VOID
//  NtfsTraverseCheck (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB ParentFcb,
//      IN PIRP Irp
//      );
//
//  VOID
//  NtfsOpenCheck (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFCB ParentFcb OPTIONAL,
//      IN PIRP Irp
//      );
//
//  VOID
//  NtfsCreateCheck (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB ParentFcb,
//      IN PIRP Irp
//      );
//

#define NtfsTraverseCheck(IC,F,IR) { \
    NtfsAccessCheck( IC,             \
                     F,              \
                     NULL,           \
                     IR,             \
                     FILE_TRAVERSE,  \
                     TRUE );         \
}

#define NtfsOpenCheck(IC,F,PF,IR) {                                                                      \
    NtfsAccessCheck( IC,                                                                                 \
                     F,                                                                                  \
                     PF,                                                                                 \
                     IR,                                                                                 \
                     IoGetCurrentIrpStackLocation(IR)->Parameters.Create.SecurityContext->DesiredAccess, \
                     FALSE );                                                                            \
}

#define NtfsCreateCheck(IC,PF,IR) {                                                                              \
    NtfsAccessCheck( IC,                                                                                         \
                     PF,                                                                                         \
                     NULL,                                                                                       \
                     IR,                                                                                         \
                     (FlagOn(IoGetCurrentIrpStackLocation(IR)->Parameters.Create.Options, FILE_DIRECTORY_FILE) ? \
                        FILE_ADD_SUBDIRECTORY : FILE_ADD_FILE),                                                  \
                     TRUE );                                                                                     \
}

VOID
NtfsAssignSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PIRP Irp,
    IN PFCB NewFcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PBCB FileRecordBcb,
    IN LONGLONG FileOffset,
    IN OUT PBOOLEAN LogIt
    );

NTSTATUS
NtfsModifySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
NtfsQuerySecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG SecurityDescriptorLength
    );

VOID
NtfsAccessCheck (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PIRP Irp,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN CheckOnly
    );

BOOLEAN
NtfsCanAdministerVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR TestSecurityDescriptor OPTIONAL,
    IN PULONG TestDesiredAccess OPTIONAL
    );

NTSTATUS
NtfsCheckFileForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN FcbExisted,
    IN PINDEX_ENTRY IndexEntry
    );

VOID
NtfsCheckIndexForAddOrDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreatePrivileges
    );

VOID
NtfsSetFcbSecurityFromDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB Fcb,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength,
    IN BOOLEAN RaiseIfInvalid
    );

INLINE
VOID
RemoveReferenceSharedSecurityUnsafe (
    IN OUT PSHARED_SECURITY *SharedSecurity
    )
/*++

Routine Description:

    This routine is called to manage the reference count on a shared security
    descriptor.  If the reference count goes to zero, the shared security is
    freed.

Arguments:

    SharedSecurity - security that is being dereferenced.

Return Value:

    None.

--*/
{
    DebugTrace( 0, (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX),
                ( "RemoveReferenceSharedSecurityUnsafe( %08x )\n", *SharedSecurity ));
    //
    //  Note that there will be one less reference shortly
    //

    ASSERT( (*SharedSecurity)->ReferenceCount != 0 );

    (*SharedSecurity)->ReferenceCount--;

    if ((*SharedSecurity)->ReferenceCount == 0) {
        DebugTrace( 0, (DEBUG_TRACE_SECURSUP | DEBUG_TRACE_ACLINDEX),
                    ( "RemoveReferenceSharedSecurityUnsafe freeing\n" ));
        NtfsFreePool( *SharedSecurity );
    }
    *SharedSecurity = NULL;
}

BOOLEAN
NtfsNotifyTraverseCheck (
    IN PCCB Ccb,
    IN PFCB Fcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );

VOID
NtfsLoadSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsStoreSecurityDescriptor (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN LogIt
    );

VOID
NtfsInitializeSecurity (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
NtOfsPurgeSecurityCache (
    IN PVCB Vcb
    );

PSHARED_SECURITY
NtfsCacheSharedSecurityBySecurityId (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN SECURITY_ID SecurityId
    );

PSHARED_SECURITY
NtfsCacheSharedSecurityForCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb
    );

SECURITY_ID
GetSecurityIdFromSecurityDescriptorUnsafe (
    PIRP_CONTEXT IrpContext,
    IN OUT PSHARED_SECURITY SharedSecurity
    );

FSRTL_COMPARISON_RESULT
NtOfsCollateSecurityHash (
    IN PINDEX_KEY Key1,
    IN PINDEX_KEY Key2,
    IN PVOID CollationData
    );

#ifdef NTFS_CACHE_RIGHTS
VOID
NtfsGetCachedRightsById (
    IN PVCB Vcb,
    IN PLUID TokenId,
    IN PLUID ModifiedId,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PACCESS_MASK Rights
    );

NTSTATUS
NtfsGetCachedRights (
    IN PVCB Vcb,
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext,
    IN PSHARED_SECURITY SharedSecurity,
    OUT PACCESS_MASK Rights,
    OUT PBOOLEAN EntryCached OPTIONAL,
    OUT PLUID TokenId OPTIONAL,
    OUT PLUID ModifiedId OPTIONAL
    );
#endif


//
//  In-memory structure support routine, implemented in StrucSup.c
//

//
//  Routines to create and destroy the Vcb
//

VOID
NtfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb
    );

BOOLEAN
NtfsDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB *Vcb
    );

//
//  Routines to create and destroy the Fcb
//

PFCB
NtfsCreateRootFcb (                         //  also creates the root lcb
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

PFCB
NtfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_REFERENCE FileReference,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN LargeFcb,
    OUT PBOOLEAN ReturnedExistingFcb OPTIONAL
    );

VOID
NtfsDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *Fcb,
    OUT PBOOLEAN AcquiredFcbTable
    );

PFCB
NtfsGetNextFcbTableEntry (
    IN PVCB Vcb,
    IN PVOID *RestartKey
    );

//
//  Routines to create and destroy the Scb
//

PSCB
NtfsCreateScb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PCUNICODE_STRING AttributeName,
    IN BOOLEAN ReturnExistingOnly,
    OUT PBOOLEAN ReturnedExistingScb OPTIONAL
    );

PSCB
NtfsCreatePrerestartScb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_REFERENCE FileReference,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN ULONG BytesPerIndexBuffer
    );

VOID
NtfsFreeScbAttributeName (
    IN PWSTR AttributeNameBuffer
    );

VOID
NtfsDeleteScb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB *Scb
    );

BOOLEAN
NtfsUpdateNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PSCB Scb,
    IN PFILE_NAME FileName OPTIONAL,
    IN BOOLEAN CheckBufferSizeOnly,
    IN BOOLEAN NewDirectory
    );

VOID
NtfsDeleteNormalizedName (
    IN PSCB Scb
    );

typedef
NTSTATUS
(*NTFSWALKUPFUNCTION)(
    PIRP_CONTEXT IrpContext,
    PFCB Fcb,
    PSCB Scb,
    PFILE_NAME FileName,
    PVOID Context );

NTSTATUS
NtfsWalkUpTree (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN NTFSWALKUPFUNCTION WalkUpFunction,
    IN OUT PVOID Context
    );

typedef struct {
    UNICODE_STRING Name;
    FILE_REFERENCE Scope;
    BOOLEAN IsRoot;
#ifdef BENL_DBG
    PFCB StartFcb;
#endif
} SCOPE_CONTEXT, *PSCOPE_CONTEXT;

NTSTATUS
NtfsBuildRelativeName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN PFILE_NAME FileName,
    IN OUT PVOID Context
    );

VOID
NtfsBuildNormalizedName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB IndexScb OPTIONAL,
    OUT PUNICODE_STRING FileName
    );

VOID
NtfsSnapshotScb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NtfsUpdateScbSnapshots (
    IN PIRP_CONTEXT IrpContext
    );

VOID
NtfsRestoreScbSnapshots (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Higher
    );

VOID
NtfsMungeScbSnapshot (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileSize
    );

VOID
NtfsFreeSnapshotsForFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

BOOLEAN
NtfsCreateFileLock (
    IN PSCB Scb,
    IN BOOLEAN RaiseOnError
    );

//
//
//  A general purpose teardown routine that helps cleanup the
//  the Fcb/Scb structures
//

VOID
NtfsTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID FcbOrScb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN CheckForAttributeTable,
    IN ULONG AcquireFlags,
    OUT PBOOLEAN RemovedFcb OPTIONAL
    );

//
//  Routines to create, destroy and walk through the Lcbs
//

PLCB
NtfsCreateLcb (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN UNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN OUT PBOOLEAN ReturnedExistingLcb OPTIONAL
    );

VOID
NtfsDeleteLcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PLCB *Lcb
    );

VOID
NtfsMoveLcb (   //  also munges the ccb and fileobjects filenames
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PSCB Scb,
    IN PFCB Fcb,
    IN PUNICODE_STRING TargetDirectoryName,
    IN PUNICODE_STRING LastComponentName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    );

VOID
NtfsRenameLcb ( //  also munges the ccb and fileobjects filenames
    IN PIRP_CONTEXT IrpContext,
    IN PLCB Lcb,
    IN PUNICODE_STRING LastComponentFileName,
    IN UCHAR FileNameFlags,
    IN BOOLEAN CheckBufferSizeOnly
    );

VOID
NtfsCombineLcbs (
    IN PIRP_CONTEXT IrpContext,
    IN PLCB PrimaryLcb,
    IN PLCB AuxLcb
    );

PLCB
NtfsLookupLcbByFlags (
    IN PFCB Fcb,
    IN UCHAR FileNameFlags
    );

ULONG
NtfsLookupNameLengthViaLcb (
    IN PFCB Fcb,
    OUT PBOOLEAN LeadingBackslash
    );

VOID
NtfsFileNameViaLcb (
    IN PFCB Fcb,
    IN PWCHAR FileName,
    ULONG Length,
    ULONG BytesToCopy
    );

//
//      VOID
//      NtfsLinkCcbToLcb (
//          IN PIRP_CONTEXT IrpContext OPTIONAL,
//          IN PFCB Fcb,
//          IN PCCB Ccb,
//          IN PLCB Lcb
//          );
//

#define NtfsLinkCcbToLcb(IC,F,C,L) {                  \
    NtfsLockFcb( IC, F );                             \
    InsertTailList( &(L)->CcbQueue, &(C)->LcbLinks ); \
    (C)->Lcb = (L);                                   \
    NtfsUnlockFcb( IC, F );                           \
}

//
//      VOID
//      NtfsUnlinkCcbFromLcb (
//          IN PIRP_CONTEXT IrpContext OPTIONAL,
//          IN PFCB Fcb,
//          IN PCCB Ccb
//          );
//

#define NtfsUnlinkCcbFromLcb(IC,F,C) {          \
    NtfsLockFcb( IC, F );                       \
    if ((C)->Lcb != NULL) {                     \
        RemoveEntryList( &(C)->LcbLinks );      \
        (C)->Lcb = NULL;                        \
    }                                           \
    NtfsUnlockFcb( IC, F );                     \
}

//
//  Routines to create and destroy the Ccb
//

PCCB
NtfsCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN BOOLEAN Indexed,
    IN USHORT EaModificationCount,
    IN ULONG Flags,
    IN PFILE_OBJECT FileObject,
    IN ULONG LastFileNameOffset
    );

VOID
NtfsDeleteCcb (
    IN PFCB Fcb,
    IN OUT PCCB *Ccb
    );

//
//  Routines to create and destroy the IrpContext
//

VOID
NtfsInitializeIrpContext (
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN Wait,
    IN OUT PIRP_CONTEXT *IrpContext
    );

VOID
NtfsCleanupIrpContext (
    IN OUT PIRP_CONTEXT IrpContext,
    IN ULONG Retry
    );

//
//  Routines to initialize and change the ntfs_io_context
//

VOID
NtfsInitializeIoContext (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_IO_CONTEXT IoContext,
    IN BOOLEAN PagingIo
    );

VOID
NtfsSetIoContextAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE ResourceToRelease,
    IN ULONG ByteCount
    );


//
//  Routine for scanning the Fcbs within the graph hierarchy
//

PSCB
NtfsGetNextScb (
    IN PSCB Scb,
    IN PSCB TerminationScb
    );

//
//  The following macros are useful for traversing the queues interconnecting
//  fcbs, scb, and lcbs.
//
//      PSCB
//      NtfsGetNextChildScb (
//          IN PFCB Fcb,
//          IN PSCB PreviousChildScb
//          );
//
//      PLCB
//      NtfsGetNextParentLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb,
//          IN PLCB PreviousParentLcb
//          );
//
//      PLCB
//      NtfsGetNextChildLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PSCB Scb,
//          IN PLCB PreviousChildLcb
//          );
//
//      PLCB
//      NtfsGetPrevChildLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PSCB Scb,
//          IN PLCB PreviousChildLcb
//          );
//
//      PLCB
//      NtfsGetNextParentLcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb,
//          IN PLCB PreviousChildLcb
//          );
//
//      PCCB
//      NtfsGetNextCcb (
//          IN PIRP_CONTEXT IrpContext,
//          IN PLCB Lcb,
//          IN PCCB PreviousCcb
//          );
//

#define NtfsGetNextChildScb(F,P) ((PSCB)                                        \
    ((P) == NULL ?                                                              \
        (IsListEmpty(&(F)->ScbQueue) ?                                          \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD((F)->ScbQueue.Flink, SCB, FcbLinks.Flink)         \
        )                                                                       \
    :                                                                           \
        ((PVOID)((PSCB)(P))->FcbLinks.Flink == &(F)->ScbQueue.Flink ?           \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD(((PSCB)(P))->FcbLinks.Flink, SCB, FcbLinks.Flink) \
        )                                                                       \
    )                                                                           \
)

#define NtfsGetNextParentLcb(F,P) ((PLCB)                                       \
    ((P) == NULL ?                                                              \
        (IsListEmpty(&(F)->LcbQueue) ?                                          \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD((F)->LcbQueue.Flink, LCB, FcbLinks.Flink)         \
        )                                                                       \
    :                                                                           \
        ((PVOID)((PLCB)(P))->FcbLinks.Flink == &(F)->LcbQueue.Flink ?           \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD(((PLCB)(P))->FcbLinks.Flink, LCB, FcbLinks.Flink) \
        )                                                                       \
    )                                                                           \
)

#define NtfsGetNextChildLcb(S,P) ((PLCB)                                              \
    ((P) == NULL ?                                                                    \
        ((((NodeType(S) == NTFS_NTC_SCB_DATA) || (NodeType(S) == NTFS_NTC_SCB_MFT))   \
          || IsListEmpty(&(S)->ScbType.Index.LcbQueue)) ?                             \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD((S)->ScbType.Index.LcbQueue.Flink, LCB, ScbLinks.Flink) \
        )                                                                             \
    :                                                                                 \
        ((PVOID)((PLCB)(P))->ScbLinks.Flink == &(S)->ScbType.Index.LcbQueue.Flink ?   \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD(((PLCB)(P))->ScbLinks.Flink, LCB, ScbLinks.Flink)       \
        )                                                                             \
    )                                                                                 \
)

#define NtfsGetPrevChildLcb(S,P) ((PLCB)                                              \
    ((P) == NULL ?                                                                    \
        ((((NodeType(S) == NTFS_NTC_SCB_DATA) || (NodeType(S) == NTFS_NTC_SCB_MFT))   \
          || IsListEmpty(&(S)->ScbType.Index.LcbQueue)) ?                             \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD((S)->ScbType.Index.LcbQueue.Blink, LCB, ScbLinks.Flink) \
        )                                                                             \
    :                                                                                 \
        ((PVOID)((PLCB)(P))->ScbLinks.Blink == &(S)->ScbType.Index.LcbQueue.Flink ?   \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD(((PLCB)(P))->ScbLinks.Blink, LCB, ScbLinks.Flink)       \
        )                                                                             \
    )                                                                                 \
)

#define NtfsGetNextParentLcb(F,P) ((PLCB)                                             \
    ((P) == NULL ?                                                                    \
        (IsListEmpty(&(F)->LcbQueue) ?                                                \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD((F)->LcbQueue.Flink, LCB, FcbLinks.Flink)               \
        )                                                                             \
    :                                                                                 \
        ((PVOID)((PLCB)(P))->FcbLinks.Flink == &(F)->LcbQueue.Flink ?                 \
            NULL                                                                      \
        :                                                                             \
            CONTAINING_RECORD(((PLCB)(P))->FcbLinks.Flink, LCB, FcbLinks.Flink)       \
        )                                                                             \
    )                                                                                 \
)

#define NtfsGetNextCcb(L,P) ((PCCB)                                             \
    ((P) == NULL ?                                                              \
        (IsListEmpty(&(L)->CcbQueue) ?                                          \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD((L)->CcbQueue.Flink, CCB, LcbLinks.Flink)         \
        )                                                                       \
    :                                                                           \
        ((PVOID)((PCCB)(P))->LcbLinks.Flink == &(L)->CcbQueue.Flink ?           \
            NULL                                                                \
        :                                                                       \
            CONTAINING_RECORD(((PCCB)(P))->LcbLinks.Flink, CCB, LcbLinks.Flink) \
        )                                                                       \
    )                                                                           \
)


#define NtfsGetFirstCcbEntry(S)                                                 \
    (IsListEmpty( &(S)->CcbQueue )                                              \
        ? NULL                                                                  \
        : CONTAINING_RECORD( (S)->CcbQueue.Flink, CCB, CcbLinks.Flink ))

#define NtfsGetNextCcbEntry(S,C)                                                \
    ( (PVOID)&(S)->CcbQueue.Flink == (PVOID)(C)->CcbLinks.Flink                 \
        ? NULL                                                                  \
        : CONTAINING_RECORD( (C)->CcbLinks.Flink, CCB, CcbLinks.Flink ))


//
//      VOID
//      NtfsDeleteFcbTableEntry (
//          IN PVCB Vcb,
//          IN FILE_REFERENCE FileReference
//          );
//

#if (defined( NTFS_FREE_ASSERTS ))
#define NtfsDeleteFcbTableEntry(V,FR) {                                     \
    FCB_TABLE_ELEMENT _Key;                                                 \
    BOOLEAN _RemovedEntry;                                                  \
    _Key.FileReference = FR;                                                \
    _RemovedEntry = RtlDeleteElementGenericTable( &(V)->FcbTable, &_Key );  \
    ASSERT( _RemovedEntry );                                                \
}
#else
#define NtfsDeleteFcbTableEntry(V,FR) {                                     \
    FCB_TABLE_ELEMENT _Key;                                                 \
    _Key.FileReference = FR;                                                \
    RtlDeleteElementGenericTable( &(V)->FcbTable, &_Key );                  \
}
#endif

//
//  Routines for allocating and deallocating the compression synchronization structures.
//

PVOID
NtfsAllocateCompressionSync (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NtfsDeallocateCompressionSync (
    IN PVOID CompressionSync
    );

//
//  The following four routines are for incrementing and decrementing the cleanup
//  counts and the close counts.  In all of the structures
//

VOID
NtfsIncrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    );

VOID
NtfsIncrementCloseCounts (
    IN PSCB Scb,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly
    );

VOID
NtfsDecrementCleanupCounts (
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN NonCachedHandle
    );

VOID
NtfsDecrementCloseCounts (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLCB Lcb OPTIONAL,
    IN BOOLEAN SystemFile,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN DecrementCountsOnly,
    IN OUT PBOOLEAN RemovedFcb OPTIONAL
    );

PERESOURCE
NtfsAllocateEresource (
    );

VOID
NtfsFreeEresource (
    IN PERESOURCE Eresource
    );

PVOID
NtfsAllocateFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    );

VOID
NtfsFreeFcbTableEntry (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    );

VOID
NtfsPostToNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

VOID
NtfsProcessNewLengthQueue (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CleanupOnly
    );

//
//  Useful debug routines
//

VOID
NtfsTestStatusProc (
    );

//
//  Usn Support routines in UsnSup.c
//

NTSTATUS
NtfsReadUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN ProbeInput
    );

ULONG
NtfsPostUsnChange (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID ScborFcb,
    IN ULONG Reason
    );

VOID
NtfsWriteUsnJournalChanges (
    PIRP_CONTEXT IrpContext
    );

VOID
NtfsSetupUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG CreateIfNotExist,
    IN ULONG Restamp,
    IN PCREATE_USN_JOURNAL_DATA JournalData
    );

VOID
NtfsTrimUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeleteUsnJournal (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsDeleteUsnSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

//
//  NtOfs support routines in vattrsup.c
//

NTFSAPI
NTSTATUS
NtfsHoldIrpForNewLength (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PIRP Irp,
    IN LONGLONG Length,
    IN PDRIVER_CANCEL CancelRoutine,
    IN PVOID CapturedData OPTIONAL,
    OUT PVOID *CopyCapturedData OPTIONAL,
    IN ULONG CapturedDataLength
    );


//
//  Time conversion support routines, implemented as a macro
//
//      VOID
//      NtfsGetCurrentTime (
//          IN PIRP_CONTEXT IrpContext,
//          IN LONGLONG Time
//          );
//

#define NtfsGetCurrentTime(_IC,_T) {            \
    ASSERT_IRP_CONTEXT(_IC);                    \
    KeQuerySystemTime((PLARGE_INTEGER)&(_T));   \
}

//
//  Time routine to check if last access should be updated.
//
//      BOOLEAN
//      NtfsCheckLastAccess (
//          IN PIRP_CONTEXT IrpContext,
//          IN OUT PFCB Fcb
//          );
//

#define NtfsCheckLastAccess(_IC,_FCB)  (                                            \
    ((NtfsLastAccess + (_FCB)->Info.LastAccessTime) < (_FCB)->CurrentLastAccess) || \
    ((_FCB)->CurrentLastAccess < (_FCB)->Info.LastAccessTime)                       \
)


//
//  Macro and #defines to decide whether a given feature is supported on a
//  given volume version.  Currently, all features either work on all Ntfs
//  volumes, or work on all volumes with major version greater than 1.  In
//  some future version, some features may require version 4.x volumes, etc.
//
//  This macro is used to decide whether to fail a user request with
//  STATUS_VOLUME_NOT_UPGRADED, and also helps us set the FILE_SUPPORTS_xxx
//  flags correctly in NtfsQueryFsAttributeInfo.
//

#define NTFS_ENCRYPTION_VERSION         2
#define NTFS_OBJECT_ID_VERSION          2
#define NTFS_QUOTA_VERSION              2
#define NTFS_REPARSE_POINT_VERSION      2
#define NTFS_SPARSE_FILE_VERSION        2

#define NtfsVolumeVersionCheck(VCB,VERSION) ( \
    ((VCB)->MajorVersion >= VERSION)          \
)

//
//  Low level verification routines, implemented in VerfySup.c
//

BOOLEAN
NtfsPerformVerifyOperation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsPerformDismountOnVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DoCompleteDismount,
    OUT PVPB *NewVpbReturn OPTIONAL
    );

BOOLEAN
NtfsPingVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PBOOLEAN OwnsVcb OPTIONAL
    );

VOID
NtfsVolumeCheckpointDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NtfsCheckpointAllVolumes (
    PVOID Parameter
    );

VOID
NtfsUsnTimeOutDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NtfsCheckUsnTimeOut (
    PVOID Parameter
    );

NTSTATUS
NtfsIoCallSelf (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN UCHAR MajorFunction
    );

BOOLEAN
NtfsLogEvent (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_USER_DATA UserData OPTIONAL,
    IN NTSTATUS LogCode,
    IN NTSTATUS FinalStatus
    );

VOID
NtfsMarkVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsSetVolumeInfoFlagState (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FlagsToSet,
    IN BOOLEAN NewState,
    IN BOOLEAN UpdateWithinTransaction
    );

BOOLEAN
NtfsUpdateVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN UCHAR DiskMajorVersion,
    IN UCHAR DiskMinorVersion
    );

VOID
NtfsPostVcbIsCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS  Status OPTIONAL,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    IN PFCB Fcb OPTIONAL
    );

VOID
NtOfsCloseAttributeSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    );

NTSTATUS
NtfsDeviceIoControlAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG BufferSize
    );


//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
NtfsOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
NtfsPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL
    );

VOID
NtfsWriteOplockPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL
    );

VOID
NtfsPrePostIrpInternal (
    IN PVOID Context,
    IN PIRP Irp OPTIONAL,
    IN BOOLEAN PendIrp,
    IN BOOLEAN SaveContext
    );

VOID
NtfsAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    );

NTSTATUS
NtfsPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp OPTIONAL
    );


//
//  Miscellaneous support macros.
//
//      ULONG_PTR
//      WordAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      LongAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      ULONG_PTR
//      QuadAlign (
//          IN ULONG_PTR Pointer
//          );
//
//      UCHAR
//      CopyUchar1 (
//          IN PUCHAR Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar2 (
//          IN PUSHORT Destination,
//          IN PUCHAR Source
//          );
//
//      UCHAR
//      CopyUchar4 (
//          IN PULONG Destination,
//          IN PUCHAR Source
//          );
//
//      PVOID
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define WordAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 1) & (-2)) \
)

#define LongAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 3) & (-4)) \
)

#define QuadAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 7) & (-8)) \
)

#define WordAlign(P) (             \
    ((((P)) + 1) & (-2)) \
)

#define LongAlign(P) (             \
    ((((P)) + 3) & (-4)) \
)

#define QuadAlign(P) (             \
    ((((P)) + 7) & (-8)) \
)

#define IsWordAligned(P)    ((ULONG_PTR)(P) == WordAlign( (ULONG_PTR)(P) ))

#define IsLongAligned(P)    ((ULONG_PTR)(P) == LongAlign( (ULONG_PTR)(P) ))

#define IsQuadAligned(P)    ((ULONG_PTR)(P) == QuadAlign( (ULONG_PTR)(P) ))

//
// A note on structure alignment checking:
//
// In a perfect world, we would just use TYPE_ALIGNMENT straight out of the box
// to check the alignment requirements for a given structure.
//
// On 32-bit platforms including Alpha, alignment faults are handled by the
// OS.  There are many places in the NTFS code where a structure requires
// quadword alignment (on Alpha) but only dword alignment is enforced.  To
// change this on Alpha32 would introduce compatibility problems, so on 32-bit
// platforms we do not want to use an alignment value greater than 4.
//
// In other places, enforcing ULONG alignment is more restrictive than
// necessary.  For example, a structure that contains nothing bigger than a
// USHORT can get by with 16-bit alignment.  However, there is no reason to
// relax these alignment restrictions, so on all platforms we do not want to
// use an alignment value of less than 4.
//
// This means that NTFS_TYPE_ALIGNMENT always resolves to 4 on 32-bit platforms,
// and to at least four on 64-bit platforms.
//

#ifdef _WIN64

#define NTFS_TYPE_ALIGNMENT(T) \
    ((TYPE_ALIGNMENT( T ) < TYPE_ALIGNMENT(ULONG)) ? TYPE_ALIGNMENT( ULONG ) : TYPE_ALIGNMENT( T ))

#else

#define NTFS_TYPE_ALIGNMENT(T) TYPE_ALIGNMENT( ULONG )

#endif

//
//  BlockAlign(): Aligns P on the next V boundary.
//  BlockAlignTruncate(): Aligns P on the prev V boundary.
//

#define BlockAlign(P,V) ((ASSERT( V != 0)), (((P)) + (V-1) & (-(V))))
#define BlockAlignTruncate(P,V) ((P) & (-(V)))

//
//  BlockOffset(): Calculates offset within V of P
//

#define BlockOffset(P,V) ((P) & (V-1))

//
//  TypeAlign(): Aligns P according to the alignment requirements of type T
//

#define TypeAlign(P,T) BlockAlign( P, NTFS_TYPE_ALIGNMENT(T) )

//
// IsTypeAligned(): Determines whether P is aligned according to the
// requirements of type T
//

#define IsTypeAligned(P,T) \
    ((ULONG_PTR)(P) == TypeAlign( (ULONG_PTR)(P), T ))

//
//  Conversions between bytes and clusters.  Typically we will round up to the
//  next cluster unless the macro specifies trucate.
//

#define ClusterAlign(V,P) (                                       \
    ((((ULONG)(P)) + (V)->ClusterMask) & (V)->InverseClusterMask) \
)

#define ClusterOffset(V,P) (          \
    (((ULONG)(P)) & (V)->ClusterMask) \
)

#define ClustersFromBytes(V,P) (                           \
    (((ULONG)(P)) + (V)->ClusterMask) >> (V)->ClusterShift \
)

#define ClustersFromBytesTruncate(V,P) (    \
    ((ULONG)(P)) >> (V)->ClusterShift       \
)

#define BytesFromClusters(V,P) (      \
    ((ULONG)(P)) << (V)->ClusterShift \
)

#define LlClustersFromBytes(V,L) (                                                  \
    Int64ShraMod32(((L) + (LONGLONG) (V)->ClusterMask), (CCHAR)(V)->ClusterShift)   \
)

#define LlClustersFromBytesTruncate(V,L) (                  \
    Int64ShraMod32((L), (CCHAR)(V)->ClusterShift)           \
)

#define LlBytesFromClusters(V,C) (                  \
    Int64ShllMod32((C), (CCHAR)(V)->ClusterShift)   \
)

//
//  Conversions between bytes and file records
//

#define BytesFromFileRecords(V,B) (                 \
    ((ULONG)(B)) << (V)->MftShift                   \
)

#define FileRecordsFromBytes(V,F) (                 \
    ((ULONG)(F)) >> (V)->MftShift                   \
)

#define LlBytesFromFileRecords(V,F) (               \
    Int64ShllMod32((F), (CCHAR)(V)->MftShift)       \
)

#define LlFileRecordsFromBytes(V,B) (               \
    Int64ShraMod32((B), (CCHAR)(V)->MftShift)       \
)

//
//  Conversions between bytes and index blocks
//

#define BytesFromIndexBlocks(B,S) (     \
    ((ULONG)(B)) << (S)                 \
)

#define LlBytesFromIndexBlocks(B,S) (   \
    Int64ShllMod32((B), (S))            \
)

//
//  Conversions between bytes and log blocks (512 byte blocks)
//

#define BytesFromLogBlocks(B) (                     \
    ((ULONG) (B)) << DEFAULT_INDEX_BLOCK_BYTE_SHIFT \
)

#define LogBlocksFromBytesTruncate(B) (             \
    ((ULONG) (B)) >> DEFAULT_INDEX_BLOCK_BYTE_SHIFT \
)

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

#define PtrOffset(B,O) ((ULONG)((ULONG_PTR)(O) - (ULONG_PTR)(B)))

//
//  The following support macros deal with dir notify support.
//
//      ULONG
//      NtfsBuildDirNotifyFilter (
//          IN PIRP_CONTEXT IrpContext,
//          IN ULONG Flags
//          );
//
//      VOID
//      NtfsReportDirNotify (
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN PUNICODE_STRING FullFileName,
//          IN USHORT TargetNameOffset,
//          IN PUNICODE_STRING StreamName OPTIONAL,
//          IN PUNICODE_STRING NormalizedParentName OPTIONAL,
//          IN ULONG Filter,
//          IN ULONG Action,
//          IN PFCB ParentFcb OPTIONAL
//          );
//
//      VOID
//      NtfsUnsafeReportDirNotify (
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN PUNICODE_STRING FullFileName,
//          IN USHORT TargetNameOffset,
//          IN PUNICODE_STRING StreamName OPTIONAL,
//          IN PUNICODE_STRING NormalizedParentName OPTIONAL,
//          IN ULONG Filter,
//          IN ULONG Action,
//          IN PFCB ParentFcb OPTIONAL
//          );
//

#define NtfsBuildDirNotifyFilter(IC,F) (                                        \
    FlagOn( (F), FCB_INFO_CHANGED_ALLOC_SIZE ) ?                                \
    (FlagOn( (F), FCB_INFO_VALID_NOTIFY_FLAGS ) | FILE_NOTIFY_CHANGE_SIZE) :    \
    FlagOn( (F), FCB_INFO_VALID_NOTIFY_FLAGS )                                  \
)

#define NtfsReportDirNotify(IC,V,FN,O,SN,NPN,F,A,PF)    {       \
    try {                                                       \
        FsRtlNotifyFilterReportChange( (V)->NotifySync,         \
                                       &(V)->DirNotifyList,     \
                                       (PSTRING) (FN),          \
                                       (USHORT) (O),            \
                                       (PSTRING) (SN),          \
                                       (PSTRING) (NPN),         \
                                       F,                       \
                                       A,                       \
                                       PF,                      \
                                       NULL );                  \
    } except (FsRtlIsNtstatusExpected( GetExceptionCode() ) ?   \
              EXCEPTION_EXECUTE_HANDLER :                       \
              EXCEPTION_CONTINUE_SEARCH) {                      \
        NOTHING;                                                \
    }                                                           \
}

#define NtfsUnsafeReportDirNotify(IC,V,FN,O,SN,NPN,F,A,PF) {    \
    FsRtlNotifyFilterReportChange( (V)->NotifySync,             \
                                   &(V)->DirNotifyList,         \
                                   (PSTRING) (FN),              \
                                   (USHORT) (O),                \
                                   (PSTRING) (SN),              \
                                   (PSTRING) (NPN),             \
                                   F,                           \
                                   A,                           \
                                   PF,                          \
                                   NULL );                      \
}


//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(D,S) {                                \
    *((UCHAR1 *)(D)) = *((UNALIGNED UCHAR1 *)(S)); \
}

#define CopyUchar2(D,S) {                                \
    *((UCHAR2 *)(D)) = *((UNALIGNED UCHAR2 *)(S)); \
}

#define CopyUchar4(D,S) {                                \
    *((UCHAR4 *)(D)) = *((UNALIGNED UCHAR4 *)(S)); \
}

//
//  The following routines are used to set up and restore the top level
//  irp field in the local thread.  They are contained in ntfsdata.c
//


PTOP_LEVEL_CONTEXT
NtfsInitializeTopLevelIrp (
    IN PTOP_LEVEL_CONTEXT TopLevelContext,
    IN BOOLEAN ForceTopLevel,
    IN BOOLEAN SetTopLevel
    );

//
//  BOOLEAN
//  NtfsIsTopLevelRequest (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  BOOLEAN
//  NtfsIsTopLevelNtfs (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  NtfsRestoreTopLevelIrp (
//      );
//
//  PTOP_LEVEL_CONTEXT
//  NtfsGetTopLevelContext (
//      );
//
//  PSCB
//  NtfsGetTopLevelHotFixScb (
//      );
//
//  VCN
//  NtfsGetTopLevelHotFixVcn (
//      );
//
//  BOOLEAN
//  NtfsIsTopLevelHotFixScb (
//      IN PSCB Scb
//      );
//
//  VOID
//  NtfsUpdateIrpContextWithTopLevel (
//      IN PIRP_CONTEXT IrpContext,
//      IN PTOP_LEVEL_CONTEXT TopLevelContext
//      );
//

#define NtfsRestoreTopLevelIrp() {                      \
    PTOP_LEVEL_CONTEXT TLC;                             \
    TLC = (PTOP_LEVEL_CONTEXT) IoGetTopLevelIrp();      \
    ASSERT( (TLC)->ThreadIrpContext != NULL );          \
    (TLC)->Ntfs = 0;                                    \
    (TLC)->ThreadIrpContext = NULL;                     \
    IoSetTopLevelIrp( (PIRP) (TLC)->SavedTopLevelIrp ); \
}

#define NtfsGetTopLevelContext() (                      \
    (PTOP_LEVEL_CONTEXT) IoGetTopLevelIrp()             \
)

#define NtfsIsTopLevelRequest(IC) (                     \
    ((IC) == (IC)->TopLevelIrpContext) &&               \
    NtfsGetTopLevelContext()->TopLevelRequest           \
)

#define NtfsIsTopLevelNtfs(IC) (                        \
    (IC) == (IC)->TopLevelIrpContext                    \
)

#define NtfsGetTopLevelHotFixScb() (                    \
    (NtfsGetTopLevelContext())->ScbBeingHotFixed        \
)

#define NtfsGetTopLevelHotFixVcn() (                    \
    (NtfsGetTopLevelContext())->VboBeingHotFixed        \
)

#define NtfsIsTopLevelHotFixScb(S) (                    \
    ((BOOLEAN) (NtfsGetTopLevelHotFixScb() == (S)))     \
)

#define NtfsUpdateIrpContextWithTopLevel(IC,TLC) {                  \
    if ((TLC)->ThreadIrpContext == NULL) {                          \
        (TLC)->Ntfs = 0x5346544e;                                   \
        (TLC)->ThreadIrpContext = (IC);                             \
        SetFlag( (IC)->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL );   \
        IoSetTopLevelIrp( (PIRP) (TLC) );                           \
    }                                                               \
    (IC)->TopLevelIrpContext = (TLC)->ThreadIrpContext;             \
}

BOOLEAN
NtfsSetCancelRoutine (
    IN PIRP Irp,
    IN PDRIVER_CANCEL CancelRoutine,
    IN ULONG_PTR IrpInformation,
    IN ULONG Async
    );

BOOLEAN
NtfsClearCancelRoutine (
    IN PIRP Irp
    );

#ifdef NTFS_CHECK_BITMAP
VOID
NtfsBadBitmapCopy (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BadBit,
    IN ULONG Length
    );

BOOLEAN
NtfsCheckBitmap (
    IN PVCB Vcb,
    IN ULONG Lcn,
    IN ULONG Count,
    IN BOOLEAN Set
    );
#endif


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect a volume device object, with the exception of the file system
//  control function which can also take a file system device object), and
//  a pointer to the IRP.  They either perform the function at the FSD level
//  or post the request to the FSP work queue for FSP level processing.
//


NTSTATUS
NtfsFsdDispatch (                       // implemented in ntfsdata.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdDispatchWait (                   // implemented in ntfsdata.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdCleanup (                        //  implemented in Cleanup.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdClose (                          //  implemented in Close.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdCreate (                         //  implemented in Create.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsDeviceIoControl (                   //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoCtl,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG_PTR IosbInformation OPTIONAL
    );

NTSTATUS
NtfsFsdDirectoryControl (               //  implemented in DirCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdPnp (                            //  implemented in Pnp.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdFlushBuffers (                   //  implemented in Flush.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFlushUserStream (                   //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG FileOffset OPTIONAL,
    IN ULONG Length
    );

NTSTATUS
NtfsFlushVolume (                       //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushCache,
    IN BOOLEAN PurgeFromCache,
    IN BOOLEAN ReleaseAllFiles,
    IN BOOLEAN MarkFilesForDismount
    );

NTSTATUS
NtfsFlushLsnStreams (                   //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN ForceRemove,
    IN BOOLEAN Partial
    );

VOID
NtfsFlushAndPurgeFcb (                  //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
NtfsFlushAndPurgeScb (                  //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PSCB ParentScb OPTIONAL
    );

NTSTATUS
NtfsFsdFileSystemControl (              //  implemented in FsCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdLockControl (                    //  implemented in LockCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdRead (                           //  implemented in Read.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdSetInformation (                 //  implemented in FileInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdShutdown (                       //  implemented in Shutdown.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdQueryVolumeInformation (         //  implemented in VolInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdSetVolumeInformation (           //  implemented in VolInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsFsdWrite (                          //  implemented in Write.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//
//
//      BOOLEAN
//      CanFsdWait (
//          IN PIRP Irp
//          );
//

#define CanFsdWait(I) IoIsOperationSynchronous(I)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
NtfsFspDispatch (                       //  implemented in FspDisp.c
    IN PVOID Context
    );

//
//  The following routines are the FSP work routines that are called
//  by the preceding NtfsFspDispath routine.  Each takes as input a pointer
//  to the IRP, perform the function, and return a pointer to the volume
//  device object that they just finished servicing (if any).  The return
//  pointer is then used by the main Fsp dispatch routine to check for
//  additional IRPs in the volume's overflow queue.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

NTSTATUS
NtfsCommonCleanup (                     //  implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

LONG
NtfsCleanupExceptionFilter (            //  implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    OUT PNTSTATUS Status
    );

VOID
NtfsFspClose (                          //  implemented in Close.c
    IN PVCB ThisVcb OPTIONAL
    );

BOOLEAN
NtfsAddScbToFspClose (                  //  implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN DelayClose
    );

BOOLEAN
NtfsNetworkOpenCreate (                 //  implemented in Create.c
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

NTSTATUS
NtfsCommonCreate (                      //  implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PCREATE_CONTEXT CreateContext
    );

VOID
NtfsInitializeFcbAndStdInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ThisFcb,
    IN BOOLEAN Directory,
    IN BOOLEAN ViewIndex,
    IN BOOLEAN Compressed,
    IN ULONG FileAttributes,
    IN PNTFS_TUNNELED_DATA SetTunnelData OPTIONAL
    );

NTSTATUS
NtfsCommonVolumeOpen (                  //  implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonDeviceControl (               //  implemented in DevCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonDirectoryControl (            //  implemented in DirCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
NtfsReportViewIndexNotify (             //  implemented in DirCtrl.c
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID ChangeInfoBuffer,
    IN USHORT ChangeInfoBufferLength
    );

NTSTATUS
NtfsCommonQueryEa (                     //  implemented in Ea.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetEa (                       //  implemented in Ea.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonQueryInformation (            //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetInformation (              //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS                                //  implemented in FsCtrl.c
NtfsGetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PNTFS_TUNNELED_DATA TunneledData
    );

NTSTATUS                                //  implemented in FsCtrl.c
NtfsSetTunneledData (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PNTFS_TUNNELED_DATA TunneledData
    );

NTSTATUS
NtfsCommonQueryQuota (                  //  implemented in Quota.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetQuota (                    //  implemented in Quota.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonFlushBuffers (                //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonFileSystemControl (           //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonLockControl (                 //  implemented in LockCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonRead (                        //  implemented in Read.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN BOOLEAN AcquireScb
    );

NTSTATUS
NtfsCommonQuerySecurityInfo (           //  implemented in SeInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetSecurityInfo (             //  implemented in SeInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsQueryViewIndex (                    //  implemented in ViewSup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN PCCB Ccb
    );

NTSTATUS
NtfsCommonQueryVolumeInfo (             //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonSetVolumeInfo (               //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
NtfsCommonWrite (                       //  implemented in Write.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.  Either the Irp or IrpContext may be NULL depending on whether
//  this is being done for a user or for a FS service.
//
//  This would typically be done in order to pass a "naked" IrpContext off to
//  the Fsp for post processing, such as read ahead.
//

VOID
NtfsCompleteRequest (
    IN OUT PIRP_CONTEXT IrpContext OPTIONAL,
    IN OUT PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    );

//
//  Here are the callbacks used by the I/O system for checking for fast I/O or
//  doing a fast query info call, or doing fast lock calls.
//

BOOLEAN
NtfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NtfsFastQueryNetworkOpenInfo (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

VOID
NtfsFastIoQueryCompressionInfo (
    IN PFILE_OBJECT FileObject,
    OUT PFILE_COMPRESSION_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
NtfsFastIoQueryCompressedSize (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    OUT PULONG CompressedSize
    );

//
//  The following macro is used by the dispatch routines to determine if
//  an operation is to be done with or without WriteThrough.
//
//      BOOLEAN
//      IsFileWriteThrough (
//          IN PFILE_OBJECT FileObject,
//          IN PVCB Vcb
//          );
//

#define IsFileWriteThrough(FO,V) (          \
    FlagOn((FO)->Flags, FO_WRITE_THROUGH)   \
)

//
//  The following macro is used to set the is fast i/o possible field in
//  the common part of the non paged fcb
//
//      NotPossible     -   Volume not mounted
//                      -   Oplock state prevents it
//
//      Possible        -   Not compressed or sparse
//                      -   No file locks
//                      -   Not a read only volume
//                      -   No Usn journal for this volume
//
//      Questionable    -   All other cases
//
//
//      BOOLEAN
//      NtfsIsFastIoPossible (
//          IN PSCB Scb
//          );
//

#define NtfsIsFastIoPossible(S) (BOOLEAN) (                                     \
    (!FlagOn((S)->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED) ||                   \
     !FsRtlOplockIsFastIoPossible( &(S)->ScbType.Data.Oplock )) ?               \
                                                                                \
        FastIoIsNotPossible :                                                   \
                                                                                \
        ((((S)->CompressionUnit == 0) &&                                        \
          (((S)->ScbType.Data.FileLock == NULL) ||                              \
           !FsRtlAreThereCurrentFileLocks( (S)->ScbType.Data.FileLock ))  &&    \
          !NtfsIsVolumeReadOnly( (S)->Vcb ) &&                                  \
          ((S)->Vcb->UsnJournal == NULL))   ?                                   \
                                                                                \
            FastIoIsPossible :                                                  \
                                                                                \
            FastIoIsQuestionable)                                               \
)

//
//  The following macro is used to detemine if the file object is opened
//  for read only access (i.e., it is not also opened for write access or
//  delete access).
//
//      BOOLEAN
//      IsFileObjectReadOnly (
//          IN PFILE_OBJECT FileObject
//          );
//

#define IsFileObjectReadOnly(FO) (!((FO)->WriteAccess | (FO)->DeleteAccess))


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }


//
//  Simple initialization for a name pair
//
//  VOID
//  NtfsInitializeNamePair(PNAME_PAIR PNp);
//

#define NtfsInitializeNamePair(PNp) {                           \
    (PNp)->Short.Buffer = (PNp)->ShortBuffer;                   \
    (PNp)->Long.Buffer = (PNp)->LongBuffer;                     \
    (PNp)->Short.Length = 0;                                    \
    (PNp)->Long.Length = 0;                                     \
    (PNp)->Short.MaximumLength = sizeof((PNp)->ShortBuffer);    \
    (PNp)->Long.MaximumLength = sizeof((PNp)->LongBuffer);      \
}

//
//  Copy a length of WCHARs into a side of a name pair. Only copy the first name
//  that fits to avoid useless work if more than three links are encountered (per
//  BrianAn), very rare case. We use the filename flags to figure out what kind of
//  name we have.
//
//  VOID
//  NtfsCopyNameToNamePair(
//              PNAME_PAIR PNp,
//              WCHAR Source,
//              ULONG SourceLen,
//              UCHAR NameFlags);
//

#define NtfsCopyNameToNamePair(PNp, Source, SourceLen, NameFlags) {                          \
    if (!FlagOn((NameFlags), FILE_NAME_DOS)) {                                               \
        if ((PNp)->Long.Length == 0) {                                                       \
            if ((PNp)->Long.MaximumLength < ((SourceLen)*sizeof(WCHAR))) {                   \
                if ((PNp)->Long.Buffer != (PNp)->LongBuffer) {                               \
                    NtfsFreePool((PNp)->Long.Buffer);                                        \
                    (PNp)->Long.Buffer = (PNp)->LongBuffer;                                  \
                    (PNp)->Long.MaximumLength = sizeof((PNp)->LongBuffer);                   \
                }                                                                            \
                (PNp)->Long.Buffer = NtfsAllocatePool(PagedPool,(SourceLen)*sizeof(WCHAR));  \
                (PNp)->Long.MaximumLength = (SourceLen)*sizeof(WCHAR);                       \
            }                                                                                \
            RtlCopyMemory((PNp)->Long.Buffer, (Source), (SourceLen)*sizeof(WCHAR));          \
            (PNp)->Long.Length = (SourceLen)*sizeof(WCHAR);                                  \
        }                                                                                    \
    } else {                                                                                 \
        ASSERT((PNp)->Short.Buffer == (PNp)->ShortBuffer);                                   \
        if ((PNp)->Short.Length == 0) {                                                      \
            RtlCopyMemory((PNp)->Short.Buffer, (Source), (SourceLen)*sizeof(WCHAR));         \
            (PNp)->Short.Length = (SourceLen)*sizeof(WCHAR);                                 \
        }                                                                                    \
    }                                                                                        \
}

//
//  Set up a previously used name pair for reuse.
//
//  VOID
//  NtfsResetNamePair(PNAME_PAIR PNp);
//

#define NtfsResetNamePair(PNp) {                    \
    if ((PNp)->Long.Buffer != (PNp)->LongBuffer) {  \
        NtfsFreePool((PNp)->Long.Buffer);             \
    }                                               \
    NtfsInitializeNamePair(PNp);                    \
}

//
// Cairo support stuff.
//

typedef NTSTATUS
(*FILE_RECORD_WALK) (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PVOID Context
    );

NTSTATUS
NtfsIterateMft (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PFILE_REFERENCE FileReference,
    IN FILE_RECORD_WALK FileRecordFunction,
    IN PVOID Context
    );

VOID
NtfsPostSpecial (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN POST_SPECIAL_CALLOUT PostSpecialCallout,
    IN PVOID Context
    );

VOID
NtfsSpecialDispatch (
    PVOID Context
    );

VOID
NtfsLoadAddOns (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PVOID Context,
    IN ULONG Count
    );

NTSTATUS
NtfsTryOpenFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PFCB *CurrentFcb,
    IN FILE_REFERENCE FileReference
    );

//
//  The following define controls whether quota operations are done
//  on this FCB.
//

#define NtfsPerformQuotaOperation(FCB) ((FCB)->QuotaControl != NULL)

VOID
NtfsAcquireQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    );

VOID
NtfsCalculateQuotaAdjustment (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PLONGLONG Delta
    );

VOID
NtfsDereferenceQuotaControlBlock (
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK *QuotaControl
    );

VOID
NtfsFixupQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

NTSTATUS
NtfsFsQuotaQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingId,
    IN BOOLEAN ReturnSingleEntry,
    IN PFILE_QUOTA_INFORMATION *FileQuotaInfo,
    IN OUT PULONG Length,
    IN OUT PCCB Ccb OPTIONAL
    );

NTSTATUS
NtfsFsQuotaSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN ULONG Length
    );

VOID
NtfsGetRemainingQuota (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG OwnerId,
    OUT PULONGLONG RemainingQuota,
    OUT PULONGLONG TotalQuota,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    );

ULONG
NtfsGetCallersUserId (
    IN PIRP_CONTEXT IrpContext
    );

ULONG
NtfsGetOwnerId (
    IN PIRP_CONTEXT IrpContext,
    IN PSID Sid,
    IN BOOLEAN CreateNew,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo OPTIONAL
    );

PQUOTA_CONTROL_BLOCK
NtfsInitializeQuotaControlBlock (
    IN PVCB Vcb,
    IN ULONG OwnerId
    );

VOID
NtfsInitializeQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    );

VOID
NtfsMarkQuotaCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

VOID
NtfsMoveQuotaOwner (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR Security
    );


VOID
NtfsPostRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsQueryQuotaUserSidList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_GET_QUOTA_INFORMATION SidList,
    OUT PFILE_QUOTA_INFORMATION QuotaBuffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN ReturnSingleEntry
    );

VOID
NtfsReleaseQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    );

VOID
NtfsUpdateFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLONGLONG Delta,
    IN LOGICAL LogIt,
    IN LOGICAL CheckQuota
    );

VOID
NtfsUpdateQuotaDefaults (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION FileQuotaInfo
    );

INLINE
VOID
NtfsConditionallyFixupQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )
{
    if (FlagOn( Fcb->Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED )) {
        NtfsFixupQuota ( IrpContext, Fcb );
    }
}

INLINE
VOID
NtfsConditionallyUpdateQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLONGLONG Delta,
    IN LOGICAL LogIt,
    IN LOGICAL CheckQuota
    )
{
    if (NtfsPerformQuotaOperation( Fcb ) &&
        !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_QUOTA_DISABLE )) {
        NtfsUpdateFileQuota( IrpContext, Fcb, Delta, LogIt, CheckQuota );
    }
}

extern BOOLEAN NtfsAllowFixups;

INLINE
VOID
NtfsReleaseQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Acquired
    )
{
    if (Acquired) {
        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }
}

//
// Define the quota charge for resident streams.
//

#define NtfsResidentStreamQuota( Vcb ) ((LONG) Vcb->BytesPerFileRecordSegment)


//
//  The following macro tests to see if it is ok for an internal routine to
//  write to the volume.
//

#define NtfsIsVcbAvailable( Vcb ) (FlagOn( Vcb->VcbState,                   \
                             VCB_STATE_VOLUME_MOUNTED |                     \
                             VCB_STATE_FLAG_SHUTDOWN |                      \
                             VCB_STATE_PERFORMED_DISMOUNT |                 \
                             VCB_STATE_LOCKED) == VCB_STATE_VOLUME_MOUNTED)

//
//  Test to see if the volume is mounted read only.
//

#define NtfsIsVolumeReadOnly( Vcb ) (FlagOn( (Vcb)->VcbState, VCB_STATE_MOUNT_READ_ONLY ))

//
//  Processing required so reg. exception filter works if another one is being used
//  to handle an exception that could be raise via NtfsRaiseStatus. If its always
//  rethrown this is not necc.
//

#define NtfsMinimumExceptionProcessing(I) {                                \
    if((I) != NULL) {                                                      \
        ClearFlag( (I)->Flags, IRP_CONTEXT_FLAG_RAISED_STATUS );           \
    }                                                                      \
}

#ifdef NTFSDBG

BOOLEAN
NtfsChangeResourceOrderState(
    IN PIRP_CONTEXT IrpContext,
    IN NTFS_RESOURCE_NAME NewResource,
    IN BOOLEAN Release,
    IN ULONG UnsafeTransition
    );

NTFS_RESOURCE_NAME
NtfsIdentifyFcb (
    IN PVCB Vcb,
    IN PFCB Fcb
    );

#endif

//
//  Size of a normalized name which is long enough to be freed at cleanup
//

#define LONGNAME_THRESHOLD 0x200

VOID
NtfsTrimNormalizedNames (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb
    );

#define NtfsSnapshotFileSizesTest( I, S ) (FlagOn( (S)->ScbState, SCB_STATE_MODIFIED_NO_WRITE | SCB_STATE_CONVERT_UNDERWAY ) || \
                                           ((S) == (I)->CleanupStructure) ||                                                    \
                                           ((S)->Fcb == (I)->CleanupStructure))

//
//  Reservation needed =  AllocationSize
//                        largest transfer size - this is because in a single transfer we cannot reuse clusters we freed from the totalallocated piece of the calculation
//                        metadata charge for new clusters
//                        minus the already allocated space
//


//
//  One problem with the reservation strategy, is that we cannot precisely reserve
//  for metadata.  If we reserve too much, we will return premature disk full, if
//  we reserve too little, the Lazy Writer can get an error.  As we add compression
//  units to a file, large files will eventually require additional File Records.
//  If each compression unit required 0x20 bytes of run information (fairly pessimistic)
//  then a 0x400 size file record would fill up with less than 0x20 runs requiring
//  (worst case) two additional clusters for another file record.  So each 0x20
//  compression units require 0x200 reserved clusters, and a separate 2 cluster
//  file record.  0x200/2 = 0x100.  So the calculations below tack a 1/0x100 (about
//  .4% "surcharge" on the amount reserved both in the Scb and the Vcb, to solve
//  the Lazy Writer popups like the ones Alan Morris gets in the print lab.
//

#define NtfsCalculateNeededReservedSpace( S )                               \
    ((S)->Header.AllocationSize.QuadPart +                                  \
     MM_MAXIMUM_DISK_IO_SIZE +                                              \
     (S)->CompressionUnit -                                                 \
     (FlagOn( (S)->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ?         \
       (S)->Header.AllocationSize.QuadPart :                                \
       (S)->TotalAllocated) +                                               \
     (Int64ShraMod32( (S)->ScbType.Data.TotalReserved, 8 )))


PDEALLOCATED_CLUSTERS
NtfsGetDeallocatedClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Dynamically allocate stack space for local variables.
//

#define NtfsAllocateFromStack(S) _alloca(S)

//
//  Common Create Flag definitions
//

#define CREATE_FLAG_DOS_ONLY_COMPONENT          (0x00000001)
#define CREATE_FLAG_CREATE_FILE_CASE            (0x00000002)
#define CREATE_FLAG_DELETE_ON_CLOSE             (0x00000004)
#define CREATE_FLAG_TRAILING_BACKSLASH          (0x00000008)
#define CREATE_FLAG_TRAVERSE_CHECK              (0x00000010)
#define CREATE_FLAG_IGNORE_CASE                 (0x00000020)
#define CREATE_FLAG_OPEN_BY_ID                  (0x00000040)
#define CREATE_FLAG_ACQUIRED_OBJECT_ID_INDEX    (0x00000080)
#define CREATE_FLAG_BACKOUT_FAILED_OPENS        (0x00000100)
#define CREATE_FLAG_INSPECT_NAME_FOR_REPARSE    (0x00000200)
#define CREATE_FLAG_SHARED_PARENT_FCB           (0x00000400)
#define CREATE_FLAG_ACQUIRED_VCB                (0x00000800)

#define CREATE_FLAG_FIRST_PASS                  (0x00002000)
#define CREATE_FLAG_FOUND_ENTRY                 (0x00004000)
#define CREATE_FLAG_EXPLICIT_ATTRIBUTE_CODE     (0x00008000)

//
//   The following macro gives the effective mode to do security related checks based on the irp
//   If the irp is for a create request: The force_check flag only is defined for creates
//
//
//      KPROCESSOR_MODE
//      NtfsEffectiveMode (
//          IN PIRP Irp,
//          IN PIO_STACK_LOCATION IrpSp
//          );
//

#define NtfsEffectiveMode( I, IS ) (ASSERT( (IS)->MajorFunction == IRP_MJ_CREATE), (FlagOn( (IS)->Flags, SL_FORCE_ACCESS_CHECK )) ? UserMode : (I)->RequestorMode )

#endif // _NTFSPROC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\quotasup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Quota.c

Abstract:

    This module implements the quota support routines for Ntfs

Author:

    Jeff Havens     [JHavens]        29-Feb-1996

Revision History:

--*/

#include "NtfsProc.h"

#define Dbg DEBUG_TRACE_QUOTA


//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('QFtN')

#define MAXIMUM_SID_LENGTH \
    (FIELD_OFFSET( SID, SubAuthority ) + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES)

#define MAXIMUM_QUOTA_ROW (SIZEOF_QUOTA_USER_DATA + MAXIMUM_SID_LENGTH + sizeof( ULONG ))

//
//  Local quota support routines.
//

VOID
NtfsClearAndVerifyQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsClearPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

VOID
NtfsDeleteUnsedIds (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsMarkUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

NTSTATUS
NtfsPackQuotaInfo (
    IN PSID Sid,
    IN PQUOTA_USER_DATA QuotaUserData OPTIONAL,
    IN PFILE_QUOTA_INFORMATION OutBuffer,
    IN OUT PULONG OutBufferSize
    );

VOID
NtfsPostUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    );

NTSTATUS
NtfsPrepareForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSID Sid
    );

VOID
NtfsRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    );

NTSTATUS
NtfsRepairPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    );

VOID
NtfsSaveQuotaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
NtfsSaveQuotaFlagsSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
NtfsVerifyOwnerIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

RTL_GENERIC_COMPARE_RESULTS
NtfsQuotaTableCompare (
    IN PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PVOID
NtfsQuotaTableAllocate (
    IN PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

VOID
NtfsQuotaTableFree (
    IN PRTL_GENERIC_TABLE Table,
    PVOID Buffer
    );

#if (DBG || defined( NTFS_FREE_ASSERTS ) || defined( NTFSDBG ))
BOOLEAN NtfsAllowFixups = 1;
BOOLEAN NtfsCheckQuota = 0;
#endif // DBG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAcquireQuotaControl)
#pragma alloc_text(PAGE, NtfsCalculateQuotaAdjustment)
#pragma alloc_text(PAGE, NtfsClearAndVerifyQuotaIndex)
#pragma alloc_text(PAGE, NtfsClearPerFileQuota)
#pragma alloc_text(PAGE, NtfsDeleteUnsedIds)
#pragma alloc_text(PAGE, NtfsDereferenceQuotaControlBlock)
#pragma alloc_text(PAGE, NtfsFixupQuota)
#pragma alloc_text(PAGE, NtfsFsQuotaQueryInfo)
#pragma alloc_text(PAGE, NtfsFsQuotaSetInfo)
#pragma alloc_text(PAGE, NtfsGetCallersUserId)
#pragma alloc_text(PAGE, NtfsGetOwnerId)
#pragma alloc_text(PAGE, NtfsGetRemainingQuota)
#pragma alloc_text(PAGE, NtfsInitializeQuotaControlBlock)
#pragma alloc_text(PAGE, NtfsInitializeQuotaIndex)
#pragma alloc_text(PAGE, NtfsMarkQuotaCorrupt)
#pragma alloc_text(PAGE, NtfsMarkUserLimit)
#pragma alloc_text(PAGE, NtfsMoveQuotaOwner)
#pragma alloc_text(PAGE, NtfsPackQuotaInfo)
#pragma alloc_text(PAGE, NtfsPostUserLimit)
#pragma alloc_text(PAGE, NtfsPostRepairQuotaIndex)
#pragma alloc_text(PAGE, NtfsPrepareForDelete)
#pragma alloc_text(PAGE, NtfsReleaseQuotaControl)
#pragma alloc_text(PAGE, NtfsRepairQuotaIndex)
#pragma alloc_text(PAGE, NtfsSaveQuotaFlags)
#pragma alloc_text(PAGE, NtfsSaveQuotaFlagsSafe)
#pragma alloc_text(PAGE, NtfsQueryQuotaUserSidList)
#pragma alloc_text(PAGE, NtfsQuotaTableCompare)
#pragma alloc_text(PAGE, NtfsQuotaTableAllocate)
#pragma alloc_text(PAGE, NtfsQuotaTableFree)
#pragma alloc_text(PAGE, NtfsUpdateFileQuota)
#pragma alloc_text(PAGE, NtfsUpdateQuotaDefaults)
#pragma alloc_text(PAGE, NtfsVerifyOwnerIndex)
#pragma alloc_text(PAGE, NtfsRepairPerFileQuota)
#endif


VOID
NtfsAcquireQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    )

/*++

Routine Description:

    Acquire the quota control block and quota index for shared update.  Multiple
    transactions can update then index, but only one thread can update a
    particular index.

Arguments:

    QuotaControl - Quota control block to be acquired.

Return Value:

    None.

--*/

{
    PVOID *Position;
    PVOID *ScbArray;
    ULONG Count;

    PAGED_CODE();

    ASSERT( QuotaControl->ReferenceCount > 0 );

    //
    //  Make sure we have a free spot in the Scb array in the IrpContext.
    //

    if (IrpContext->SharedScb == NULL) {

        Position = &IrpContext->SharedScb;
        IrpContext->SharedScbSize = 1;

    //
    //  Too bad the first one is not available.  If the current size is one then allocate a
    //  new block and copy the existing value to it.
    //

    } else if (IrpContext->SharedScbSize == 1) {

        if (IrpContext->SharedScb == QuotaControl) {

            //
            //  The quota block has already been aquired.
            //

            return;
        }

        ScbArray = NtfsAllocatePool( PagedPool, sizeof( PVOID ) * 4 );
        RtlZeroMemory( ScbArray, sizeof( PVOID ) * 4 );
        *ScbArray = IrpContext->SharedScb;
        IrpContext->SharedScb = ScbArray;
        IrpContext->SharedScbSize = 4;
        Position = ScbArray + 1;

    //
    //  Otherwise look through the existing array and look for a free spot.  Allocate a larger
    //  array if we need to grow it.
    //

    } else {

        Position = IrpContext->SharedScb;
        Count = IrpContext->SharedScbSize;

        do {

            if (*Position == NULL) {

                break;
            }

            if (*Position == QuotaControl) {

                //
                //  The quota block has already been aquired.
                //

                return;
            }

            Count -= 1;
            Position += 1;

        } while (Count != 0);

        //
        //  If we didn't find one then allocate a new structure.
        //

        if (Count == 0) {

            ScbArray = NtfsAllocatePool( PagedPool, sizeof( PVOID ) * IrpContext->SharedScbSize * 2 );
            RtlZeroMemory( ScbArray, sizeof( PVOID ) * IrpContext->SharedScbSize * 2 );
            RtlCopyMemory( ScbArray,
                           IrpContext->SharedScb,
                           sizeof( PVOID ) * IrpContext->SharedScbSize );

            NtfsFreePool( IrpContext->SharedScb );
            IrpContext->SharedScb = ScbArray;
            Position = ScbArray + IrpContext->SharedScbSize;
            IrpContext->SharedScbSize *= 2;
        }
    }

    //
    //  The following assert is bougus, but I want know if we hit the case
    //  where create is acquiring the scb stream shared.
    //  Then make sure that the resource is released in create.c
    //

    ASSERT( IrpContext->MajorFunction != IRP_MJ_CREATE || IrpContext->OriginatingIrp != NULL || NtfsIsExclusiveScb( IrpContext->Vcb->QuotaTableScb ));

    //
    //  Increase the reference count so the quota control block is not deleted
    //  while it is in the shared list.
    //

    ASSERT( QuotaControl->ReferenceCount > 0 );
    InterlockedIncrement( &QuotaControl->ReferenceCount );

    //
    //  The quota index must be acquired before the mft scb is acquired.
    //

    ASSERT(!NtfsIsExclusiveScb( IrpContext->Vcb->MftScb ) ||
           ExIsResourceAcquiredSharedLite( IrpContext->Vcb->QuotaTableScb->Header.Resource ));

    NtfsAcquireResourceShared( IrpContext, IrpContext->Vcb->QuotaTableScb, TRUE );
    ExAcquireFastMutexUnsafe( QuotaControl->QuotaControlLock );

    *Position = QuotaControl;

    return;
}


VOID
NtfsCalculateQuotaAdjustment (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PLONGLONG Delta
    )

/*++

Routine Description:

    This routine scans the user data streams in a file and determines
    by how much the quota needs to be adjusted.

Arguments:

    Fcb - Fcb whose quota usage is being modified.

    Delta - Returns the amount of quota adjustment required for the file.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;
    VCN StartVcn = 0;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_FCB( Fcb );

    //
    //  There is nothing to do if the standard infor has not been
    //  expanded yet.
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {
        *Delta = 0;
        return;
    }

    NtfsInitializeAttributeContext( &Context );

    //
    //  Use a try-finally to cleanup the enumeration structure.
    //

    try {

        //
        //  Start with the $STANDARD_INFORMATION.  This must be the first one found.
        //

        if (!NtfsLookupAttribute( IrpContext, Fcb, &Fcb->FileReference, &Context )) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        Attribute = NtfsFoundAttribute( &Context );

        if (Attribute->TypeCode != $STANDARD_INFORMATION) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Initialize quota amount to the value current in the standard information structure.
        //

        *Delta = -(LONGLONG) ((PSTANDARD_INFORMATION) NtfsAttributeValue( Attribute ))->QuotaCharged;

        //
        //  Now continue while there are more attributes to find.
        //

        while (NtfsLookupNextAttributeByVcn( IrpContext, Fcb, &StartVcn, &Context )) {

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  For all user data streams charge for a file record plus any non-resident allocation.
            //  For index streams charge for a file record for the INDEX_ROOT.
            //
            //  For user data look for a resident attribute or the first attribute of a non-resident stream.
            //  Otherwise look for a $I30 stream.
            //

            if (NtfsIsTypeCodeSubjectToQuota( Attribute->TypeCode ) ||
                ((Attribute->TypeCode == $INDEX_ROOT) &&
                 ((Attribute->NameLength * sizeof( WCHAR )) == NtfsFileNameIndex.Length) &&
                 RtlEqualMemory( Add2Ptr( Attribute, Attribute->NameOffset ),
                                 NtfsFileNameIndex.Buffer,
                                 NtfsFileNameIndex.Length ))) {

                //
                //  Always charge for at least one file record.
                //

                *Delta += NtfsResidentStreamQuota( Fcb->Vcb );

                //
                //  Charge for the allocated length for non-resident.
                //

                if (!NtfsIsAttributeResident( Attribute )) {

                    *Delta += Attribute->Form.Nonresident.AllocatedLength;
                }
            }
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    return;
}


VOID
NtfsClearAndVerifyQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine iterates over the quota user data index and verifies the back
    pointer to the owner id index.  It also zeros the quota used field for
    each owner.

Arguments:

    Vcb - Pointer to the volume control block whose index is to be operated
          on.

Return Value:

    None

--*/

{
    INDEX_KEY IndexKey;
    INDEX_ROW OwnerRow;
    MAP_HANDLE MapHandle;
    PQUOTA_USER_DATA UserData;
    PINDEX_ROW QuotaRow;
    PVOID RowBuffer;
    NTSTATUS Status;
    ULONG OwnerId;
    ULONG Count;
    ULONG i;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;
    PINDEX_ROW IndexRow = NULL;
    PREAD_CONTEXT ReadContext = NULL;
    BOOLEAN IndexAcquired = FALSE;

    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Allocate a buffer lager enough for several rows.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

    try {

        //
        //  Allocate a bunch of index row entries.
        //

        Count = PAGE_SIZE / sizeof( QUOTA_USER_DATA );

        IndexRow = NtfsAllocatePool( PagedPool,
                                     Count * sizeof( INDEX_ROW ) );

        //
        //  Iterate through the quota entries.  Start where we left off.
        //

        OwnerId = Vcb->QuotaFileReference.SegmentNumberLowPart;
        IndexKey.KeyLength = sizeof( OwnerId );
        IndexKey.Key = &OwnerId;

        Status = NtOfsReadRecords( IrpContext,
                                   QuotaScb,
                                   &ReadContext,
                                   &IndexKey,
                                   NtOfsMatchAll,
                                   NULL,
                                   &Count,
                                   IndexRow,
                                   PAGE_SIZE,
                                   RowBuffer );


        while (NT_SUCCESS( Status )) {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
            NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
            IndexAcquired = TRUE;

            //
            //  The following assert must be done while the quota resource
            //  held; otherwise a lingering transaction may cause it to
            //

            ASSERT( RtlIsGenericTableEmpty( &Vcb->QuotaControlTable ));

            QuotaRow = IndexRow;

            for (i = 0; i < Count; i += 1, QuotaRow += 1) {

                UserData = QuotaRow->DataPart.Data;

                //
                //  Validate the record is long enough for the Sid.
                //

                IndexKey.KeyLength = RtlLengthSid( &UserData->QuotaSid );

                if ((IndexKey.KeyLength + SIZEOF_QUOTA_USER_DATA > QuotaRow->DataPart.DataLength) ||
                    !RtlValidSid( &UserData->QuotaSid )) {

                    ASSERT( FALSE );

                    //
                    //  The sid is bad delete the record.
                    //

                    NtOfsDeleteRecords( IrpContext,
                                        QuotaScb,
                                        1,
                                        &QuotaRow->KeyPart );

                    continue;
                }

                IndexKey.Key = &UserData->QuotaSid;

                //
                //  Look up the Sid is in the owner id index.
                //

                Status = NtOfsFindRecord( IrpContext,
                                          OwnerIdScb,
                                          &IndexKey,
                                          &OwnerRow,
                                          &MapHandle,
                                          NULL );

                ASSERT( NT_SUCCESS( Status ));

                if (!NT_SUCCESS( Status )) {

                    //
                    //  The owner id entry is missing.  Add one back in.
                    //

                    OwnerRow.KeyPart = IndexKey;
                    OwnerRow.DataPart.DataLength = QuotaRow->KeyPart.KeyLength;
                    OwnerRow.DataPart.Data = QuotaRow->KeyPart.Key;

                    NtOfsAddRecords( IrpContext,
                                     OwnerIdScb,
                                     1,
                                     &OwnerRow,
                                     FALSE );


                } else {

                    //
                    //  Verify that the owner id's match.
                    //

                    if (*((PULONG) QuotaRow->KeyPart.Key) != *((PULONG) OwnerRow.DataPart.Data)) {

                        ASSERT( FALSE );

                        //
                        //  Keep the quota record with the lower
                        //  quota id.  Delete the one with the higher
                        //  quota id.  Note this is the simple approach
                        //  and not best case of the lower id does not
                        //  exist.  In that case a user entry will be delete
                        //  and be reassigned a default quota.
                        //

                        if (*((PULONG) QuotaRow->KeyPart.Key) < *((PULONG) OwnerRow.DataPart.Data)) {

                            //
                            //  Make the ownid's match.
                            //

                            OwnerRow.KeyPart = IndexKey;
                            OwnerRow.DataPart.DataLength = QuotaRow->KeyPart.KeyLength;
                            OwnerRow.DataPart.Data = QuotaRow->KeyPart.Key;

                            NtOfsUpdateRecord( IrpContext,
                                               OwnerIdScb,
                                               1,
                                               &OwnerRow,
                                               NULL,
                                               NULL );

                        } else {

                            //
                            // Delete this record and proceed.
                            //


                            NtOfsDeleteRecords( IrpContext,
                                                QuotaScb,
                                                1,
                                                &QuotaRow->KeyPart );

                            NtOfsReleaseMap( IrpContext, &MapHandle );
                            continue;
                        }
                    }

                    NtOfsReleaseMap( IrpContext, &MapHandle );
                }

                //
                //  Set the quota used to zero.
                //

                UserData->QuotaUsed = 0;
                QuotaRow->DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

                NtOfsUpdateRecord( IrpContext,
                                   QuotaScb,
                                   1,
                                   QuotaRow,
                                   NULL,
                                   NULL );
            }

            //
            //  Release the indexes and commit what has been done so far.
            //

            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
            IndexAcquired = FALSE;

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            //
            //  Remember how far we got so we can restart correctly.
            //

            Vcb->QuotaFileReference.SegmentNumberLowPart = *((PULONG) IndexRow[Count - 1].KeyPart.Key);

            //
            //  Make sure the next free id is beyond the current ids.
            //

            if (Vcb->QuotaOwnerId <= Vcb->QuotaFileReference.SegmentNumberLowPart) {

                ASSERT( Vcb->QuotaOwnerId > Vcb->QuotaFileReference.SegmentNumberLowPart );
                Vcb->QuotaOwnerId = Vcb->QuotaFileReference.SegmentNumberLowPart + 1;
            }

            //
            //  Look up the next set of entries in the quota index.
            //

            Count = PAGE_SIZE / sizeof( QUOTA_USER_DATA );
            Status = NtOfsReadRecords( IrpContext,
                                       QuotaScb,
                                       &ReadContext,
                                       NULL,
                                       NtOfsMatchAll,
                                       NULL,
                                       &Count,
                                       IndexRow,
                                       PAGE_SIZE,
                                       RowBuffer );
        }

        ASSERT( (Status == STATUS_NO_MORE_MATCHES) || (Status == STATUS_NO_MATCH) );

    } finally {

        NtfsFreePool( RowBuffer );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        if (IndexAcquired) {
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (IndexRow != NULL) {
            NtfsFreePool( IndexRow );
        }

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return;
}


NTSTATUS
NtfsClearPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine clears the quota charged field in each file on the volume.  The
    Quata control block is also released in fcb.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Unsed.

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONGLONG NewQuota;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PSTANDARD_INFORMATION StandardInformation;
    PQUOTA_CONTROL_BLOCK QuotaControl = Fcb->QuotaControl;
    PVCB Vcb = Fcb->Vcb;

    UNREFERENCED_PARAMETER( Context);

    PAGED_CODE();

    //
    //  There is nothing to do if the standard info has not been
    //  expanded yet.
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {
        return STATUS_SUCCESS;
    }

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        ASSERT( NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION ));

        NewQuota = 0;

        //
        //  Call to change the attribute value.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  FIELD_OFFSET( STANDARD_INFORMATION, QuotaCharged ),
                                  &NewQuota,
                                  sizeof( StandardInformation->QuotaCharged ),
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  &AttrContext );

        //
        //  Release the quota control block for this fcb.
        //

        if (QuotaControl != NULL) {
            NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return STATUS_SUCCESS;
}


VOID
NtfsDeleteUnsedIds (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine iterates over the quota user data index and removes any
    entries still marked as deleted.

Arguments:

    Vcb - Pointer to the volume control block whoes index is to be operated
          on.

Return Value:

    None

--*/

{
    INDEX_KEY IndexKey;
    PINDEX_KEY KeyPtr;
    PQUOTA_USER_DATA UserData;
    PINDEX_ROW QuotaRow;
    PVOID RowBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG OwnerId;
    ULONG Count;
    ULONG i;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;
    PINDEX_ROW IndexRow = NULL;
    PREAD_CONTEXT ReadContext = NULL;
    BOOLEAN IndexAcquired = FALSE;

    //
    //  Allocate a buffer large enough for several rows.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, PAGE_SIZE );

    try {

        //
        //  Allocate a bunch of index row entries.
        //

        Count = PAGE_SIZE / sizeof( QUOTA_USER_DATA );

        IndexRow = NtfsAllocatePool( PagedPool,
                                     Count * sizeof( INDEX_ROW ) );

        //
        //  Iterate through the quota entries.  Start where we left off.
        //

        OwnerId = Vcb->QuotaFileReference.SegmentNumberLowPart;
        IndexKey.KeyLength = sizeof( OwnerId );
        IndexKey.Key = &OwnerId;
        KeyPtr = &IndexKey;

        while (NT_SUCCESS( Status )) {

            NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

            //
            //  Acquire the VCB shared and check whether we should
            //  continue.
            //

            if (!NtfsIsVcbAvailable( Vcb )) {

                //
                //  The volume is going away, bail out.
                //

                NtfsReleaseVcb( IrpContext, Vcb );
                Status = STATUS_VOLUME_DISMOUNTED;
                leave;
            }

            NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
            NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            IndexAcquired = TRUE;

            //
            //  Make sure the delete secquence number has not changed since
            //  the scan was delete.
            //

            if (ULongToPtr( Vcb->QuotaDeleteSecquence ) != IrpContext->Union.NtfsIoContext) {

                //
                //  The scan needs to be restarted. Set the state to posted
                //  and raise status can not wait which will cause us to retry.
                //

                ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
                SetFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_POSTED );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            Status = NtOfsReadRecords( IrpContext,
                                       QuotaScb,
                                       &ReadContext,
                                       KeyPtr,
                                       NtOfsMatchAll,
                                       NULL,
                                       &Count,
                                       IndexRow,
                                       PAGE_SIZE,
                                       RowBuffer );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            QuotaRow = IndexRow;

            for (i = 0; i < Count; i += 1, QuotaRow += 1) {

                PQUOTA_CONTROL_BLOCK QuotaControl;

                UserData = QuotaRow->DataPart.Data;

                if (!FlagOn( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {
                    continue;
                }

                //
                //  Check to see if there is a quota control entry
                //  for this id.
                //

                ASSERT( FIELD_OFFSET( QUOTA_CONTROL_BLOCK, OwnerId ) <= FIELD_OFFSET( INDEX_ROW, KeyPart.Key ));

                QuotaControl = RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                             CONTAINING_RECORD( &QuotaRow->KeyPart.Key,
                                                                                QUOTA_CONTROL_BLOCK,
                                                                                OwnerId ));

                //
                //  If there is a quota control entry or there is now
                //  some quota charged, then clear the deleted flag
                //  and update the entry.
                //

                if ((QuotaControl != NULL) || (UserData->QuotaUsed != 0)) {

                    ASSERT( (QuotaControl == NULL) && (UserData->QuotaUsed == 0) );

                    ClearFlag( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED );

                    QuotaRow->DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

                    IndexKey.KeyLength = sizeof( OwnerId );
                    IndexKey.Key = &OwnerId;
                    NtOfsUpdateRecord( IrpContext,
                                       QuotaScb,
                                       1,
                                       QuotaRow,
                                       NULL,
                                       NULL );

                    continue;
                }

                //
                //  Delete the user quota data record.
                //

                IndexKey.KeyLength = sizeof( OwnerId );
                IndexKey.Key = &OwnerId;
                NtOfsDeleteRecords( IrpContext,
                                    QuotaScb,
                                    1,
                                    &QuotaRow->KeyPart );

                //
                // Delete the owner id record.
                //

                IndexKey.Key = &UserData->QuotaSid;
                IndexKey.KeyLength = RtlLengthSid( &UserData->QuotaSid );
                NtOfsDeleteRecords( IrpContext,
                                    OwnerIdScb,
                                    1,
                                    &IndexKey );
            }

            //
            //  Release the indexes and commit what has been done so far.
            //

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
            IndexAcquired = FALSE;

            //
            //  Complete the request which commits the pending
            //  transaction if there is one and releases of the
            //  acquired resources.  The IrpContext will not
            //  be deleted because the no delete flag is set.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
            NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

            //
            //  Remember how far we got so we can restart correctly.
            //

            Vcb->QuotaFileReference.SegmentNumberLowPart = *((PULONG) IndexRow[Count - 1].KeyPart.Key);

            KeyPtr = NULL;
        }

        ASSERT( (Status == STATUS_NO_MORE_MATCHES) || (Status == STATUS_NO_MATCH) );

    } finally {

        NtfsFreePool( RowBuffer );

        if (IndexAcquired) {
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            NtfsReleaseScb( IrpContext, QuotaScb );
            NtfsReleaseScb( IrpContext, OwnerIdScb );
            NtfsReleaseVcb( IrpContext, Vcb );
        }

        if (IndexRow != NULL) {
            NtfsFreePool( IndexRow );
        }

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return;
}


VOID
NtfsDereferenceQuotaControlBlock (
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK *QuotaControl
    )

/*++

Routine Description:

    This routine dereferences the quota control block.
    If reference count is now zero the block will be deallocated.

Arguments:

    Vcb - Vcb for the volume that own the quota contorl block.

    QuotaControl - Quota control block to be derefernece.

Return Value:

    None.

--*/

{
    PQUOTA_CONTROL_BLOCK TempQuotaControl;
    LONG ReferenceCount;
    ULONG OwnerId;
    ULONG QuotaControlDeleteCount;

    PAGED_CODE();

    //
    //  Capture the owner id and delete count;
    //

    OwnerId = (*QuotaControl)->OwnerId;
    QuotaControlDeleteCount = Vcb->QuotaControlDeleteCount;

    //
    //  Update the reference count.
    //

    ReferenceCount = InterlockedDecrement( &(*QuotaControl)->ReferenceCount );

    ASSERT( ReferenceCount >= 0 );

    //
    // If the reference count is not zero we are done.
    //

    if (ReferenceCount != 0) {

        //
        //  Clear the pointer from the FCB and return.
        //

        *QuotaControl = NULL;
        return;
    }

    //
    //  Lock the quota table.
    //

    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        //
        //  Now things get messy.  Check the delete count.
        //

        if (QuotaControlDeleteCount != Vcb->QuotaControlDeleteCount) {

            //
            //  This is a bogus assert, but I want to see if this ever occurs.
            //

            ASSERT( QuotaControlDeleteCount != Vcb->QuotaControlDeleteCount );

            //
            //  Something has already been deleted, the old quota control
            //  block may have been deleted already.  Look it up again.
            //

            TempQuotaControl = RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                             CONTAINING_RECORD( &OwnerId,
                                                                                QUOTA_CONTROL_BLOCK,
                                                                                OwnerId ));

            //
            //  The block was already deleted we are done.
            //

            if (TempQuotaControl == NULL) {
                leave;
            }

        } else {

            TempQuotaControl = *QuotaControl;
            ASSERT( TempQuotaControl == RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                                      CONTAINING_RECORD( &OwnerId,
                                                                                         QUOTA_CONTROL_BLOCK,
                                                                                         OwnerId )));
        }

        //
        //  Verify the reference count is still zero.  The reference count
        //  cannot transision from zero to one while the quota table lock is
        //  held.
        //

        if (TempQuotaControl->ReferenceCount != 0) {
            leave;
        }

        //
        //  Increment the delete count.
        //

        InterlockedIncrement( &Vcb->QuotaControlDeleteCount );

        NtfsFreePool( TempQuotaControl->QuotaControlLock );
        RtlDeleteElementGenericTable( &Vcb->QuotaControlTable,
                                      TempQuotaControl );

    } finally {

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        *QuotaControl = NULL;
    }

    return;
}


VOID
NtfsFixupQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine ensures that the charged field is correct in the
    standard information attribute of a file.  If there is a problem
    the it is fixed.

Arguments:

    Fcb - Pointer to the FCB of the file being opened.

Return Value:

    NONE

--*/

{
    LONGLONG Delta = 0;

    PAGED_CODE();

    ASSERT( FlagOn( Fcb->Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED ));
    ASSERT( NtfsIsExclusiveFcb( Fcb ));

    if (Fcb->OwnerId != QUOTA_INVALID_ID) {

        ASSERT( Fcb->QuotaControl == NULL );

        Fcb->QuotaControl = NtfsInitializeQuotaControlBlock( Fcb->Vcb, Fcb->OwnerId );
    }

    if ((NtfsPerformQuotaOperation( Fcb )) && (!NtfsIsVolumeReadOnly( Fcb->Vcb ))) {

        NtfsCalculateQuotaAdjustment( IrpContext, Fcb, &Delta );

        ASSERT( NtfsAllowFixups || FlagOn( Fcb->Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING ) || (Delta == 0) );

        if (Delta != 0) {
#if DBG

            if (IrpContext->OriginatingIrp != NULL ) {
                PFILE_OBJECT FileObject;

                FileObject = IoGetCurrentIrpStackLocation(
                                IrpContext->OriginatingIrp )->FileObject;

                if (FileObject != NULL && FileObject->FileName.Buffer != NULL) {
                    DebugTrace( 0, Dbg, ( "NtfsFixupQuota: Quota fix up required on %Z of %I64x bytes\n",
                              &FileObject->FileName,
                              Delta ));
                }
            }
#endif

            NtfsUpdateFileQuota( IrpContext, Fcb, &Delta, TRUE, FALSE );
        }
    }

    return;
}


NTSTATUS
NtfsFsQuotaQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingId,
    IN BOOLEAN ReturnSingleEntry,
    IN OUT PFILE_QUOTA_INFORMATION *QuotaInfoOutBuffer,
    IN OUT PULONG Length,
    IN OUT PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine returns the quota information for the volume.

Arguments:

    Vcb - Volume control block for the volume to be quered.

    StartingId - Owner Id after which to start the listing.

    ReturnSingleEntry - Indicates only one entry should be returned.

    QuotaInfoOutBuffer - Buffer to return the data. On return, points at the
    last good entry copied.

    Length - In the size of the buffer. Out the amount of space remaining.

    Ccb - Optional Ccb which is updated with the last returned owner id.

Return Value:

    Returns the status of the operation.

--*/

{
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    PINDEX_KEY KeyPtr;
    PQUOTA_USER_DATA UserData;
    PVOID RowBuffer;
    NTSTATUS Status;
    ULONG OwnerId;
    ULONG Count = 1;
    PREAD_CONTEXT ReadContext = NULL;
    ULONG UserBufferLength = *Length;
    PFILE_QUOTA_INFORMATION OutBuffer = *QuotaInfoOutBuffer;

    PAGED_CODE();

    if (UserBufferLength < sizeof(FILE_QUOTA_INFORMATION)) {

        //
        //  The user buffer is way too small.
        //

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Return nothing if quotas are not enabled.
    //

    if (Vcb->QuotaTableScb == NULL) {

        return STATUS_SUCCESS;
    }

    //
    //  Allocate a buffer large enough for the largest quota entry and key.
    //

    RowBuffer = NtfsAllocatePool( PagedPool, MAXIMUM_QUOTA_ROW );

    //
    //  Look up each entry in the quota index start with the next
    //  requested owner id.
    //

    OwnerId = StartingId + 1;

    if (OwnerId < QUOTA_FISRT_USER_ID) {
        OwnerId = QUOTA_FISRT_USER_ID;
    }

    IndexKey.KeyLength = sizeof( OwnerId );
    IndexKey.Key = &OwnerId;
    KeyPtr = &IndexKey;

    try {

        while (NT_SUCCESS( Status = NtOfsReadRecords( IrpContext,
                                                      Vcb->QuotaTableScb,
                                                      &ReadContext,
                                                      KeyPtr,
                                                      NtOfsMatchAll,
                                                      NULL,
                                                      &Count,
                                                      &IndexRow,
                                                      MAXIMUM_QUOTA_ROW,
                                                      RowBuffer ))) {

            ASSERT( Count == 1 );

            KeyPtr = NULL;
            UserData = IndexRow.DataPart.Data;

            //
            //  Skip this entry if it has been deleted.
            //

            if (FlagOn( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {
                continue;
            }

            if (!NT_SUCCESS( Status = NtfsPackQuotaInfo(&UserData->QuotaSid,
                                                        UserData,
                                                        OutBuffer,
                                                        &UserBufferLength ))) {
                break;
            }

            //
            //  Remember the owner id of the last entry returned.
            //

            OwnerId = *((PULONG) IndexRow.KeyPart.Key);

            if (ReturnSingleEntry) {
                break;
            }

            *QuotaInfoOutBuffer = OutBuffer;
            OutBuffer = Add2Ptr( OutBuffer, OutBuffer->NextEntryOffset );
        }

        //
        //  If we're returning at least one entry, it's a SUCCESS.
        //

        if (UserBufferLength != *Length) {

            Status =  STATUS_SUCCESS;

            //
            //  Set the next entry offset to zero to
            //  indicate list termination. If we are only returning a
            //  single entry, it makes more sense to let the caller
            //  take care of it.
            //

            if (!ReturnSingleEntry) {

                (*QuotaInfoOutBuffer)->NextEntryOffset = 0;
            }

            if (Ccb != NULL) {
                Ccb->LastOwnerId = OwnerId;
            }

            //
            //  Return how much of the buffer was used up.
            //  QuotaInfoOutBuffer already points at the last good entry.
            //

            *Length = UserBufferLength;

        } else if (Status != STATUS_BUFFER_OVERFLOW) {

            //
            //  We return NO_MORE_ENTRIES if we aren't returning any
            //  entries (even when the buffer was large enough).
            //

            Status = STATUS_NO_MORE_ENTRIES;
        }

    } finally {

        NtfsFreePool( RowBuffer );

        if (ReadContext != NULL) {
            NtOfsFreeReadContext( ReadContext );
        }
    }

    return Status;
}


NTSTATUS
NtfsFsQuotaSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine sets the quota information on the volume for the
    owner pasted in from the user buffer.

Arguments:

    Vcb - Volume control block for the volume to be changed.

    FileQuotaInfo - Buffer to return the data.

    Length - The size of the buffer in bytes.

Return Value:

    Returns the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LengthUsed = 0;

    PAGED_CODE();

    //
    //  Return nothing if quotas are not enabled.
    //

    if (Vcb->QuotaTableScb == NULL) {

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    //  Validate the entire buffer before doing any work.
    //

    Status = IoCheckQuotaBufferValidity( FileQuotaInfo,
                                         Length,
                                         &LengthUsed );

    IrpContext->OriginatingIrp->IoStatus.Information = LengthUsed;

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    LengthUsed = 0;

    //
    //  Perform the requested updates.
    //

    while (TRUE) {

        //
        //  Make sure that the administrator limit is not being changed.
        //

        if (RtlEqualSid( SeExports->SeAliasAdminsSid, &FileQuotaInfo->Sid ) &&
            (FileQuotaInfo->QuotaLimit.QuadPart != -1)) {

            //
            //  Reject the request with access denied.
            //

            NtfsRaiseStatus( IrpContext, STATUS_ACCESS_DENIED, NULL, NULL );

        }

        if (FileQuotaInfo->QuotaLimit.QuadPart == -2) {

            Status = NtfsPrepareForDelete( IrpContext,
                                           Vcb,
                                           &FileQuotaInfo->Sid );

            if (!NT_SUCCESS( Status )) {
                break;
            }

        } else {

            NtfsGetOwnerId( IrpContext,
                            &FileQuotaInfo->Sid,
                            TRUE,
                            FileQuotaInfo );
        }

        if (FileQuotaInfo->NextEntryOffset == 0) {
            break;
        }

        //
        //  Advance to the next entry.
        //

        FileQuotaInfo = Add2Ptr( FileQuotaInfo, FileQuotaInfo->NextEntryOffset);
    }

    //
    //  If the quota tracking has been requested and the quotas need to be
    //  repaired then try to repair them now.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED ) &&
        FlagOn( Vcb->QuotaFlags,
                (QUOTA_FLAG_OUT_OF_DATE |
                 QUOTA_FLAG_CORRUPT |
                 QUOTA_FLAG_PENDING_DELETES) )) {

        NtfsPostRepairQuotaIndex( IrpContext, Vcb );
    }

    return Status;
}


NTSTATUS
NtfsQueryQuotaUserSidList (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_GET_QUOTA_INFORMATION SidList,
    IN OUT PFILE_QUOTA_INFORMATION QuotaInfoOutBuffer,
    IN OUT PULONG BufferLength,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine query for the quota data for each user specified in the
    user provided sid list.

Arguments:

    Vcb - Supplies a pointer to the volume control block.

    SidList - Supplies a pointer to the Sid list.  The list has already
              been validated.

    QuotaInfoOutBuffer - Indicates where the retrived query data should be placed.

    BufferLength - Indicates that size of the buffer, and is updated with the
                  amount of data actually placed in the buffer.

    ReturnSingleEntry - Indicates if just one entry should be returned.

Return Value:

    Returns the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesRemaining = *BufferLength;
    PFILE_QUOTA_INFORMATION LastEntry = QuotaInfoOutBuffer;
    ULONG OwnerId;

    PAGED_CODE( );

    //
    //  Loop through each of the entries.
    //

    while (TRUE) {

        //
        //  Get the owner id.
        //

        OwnerId = NtfsGetOwnerId( IrpContext,
                                  &SidList->Sid,
                                  FALSE,
                                  NULL );

       if (OwnerId != QUOTA_INVALID_ID) {

            //
            //  Send ownerid and ask for a single entry.
            //

            Status = NtfsFsQuotaQueryInfo( IrpContext,
                                           Vcb,
                                           OwnerId - 1,
                                           TRUE,
                                           &QuotaInfoOutBuffer,
                                           &BytesRemaining,
                                           NULL );

        } else {

            //
            //  Send back zeroed data alongwith the Sid.
            //

            Status = NtfsPackQuotaInfo( &SidList->Sid,
                                        NULL,
                                        QuotaInfoOutBuffer,
                                        &BytesRemaining );
        }

        //
        //  Bail out if we got a real error.
        //

        if (!NT_SUCCESS( Status ) && (Status != STATUS_NO_MORE_ENTRIES)) {

            break;
        }

        if (ReturnSingleEntry) {

            break;
        }

        //
        //  Make a note of the last entry filled in.
        //

        LastEntry = QuotaInfoOutBuffer;

        //
        //  If we've exhausted the SidList, we're done
        //

        if (SidList->NextEntryOffset == 0) {
            break;
        }

        SidList =  Add2Ptr( SidList, SidList->NextEntryOffset );

        ASSERT(QuotaInfoOutBuffer->NextEntryOffset > 0);
        QuotaInfoOutBuffer = Add2Ptr( QuotaInfoOutBuffer,
                                      QuotaInfoOutBuffer->NextEntryOffset );
    }

    //
    //  Set the next entry offset to zero to
    //  indicate list termination.
    //

    if (BytesRemaining != *BufferLength) {

        LastEntry->NextEntryOffset = 0;
        Status =  STATUS_SUCCESS;
    }

    //
    //  Update the buffer length to reflect what's left.
    //  If we've copied anything at all, we must return SUCCESS.
    //

    ASSERT( (BytesRemaining == *BufferLength) || (Status == STATUS_SUCCESS ) );
    *BufferLength = BytesRemaining;

    return Status;
}


NTSTATUS
NtfsPackQuotaInfo (
    IN PSID Sid,
    IN PQUOTA_USER_DATA QuotaUserData OPTIONAL,
    IN PFILE_QUOTA_INFORMATION OutBuffer,
    IN OUT PULONG OutBufferSize
    )

/*++
Routine Description:

    This is an internal routine that fills a given FILE_QUOTA_INFORMATION
    structure with information from a given QUOTA_USER_DATA structure.

Arguments:

    Sid - SID to be copied. Same as the one embedded inside the USER_DATA struct.
    This routine doesn't care if it's a valid sid.

    QuotaUserData - Source of data

    QuotaInfoBufferPtr - Buffer to have user data copied in to.

    OutBufferSize - IN size of the buffer, OUT size of the remaining buffer.
--*/

{
    ULONG SidLength;
    ULONG NextOffset;
    ULONG EntrySize;

    SidLength = RtlLengthSid( Sid );
    EntrySize = SidLength +  FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid );

    //
    //  Abort if this entry won't fit in the buffer.
    //

    if (*OutBufferSize < EntrySize) {

        return STATUS_BUFFER_OVERFLOW;
    }

    if (ARGUMENT_PRESENT(QuotaUserData)) {

        //
        //  Fill in the user buffer for this entry.
        //

        OutBuffer->ChangeTime.QuadPart = QuotaUserData->QuotaChangeTime;
        OutBuffer->QuotaUsed.QuadPart = QuotaUserData->QuotaUsed;
        OutBuffer->QuotaThreshold.QuadPart = QuotaUserData->QuotaThreshold;
        OutBuffer->QuotaLimit.QuadPart = QuotaUserData->QuotaLimit;

    } else {

        //
        //  Return all zeros for the data, up until the Sid.
        //

        RtlZeroMemory( OutBuffer, FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid) );
    }

    OutBuffer->SidLength = SidLength;
    RtlCopyMemory( &OutBuffer->Sid,
                   Sid,
                   SidLength );

    //
    //  Calculate the next offset.
    //

    NextOffset = QuadAlign( EntrySize );

    //
    //  Add the offset to the amount used.
    //  NextEntryOffset may be sligthly larger than Length due to
    //  rounding of the previous entry size to longlong.
    //

    if (*OutBufferSize > NextOffset) {

        *OutBufferSize -= NextOffset;
        OutBuffer->NextEntryOffset = NextOffset;

    } else {

        //
        //  We did have enough room for this entry, but quad-alignment made
        //  it look like we didn't. Return the last few bytes left
        //  (what we lost in rounding up) just for correctness, although
        //  those really won't be of much use. The NextEntryOffset will be
        //  zeroed subsequently by the caller.
        //  Note that the OutBuffer is pointing at the _beginning_ of the
        //  last entry returned in this case.
        //

        ASSERT( *OutBufferSize >= EntrySize );
        *OutBufferSize -= EntrySize;
        OutBuffer->NextEntryOffset = EntrySize;
    }

    return STATUS_SUCCESS;
}


ULONG
NtfsGetOwnerId (
    IN PIRP_CONTEXT IrpContext,
    IN PSID Sid,
    IN BOOLEAN CreateNew,
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo OPTIONAL
    )

/*++

Routine Description:

    This routine determines the owner id for the requested SID.  First the
    Sid is looked up in the Owner Id index.  If the entry exists, then that
    owner id is returned.  If the sid does not exist then  new entry is
    created in the owner id index.

Arguments:

    Sid - Security id to determine the owner id.

    CreateNew - Create a new id if necessary.

    FileQuotaInfo - Optional quota data to update quota index with.

Return Value:

    ULONG - Owner Id for the security id. QUOTA_INVALID_ID is returned if id
        did not exist and CreateNew was FALSE.

--*/

{
    ULONG OwnerId;
    ULONG DefaultId;
    ULONG SidLength;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    PQUOTA_USER_DATA NewQuotaData = NULL;
    QUICK_INDEX_HINT QuickIndexHint;
    PSCB QuotaScb;
    PVCB Vcb = IrpContext->Vcb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;

    BOOLEAN ExistingRecord;

    PAGED_CODE();

    //
    //  Determine the Sid length.
    //

    SidLength = RtlLengthSid( Sid );

    IndexKey.KeyLength = SidLength;
    IndexKey.Key = Sid;

    //
    //  If there is quota information to update or there are pending deletes
    //  then long path must be taken where the user quota entry is found.
    //

    if (FileQuotaInfo == NULL) {

        //
        //  Acquire the owner id index shared.
        //

        NtfsAcquireSharedScb( IrpContext, OwnerIdScb );

        try {

            //
            //  Assume the Sid is in the index.
            //

            Status = NtOfsFindRecord( IrpContext,
                                      OwnerIdScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      NULL );

            //
            //  If the sid was found then capture is value.
            //

            if (NT_SUCCESS( Status )) {

                ASSERT( IndexRow.DataPart.DataLength == sizeof( ULONG ));
                OwnerId = *((PULONG) IndexRow.DataPart.Data);

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );
            }

        } finally {
            NtfsReleaseScb( IrpContext, OwnerIdScb );
        }

        //
        //  If the sid was found and there are no pending deletes, we are done.
        //

        if (NT_SUCCESS(Status)) {

            if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {
                return OwnerId;
            }

            //
            //  Look up the actual record to see if it is deleted.
            //

            QuotaScb = Vcb->QuotaTableScb;
            NtfsAcquireSharedScb( IrpContext, QuotaScb );

            try {

                IndexKey.KeyLength = sizeof(ULONG);
                IndexKey.Key = &OwnerId;

                Status = NtOfsFindRecord( IrpContext,
                                          QuotaScb,
                                          &IndexKey,
                                          &IndexRow,
                                          &MapHandle,
                                          NULL );

                if (!NT_SUCCESS( Status )) {

                    ASSERT( NT_SUCCESS( Status ));
                    NtfsMarkQuotaCorrupt( IrpContext, Vcb );
                    OwnerId = QUOTA_INVALID_ID;
                    leave;
                }

                if (FlagOn( ((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaFlags,
                            QUOTA_FLAG_ID_DELETED )) {

                    //
                    //  Return invalid user.
                    //

                    OwnerId = QUOTA_INVALID_ID;
                }

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );

            } finally {

                NtfsReleaseScb( IrpContext, QuotaScb );
            }

            //
            //  If an active id was found or caller does not want a new
            //  created then return.
            //

            if ((OwnerId != QUOTA_INVALID_ID) || !CreateNew) {
                return OwnerId;
            }

        } else if (!CreateNew) {

            //
            //  Just return QUOTA_INVALID_ID.
            //

            return QUOTA_INVALID_ID;
        }
    }

    //
    //  If we have the quotatable resource, we should have it exclusively.
    //

    ASSERT( CreateNew );
    ASSERT( !ExIsResourceAcquiredSharedLite( Vcb->QuotaTableScb->Fcb->Resource ) ||
            ExIsResourceAcquiredExclusiveLite( Vcb->QuotaTableScb->Fcb->Resource ));

    //
    //  Acquire Owner id and quota index exclusive.
    //

    QuotaScb = Vcb->QuotaTableScb;
    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );

    NtOfsInitializeMapHandle( &MapHandle );

    try {

        //
        //  Verify that the sid is still not in the index.
        //

        IndexKey.KeyLength = SidLength;
        IndexKey.Key = Sid;

        Status = NtOfsFindRecord( IrpContext,
                                  OwnerIdScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        //
        //  If the sid was found then capture the owner id.
        //

        ExistingRecord = NT_SUCCESS(Status);

        if (ExistingRecord) {

            ASSERT( IndexRow.DataPart.DataLength == sizeof( ULONG ));
            OwnerId = *((PULONG) IndexRow.DataPart.Data);

            if ((FileQuotaInfo == NULL) &&
                !FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

                leave;
            }

            //
            //  Release the index map handle.
            //

            NtOfsReleaseMap( IrpContext, &MapHandle );

        } else {

            //
            //  Allocate a new owner id and update the owner index.
            //

            OwnerId = Vcb->QuotaOwnerId;
            Vcb->QuotaOwnerId += 1;

            IndexRow.KeyPart.KeyLength = SidLength;
            IndexRow.KeyPart.Key = Sid;
            IndexRow.DataPart.Data = &OwnerId;
            IndexRow.DataPart.DataLength = sizeof(OwnerId);

            NtOfsAddRecords( IrpContext,
                             OwnerIdScb,
                             1,
                             &IndexRow,
                             FALSE );
        }

        //
        //  Allocate space for the new quota user data.
        //

        NewQuotaData = NtfsAllocatePool( PagedPool,
                                         SIZEOF_QUOTA_USER_DATA + SidLength);

        if (ExistingRecord) {

            //
            //  Find the existing record and update it.
            //

            IndexKey.KeyLength = sizeof( ULONG );
            IndexKey.Key = &OwnerId;

            RtlZeroMemory( &QuickIndexHint, sizeof( QuickIndexHint ));

            Status = NtOfsFindRecord( IrpContext,
                                      QuotaScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      &QuickIndexHint );

            if (!NT_SUCCESS( Status )) {

                ASSERT( NT_SUCCESS( Status ));
                NtfsMarkQuotaCorrupt( IrpContext, Vcb );
                OwnerId = QUOTA_INVALID_ID;
                leave;
            }

            ASSERT( IndexRow.DataPart.DataLength == SIZEOF_QUOTA_USER_DATA + SidLength );

            RtlCopyMemory( NewQuotaData, IndexRow.DataPart.Data, IndexRow.DataPart.DataLength );

            ASSERT( RtlEqualMemory( &NewQuotaData->QuotaSid, Sid, SidLength ));

            //
            //  Update the changed fields in the record.
            //

            if (FileQuotaInfo != NULL) {

                ClearFlag( NewQuotaData->QuotaFlags, QUOTA_FLAG_DEFAULT_LIMITS );
                NewQuotaData->QuotaThreshold = FileQuotaInfo->QuotaThreshold.QuadPart;
                NewQuotaData->QuotaLimit = FileQuotaInfo->QuotaLimit.QuadPart;
                KeQuerySystemTime( (PLARGE_INTEGER) &NewQuotaData->QuotaChangeTime );

            } else if (!FlagOn( NewQuotaData->QuotaFlags, QUOTA_FLAG_ID_DELETED )) {

                //
                //  There is nothing to update just return.
                //

                leave;
            }

            //
            //  Always clear the deleted flag.
            //

            ClearFlag( NewQuotaData->QuotaFlags, QUOTA_FLAG_ID_DELETED );
            ASSERT( (OwnerId != Vcb->AdministratorId) || (NewQuotaData->QuotaLimit == -1) );

            //
            // The key length does not change.
            //

            IndexRow.KeyPart.Key = &OwnerId;
            ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
            IndexRow.DataPart.Data = NewQuotaData;
            IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

            NtOfsUpdateRecord( IrpContext,
                               QuotaScb,
                               1,
                               &IndexRow,
                               &QuickIndexHint,
                               &MapHandle );

            leave;
        }

        if (FileQuotaInfo == NULL) {

            //
            //  Look up the default quota limits.
            //

            DefaultId = QUOTA_DEFAULTS_ID;
            IndexKey.KeyLength = sizeof( ULONG );
            IndexKey.Key = &DefaultId;

            Status = NtOfsFindRecord( IrpContext,
                                      QuotaScb,
                                      &IndexKey,
                                      &IndexRow,
                                      &MapHandle,
                                      NULL );

            if (!NT_SUCCESS( Status )) {

                ASSERT( NT_SUCCESS( Status ));
                NtfsRaiseStatus( IrpContext,
                                 STATUS_QUOTA_LIST_INCONSISTENT,
                                 NULL,
                                 Vcb->QuotaTableScb->Fcb );
            }

            ASSERT( IndexRow.DataPart.DataLength >= SIZEOF_QUOTA_USER_DATA );

            //
            //  Initialize the new quota entry with the defaults.
            //

            RtlCopyMemory( NewQuotaData,
                           IndexRow.DataPart.Data,
                           SIZEOF_QUOTA_USER_DATA );

            ClearFlag( NewQuotaData->QuotaFlags, ~QUOTA_FLAG_USER_MASK );

        } else {

            //
            //  Initialize the new record with the new data.
            //

            RtlZeroMemory( NewQuotaData, SIZEOF_QUOTA_USER_DATA );

            NewQuotaData->QuotaVersion = QUOTA_USER_VERSION;
            NewQuotaData->QuotaThreshold = FileQuotaInfo->QuotaThreshold.QuadPart;
            NewQuotaData->QuotaLimit = FileQuotaInfo->QuotaLimit.QuadPart;
        }

        ASSERT( !RtlEqualSid( SeExports->SeAliasAdminsSid, Sid ) ||
                (NewQuotaData->QuotaThreshold == -1) );

        //
        //  Copy the Sid into the new record.
        //

        RtlCopyMemory( &NewQuotaData->QuotaSid, Sid, SidLength );
        KeQuerySystemTime( (PLARGE_INTEGER) &NewQuotaData->QuotaChangeTime );

        //
        //  Add the new quota data record to the index.
        //

        IndexRow.KeyPart.KeyLength = sizeof( ULONG );
        IndexRow.KeyPart.Key = &OwnerId;
        IndexRow.DataPart.Data = NewQuotaData;
        IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA + SidLength;

        NtOfsAddRecords( IrpContext,
                         QuotaScb,
                         1,
                         &IndexRow,
                         TRUE );

    } finally {

        if (NewQuotaData != NULL) {
            NtfsFreePool( NewQuotaData );
        }

        //
        //  Release the index map handle and index resources.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, QuotaScb );
        NtfsReleaseScb( IrpContext, OwnerIdScb );
    }

    return OwnerId;
}


VOID
NtfsGetRemainingQuota (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG OwnerId,
    OUT PULONGLONG RemainingQuota,
    OUT PULONGLONG TotalQuota,
    IN OUT PQUICK_INDEX_HINT QuickIndexHint OPTIONAL
    )

/*++

Routine Description:

    This routine returns the remaining amount of quota a user has before a
    the quota limit is reached.

Arguments:

    Fcb - Fcb whose quota usage is being checked.

    OwnerId - Supplies the owner id to look up.

    RemainingQuota - Returns the remaining amount of quota in bytes.

    TotalQuota - Returns the total amount of quota in bytes for the given sid.

    QuickIndexHint - Supplies an optional hint where to look of the value.

Return Value:

    None

--*/

{
    PQUOTA_USER_DATA UserData;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    NTSTATUS Status;
    PVCB Vcb = IrpContext->Vcb;

    PAGED_CODE();

    //
    //  Initialize the map handle.
    //

    NtOfsInitializeMapHandle( &MapHandle );
    NtfsAcquireSharedScb( IrpContext, Vcb->QuotaTableScb );

    try {

        IndexKey.KeyLength = sizeof(ULONG);
        IndexKey.Key = &OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  QuickIndexHint );

        if (!NT_SUCCESS( Status )) {

            //
            //  This look up should not fail.
            //

            ASSERT( NT_SUCCESS( Status ));

            //
            //  There is one case where this could occur.  That is a
            //  owner id could be deleted while this ccb was in use.
            //

            *RemainingQuota = 0;
            *TotalQuota = 0;
            leave;
        }

        UserData = IndexRow.DataPart.Data;

        if (UserData->QuotaUsed >= UserData->QuotaLimit) {

            *RemainingQuota = 0;

        } else {

            *RemainingQuota = UserData->QuotaLimit - UserData->QuotaUsed;
        }

        *TotalQuota = UserData->QuotaLimit;

    } finally {

        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }

    return;
}


PQUOTA_CONTROL_BLOCK
NtfsInitializeQuotaControlBlock (
    IN PVCB Vcb,
    IN ULONG OwnerId
    )

/*++

Routine Description:

    This routine returns the quota control block field specified owner.  First
    a lookup is done in the quota control table for an existing quota control
    block.  If there is no quota control block, then a new one is created.

Arguments:

    Vcb - Supplies the volume control block.

    OwnerId - Supplies the requested owner id.

Return Value:

    Returns a quota control block for the owner.

--*/

{
    PQUOTA_CONTROL_BLOCK QuotaControl;
    BOOLEAN NewEntry;
    PQUOTA_CONTROL_BLOCK InitQuotaControl;
    PFAST_MUTEX Lock = NULL;
    PVOID NodeOrParent;
    TABLE_SEARCH_RESULT SearchResult;

    PAGED_CODE();

    ASSERT( OwnerId != 0 );

    //
    //  Lock the quota table.
    //

    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        InitQuotaControl = Vcb->QuotaControlTemplate;
        InitQuotaControl->OwnerId = OwnerId;

        QuotaControl = RtlLookupElementGenericTableFull( &Vcb->QuotaControlTable,
                                                         InitQuotaControl,
                                                         &NodeOrParent,
                                                         &SearchResult );

        if (QuotaControl == NULL) {

            //
            //  Allocate and initialize the lock.
            //

            Lock = NtfsAllocatePoolWithTag( NonPagedPool,
                                            sizeof( FAST_MUTEX ),
                                            'QftN' );

            ExInitializeFastMutex( Lock );

            //
            //  Insert table element into table.
            //

            QuotaControl = RtlInsertElementGenericTableFull( &Vcb->QuotaControlTable,
                                                             InitQuotaControl,
                                                             sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA,
                                                             &NewEntry,
                                                             NodeOrParent,
                                                             SearchResult );

            ASSERT( IsQuadAligned( &QuotaControl->QuickIndexHint ));

            QuotaControl->QuotaControlLock = Lock;
            Lock = NULL;
        }

        //
        //  Update the reference count and add set the pointer in the Fcb.
        //

        InterlockedIncrement( &QuotaControl->ReferenceCount );

        ASSERT( OwnerId == QuotaControl->OwnerId );

    } finally {

        //
        //  Clean up.
        //

        if (Lock != NULL) {
            NtfsFreePool( Lock );
        }

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

    }

    return QuotaControl;
}


VOID
NtfsInitializeQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine opens the quota index for the volume.  If the index does not
    exist it is created and initialized.

Arguments:

    Fcb - Pointer to Fcb for the quota file.

    Vcb - Volume control block for volume be mounted.

Return Value:

    None

--*/

{
    ULONG Key;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    MAP_HANDLE MapHandle;
    QUOTA_USER_DATA QuotaData;
    UNICODE_STRING IndexName = CONSTANT_UNICODE_STRING( L"$Q" );

    PAGED_CODE();

    //
    //  Initialize quota table and fast mutex.
    //

    ExInitializeFastMutex( &Vcb->QuotaControlLock );

    RtlInitializeGenericTable( &Vcb->QuotaControlTable,
                               NtfsQuotaTableCompare,
                               NtfsQuotaTableAllocate,
                               NtfsQuotaTableFree,
                               NULL );

ReInitializeQuotaIndex:

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      IndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_ULONG,
                      NtOfsCollateUlong,
                      NULL,
                      &Vcb->QuotaTableScb );

    IndexName.Buffer = L"$O";

    NtOfsCreateIndex( IrpContext,
                      Fcb,
                      IndexName,
                      CREATE_OR_OPEN,
                      0,
                      COLLATION_NTOFS_SID,
                      NtOfsCollateSid,
                      NULL,
                      &Vcb->OwnerIdTableScb );

    //
    //  Find the next owner id to allocate.
    //

    NtfsAcquireExclusiveScb( IrpContext, Vcb->QuotaTableScb );

    try {

        //
        //  Initialize quota delete secquence number.
        //

        Vcb->QuotaDeleteSecquence = 1;

        //
        //  Load the quota flags.
        //

        Key = QUOTA_DEFAULTS_ID;
        IndexRow.KeyPart.KeyLength = sizeof( ULONG );
        IndexRow.KeyPart.Key = &Key;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexRow.KeyPart,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL);

        if (NT_SUCCESS( Status )) {

            //
            //  Make sure this is the correct version.
            //

            if (((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaVersion > QUOTA_USER_VERSION) {

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );

                //
                //  Wrong version close the quota index this will
                //  pervent use from doing anything with quotas.
                //

                NtOfsCloseIndex( IrpContext, Vcb->QuotaTableScb );
                Vcb->QuotaTableScb = NULL;

                leave;
            }

            //
            //  If this is an old version delete it.
            //

            if (((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaVersion < QUOTA_USER_VERSION) {

                DebugTrace( 0, Dbg, ( "NtfsInitializeQuotaIndex: Deleting version 1 quota index\n" ));

                //
                //  Release the index map handle.
                //

                NtOfsReleaseMap( IrpContext, &MapHandle );

                //
                // Increment the cleanup count so the FCB does not
                // go away.
                //

                Fcb->CleanupCount += 1;

                //
                //  This is an old version of the quota file
                //  delete it the owner id index and start over again.
                //

                NtOfsDeleteIndex( IrpContext, Fcb, Vcb->QuotaTableScb );

                NtOfsCloseIndex( IrpContext, Vcb->QuotaTableScb );
                Vcb->QuotaTableScb = NULL;

                //
                //  Delete the owner index too.
                //

                NtOfsDeleteIndex( IrpContext, Fcb, Vcb->OwnerIdTableScb );

                NtOfsCloseIndex( IrpContext, Vcb->OwnerIdTableScb );
                Vcb->OwnerIdTableScb = NULL;

                NtfsCommitCurrentTransaction( IrpContext );

                //
                // Restore the cleanup count
                //

                Fcb->CleanupCount -= 1;

                IndexName.Buffer = L"$Q";

                goto ReInitializeQuotaIndex;
            }

            //
            //  The index already exists, just initialize the quota
            //  fields in the VCB.
            //

            Vcb->QuotaFlags = ((PQUOTA_USER_DATA) IndexRow.DataPart.Data)->QuotaFlags;

            //
            //  Release the index map handle.
            //

            NtOfsReleaseMap( IrpContext, &MapHandle );

        } else if (Status == STATUS_NO_MATCH) {

            //
            //  The index was newly created.
            //  Create a default quota data row.
            //

            Key = QUOTA_DEFAULTS_ID;

            RtlZeroMemory( &QuotaData, sizeof( QUOTA_USER_DATA ));

            //
            //  Indicate that the quota needs to be rebuilt.
            //

            QuotaData.QuotaVersion = QUOTA_USER_VERSION;

            QuotaData.QuotaFlags = QUOTA_FLAG_DEFAULT_LIMITS;

            QuotaData.QuotaThreshold = MAXULONGLONG;
            QuotaData.QuotaLimit = MAXULONGLONG;
            KeQuerySystemTime( (PLARGE_INTEGER) &QuotaData.QuotaChangeTime );

            IndexRow.KeyPart.KeyLength = sizeof( ULONG );
            IndexRow.KeyPart.Key = &Key;
            IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;
            IndexRow.DataPart.Data = &QuotaData;

            NtOfsAddRecords( IrpContext,
                             Vcb->QuotaTableScb,
                             1,
                             &IndexRow,
                             TRUE );

            Vcb->QuotaOwnerId = QUOTA_FISRT_USER_ID;

            Vcb->QuotaFlags = QuotaData.QuotaFlags;
        }

        Key = MAXULONG;
        IndexRow.KeyPart.KeyLength = sizeof( ULONG );
        IndexRow.KeyPart.Key = &Key;

        Status = NtOfsFindLastRecord( IrpContext,
                                      Vcb->QuotaTableScb,
                                      &IndexRow.KeyPart,
                                      &IndexRow,
                                      &MapHandle );

        if (!NT_SUCCESS( Status )) {

            //
            //  This call should never fail.
            //

            ASSERT( NT_SUCCESS( Status) );
            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_CORRUPT);
            leave;
        }

        Key = *((PULONG) IndexRow.KeyPart.Key) + 1;

        if (Key < QUOTA_FISRT_USER_ID) {
            Key = QUOTA_FISRT_USER_ID;
        }

        Vcb->QuotaOwnerId = Key;

        //
        //  Release the index map handle.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );

        //
        //  Get the administrator ID so it can be protected from quota
        //  limits.
        //

        Vcb->AdministratorId = NtfsGetOwnerId( IrpContext,
                                               SeExports->SeAliasAdminsSid,
                                               TRUE,
                                               NULL );

        if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED )) {

            //
            //  Allocate and initialize the template control block.
            //  Allocate enough space in the quota control block for the index
            //  data part. This is used as the new record when calling update
            //  record.  This template is only allocated once and then it is
            //  saved in the vcb.
            //

            Vcb->QuotaControlTemplate = NtfsAllocatePoolWithTag( PagedPool,
                                                                 sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA,
                                                                 'QftN' );

            RtlZeroMemory( Vcb->QuotaControlTemplate,
                           sizeof( QUOTA_CONTROL_BLOCK ) +
                           SIZEOF_QUOTA_USER_DATA );

            Vcb->QuotaControlTemplate->NodeTypeCode = NTFS_NTC_QUOTA_CONTROL;
            Vcb->QuotaControlTemplate->NodeByteSize = sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA;
        }

        //
        //  Fix up the quota on the root directory.
        //

        NtfsConditionallyFixupQuota( IrpContext, Vcb->RootIndexScb->Fcb );

    } finally {

        if (Vcb->QuotaTableScb != NULL) {
            NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
        }
    }

    //
    //  If the quota tracking has been requested and the quotas need to be
    //  repaired then try to repair them now.
    //

    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED) &&
        FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE | QUOTA_FLAG_CORRUPT | QUOTA_FLAG_PENDING_DELETES )) {
        NtfsPostRepairQuotaIndex( IrpContext, Vcb );
    }

    return;
}


VOID
NtfsMarkUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine marks a user's quota data entry to indicate that the user
    has exceeded quota.  The event is also logged.

Arguments:

    Context - Supplies a pointer to the referenced quota control block.

Return Value:

    None.

--*/

{
    PQUOTA_CONTROL_BLOCK QuotaControl = Context;
    PVCB Vcb = IrpContext->Vcb;
    LARGE_INTEGER CurrentTime;
    PQUOTA_USER_DATA UserData;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    NTSTATUS Status;
    BOOLEAN QuotaTableAcquired = FALSE;

    PAGED_CODE();

    DebugTrace( 0, Dbg, ( "NtfsMarkUserLimit: Quota limit called for owner id = %lx\n", QuotaControl->OwnerId ));

    NtOfsInitializeMapHandle( &MapHandle );

    //
    //  Acquire the VCB shared and check whether we should
    //  continue.
    //

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        if (!NtfsIsVcbAvailable( Vcb )) {

            //
            //  The volume is going away, bail out.
            //

            Status = STATUS_VOLUME_DISMOUNTED;
            leave;
        }

        NtfsAcquireExclusiveScb( IrpContext, Vcb->QuotaTableScb );
        QuotaTableAcquired = TRUE;

        //
        //  Get the user's quota data entry.
        //

        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &QuotaControl->OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuotaControl->QuickIndexHint );

        if (!NT_SUCCESS( Status ) ||
            (IndexRow.DataPart.DataLength < SIZEOF_QUOTA_USER_DATA + FIELD_OFFSET( SID, SubAuthority )) ||
             ((ULONG) SeLengthSid( &(((PQUOTA_USER_DATA) (IndexRow.DataPart.Data))->QuotaSid)) + SIZEOF_QUOTA_USER_DATA !=
                IndexRow.DataPart.DataLength)) {

            //
            //  This look up should not fail.
            //

            ASSERT( NT_SUCCESS( Status ));
            ASSERTMSG(( "NTFS: corrupt quotasid\n" ), FALSE);

            NtfsMarkQuotaCorrupt( IrpContext, IrpContext->Vcb );
            leave;
        }

        //
        //  Space is allocated for the new record after the quota control
        //  block.
        //

        UserData = (PQUOTA_USER_DATA) (QuotaControl + 1);
        ASSERT( IndexRow.DataPart.DataLength >= SIZEOF_QUOTA_USER_DATA );

        RtlCopyMemory( UserData,
                       IndexRow.DataPart.Data,
                       SIZEOF_QUOTA_USER_DATA );

        KeQuerySystemTime( &CurrentTime );
        UserData->QuotaChangeTime = CurrentTime.QuadPart;

        //
        //  Indicate that user exceeded quota.
        //

        UserData->QuotaExceededTime = CurrentTime.QuadPart;
        SetFlag( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED );

        //
        //  Log the limit event.  If this fails then leave.
        //

        if (!NtfsLogEvent( IrpContext,
                           IndexRow.DataPart.Data,
                           IO_FILE_QUOTA_LIMIT,
                           STATUS_DISK_FULL )) {
            leave;
        }

        //
        // The key length does not change.
        //

        IndexRow.KeyPart.Key = &QuotaControl->OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
        IndexRow.DataPart.Data = UserData;
        IndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

        NtOfsUpdateRecord( IrpContext,
                           Vcb->QuotaTableScb,
                           1,
                           &IndexRow,
                           &QuotaControl->QuickIndexHint,
                           &MapHandle );

    } except( NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    //
    //  The request will be retied if the status is can't wait or log file full.
    //

    if ((Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL)) {

        //
        //  If we will not be called back, then no matter what happened
        //  dereference the quota control block and clear the post flag.
        //

        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
        ASSERT( FlagOn( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED ));
        ClearFlag( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED );
        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

        NtfsDereferenceQuotaControlBlock( Vcb, &QuotaControl );
    }

    //
    //  Release the index map handle.
    //

    NtOfsReleaseMap( IrpContext, &MapHandle );

    if (QuotaTableAcquired) {

        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }

    NtfsReleaseVcb( IrpContext, Vcb );

    if (!NT_SUCCESS( Status )) {

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    return;
}


VOID
NtfsMoveQuotaOwner (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSECURITY_DESCRIPTOR Security
    )

/*++

Routine Description:

    This routine changes the owner id and quota charged for a file when the
    file owner is changed.

Arguments:

    Fcb - Pointer to fcb being opened.

    Security - Pointer to the new security descriptor

Return Value:

    None.

--*/

{
    LONGLONG QuotaCharged;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PSTANDARD_INFORMATION StandardInformation;
    PSID Sid = NULL;
    ULONG OwnerId;
    NTSTATUS Status;
    BOOLEAN OwnerDefaulted;

    PAGED_CODE();

    if (!NtfsPerformQuotaOperation(Fcb)) {
        return;
    }

    //
    //  Extract the security id from the security descriptor.
    //

    Status = RtlGetOwnerSecurityDescriptor( Security,
                                            &Sid,
                                            &OwnerDefaulted );

    if (!NT_SUCCESS( Status )) {
        NtfsRaiseStatus( IrpContext, Status, NULL, Fcb );
    }

    //
    //  If we didn't get a SID then we can't move the owner.
    //

    if (Sid == NULL) {

        return;
    }

    //
    //  Generate a owner id for the Fcb.
    //

    OwnerId = NtfsGetOwnerId( IrpContext, Sid, TRUE, NULL );

    if (OwnerId == Fcb->OwnerId) {

        //
        //  The owner is not changing so just return.
        //

        return;
    }

    //
    //  Initialize the context structure and map handle.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Preacquire the quota index exclusive since an entry may need to
    //  be added.
    //

    NtfsAcquireExclusiveScb( IrpContext, Fcb->Vcb->QuotaTableScb );

    try {

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        QuotaCharged = -((LONGLONG) StandardInformation->QuotaCharged);

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  Remove the quota from the old owner.
        //

        NtfsUpdateFileQuota( IrpContext,
                             Fcb,
                             &QuotaCharged,
                             TRUE,
                             FALSE );

        //
        //  Set the new owner id.
        //

        Fcb->OwnerId = OwnerId;

        //
        //  Note the old quota block is kept around until the operation is
        //  complete.  This is so the recovery code does not have allocate
        //  a memory if the old quota block is needed.  This is done in
        //  NtfsCommonSetSecurityInfo.
        //

        Fcb->QuotaControl = NtfsInitializeQuotaControlBlock( Fcb->Vcb, OwnerId );

        QuotaCharged = -QuotaCharged;

        //
        //  Try to charge the quota to the new owner.
        //

        NtfsUpdateFileQuota( IrpContext,
                     Fcb,
                     &QuotaCharged,
                     TRUE,
                     TRUE );

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsReleaseScb( IrpContext, Fcb->Vcb->QuotaTableScb );
    }

    return;
}


VOID
NtfsMarkQuotaCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine attempts to mark the quota index corrupt.  It will
    also attempt post a request to rebuild the quota index.

Arguments:

    Vcb - Supplies a pointer the the volume who quota data is corrupt.

Return Value:

    None

--*/

{

    DebugTrace( 0, Dbg, ( "NtfsMarkQuotaCorrupt: Marking quota dirty on Vcb = %lx\n", Vcb));

    if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_CORRUPT )) {

        //
        //  If the quota were not previous corrupt then log an event
        //  so others know this occured.
        //

        NtfsLogEvent( IrpContext,
                      NULL,
                      IO_FILE_QUOTA_CORRUPT,
                      STATUS_FILE_CORRUPT_ERROR );
    }

    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_CORRUPT );
    SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS );

    //
    //  Since the index is corrupt there is no point in tracking the
    //  quota usage.
    //

    ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED );

    ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

    //
    //  Do not save the flags here since the quota scb may be acquired
    //  shared.  The repair will save the flags when it runs.
    //  Try to fix the problems.
    //

    NtfsPostRepairQuotaIndex( IrpContext, Vcb );

    return;
}


VOID
NtfsPostRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine posts a request to recalculate all of the user quota data.

Arguments:

    Vcb - Volume control block for volume whos quota needs to be fixed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    try {

        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

        if (FlagOn( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING)) {
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            leave;
        }

        if (Vcb->QuotaControlTemplate == NULL) {

            //
            //  Allocate and initialize the template control block.
            //  Allocate enough space in the quota control block for the index
            //  data part. This is used as the new record when calling update
            //  record.  This template is only allocated once and then it is
            //  saved in the vcb.
            //

            Vcb->QuotaControlTemplate = NtfsAllocatePoolWithTag( PagedPool,
                                                                 sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA,
                                                                 'QftN' );

            RtlZeroMemory( Vcb->QuotaControlTemplate,
                           sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA );

            Vcb->QuotaControlTemplate->NodeTypeCode = NTFS_NTC_QUOTA_CONTROL;
            Vcb->QuotaControlTemplate->NodeByteSize = sizeof( QUOTA_CONTROL_BLOCK ) + SIZEOF_QUOTA_USER_DATA;

        }

        SetFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_POSTED );
        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

        //
        //  Post this special request.
        //

        NtfsPostSpecial( IrpContext,
                         Vcb,
                         NtfsRepairQuotaIndex,
                         NULL );


    } finally {

        if (AbnormalTermination()) {

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_POSTED);
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        }
    }

    return;
}


VOID
NtfsPostUserLimit (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    )

/*++

Routine Description:

    This routine posts a request to save the fact that the user has exceeded
    their limit.

Arguments:

    Vcb - Volume control block for volume whos quota needs to be fixed.

    QuotaControl - Quota control block for the user.

Return Value:

    None

--*/

{

    PAGED_CODE();

    try {

        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

        if (FlagOn( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED )) {
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            leave;
        }

        SetFlag( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED );

        //
        //  Reference the quota control block so it does not go away.
        //

        ASSERT( QuotaControl->ReferenceCount > 0 );
        InterlockedIncrement( &QuotaControl->ReferenceCount );

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

        //
        //  Post this special request.
        //

        NtfsPostSpecial( IrpContext,
                         Vcb,
                         NtfsMarkUserLimit,
                         QuotaControl );

    } finally {

        if (AbnormalTermination()) {

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( QuotaControl->Flags, QUOTA_FLAG_LIMIT_POSTED );
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        }
    }

    return;
}


NTSTATUS
NtfsPrepareForDelete (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSID Sid
    )

/*++

Routine Description:

    This routine determines if an owner id is a candidate for deletion.  If
    the id appears deletable its user data is reset to the defaults and the
    entry is marked as deleted.  Later a worker thread will do the actual
    deletion.

Arguments:

    Vcb - Supplies a pointer to the volume containing the entry to be deleted.

    Sid - Security id to to be deleted.

Return Value:

    Returns a status indicating of the id was deletable at this time.

--*/
{
    ULONG OwnerId;
    ULONG DefaultOwnerId;
    NTSTATUS Status = STATUS_SUCCESS;
    INDEX_ROW IndexRow;
    INDEX_ROW NewIndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    PQUOTA_CONTROL_BLOCK QuotaControl;
    QUOTA_USER_DATA NewQuotaData;
    PSCB QuotaScb = Vcb->QuotaTableScb;
    PSCB OwnerIdScb = Vcb->OwnerIdTableScb;

    PAGED_CODE();

    //
    //  Determine the Sid length.
    //

    IndexKey.KeyLength = RtlLengthSid( Sid );
    IndexKey.Key = Sid;

    //
    //  Acquire Owner id and quota index exclusive.
    //

    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtfsAcquireExclusiveScb( IrpContext, OwnerIdScb );
    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    NtOfsInitializeMapHandle( &MapHandle );

    try {

        //
        //  Look up the SID in the owner index.
        //

        Status = NtOfsFindRecord( IrpContext,
                                  OwnerIdScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {
            leave;
        }

        //
        //  If the sid was found then capture the owner id.
        //

        ASSERT( IndexRow.DataPart.DataLength == sizeof( ULONG ));
        OwnerId = *((PULONG) IndexRow.DataPart.Data);

        //
        //  Release the index map handle.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );

        //
        //  Find the existing record and update it.
        //

        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {

            ASSERT( NT_SUCCESS( Status ));
            NtfsMarkQuotaCorrupt( IrpContext, Vcb );
            leave;
        }

        RtlCopyMemory( &NewQuotaData, IndexRow.DataPart.Data, SIZEOF_QUOTA_USER_DATA );

        //
        //  Check to see if there is a quota control entry
        //  for this id.
        //

        ASSERT( FIELD_OFFSET( QUOTA_CONTROL_BLOCK, OwnerId ) <= FIELD_OFFSET( INDEX_ROW, KeyPart.Key ));

        QuotaControl = RtlLookupElementGenericTable( &Vcb->QuotaControlTable,
                                                     CONTAINING_RECORD( &IndexRow.KeyPart.Key,
                                                                        QUOTA_CONTROL_BLOCK,
                                                                        OwnerId ));

        //
        //  If there is a quota control entry or there is now
        //  some quota charged, then the entry cannot be deleted.
        //

        if ((QuotaControl != NULL) || (NewQuotaData.QuotaUsed != 0)) {

            Status = STATUS_CANNOT_DELETE;
            leave;
        }

        //
        //  Find the default quota record.
        //

        DefaultOwnerId = QUOTA_DEFAULTS_ID;
        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &DefaultOwnerId;

        NtOfsReleaseMap( IrpContext, &MapHandle );

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  NULL );

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, STATUS_QUOTA_LIST_INCONSISTENT, NULL, QuotaScb->Fcb );
        }

        //
        //  Set the user entry to the current defaults. Then if the entry
        //  is really inuse it will appear that is came back after the delete.
        //

        RtlCopyMemory( &NewQuotaData,
                       IndexRow.DataPart.Data,
                       SIZEOF_QUOTA_USER_DATA );

        ClearFlag( NewQuotaData.QuotaFlags, ~QUOTA_FLAG_USER_MASK );

        //
        //  Set the deleted flag.
        //

        SetFlag( NewQuotaData.QuotaFlags, QUOTA_FLAG_ID_DELETED );

        //
        // The key length does not change.
        //

        NewIndexRow.KeyPart.Key = &OwnerId;
        NewIndexRow.KeyPart.KeyLength = sizeof( ULONG );
        NewIndexRow.DataPart.Data = &NewQuotaData;
        NewIndexRow.DataPart.DataLength = SIZEOF_QUOTA_USER_DATA;

        NtOfsUpdateRecord( IrpContext,
                           QuotaScb,
                           1,
                           &NewIndexRow,
                           NULL,
                           NULL );

        //
        //  Update the delete secquence number this is used to indicate
        //  another id has been deleted.  If the repair code is in the
        //  middle of its scan it must restart the scan.
        //

        Vcb->QuotaDeleteSecquence += 1;

        //
        //  Indicate there are pending deletes.
        //

        if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES );

            ASSERT( IndexRow.DataPart.DataLength <= sizeof( QUOTA_USER_DATA ));

            RtlCopyMemory( &NewQuotaData,
                           IndexRow.DataPart.Data,
                           IndexRow.DataPart.DataLength );

            //
            //  Update the changed fields in the record.
            //

            NewQuotaData.QuotaFlags = Vcb->QuotaFlags;

            //
            //  Note the sizes in the IndexRow stay the same.
            //

            IndexRow.KeyPart.Key = &DefaultOwnerId;
            ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
            IndexRow.DataPart.Data = &NewQuotaData;

            NtOfsUpdateRecord( IrpContext,
                               QuotaScb,
                               1,
                               &IndexRow,
                               NULL,
                               NULL );
        }

    } finally {

        //
        //  Release the index map handle and index resources.
        //

        NtOfsReleaseMap( IrpContext, &MapHandle );
        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtfsReleaseScb( IrpContext, QuotaScb );
    }

    return Status;
}


VOID
NtfsRepairQuotaIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called by a worker thread to fix the quota indexes
    and recalculate all of the quota values.

Arguments:

    Context - Unused.

Return Value:

    None

--*/

{
    PVCB Vcb = IrpContext->Vcb;
    ULONG State;
    NTSTATUS Status;
    ULONG RetryCount = 0;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( Context );

    try {

        DebugTrace( 0, Dbg, ( "NtfsRepairQuotaIndex: Starting quota repair. Vcb = %lx\n", Vcb ));

        //
        //  The volume could've gotten write-protected by now.
        //

        if (NtfsIsVolumeReadOnly( Vcb )) {

            NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
        }

        //
        //  Acquire the volume exclusive and the quota lock.
        //

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
        ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

        Status = STATUS_SUCCESS;

        if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED )) {

            //
            //  There is no point in doing any of this work if tracking
            //  is not requested.
            //

            Status = STATUS_INVALID_PARAMETER;

        } else if (FlagOn( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING ) == VCB_QUOTA_REPAIR_POSTED) {

            if (FlagOn( Vcb->QuotaFlags,
                        (QUOTA_FLAG_OUT_OF_DATE |
                         QUOTA_FLAG_CORRUPT |
                         QUOTA_FLAG_PENDING_DELETES) ) == QUOTA_FLAG_PENDING_DELETES) {

                //
                //  Only the last to phases need to be run.
                //

                ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );

                SetFlag( Vcb->QuotaState, VCB_QUOTA_RECALC_STARTED );

                State = VCB_QUOTA_RECALC_STARTED;

                //
                //  Capture the delete secquence number.  If it changes
                //  before the actual deletes are done then we have to
                //  start over.
                //

                IrpContext->Union.NtfsIoContext = ULongToPtr( Vcb->QuotaDeleteSecquence );

            } else {

                //
                //  We are starting just starting.  Clear the quota tracking
                //  flags and indicate the current state.
                //

                ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );

                SetFlag( Vcb->QuotaState, VCB_QUOTA_CLEAR_RUNNING | VCB_QUOTA_SAVE_QUOTA_FLAGS);

                ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED );

                SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE );

                State = VCB_QUOTA_CLEAR_RUNNING;
            }

            //
            //  Initialize the File reference to the root index.
            //

            NtfsSetSegmentNumber( &Vcb->QuotaFileReference,
                                  0,
                                  ROOT_FILE_NAME_INDEX_NUMBER );

            Vcb->QuotaFileReference.SequenceNumber = 0;

            NtfsLogEvent( IrpContext,
                          NULL,
                          IO_FILE_QUOTA_STARTED,
                          STATUS_SUCCESS );

        }  else {

            State = FlagOn( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING);
        }

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtfsReleaseVcb( IrpContext, Vcb );

        if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {

            NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
        }

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        //
        //  Determine the current state
        //

        switch (State) {

        case VCB_QUOTA_CLEAR_RUNNING:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting clear per file quota.\n" ));

            //
            //  Clear the quota charged field in each file and clear
            //  all of the quota control blocks from the fcbs.
            //

            Status = NtfsIterateMft( IrpContext,
                                      Vcb,
                                      &Vcb->QuotaFileReference,
                                      NtfsClearPerFileQuota,
                                      NULL );

            if (Status == STATUS_END_OF_FILE) {
                Status = STATUS_SUCCESS;
            }

            if (!NT_SUCCESS( Status )) {
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

RestartVerifyQuotaIndex:

            //
            //  Update the state to the next phase.
            //

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_INDEX_REPAIR);
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            //
            //  NtfsClearAndVerifyQuotaIndex uses the low part of the
            //  file reference to store the current owner id.
            //  Intialize this to the first user id.
            //

            Vcb->QuotaFileReference.SegmentNumberLowPart = QUOTA_FISRT_USER_ID;

            //
            //  Fall through.
            //

        case VCB_QUOTA_INDEX_REPAIR:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting clear quota index.\n" ));

            //
            //  Clear the quota used for each owner id.
            //

            NtfsClearAndVerifyQuotaIndex( IrpContext, Vcb );

            //
            //  Update the state to the next phase.
            //

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_OWNER_VERIFY);
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            //
            //  Note NtfsVerifyOwnerIndex does not use any restart state,
            //  since it normally does not preform any transactions.
            //

            //
            //  Fall through.
            //

        case VCB_QUOTA_OWNER_VERIFY:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting verify owner index.\n" ));

            //
            //  Verify the owner's id points to quota user data.
            //

            Status = NtfsVerifyOwnerIndex( IrpContext, Vcb );

            //
            //  Restart the rebuild with the quota index phase.
            //

            if (!NT_SUCCESS( Status ) ) {

                if (RetryCount < 2) {

                    RetryCount += 1;
                    goto RestartVerifyQuotaIndex;

                } else {

                    NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
                }
            }

            //
            //  Update the state to the next phase.
            //  Start tracking quota and do enforcement as requested.
            //

            NtfsAcquireExclusiveVcb( IrpContext, Vcb, TRUE );
            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_RECALC_STARTED | VCB_QUOTA_SAVE_QUOTA_FLAGS);

            if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED)) {

                SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED);
                Status = STATUS_SUCCESS;

            } else {

                //
                //  There is no point in doing any of this work if tracking
                //  is not requested.
                //

                Status = STATUS_INVALID_PARAMETER;
            }

            //
            //  Capture the delete secquence number.  If it changes
            //  before the actual deletes are done then we have to
            //  start over.
            //

            IrpContext->Union.NtfsIoContext = ULongToPtr( Vcb->QuotaDeleteSecquence );

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
            NtfsReleaseVcb( IrpContext, Vcb );

            if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {

                NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
            }

            if (!NT_SUCCESS( Status )) {
                NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
            }

            //
            //  Initialize the File reference to the first user file.
            //

            NtfsSetSegmentNumber( &Vcb->QuotaFileReference,
                                  0,
                                  ROOT_FILE_NAME_INDEX_NUMBER );
            Vcb->QuotaFileReference.SequenceNumber = 0;

            //
            //  Fall through.
            //

        case VCB_QUOTA_RECALC_STARTED:

            DebugTrace( 4, Dbg, ( "NtfsRepairQuotaIndex: Starting per file quota usage.\n" ));

            //
            //  Fix the user files.
            //

            Status = NtfsIterateMft( IrpContext,
                                      Vcb,
                                      &Vcb->QuotaFileReference,
                                      NtfsRepairPerFileQuota,
                                      NULL );

            if (Status == STATUS_END_OF_FILE) {
                Status = STATUS_SUCCESS;
            }

            //
            //  Everything is done indicate we are up to date.
            //

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS);

            if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

                //
                //  Need to actually delete the ids.
                //

                SetFlag( Vcb->QuotaState, VCB_QUOTA_DELETEING_IDS );
                State = VCB_QUOTA_DELETEING_IDS;

                //
                //  NtfsDeleteUnsedIds uses the low part of the
                //  file reference to store the current owner id.
                //  Intialize this to the first user id.
                //

                Vcb->QuotaFileReference.SegmentNumberLowPart = QUOTA_FISRT_USER_ID;

            }

            ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE | QUOTA_FLAG_CORRUPT );

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {
                NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
            }

            if (State != VCB_QUOTA_DELETEING_IDS) {
                break;
            }

        case VCB_QUOTA_DELETEING_IDS:

            //
            //  Remove and ids which are marked for deletion.
            //

            NtfsDeleteUnsedIds( IrpContext, Vcb );

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS);
            ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES );

            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            if (FlagOn( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS )) {
                NtfsSaveQuotaFlagsSafe( IrpContext, Vcb );
            }

            break;

        default:

            ASSERT( FALSE );
            Status = STATUS_INVALID_PARAMETER;
            NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
        }

        if (NT_SUCCESS( Status )) {
            NtfsLogEvent( IrpContext,
                          NULL,
                          IO_FILE_QUOTA_SUCCEEDED,
                          Status );
        }

    } except(NtfsExceptionFilter(IrpContext, GetExceptionInformation())) {

        Status = IrpContext->TopLevelIrpContext->ExceptionStatus;
    }

    DebugTrace( 0, Dbg, ( "NtfsRepairQuotaIndex: Quota repair done. Status = %8lx Context = %lx\n", Status, (ULONG) NtfsSegmentNumber( &Vcb->QuotaFileReference )));

    if (!NT_SUCCESS( Status )) {

        //
        //  If we will not be called back then clear the running state bits.
        //

        if ((Status != STATUS_CANT_WAIT) && (Status != STATUS_LOG_FILE_FULL)) {

            ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );
            ClearFlag( Vcb->QuotaState, VCB_QUOTA_REPAIR_RUNNING );
            ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );

            //
            //  Only log if we attempted to do work - which is only the case
            //  if tracking is on
            //

            if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED)) {
                NtfsLogEvent( IrpContext, NULL, IO_FILE_QUOTA_FAILED, Status );
            }

        }

        NtfsRaiseStatus( IrpContext, Status, NULL, NULL );
    }

    return;
}


VOID
NtfsReleaseQuotaControl (
    IN PIRP_CONTEXT IrpContext,
    IN PQUOTA_CONTROL_BLOCK QuotaControl
    )

/*++

Routine Description:

    This function is called by transcation control to release the quota control
    block and quota index after a transcation has been completed.

Arguments:

    QuotaControl - Quota control block to be released.

Return Value:

    None.

--*/

{
    PVCB Vcb = IrpContext->Vcb;
    PAGED_CODE();

    ExReleaseFastMutexUnsafe( QuotaControl->QuotaControlLock );
    NtfsReleaseResource( IrpContext, Vcb->QuotaTableScb );

    NtfsDereferenceQuotaControlBlock( Vcb, &QuotaControl );

    return;
}


NTSTATUS
NtfsRepairPerFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine calculate the quota used by a file and update the
    update QuotaCharged field in the standard info as well as QuotaUsed
    in the user's index structure.  If the owner id is not set this is
    also updated at this time.

Arguments:

    Fcb - Fcb for the file to be processed.

    Context - Unsed.

Return Value:

    STATUS_SUCCESS

--*/

{
    LONGLONG Delta;
    INDEX_KEY IndexKey;
    INDEX_ROW IndexRow;
    PREAD_CONTEXT ReadContext = NULL;
    ULONG Count;
    PSID Sid;
    PVCB Vcb = Fcb->Vcb;
    NTSTATUS Status;
    BOOLEAN OwnerDefaulted;
    BOOLEAN SetOwnerId = FALSE;
    BOOLEAN StdInfoGrown = FALSE;

    PAGED_CODE( );

    UNREFERENCED_PARAMETER( Context);

    //
    //  Preacquire the security stream and  quota index in case the
    //  mft has to be grown.
    //

    ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ) || NtfsIsExclusiveScb( Vcb->QuotaTableScb ));

    NtfsAcquireExclusiveScb( IrpContext, Vcb->QuotaTableScb );

    try {

        //
        //  Always clear the owner ID so that the SID is retrived from
        //  the security descriptor.
        //

        Fcb->OwnerId = QUOTA_INVALID_ID;

        if (Fcb->QuotaControl != NULL) {

            //
            //  If there is a quota control block it is now bougus
            //  Free it up a new one will be generated below.
            //

            NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
        }

        if (Fcb->OwnerId != QUOTA_INVALID_ID) {

            //
            //  Verify the id actually exists in the index.
            //

            Count = 0;
            IndexKey.Key = &Fcb->OwnerId;
            IndexKey.KeyLength = sizeof( Fcb->OwnerId );
            Status = NtOfsReadRecords( IrpContext,
                                       Vcb->QuotaTableScb,
                                       &ReadContext,
                                       &IndexKey,
                                       NtOfsMatchUlongExact,
                                       &IndexKey,
                                       &Count,
                                       &IndexRow,
                                       0,
                                       NULL );

            if (!NT_SUCCESS( Status )) {

                ASSERT( NT_SUCCESS( Status ));

                //
                //  There is no user quota data for this id assign a
                //  new one to the file.
                //

                Fcb->OwnerId = QUOTA_INVALID_ID;

                if (Fcb->QuotaControl != NULL) {

                    //
                    //  If there is a quota control block it is now bougus
                    //  Free it up a new one will be generated below.
                    //

                    NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
                }
            }

            NtOfsFreeReadContext( ReadContext );
        }

        if (Fcb->OwnerId == QUOTA_INVALID_ID) {

            if (Fcb->SharedSecurity == NULL) {
                NtfsLoadSecurityDescriptor ( IrpContext, Fcb  );
            }

            ASSERT( Fcb->SharedSecurity != NULL );

            //
            //  Extract the security id from the security descriptor.
            //

            Status = RtlGetOwnerSecurityDescriptor( Fcb->SharedSecurity->SecurityDescriptor,
                                                    &Sid,
                                                    &OwnerDefaulted );

            if (!NT_SUCCESS(Status)) {
                NtfsRaiseStatus( IrpContext, Status, NULL, Fcb);
            }

            //
            // Generate a owner id for the Fcb.
            //

            Fcb->OwnerId = NtfsGetOwnerId( IrpContext,
                                           Sid,
                                           TRUE,
                                           NULL );

            SetOwnerId = TRUE;

            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO )) {

                NtfsUpdateStandardInformation( IrpContext, Fcb );

            } else {

                //
                //  Grow the standard information.
                //

                StdInfoGrown = TRUE;
                NtfsGrowStandardInformation( IrpContext, Fcb );
            }
        }

        //
        //  Initialize the quota control block.
        //

        if (Fcb->QuotaControl == NULL) {
            Fcb->QuotaControl = NtfsInitializeQuotaControlBlock( Vcb, Fcb->OwnerId );
        }

        NtfsCalculateQuotaAdjustment( IrpContext, Fcb, &Delta );

        ASSERT( NtfsAllowFixups || FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE ) || (Delta == 0));

        if ((Delta != 0) || FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_PENDING_DELETES )) {

            NtfsUpdateFileQuota( IrpContext, Fcb, &Delta, TRUE, FALSE );
        }

        if (SetOwnerId) {

            //
            //  If the owner id was set then commit the transaction now.
            //  That way if a raise occurs the OwnerId can be cleared before
            //  the function returns. No resources are released.
            //

            NtfsCheckpointCurrentTransaction( IrpContext );
        }

    } finally {

        //
        //  Clear any Fcb changes if the operation failed.
        //  This is so when a retry occurs the necessary
        //  operations are done.
        //

        if (AbnormalTermination()) {

            if (StdInfoGrown) {
                ClearFlag( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO );
            }

            if (SetOwnerId) {

                Fcb->OwnerId = QUOTA_INVALID_ID;

                if (Fcb->QuotaControl != NULL) {
                    NtfsDereferenceQuotaControlBlock( Vcb, &Fcb->QuotaControl );
                }
            }
        }

        NtfsReleaseScb( IrpContext, Vcb->QuotaTableScb );
    }

    return STATUS_SUCCESS;
}


VOID
NtfsUpdateFileQuota (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLONGLONG Delta,
    IN LOGICAL LogIt,
    IN LOGICAL CheckQuota
    )

/*++

Routine Description:

    This routine updates the quota amount for a file and owner by the
    requested amount. If quota is being increated and the CheckQuota is true
    than the new quota amount will be tested for quota violations. If the
    hard limit is exceeded an error is raised.  If the LogIt flags is not set
    then changes to the standard information structure are not logged.
    Changes to the user quota data are always logged.

Arguments:

    Fcb - Fcb whose quota usage is being modified.

    Delta - Supplies the signed amount to change the quota for the file.

    LogIt - Indicates whether we should log this change.

    CheckQuota - Indicates whether we should check for quota violations.

Return Value:

    None.

--*/

{

    ULONGLONG NewQuota;
    LARGE_INTEGER CurrentTime;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PSTANDARD_INFORMATION StandardInformation;
    PQUOTA_USER_DATA UserData;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    NTSTATUS Status;
    PQUOTA_CONTROL_BLOCK QuotaControl = Fcb->QuotaControl;
    PVCB Vcb = Fcb->Vcb;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFileQuota:  Entered\n") );

    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO ));


    //
    //  Readonly volumes shouldn't proceed.
    //

    if (NtfsIsVolumeReadOnly( Vcb )) {

        ASSERT( FALSE );
        NtfsRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED, NULL, NULL );
    }

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure and map handle.
        //

        NtfsInitializeAttributeContext( &AttrContext );
        NtOfsInitializeMapHandle( &MapHandle );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

        ASSERT( NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION ));

        NewQuota = StandardInformation->QuotaCharged + *Delta;

        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        if ((LONGLONG) NewQuota < 0) {

            //
            //  Do not let the quota data go negitive.
            //

            NewQuota = 0;
        }

        if (LogIt) {

            //
            //  Call to change the attribute value.
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      FIELD_OFFSET(STANDARD_INFORMATION, QuotaCharged),
                                      &NewQuota,
                                      sizeof( StandardInformation->QuotaCharged),
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      FALSE,
                                      &AttrContext );
        } else {

            //
            //  Just update the value in the standard information
            //  it will be logged later.
            //

            StandardInformation->QuotaCharged = NewQuota;
        }

        //
        //  Update the quota information block.
        //

        NtfsAcquireQuotaControl( IrpContext, QuotaControl );

        IndexKey.KeyLength = sizeof(ULONG);
        IndexKey.Key = &QuotaControl->OwnerId;

        Status = NtOfsFindRecord( IrpContext,
                                  Vcb->QuotaTableScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuotaControl->QuickIndexHint );

        if (!(NT_SUCCESS( Status )) ||
            (IndexRow.DataPart.DataLength < SIZEOF_QUOTA_USER_DATA + FIELD_OFFSET( SID, SubAuthority )) ||
             ((ULONG)SeLengthSid( &(((PQUOTA_USER_DATA)(IndexRow.DataPart.Data))->QuotaSid)) + SIZEOF_QUOTA_USER_DATA !=
                IndexRow.DataPart.DataLength)) {

            //
            //  This look up should not fail.
            //

            ASSERT( NT_SUCCESS( Status ));
            ASSERTMSG(( "NTFS: corrupt quotasid\n" ), FALSE);

            NtfsMarkQuotaCorrupt( IrpContext, IrpContext->Vcb );
            leave;
        }

        //
        //  Space is allocated for the new record after the quota control
        //  block.
        //

        UserData = (PQUOTA_USER_DATA) (QuotaControl + 1);
        ASSERT( IndexRow.DataPart.DataLength >= SIZEOF_QUOTA_USER_DATA );

        RtlCopyMemory( UserData,
                       IndexRow.DataPart.Data,
                       SIZEOF_QUOTA_USER_DATA );

        ASSERT( (LONGLONG) UserData->QuotaUsed >= -*Delta );

        UserData->QuotaUsed += *Delta;

        if ((LONGLONG) UserData->QuotaUsed < 0) {

            //
            //  Do not let the quota data go negative.
            //

            UserData->QuotaUsed = 0;
        }

        //
        //  Indicate only the quota used field has been set so far.
        //

        Length = FIELD_OFFSET( QUOTA_USER_DATA, QuotaChangeTime );

        //
        //  Only update the quota modified time if this is the last cleanup
        //  for the owner.
        //

        if (IrpContext->MajorFunction == IRP_MJ_CLEANUP) {

            KeQuerySystemTime( &CurrentTime );
            UserData->QuotaChangeTime = CurrentTime.QuadPart;

            ASSERT( Length <= FIELD_OFFSET( QUOTA_USER_DATA, QuotaThreshold ));
            Length = FIELD_OFFSET( QUOTA_USER_DATA, QuotaThreshold );
        }

        if (CheckQuota && (*Delta > 0)) {

            if ((UserData->QuotaUsed > UserData->QuotaLimit) &&
                (UserData->QuotaUsed >= (UserData->QuotaLimit + Vcb->BytesPerCluster))) {

                KeQuerySystemTime( &CurrentTime );
                UserData->QuotaChangeTime = CurrentTime.QuadPart;

                if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_LOG_LIMIT ) &&
                    (!FlagOn( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED ) ||
                     ((ULONGLONG) CurrentTime.QuadPart > UserData->QuotaExceededTime + NtfsMaxQuotaNotifyRate))) {

                    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED) &&
                        (Vcb->AdministratorId != QuotaControl->OwnerId)) {

                        //
                        //  The operation to mark the user's quota data entry
                        //  must be posted since any changes to the entry
                        //  will be undone by the following raise.
                        //

                        NtfsPostUserLimit( IrpContext, Vcb, QuotaControl );
                        NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, Fcb );

                    } else {

                        //
                        //  Log the fact that quota was exceeded.
                        //

                        if (NtfsLogEvent( IrpContext,
                                          IndexRow.DataPart.Data,
                                          IO_FILE_QUOTA_LIMIT,
                                          STATUS_SUCCESS )) {

                            //
                            //  The event was successfuly logged.  Do not log
                            //  another for a while.
                            //

                            DebugTrace( 0, Dbg, ("NtfsUpdateFileQuota: Quota Limit exceeded. OwnerId = %lx\n", QuotaControl->OwnerId));

                            UserData->QuotaExceededTime = CurrentTime.QuadPart;
                            SetFlag( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED );

                            //
                            //  Log all of the changed data.
                            //

                            Length = SIZEOF_QUOTA_USER_DATA;
                        }
                    }

                } else if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED) &&
                           (Vcb->AdministratorId != QuotaControl->OwnerId)) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, Fcb );
                }

            }

            if (UserData->QuotaUsed > UserData->QuotaThreshold) {

                KeQuerySystemTime( &CurrentTime );
                UserData->QuotaChangeTime = CurrentTime.QuadPart;

                if ((ULONGLONG) CurrentTime.QuadPart >
                    (UserData->QuotaExceededTime + NtfsMaxQuotaNotifyRate)) {

                    if (FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_LOG_THRESHOLD)) {

                        if (NtfsLogEvent( IrpContext,
                                          IndexRow.DataPart.Data,
                                          IO_FILE_QUOTA_THRESHOLD,
                                          STATUS_SUCCESS )) {

                            //
                            //  The event was successfuly logged.  Do not log
                            //  another for a while.
                            //

                            DebugTrace( 0, Dbg, ("NtfsUpdateFileQuota: Quota threshold exceeded. OwnerId = %lx\n", QuotaControl->OwnerId));

                            UserData->QuotaExceededTime = CurrentTime.QuadPart;

                            //
                            //  Log all of the changed data.
                            //

                            Length = SIZEOF_QUOTA_USER_DATA;
                        }
                    }

                    //
                    //  Now is a good time to clear the limit reached flag.
                    //

                    ClearFlag( UserData->QuotaFlags, QUOTA_FLAG_LIMIT_REACHED );
                }
            }
        }

        //
        //  Always clear the deleted flag.
        //

        ClearFlag( UserData->QuotaFlags, QUOTA_FLAG_ID_DELETED );

        //
        // Only log the part that changed.
        //

        IndexRow.KeyPart.Key = &QuotaControl->OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof(ULONG) );
        IndexRow.DataPart.Data = UserData;
        IndexRow.DataPart.DataLength = Length;

        NtOfsUpdateRecord( IrpContext,
                         Vcb->QuotaTableScb,
                         1,
                         &IndexRow,
                         &QuotaControl->QuickIndexHint,
                         &MapHandle );

    } finally {

        DebugUnwind( NtfsUpdateFileQuota );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtOfsReleaseMap( IrpContext, &MapHandle );

        DebugTrace( -1, Dbg, ("NtfsUpdateFileQuota:  Exit\n") );
    }

    return;
}


VOID
NtfsSaveQuotaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine saves the quota flags in the defaults quota entry.

Arguments:

    Vcb - Volume control block for volume be query.

Return Value:

    None.

--*/

{
    ULONG OwnerId;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    QUICK_INDEX_HINT QuickIndexHint;
    QUOTA_USER_DATA NewQuotaData;
    PSCB QuotaScb;

    PAGED_CODE();

    //
    //  Acquire quota index exclusive.
    //

    QuotaScb = Vcb->QuotaTableScb;
    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtOfsInitializeMapHandle( &MapHandle );
    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        //
        //  Find the default quota record and update it.
        //

        OwnerId = QUOTA_DEFAULTS_ID;
        IndexKey.KeyLength = sizeof(ULONG);
        IndexKey.Key = &OwnerId;

        RtlZeroMemory( &QuickIndexHint, sizeof( QuickIndexHint ));

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuickIndexHint );

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, STATUS_QUOTA_LIST_INCONSISTENT, NULL, QuotaScb->Fcb );
        }

        ASSERT( IndexRow.DataPart.DataLength <= sizeof( QUOTA_USER_DATA ));

        RtlCopyMemory( &NewQuotaData,
                       IndexRow.DataPart.Data,
                       IndexRow.DataPart.DataLength );

        //
        //  Update the changed fields in the record.
        //

        NewQuotaData.QuotaFlags = Vcb->QuotaFlags;

        //
        //  Note the sizes in the IndexRow stay the same.
        //

        IndexRow.KeyPart.Key = &OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof(ULONG) );
        IndexRow.DataPart.Data = &NewQuotaData;

        NtOfsUpdateRecord( IrpContext,
                           QuotaScb,
                           1,
                           &IndexRow,
                           &QuickIndexHint,
                           &MapHandle );

        ClearFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS);

    } finally {

        //
        //  Release the index map handle and scb.
        //

        ExReleaseFastMutexUnsafe( &Vcb->QuotaControlLock );
        NtOfsReleaseMap( IrpContext, &MapHandle );
        NtfsReleaseScb( IrpContext, QuotaScb );
    }

    return;
}


VOID
NtfsSaveQuotaFlagsSafe (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine safely saves the quota flags in the defaults quota entry.
    It acquires the volume shared, checks to see if it is ok to write,
    updates the flags and finally commits the transaction.

Arguments:

    Vcb - Volume control block for volume be query.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT( IrpContext->TransactionId == 0);

    NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );

    try {

        //
        //  Acquire the VCB shared and check whether we should
        //  continue.
        //

        if (!NtfsIsVcbAvailable( Vcb )) {

            //
            //  The volume is going away, bail out.
            //

            NtfsRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED, NULL, NULL );
        }

        //
        //  Do the work.
        //

        NtfsSaveQuotaFlags( IrpContext, Vcb );

        //
        //  Set the irp context flags to indicate that we are in the
        //  fsp and that the irp context should not be deleted when
        //  complete request or process exception are called. The in
        //  fsp flag keeps us from raising in a few places.  These
        //  flags must be set inside the loop since they are cleared
        //  under certain conditions.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DONT_DELETE | IRP_CONTEXT_FLAG_RETAIN_FLAGS );
        SetFlag( IrpContext->State, IRP_CONTEXT_STATE_IN_FSP);

        NtfsCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    } finally {

        NtfsReleaseVcb( IrpContext, Vcb );
    }

    return;
}


VOID
NtfsUpdateQuotaDefaults (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_CONTROL_INFORMATION FileControlInfo
    )

/*++

Routine Description:

    This function updates the default settings index entry for quotas.

Arguments:

    Vcb - Volume control block for volume be query.

    FileQuotaInfo - Optional quota data to update quota index with.

Return Value:

    None.

--*/

{
    ULONG OwnerId;
    NTSTATUS Status;
    INDEX_ROW IndexRow;
    INDEX_KEY IndexKey;
    MAP_HANDLE MapHandle;
    QUOTA_USER_DATA NewQuotaData;
    QUICK_INDEX_HINT QuickIndexHint;
    ULONG Flags;
    PSCB QuotaScb;

    PAGED_CODE();

    //
    //  Acquire quota index exclusive.
    //

    QuotaScb = Vcb->QuotaTableScb;
    NtfsAcquireExclusiveScb( IrpContext, QuotaScb );
    NtOfsInitializeMapHandle( &MapHandle );
    ExAcquireFastMutexUnsafe( &Vcb->QuotaControlLock );

    try {

        //
        //  Find the default quota record and update it.
        //

        OwnerId = QUOTA_DEFAULTS_ID;
        IndexKey.KeyLength = sizeof( ULONG );
        IndexKey.Key = &OwnerId;

        RtlZeroMemory( &QuickIndexHint, sizeof( QuickIndexHint ));

        Status = NtOfsFindRecord( IrpContext,
                                  QuotaScb,
                                  &IndexKey,
                                  &IndexRow,
                                  &MapHandle,
                                  &QuickIndexHint );

        if (!NT_SUCCESS( Status )) {
            NtfsRaiseStatus( IrpContext, STATUS_QUOTA_LIST_INCONSISTENT, NULL, QuotaScb->Fcb );
        }

        ASSERT( IndexRow.DataPart.DataLength == SIZEOF_QUOTA_USER_DATA );

        RtlCopyMemory( &NewQuotaData,
                       IndexRow.DataPart.Data,
                       IndexRow.DataPart.DataLength );

        //
        //  Update the changed fields in the record.
        //

        NewQuotaData.QuotaThreshold = FileControlInfo->DefaultQuotaThreshold.QuadPart;
        NewQuotaData.QuotaLimit = FileControlInfo->DefaultQuotaLimit.QuadPart;
        KeQuerySystemTime( (PLARGE_INTEGER) &NewQuotaData.QuotaChangeTime );

        //
        //  Update the quota flags.
        //

        Flags = FlagOn( FileControlInfo->FileSystemControlFlags,
                        FILE_VC_QUOTA_MASK );

        switch (Flags) {

        case FILE_VC_QUOTA_NONE:

            //
            //  Disable quotas
            //

            ClearFlag( Vcb->QuotaFlags,
                       (QUOTA_FLAG_TRACKING_ENABLED |
                        QUOTA_FLAG_ENFORCEMENT_ENABLED |
                        QUOTA_FLAG_TRACKING_REQUESTED) );

            break;

        case FILE_VC_QUOTA_TRACK:

            //
            //  Clear the enforment flags.
            //

            ClearFlag( Vcb->QuotaFlags, QUOTA_FLAG_ENFORCEMENT_ENABLED );

            //
            //  Request tracking be enabled.
            //

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED );
            break;

        case FILE_VC_QUOTA_ENFORCE:

            //
            //  Set the enforcement and tracking enabled flags.
            //

            SetFlag( Vcb->QuotaFlags,
                     QUOTA_FLAG_ENFORCEMENT_ENABLED | QUOTA_FLAG_TRACKING_REQUESTED);

            break;
        }

        //
        //  If quota tracking is not now
        //  enabled then the quota data will need
        //  to be rebuild so indicate quotas are out of date.
        //  Note the out of date flags always set of quotas
        //  are disabled.
        //

        if (!FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_ENABLED )) {
            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE );
        }

        //
        //  Track the logging flags.
        //

        ClearFlag( Vcb->QuotaFlags,
                   QUOTA_FLAG_LOG_THRESHOLD | QUOTA_FLAG_LOG_LIMIT );

        if (FlagOn( FileControlInfo->FileSystemControlFlags, FILE_VC_LOG_QUOTA_THRESHOLD )) {

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_LOG_THRESHOLD );
        }

        if (FlagOn( FileControlInfo->FileSystemControlFlags, FILE_VC_LOG_QUOTA_LIMIT )) {

            SetFlag( Vcb->QuotaFlags, QUOTA_FLAG_LOG_LIMIT );
        }

        SetFlag( Vcb->QuotaState, VCB_QUOTA_SAVE_QUOTA_FLAGS );

        //
        //  Save the new flags in the new index entry.
        //

        NewQuotaData.QuotaFlags = Vcb->QuotaFlags;

        //
        //  Note the sizes in the IndexRow stays the same.
        //

        IndexRow.KeyPart.Key = &OwnerId;
        ASSERT( IndexRow.KeyPart.KeyLength == sizeof( ULONG ));
        IndexRow.DataPart.Data = &NewQuotaData;

       