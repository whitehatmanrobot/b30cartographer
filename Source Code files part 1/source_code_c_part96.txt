             // break;
            }
            pcndNodeData = pcndNodeData->pcndNodeNext;
        } // while: more nodes in the cluster
    } // for: each cluster

    return fAllNodesUp;

} //*** FAllNodesUpOrPaused


//////////////////////////////////////////////////////////////////////////////
//++
//
//  FContainsNoNT4W2K
//
//  Description:
//      Returns a boolean value indicating whether some cluster contains
//      NT4/W2K node.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE    No cluster contains NT4/W2K node.
//      FALSE   At least one node is NT4/W2K.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
FContainsNoNT4W2K( void )
{
    size_t              idxClusters;
    BOOL                fContainsNoNT4W2K = TRUE;


    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    {
            if ( g_rgcdClusters[ idxClusters ].dwMixedMode == 1 ) 
            {
                PrintMessage(MSG_DISPLAYING_PARTICULAR_CLUSTER_CONTAINS_NT4_W2K,
                             g_rgcdClusters[ idxClusters ].pszClusterName
                             );
                fContainsNoNT4W2K = FALSE;
                // break;
            }
    } // for: each cluster

    return fContainsNoNT4W2K;

} //*** FContainsNoNT4W2K

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LookupSID
//
//  Description:
//      Returns a SID for a given account name
//
//  Arguments:
//      pszAccountName
//
//  Return Values:
//      pointer to a SID, if success. Caller is responsible for deallocating it 
//         using HeapFree( GetProcessHeap ) call
//      NULL - if lookup or allocation failed. Use GetLastError to obtain the error code
//
//--
//////////////////////////////////////////////////////////////////////////////
PSID 
LookupSID( LPCWSTR pszAccountName ) 
{
    PSID sid = NULL;
    DWORD sidLen = 0;
    LPWSTR domainName = NULL;
    DWORD domainLen = 0;
    SID_NAME_USE nameUse;
    DWORD sc = ERROR_SUCCESS;
    BOOL success;

    success = LookupAccountNameW(NULL, pszAccountName, NULL, &sidLen, NULL, &domainLen, &nameUse);

    if (success) 
    {
        // Not supposed to happen. Cannot change the .mc file so close to RTM to provide a meaningful message
        // ERROR_INVALID_DATA will do

        sc = ERROR_INVALID_DATA; 
        goto Cleanup;
    }

    sc = GetLastError();
    if(sc != ERROR_INSUFFICIENT_BUFFER)
    {
        goto Cleanup;
    }
    sc = ERROR_SUCCESS;

    sid = (PSID)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sidLen);
    if (sid == NULL) 
    {
        sc = GetLastError();
        goto Cleanup;
    }

    domainName = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, domainLen * sizeof(WCHAR));
    if (domainName == NULL) 
    {
        sc = GetLastError();
        goto Cleanup;
    }

    if (!LookupAccountNameW(
        NULL, 
        pszAccountName,  
        sid, &sidLen, domainName, &domainLen, &nameUse))
    {
        sc = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if ( domainName != NULL )
    {
        HeapFree( GetProcessHeap(), 0, domainName );
    }

    if (sc != ERROR_SUCCESS) 
    {
	if (sid != NULL) {
            HeapFree( GetProcessHeap(), 0, sid );
            sid = NULL;
        }
        SetLastError(sc);
    }

    return sid;
} //*** LookupSID

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CompareAccountSIDs
//
//  Description:
//     Compare if pszClusterServiceAccountName and pszSCMClusterServiceAccountName
//     have the same SID. 
//
//  Arguments:
//     pszClusterServiceAccountName: account cluster service is currrently using. 
//                                   For example, ruihu@redmond.microsoft.com.
//     pszSCMClusterServiceAccountName: cluster service account stored in SCM.
//                                      For example, redmond.microsoft.com\ruihu
//                                      or redmond\ruihu
//
//  Return Values:
//      ERROR_SUCCESS:                 same cluster service domain name and 
//                                     cluster service user name
//     ERROR_INVALID_SERVICE_ACCOUNT:  otherwise
//
//--
//////////////////////////////////////////////////////////////////////////////

DWORD 
CompareAccountSIDs(LPWSTR pszClusterServiceAccountName, 
                   LPWSTR pszSCMClusterServiceAccountName
                   ) 
{
    PSID sid1 = NULL, sid2 = NULL; 
    DWORD sc = ERROR_INVALID_SERVICE_ACCOUNT;

    sid1 = LookupSID(pszClusterServiceAccountName);
    sid2 = LookupSID(pszSCMClusterServiceAccountName);

    if (sid1 == NULL || sid2 == NULL) 
    {
        sc = GetLastError();
        goto Cleanup;
    }

    if ( EqualSid(sid1, sid2) ) {
        sc = ERROR_SUCCESS;
    }

Cleanup:

    if ( sid1 != NULL )
    {
        HeapFree( GetProcessHeap(), 0, sid1 );
    } 
    
    if ( sid2 != NULL )
    {
        HeapFree( GetProcessHeap(), 0, sid2 );
    } 
    
    return sc;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CompareAccountName
//
//  Description:
//     Compare if pszClusterServiceAccountName and pszSCMClusterServiceAccountName
//     contain same cluster service domain name and cluster service user name. 
//
//  Arguments:
//     pszClusterServiceAccountName: account cluster service is currrently using. 
//                                   For example, ruihu@redmond.microsoft.com.
//     pszSCMClusterServiceAccountName: cluster service account stored in SCM.
//                                      For example, redmond.microsoft.com\ruihu
//                                      or redmond\ruihu
//
//  Return Values:
//      ERROR_SUCCESS:                 same cluster service domain name and 
//                                     cluster service user name
//     ERROR_INVALID_SERVICE_ACCOUNT:  otherwise
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD 
CompareAccountName(LPWSTR pszClusterServiceAccountName, 
                   LPWSTR pszSCMClusterServiceAccountName
                   ) 
{

    PWCHAR  pszAt = NULL;
    PWCHAR  pwszBackSlash = NULL;
    PWCHAR  pszOcu = NULL;
    DWORD   sc = ERROR_SUCCESS;


    //
    // Locate character L'@' in pszClusterServiceAccountName
    //
    pszAt = wcschr( pszClusterServiceAccountName, L'@' );
    if ( pszAt == NULL )
    {
        sc = ERROR_INVALID_SERVICE_ACCOUNT;
        goto Cleanup;
    }
    *pszAt = UNICODE_NULL;
    pszAt++;


    //
    // Locate character L'\\' in  pszSCMClusterServiceAccountName
    //
    pwszBackSlash = wcschr( pszSCMClusterServiceAccountName, L'\\' );
    if ( pwszBackSlash == NULL )
    {
        sc = ERROR_INVALID_SERVICE_ACCOUNT;
        goto Cleanup;
    }
    *pwszBackSlash = UNICODE_NULL;
    pwszBackSlash++;

    //
    // check user name
    //
    sc = wcsncmp(pszClusterServiceAccountName, pwszBackSlash, (pszAt - pszClusterServiceAccountName) );
    if ( sc != 0) 
    {
        goto Cleanup;
    }

    //
    // check domain name
    //
    pszOcu = wcsstr(pszAt, pszSCMClusterServiceAccountName);
    if ( pszOcu == NULL ) 
    {
        sc = ERROR_INVALID_SERVICE_ACCOUNT;
        goto Cleanup;
    }

    sc = ERROR_SUCCESS;

Cleanup:

    if ( pszAt != NULL ) 
    {
        pszAt--;
        *pszAt = L'@';
    }

    if ( pwszBackSlash != NULL ) 
    {
        pwszBackSlash--;
        *pwszBackSlash = L'\\';
    }

    return sc;

} // CompareAccountName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  FAllNodesUsingSameAccount
//
//  Description:
//      For all nodes 
//      {
//          Query the actual account cluster service is using
//          Query the cluster service account stored in SCM database
//      }
//
//      
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE    If all are the same    
//      FALSE   Otherwise
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL 
FAllNodesUsingSameAccount( void )
{
    size_t              idxClusters;
    BOOL                fSameAccount = TRUE;
    size_t              cchAccount;
    PCLUSTER_NODE_DATA  ClusterNodePtr;

    
    if ( g_FirstNodeWithNonNullClusterServiceAccountName == NULL) 
    {
        //
        // From Assertion 1 and Assertion 2 in routine ScChangePasswordEx(), 
        // we know that all Up/Paused nodes of all clusters are NT4/Win2K nodes. 
        // In this case, we don't care if all cluster nodes are using the same
        // cluster service account or not, since we are not going to change 
        // the password. Return TRUE.
        //
        fSameAccount = TRUE;
        goto Cleanup;
    }

    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    {
        ClusterNodePtr = g_rgcdClusters[ idxClusters ].pcndNodeList;
        while ( ClusterNodePtr != NULL ) 
        {

            //
            // Checking accounts cluster services are using
            //

            if ( ClusterNodePtr->pszClusterServiceAccountName != NULL )
            {
                cchAccount = wcslen( ClusterNodePtr->pszClusterServiceAccountName );
                if ( wcsncmp( ClusterNodePtr->pszClusterServiceAccountName, 
                             g_FirstNodeWithNonNullClusterServiceAccountName->pszClusterServiceAccountName,
                             cchAccount ) != 0 ) 
                {
                    PrintMessage(MSG_TWO_NODES_ARE_NOT_USING_THE_SAME_DOMAIN_ACCOUNT,
                                 g_FirstNodeWithNonNullClusterServiceAccountName->szNodeName,
                                 g_rgcdClusters[g_FirstNonNullNodeClusterIndex].pszClusterName,
                                 ClusterNodePtr->szNodeName,
                                 g_rgcdClusters[ idxClusters ].pszClusterName,
                                 g_FirstNodeWithNonNullClusterServiceAccountName->pszClusterServiceAccountName,
                                 ClusterNodePtr->pszClusterServiceAccountName
                                 );

                    fSameAccount = FALSE;
                    goto Cleanup;
                }
            }
            //
            //  If (ClusterNodePtr->pszClusterServiceAccountName == NULL), then 
            //  from Assertion 2 in routine ScChangePasswordEx(), we know: 
            //  1. This node is Up/Paused and it is a NT4/Win2K node. Password 
            //     change will then abort. So we don't care about its account.
            //  2. Or, this node is not Up/Paused. Password change will not 
            //     be executed on this node. So we don't care about its 
            //     account either.
            //


            //
            // Checking cluster service accounts stored in SCM
            //

            if ( ClusterNodePtr->pszSCMClusterServiceAccountName != NULL ) 
            {
                if ( CompareAccountSIDs( 
                             g_FirstNodeWithNonNullClusterServiceAccountName->pszClusterServiceAccountName, 
                             ClusterNodePtr->pszSCMClusterServiceAccountName) != ERROR_SUCCESS ) 
                {

                    PrintMessage(MSG_TWO_NODES_ARE_NOT_USING_THE_SAME_SCM_DOMAIN_ACCOUNT,
                                 g_FirstNodeWithNonNullClusterServiceAccountName->szNodeName,
                                 g_rgcdClusters[g_FirstNonNullNodeClusterIndex].pszClusterName,
                                 ClusterNodePtr->szNodeName,
                                 g_rgcdClusters[ idxClusters ].pszClusterName,
                                 g_FirstNodeWithNonNullClusterServiceAccountName->pszClusterServiceAccountName,
                                 ClusterNodePtr->pszSCMClusterServiceAccountName
                                 );

                    fSameAccount = FALSE;
                    goto Cleanup;
                }
            }
            //
            // if (ClusterNodePtr->pszSCMClusterServiceAccountName==NULL), then 
            // from Assertion 2 in routine ScChangePasswordEx(), we know that the node
            // is not Up/Paused. Password change will not be executed on that node. 
            // So we don't care about its account.
            //


            ClusterNodePtr = ClusterNodePtr->pcndNodeNext;
        } // while
    }  // for

Cleanup:

    return fSameAccount;

} //*** FAllNodesUsingSameAccount


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ValidateClusters
//
//  Description:
//
//     Check if all of the clusters are available (all nodes in clusters are UP or PAUSED)
//     Check if some cluster contains NT4/W2K node.
//     Check if all of the clusters use the same service account
//
//  Arguments:
//       mcpfFlags
//       sc
//
//  Return Values:
//      TRUE    Should go ahead with password change.
//      FALSE   Should abort password change.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL 
ValidateClusters(int mcpfFlags, DWORD *psc)
{
    BOOL fRetVal = FALSE;
    BOOL fSameDomainAccount = TRUE;
    BOOL fAllNodesUpOrPaused = TRUE;
    BOOL fContainsNoNT4W2K = TRUE;

    //
    // Check if all of the clusters are available (all nodes in clusters are UP or PAUSED)
    //
    if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
    {
        PrintMessage( MSG_CHECK_IF_CLUSTERS_AVAILABLE );
    }
    fAllNodesUpOrPaused = FAllNodesUpOrPaused(mcpfFlags);
    
    if ( fAllNodesUpOrPaused == FALSE )
    {
        if ( (mcpfFlags & cpfFORCE_FLAG)  == 0 )
        {
            PrintMessage( MSG_CLUSTERS_NOT_AVAILABLE );
            if ( (mcpfFlags & cpfTEST_FLAG)  == 0)
            {
                // abort password change if none of /FORCE and /TEST options is set.
                PrintMessage( MSG_CHANGE_PASSWORD_UNABLE_TO_PROCEED );
                *psc = ERROR_ALL_NODES_NOT_AVAILABLE;
                fRetVal = FALSE;
                goto Cleanup;
            }
        }
        else
        {
            if ( (( mcpfFlags & cpfQUIET_FLAG ) == 0) && (( mcpfFlags & cpfTEST_FLAG ) == 0) )
            {
                PrintMessage( MSG_CLUSTERS_IGNORING_UNAVAILABLE_NODES );
            }
        }
    } // if:

    //
    // Check if some cluster contains NT4/W2K node.
    //
    if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
    {
        PrintMessage( MSG_CHECK_IF_CLUSTER_CONTAINS_NT4_W2K );
    }

    fContainsNoNT4W2K = FContainsNoNT4W2K();
    if ( fContainsNoNT4W2K == FALSE )
    {


        if (( mcpfFlags & cpfTEST_FLAG ) == 0) 
        {
            // abort password changee if /TEST option is not set.
            PrintMessage( MSG_CHANGE_PASSWORD_UNABLE_TO_PROCEED );
            *psc = ERROR_CLUSTER_OLD_VERSION;
            fRetVal = FALSE;
            goto Cleanup;
        }
    } // if:

    //
    // Check if all of the clusters use the same service account
    //
    if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
    {
        PrintMessage( MSG_CHECK_IF_SAME_DOMAIN_ACCOUNT );
    }
    fSameDomainAccount = FAllNodesUsingSameAccount();
    if ( fSameDomainAccount == FALSE )
    {
        PrintMessage( MSG_NOT_SAME_DOMAIN_ACCOUNT );
        if ( ( mcpfFlags & cpfTEST_FLAG ) == 0 )
        {
            PrintMessage( MSG_CHANGE_PASSWORD_UNABLE_TO_PROCEED );
            *psc = ERROR_INVALID_SERVICE_ACCOUNT;
            fRetVal = FALSE;
            goto Cleanup;
        }
    }

    fRetVal = TRUE;

Cleanup:

    return fRetVal;

} // ValidateClusters()
                


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ChangePasswordOnDC
//
//  Description:
//
//      Change password on DC.
//
//  Arguments:
//       mcpfFlags
//       sc
//       pwszNewPasswordIn
//       pwszOldPasswordIn
//
//  Return Values:
//      TRUE    Password changed successfully on DC.
//      FALSE   Otherwise
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL ChangePasswordOnDC(
          int       mcpfFlags
        , DWORD *   sc
        , LPCWSTR   pwszNewPasswordIn
        , LPCWSTR   pwszOldPasswordIn
        )
{
    BOOL    fSuccess = TRUE;
    PWCHAR  pwszBackSlash = NULL;

    if ( ( mcpfFlags & cpfSKIPDC_FLAG ) == 0 )
    {
        if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
        {
            PrintMessage( MSG_BLANKLINE_SEPARATOR );
            PrintMessage( MSG_CHANGE_PASSWORD_ON_DC );
        }

        {

            //
            // g_FirstNodeWithNonNullSCMClusterServiceAccountName points to
            // the first node with non-null pszSCMClusterServiceAccountName.
            // From Assertion 1 and Assertion 2 in routine ScChangePasswordEx() 
            // it is guaranteed that 
            // g_FirstNodeWithNonNullSCMClusterServiceAccountName != NULL.
            //
            ASSERT( g_FirstNodeWithNonNullSCMClusterServiceAccountName != NULL );          
            
            //
            // g_FirstNodeWithNonNullSCMClusterServiceAccountName->pszSCMClusterServiceAccountName: 
            //     redmond.microsoft.com\ruihu
            //
            pwszBackSlash = wcschr( g_FirstNodeWithNonNullSCMClusterServiceAccountName->pszSCMClusterServiceAccountName, L'\\');
            if ( pwszBackSlash == NULL ) 
            {
                *sc = ERROR_INVALID_ACCOUNT_NAME;
                PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, 
                              g_rgcdClusters[ 0 ].pszClusterName );
                fSuccess = FALSE;
                goto Cleanup;
            }
            *pwszBackSlash = UNICODE_NULL;
            pwszBackSlash++;
            *sc = NetUserChangePassword(
                       g_FirstNodeWithNonNullSCMClusterServiceAccountName->pszSCMClusterServiceAccountName // Domain Name
                    ,  pwszBackSlash // User Name
                    ,  pwszOldPasswordIn
                    ,  pwszNewPasswordIn
                    );
            pwszBackSlash--;
            *pwszBackSlash = L'\\';

        }


        if ( *sc != NERR_Success )
        {
            fSuccess = FALSE;
            PrintMessage ( MSG_CHANGE_PASSWORD_ON_DC_FAILED );
            goto Cleanup;
        }

    } // if: not skipping the DC change
    else
    {
        if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
        {
            PrintMessage( MSG_BLANKLINE_SEPARATOR );
            PrintMessage( MSG_SKIP_CHANGING_PASSWORD_ON_DC );
        }
    }

    fSuccess = TRUE;

Cleanup:
   
    return fSuccess;

} // ChangePasswordOnDC()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  ChangePasswordOnCluster
//
//  Description:
//
//      Change password on Cluster (g_rgcdClusters[idxClusters]).
//
//  Arguments:
//       mcpfFlags
//       idxClusters: cluster index
//       psc
//       pscLastClusterError
//
//  Return Values:
//      TRUE    Password changed successfully on g_rgcdClusters[idxClusters].
//      FALSE   Otherwise
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL 
ChangePasswordOnCluster(
      int mcpfFlags
    , size_t    idxClusters 
    , DWORD *   psc 
    , DWORD *   pscLastClusterError
    , DWORD *   pscLastNodeError
    , LPCWSTR   pwszNewPasswordIn
    )
{

    PCLUSTER_NODE_DATA  pcndNodeData = NULL;
    DWORD               cbStatusBuffer = 0;
    DWORD               cRetryCount = 0;
    size_t              cch;
    WCHAR               wszError[512];
    BOOL                fSuccess = TRUE;

    if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
    {
        PrintMessage( MSG_BLANKLINE_SEPARATOR );
        PrintMessage( MSG_CHANGE_PASSWORD_ON_CLUSTER, g_rgcdClusters[ idxClusters ].pszClusterName );
    }
    cbStatusBuffer = ( g_rgcdClusters[ idxClusters ].cNumNodes ) * sizeof( CLUSTER_SET_PASSWORD_STATUS );

    do  // Retry loop
    {

        if ( g_pcspsStatusBuffer != NULL )
        {
            HeapFree( GetProcessHeap(), 0, g_pcspsStatusBuffer );
            g_pcspsStatusBuffer = NULL;
        } // if: buffer previously allocated

        g_pcspsStatusBuffer = (PCLUSTER_SET_PASSWORD_STATUS) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, cbStatusBuffer );
        if ( g_pcspsStatusBuffer == NULL )
        {
            fSuccess = FALSE;
            *psc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        *psc = SetClusterServiceAccountPassword(
                      g_rgcdClusters[ idxClusters ].pszClusterName
                    , (LPWSTR)pwszNewPasswordIn
                    , CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES
                    , g_pcspsStatusBuffer
                    , &cbStatusBuffer
                    );

        if ( *psc == ERROR_MORE_DATA )
        {
            PrintMessage( MSG_CHANGE_CLUSTER_PASSWORD_MORE_NODES_JOIN_CLUSTER, g_rgcdClusters[ idxClusters ].pszClusterName );
        }

    } while ( *psc == ERROR_MORE_DATA && ++cRetryCount < RETRY_LIMIT ); // do: Retry loop

    switch ( *psc )
    {  /* 0 */
        case ERROR_MORE_DATA:
        {
            PrintMessage( MSG_CHANGE_CLUSTER_PASSWORD_MEMBERSHIP_UNSTABLE, g_rgcdClusters[ idxClusters ].pszClusterName, cRetryCount );
            break;
        }

        case ERROR_CLUSTER_OLD_VERSION: 
        {
            // This should never happen. 
            PrintMessage( MSG_CHANGE_CLUSTER_PASSWORD_CLUSTER_CONTAINS_NT4_OR_W2K_NODE, g_rgcdClusters[ idxClusters ].pszClusterName );
            break;
        }

        case ERROR_FILE_CORRUPT: 
        {
            PrintMessage( MSG_CHANGE_CLUSTER_PASSWORD_MESSAGE_CORRUPTED, g_rgcdClusters[ idxClusters ].pszClusterName );
            break;
        }

        case CRYPT_E_HASH_VALUE: 
        {
            PrintMessage( MSG_CHANGE_CLUSTER_PASSWORD_CRYPTO_FUNCTION_FAILED, g_rgcdClusters[ idxClusters ].pszClusterName );
            break;
        }

        case ERROR_SUCCESS:
        {  /* 1 */
            DWORD   idxStatus;
            DWORD   cStatusEntries = cbStatusBuffer / sizeof( CLUSTER_SET_PASSWORD_STATUS );

            pcndNodeData = g_rgcdClusters[ idxClusters ].pcndNodeList;
            for ( idxStatus = 0 ; idxStatus < cStatusEntries ; idxStatus++ )
            {  /* 2 */
                if ( g_pcspsStatusBuffer[ idxStatus ].SetAttempted == FALSE )
                { /* 2.1 */
                    LPWSTR pwszNodeState;

                    GetNodeStateString( pcndNodeData, &pwszNodeState );
                    PrintMessage(
                          MSG_CHANGE_CLUSTER_PASSWORD_CLUSTER_NODE_DOWN
                        , PszNodeName( pcndNodeData, g_pcspsStatusBuffer[ idxStatus ].NodeId )
                        , g_rgcdClusters[ idxClusters ].pszClusterName
                        , pwszNodeState
                        );

                    LocalFree( pwszNodeState );

                } /* 2.1 */ // if: the set operation was not attempted
                else 
                { /* 2.1 */
                    switch ( g_pcspsStatusBuffer[ idxStatus ].ReturnStatus )
                    {  /* 3 */
                        case ERROR_SUCCESS:
                        {
                            if ( ( mcpfFlags & cpfQUIET_FLAG ) == 0 )
                            {
                                PrintMessage(
                                      MSG_CHANGE_CLUSTER_PASSWORD_SUCCEEDED_ON_NODE
                                    , PszNodeName( pcndNodeData, g_pcspsStatusBuffer[ idxStatus ].NodeId )
                                    , g_rgcdClusters[ idxClusters ].pszClusterName
                                    );
                            }
                            break;
                        }

                        case ERROR_FILE_CORRUPT:
                        {
                            PrintMessage(
                                  MSG_CHANGE_CLUSTER_PASSWORD_MESSAGE_CORRUPTED_ON_NODE
                                , PszNodeName( pcndNodeData, g_pcspsStatusBuffer[ idxStatus ].NodeId )
                                , g_rgcdClusters[ idxClusters ].pszClusterName
                                );
                            break;
                        }

                        case CRYPT_E_HASH_VALUE:
                        {
                            PrintMessage(
                                    MSG_CHANGE_CLUSTER_PASSWORD_CRYPTO_FUNCTION_FAILED_ON_NODE
                                  , PszNodeName( pcndNodeData, g_pcspsStatusBuffer[ idxStatus ].NodeId )
                                  , g_rgcdClusters[ idxClusters ].pszClusterName
                                  );
                            break;
                        }

                        default:
                        {
                            cch = FormatSystemError( g_pcspsStatusBuffer[ idxStatus ].ReturnStatus, sizeof( wszError ), wszError );
                            if ( cch == 0 ) 
                            {
                                wszError[0] = L'\0';
                            }
                            PrintMessage(
                                    MSG_CHANGE_CLUSTER_PASSWORD_FAILED_ON_NODE
                                  , PszNodeName( pcndNodeData, g_pcspsStatusBuffer[ idxStatus ].NodeId )
                                  , g_rgcdClusters[ idxClusters ].pszClusterName
                                  , g_pcspsStatusBuffer[ idxStatus ].ReturnStatus
                                  , wszError
                                  );
                            break;
                        }
                    } /* 3 */ // switch: status buffer entry status value

                    // Remember last node error.
                    if ( g_pcspsStatusBuffer[ idxStatus ].ReturnStatus != ERROR_SUCCESS ) 
                    {
                        *pscLastNodeError = g_pcspsStatusBuffer[ idxStatus ].ReturnStatus;
                    }

                } /* 2.1 */ // else if: the set operation was attempted
            } /* 2 */ // for: each status buffer entry
            break;
        } /* 1 */ // case ERROR_SUCCESS

        default:
        {
            cch = FormatSystemError( *psc, sizeof( wszError ), wszError );
            if ( cch == 0 )
            {
                wszError[0] = L'\0';
            }
            PrintMessage( 
                  MSG_CHANGE_CLUSTER_PASSWORD_FAILED_ON_CLUSTER
                , g_rgcdClusters[ idxClusters ].pszClusterName
                , *psc
                , wszError
                );
            break;
        }

    } /* 0 */ // switch: return value from SetClusterServiceAccountPassword

    // Remember failure status from SetClusterServiceAccountPassword
    if ( *psc != ERROR_SUCCESS )
    {
        *pscLastClusterError = *psc;
    }

    fSuccess = TRUE;

Cleanup:

    return fSuccess;

} // ChangePasswordOnCluster()
 

//////////////////////////////////////////////////////////////////////////////
//++
//
//  PszNodeName
//
//  Description:
//      Get the name of the node from the specified node data structure.
//
//  Arguments:
//      pcndNodeDataIn
//      nNodeIdIn
//
//  Return Values:
//      Name of the node, or NULL if not found.
//
//--
//////////////////////////////////////////////////////////////////////////////
LPWSTR
PszNodeName(
      PCLUSTER_NODE_DATA    pcndNodeDataIn
    , DWORD                 nNodeIdIn
    )
{
    LPWSTR  pszNodeName = NULL;

    while ( pcndNodeDataIn != NULL )
    {
        if ( pcndNodeDataIn->nNodeId == nNodeIdIn )
        {
            pszNodeName = pcndNodeDataIn->szNodeName;
            break;
        }

        pcndNodeDataIn = pcndNodeDataIn->pcndNodeNext;
    } // while: more nodes

    return pszNodeName;

} //*** PszNodeName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScChangePasswordEx
//
//  Description:
//      Change the password for the cluster service account on DC and on 
//      all nodes in all specified clusters.
//
//  Arguments:
//      rvstrClusterNamesIn
//      pszNewPasswordIn
//      pszOldPasswordIn
//      mcpfFlags
//
//  Return Values:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
ScChangePasswordEx(
      const std::vector< CString > &    rvstrClusterNamesIn
    , LPCWSTR                           pwszNewPasswordIn
    , LPCWSTR                           pwszOldPasswordIn
    , int                               mcpfFlags
    )
{
    DWORD   sc = ERROR_SUCCESS;
    DWORD   scLastClusterError = ERROR_SUCCESS;
    DWORD   scLastNodeError = ERROR_SUCCESS;
    size_t  idxClusters;

    //
    // Init variables
    g_cNumClusters = rvstrClusterNamesIn.size();
    if ( g_cNumClusters == 0 ) 
    {
        goto Cleanup;
    }

    g_rgcdClusters = (PCLUSTER_DATA) HeapAlloc(GetProcessHeap(), 
                                               HEAP_ZERO_MEMORY, 
                                               sizeof(CLUSTER_DATA) * rvstrClusterNamesIn.size()
                                               );
    if ( g_rgcdClusters == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Parse arguments
    //
    for ( idxClusters = 0 ; idxClusters < rvstrClusterNamesIn.size() ; idxClusters++ )
    {
        g_rgcdClusters[ idxClusters ].pszClusterName = (LPCWSTR) rvstrClusterNamesIn[ idxClusters ];
    } // for: each cluster name

    //
    // Parse options
    //
    if (    ( ( mcpfFlags & cpfQUIET_FLAG ) != 0 )
        &&  ( ( mcpfFlags & cpfVERBOSE_FLAG ) != 0 )    // verbose overwrites quiet
        )
    {
        PrintMessage( MSG_CHANGE_PASSWORD_OPTION_OVERWRITTEN, L"QUIET", L"VERBOSE" );
        mcpfFlags &= ~cpfQUIET_FLAG;
    }

    if (    ( ( mcpfFlags & cpfQUIET_FLAG ) != 0 )
        &&  ( ( mcpfFlags & cpfTEST_FLAG ) != 0 )   // test overwrites quiet
        )
    {
        PrintMessage( MSG_CHANGE_PASSWORD_OPTION_OVERWRITTEN, L"QUIET", L"TEST" );
        mcpfFlags &= ~cpfQUIET_FLAG;
    }

    if (    ( ( mcpfFlags & cpfFORCE_FLAG ) != 0 )
        &&  ( ( mcpfFlags & cpfTEST_FLAG ) != 0 )   // test overwrites force
        )
    {
        PrintMessage( MSG_CHANGE_PASSWORD_OPTION_OVERWRITTEN, L"FORCE", L"TEST" );
        mcpfFlags &= ~cpfFORCE_FLAG;
    }
    
    //
    // Build node list
    //
    sc = ScBuildNodeList();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }


    //
    // The following assertions are true from this point.
    //
    // Assertion 1: about a cluster
    //
    //     FOREACH (cluster)
    //     {
    //         There exists at least one node in its cluster node list
    //         whose state is Up/Paused. And if that node is not a 
    //         NT4/Win2K node, then its pszClusterServiceAccountName
    //         and pszSCMClusterServiceAccountName are not NULL.
    //     }
    //

    // 
    // Assertion 2: about a node.
    // 
    // if (a node is Up/Paused)
    // {
    //     if (it is a NT4/Win2K node)
    //     {
    //        ASSERT(pszClusterServiceAccountName == NULL); 
    //     }
    //     else                
    //     {
    //        ASSERT(pszClusterServiceAccountName != NULL); 
    //     }
    //     ASSERT(pszSCMClusterServiceAccountName != NULL); 
    // }
    // else
    // {
    //     ASSERT(pszClusterServiceAccountName == NULL);
    //     ASSERT(pszSCMClusterServiceAccountName == NULL); 
    // }
    //

    

    //
    // Print clusters
    //
    if ( ( mcpfFlags & cpfVERBOSE_FLAG ) != 0 )
    {
        PrintClusters();
    }

    
    //
    // Validation
    //
    if ( ValidateClusters( mcpfFlags, &sc ) == FALSE )
    {
        goto Cleanup;
    }

    //
    // if /TEST option is set, we are done.
    //
    if ( ( mcpfFlags & cpfTEST_FLAG ) != 0 )
    {
        goto Cleanup;
    }

    //
    // Close cluster handle
    //
    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    {
        if ( g_rgcdClusters[ idxClusters ].hCluster != NULL )
        {
            CloseCluster( g_rgcdClusters[ idxClusters ].hCluster );
            g_rgcdClusters[ idxClusters ].hCluster = NULL;
        } // if: cluster handle is open
    } // for: each cluster


    //
    // Change password on DC
    //
    if ( ChangePasswordOnDC(mcpfFlags, &sc, pwszNewPasswordIn, pwszOldPasswordIn ) == FALSE )
    {
        goto Cleanup;
    }

    //
    // Change password on each cluster 
    //
    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    {
        if ( FALSE == ChangePasswordOnCluster(
                              mcpfFlags
                            , idxClusters
                            , &sc 
                            , &scLastClusterError
                            , &scLastNodeError
                            , pwszNewPasswordIn ) )
        {
            goto Cleanup;
        }
    } // for: each cluster

    PrintMessage( MSG_BLANKLINE_SEPARATOR );

    //
    // Error code policy:
    // If every cluster and every node succeeded, return success.
    // Else if a cluster failed, return the last cluster error.
    // Else if a node failed, return the last node error.
    //
    if ( scLastClusterError != ERROR_SUCCESS )
    {
        sc = scLastClusterError;
    }
    else if ( scLastNodeError != ERROR_SUCCESS ) 
    {
        sc = scLastNodeError;
    }
    else
    {
        sc = ERROR_SUCCESS;
    }

Cleanup:

    //
    // Clean up and return
    //
    if ( g_pcspsStatusBuffer != NULL )
    {
        HeapFree( GetProcessHeap(), 0, g_pcspsStatusBuffer );
    } // if: buffer previously allocated

    if ( g_rgcdClusters != NULL ) {
        for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
        {
            PCLUSTER_NODE_DATA  pcndNodeData[ 2 ];
    
            pcndNodeData[ 0 ] = g_rgcdClusters[ idxClusters].pcndNodeList;
            while ( pcndNodeData[ 0 ] != NULL )
            {
                pcndNodeData[ 1 ] = pcndNodeData[ 0 ]->pcndNodeNext;
    
    
                if ( pcndNodeData[ 0 ]->pszClusterServiceAccountName != NULL )
                {
                    HeapFree( GetProcessHeap(), 0, pcndNodeData[ 0 ]->pszClusterServiceAccountName );
                }
    
    
                if ( pcndNodeData[ 0 ]->pszSCMClusterServiceAccountName != NULL )
                {
                    HeapFree( GetProcessHeap(), 0, pcndNodeData[ 0 ]->pszSCMClusterServiceAccountName );
                }
    
                HeapFree( GetProcessHeap(), 0, pcndNodeData[ 0 ] );
                pcndNodeData[ 0 ] = pcndNodeData[ 1 ];
            }
        }  // for: each cluster
    }

    if ( g_rgcdClusters != NULL )
    {
        HeapFree( GetProcessHeap(), 0, g_rgcdClusters );
    } // if: buffer previously allocated

    return sc;

} //*** ChangePasswordEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      PropLstS.cpp
//
//  Abstract:
//      Stub for implementation of property list classes.
//
//  Author:
//      Galen Barbee    (GalenB)    20-Dec-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\passwordcmd.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001-2002 Microsoft Corporation
//
//  Module Name:
//      PasswordCmd.h
//
//  Description:
//      Change cluster service account password.
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//      Rui Hu (ruihu),                       01-Jun-2001
//
//  Revision History:
//      April 10, 2002  Updated for the security push
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#if !defined(_UNICODE)
#define _UNICODE 1
#endif

#if !defined(UNICODE)
#define UNICODE 1
#endif

#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <windns.h>
#include <stdio.h>
#include <stdlib.h>
#include <clusapi.h>
#include <resapi.h>
#include <string.h>
#include <lm.h>
#include <Dsgetdc.h>

#include <clusrtl.h>

// For NetServerEnum
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>
#include <lmapibuf.h>

#include <vector>

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////

#define RETRY_LIMIT         50
#define MAX_NODEID_LENGTH   100

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

enum EChangePasswordFlags
{
    cpfFORCE_FLAG       = 0x01,
    cpfQUIET_FLAG       = 0x02,
    cpfSKIPDC_FLAG      = 0x04,
    cpfTEST_FLAG        = 0x08,
    cpfVERBOSE_FLAG     = 0x10,
    cpfUNATTEND_FLAG    = 0x20
};

typedef struct CLUSTER_NODE_DATA
{
    struct CLUSTER_NODE_DATA *  pcndNodeNext;
    WCHAR                       szNodeName[ MAX_COMPUTERNAME_LENGTH+1 ];
    WCHAR                       szNodeStrId[ MAX_NODEID_LENGTH+1 ];
    DWORD                       nNodeId;
    CLUSTER_NODE_STATE          cnsNodeState;
    LPWSTR                      pszSCMClusterServiceAccountName;
                                // cluster service account stored in SCM
    LPWSTR                      pszClusterServiceAccountName; 
                                // account cluster service is currrently using
} CLUSTER_NODE_DATA, * PCLUSTER_NODE_DATA;

typedef struct CLUSTER_DATA
{
    LPCWSTR             pszClusterName;
    HCLUSTER            hCluster;
    DWORD               cNumNodes;
    DWORD               dwMixedMode; // 0 - does not contain NT4 or Win2K node(s)
                                     // 1 - contains NT4 or Win2K node(s)
    PCLUSTER_NODE_DATA  pcndNodeList;
} CLUSTER_DATA, * PCLUSTER_DATA;

//////////////////////////////////////////////////////////////////////////////
//  Function Prototypes
//////////////////////////////////////////////////////////////////////////////

DWORD
ScChangePasswordEx(
      const std::vector< CString > &    rvstrClusterNamesIn
    , LPCWSTR                           pszNewPasswordIn
    , LPCWSTR                           pszOldPasswordIn
    , int                               mcpfFlagsIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\rename.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Rename.cpp
//
//  Abstract:
//      Commands for modules which are renamable.
//
//  Author:
//      Michael Burton (t-mburt)              25-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 11, 2002  Updated for the security push.
//
//////////////////////////////////////////////////////////////////////////////
#include "rename.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRenamableModuleCmd::CRenamableModuleCmd
//
//	Routine Description:
//		Default Constructor
//		Initializes all the DWORD parameters to UNDEFINED and
//		all the pointers to cluster functions to NULL.
//		*ALL* these variables must be defined in any derived class.
//
//	Arguments:
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		m_dwMsgModuleRenameCmd			SET to UNDEFINED
//		m_pfnSetClusterModuleName		SET to NULL
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRenamableModuleCmd::CRenamableModuleCmd( CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	m_dwMsgModuleRenameCmd	  = UNDEFINED;
	m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) NULL;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRenamableModuleCmd::Execute
//
//	Routine Description:
//		Takes a command line option and determines which command to
//		execute.  If no command line option specified, gets the next one
//		automatically.	If the token is not identifed as being handle-able
//		in this class, the token is passed up to CGenericModuleCmd::Execute
//		unless DONT_PASS_HIGHER is specified as the second parameter, 
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	ExecuteOption eEOpt							
//			OPTIONAL enum, either DONT_PASS_HIGHER or
//			PASS_HIGHER_ON_ERROR (default)
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRenamableModuleCmd::Execute( const CCmdLineOption & option, 
									ExecuteOption eEOpt )
	throw( CSyntaxException )
{
	// Look up the command
	if ( option.GetType() == optRename )
		return Rename( option );

	if (eEOpt == PASS_HIGHER_ON_ERROR)
		return CGenericModuleCmd::Execute( option );
	else
		return ERROR_NOT_HANDLED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRenamableModuleCmd::Rename
//
//	Routine Description:
//		Renames the specified module to the new name
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Module name
//		m_dwMsgModuleRenameCmd		Command Control to rename module
//		m_dwMsgStatusHeader 		Listing header
//		m_pfnSetClusterModuleName	Function to set module name
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRenamableModuleCmd::Rename( const CCmdLineOption & thisOption )
	throw( CSyntaxException )
{
	// This option takes exactly one value.
	if ( thisOption.GetValues().size() != 1 )
	{
        CSyntaxException se( SeeHelpStringID() );
		se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
        CSyntaxException se( SeeHelpStringID() );
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	const CString & strNewName = ( thisOption.GetValues() )[0];

	assert(m_dwMsgModuleRenameCmd != UNDEFINED);
	PrintMessage( m_dwMsgModuleRenameCmd, (LPCWSTR) m_strModuleName );

	assert(m_pfnSetClusterModuleName);
	dwError = m_pfnSetClusterModuleName( m_hModule, strNewName );

	assert(m_dwMsgStatusHeader != UNDEFINED);
	PrintMessage( m_dwMsgStatusHeader );
	PrintStatus( strNewName );

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      precomp.h
//
//  Abstract:
//      This file contains some standard headers used by files in the
//      cluster.exe project. Putting them all in one file (when precompiled headers
//      are used) speeds up the compilation process.
//
//  Implementation File:
//      The CComModule _Module declared in this file is instantiated in cluster.cpp
//
//  Author:
//      Vijayendra Vasu (vvasu) September 16, 1998
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002  Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

/////////////////////////////////////////////////////////////////////////////
//  Preprocessor settings for the project and other
//  miscellaneous pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4250 )   // 'class' inherits 'method' via dominence
#pragma warning( disable : 4290 )   // exception specification ignored
#pragma warning( disable : 4512 )   // assignment operator could not be generated
#pragma warning( disable : 4663 )   // class template 'vector' specialization

#ifndef _UNICODE
#define _UNICODE
#endif

#ifndef UNICODE
#define UNICODE
#endif


/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

//
// Enable cluster debug reporting
//
#if DBG
#define CLRTL_INCLUDE_DEBUG_REPORTING
#endif // DBG
#include "ClRtlDbg.h"
#define ASSERT _CLRTL_ASSERTE
#define ATLASSERT ASSERT

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <wincrypt.h>
#include <windns.h>
#include <Dsgetdc.h>
#include <Lm.h>
#include <Nb30.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <assert.h>

#include <clusapi.h>
#include <clusrtl.h>

#include <atlbase.h>

extern CComModule _Module;

#include <atlapp.h>

#pragma warning( push )
#pragma warning( disable : 4267 )   // conversion from 'type1' to 'type1'
#include <atltmp.h>
#pragma warning( pop )

// For cluster configuration server COM objects.
#include <ClusCfgGuids.h>
#include <ClusCfgInternalGuids.h>
#include <Guids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

// For trace macros such as THR
#define USES_SYSALLOCSTRING
#include <debug.h>
#include <EncryptedBSTR.h>

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\rename.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2002 Microsoft Corporation
//
//  Module Name:
//      Rename.h
//
//  Abstract:
//      Interfaces for modules which are renamable.
//
//  Author:
//      Michael Burton (t-mburt)              25-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002  Updated for the security push.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include "modcmd.h"

class CRenamableModuleCmd : virtual public CGenericModuleCmd
{
public:
	CRenamableModuleCmd( CCommandLine & cmdLine );

protected:
	// Additional Commands
	// Additional Commands
	virtual DWORD Execute( const CCmdLineOption & option, 
						   ExecuteOption eEOpt = PASS_HIGHER_ON_ERROR  )
		throw( CSyntaxException );

	virtual DWORD Rename( const CCmdLineOption & thisOption )
		throw( CSyntaxException );


	DWORD   m_dwMsgModuleRenameCmd;
	DWORD (*m_pfnSetClusterModuleName) (HCLUSMODULE,LPCWSTR);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\rescmd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      rescmd.h
//
//  Abstract:
//      Interface for commands which may be performed on resources
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002  Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once
#include "resumb.h"
#include "rename.h"

class CCommandLine;

class CResourceCmd :	public CRenamableModuleCmd,
						public CResourceUmbrellaCmd
{
public:
	CResourceCmd( const CString & strClusterName, CCommandLine & cmdLine );

	DWORD Execute();

private:
	DWORD Create( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Move( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD Online( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Offline( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD FailResource( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD AddDependency( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveDependency( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD ListDependencies( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD AddOwner( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveOwner( const CCmdLineOption & thisOption ) throw( CSyntaxException );

	DWORD AddCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetChkPointsForResource( const CString & strResourceName );

	DWORD AddCryptoCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD RemoveCryptoCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetCryptoCheckPoints( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD GetCryptoChkPointsForResource( const CString & strResourceName );

	DWORD PrintHelp();
	virtual DWORD SeeHelpStringID() const;
	DWORD PrintStatus( LPCWSTR lpszResourceName );
	DWORD PrintStatus2( LPCWSTR lpszResourceName, LPCWSTR lpszNodeName );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cluster.rc
//

#define IDS_PASSWORD_PROMPT             1000
#define IDS_NEW_PASSWORD_PROMPT         1001
#define IDS_OLD_PASSWORD_PROMPT         1002
#define IDS_CONFIRM_NEW_PASSWORD_PROMPT 1003
#define IDS_PASSWORD_MISMATCH           1004

#define IDS_CLUSCFG_PROGRESS_FORMAT             1050
#define IDS_CLUSCFG_PREPARING_TO_CREATE_CLUSTER 1051
#define IDS_CLUSCFG_PREPARING_TO_ADD_NODES      1052
#define IDS_CLUSCFG_PREPARING_TO_ADD_NODES_2    1053
#define IDS_CLUSCFG_ANALYZING                   1054
#define IDS_CLUSCFG_CREATING                    1055
#define IDS_CLUSCFG_ADDING_NODES                1056
#define IDS_CLUSCFG_MIN_CONFIG_CREATE_CLUSTER   1057
#define IDS_CLUSCFG_MIN_CONFIG_ADD_NODES        1058

#define IDS_CLUSCFG_DONE                        1060

#define IDS_TASKID_UNKNOWN                              1100

#define IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER  1101
#define IDS_TASKID_MAJOR_ESTABLISH_CONNECTION           1102
#define IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY         1103
#define IDS_TASKID_MAJOR_FIND_DEVICES                   1104
#define IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY      1105
#define IDS_TASKID_MAJOR_REANALYZE                      1106
#define IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES     1107
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES       1108
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCES            1109

//  Copies from Mgmt\ClusCfg\Wizard\WizardStrings.h for use by NameUtilStub.cpp
#define ID_WIZ_START 1000 // Changed from original to fit with IDs here.
#define IDS_TASKID_MINOR_FQDN_DNS_BINDING_FAILED            ( ID_WIZ_START + 201 )
#define IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_FAILED     ( ID_WIZ_START + 202 )
#define IDS_TASKID_MINOR_NETBIOS_RESET_FAILED               ( ID_WIZ_START + 203 )
#define IDS_TASKID_MINOR_NETBIOS_BINDING_SUCCEEDED          ( ID_WIZ_START + 204 )
#define IDS_TASKID_MINOR_NETBIOS_BINDING_FAILED             ( ID_WIZ_START + 205 )
#define IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_SUCCEEDED  ( ID_WIZ_START + 206 )
#define IDS_TASKID_MINOR_MULTIPLE_DNS_RECORDS_FOUND         ( ID_WIZ_START + 207 )
#define IDS_TASKID_MINOR_FQDN_DNS_BINDING_SUCCEEDED         ( ID_WIZ_START + 208 )
#define IDS_TASKID_MINOR_NETBIOS_LANAENUM_FAILED            ( ID_WIZ_START + 209 )

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\resgcmd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      resgcmd.h
//
//  Abstract:
//      Interface for functions which may be performed on a resource group object.
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once
#include "resumb.h"
#include "rename.h"

class CCommandLine;

class CResGroupCmd :	public CRenamableModuleCmd,
						public CResourceUmbrellaCmd
{
public:
	CResGroupCmd( const CString & strClusterName, CCommandLine & cmdLine );

	// Parse and execute the command line
	DWORD Execute();

protected:

	virtual DWORD SeeHelpStringID() const;

	// Specific Commands
	DWORD PrintHelp();

	DWORD PrintStatus( LPCWSTR lpszGroupName );
	DWORD PrintStatus2( LPCWSTR lpszGroupName, LPCWSTR lpszNodeName );

	DWORD SetOwners( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Create( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Delete( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Move( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Online( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD Offline( const CCmdLineOption & thisOption ) throw( CSyntaxException );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\rescmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      rescmd.cpp
//
//  Abstract:
//      Resource Commands
//      Implements commands which may be performed on resources
//
//  Author:
//      Charles Stacy Harris III (stacyh)   20-March-1997
//      Michael Burton (t-mburt)            04-Aug-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "cluswrap.h"
#include "rescmd.h"

#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::CResourceCmd
//
//  Routine Description:
//      Constructor
//      Initializes all the DWORD params used by CGenericModuleCmd,
//      CRenamableModuleCmd, and CResourceUmbrellaCmd to
//      provide generic functionality.
//
//  Arguments:
//      IN  const CString & strClusterName
//          Name of the cluster being administered
//
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceCmd::CResourceCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine ), CRenamableModuleCmd( cmdLine ),
    CResourceUmbrellaCmd( cmdLine )
{
    m_strClusterName = strClusterName;
    m_strModuleName.Empty();

    m_hCluster = NULL;
    m_hModule = NULL;

    m_dwMsgStatusList          = MSG_RESOURCE_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_RESOURCE_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_RESOURCE_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_RES_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_RES_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_RES_ALL;
    m_dwCtlGetPrivProperties   = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_RESOURCE;
    m_pfnOpenClusterModule     = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterResource;
    m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterResource;
    m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterResourceControl;
    m_pfnClusterOpenEnum       = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterResourceOpenEnum;
    m_pfnClusterCloseEnum      = (DWORD(*)(HCLUSENUM)) ClusterResourceCloseEnum;
    m_pfnWrapClusterEnum         = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterResourceEnum;

    // Renamable Properties
    m_dwMsgModuleRenameCmd    = MSG_RESCMD_RENAME;
    m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) SetClusterResourceName;

    // Resource Umbrella Properties
    m_dwMsgModuleStatusListForNode  = MSG_RESOURCE_STATUS_LIST_FOR_NODE;
    m_dwClstrModuleEnumNodes        = CLUSTER_RESOURCE_ENUM_NODES;
    m_dwMsgModuleCmdListOwnersList  = MSG_RESCMD_OWNERS;
    m_dwMsgModuleCmdListOwnersHeader= MSG_NODELIST_HEADER;
    m_dwMsgModuleCmdListOwnersDetail= MSG_NODELIST_DETAIL;
    m_dwMsgModuleCmdDelete          = MSG_RESCMD_DELETE;
    m_pfnDeleteClusterModule        = (DWORD(*)(HCLUSMODULE)) DeleteClusterResource;

} //*** CResourceCmd::CResourceCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent classes (first CRenamableModuleCmd, then CRsourceUmbrellaCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Execute()
{
    m_theCommandLine.ParseStageTwo();

    DWORD dwReturnValue = ERROR_SUCCESS;

    const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

    vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
    vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

    CSyntaxException se( SeeHelpStringID() );

    if ( curOption == lastOption )
    {
        dwReturnValue = Status( NULL );
        goto Cleanup;
    }

    while ( ( curOption != lastOption ) && ( dwReturnValue == ERROR_SUCCESS ) )
    {
        switch ( curOption->GetType() )
        {
            case optHelp:
            {
                // If help is one of the options, process no more options.
                dwReturnValue = PrintHelp();
                goto Cleanup;
            }

            case optDefault:
            {
                const vector<CCmdLineParameter> & paramList = curOption->GetParameters();

                //  Check number of parameters.
                if ( paramList.size() == 0 )
                {
                    se.LoadMessage( IDS_MISSING_PARAMETERS );
                    throw se;
                }
                else if ( paramList.size() > 1 )
                {
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_NO_NAME );
                    throw se;
                }

                const CCmdLineParameter & param = paramList[0];


                // If we are here, then it is either because /node:nodeName
                // has been specified or because a group name has been given.
                // Note that the /node:nodeName switch is not treated as an option.
                // It is really a parameter to the implicit /status command.

                if ( param.GetType() == paramNodeName )
                {
                    const vector<CString> & valueList = param.GetValues();

                    // This parameter takes exactly one value.
                    if ( valueList.size() != 1 )
                    {
                        se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, param.GetName() );
                        throw se;
                    }

                    m_strModuleName.Empty();
                    dwReturnValue = Status( valueList[0], TRUE /* bNodeStatus */ );

                } // if: A node name has been specified
                else
                {
                    if ( param.GetType() != paramUnknown )
                    {
                        se.LoadMessage( MSG_INVALID_PARAMETER, param.GetName() );
                        throw se;
                    }

                    // This parameter takes no values.
                    if ( param.GetValues().size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
                        throw se;
                    }

                    m_strModuleName = param.GetName();

                    // No more options are provided, just show status.
                    // For example: cluster myCluster node myNode
                    if ( ( curOption + 1 ) == lastOption )
                    {
                        dwReturnValue = Status( m_strModuleName, FALSE /* bNodeStatus */ );
                    }

                } // else: No node name has been specified.

                break;

            } // case optDefault

            case optStatus:
            {
                // This option takes no values.
                if ( curOption->GetValues().size() != 0 )
                {
                    se.LoadMessage( MSG_OPTION_NO_VALUES, curOption->GetName() );
                    throw se;
                }

                // This option takes no parameters.
                if ( curOption->GetParameters().size() != 0 )
                {
                    se.LoadMessage( MSG_OPTION_NO_PARAMETERS, curOption->GetName() );
                    throw se;
                }

                dwReturnValue = Status( m_strModuleName,  FALSE /* bNodeStatus */ );
                break;
            }

            case optOnline:
            {
                dwReturnValue = Online( *curOption );
                break;
            }

            case optFail:
            {
                dwReturnValue = FailResource( *curOption );
                break;
            }

            case optAddDependency:
            {
                dwReturnValue = AddDependency( *curOption );
                break;
            }

            case optRemoveDependency:
            {
                dwReturnValue = RemoveDependency( *curOption );
                break;
            }

            case optListDependencies:
            {
                dwReturnValue = ListDependencies( *curOption );
                break;
            }

            case optAddOwner:
            {
                dwReturnValue = AddOwner( *curOption );
                break;
            }

            case optRemoveOwner:
            {
                dwReturnValue = RemoveOwner( *curOption );
                break;
            }

            case optAddCheckPoints:
            {
                dwReturnValue = AddCheckPoints( *curOption );
                break;
            }

            case optRemoveCheckPoints:
            {
                dwReturnValue = RemoveCheckPoints( *curOption );
                break;
            }

            case optGetCheckPoints:
            {
                dwReturnValue = GetCheckPoints( *curOption );
                break;
            }

            case optAddCryptoCheckPoints:
            {
                dwReturnValue = AddCryptoCheckPoints( *curOption );
                break;
            }

            case optRemoveCryptoCheckPoints:
            {
                dwReturnValue = RemoveCryptoCheckPoints( *curOption );
                break;
            }

            case optGetCryptoCheckPoints:
            {
                dwReturnValue = GetCryptoCheckPoints( *curOption );
                break;
            }

            default:
            {
                dwReturnValue = CRenamableModuleCmd::Execute( *curOption, DONT_PASS_HIGHER );

                if ( dwReturnValue == ERROR_NOT_HANDLED )
                    dwReturnValue = CResourceUmbrellaCmd::Execute( *curOption );
            }

        } // switch: based on the type of option

        PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
        ++curOption;
    } // for each option in the list

Cleanup:

    return dwReturnValue;

} //*** CResourceCmd::Execute()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Resources
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::PrintHelp()
{
    return PrintMessage( MSG_HELP_RESOURCE );

} //*** CResourceCmd::PrintHelp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::SeeHelpStringID
//
//  Routine Description:
//      Provides the message ID of the string that shows what command line to
//      use to get help for this kind of command.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The command-specific message ID.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::SeeHelpStringID() const
{
    return MSG_SEE_RESOURCE_HELP;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszResourceName                Name of the module
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintStatus2
//
//--
/////////////////////////////////////////////////////////////////////////////
inline DWORD CResourceCmd::PrintStatus( LPCWSTR lpszResourceName )
{
    return PrintStatus2(lpszResourceName, NULL);

} //*** CResourceCmd::PrintStatus()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintStatus2
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      pwszResourceName            Name of the module
//      pwszNodeName                Name of the node
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::PrintStatus2( LPCWSTR pwszResourceName, LPCWSTR pwszNodeName )
{
    DWORD                   sc = ERROR_SUCCESS;
    CLUSTER_RESOURCE_STATE  nState;
    LPWSTR                  pwszResNodeName = NULL;
    LPWSTR                  pwszResGroupName = NULL;
    HRESOURCE               hResource;
    LPWSTR                  pwszStatus = NULL;

    hResource = OpenClusterResource( m_hCluster, pwszResourceName );
    if ( hResource == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    nState = WrapGetClusterResourceState( hResource, &pwszResNodeName, &pwszResGroupName );
    if ( nState == ClusterResourceStateUnknown )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    //zap! Check the group name also! needs to be passed in...

    // if the node names don't match just return.
    if ( pwszNodeName && *pwszNodeName )  // non-null and non-empty
    {
        if( lstrcmpi( pwszResNodeName, pwszNodeName ) != 0 )
        {
            sc = ERROR_SUCCESS;
        }
    }

    switch( nState )
    {
        case ClusterResourceInherited:
            LoadMessage( MSG_STATUS_INHERITED, &pwszStatus );
            break;

        case ClusterResourceInitializing:
            LoadMessage( MSG_STATUS_INITIALIZING, &pwszStatus );
            break;

        case ClusterResourceOnline:
            LoadMessage( MSG_STATUS_ONLINE, &pwszStatus );
            break;

        case ClusterResourceOffline:
            LoadMessage( MSG_STATUS_OFFLINE, &pwszStatus );
            break;

        case ClusterResourceFailed:
            LoadMessage( MSG_STATUS_FAILED, &pwszStatus );
            break;

        case ClusterResourcePending:
            LoadMessage( MSG_STATUS_PENDING, &pwszStatus );
            break;

        case ClusterResourceOnlinePending:
            LoadMessage( MSG_STATUS_ONLINEPENDING, &pwszStatus );
            break;

        case ClusterResourceOfflinePending:
            LoadMessage( MSG_STATUS_OFFLINEPENDING, &pwszStatus );
            break;

        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &pwszStatus  );
            break;

    } // switch: nState

    sc = PrintMessage( MSG_RESOURCE_STATUS, pwszResourceName, pwszResGroupName, pwszResNodeName, pwszStatus );

Cleanup:

    // Since Load/FormatMessage uses LocalAlloc...
    LocalFree( pwszStatus );
    LocalFree( pwszResNodeName );
    LocalFree( pwszResGroupName );

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    }

    return sc;

} //*** CResourceCmd::PrintStatus2()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Create
//
//  Routine Description:
//      Create a resource.  Reads the command line to get
//      additional options
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_hModule                   Resource Handle
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Create( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    CString strGroupName;
    CString strResType;
    DWORD dwFlags = 0;

    strGroupName.Empty();
    strResType.Empty();

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bGroupNameFound = FALSE, bTypeFound = FALSE, bSeparateFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramGroupName:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bGroupNameFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strGroupName = valueList[0];
                bGroupNameFound = TRUE;
                break;

            case paramResType:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bTypeFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strResType = valueList[0];
                bTypeFound = TRUE;
                break;

            case paramSeparate:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 0 )
                {
                    se.LoadMessage( MSG_PARAM_NO_VALUES, curParam->GetName() );
                    throw se;
                }

                if ( bSeparateFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                dwFlags |= CLUSTER_RESOURCE_SEPARATE_MONITOR;  // treat as bit mask for future
                bSeparateFound = TRUE;
                break;

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }
        }

        ++curParam;
    }


    if( strGroupName.IsEmpty() || strResType.IsEmpty() )
    {
        se.LoadMessage( IDS_MISSING_PARAMETERS );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    HGROUP hGroup = OpenClusterGroup( m_hCluster, strGroupName );

    if( !hGroup )
        return GetLastError();

    PrintMessage( MSG_RESCMD_CREATE, (LPCWSTR) m_strModuleName );

    m_hModule = CreateClusterResource( hGroup, m_strModuleName, strResType, dwFlags );


    if( !m_hModule )
        return GetLastError();

    PrintMessage( MSG_RESOURCE_STATUS_HEADER );
    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::Create()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Move
//
//  Routine Description:
//      Move the resource to a new group.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Move( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strGroupName = (thisOption.GetValues())[0];

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    // Check to see if there is a value for the destination node.
    HGROUP hDestGroup = 0;

    hDestGroup = OpenClusterGroup( m_hCluster, strGroupName );

    if( !hDestGroup )
        return GetLastError();


    PrintMessage( MSG_RESCMD_MOVE, (LPCWSTR) m_strModuleName, strGroupName );

    dwError = ChangeClusterResourceGroup( (HRESOURCE) m_hModule, hDestGroup );

    CloseClusterGroup( hDestGroup );


    if( dwError != ERROR_SUCCESS )
        return dwError;


    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    dwError = PrintStatus( m_strModuleName );


    return dwError;

} //*** CResourceCmd::Move()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Online
//
//  Routine Description:
//      Bring a resource online with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Online( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // Finish command line parsing
    DWORD dwWait = INFINITE;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;
    BOOL bPending = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                size_t nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    // Execute command
    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    PrintMessage( MSG_RESCMD_ONLINE, (LPCWSTR) m_strModuleName );

    dwError = ScWrapOnlineClusterResource( m_hCluster, (HRESOURCE) m_hModule, dwWait, (long *) &bPending );
    if( dwError != ERROR_SUCCESS )
        return dwError;

    if ( bPending )
        return ERROR_IO_PENDING;

    // Print status
    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::Online()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::Offline
//
//  Routine Description:
//      Take a resource offline with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::Offline( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // Finish command line parsing
    DWORD dwWait = INFINITE;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;
    BOOL bPending = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                size_t nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    // Execute command
    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    PrintMessage( MSG_RESCMD_OFFLINE, (LPCWSTR) m_strModuleName );

    dwError = ScWrapOfflineClusterResource( m_hCluster, (HRESOURCE) m_hModule, dwWait, (long *) &bPending );
    if( dwError != ERROR_SUCCESS )
        return dwError;

    if ( bPending )
        return ERROR_IO_PENDING;

    // Print status
    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::Offline()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::FailResource
//
//  Routine Description:
//      Fail a resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::FailResource( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    PrintMessage( MSG_RESCMD_FAIL, (LPCWSTR) m_strModuleName );

    dwError = FailClusterResource( (HRESOURCE) m_hModule );

    if( dwError != ERROR_SUCCESS )
        return dwError;

    PrintMessage( MSG_RESOURCE_STATUS_HEADER );
    dwError = PrintStatus( m_strModuleName );

    return dwError;

} //*** CResourceCmd::FailResource()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::AddDependency
//
//  Routine Description:
//      Add a resource dependency to the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddDependency( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strDependResource = ( thisOption.GetValues() )[0];

    if( strDependResource.IsEmpty() != FALSE )
    {
        se.LoadMessage( MSG_NO_NODE_NAME );
        throw se;
    }


    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HRESOURCE hResourceDep = OpenClusterResource( m_hCluster, strDependResource );

    if( !hResourceDep )
        return GetLastError();

    PrintMessage( MSG_RESCMD_ADDDEP, (LPCWSTR) m_strModuleName, strDependResource );

    dwError = AddClusterResourceDependency( (HRESOURCE) m_hModule, hResourceDep );

    CloseClusterResource( hResourceDep );

    return dwError;

} //*** CResourceCmd::AddDependency()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::RemoveDependency
//
//  Routine Description:
//      Remove a resource dependency
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveDependency( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }


    const CString & strDependResource = ( thisOption.GetValues() )[0];

    if( strDependResource.IsEmpty() != FALSE )
    {
        se.LoadMessage( MSG_NO_NODE_NAME );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    HRESOURCE hResourceDep = OpenClusterResource( m_hCluster, strDependResource );

    if( !hResourceDep )
        return GetLastError();

    PrintMessage( MSG_RESCMD_REMOVEDEP, (LPCWSTR) m_strModuleName, strDependResource );

    dwError = RemoveClusterResourceDependency( (HRESOURCE) m_hModule, hResourceDep );

    CloseClusterResource( hResourceDep );

    return dwError;

} //*** CResourceCmd::RemoveDependency()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::ListDependency
//
//  Routine Description:
//      List the resource depencies
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::ListDependencies( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD       sc = ERROR_SUCCESS;
    DWORD       idx = 0;
    DWORD       dwType = 0;
    LPWSTR      pwszName = NULL;
    HRESENUM    hEnum = NULL;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    hEnum = ClusterResourceOpenEnum( (HRESOURCE) m_hModule, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if( hEnum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    PrintMessage( MSG_RESCMD_LISTDEP, (LPCWSTR) m_strModuleName );
    PrintMessage( MSG_RESOURCE_STATUS_HEADER );

    sc = ERROR_SUCCESS;
    for( idx = 0; sc == ERROR_SUCCESS; idx++ )
    {
        sc = WrapClusterResourceEnum( hEnum, idx, &dwType, &pwszName );

        if( sc == ERROR_SUCCESS )
        {
            PrintStatus( pwszName );
        }
        LocalFree( pwszName );
    } // for:

    if( sc == ERROR_NO_MORE_ITEMS )
    {
        sc = ERROR_SUCCESS;
    }

Cleanup:

    if ( hEnum != NULL )
    {
        ClusterResourceCloseEnum( hEnum );
    }

    return sc;

} //*** CResourceCmd::ListDependencies()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::AddOwner
//
//  Routine Description:
//      Add an owner to the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddOwner( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strNodeName = ( thisOption.GetValues() )[0];

    if( strNodeName.IsEmpty() != FALSE )
    {
        se.LoadMessage( MSG_NO_NODE_NAME );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HNODE hNode = OpenClusterNode( m_hCluster, strNodeName );

    if( !hNode )
        return GetLastError();

    PrintMessage( MSG_RESCMD_ADDNODE, (LPCWSTR) m_strModuleName, strNodeName );

    dwError = AddClusterResourceNode( (HRESOURCE) m_hModule, hNode );

    CloseClusterNode( hNode );

    return dwError;

} //*** CResourceCmd::AddOwner()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::RemoveOwner
//
//  Routine Description:
//      Remove an owner from the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveOwner( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes exactly one value.
    if ( thisOption.GetValues().size() != 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const CString & strNodeName = ( thisOption.GetValues() )[0];

    if( strNodeName.IsEmpty() != FALSE )
    {
        se.LoadMessage( MSG_NO_NODE_NAME );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    HNODE hNode = OpenClusterNode( m_hCluster, strNodeName );

    if( !hNode )
        return GetLastError();

    PrintMessage( MSG_RESCMD_REMOVENODE, (LPCWSTR) m_strModuleName, strNodeName );

    dwError = RemoveClusterResourceNode( (HRESOURCE) m_hModule, hNode );

    CloseClusterNode( hNode );

    return dwError;

} //*** CResourceCmd::RemoveOwner()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::AddCheckPoints
//
//  Routine Description:
//      Add registry checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were added successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    DWORD   sc = ERROR_SUCCESS;
    size_t  idx;

    const vector<CString> & valueList = thisOption.GetValues();
    size_t nNumberOfCheckPoints = valueList.size();


    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        se.LoadMessage( IDS_NO_RESOURCE_NAME );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if( sc != ERROR_SUCCESS )
    {
        CloseCluster();
        goto Cleanup;
    }

    for ( idx = 0; idx < nNumberOfCheckPoints; ++idx )
    {
        const CString & strCurrentCheckPoint = valueList[idx];
        LPCWSTR lpcszIcchBuffer = strCurrentCheckPoint;

        PrintMessage(
            MSG_RESCMD_ADDING_REG_CHECKPOINT,
            (LPCWSTR) m_strModuleName,
            (LPCWSTR) strCurrentCheckPoint
            );

        sc = ClusterResourceControl(
            ( HRESOURCE ) m_hModule,
            NULL,
            CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
            (LPVOID) ( (LPCWSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( *lpcszIcchBuffer ),
            NULL,
            0,
            NULL
            );

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }
    } // for:

    CloseModule();
    CloseCluster();

Cleanup:

    return sc;

} //*** CResourceCmd::AddCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::RemoveCheckPoints
//
//  Routine Description:
//      Remove registry checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were removed successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD sc = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    size_t nNumberOfCheckPoints = valueList.size();

    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        se.LoadMessage( IDS_NO_RESOURCE_NAME );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
        return sc;

    sc = OpenModule();
    if( sc != ERROR_SUCCESS )
    {
        CloseCluster();
        return sc;
    }

    for ( size_t idx = 0; idx < nNumberOfCheckPoints; ++idx )
    {
        const CString & strCurrentCheckPoint = valueList[idx];

        PrintMessage(
            MSG_RESCMD_REMOVING_REG_CHECKPOINT,
            (LPCWSTR) m_strModuleName,
            (LPCWSTR) strCurrentCheckPoint
            );

        sc = ClusterResourceControl(
            ( HRESOURCE ) m_hModule,
            NULL,
            CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
            (LPVOID) ( (LPCWSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( WCHAR ),
            NULL,
            0,
            NULL
            );

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return sc;

} //***CResourceCmd::RemoveCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetCheckPoints
//
//  Routine Description:
//      Gets a list of registry checkpoints for one or more resources
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD sc = ERROR_SUCCESS;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
        return sc;

    // If no resource name is specified list the checkpoints of all resources.
    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        HCLUSENUM hResourceEnum;

        hResourceEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESOURCE  );
        if ( NULL == hResourceEnum )
        {
            sc = GetLastError();
        }
        else
        {
            CString strCurResName;
            LPWSTR pszNodeNameBuffer;

            // Emperically allocate space for MAX_PATH characters.
            DWORD nResNameBufferSize = MAX_PATH;
            pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );

            PrintMessage( MSG_RESCMD_LISTING_ALL_REG_CHECKPOINTS );
            PrintMessage( MSG_PROPERTY_HEADER_REG_CHECKPOINT );

            for ( DWORD dwIndex = 0; ERROR_SUCCESS == sc;  )
            {
                DWORD dwObjectType;
                DWORD nInOutBufferSize = nResNameBufferSize;

                sc = ClusterEnum( hResourceEnum, dwIndex, &dwObjectType,
                    pszNodeNameBuffer, &nInOutBufferSize );

                // We have enumerated all resources.
                if ( ERROR_NO_MORE_ITEMS == sc )
                {
                    sc = ERROR_SUCCESS;
                    break;
                }

                if ( ERROR_MORE_DATA == sc )
                {
                    sc = ERROR_SUCCESS;
                    strCurResName.ReleaseBuffer();

                    nResNameBufferSize = nInOutBufferSize + 1;
                    pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );
                }
                else
                {
                    ++dwIndex;

                    if ( ( ERROR_SUCCESS == sc ) &&
                         ( CLUSTER_ENUM_RESOURCE == dwObjectType ) )
                    {
                        sc =  GetChkPointsForResource( pszNodeNameBuffer );

                    } // if: we successfully got the name of a resource.

                } // else: We got all the data that ClusterEnum wanted to return.

            } // While there are more resources to be enumerated.

            strCurResName.ReleaseBuffer();

            ClusterCloseEnum( hResourceEnum );
        } // else: hResourceEnum is not NULL.

    } // if: m_strModuleName is empty.
    else
    {
        PrintMessage( MSG_RESCMD_LISTING_REG_CHECKPOINTS, (LPCWSTR) m_strModuleName );
        PrintMessage( MSG_PROPERTY_HEADER_REG_CHECKPOINT );

        sc = GetChkPointsForResource( m_strModuleName );

    } // else: m_strModuleName is not empty.

    CloseCluster();

    return sc;

} //*** CResourceCmd::GetCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetChkPointsForResource
//
//  Routine Description:
//      Gets a list of registry checkpoints for one resource
//
//  Arguments:
//      strResourceName [IN]        The name of the resource whose checkpoints
//                                  are to be listed.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//  Remarks:
//      m_hCluster should contain a valid handle to an open cluster before this
//      function is called.
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetChkPointsForResource( const CString & strResourceName )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD       sc = ERROR_SUCCESS;
    HRESOURCE   hCurrentResource = NULL;
    LPWSTR      pwszOutBuffer = NULL;
    DWORD       cchBufferSize = MAX_PATH;
    DWORD       cchRequiredSize = 0;
    LPWSTR      pwszCheckPoints = NULL;

    hCurrentResource = OpenClusterResource( m_hCluster, strResourceName );
    if ( NULL == hCurrentResource )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    for ( ;; )
    {
        pwszOutBuffer = new WCHAR[ cchBufferSize ];
        if ( pwszOutBuffer == NULL )
        {
            sc = GetLastError();
            break;
        }

        sc = ClusterResourceControl(
                                        hCurrentResource,
                                        NULL,
                                        CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS,
                                        NULL,
                                        0,
                                        (LPVOID) pwszOutBuffer,
                                        cchBufferSize,
                                        &cchRequiredSize
                                   );

        if ( sc == ERROR_MORE_DATA )
        {
            cchBufferSize = cchRequiredSize;
            delete [] pwszOutBuffer;
            pwszOutBuffer = NULL;
        }
        else
        {
            break;
        }

    } // for: ever

    // We have retrieved the checkpoints successfully.
    if ( sc == ERROR_SUCCESS )
    {
        pwszCheckPoints = pwszOutBuffer;

        // There are no checkpoints for this resource.
        if ( 0 == cchRequiredSize )
        {
            PrintMessage( MSG_RESCMD_NO_REG_CHECKPOINTS_PRESENT, (LPCWSTR) strResourceName );
        }
        else
        {
            while ( *pwszCheckPoints != L'\0' )
            {
                PrintMessage( MSG_REG_CHECKPOINT_STATUS, (LPCWSTR) strResourceName, pwszCheckPoints );

                // Move to next checkpoint.
                do
                {
                    ++pwszCheckPoints;
                } while ( *pwszCheckPoints != L'\0' );


                // Move past the NULL
                ++pwszCheckPoints;

            } // while: There still are checkpoints to be displayed.

        } // else: There is at least one checkpoint to be displayed.

    } // if: ( ERROR_SUCCESS == sc )


Cleanup:

    delete [] pwszOutBuffer;

    if ( hCurrentResource != NULL )
    {
        CloseClusterResource( hCurrentResource );
    }

    return sc;

} //*** CResourceCmd::GetChkPointsForResource()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::AddCryptoCheckPoints
//
//  Routine Description:
//      Add crypto key checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were added successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::AddCryptoCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD sc = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    size_t nNumberOfCheckPoints = valueList.size();


    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        se.LoadMessage( IDS_NO_RESOURCE_NAME );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
        return sc;

    sc = OpenModule();
    if( sc != ERROR_SUCCESS )
    {
        CloseCluster();
        return sc;
    }

    for ( size_t idx = 0; idx < nNumberOfCheckPoints; ++idx )
    {
        const CString & strCurrentCheckPoint = valueList[idx];
        LPCWSTR lpcszIcchBuffer = strCurrentCheckPoint;

        PrintMessage(
            MSG_RESCMD_ADDING_CRYPTO_CHECKPOINT,
            (LPCWSTR) m_strModuleName,
            (LPCWSTR) strCurrentCheckPoint
            );

        sc = ClusterResourceControl(
            ( HRESOURCE ) m_hModule,
            NULL,
            CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
            (LPVOID) ( (LPCWSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( *lpcszIcchBuffer ),
            NULL,
            0,
            NULL
            );

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return sc;

} //*** AddCryptoCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::RemoveCryptoCheckPoints
//
//  Routine Description:
//      Remove crypto key checkpoints for the resource
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               if all checkpoints were removed successfully.
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::RemoveCryptoCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD sc = ERROR_SUCCESS;

    const vector<CString> & valueList = thisOption.GetValues();
    size_t nNumberOfCheckPoints = valueList.size();

    // This option takes one or more value.
    if ( nNumberOfCheckPoints < 1 )
    {
        se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        se.LoadMessage( IDS_NO_RESOURCE_NAME );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
        return sc;

    sc = OpenModule();
    if( sc != ERROR_SUCCESS )
    {
        CloseCluster();
        return sc;
    }

    for ( size_t idx = 0; idx < nNumberOfCheckPoints; ++idx )
    {
        const CString & strCurrentCheckPoint = valueList[idx];

        PrintMessage(
            MSG_RESCMD_REMOVING_CRYPTO_CHECKPOINT,
            (LPCWSTR) m_strModuleName,
            (LPCWSTR) strCurrentCheckPoint
            );

        sc = ClusterResourceControl(
            ( HRESOURCE ) m_hModule,
            NULL,
            CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT,
            (LPVOID) ( (LPCWSTR) strCurrentCheckPoint ),
            ( strCurrentCheckPoint.GetLength() + 1 ) * sizeof( WCHAR ),
            NULL,
            0,
            NULL
            );

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }
    }

    CloseModule();
    CloseCluster();

    return sc;

} //*** CResourceCmd::RemoveCryptoCheckPoints(()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetCryptoCheckPoints
//
//  Routine Description:
//      Gets a list of crypto key checkpoints for one or more resources
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetCryptoCheckPoints( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD sc = ERROR_SUCCESS;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
        return sc;

    // If no resource name is specified list the checkpoints of all resources.
    if ( m_strModuleName.IsEmpty() != FALSE )
    {
        HCLUSENUM hResourceEnum;

        hResourceEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESOURCE  );
        if ( NULL == hResourceEnum )
        {
            sc = GetLastError();
        }
        else
        {
            CString strCurResName;
            LPWSTR pszNodeNameBuffer;

            // Emperically allocate space for MAX_PATH characters.
            DWORD nResNameBufferSize = MAX_PATH;
            pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );

            PrintMessage( MSG_RESCMD_LISTING_ALL_CRYPTO_CHECKPOINTS );
            PrintMessage( MSG_PROPERTY_HEADER_CRYPTO_CHECKPOINT );

            for ( DWORD dwIndex = 0; ERROR_SUCCESS == sc;  )
            {
                DWORD dwObjectType;
                DWORD nInOutBufferSize = nResNameBufferSize;

                sc = ClusterEnum( hResourceEnum, dwIndex, &dwObjectType,
                    pszNodeNameBuffer, &nInOutBufferSize );

                // We have enumerated all resources.
                if ( ERROR_NO_MORE_ITEMS == sc )
                {
                    sc = ERROR_SUCCESS;
                    break;
                }

                if ( ERROR_MORE_DATA == sc )
                {
                    sc = ERROR_SUCCESS;
                    strCurResName.ReleaseBuffer();

                    nResNameBufferSize = nInOutBufferSize + 1;
                    pszNodeNameBuffer = strCurResName.GetBuffer( nResNameBufferSize );
                }
                else
                {
                    ++dwIndex;

                    if ( ( ERROR_SUCCESS == sc ) &&
                         ( CLUSTER_ENUM_RESOURCE == dwObjectType ) )
                    {
                        sc =  GetCryptoChkPointsForResource( pszNodeNameBuffer );

                    } // if: we successfully got the name of a resource.

                } // else: We got all the data that ClusterEnum wanted to return.

            } // While there are more resources to be enumerated.

            strCurResName.ReleaseBuffer();

            ClusterCloseEnum( hResourceEnum );

        } // else: hResourceEnum is not NULL.

    } // if: m_strModuleName is empty.
    else
    {
        PrintMessage( MSG_RESCMD_LISTING_CRYPTO_CHECKPOINTS, (LPCWSTR) m_strModuleName );
        PrintMessage( MSG_PROPERTY_HEADER_CRYPTO_CHECKPOINT );

        sc = GetCryptoChkPointsForResource( m_strModuleName );

    } // else: m_strModuleName is not empty.

    CloseCluster();

    return sc;

} //*** CResourceCmd::GetCryptoCheckPoints()


////////////////////////////////////////////////////////////////
//+++
//
//  CResourceCmd::GetCryptoChkPointsForResource
//
//  Routine Description:
//      Gets a list of crypto key checkpoints for one resource
//
//  Arguments:
//      strResourceName [IN]        The name of the resource whose checkpoints
//                                  are to be listed.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//  Remarks:
//      m_hCluster should contain a valid handle to an open cluster before this
//      function is called.
//--
////////////////////////////////////////////////////////////////
DWORD CResourceCmd::GetCryptoChkPointsForResource( const CString & strResourceName )
{
    DWORD       sc = ERROR_SUCCESS;
    HRESOURCE   hCurrentResource = NULL;
    LPWSTR      pwszOutBuffer = NULL;
    DWORD       cchBufferSize = MAX_PATH;
    DWORD       cchRequiredSize = 0;
    LPWSTR      pwszCheckPoints = NULL;

    hCurrentResource = OpenClusterResource( m_hCluster, strResourceName );
    if ( hCurrentResource == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    for ( ;; )
    {
        pwszOutBuffer = new WCHAR[ cchBufferSize ];
        if ( pwszOutBuffer == NULL )
        {
            sc = GetLastError();
            break;
        }

        sc = ClusterResourceControl(
            hCurrentResource,
            NULL,
            CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS,
            NULL,
            0,
            (LPVOID) pwszOutBuffer,
            cchBufferSize,
            &cchRequiredSize
            );

        if ( sc == ERROR_MORE_DATA )
        {
            cchBufferSize = cchRequiredSize;
            delete [] pwszOutBuffer;
            pwszOutBuffer = NULL;
        }
        else
        {
            break;
        }

    } // for: ever

    // We have retrieved the checkpoints successfully.
    if ( sc == ERROR_SUCCESS )
    {
        pwszCheckPoints = pwszOutBuffer;

        // There are no checkpoints for this resource.
        if ( 0 == cchRequiredSize )
        {
            PrintMessage( MSG_RESCMD_NO_CRYPTO_CHECKPOINTS_PRESENT, (LPCWSTR) strResourceName );
        }
        else
        {
            while ( *pwszCheckPoints != L'\0' )
            {
                PrintMessage( MSG_CRYPTO_CHECKPOINT_STATUS, (LPCWSTR) strResourceName, pwszCheckPoints );

                // Move to next checkpoint.
                do
                {
                    ++pwszCheckPoints;
                } while ( *pwszCheckPoints != L'\0' );


                // Move past the L'\0'
                ++pwszCheckPoints;

            } // while: There still are checkpoints to be displayed.

        } // else: There is at least one checkpoint to be displayed.

    } // if: ( ERROR_SUCCESS == sc )

Cleanup:

    delete [] pwszOutBuffer;

    if ( hCurrentResource != NULL )
    {
        CloseClusterResource( hCurrentResource );
    }

    return sc;

} //*** CResourceCmd::GetCryptoChkPointsForResource()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\resgcmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996 - 2002 Microsoft Corporation
//
//  Module Name:
//      resgcmd.h
//
//  Abstract:
//      Implements commands which may be performed on groups.
//
//  Author:
//      Charles Stacy Harris III (stacyh)     20-March-1997
//      Michael Burton (t-mburt)              04-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "cluswrap.h"
#include "resgcmd.h"

#include "cmdline.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::CResGroupCmd
//
//  Routine Description:
//      Constructor
//      Initializes all the DWORD params used by CGenericModuleCmd,
//      CRenamableModuleCmd, and CResourceUmbrellaCmd to
//      provide generic functionality.
//
//  Arguments:
//      IN  const CString & strClusterName
//          Name of the cluster being administered
//
//      IN  CCommandLine & cmdLine              
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////

CResGroupCmd::CResGroupCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine ), CRenamableModuleCmd( cmdLine ),
    CResourceUmbrellaCmd( cmdLine )
{
    m_strClusterName = strClusterName;
    m_strModuleName.IsEmpty();

    m_hCluster = NULL;
    m_hModule = NULL;

    m_dwMsgStatusList          = MSG_GROUP_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_GROUP_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_GROUP_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_GROUP_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_GROUP_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_GROUP_ALL;
    m_dwCtlGetPrivProperties   = CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_GROUP_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_GROUP;
    m_pfnOpenClusterModule     = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterGroup;
    m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterGroup;
    m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterGroupControl;
    m_pfnClusterOpenEnum       = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterGroupOpenEnum;
    m_pfnClusterCloseEnum      = (DWORD(*)(HCLUSENUM)) ClusterGroupCloseEnum;
    m_pfnWrapClusterEnum         = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterGroupEnum;

    // Renamable Properties
    m_dwMsgModuleRenameCmd    = MSG_GROUPCMD_RENAME;
    m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) SetClusterGroupName;

    // Resource Umbrella Properties
    m_dwMsgModuleStatusListForNode  = MSG_GROUP_STATUS_LIST_FOR_NODE;
    m_dwClstrModuleEnumNodes        = CLUSTER_GROUP_ENUM_NODES;
    m_dwMsgModuleCmdListOwnersList  = MSG_GROUPCMD_LISTOWNERS_LIST;
    m_dwMsgModuleCmdListOwnersHeader= MSG_GROUPCMD_LISTOWNERS_HEADER;
    m_dwMsgModuleCmdListOwnersDetail= MSG_GROUPCMD_LISTOWNERS_DETAIL;
    m_dwMsgModuleCmdDelete          = MSG_GROUPCMD_DELETE;
    m_pfnDeleteClusterModule        = (DWORD(*)(HCLUSMODULE)) DeleteClusterGroup;

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent classes (first CRenamableModuleCmd, then CRsourceUmbrellaCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Execute()
{
    m_theCommandLine.ParseStageTwo();

    DWORD dwReturnValue = ERROR_SUCCESS;

    const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

    vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
    vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

    CSyntaxException se( SeeHelpStringID() ); 

    if ( optionList.empty() )
    {
        return Status( NULL );
    }

    while ( ( curOption != lastOption ) && ( dwReturnValue == ERROR_SUCCESS ) )
    {
        switch ( curOption->GetType() )
        {
            case optHelp:
            {
                // If help is one of the options, process no more options.
                return PrintHelp();
            }

            case optDefault:
            {
                const vector<CCmdLineParameter> & paramList = curOption->GetParameters();

                //  Check number of parameters.
                if ( paramList.size() == 0 )
                {
                    se.LoadMessage( IDS_MISSING_PARAMETERS );
                    throw se;
                }
                else if ( paramList.size() > 1 )
                {
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_NO_NAME );
                    throw se;
                }

                const CCmdLineParameter & param = paramList[0];

                // If we are here, then it is either because /node:nodeName
                // has been specified or because a group name has been given.
                // Note that the /node:nodeName switch is not treated as an option.
                // It is really a parameter to the implicit /status command.

                if ( param.GetType() == paramNodeName )
                {
                    const vector<CString> & valueList = param.GetValues();

                    // This parameter takes exactly one value.
                    if ( valueList.size() != 1 )
                    {
                        se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, param.GetName() );
                        throw se;
                    }

                    m_strModuleName.Empty();
                    dwReturnValue = Status( valueList[0], TRUE /* bNodeStatus */ );

                } // if: A node name has been specified
                else
                {
                    if ( param.GetType() != paramUnknown )
                    {
                        se.LoadMessage( MSG_INVALID_PARAMETER, param.GetName() );
                        throw se;
                    }

                    // This parameter takes no values.
                    if ( param.GetValues().size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
                        throw se;
                    }

                    m_strModuleName = param.GetName();

                    // No more options are provided, just show status.
                    // For example: cluster myCluster node myNode
                    if ( ( curOption + 1 ) == lastOption )
                    {
                        dwReturnValue = Status( m_strModuleName, FALSE /* bNodeStatus */ );
                    }

                } // else: No node name has been specified.

                break;

            } // case optDefault

            case optStatus:
            {
                // This option takes no values.
                if ( curOption->GetValues().size() != 0 )
                {
                    se.LoadMessage( MSG_OPTION_NO_VALUES, curOption->GetName() );
                    throw se;
                }

                // This option takes no parameters.
                if ( curOption->GetParameters().size() != 0 )
                {
                    se.LoadMessage( MSG_OPTION_NO_PARAMETERS, curOption->GetName() );
                    throw se;
                }

                dwReturnValue = Status( m_strModuleName,  FALSE /* bNodeStatus */ );
                break;
            }

            case optSetOwners:
            {
                dwReturnValue = SetOwners( *curOption );
                break;
            }

            case optOnline:
            {
                dwReturnValue = Online( *curOption );
                break;
            }

            default:
            {
                dwReturnValue = CRenamableModuleCmd::Execute( *curOption, DONT_PASS_HIGHER );

                if ( dwReturnValue == ERROR_NOT_HANDLED )
                    dwReturnValue = CResourceUmbrellaCmd::Execute( *curOption );
            }

        } // switch: based on the type of option

        PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
        ++curOption;
    } // for each option in the list

    return dwReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Resource Groups
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::PrintHelp()
{
    return PrintMessage( MSG_HELP_GROUP );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::SeeHelpStringID
//
//  Routine Description:
//      Provides the message ID of the string that shows what command line to
//      use to get help for this kind of command.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The command-specific message ID.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::SeeHelpStringID() const
{
    return MSG_SEE_GROUP_HELP;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszGroupName               Name of the module
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintStatus2
//
//--
/////////////////////////////////////////////////////////////////////////////
inline DWORD CResGroupCmd::PrintStatus( LPCWSTR lpszGroupName )
{
    return PrintStatus2(lpszGroupName, NULL);
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceCmd::PrintStatus2
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszGroupName               Name of the module
//      lpszNodeName                Name of the node
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::PrintStatus2( LPCWSTR lpszGroupName, LPCWSTR lpszNodeName )
{
    DWORD _sc = ERROR_SUCCESS;

    CLUSTER_GROUP_STATE nState;
    LPWSTR lpszGroupNodeName = NULL;

    HGROUP hModule = OpenClusterGroup( m_hCluster, lpszGroupName );
    if (!hModule)
        return GetLastError();

    nState = WrapGetClusterGroupState( hModule, &lpszGroupNodeName );

    if( nState == ClusterGroupStateUnknown )
        return GetLastError();

    // if the node names don't match just return.
    if( lpszNodeName && *lpszNodeName )  // non-null and non-empty
        if( lstrcmpi( lpszGroupNodeName, lpszNodeName ) != 0 )
        {
            LocalFree( lpszGroupNodeName );
            return ERROR_SUCCESS;
        }


    LPWSTR lpszStatus = 0;

    switch( nState )
    {
        case ClusterGroupOnline:
            LoadMessage( MSG_STATUS_ONLINE, &lpszStatus );
            break;

        case ClusterGroupOffline:
            LoadMessage( MSG_STATUS_OFFLINE, &lpszStatus );
            break;

        case ClusterGroupFailed:
            LoadMessage( MSG_STATUS_FAILED, &lpszStatus );
            break;

        case ClusterGroupPartialOnline:
            LoadMessage( MSG_STATUS_PARTIALONLINE, &lpszStatus );
            break;

        case ClusterGroupPending:
            LoadMessage( MSG_STATUS_PENDING, &lpszStatus );
            break;

        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
    }

    _sc = PrintMessage( MSG_GROUP_STATUS, lpszGroupName, lpszGroupNodeName, lpszStatus );

    // Since Load/FormatMessage uses LocalAlloc...
    if( lpszStatus )
        LocalFree( lpszStatus );

    if( lpszGroupNodeName )
        LocalFree( lpszGroupNodeName );

    if (hModule)
        CloseClusterGroup(hModule);

    return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::SetOwners
//
//  Routine Description:
//      Set the owner of a resource to the specified nodes
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::SetOwners( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() ); 

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    const vector<CString> & valueList = thisOption.GetValues();

    // This option needs at least one value.
    if ( valueList.size() < 1 )
    {
        se.LoadMessage( MSG_OPTION_AT_LEAST_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    DWORD _sc = OpenCluster();
    if( _sc != ERROR_SUCCESS )
        return _sc;

    _sc = OpenModule();
    if( _sc != ERROR_SUCCESS )
        return _sc;

    UINT nNodeCount = (UINT)valueList.size();

    HNODE * phNodes = new HNODE[ nNodeCount ];
    if( !phNodes )
        return ERROR_OUTOFMEMORY;

    ZeroMemory( phNodes, nNodeCount * sizeof (HNODE) );


    // Open all the nodes.
    for( UINT i = 0; i < nNodeCount && _sc == ERROR_SUCCESS; i++ )
    {
        phNodes[ i ] = OpenClusterNode( m_hCluster, valueList[i] );
        if( !phNodes[ i ] )
            _sc = GetLastError();
    }

    if( _sc != ERROR_SUCCESS ) 
    {
        delete [] phNodes;
        return _sc;
    }

    // Do the set.
    _sc = SetClusterGroupNodeList( (HGROUP) m_hModule, nNodeCount, phNodes );


    // Close all the nodes.
    for( i = 0; i < nNodeCount; i++ )
        if( phNodes[ i ] )
            CloseClusterNode( phNodes[ i ] );

    delete[] phNodes;

    return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::Create
//
//  Routine Description:
//      Create a resource group.  Does not allow any additional
//      command line parameters (unlike CResourceCmd)
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_hModule                   Resource Group Handle
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Create( const CCmdLineOption & thisOption ) 
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() ); 

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    DWORD _sc = OpenCluster();
    if( _sc != ERROR_SUCCESS )
        return _sc;


    PrintMessage( MSG_GROUPCMD_CREATE, (LPCWSTR) m_strModuleName );

    m_hModule = CreateClusterGroup( m_hCluster, m_strModuleName );

    if( m_hModule == 0 )
    {
        _sc = GetLastError();
        return _sc;
    }

    PrintMessage( MSG_GROUP_STATUS_HEADER );
    PrintStatus( m_strModuleName );

    return _sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::Move
//
//  Routine Description:
//      Move the resource group to a new node
//      with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Move( const CCmdLineOption & thisOption ) 
    throw( CSyntaxException )
{
    DWORD dwWait = INFINITE;            // in seconds
    DWORD _sc;
    CLUSTER_GROUP_STATE oldCgs = ClusterGroupStateUnknown;
    LPWSTR pwszOldNode = NULL;      // Old Node
    HNODE hDestNode = NULL;
    CSyntaxException se( SeeHelpStringID() ); 

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                size_t nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    const vector<CString> & valueList = thisOption.GetValues();
    CString strNodeName;

    // This option takes one values.
    if ( valueList.size() > 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }
    else
    {
        if ( valueList.size() == 0 )
            strNodeName.Empty();
        else
            strNodeName = valueList[0];
    }

    _sc = OpenCluster();
    if( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    _sc = OpenModule();
    if( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    // Check to see if there is a value for the destination node and open it
    if( strNodeName.IsEmpty() == FALSE )
    {
        hDestNode = OpenClusterNode( m_hCluster, strNodeName );

        if( hDestNode == NULL )
        {
            _sc = GetLastError();
            goto Cleanup;
        } // if:
    } // if:

    PrintMessage( MSG_GROUPCMD_MOVE, (LPCWSTR) m_strModuleName );
    oldCgs = WrapGetClusterGroupState( (HGROUP) m_hModule, &pwszOldNode );

    if ( oldCgs == ClusterGroupStateUnknown )
    {
        // Some error occurred in WrapGetClusterGroupState.
        // Get this error. Assumes that the error code been preserved by
        // WrapGetClusterGroupState.
        _sc = GetLastError();
        goto Cleanup;
    } // if:

    // If we're moving to the same node, then don't bother.
    if( strNodeName.CompareNoCase( pwszOldNode ) == 0 ) 
    {
        PrintMessage( MSG_GROUP_STATUS_HEADER );
        PrintStatus( m_strModuleName );

        _sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if:

    _sc = ScWrapMoveClusterGroup( m_hCluster, (HGROUP) m_hModule, hDestNode, dwWait );
    if ( _sc == ERROR_IO_PENDING )
    {
        _sc = ERROR_SUCCESS;
    } // if:

    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    PrintMessage( MSG_GROUP_STATUS_HEADER );
    PrintStatus( m_strModuleName );

Cleanup:

    // LocalFree on NULL is ok.
    LocalFree(pwszOldNode);

    if( hDestNode != NULL )
    {
        CloseClusterNode( hDestNode );
    }

    return _sc;

} // CResGroupCmd::Move


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::Online
//
//  Routine Description:
//      Bring a resource group online with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Online( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwWait = INFINITE;            // in seconds
    CSyntaxException se( SeeHelpStringID() ); 

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                size_t nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    const vector<CString> & valueList = thisOption.GetValues();
    CString strNodeName;

    if ( valueList.size() > 1 )
    {
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }
    else
    {
        if ( valueList.size() == 0 )
            strNodeName.Empty();
        else
            strNodeName = valueList[0];
    }

    // Execute command.
    DWORD _sc = OpenCluster();
    if( _sc != ERROR_SUCCESS )
        return _sc;

    _sc = OpenModule();
    if( _sc != ERROR_SUCCESS )
        return _sc;

    HNODE hDestNode = 0;
    // Check to see if there is a value for the destination node.
    if( strNodeName.IsEmpty() == FALSE )
    {
        hDestNode = OpenClusterNode( m_hCluster, strNodeName );

        if( !hDestNode )
            return GetLastError();
    }

    PrintMessage( MSG_GROUPCMD_ONLINE, (LPCWSTR) m_strModuleName );
    _sc = ScWrapOnlineClusterGroup( m_hCluster, (HGROUP) m_hModule, hDestNode, dwWait );

    if ( _sc == ERROR_IO_PENDING )
    {
        _sc = ERROR_SUCCESS;
    }

    if ( _sc == ERROR_SUCCESS )
    {
        PrintMessage( MSG_GROUP_STATUS_HEADER );
        PrintStatus( m_strModuleName );
    }

    if( hDestNode )
        CloseClusterNode( hDestNode );

    return _sc;

} // CResGroupCmd::Online


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResGroupCmd::Offline
//
//  Routine Description:
//      Bring a resource group offline with optional response timeout value.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of resource
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResGroupCmd::Offline( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() ); 

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // Finish command line parsing
    DWORD dwWait = INFINITE;            // in seconds

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bWaitFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramWait:
            {
                if ( bWaitFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                size_t nValueCount = valueList.size();

                // This parameter must have exactly one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount == 0 )
                        dwWait = INFINITE;      // in seconds
                    else
                        dwWait = _wtoi( valueList[0] );
                }

                bWaitFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++curParam;
    }

    DWORD _sc = OpenCluster();
    if( _sc != ERROR_SUCCESS )
        return _sc;

    _sc = OpenModule();
    if( _sc != ERROR_SUCCESS )
        return _sc;

    PrintMessage( MSG_GROUPCMD_OFFLINE, (LPCWSTR) m_strModuleName );

    _sc = ScWrapOfflineClusterGroup( m_hCluster, (HGROUP) m_hModule, dwWait );

    if ( _sc == ERROR_IO_PENDING )
    {
        _sc = ERROR_SUCCESS;
    }

    if ( _sc == ERROR_SUCCESS )
    {
        PrintMessage( MSG_GROUP_STATUS_HEADER );
        PrintStatus( m_strModuleName );
    }

    return _sc;

} // CResGroupCmd::Offline
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\restcmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      restcmd.cpp
//
//  Description:
//      Resource Type Commands.
//      Implements commands which may be performed on resource types
//
//  Author:
//      Charles Stacy Harris III (stacyh)     20-March-1997
//      Michael Burton (t-mburt)              04-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "clusudef.h"
#include <cluswrap.h>
#include <ResTypeUtils.h>
#include "restcmd.h"

#include "cmdline.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::CResTypeCmd
//
//  Routine Description:
//      Constructor
//      Initializes all the DWORD params used by CGenericModuleCmd to
//      provide generic functionality.
//
//  Arguments:
//      IN  LPCWSTR lpszClusterName
//          Cluster name. If NULL, opens default cluster.
//
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypeCmd::CResTypeCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine )
{
    m_hCluster = 0;
    m_strClusterName = strClusterName;
    m_strDisplayName.Empty();

    m_dwMsgStatusList          = MSG_RESTYPE_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_RESTYPE_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_RESTYPE_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_RESTYPE_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_RESTYPE_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_RESTYPE_ALL;
    m_dwCtlGetPrivProperties   = CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_RESTYPE;
    m_pfnOpenClusterModule     = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) NULL;
    m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  NULL;
    m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterResourceTypeControl;

} //*** CResTypeCmd::CResTypeCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::~CResTypeCmd
//
//  Routine Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypeCmd::~CResTypeCmd( void )
{
    CloseCluster();

} //*** CResTypeCmd::~CResTypeCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::OpenModule
//
//  Routine Description:
//      This function does not really open a resource type since resource types
//      don't have handles. It actaully just converts the "display name" of a resource
//      to a type name.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_strModuleName             The name of the module
//      m_hModule                   The handle to the module
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      ERROR_INVALID_DATA          if no display name was specified
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::OpenModule( void )
{
    DWORD _sc = ERROR_SUCCESS;

    // The command line uses the display name of the resource
    if ( m_strDisplayName.IsEmpty() == FALSE )
    {
        LPWSTR _pszTypeName = NULL;

        _sc = ScResDisplayNameToTypeName( m_hCluster, m_strDisplayName, &_pszTypeName );

        if ( _sc == ERROR_SUCCESS )
        {
            m_strModuleName = _pszTypeName;
            LocalFree( _pszTypeName );
        } // if: name converted successfully

    } // if: display name specified
    else
    {
        _sc = ERROR_INVALID_DATA;
    } // else: no display name specified

    return _sc;

} //*** CResTypeCmd::OpenModule()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent classes (first CRenamableModuleCmd, then CRsourceUmbrellaCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::Execute( void )
{
    m_theCommandLine.ParseStageTwo();

    const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

    vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
    vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

    CSyntaxException se( SeeHelpStringID() );

    // No options specified. Execute the default command.
    if ( optionList.empty() )
        return ListResTypes( NULL );

    DWORD dwReturnValue = ERROR_SUCCESS;

        // Process one option after another.
    while ( ( curOption != lastOption ) && ( dwReturnValue == ERROR_SUCCESS ) )
    {
        // Look up the command
        switch( curOption->GetType() )
        {
            case optHelp:
            {
                // If help is one of the options, process no more options.
                dwReturnValue = PrintHelp();
                break;
            }

            case optDefault:
            {
                const vector<CCmdLineParameter> & paramList = curOption->GetParameters();

                //  Check number of parameters.
                if ( paramList.size() == 0 )
                {
                    se.LoadMessage( IDS_MISSING_PARAMETERS );
                    throw se;
                }
                else if ( paramList.size() > 1 )
                {
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_NO_NAME );
                    throw se;
                }
                else // just one parameter present
                {
                    const CCmdLineParameter & param = paramList[0];

                    //  Check parameter type.
                    if ( param.GetType() != paramUnknown )
                    {
                        se.LoadMessage( MSG_INVALID_PARAMETER, param.GetName() );
                        throw se;
                    }

                        // This parameter takes no values.
                    if ( param.GetValues().size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
                        throw se;
                    }

                    m_strDisplayName = param.GetName();

                    // No more options are provided, just show status.
                    // For example: cluster myCluster restype myResourceType
                    if ( ( curOption + 1 ) == lastOption )
                    {
                        dwReturnValue = ListResTypes( NULL );
                    }

                } // else: this option has the right number of parameters

                break;

            } // case optDefault

            case optList:
            {
                dwReturnValue = ListResTypes( curOption );
                break;
            }

            case optCreate:
            {
                dwReturnValue = Create( *curOption );
                break;
            }

            case optDelete:
            {
                dwReturnValue = Delete( *curOption );
                break;
            }

            case optListOwners:
            {
                dwReturnValue = ShowPossibleOwners( *curOption );
                break;
            }

            // ResType does not support the /status option. So, don't pass it
            // on to the base class (which tries to handle /status).
            case optStatus:
            {
                se.LoadMessage( IDS_INVALID_OPTION, curOption->GetName() );
                throw se;
            }

            default:
            {
                dwReturnValue = CGenericModuleCmd::Execute( *curOption );
            }

        } // switch: based on the type of option

        PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
        ++curOption;
    } // for each option in the list

    return dwReturnValue;

} //*** CResTypeCmd::Execute()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Resource Types
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::PrintHelp( void )
{
    return PrintMessage( MSG_HELP_RESTYPE );

} //*** CResTypeCmd::PrintHelp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::SeeHelpStringID
//
//  Routine Description:
//      Provides the message ID of the string that shows what command line to
//      use to get help for this kind of command.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The command-specific message ID.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::SeeHelpStringID() const
{
    return MSG_SEE_RESTYPE_HELP;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::Create
//
//  Routine Description:
//      Create a resource type.  Reads the command line to get
//      additional options
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_hModule                   Resource Type Handle
//      m_strDisplayName            Display name of resource type
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::Create( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    CString strDLLName;
    CString strTypeName;
    DWORD dwLooksAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    DWORD dwIsAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bDLLNameFound = FALSE, bTypeFound = FALSE,
         bIsAliveFound = FALSE, bLooksAliveFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramDLLName:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bDLLNameFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strDLLName = valueList[0];
                bDLLNameFound = TRUE;
                break;

            case paramResType:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bTypeFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strTypeName = valueList[0];
                bTypeFound = TRUE;
                break;

            case paramLooksAlive:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bLooksAliveFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                dwLooksAlivePollInterval = _wtol( valueList[0] );
                bLooksAliveFound = TRUE;
                break;

            case paramIsAlive:
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, curParam->GetName() );
                    throw se;
                }

                if ( bIsAliveFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                dwIsAlivePollInterval = _wtoi( valueList[0] );
                bIsAliveFound = TRUE;
                break;

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }
        }

        ++curParam;
    }


    // Check for missing parameters.
    if ( strDLLName.IsEmpty() )
    {
        se.LoadMessage( MSG_MISSING_DLLNAME );
        throw se;
    }

    if ( strTypeName.IsEmpty() )
        strTypeName = m_strDisplayName;

    // Execute command
    DWORD dwError = OpenCluster();
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = CreateClusterResourceType(
        m_hCluster,
        strTypeName,
        m_strDisplayName,
        strDLLName,
        dwLooksAlivePollInterval,
        dwIsAlivePollInterval );

    if ( dwError == ERROR_SUCCESS )
        PrintMessage( MSG_RESTCMD_CREATE, m_strDisplayName );

    return dwError;

} //*** CResTypeCmd::Create()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::Delete
//
//  Routine Description:
//      Delete a resource type.  Accepts an optional /TYPE parameter
//      to denote that the specified name is a resource type name
//      and not a display name
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_hModule                   Resource Type Handle
//      m_strDisplayName            Display name of resource type
//      m_strModuleName             Name of resource type
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::Delete( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    DWORD dwError = OpenCluster();
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    CString strResTypeName;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();
    BOOL bTypeFound = FALSE;

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramResType:
            {
                // Each of the parameters must have exactly one value.
                if ( valueList.size() != 0 )
                {
                    se.LoadMessage( MSG_PARAM_NO_VALUES, curParam->GetName() );
                    throw se;
                }

                if ( bTypeFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strResTypeName = m_strDisplayName;
                bTypeFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter

        ++curParam;
    }


    if ( strResTypeName.IsEmpty() != FALSE )
    {
        dwError = OpenModule();
        if ( dwError != ERROR_SUCCESS )
            return dwError;
        strResTypeName = m_strModuleName;
    }

    dwError = DeleteClusterResourceType( m_hCluster, strResTypeName );

    if ( dwError == ERROR_SUCCESS )
        return PrintMessage( MSG_RESTCMD_DELETE, strResTypeName );

    return dwError;

} //*** CResTypeCmd:Delete()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::ShowPossibleOwners
//
//  Routine Description:
//      Display the nodes which can own a resource type.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_hModule                   Resource Type Handle
//      m_strDisplayName            Display name of resource type
//      m_strModuleName             Name of resource type
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::ShowPossibleOwners( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD       sc = ERROR_SUCCESS;
    HCLUSENUM   hClusEnum = NULL;
    CString     strResTypeName;
    BOOL        bTypeFound = FALSE;
    DWORD       dwType;
    LPWSTR      pszNameBuffer;
    DWORD       dwNameBufferSize = 256; // some arbitrary starting buffer size
    DWORD       dwRequiredSize = dwNameBufferSize;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();
    vector<CCmdLineParameter>::const_iterator curParam = paramList.begin();
    vector<CCmdLineParameter>::const_iterator last = paramList.end();

    while( curParam != last )
    {
        const vector<CString> & valueList = curParam->GetValues();

        switch( curParam->GetType() )
        {
            case paramResType:
            {
                // This parameter does not take a value.
                if ( valueList.size() != 0 )
                {
                    se.LoadMessage( MSG_PARAM_NO_VALUES, curParam->GetName() );
                    throw se;
                }

                if ( bTypeFound != FALSE )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, curParam->GetName() );
                    throw se;
                }

                strResTypeName = m_strDisplayName;
                bTypeFound = TRUE;
                break;
            }

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, curParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter

        ++curParam;
    } // while: curParam != last

    // The /type switch has not been specified and a display name has been given.
    if ( ( bTypeFound == FALSE ) && ( m_strDisplayName.IsEmpty() == FALSE ) )
    {
        sc = OpenModule();
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
        strResTypeName = m_strModuleName;
    }

    if ( strResTypeName.IsEmpty() != FALSE )
    {
        // No type name is given. Show possible owners of all resource types.

        // If the type name is not specified, no other parameters are allowed.
        if ( thisOption.GetParameters().size() != 0 )
        {
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
            throw se;
        }

        // Open an enumeration of the resource types.
        hClusEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESTYPE );
        if ( hClusEnum == NULL )
        {
            sc = GetLastError();
            goto Cleanup;
        }

        // Allocate a buffer for holding the name of the resource types.
        pszNameBuffer = (LPWSTR) LocalAlloc( LMEM_FIXED, dwNameBufferSize * sizeof( *pszNameBuffer ) );
        if ( pszNameBuffer == NULL )
        {
            ClusterCloseEnum( hClusEnum );
            sc = GetLastError();
            goto Cleanup;
        }

        PrintMessage( MSG_RESTYPE_POSSIBLE_OWNERS_LIST_ALL );
        PrintMessage( MSG_HEADER_RESTYPE_POSSIBLE_OWNERS );

        DWORD dwIndex = 0;
        do
        {
            dwRequiredSize = dwNameBufferSize;
            sc = ClusterEnum( hClusEnum, dwIndex, &dwType,
                                   pszNameBuffer, &dwRequiredSize );

            // Buffer space is insufficient. Allocate some more.
            if ( sc == ERROR_MORE_DATA )
            {
                // Make space for the NULL character.
                ++dwRequiredSize;

                LPWSTR pszNewMemory = (LPWSTR) LocalReAlloc( pszNameBuffer,
                                                             dwRequiredSize * sizeof( *pszNameBuffer ),
                                                             LMEM_FIXED );
                if ( pszNewMemory == NULL )
                {
                    sc = GetLastError();
                    break;
                }

                pszNameBuffer = pszNewMemory;
                dwNameBufferSize = dwRequiredSize;

                sc = ClusterEnum( hClusEnum, dwIndex, &dwType,
                                       pszNameBuffer, &dwRequiredSize );

            } // if: more buffer space is needed
            else
            {
                // We are finished with the enumeration.
                if ( sc == ERROR_NO_MORE_ITEMS )
                {
                    sc = ERROR_SUCCESS;
                    break;
                }

                // Something went wrong. Don't proceed.
                if ( sc != ERROR_SUCCESS )
                {
                    break;
                }

                sc = ResTypePossibleOwners( pszNameBuffer );

            } // else: buffer space was sufficient.

            ++dwIndex;
        }
        while ( sc == ERROR_SUCCESS );

        LocalFree( pszNameBuffer );
        ClusterCloseEnum( hClusEnum );

    } // if: no resource type has been specified.
    else
    {
        // Type name found. Show possible owner owners for this resource type only.

        PrintMessage( MSG_RESTYPE_POSSIBLE_OWNERS_LIST, strResTypeName );
        PrintMessage( MSG_HEADER_RESTYPE_POSSIBLE_OWNERS );
        sc = ResTypePossibleOwners( strResTypeName );

    } // else: resource type name has been specified.

Cleanup:

    return sc;

} //*** CResTypeCmd::ShowPossibleOwners()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::ResTypePossibleOwners
//
//  Routine Description:
//      Display the nodes which can own this particular resource type.
//
//  Arguments:
//      IN  const CString & strResTypeName
//          The possible owners of this resource type are displayed.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::ResTypePossibleOwners( const CString & strResTypeName )
{
    HRESTYPEENUM    hResTypeEnum = NULL;
    DWORD           sc = ERROR_SUCCESS;
    DWORD           dwType;
    LPWSTR          pszNameBuffer = NULL;
    DWORD           dwNameBufferSize = 256; // some arbitrary starting buffer size
    DWORD           dwRequiredSize = dwNameBufferSize;


    hResTypeEnum = ClusterResourceTypeOpenEnum( m_hCluster,
                                                strResTypeName,
                                                CLUSTER_RESOURCE_TYPE_ENUM_NODES );

    // Could not open the resource type enumeration
    if ( hResTypeEnum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    // Allocate a buffer for holding the name of the possible owner node.
    pszNameBuffer = (LPWSTR) LocalAlloc( LMEM_FIXED, dwNameBufferSize * sizeof( *pszNameBuffer ) );
    if ( pszNameBuffer == NULL )
    {
        ClusterResourceTypeCloseEnum( hResTypeEnum );
        sc = GetLastError();
        goto Cleanup;
    }

    DWORD dwIndex = 0;
    for ( ;; )
    {
        dwRequiredSize = dwNameBufferSize;
        sc = ClusterResourceTypeEnum( hResTypeEnum, dwIndex, &dwType,
                                           pszNameBuffer, &dwRequiredSize );

        // Buffer space is insufficient. Allocate some more.
        if ( sc == ERROR_MORE_DATA )
        {
            // Make space for the NULL character.
            ++dwRequiredSize;

            LPWSTR pszNewMemory = (LPWSTR) LocalReAlloc( pszNameBuffer,
                                                         dwRequiredSize * sizeof( *pszNameBuffer ),
                                                         LMEM_FIXED );
            if ( pszNewMemory == NULL )
            {
                sc = GetLastError();
                break;
            }

            pszNameBuffer = pszNewMemory;
            dwNameBufferSize = dwRequiredSize;

            sc = ClusterResourceTypeEnum( hResTypeEnum, dwIndex, &dwType,
                                               pszNameBuffer, &dwRequiredSize );

        } // if: more buffer space is needed
        else
        {
            // We are finished with the enumeration.
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                sc = ERROR_SUCCESS;
                break;
            }

            // Something went wrong. Don't proceed.
            if ( sc != ERROR_SUCCESS )
            {
                break;
            }

            PrintMessage( MSG_RESTYPE_POSSIBLE_OWNERS, strResTypeName, pszNameBuffer );

        } // else: buffer space was sufficient.

        ++dwIndex;
    } // for: ever

Cleanup:

    LocalFree( pszNameBuffer );

    if ( hResTypeEnum != NULL )
    {
        ClusterResourceTypeCloseEnum( hResTypeEnum );
    }

    return sc;

} // CResTypeCmd::ResTypePossibleOwners(

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::DoProperties
//
//  Routine Description:
//      Dispatches the property command to either Get, Set, or All properties
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strDisplayName            Name of module.  If non-NULL, prints
//                                  out properties for the specified module.
//                                  Otherwise, prints props for all modules.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::DoProperties( const CCmdLineOption & thisOption,
                                 PropertyType ePropType )
    throw( CSyntaxException )
{
    DWORD dwError;

    if ( m_strDisplayName.IsEmpty() != FALSE )
        return AllProperties( thisOption, ePropType );

    dwError = OpenCluster();
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

    // If there are no property-value pairs on the command line,
    // then we print the properties otherwise we set them.
    if( paramList.size() == 0 )
    {
        PrintMessage( ePropType==PRIVATE ? MSG_PRIVATE_LISTING : MSG_PROPERTY_LISTING,
            (LPCWSTR) m_strModuleName );
        PrintMessage( m_dwMsgPropertyHeaderAll );
        return GetProperties( thisOption, ePropType, m_strModuleName);
    }
    else
        return SetProperties( thisOption, ePropType );

} //*** CResTypeCmd::DoProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::GetProperties
//
//  Routine Description:
//      Prints out properties for the specified module
//      Needs to take into account the fact that it doesn't actually
//      open a handle to a resource type, so this function overrides the
//      default in CGenericModuleCmd
//
//  Arguments:
//      IN  const vector<CCmdLineParameter> & paramList
//          Contains the list of property-value pairs to be set
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//      IN  LPCWSTR lpszResTypeName
//          Name of the module
//
//  Member variables used / set:
//      m_hModule                   Module handle
//      m_strModuleName             Name of resource type
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::GetProperties( const CCmdLineOption & thisOption,
                                  PropertyType ePropType, LPCWSTR lpszResTypeParam )
{
    assert( m_hCluster != NULL );

    DWORD dwError = ERROR_SUCCESS;
    LPCWSTR lpszResTypeName;

    // If no lpszResTypeName specified, use current resource type,
    if ( ! lpszResTypeParam )
    {
        lpszResTypeName = m_strModuleName;
    }
    else
    {
        lpszResTypeName = lpszResTypeParam;
    }


    // Use the proplist helper class.
    CClusPropList PropList;


    // Get R/O properties
    DWORD dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES
                             : CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES;

    dwError = PropList.ScGetResourceTypeProperties(
        m_hCluster,
        lpszResTypeName,
        dwControlCode
        );

    if ( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = PrintProperties( PropList, thisOption.GetValues(), READONLY, lpszResTypeParam );
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    // Get R/W properties
    dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
                               : CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;

    dwError = PropList.ScGetResourceTypeProperties(
        m_hCluster,
        lpszResTypeName,
        dwControlCode
        );

    if ( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = PrintProperties( PropList, thisOption.GetValues(), READWRITE, lpszResTypeParam );

    return dwError;

} //*** CResTypeCmd::GetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::SetProperties
//
//  Routine Description:
//      Set the properties for the specified module
//      Needs to take into account the fact that it doesn't actually
//      open a handle to a resource type, so this function overrides the
//      default in CGenericModuleCmd
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Member variables used / set:
//      m_hModule                   Module handle
//      m_strModuleName             Name of resource type
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::SetProperties( const CCmdLineOption & thisOption,
                                  PropertyType ePropType )
    throw( CSyntaxException )
{
    assert( m_hCluster != NULL );

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwControlCode;
    DWORD dwBytesReturned = 0;
    CSyntaxException se( SeeHelpStringID() );

    // Use the proplist helper class.
    CClusPropList CurrentProps;
    CClusPropList NewProps;

    LPCWSTR lpszResTypeName = m_strModuleName;

    // First get the existing properties...
    dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
                                       : CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;

    dwError = CurrentProps.ScGetResourceTypeProperties(
        m_hCluster,
        lpszResTypeName,
        dwControlCode
        );

    if ( dwError != ERROR_SUCCESS )
        return dwError;


    // If values have been specified with this option, then it means that we want
    // to set these properties to their default values. So, there has to be
    // exactly one parameter and it has to be /USEDEFAULT.
    if ( thisOption.GetValues().size() != 0 )
    {
        const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

        if ( paramList.size() != 1 )
        {
            se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_WITH_NAME, thisOption.GetName() );
            throw se;
        }

        if ( paramList[0].GetType() != paramUseDefault )
        {

            se.LoadMessage( MSG_INVALID_PARAMETER, paramList[0].GetName() );
            throw se;
        }

        // This parameter does not take any values.
        if ( paramList[0].GetValues().size() != 0 )
        {
            se.LoadMessage( MSG_PARAM_NO_VALUES, paramList[0].GetName() );
            throw se;
        }

        dwError = ConstructPropListWithDefaultValues( CurrentProps, NewProps, thisOption.GetValues() );
        if( dwError != ERROR_SUCCESS )
            return dwError;

    } // if: values have been specified with this option.
    else
    {
        dwError = ConstructPropertyList( CurrentProps, NewProps, thisOption.GetParameters(), FALSE, SeeHelpStringID() );
        if ( dwError != ERROR_SUCCESS )
            return dwError;
    }


    // Call the set function...
    dwControlCode = ePropType==PRIVATE ? CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES
                             : CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;

    dwBytesReturned = 0;
    dwError = ClusterResourceTypeControl(
        m_hCluster,
        lpszResTypeName,
        NULL, // hNode
        dwControlCode,
        NewProps.Plist(),
        (DWORD) NewProps.CbBufferSize(),
        0,
        0,
        &dwBytesReturned );

    return dwError;

} //*** CResTypeCmd::SetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::ListResTypes
//
//  Routine Description:
//      Prints out all the available resource types.  Akin to Status
//      for most other modules
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strDisplayName            Name of module.  If non-NULL, prints
//                                  out info for the specified module.
//                                  Otherwise, prints props for all modules.
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::ListResTypes( const CCmdLineOption * pOption )
    throw( CSyntaxException )
{
    CSyntaxException se( SeeHelpStringID() );
    DWORD           sc      = ERROR_SUCCESS;
    HCLUSENUM       hEnum   = NULL;
    DWORD           dwIndex = 0;
    DWORD           dwType  = 0;
    LPWSTR          pszName = NULL;

    // pOption will be NULL if this function has been called as the
    // default action.
    if ( pOption != NULL )
    {
        // This option takes no values.
        if ( pOption->GetValues().size() != 0 )
        {
            se.LoadMessage( MSG_OPTION_NO_VALUES, pOption->GetName() );
            throw se;
        } // if:

        // This option takes no parameters.
        if ( pOption->GetParameters().size() != 0 )
        {
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, pOption->GetName() );
            throw se;
        } // if:
    } // if:

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    if ( m_strDisplayName.IsEmpty() == FALSE )
    {
        PrintMessage( MSG_RESTYPE_STATUS_LIST, m_strDisplayName );
        PrintMessage( MSG_RESTYPE_STATUS_HEADER );
        sc = PrintResTypeInfo( m_strDisplayName );
        goto Cleanup;
    } // if:

    hEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_RESTYPE );
    if( hEnum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if:

    PrintMessage( MSG_RESTYPE_STATUS_LIST_ALL );
    PrintMessage( MSG_RESTYPE_STATUS_HEADER );

    for ( dwIndex = 0; sc == ERROR_SUCCESS; dwIndex++ )
    {
        sc = WrapClusterEnum( hEnum, dwIndex, &dwType, &pszName );
        if ( sc == ERROR_SUCCESS )
        {
            PrintResTypeInfo( pszName ); // option.svValue == nodename
        } // if:

        // LocalFree on NULL is ok.
        LocalFree( pszName );
    } // for:

    if( sc == ERROR_NO_MORE_ITEMS )
    {
        sc = ERROR_SUCCESS;
    } // if:

    ClusterCloseEnum( hEnum );

Cleanup:

    return sc;

} //*** CResTypeCmd::ListResTypes()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeCmd::PrintResTypeInfo
//
//  Routine Description:
//      Prints out info for the specified resource type
//
//  Arguments:
//      pszResTypeName              Name of the resource type
//
//  Member variables used / set:
//      m_hCluster                  Cluster handle
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResTypeCmd::PrintResTypeInfo( LPCWSTR pszResTypeName )
{
    DWORD   _sc             = ERROR_SUCCESS;
    LPWSTR  _pszDisplayName = NULL;

    _sc = ScResTypeNameToDisplayName( m_hCluster, pszResTypeName, &_pszDisplayName );
    if ( _sc == ERROR_SUCCESS )
    {
        PrintMessage( MSG_RESTYPE_STATUS, _pszDisplayName, pszResTypeName );
    } // if:  resource type name information retrieved successfully
    else
    {
        PrintMessage( MSG_RESTYPE_STATUS_ERROR, pszResTypeName );
    }

    LocalFree( _pszDisplayName );

    return _sc;

} //*** CResTypeCmd::PrintResTypeInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\restcmd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      restcmd.h
//
//  Abstract:
//      Interface for functions which may be performed on resource type object.
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once
#include "modcmd.h"

class CCommandLine;

class CResTypeCmd : public CGenericModuleCmd
{
public:
	CResTypeCmd( const CString & strClusterName, CCommandLine & cmdLine );
	~CResTypeCmd();

	// Parse and execute the command line
	DWORD Execute() throw( CSyntaxException );

protected:
	CString m_strDisplayName;

	DWORD OpenModule();
	virtual DWORD SeeHelpStringID() const;

	// Specifc Commands
	DWORD PrintHelp();

	DWORD Create( const CCmdLineOption & thisOption ) 
		throw( CSyntaxException );

	DWORD Delete( const CCmdLineOption & thisOption ) 
		throw( CSyntaxException );

	DWORD CResTypeCmd::ResTypePossibleOwners( const CString & strResTypeName ) ;

	DWORD ShowPossibleOwners( const CCmdLineOption & thisOption ) 
		throw( CSyntaxException );

	DWORD PrintStatus( LPCWSTR ) {return ERROR_SUCCESS;}
	
	DWORD DoProperties( const CCmdLineOption & thisOption,
						PropertyType ePropType )
		throw( CSyntaxException );

	DWORD GetProperties( const CCmdLineOption & thisOption, PropertyType ePropType, 
						 LPCWSTR lpszResTypeName );

	DWORD SetProperties( const CCmdLineOption & thisOption,
						 PropertyType ePropType )
		throw( CSyntaxException );


	DWORD ListResTypes( const CCmdLineOption * pOption )
		throw( CSyntaxException );

	DWORD PrintResTypeInfo( LPCWSTR lpszResTypeName );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\resumb.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996 - 2002 Microsoft Corporation
//
//  Module Name:
//      resumb.h
//
//  Abstract:
//        Universal resource commands supported by multiple
//        resource modules
//
//  Author:
//      Michael Burton (t-mburt)              25-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "resumb.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::CResourceUmbrellaCmd
//
//	Routine Description:
//		Default Constructor
//		Initializes all the DWORD parameters to UNDEFINED and
//		all the pointers to cluster functions to NULL.
//		*ALL* these variables must be defined in any derived class.
//
//	Arguments:
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		A bunch.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceUmbrellaCmd::CResourceUmbrellaCmd( CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine )
{
	m_dwMsgModuleStatusListForNode	= UNDEFINED;
	m_dwClstrModuleEnumNodes		= UNDEFINED;
	m_dwMsgModuleCmdListOwnersList	= UNDEFINED;
	m_dwMsgModuleCmdDelete			= UNDEFINED;
	m_dwMsgModuleCmdListOwnersHeader= UNDEFINED;
	m_dwMsgModuleCmdListOwnersDetail= UNDEFINED;
	m_pfnDeleteClusterModule		= (DWORD(*)(HCLUSMODULE)) NULL;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::Execute
//
//	Routine Description:
//		Takes a command line option and determines which command to
//		execute.  If no command line option specified, gets the next one
//		automatically.	If the token is not identied as being handle-able
//		in this class, the token is passed up to CGenericModuleCmd::Execute
//		unless DONT_PASS_HIGHER is specified as the second parameter, 
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//		IN	ExecuteOption eEOpt							
//			OPTIONAL enum, either DONT_PASS_HIGHER or
//			PASS_HIGHER_ON_ERROR (default)
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::Execute( const CCmdLineOption & option, 
									 ExecuteOption eEOpt )
	throw( CSyntaxException )
{
	// Look up the command
	switch( option.GetType() )
	{
		case optCreate:
			return Create( option );

		case optDelete:
			return Delete( option );

		case optMove:
			return Move( option );

		case optOffline:
			return Offline( option );

		case optListOwners:
			return ListOwners( option );

		default:
			if ( eEOpt == PASS_HIGHER_ON_ERROR )
				return CGenericModuleCmd::Execute( option );
			else
				return ERROR_NOT_HANDLED;
	}
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::Status
//
//	Routine Description:
//		Prints out the status of the module.  Differs from
//		CGenericModuleCmd::Status in that it accepts additional
//		parameters.
//
//	Arguments:
//		IN	const CString & strName
//			This string contains either the name of a node or of a group,
//			depending on the next argument.
//
//		IN	BOOL bNodeStatus
//			TRUE if we want the status at a particular node.
//			FALSE otherwise.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_strModuleName 			Name of module.  If non-NULL, Status() prints
//									out the status of the specified module.
//									Otherwise, prints status of all modules.
//		m_dwMsgStatusList			Field titles for listing status of module
//		m_dwMsgStatusHeader 		Header for statuses
//		m_dwClusterEnumModule		Command for opening enumeration
//		m_dwMsgStatusListAll		Message for listing status of multiple modules
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::Status( const CString & strName, BOOL bNodeStatus )
{
	DWORD dwError = ERROR_SUCCESS;

	dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	if ( bNodeStatus == FALSE )
	{
		// List one resource
		if( m_strModuleName.IsEmpty() == FALSE )
		{
			assert(m_dwMsgStatusList != UNDEFINED && m_dwMsgStatusHeader != UNDEFINED);
			PrintMessage( m_dwMsgStatusList, (LPCWSTR) m_strModuleName );
			PrintMessage( m_dwMsgStatusHeader );
			return PrintStatus( m_strModuleName );
		}

	} // if: we don't want the status only at a particular node.
	else
	{
		// List all modules.
		HNODE hTargetNode;

		hTargetNode = OpenClusterNode( m_hCluster, strName );

		// Error if the given node does not exist.
		if ( NULL == hTargetNode )
		{
			return GetLastError();
		}
		else
		{
			CloseClusterNode( hTargetNode );
		}

	} // else: we want the status at a particular node.

	HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, m_dwClusterEnumModule );

	if( !hEnum )
		return GetLastError();


	if ( bNodeStatus != FALSE )
		PrintMessage( m_dwMsgModuleStatusListForNode, strName );
	else
		PrintMessage( m_dwMsgStatusListAll );

	PrintMessage( m_dwMsgStatusHeader );


	DWORD dwIndex = 0;
	DWORD dwType = 0;
	LPWSTR lpszName = NULL;

	dwError = ERROR_SUCCESS;

	for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
	{

		dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );
			
		if( dwError == ERROR_SUCCESS )
			PrintStatus2( lpszName, strName );

		if( lpszName )
			LocalFree( lpszName );
	}


	if( dwError == ERROR_NO_MORE_ITEMS )
		dwError = ERROR_SUCCESS;

	ClusterCloseEnum( hEnum );

	return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::Delete
//
//	Routine Description:
//		Delete a resource module.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource type
//		m_dwMsgModuleCmdDelete		Delete module message
//		m_pfnDeleteClusterModule	Function to delete cluster module
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::Delete( const CCmdLineOption & thisOption ) 
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
        CSyntaxException se( SeeHelpStringID() );
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
        CSyntaxException se( SeeHelpStringID() );
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;


	assert(m_dwMsgModuleCmdDelete != UNDEFINED);
	PrintMessage( m_dwMsgModuleCmdDelete, (LPCWSTR) m_strModuleName );

	assert(m_pfnDeleteClusterModule);
	return m_pfnDeleteClusterModule( m_hModule );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CResourceUmbrellaCmd::ListOwners
//
//	Routine Description:
//		List the owners of a module.
//
//	Arguments:
//		IN	const CCmdLineOption & thisOption
//			Contains the type, values and arguments of this option.
//
//	Exceptions:
//		CSyntaxException
//			Thrown for incorrect command line syntax.
//
//	Member variables used / set:
//		m_hCluster					SET (by OpenCluster)
//		m_hModule					SET (by OpenModule)
//		m_strModuleName 			Name of resource type
//		m_pfnClusterOpenEnum		Function to open an enumeration
//		m_dwClstrModuleEnumNodes	Command to enumerate nodes
//		m_dwMsgModuleCmdListOwnersList	List owners for module field header
//		m_dwMsgModuleCmdListOwnersHeader List owners for module header
//		m_pfnWrapClusterEnum		Function to enumeration wrapper
//		m_dwMsgModuleCmdListOwnersDetail List owners detail list
//		m_pfnClusterCloseEnum		Function to close enumeration
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceUmbrellaCmd::ListOwners( const CCmdLineOption & thisOption ) 
	throw( CSyntaxException )
{
	// This option takes no values.
	if ( thisOption.GetValues().size() != 0 )
	{
        CSyntaxException se( SeeHelpStringID() );
		se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
		throw se;
	}

	// This option takes no parameters.
	if ( thisOption.GetParameters().size() != 0 )
	{
        CSyntaxException se( SeeHelpStringID() );
		se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
		throw se;
	}

	DWORD dwError = OpenCluster();
	if( dwError != ERROR_SUCCESS )
		return dwError;

	dwError = OpenModule();
	if( dwError != ERROR_SUCCESS )
		return dwError;


	assert(m_pfnClusterOpenEnum);
	assert(m_dwClstrModuleEnumNodes != UNDEFINED);
	HCLUSENUM hEnum = m_pfnClusterOpenEnum( m_hModule, m_dwClstrModuleEnumNodes );
	if( !hEnum )
		return GetLastError();

	assert (m_strModuleName);
	PrintMessage( m_dwMsgModuleCmdListOwnersList, (LPCWSTR) m_strModuleName);
	PrintMessage( m_dwMsgModuleCmdListOwnersHeader );

	DWORD dwIndex = 0;
	DWORD dwType = 0;
	LPWSTR lpszName = 0;

	dwError = ERROR_SUCCESS;

	assert(m_pfnWrapClusterEnum);
	assert(m_dwMsgModuleCmdListOwnersDetail != UNDEFINED);
	for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
	{
		dwError = m_pfnWrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );
			
		if( dwError == ERROR_SUCCESS )
			PrintMessage( m_dwMsgModuleCmdListOwnersDetail, lpszName );

		if( lpszName )
			LocalFree( lpszName );
	}


	if( dwError == ERROR_NO_MORE_ITEMS )
		dwError = ERROR_SUCCESS;

	assert(m_pfnClusterCloseEnum);
	m_pfnClusterCloseEnum( hEnum );

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\token.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      token.h
//
//  Abstract:
//      This file contains the declaration of the tokens that are valid on the
//      command line of cluster.exe
//
//  Implementation File:
//      token.cpp
//
//  Author:
//      Vijayendra Vasu (vvasu)               28-Oct-1998
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      001. This  has been drastically changed from the previous version.
//           The tokens have now been categorized into three types: objects,
//           options and parameters (enumerated in the file cmdline.h). This
//           functions in this file help categorize tokens into these 
//           categories.
//      April 10, 2002      Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once


/////////////////////////////////////////////////////////////////////////////
//  Include files
/////////////////////////////////////////////////////////////////////////////
#include "cmdline.h"


/////////////////////////////////////////////////////////////////////////////
//  Type definitions
/////////////////////////////////////////////////////////////////////////////
template <class EnumType> struct LookupStruct
{
    LPCWSTR pszName;
    EnumType type;
};


/////////////////////////////////////////////////////////////////////////////
//  External variable declarations
/////////////////////////////////////////////////////////////////////////////

extern const LookupStruct<ObjectType> objectLookupTable[];
extern const LookupStruct<OptionType> optionLookupTable[];
extern const LookupStruct<ParameterType> paramLookupTable[];
extern const LookupStruct<ValueFormat> formatLookupTable[];

extern const size_t objectLookupTableSize;
extern const size_t optionLookupTableSize;
extern const size_t paramLookupTableSize;
extern const size_t formatLookupTableSize;


// Separator character constants.
extern const CString OPTION_SEPARATOR;
extern const CString OPTION_VALUE_SEPARATOR;
extern const CString PARAM_VALUE_SEPARATOR;
extern const CString VALUE_SEPARATOR;

extern const CString SEPERATORS;
extern const CString DELIMITERS;


/////////////////////////////////////////////////////////////////////////////
//  Template function definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  LookupType
//
//  Routine Description:
//      This template function looks up a particular token in a lookup table
//      and returns the type of the token if found.
//
//  Arguments:
//      IN  const CString & strToken
//          The token to be looked up
//
//      IN  struct LookupStruct<EnumType> lookupTable[]
//          The lookup table. This table must have at least one entry and the 
//          first entry must be the default type (the type to be returned if
//          the given token is not found.
//
//      IN  const int nTableSize
//          Size of the lookup table.
//
//  Return Value:
//      The type of the token if it is found or the type specified in the first
//      entry of the lookup table if it is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
template <class EnumType>
EnumType LookupType( const CString & strToken, 
                     const LookupStruct<EnumType> lookupTable[],
                     const size_t nTableSize )
{
    for ( size_t idx = 1; idx < nTableSize; ++idx )
    {
        if ( strToken.CompareNoCase( lookupTable[idx].pszName ) == 0 )
            return lookupTable[idx].type;
    }
    
    // The given token is not found in the lookup table
    // lookupTable[0].type contains the default return value.
    return lookupTable[0].type;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  LookupName
//
//  Routine Description:
//      This template function looks up a particular type in a lookup table
//      and returns the name of the type if found.
//
//  Arguments:
//      IN  EnumType type
//          The type whose name is to be looked up
//
//      IN  struct LookupStruct<EnumType> lookupTable[]
//          The lookup table. This table must have at least one entry and the 
//          first entry must be the default type (the type to be returned if
//          the given token is not found.
//
//      IN  const int nTableSize
//          Size of the lookup table.
//
//  Return Value:
//      The name of the token if it is found or the name specified in the first
//      entry of the lookup table if it is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
template <class EnumType>
LPCWSTR LookupName( EnumType type, 
                    const LookupStruct<EnumType> lookupTable[],
                    const int nTableSize )
{
    for ( int i = 1; i < nTableSize; ++i )
    {
        if ( type == lookupTable[i].type )
            return lookupTable[i].pszName;
    }
    
    // The given type is not found in the lookup table
    // lookupTable[0].pszName contains the default return value.
    return lookupTable[0].pszName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\token.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      token.cpp
//
//  Description:
//      Definition of valid token strings.
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//      David Potter (DavidP)                 11-JUL-2001
//      Vijayendra Vasu (vvasu)               20-OCT-1998
//
//  Revision History:
//      April 10, 2002  Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  Include files
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "token.h"
#include <clusapi.h>

/////////////////////////////////////////////////////////////////////////////
//  Global variables
/////////////////////////////////////////////////////////////////////////////

// Separator and delimiters.

// Seperators are special types of tokens.
const CString OPTION_SEPARATOR( TEXT("/-") );
const CString OPTION_VALUE_SEPARATOR( TEXT(":") );
const CString PARAM_VALUE_SEPARATOR( TEXT("=") );
const CString VALUE_SEPARATOR( TEXT(",") );

const CString SEPERATORS( OPTION_SEPARATOR +
                          OPTION_VALUE_SEPARATOR +
                          PARAM_VALUE_SEPARATOR +
                          VALUE_SEPARATOR );        

// Delimiters mark the end of a token.
// Whitespaces and end of input are also delimiters.
// Note: "-" and "/" are not delimiters. They can occur in a token.
// For example: cluster-1 is a valid token.
const CString DELIMITERS( OPTION_VALUE_SEPARATOR + 
                          PARAM_VALUE_SEPARATOR +
                          VALUE_SEPARATOR );


// Lookup tables and their sizes.

const LookupStruct<ObjectType> objectLookupTable[] =
{
    // Default value
    { TEXT("Invalid Object"),   objInvalid },

    // Node
    { TEXT("Node"),             objNode },

    // Group
    { TEXT("ResourceGroup"),    objGroup },
    { TEXT("ResGroup"),         objGroup },
    { TEXT("Group"),            objGroup },

    // Resource
    { TEXT("Resource"),         objResource },
    { TEXT("Res"),              objResource },

    { TEXT("ResourceType"),     objResourceType },
    { TEXT("ResType"),          objResourceType },
    { TEXT("Type"),             objResourceType },

    // Network
    { TEXT("Network"),          objNetwork },
    { TEXT("Net"),              objNetwork },
    
    // Network Interface
    { TEXT("NetInt"),           objNetInterface },
    { TEXT("NetInterface"),     objNetInterface }
};

const size_t objectLookupTableSize = RTL_NUMBER_OF( objectLookupTable );

const LookupStruct<OptionType> optionLookupTable[] =
{
    { TEXT("Invalid Option"),       optInvalid },

    //   Common options
    { TEXT("?"),                    optHelp },
    { TEXT("Help"),                 optHelp },

    { TEXT("Create"),               optCreate },

    { TEXT("Delete"),               optDelete },
    { TEXT("Del"),                  optDelete },

    { TEXT("Move"),                 optMove },
    { TEXT("MoveTo"),               optMove },

    { TEXT("List"),                 optList },

    { TEXT("ListOwners"),           optListOwners },

    { TEXT("Online"),               optOnline },
    { TEXT("On"),                   optOnline },

    { TEXT("Offline"),              optOffline },
    { TEXT("Off"),                  optOffline },

    { TEXT("Properties"),           optProperties },
    { TEXT("Prop"),                 optProperties },
    { TEXT("Props"),                optProperties },

    { TEXT("PrivProperties"),       optPrivateProperties },
    { TEXT("PrivProp"),             optPrivateProperties },
    { TEXT("PrivProps"),            optPrivateProperties },
    { TEXT("Priv"),                 optPrivateProperties },

    { TEXT("Rename"),               optRename },
    { TEXT("Ren"),                  optRename },

    { TEXT("Status"),               optStatus },
    { TEXT("State"),                optStatus },
    { TEXT("Stat"),                 optStatus },


    // Cluster options
    { TEXT("Quorum"),               optQuorumResource },
    { TEXT("QuorumResource"),       optQuorumResource },

    { TEXT("Version"),              optVersion },
    { TEXT("Ver"),                  optVersion },

    { TEXT("SetFail"),              optSetFailureActions },
    { TEXT("SetFailureActions"),    optSetFailureActions },

    { TEXT("RegExt"),               optRegisterAdminExtensions },
    { TEXT("RegAdminExt"),          optRegisterAdminExtensions },

    { TEXT("UnRegExt"),             optUnregisterAdminExtensions },
    { TEXT("UnRegAdminExt"),        optUnregisterAdminExtensions },

    { TEXT("Add"),                  optAddNodes },
    { TEXT("AddNode"),              optAddNodes },
    { TEXT("AddNodes"),             optAddNodes },

    { TEXT("ChangePassword"),       optChangePassword },
    { TEXT("ChangePass"),           optChangePassword },

    { TEXT("ListNetPriority"),      optListNetPriority },
    { TEXT("ListNetPri"),           optListNetPriority },
    { TEXT("SetNetPriority"),       optSetNetPriority },
    { TEXT("SetNetPri"),            optSetNetPriority },

    // Node options
    { TEXT("Pause"),                optPause },

    { TEXT("Resume"),               optResume },

    { TEXT("Evict"),                optEvict },

    { TEXT("Force"),                optForceCleanup },
    { TEXT("ForceCleanup"),         optForceCleanup },

    { TEXT("Start"),                optStartService },

    { TEXT("Stop"),                 optStopService },


    // Group options
    { TEXT("SetOwners"),            optSetOwners },

    
    // Resource options 
    { TEXT("AddChk"),               optAddCheckPoints },
    { TEXT("AddCheck"),             optAddCheckPoints },
    { TEXT("AddChkPoints"),         optAddCheckPoints },
    { TEXT("AddCheckPoints"),       optAddCheckPoints },

    { TEXT("AddCryptoChk"),         optAddCryptoCheckPoints },
    { TEXT("AddCryptoCheck"),       optAddCryptoCheckPoints },
    { TEXT("AddCryptoChkPoints"),   optAddCryptoCheckPoints },
    { TEXT("AddCryptoCheckPoints"), optAddCryptoCheckPoints },

    { TEXT("AddDep"),               optAddDependency },
    { TEXT("AddDependency"),        optAddDependency },

    { TEXT("AddOwner"),             optAddOwner },

    { TEXT("Fail"),                 optFail },

    { TEXT("Chk"),                  optGetCheckPoints },
    { TEXT("Check"),                optGetCheckPoints },
    { TEXT("ChkPoints"),            optGetCheckPoints },
    { TEXT("CheckPoints"),          optGetCheckPoints },

    { TEXT("CryptoChk"),            optGetCryptoCheckPoints },
    { TEXT("CryptoCheck"),          optGetCryptoCheckPoints },
    { TEXT("CryptoChkPoints"),      optGetCryptoCheckPoints },
    { TEXT("CryptoCheckPoints"),    optGetCryptoCheckPoints },

    { TEXT("ListDep"),              optListDependencies },
    { TEXT("ListDependencies"),     optListDependencies },

    { TEXT("RemoveDep"),            optRemoveDependency },
    { TEXT("RemoveDependency"),     optRemoveDependency },

    { TEXT("RemoveOwner"),          optRemoveOwner },
    { TEXT("RemOwner"),             optRemoveOwner },

    { TEXT("RemoveChk"),            optRemoveCheckPoints },
    { TEXT("RemoveCheck"),          optRemoveCheckPoints },
    { TEXT("RemoveChkPoints"),      optRemoveCheckPoints },
    { TEXT("RemoveCheckPoints"),    optRemoveCheckPoints },


    { TEXT("RemoveCryptoChk"),          optRemoveCryptoCheckPoints },
    { TEXT("RemoveCryptoCheck"),        optRemoveCryptoCheckPoints },
    { TEXT("RemoveCryptoChkPoints"),    optRemoveCryptoCheckPoints },
    { TEXT("RemoveCryptoCheckPoints"),  optRemoveCryptoCheckPoints },


    // Resource type options
    { TEXT("ListOwners"),           optListOwners },


    // Network options
    { TEXT("ListInt"),              optListInterfaces },
    { TEXT("ListInterface"),        optListInterfaces },
    { TEXT("ListInterfaces"),       optListInterfaces }

};

const size_t optionLookupTableSize = RTL_NUMBER_OF( optionLookupTable );

const LookupStruct<ParameterType> paramLookupTable[] =
{
    { TEXT("Unknown parameter"),    paramUnknown },
    { TEXT("C"),                    paramCluster },
    { TEXT("Cluster"),              paramCluster },
    { TEXT("DisplayName"),          paramDisplayName },
    { TEXT("DLL"),                  paramDLLName },
    { TEXT("DLLName"),              paramDLLName },
    { TEXT("Group"),                paramGroupName },
    { TEXT("IsAlive"),              paramIsAlive },
    { TEXT("LooksAlive"),           paramLooksAlive },
    { TEXT("MaxLogSize"),           paramMaxLogSize },
    { TEXT("Net"),                  paramNetworkName },
    { TEXT("Network"),              paramNetworkName },
    { TEXT("Node"),                 paramNodeName },
    { TEXT("Path"),                 paramPath },
    { TEXT("ResourceType"),         paramResType },
    { TEXT("ResType"),              paramResType },
    { TEXT("Type"),                 paramResType },
    { TEXT("Separate"),             paramSeparate },
    { TEXT("UseDefault"),           paramUseDefault },
    { TEXT("Wait"),                 paramWait },
    { TEXT("User"),                 paramUser },
    { TEXT("Password"),             paramPassword },
    { TEXT("Pass"),                 paramPassword },
    { TEXT("IPAddress"),            paramIPAddress },
    { TEXT("IPAddr"),               paramIPAddress },
    { TEXT("Verbose"),              paramVerbose },
    { TEXT("Verb"),                 paramVerbose },
    { TEXT("Unattended"),           paramUnattend },
    { TEXT("Unattend"),             paramUnattend },
    { TEXT("Wiz"),                  paramWizard },
    { TEXT("Wizard"),               paramWizard },
    { TEXT("SkipDC"),               paramSkipDC },  // password change
    { TEXT("Test"),                 paramTest }, // password change
    { TEXT("Quiet"),                paramQuiet }, // password change
    { TEXT("Min"),                  paramMinimal },
    { TEXT("Minimum"),              paramMinimal }
};

const size_t paramLookupTableSize = RTL_NUMBER_OF( paramLookupTable );

const LookupStruct<ValueFormat> formatLookupTable[] =
{
    { TEXT(""),                     vfInvalid },
    { TEXT("BINARY"),               vfBinary },
    { TEXT("DWORD"),                vfDWord },
    { TEXT("STR"),                  vfSZ },
    { TEXT("STRING"),               vfSZ },
    { TEXT("EXPANDSTR"),            vfExpandSZ },
    { TEXT("EXPANDSTRING"),         vfExpandSZ },
    { TEXT("MULTISTR"),             vfMultiSZ },
    { TEXT("MULTISTRING"),          vfMultiSZ },
    { TEXT("SECURITY"),             vfSecurity },
    { TEXT("ULARGE"),               vfULargeInt }
};

const size_t formatLookupTableSize = RTL_NUMBER_OF( formatLookupTable );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\resumb.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      resumb.h
//
//  Abstract:
//      This module defines the interface available for several
//      additional generic functions available to resource modules
//      
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once
#include "modcmd.h"

class CResourceUmbrellaCmd : virtual public CGenericModuleCmd
{
public:
	CResourceUmbrellaCmd( CCommandLine & cmdLine );

protected:
	virtual DWORD Execute( const CCmdLineOption & option, 
						   ExecuteOption eEOpt = PASS_HIGHER_ON_ERROR  )
		throw( CSyntaxException );

	DWORD Status( const CCmdLineOption * pOption ) throw( CSyntaxException )
	{
		return CGenericModuleCmd::Status( pOption );
	}

	DWORD Status( const CString & strName, BOOL bNodeStatus );

	DWORD Delete( const CCmdLineOption & Command ) throw( CSyntaxException );
	DWORD ListOwners( const CCmdLineOption & Command ) throw( CSyntaxException );

	virtual DWORD Create( const CCmdLineOption & Command ) throw( CSyntaxException ) = 0;
	virtual DWORD Offline( const CCmdLineOption & Command ) throw( CSyntaxException ) = 0;
	virtual DWORD Move( const CCmdLineOption & Command ) throw( CSyntaxException ) = 0;

	virtual DWORD PrintStatus2( LPCWSTR lpszModuleName, LPCWSTR lpszNodeName ) = 0;

	DWORD m_dwMsgModuleStatusListForNode;
	DWORD m_dwMsgModuleCmdListOwnersList;
	DWORD m_dwMsgModuleCmdListOwnersDetail;
	DWORD m_dwMsgModuleCmdListOwnersHeader;
	DWORD m_dwClstrModuleEnumNodes;
	DWORD m_dwMsgModuleCmdDelete;
	DWORD (*m_pfnDeleteClusterModule)(HCLUSMODULE);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\admcommonres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AdmCommonRes.h
//
//  Abstract:
//      Definition of resource constants used with the cluster admin
//      common directory.
//
//  Implementation File:
//      AdmCommonRes.rc
//
//  Author:
//      David Potter (davidp)   February 20, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#define __ADMCOMMONRES_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define ADMC_IDS_REQUIRED_FIELD_EMPTY   0xD000
#define ADMC_IDS_PATH_IS_INVALID        0xD001
#define ADMC_IDS_EMPTY_RIGHT_LIST       0xD002
#define ADMC_IDS_CLSIDFROMSTRING_ERROR  0xD003
#define ADMC_IDS_EXT_CREATE_INSTANCE_ERROR 0xD004
#define ADMC_IDS_EXT_ADD_PAGES_ERROR    0xD005
#define ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR 0xD006
#define ADMC_IDS_INSERT_MENU_ERROR      0xD007
#define ADMC_IDS_ADD_PAGE_TO_PROP_SHEET_ERROR 0xD008
#define ADMC_IDS_ADD_FIRST_PAGE_TO_PROP_SHEET_ERROR 0xD009
#define ADMC_IDS_CREATE_EXT_PAGE_ERROR  0xD00A
#define ADMC_IDS_ADD_PAGE_TO_WIZARD_ERROR 0xD00B
#define ADMC_IDS_INIT_EXT_PAGES_ERROR   0xD00C

#define ADMC_IDS_RESCLASS_UNKNOWN       0xD050
#define ADMC_IDS_RESCLASS_STORAGE       0xD051

#define ADMC_ID_MENU_PROPERTIES         0xD100
#define ADMC_ID_MENU_WHATS_THIS         0xD101

#define ADMC_IDC_LCP_NOTE               0xD200
#define ADMC_IDC_LCP_LEFT_LABEL         0xD201
#define ADMC_IDC_LCP_LEFT_LIST          0xD202
#define ADMC_IDC_LCP_ADD                0xD203
#define ADMC_IDC_LCP_REMOVE             0xD204
#define ADMC_IDC_LCP_RIGHT_LABEL        0xD205
#define ADMC_IDC_LCP_RIGHT_LIST         0xD206
#define ADMC_IDC_LCP_MOVE_UP            0xD207
#define ADMC_IDC_LCP_MOVE_DOWN          0xD208
#define ADMC_IDC_LCP_PROPERTIES         0xD209

// Property Sheet control id's (determined with Spy++ by MFC)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025

/////////////////////////////////////////////////////////////////////////////

#endif // __ADMCOMMONRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\util.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2000 Microsoft Corporation
//
//  Module Name:
//      Util.h
//
//  Description:
//      Utility funtions and structures.
//
//  Maintained By:
//      Vij Vasu (VVasu)    26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <aclapi.h>
#include "cmderror.h"
#include "PropList.h"
#include "cluswrap.h"
#include "cmdline.h"

enum PropertyAttrib
{
    READONLY,
    READWRITE
};

HRESULT RtlSetThreadUILanguage( DWORD dwReserved );

DWORD PrintString( LPCWSTR lpszMessage );

size_t FormatSystemError( DWORD dwError, size_t cbError, LPWSTR szError );

DWORD PrintSystemError( DWORD dwError, LPCWSTR pszPad = NULL );

DWORD PrintMessage( DWORD dwMessage, ... );

DWORD LoadMessage( DWORD dwMessage, LPWSTR * ppMessage );

DWORD PrintProperties( CClusPropList &PropList,
                       const vector<CString> & vstrFilterList,
                       PropertyAttrib eReadOnly,
                       LPCWSTR lpszOwnerName = NULL,
                       LPCWSTR lpszNetIntSpecific = NULL);

DWORD ConstructPropListWithDefaultValues(
    CClusPropList &             CurrentProps,
    CClusPropList &             newPropList,
    const vector< CString > &   vstrPropNames
    );

DWORD ConstructPropertyList( CClusPropList &CurrentProps, CClusPropList &NewProps,
                             const vector<CCmdLineParameter> & paramList,
                             BOOL bClusterSecurity = FALSE,
							 DWORD	idExceptionHelp = MSG_SEE_CLUSTER_HELP )
    throw( CSyntaxException );

DWORD
WaitGroupQuiesce(
    IN HCLUSTER hCluster,
    IN HGROUP   hGroup,
    IN LPWSTR   lpszGroupName,
    IN DWORD    dwWaitTime
    );

DWORD MyStrToULongLong( LPCWSTR lpszNum, ULONGLONG * pullValue );
DWORD MyStrToBYTE( LPCWSTR lpszNum, BYTE * pByte );
DWORD MyStrToDWORD( LPCWSTR lpszNum, DWORD * dwVal );
DWORD MyStrToLONG( LPCWSTR lpszNum, LONG * lVal );
BOOL isNegativeNum( LPWSTR lpszNum );
BOOL isValidNum( LPWSTR lpszNum );

HRESULT
HrGetLocalNodeFQDNName(
    BSTR *  pbstrFQDNOut
    );

HRESULT
HrGetLoggedInUserDomain(
    BSTR * pbstrDomainOut
    );

DWORD
ScGetPassword(
      LPWSTR    pwszPasswordOut
    , DWORD     cchPasswordIn
    );

BOOL
MatchCRTLocaleToConsole( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\admnetutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AdmNetUtils.cpp
//
//	Abstract:
//		Declaration of network utility functions.
//
//	Implementation File:
//		AdmNetUtils.cpp
//
//	Author:
//		David Potter (davidp)	February 19, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMNETUTILS_H_
#define __ADMNETUTILS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

BOOL BIsValidIpAddress(IN LPCWSTR pszAddress);
BOOL BIsValidSubnetMask(IN LPCWSTR pszMask);
BOOL BIsValidIpAddressAndSubnetMask(IN LPCWSTR pszAddress, IN LPCWSTR pszMask);
BOOL BIsIpAddressInUse(IN LPCWSTR pszAddress);

/////////////////////////////////////////////////////////////////////////////

#endif // __ADMNETUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\util.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      util.cpp
//
//  Description:
//      Utility functions and structures.
//
//  Maintained By:
//      David Potter (DavidP)               04-MAY-2001
//      Michael Burton (t-mburt)            04-Aug-1997
//      Charles Stacy Harris III (stacyh)   20-March-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include <limits.h>     // ULONG_MAX, LONG_MIN, LONG_MAX
#include <errno.h>      // errno

#include <clusrtl.h>
#include "cluswrap.h"
#include "util.h"
#include "token.h"

#pragma warning( push )
#pragma warning( disable : 4201 )   // nonstandard extension used
#include <dnslib.h>     // DNS_MAX_NAME_BUFFER_LENGTH
#pragma warning( pop )

#include <security.h>   // GetUserNameEx
#include <Wincon.h>     // ReadConsole, etc.
#include <Dsgetdc.h>
#include <Lm.h>

/////////////////////////////////////////////////////////////////////////////
//  Lookup tables
/////////////////////////////////////////////////////////////////////////////

const LookupStruct<CLUSTER_PROPERTY_FORMAT> formatCharLookupTable[] =
{
    { L"",                      CLUSPROP_FORMAT_UNKNOWN },
    { L"B",                     CLUSPROP_FORMAT_BINARY },
    { L"D",                     CLUSPROP_FORMAT_DWORD },
    { L"S",                     CLUSPROP_FORMAT_SZ },
    { L"E",                     CLUSPROP_FORMAT_EXPAND_SZ },
    { L"M",                     CLUSPROP_FORMAT_MULTI_SZ },
    { L"I",                     CLUSPROP_FORMAT_ULARGE_INTEGER },
    { L"L",                     CLUSPROP_FORMAT_LONG },
    { L"X",                     CLUSPROP_FORMAT_EXPANDED_SZ },
    { L"U",                     CLUSPROP_FORMAT_USER }
};

const size_t formatCharLookupTableSize = RTL_NUMBER_OF( formatCharLookupTable );

const LookupStruct<CLUSTER_PROPERTY_FORMAT> cluspropFormatLookupTable[] =
{
    { L"UNKNOWN",               CLUSPROP_FORMAT_UNKNOWN },
    { L"BINARY",                CLUSPROP_FORMAT_BINARY },
    { L"DWORD",                 CLUSPROP_FORMAT_DWORD },
    { L"STRING",                CLUSPROP_FORMAT_SZ },
    { L"EXPANDSTRING",          CLUSPROP_FORMAT_EXPAND_SZ },
    { L"MULTISTRING",           CLUSPROP_FORMAT_MULTI_SZ },
    { L"ULARGE",                CLUSPROP_FORMAT_ULARGE_INTEGER }
};

const size_t cluspropFormatLookupTableSize = RTL_NUMBER_OF( cluspropFormatLookupTable );

const ValueFormat ClusPropToValueFormat[] =
{
    vfInvalid,
    vfBinary,
    vfDWord,
    vfSZ,
    vfExpandSZ,
    vfMultiSZ,
    vfULargeInt,
    vfInvalid,
    vfInvalid
};

const LookupStruct<ACCESS_MODE> accessModeLookupTable[] =
{
    { L"",          NOT_USED_ACCESS },
    { L"GRANT",     GRANT_ACCESS    },
    { L"DENY",      DENY_ACCESS     },
    { L"SET",       SET_ACCESS      },
    { L"REVOKE",    REVOKE_ACCESS   }
};

// Access right specifier characters.
const WCHAR g_FullAccessChar = L'F';
const WCHAR g_ReadAccessChar = L'R';
const WCHAR g_ChangeAccessChar = L'C';

const size_t accessModeLookupTableSize = RTL_NUMBER_OF( accessModeLookupTable );

#define MAX_BUF_SIZE 2048

DWORD
PrintProperty(
    LPCWSTR                 pwszPropName,
    CLUSPROP_BUFFER_HELPER  PropValue,
    PropertyAttrib          eReadOnly,
    LPCWSTR                 lpszOwnerName,
    LPCWSTR                 lpszNetIntSpecific
    );

//
// Local functions.
//

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RtlSetThreadUILanguage
//
//  Routine Description:
//      Sets the thread UI language.
// 
//  Arguments:
//      IN  DWORD dwReserved
//          Reserved.
//
//  Return Value:
//      S_OK on success
//      Other Result on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT RtlSetThreadUILanguage( DWORD dwReserved )
{
    typedef BOOLEAN (WINAPI * PFN_SETTHREADUILANGUAGE)( DWORD dwReserved );
    
    PFN_SETTHREADUILANGUAGE     pfnSetThreadUILanguage = NULL;
    HMODULE                     hKernel32Lib = NULL;
    const CHAR                  cszFunctionName[] = "SetThreadUILanguage";
    LANGID                      langID;
    HRESULT                     hr = S_OK;
    
    hKernel32Lib = LoadLibraryW( L"kernel32.dll" );
    if ( hKernel32Lib != NULL )
    {
        // Library loaded successfully. Now load the address of the function.
        pfnSetThreadUILanguage = (PFN_SETTHREADUILANGUAGE) GetProcAddress( hKernel32Lib, cszFunctionName );

        // We will keep the library loaded in memory only if the function is loaded successfully.
        if ( pfnSetThreadUILanguage == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Cleanup;
        } // if: ( pfnSetThreadUILanguage == NULL )
        else
        {
            // Call the function.
            langID = pfnSetThreadUILanguage( dwReserved );
            pfnSetThreadUILanguage = NULL;
        } // else:
    } // if: ( hKernel32Lib != NULL ) 
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // else: 
    
Cleanup:

    if ( hKernel32Lib != NULL )
    {
        // Unload the library
        FreeLibrary( hKernel32Lib );
        hKernel32Lib = NULL;
    } // if: ( hKernel32Lib != NULL )
    
    return hr;
    
} //*** RtlSetThreadUILanguage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  MyPrintMessage
//
//  Routine Description:
//      Replacement printing routine.
//
//  Arguments:
//      IN  struct _iobuf * lpOutDevice
//          The output stream.
//
//      IN  LPCWSTR lpMessage
//          The message to print.
//
//  Return Value:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
MyPrintMessage(
    struct _iobuf *lpOutDevice,
    LPCWSTR lpMessage
    )

{
    DWORD   sc = ERROR_SUCCESS;
    size_t  cbMBStr;
    PCHAR   pszMultiByteStr = NULL;
    size_t  cchMultiByte;

    cbMBStr = WideCharToMultiByte( CP_OEMCP,
                                    0,
                                    lpMessage,
                                    -1,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
    if ( cbMBStr == 0 ) 
    {
        sc = GetLastError();
        goto Cleanup;
    }

    pszMultiByteStr = new CHAR[ cbMBStr ];
    if ( pszMultiByteStr == NULL ) 
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    cchMultiByte = cbMBStr;
    cbMBStr = WideCharToMultiByte( CP_OEMCP,
                                    0,
                                    lpMessage,
                                    -1,
                                    pszMultiByteStr,
                                    (int)cchMultiByte,
                                    NULL,
                                    NULL );
    if ( cbMBStr == 0 ) 
    {
        sc = GetLastError();
        goto Cleanup;
    }

    //zap! print to stderr or stdout depending on severity...
    fprintf( lpOutDevice, "%s", pszMultiByteStr );

Cleanup:

    delete [] pszMultiByteStr;

    return sc;

} //*** MyPrintMessage()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatSystemError
//
//  Routine Description:
//      Map a system error code into a formatted system error message.
//
//  Arguments:
//      IN  DWORD dwError
//          The system error code.
//
//      IN  DWORD  cbError
//          Size of szError string in bytes.
//
//      OUT LPWSTR szError
//          Buffer for formatted system error message.
//
//  Return Value:
//      The number of characters stored in the output buffer, excluding 
//      the terminating null character. Zero indicates error.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
size_t FormatSystemError( DWORD dwError, size_t cbError, LPWSTR szError )
{
    size_t _cch;
    
    // Format the NT status code from the system.
    _cch = FormatMessageW(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    szError,
                    (DWORD) cbError / sizeof(WCHAR),
                    0
                    );
    if (_cch == 0)
    {
        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = (size_t) FormatMessageW(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            ::GetModuleHandle(L"NTDLL.DLL"),
                            dwError,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                            szError,
                            (DWORD) cbError / sizeof(WCHAR),
                            0
                            );

        if (_cch == 0)    
        {
            // One last chance: see if ACTIVEDS.DLL can format the status code
            HMODULE activeDSHandle = ::LoadLibraryW(L"ACTIVEDS.DLL");

            _cch = (size_t) FormatMessageW(
                                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                                activeDSHandle,
                                dwError,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                szError,
                                (DWORD) cbError / sizeof(WCHAR),
                                0
                                );

            ::FreeLibrary( activeDSHandle );
        }  // if:  error formatting status code from NTDLL
    }  // if:  error formatting status code from system

    return _cch;

} //*** FormatSystemError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintSystemError
//
//  Routine Description:
//      Print a system error.
//
//  Arguments:
//      IN  DWORD dwError
//          The system error code.
//
//      IN  LPCWSTR pszPad
//          Padding to add before displaying the message.
//
//  Return Value:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintSystemError( DWORD dwError, LPCWSTR pszPad )
{
    size_t  _cch;
    WCHAR   _szError[512];
    DWORD   _sc = ERROR_SUCCESS;

//  if( IS_ERROR( dwError ) ) why doesn't this work...

    // Don't display "System error ..." if all that happened was the user
    // canceled the wizard.
    if ( dwError != ERROR_CANCELLED )
    {
        if ( pszPad != NULL )
        {
            MyPrintMessage( stdout, pszPad );
        }
        if ( dwError == ERROR_RESOURCE_PROPERTIES_STORED )
        {
            PrintMessage( MSG_WARNING, dwError );
        } // if:
        else
        {
            PrintMessage( MSG_ERROR, dwError );
        } // else:
    } // if: not ERROR_CANCELLED

    // Format the NT status code.
    _cch = FormatSystemError( dwError, sizeof( _szError ), _szError );

    if (_cch == 0)
    {
        _sc = GetLastError();
        PrintMessage( MSG_ERROR_CODE_ERROR, _sc, dwError );
    }  // if:  error formatting the message
    else
    {
#if 0 // TODO: 29-AUG-2000 DAVIDP Need to print only once.
        if ( pszPad != NULL )
        {
            MyPrintMessage( stdout, pszPad );
        }
        MyPrintMessage( stdout, _szError );
#endif
        MyPrintMessage( stderr, _szError );
    } // else: message formatted without problems   

    return _sc;

} //*** PrintSystemError()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintMessage
//
//  Routine Description:
//      Print a message with substitution strings to stdout.
//
//  Arguments:
//      IN  DWORD dwMessage
//          The ID of the message to load from the resource file.
//
//      ... Any parameters to FormatMessageW.
//
//  Return Value:
//      Any status codes from MyPrintMessage.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintMessage( DWORD dwMessage, ... )
{
    DWORD _sc = ERROR_SUCCESS;

    va_list args;
    va_start( args, dwMessage );

    HMODULE hModule = GetModuleHandle(0);
    DWORD dwLength;
    LPWSTR  lpMessage = 0;

    dwLength = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        (LPCVOID)hModule,
        dwMessage,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // User Default Language
        (LPWSTR)&lpMessage,
        0,
        &args );

    if( dwLength == 0 )
    {
        // Keep as local for debug
        _sc = GetLastError();
        return _sc;
    }

    _sc = MyPrintMessage( stdout, lpMessage );

    LocalFree( lpMessage );

    va_end( args );

    return _sc;

} //*** PrintMessage()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  LoadMessage
//
//  Routine Description:
//      Load a message from the resource file.
//
//  Arguments:
//      IN  DWORD dwMessage
//          The ID of the message to load.
//
//      OUT LPWSTR * ppMessage
//          Pointer in which to return the buffer allocated by this routine.
//          The caller must call LocalFree on the resulting buffer.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was successful.
//      Other Win32 codes.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD LoadMessage( DWORD dwMessage, LPWSTR * ppMessage )
{
    DWORD _sc = ERROR_SUCCESS;

    HMODULE hModule = GetModuleHandle(0);
    DWORD   dwLength;
    LPWSTR  lpMessage = 0;

    dwLength = FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                    (LPCVOID)hModule,
                    dwMessage,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // User Default Language
                    (LPWSTR)&lpMessage,
                    0,
                    0 );

    if( dwLength == 0 )
    {
        // Keep as local for debug
        _sc = GetLastError();
        goto Cleanup;
    }

    *ppMessage = lpMessage;

Cleanup:

    return _sc;

} //*** LoadMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintString
//
//  Routine Description:
//      Print a string to stdout.
//
//  Arguments:
//      IN  LPCWSTR lpszMessage
//          The message to print.
//
//  Return Value:
//      Any status codes from MyPrintMessage.
//
//  Exceptions:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintString( LPCWSTR lpszMessage )
{
    return MyPrintMessage( stdout, lpszMessage );

} //*** PrintString()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  MakeExplicitAccessList
//
//  Routine Description:
//      This function takes a list of strings in the format:
//        trustee1,accessMode1,[accessMask1],trustee2,accessMode2,[accessMask2], ...
//      and creates an vector or EXPLICIT_ACCESS structures.
//
//  Arguments:
//      IN  const CString & strPropName
//          Name of the property whose value is the old SD
//
//      IN  BOOL bClusterSecurity
//          Indicates that access list is being created for the security descriptor
//          of a cluster.
//
//      OUT vector<EXPLICIT_ACCESS> &vExplicitAccess
//          A vector of EXPLICIT_ACCESS structures each containing access control
//          information for one trustee.
//
//  Return Value:
//      None
//
//  Exceptions:
//      CException
//
//--
/////////////////////////////////////////////////////////////////////////////
static
void MakeExplicitAccessList(
        const vector<CString> & vstrValues,
        vector<EXPLICIT_ACCESS> &vExplicitAccess,
        BOOL bClusterSecurity
        )
        throw( CException )
{
    size_t nNumberOfValues = vstrValues.size();
    vExplicitAccess.clear();

    size_t nIndex = 0;
    while ( nIndex < nNumberOfValues )
    {
        // Trustee name is at position nIndex in the vector of values.
        const CString & curTrustee = vstrValues[nIndex];
        DWORD dwInheritance;

        ++nIndex;
        // If there are no more values, it is an error. The access mode has
        // to be specified when the user name has been specified.
        if ( nIndex >= nNumberOfValues )
        {
            CException e;
            e.LoadMessage( MSG_PARAM_SECURITY_MODE_ERROR,
                            curTrustee );

            throw e;
        }

        // Get the access mode.
        const CString & strAccessMode = vstrValues[nIndex];
        ACCESS_MODE amode = LookupType(
                                strAccessMode,
                                accessModeLookupTable,
                                accessModeLookupTableSize );

        if ( amode == NOT_USED_ACCESS )
        {
            CException e;
            e.LoadMessage( MSG_PARAM_SECURITY_MODE_ERROR,
                            curTrustee );

            throw e;
        }

        ++nIndex;

        DWORD dwAccessMask = 0;

        // If the specified access mode was REVOKE_ACCESS then no further values
        // are required. Otherwise atleast one more value must exist.
        if ( amode != REVOKE_ACCESS )
        {
            if ( nIndex >= nNumberOfValues )
            {
                CException e;
                e.LoadMessage( MSG_PARAM_SECURITY_MISSING_RIGHTS,
                                curTrustee );

                throw e;
            }

            LPCWSTR pstrRights = vstrValues[nIndex];
            ++nIndex;

            while ( *pstrRights != L'\0' )
            {
                WCHAR wchRight = towupper( *pstrRights );

                switch ( wchRight )
                {
                    // Read Access
                    case g_ReadAccessChar:
                    {
                        // If bClusterSecurity is TRUE, then full access is the only valid
                        // access right that can be specified.
                        if ( bClusterSecurity != FALSE )
                        {
                            CException e;
                            e.LoadMessage( MSG_PARAM_SECURITY_FULL_ACCESS_ONLY,
                                            curTrustee,
                                            *pstrRights,
                                            g_FullAccessChar );

                            throw e;
                        }

                        dwAccessMask = FILE_GENERIC_READ | FILE_EXECUTE;
                    }
                    break;

                    // Change Access
                    case g_ChangeAccessChar:
                    {
                        // If bClusterSecurity is TRUE, then full access is the only valid
                        // access right that can be specified.
                        if ( bClusterSecurity != FALSE )
                        {
                            CException e;
                            e.LoadMessage( MSG_PARAM_SECURITY_FULL_ACCESS_ONLY,
                                            curTrustee,
                                            *pstrRights,
                                            g_FullAccessChar );

                            throw e;
                        }

                        dwAccessMask = SYNCHRONIZE | READ_CONTROL | DELETE |
                                       FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA |
                                       FILE_APPEND_DATA | FILE_WRITE_DATA;
                    }
                    break;

                    // Full Access
                    case 'F':
                    {
                        if ( bClusterSecurity != FALSE )
                        {
                            dwAccessMask = CLUSAPI_ALL_ACCESS;
                        }
                        else
                        {
                            dwAccessMask = FILE_ALL_ACCESS;
                        }
                    }
                    break;

                    default:
                    {
                        CException e;
                        e.LoadMessage( MSG_PARAM_SECURITY_RIGHTS_ERROR,
                                        curTrustee );

                        throw e;
                    }

                } // switch: Based on the access right type

                ++pstrRights;

            } // while: there are more access rights specified

        } // if: access mode is not REVOKE_ACCESS

        dwInheritance = NO_INHERITANCE;

        EXPLICIT_ACCESS oneACE;
        BuildExplicitAccessWithName(
            &oneACE,
            const_cast<LPWSTR>( (LPCWSTR) curTrustee ),
            dwAccessMask,
            amode,
            dwInheritance );

        vExplicitAccess.push_back( oneACE );

    } // while: There are still values to be processed in the value list.
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CheckForRequiredACEs
//
//  Description:
//      This function makes sure that the security that is passed in has
//      access allowed ACES for those accounts required to have access to
//      a cluster.
//
//  Arguments:
//      IN  const SECURITY_DESCRIPTOR *pSD
//          Pointer to the Security Descriptor to be checked.
//          This is assumed to point to a valid Security Descriptor.
//
//  Return Value:
//      Return ERROR_SUCCESS on success or an error code indicating failure.
//
//  Exceptions:
//      CException is thrown if the required ACEs are missing.
//
//--
/////////////////////////////////////////////////////////////////////////////
static
DWORD CheckForRequiredACEs(
            PSECURITY_DESCRIPTOR pSD
          )
          throw( CException )
{
    DWORD                       _sc = ERROR_SUCCESS;
    CException                  e;
    PSID                        vpRequiredSids[] = { NULL, NULL, NULL };
    DWORD                       vmsgAceNotFound[] = {
                                                      MSG_PARAM_SYSTEM_ACE_MISSING,
                                                      MSG_PARAM_ADMIN_ACE_MISSING,
                                                      MSG_PARAM_NETSERV_ACE_MISSING
                                                    };
    int                         nSidIndex;
    int                         nRequiredSidCount = RTL_NUMBER_OF( vpRequiredSids );
    BOOL                        bRequiredSidsPresent = FALSE;
    PACL                        pDACL           = NULL;
    BOOL                        bHasDACL        = FALSE;
    BOOL                        bDaclDefaulted  = FALSE;
    ACL_SIZE_INFORMATION        asiAclSize;
    ACCESS_ALLOWED_ACE *        paaAllowedAce = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

    if ( ( AllocateAndInitializeSid(            // Allocate System SID
                &siaNtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &vpRequiredSids[0]
         ) == 0 ) ||
         ( AllocateAndInitializeSid(            // Allocate Domain Admins SID
                &siaNtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &vpRequiredSids[1]
         ) == 0 ) ||
         ( AllocateAndInitializeSid(            // Allocate Network Service SID
                &siaNtAuthority,
                1,
                SECURITY_NETWORK_SERVICE_RID,
                0, 0, 0, 0, 0, 0, 0,
                &vpRequiredSids[2]
         ) == 0 ) )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    if ( GetSecurityDescriptorDacl( pSD, &bHasDACL, &pDACL, &bDaclDefaulted ) == 0 )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    // SD does not have DACL. No access is denied for everyone.
    if ( bHasDACL == FALSE )
    {
        goto Cleanup;
    }

    // NULL DACL means access is allowed to everyone.
    if ( pDACL == NULL )
    {
        bRequiredSidsPresent = TRUE;
        goto Cleanup;
    }

    if ( IsValidAcl( pDACL ) == FALSE )
    {
        _sc = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( GetAclInformation(
            pDACL,
            (LPVOID) &asiAclSize,
            sizeof( asiAclSize ),
            AclSizeInformation
            ) == 0 )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

        // Check for the required SIDs.
    for ( nSidIndex = 0; ( nSidIndex < nRequiredSidCount ) && ( _sc == ERROR_SUCCESS ); ++nSidIndex )
    {
        bRequiredSidsPresent = FALSE;

        // Search the ACL for the required SIDs.
        for ( DWORD nAceCount = 0; nAceCount < asiAclSize.AceCount; nAceCount++ )
        {
            if ( GetAce( pDACL, nAceCount, (LPVOID *) &paaAllowedAce ) == 0 )
            {
                _sc = GetLastError();
                break;
            }

            if ( paaAllowedAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
            {
                if ( EqualSid( &paaAllowedAce->SidStart, vpRequiredSids[nSidIndex] ) != FALSE)
                {
                    bRequiredSidsPresent = TRUE;
                    break;

                } // if: EqualSid

            } // if: is this an access allowed ace?

        } // for: loop through all the ACEs in the DACL.

        // This required SID is not present.
        if ( bRequiredSidsPresent == FALSE )
        {
            e.LoadMessage( vmsgAceNotFound[nSidIndex] );
            break;
        }
    } // for: loop through all SIDs that need to be checked.

Cleanup:

    // Free the allocated Sids.
    for ( nSidIndex = 0; nSidIndex < nRequiredSidCount; ++nSidIndex )
    {
        if ( vpRequiredSids[nSidIndex] != NULL )
        {
            FreeSid( vpRequiredSids[nSidIndex] );
        }
    }

    if ( bRequiredSidsPresent == FALSE )
    {
        throw e;
    }

    return _sc;

} //*** CheckForRequiredACEs


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScMakeSecurityDescriptor
//
//  Description:
//      This function takes a list of strings in the format:
//        trustee1,accessMode1,[accessMask1],trustee2,accessMode2,[accessMask2], ...
//      and creates an access control list (ACL). It then adds this ACL to
//      the ACL in the security descriptor (SD) given as a value of the
//      property strPropName in the property list CurrentProps.
//      This updated SD in the self relative format is returned.
//
//  Arguments:
//      IN  const CString & strPropName
//          Name of the property whose value is the old SD
//
//      IN  const CClusPropList & CurrentProps
//          Property list containing strPropName and its value
//
//      IN  const vector<CString> & vstrValues
//          User specified list of trustees, access modes and access masks
//
//      OUT PSECURITY_DESCRIPTOR * pSelfRelativeSD
//          A pointer to the pointer which stores the address of the newly
//          created SD in self relative format. The caller has to free this
//          memory using LocalFree on successful compeltion of this funciton.
//
//      IN  BOOL bClusterSecurity
//          Indicates that access list is being created for the security descriptor
//          of a cluster.
//
//  Return Value:
//      Return ERROR_SUCCESS on success or an error code indicating failure.
//
//  Exceptions:
//      CException
//
//--
/////////////////////////////////////////////////////////////////////////////
static
DWORD ScMakeSecurityDescriptor(
            const CString & strPropName,
            CClusPropList & CurrentProps,
            const vector<CString> & vstrValues,
            PSECURITY_DESCRIPTOR * ppSelfRelativeSD,
            BOOL bClusterSecurity
          )
          throw( CException )
{
    ASSERT( ppSelfRelativeSD != NULL );

    DWORD                   _sc = ERROR_SUCCESS;

    BYTE                    rgbNewSD[ SECURITY_DESCRIPTOR_MIN_LENGTH ];
    PSECURITY_DESCRIPTOR    psdNewSD = reinterpret_cast< PSECURITY_DESCRIPTOR >( rgbNewSD );

    PEXPLICIT_ACCESS        explicitAccessArray = NULL;
    PACL                    paclNewDacl = NULL;
    size_t                  nCountOfExplicitEntries;

    PACL                    paclExistingDacl = NULL;
    BOOL                    bDaclPresent = TRUE;        // We will set the ACL in this function.
    BOOL                    bDaclDefaulted = FALSE;     // So these two flags have these values.

    PACL                    paclExistingSacl = NULL;
    BOOL                    bSaclPresent = FALSE;
    BOOL                    bSaclDefaulted = TRUE;

    PSID                    pGroupSid = NULL;
    BOOL                    bGroupDefaulted = TRUE;

    PSID                    pOwnerSid = NULL;
    BOOL                    bOwnerDefaulted = TRUE;

    // Initialize a new security descriptor.
    if ( InitializeSecurityDescriptor(
            psdNewSD,
            SECURITY_DESCRIPTOR_REVISION
            ) == 0 )
    {
        _sc = ::GetLastError();
        goto Cleanup;
    }


    {
        vector< EXPLICIT_ACCESS > vExplicitAccess;
        MakeExplicitAccessList( vstrValues, vExplicitAccess, bClusterSecurity );

        // Take the vector of EXPLICIT_ACCESS structures and coalesce it into an array
        // since an array is required by the SetEntriesInAcl function.
        // MakeExplicitAccessList either makes a list with at least on element or
        // throws an exception.
        nCountOfExplicitEntries = vExplicitAccess.size();
        explicitAccessArray = ( PEXPLICIT_ACCESS ) LocalAlloc(
                                                        LMEM_FIXED,
                                                        sizeof( explicitAccessArray[0] ) *
                                                        nCountOfExplicitEntries
                                                        );

        if ( explicitAccessArray == NULL )
        {
            return ::GetLastError();
        }

        for ( size_t nIndex = 0; nIndex < nCountOfExplicitEntries; ++nIndex )
        {
            explicitAccessArray[nIndex] = vExplicitAccess[nIndex];
        }

        // vExplicitAccess goes out of scope here, freeing up memory.
    }

    // This property already exists in the property list and contains valid data.
    _sc = CurrentProps.ScMoveToPropertyByName( strPropName );
    if ( ( _sc == ERROR_SUCCESS ) &&
         ( CurrentProps.CbhCurrentValue().pBinaryValue->cbLength > 0 ) )
    {
        PSECURITY_DESCRIPTOR pExistingSD =
            reinterpret_cast< PSECURITY_DESCRIPTOR >( CurrentProps.CbhCurrentValue().pBinaryValue->rgb );

        if ( IsValidSecurityDescriptor( pExistingSD ) == 0 )
        {
            // Return the most appropriate error code, since IsValidSecurityDescriptor
            // does not provide extended error information.
            _sc = ERROR_INVALID_DATA;
            goto Cleanup;

        } // if: : the exisiting SD is not valid
        else
        {
            // Get the DACL, SACL, Group and Owner information of the existing SD

            if ( GetSecurityDescriptorDacl(
                    pExistingSD,        // address of security descriptor
                    &bDaclPresent,      // address of flag for presence of DACL
                    &paclExistingDacl,  // address of pointer to the DACL
                    &bDaclDefaulted     // address of flag for default DACL
                    ) == 0 )
            {
                _sc = GetLastError();
                goto Cleanup;
            }

            if ( GetSecurityDescriptorSacl(
                    pExistingSD,        // address of security descriptor
                    &bSaclPresent,      // address of flag for presence of SACL
                    &paclExistingSacl,  // address of pointer to the SACL
                    &bSaclDefaulted     // address of flag for default SACL
                    ) == 0 )
            {
                _sc = GetLastError();
                goto Cleanup;
            }

            if ( GetSecurityDescriptorGroup(
                    pExistingSD,        // address of security descriptor
                    &pGroupSid,         // address of the pointer to the Group SID
                    &bGroupDefaulted    // address of the flag for default Group
                    ) == 0 )
            {
                _sc = GetLastError();
                goto Cleanup;
            }

            if ( GetSecurityDescriptorOwner(
                    pExistingSD,        // address of security descriptor
                    &pOwnerSid,         // address of the pointer to the Owner SID
                    &bOwnerDefaulted    // address of the flag for default Owner
                    ) == 0 )
            {
                _sc = GetLastError();
                goto Cleanup;
            }

        } // else: the exisiting SD is valid

    } // if: Current property already exists in the property list and has valid data.
    else
    {
        _sc = ERROR_SUCCESS;

    } // else: Current property is a new property.

    // Add the newly created DACL to the existing DACL
    _sc = SetEntriesInAcl(
                        (ULONG)nCountOfExplicitEntries,
                        explicitAccessArray,
                        paclExistingDacl,
                        &paclNewDacl
                        );

    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }


    // Add the DACL, SACL, Group and Owner information to the new SD
    if ( SetSecurityDescriptorDacl(
            psdNewSD,           // pointer to security descriptor
            bDaclPresent,       // flag for presence of DACL
            paclNewDacl,        // pointer to the DACL
            bDaclDefaulted      // flag for default DACL
            ) == 0 )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorSacl(
            psdNewSD,           // pointer to security descriptor
            bSaclPresent,       // flag for presence of DACL
            paclExistingSacl,   // pointer to the SACL
            bSaclDefaulted      // flag for default SACL
            ) == 0 )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorGroup(
            psdNewSD,           // pointer to security descriptor
            pGroupSid,          // pointer to the Group SID
            bGroupDefaulted     // flag for default Group SID
            ) == 0 )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    if ( SetSecurityDescriptorOwner(
            psdNewSD,           // pointer to security descriptor
            pOwnerSid,          // pointer to the Owner SID
            bOwnerDefaulted     // flag for default Owner SID
            ) == 0 )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    if ( bClusterSecurity == FALSE )
    {

#if(_WIN32_WINNT >= 0x0500)

        // If we are not setting the cluster security, set the
        // SE_DACL_AUTO_INHERIT_REQ flag too.

        if ( SetSecurityDescriptorControl(
                psdNewSD,
                SE_DACL_AUTO_INHERIT_REQ,
                SE_DACL_AUTO_INHERIT_REQ
                ) == 0 )
        {
            _sc = GetLastError();
            goto Cleanup;
        }

#endif /* _WIN32_WINNT >=  0x0500 */

    } // if: bClusterSecurity == FALSE

    // Arbitrary size. MakeSelfRelativeSD tell us the required size on failure.
    DWORD dwSDSize = 256;

    // This memory is freed by the caller.
    *ppSelfRelativeSD = ( PSECURITY_DESCRIPTOR ) LocalAlloc( LMEM_FIXED, dwSDSize );

    if ( *ppSelfRelativeSD == NULL )
    {
        _sc = GetLastError();
        goto Cleanup;
    }

    if ( MakeSelfRelativeSD( psdNewSD, *ppSelfRelativeSD, &dwSDSize ) == 0 )
    {
        // MakeSelfReltiveSD may have failed due to insufficient buffer size.
        // Try again with indicated buffer size.
        LocalFree( *ppSelfRelativeSD );

        // This memory is freed by the caller.
        *ppSelfRelativeSD = ( PSECURITY_DESCRIPTOR ) LocalAlloc( LMEM_FIXED, dwSDSize );

        if ( *ppSelfRelativeSD == NULL )
        {
            _sc = GetLastError();
            goto Cleanup;
        }

        if ( MakeSelfRelativeSD( psdNewSD, *ppSelfRelativeSD, &dwSDSize ) == 0 )
        {
            _sc = GetLastError();
            goto Cleanup;
        }

    } // if: MakeSelfRelativeSD fails

Cleanup:

    LocalFree( paclNewDacl );
    LocalFree( explicitAccessArray );

    if ( _sc == ERROR_INVALID_PARAMETER )
    {
        PrintMessage( MSG_ACL_ERROR );
    }

    return _sc;

} //*** ScMakeSecurityDescriptor


/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintProperty helper functions
//
//  Description:
//      These functions are used by all of the command classes to manipulate property lists.
//      Since these are common functions, I should consider putting them into a class or
//      making them part of a base class for the command classes...
//
//  Arguments:
//
//      Variable
//
//  Return Value:
//
//  Exceptions:
//
//--
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintProperties
//  ~~~~~~~~~~~~~~~
//    This function will print the property name/value pairs.
//    The reason that this function is not in the CClusPropList class is
//    that is is not generic. The code in cluswrap.cpp is intended to be generic.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD PrintProperties(
    CClusPropList &             PropList,
    const vector< CString > &   vstrFilterList,
    PropertyAttrib              eReadOnly,
    LPCWSTR                     pszOwnerName,
    LPCWSTR                     pszNetIntSpecific
    )
{
    DWORD _sc = PropList.ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        size_t _nFilterListSize = vstrFilterList.size();

        do
        {
            LPCWSTR _pszCurPropName = PropList.PszCurrentPropertyName();

            // If property names are provided in the filter list then it means that only those
            // properties whose names are listed are to be displayed.
            if ( _nFilterListSize != 0 )
            {
                // Check if the current property is to be displayed or not.
                BOOL    _bFound = FALSE;
                size_t  _idx;

                for ( _idx = 0 ; _idx < _nFilterListSize ; ++_idx )
                {
                    if ( vstrFilterList[ _idx ].CompareNoCase( _pszCurPropName ) == 0 )
                    {
                        _bFound = TRUE;
                        break;
                    }

                } // for: the number of entries in the filter list.

                if ( _bFound == FALSE )
                {
                    // This property need not be displayed.

                    // Advance to the next property.
                    _sc = PropList.ScMoveToNextProperty();

                    continue;
                }

            } // if: properties need to be filtered.

            do
            {
                _sc = PrintProperty(
                        PropList.PszCurrentPropertyName(),
                        PropList.CbhCurrentValue(),
                        eReadOnly,
                        pszOwnerName,
                        pszNetIntSpecific
                        );

                if ( _sc != ERROR_SUCCESS )
                {
                    return _sc;
                }

                //
                // Advance to the next property.
                //
                _sc = PropList.ScMoveToNextPropertyValue();
            } while ( _sc == ERROR_SUCCESS );

            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _sc = PropList.ScMoveToNextProperty();
            } // if: exited loop because all values were enumerated
        } while ( _sc == ERROR_SUCCESS );
    } // if: move to first prop succeeded.  Would fail if empty!

    if ( _sc == ERROR_NO_MORE_ITEMS )
    {
        _sc = ERROR_SUCCESS;
    } // if: exited loop because all properties were enumerated

    return _sc;

} //*** PrintProperties()




DWORD PrintProperty(
    LPCWSTR                 pwszPropName,
    CLUSPROP_BUFFER_HELPER  PropValue,
    PropertyAttrib          eReadOnly,
    LPCWSTR                 pszOwnerName,
    LPCWSTR                 pszNetIntSpecific
    )
{
    DWORD _sc = ERROR_SUCCESS;

    LPWSTR  _pszValue = NULL;
    LPCWSTR _pszFormatChar = LookupName( (CLUSTER_PROPERTY_FORMAT) PropValue.pValue->Syntax.wFormat,
                                        formatCharLookupTable, formatCharLookupTableSize );

    PrintMessage( MSG_PROPERTY_FORMAT_CHAR, _pszFormatChar );

    if ( eReadOnly == READONLY )
    {
        PrintMessage( MSG_READONLY_PROPERTY );
    }
    else
    {
        PrintMessage( MSG_READWRITE_PROPERTY );
    }

    switch( PropValue.pValue->Syntax.wFormat )
    {
        case CLUSPROP_FORMAT_SZ:
        case CLUSPROP_FORMAT_EXPAND_SZ:
        case CLUSPROP_FORMAT_EXPANDED_SZ:
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_STRING_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pStringValue->sz
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                            MSG_PROPERTY_STRING_WITH_OWNER,
                            pszOwnerName,
                            pwszPropName,
                            PropValue.pStringValue->sz
                            );
                }
                else
                {
                    _sc = PrintMessage(
                            MSG_PROPERTY_STRING,
                            pwszPropName,
                            PropValue.pStringValue->sz
                            );
                }
            }
            break;

        case CLUSPROP_FORMAT_MULTI_SZ:
            _pszValue = PropValue.pStringValue->sz;

            for ( ;; )
            {
                if (    ( pszOwnerName != NULL )
                    &&  ( pszNetIntSpecific != NULL ) )
                {
                    PrintMessage(
                        MSG_PROPERTY_STRING_WITH_NODE_AND_NET,
                        pszOwnerName,
                        pszNetIntSpecific,
                        pwszPropName,
                        _pszValue
                        );
                } // if:
                else
                {
                    if ( pszOwnerName != NULL )
                    {
                        PrintMessage(
                            MSG_PROPERTY_STRING_WITH_OWNER,
                            pszOwnerName,
                            pwszPropName,
                            _pszValue
                            );
                    }
                    else
                    {
                        PrintMessage(
                            MSG_PROPERTY_STRING,
                            pwszPropName,
                            _pszValue
                            );
                    }
                } // else:


                while ( *_pszValue != L'\0' )
                {
                    _pszValue++;
                }
                _pszValue++; // Skip the NULL

                if ( *_pszValue != L'\0' )
                {
                    PrintMessage( MSG_PROPERTY_FORMAT_CHAR, _pszFormatChar );

                    if ( eReadOnly == READONLY )
                    {
                        PrintMessage( MSG_READONLY_PROPERTY );
                    }
                    else
                    {
                        PrintMessage( MSG_READWRITE_PROPERTY );
                    }
                } // if:
                else
                {
                    break;
                } // else:
            } // for: ever

            break;

        case CLUSPROP_FORMAT_BINARY:
        {
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_BINARY_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_BINARY_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName
                                );
                }
                else
                {
                    _sc = PrintMessage( MSG_PROPERTY_BINARY, pwszPropName );
                }
            }

            int _nCount = PropValue.pBinaryValue->cbLength;
            int _idx;

            // Display a maximum of 4 bytes.
            if ( _nCount > 4 )
            {
                _nCount = 4;
            }

            for ( _idx = 0 ; _idx < _nCount ; ++_idx )
            {
                PrintMessage( MSG_PROPERTY_BINARY_VALUE, PropValue.pBinaryValue->rgb[ _idx ] );
            }

            PrintMessage( MSG_PROPERTY_BINARY_VALUE_COUNT, PropValue.pBinaryValue->cbLength );

            break;
        }

        case CLUSPROP_FORMAT_DWORD:
            if ( ( pszOwnerName != NULL ) && ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_DWORD_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pDwordValue->dw
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_DWORD_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName,
                                PropValue.pDwordValue->dw
                                );
                }
                else
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_DWORD,
                                pwszPropName,
                                PropValue.pDwordValue->dw
                                );
                }
            }
            break;

        case CLUSPROP_FORMAT_LONG:
            if ( ( pszOwnerName != NULL ) && ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_LONG_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            PropValue.pLongValue->l
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_LONG_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName,
                                PropValue.pLongValue->l
                                );
                }
                else
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_LONG,
                                pwszPropName,
                                PropValue.pLongValue->l
                                );
                }
            }
            break;

        case CLUSPROP_FORMAT_ULARGE_INTEGER:
            //
            // we don't know if the large int will be properly aligned for
            // Win64. To handle this, each DWORD is copied separately into an
            // aligned structure.
            //
            ULARGE_INTEGER  ulPropValue;

            ulPropValue.u = PropValue.pULargeIntegerValue->li.u;

            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {

                _sc = PrintMessage(
                            MSG_PROPERTY_ULARGE_INTEGER_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName,
                            ulPropValue.QuadPart
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_ULARGE_INTEGER_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName,
                                ulPropValue.QuadPart
                                );
                }
                else
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_ULARGE_INTEGER,
                                pwszPropName,
                                ulPropValue.QuadPart
                                );
                }
            }
            break;


        default:
            if (    ( pszOwnerName != NULL )
                &&  ( pszNetIntSpecific != NULL ) )
            {
                _sc = PrintMessage(
                            MSG_PROPERTY_UNKNOWN_WITH_NODE_AND_NET,
                            pszOwnerName,
                            pszNetIntSpecific,
                            pwszPropName
                            );
            }
            else
            {
                if ( pszOwnerName != NULL )
                {
                    _sc = PrintMessage(
                                MSG_PROPERTY_UNKNOWN_WITH_OWNER,
                                pszOwnerName,
                                pwszPropName
                                );
                }
                else
                {
                    _sc = PrintMessage( MSG_PROPERTY_UNKNOWN, pwszPropName );
                }
            }

            break;
    }


    return _sc;

} //*** PrintProperty()


// Constructs a property list in which all the properties named in vstrPropName
// are set to their default values.
DWORD ConstructPropListWithDefaultValues(
    CClusPropList &             CurrentProps,
    CClusPropList &             newPropList,
    const vector< CString > &   vstrPropNames
    )
{
    DWORD _sc = ERROR_SUCCESS;

    size_t  _nListSize = vstrPropNames.size();
    size_t  _nListBufferNeeded = 0;
    size_t  _idx;
    size_t  _nPropNameLen;

    // Precompute the required size of the property list to prevent resizing
    // every time a property is added.
    // Does not matter too much if this value is wrong.

    for ( _idx = 0 ; _idx < _nListSize ; ++_idx )
    {
        _nPropNameLen = ( vstrPropNames[ _idx ].GetLength() + 1 ) * sizeof( WCHAR );

        _nListBufferNeeded += sizeof( CLUSPROP_PROPERTY_NAME ) +
                                sizeof( CLUSPROP_VALUE ) +
                                sizeof( CLUSPROP_SYNTAX ) +
                                ALIGN_CLUSPROP( _nPropNameLen ) +   // Length of the property name
                                ALIGN_CLUSPROP( 0 );                // Length of the data
    }

    _sc = newPropList.ScAllocPropList( (DWORD) _nListBufferNeeded );
    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    for ( _idx = 0 ; _idx < _nListSize ; ++_idx )
    {
        const CString & strCurrent = vstrPropNames[ _idx ];

        // Search for current property in the list of existing properties.
        _sc = CurrentProps.ScMoveToPropertyByName( strCurrent );

        // If the current property does not exist, nothing needs to be done.
        if ( _sc != ERROR_SUCCESS )
        {
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _sc = ERROR_SET_NOT_FOUND;
            }
            continue;
        }

        _sc = newPropList.ScSetPropToDefault( strCurrent, CurrentProps.CpfCurrentValueFormat() );
        if ( _sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    } // for: 

Cleanup:

    return _sc;

} //*** ConstructPropListWithDefaultValues()


DWORD ConstructPropertyList(
    CClusPropList &CurrentProps,
    CClusPropList &NewProps,
    const vector<CCmdLineParameter> & paramList,
    BOOL bClusterSecurity /* = FALSE */,
	DWORD idExceptionHelp /* = MSG_SEE_CLUSTER_HELP */
    )
    throw( CSyntaxException )
{
    // Construct a list checking name and type against the current properties.
    DWORD _sc = ERROR_SUCCESS;
    CSyntaxException se( idExceptionHelp );

    vector< CCmdLineParameter >::const_iterator curParam = paramList.begin();
    vector< CCmdLineParameter >::const_iterator last = paramList.end();

    // Add each property to the property list.
    for( ; ( curParam != last )  && ( _sc == ERROR_SUCCESS ); ++curParam )
    {
        const CString & strPropName = curParam->GetName();
        const vector< CString > & vstrValues = curParam->GetValues();
        BOOL  bKnownProperty = FALSE;

        if ( curParam->GetType() != paramUnknown )
        {
            se.LoadMessage( MSG_INVALID_OPTION, strPropName );
            throw se;
        }

        // All properties must must have at least one value.
        if ( vstrValues.size() <= 0 )
        {
            se.LoadMessage( MSG_PARAM_VALUE_REQUIRED, strPropName );
            throw se;
        }

        if ( curParam->GetValueFormat() == vfInvalid )
        {
            se.LoadMessage( MSG_PARAM_INVALID_FORMAT, strPropName, curParam->GetValueFormatName() );
            throw se;
        }

        ValueFormat vfGivenFormat;

        // Look up property to determine format
        _sc = CurrentProps.ScMoveToPropertyByName( strPropName );
        if ( _sc == ERROR_SUCCESS )
        {
            WORD wActualClusPropFormat = (WORD) CurrentProps.CpfCurrentValueFormat();
            ValueFormat vfActualFormat = ClusPropToValueFormat[ wActualClusPropFormat ];

            if ( curParam->GetValueFormat() == vfUnspecified )
            {
                vfGivenFormat = vfActualFormat;

            } // if: no format was specififed.
            else
            {
                vfGivenFormat = curParam->GetValueFormat();

                // Special Case:
                // Don't check to see if the given format matches with the actual format
                // if the given format is security and the actual format is binary.
                if ( ( vfGivenFormat != vfSecurity ) || ( vfActualFormat != vfBinary ) )
                {
                    if ( vfActualFormat != vfGivenFormat )
                    {
                        se.LoadMessage( MSG_PARAM_INCORRECT_FORMAT,
                                        strPropName,
                                        curParam->GetValueFormatName(),
                                        LookupName( (CLUSTER_PROPERTY_FORMAT) wActualClusPropFormat,
                                                    cluspropFormatLookupTable,
                                                    cluspropFormatLookupTableSize ) );
                        throw se;
                    }
                } // if: given format is not Security or actual format is not binary

            } // else: a format was specified.

            bKnownProperty = TRUE;
        } // if: the current property is a known property
        else
        {

            // The current property is user defined property.
            // CurrentProps.ScMoveToPropertyByName returns ERROR_NO_MORE_ITEMS in this case.
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                // This is not a predefined property.
                if ( curParam->GetValueFormat() == vfUnspecified )
                {
                    // If the format is unspecified, assume it to be a string.
                    vfGivenFormat = vfSZ;
                }
                else
                {
                    // Otherwise, use the specified format.
                    vfGivenFormat = curParam->GetValueFormat();
                }

                bKnownProperty = FALSE;
                _sc = ERROR_SUCCESS;

            } // if: CurrentProps.ScMoveToPropertyByName returned ERROR_NO_MORE_ITEMS
            else
            {
                // An error occurred - quit.
                break;

            } // else: an error occurred

        } // else: the current property is not a known property


        switch( vfGivenFormat )
        {
            case vfSZ:
            {
                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                _sc = NewProps.ScAddProp( strPropName, vstrValues[ 0 ], CurrentProps.CbhCurrentValue().psz );
                break;
            }

            case vfExpandSZ:
            {
                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                _sc = NewProps.ScAddExpandSzProp( strPropName, vstrValues[ 0 ] );
                break;
            }

            case vfMultiSZ:
            {
                CString strMultiszString;

                curParam->GetValuesMultisz( strMultiszString );
                if ( bKnownProperty )
                {
                    _sc = NewProps.ScAddMultiSzProp( strPropName, strMultiszString, CurrentProps.CbhCurrentValue().pMultiSzValue->sz );
                }
                else
                {
                    _sc = NewProps.ScAddMultiSzProp( strPropName, strMultiszString, NULL );
                }
            }
            break;

            case vfDWord:
            {
                DWORD dwOldValue;

                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                DWORD dwValue = 0;

                _sc = MyStrToDWORD( vstrValues[ 0 ], &dwValue );
                if (_sc != ERROR_SUCCESS)
                {
                    break;
                }

                if ( bKnownProperty )
                {
                    // Pass the old value only if this property already exists.
                    dwOldValue = CurrentProps.CbhCurrentValue().pDwordValue->dw;
                }
                else
                {
                    // Otherwise pass a value different from the new value.
                    dwOldValue = dwValue - 1;
                }
                _sc = NewProps.ScAddProp( strPropName, dwValue, dwOldValue );
            }
            break;

            case vfBinary:
            {
                size_t cbValues = vstrValues.size();

                // Get the bytes to be stored.
                BYTE *pByte = (BYTE *) ::LocalAlloc( LMEM_FIXED, cbValues * sizeof( *pByte ) );

                if ( pByte == NULL )
                {
                    _sc = ::GetLastError();
                    break;
                }

                for ( size_t idx = 0 ; idx < cbValues ; )
                {
                   // If this value is an empty string, ignore it.
                   if ( vstrValues[ idx ].IsEmpty() )
                   {
                      --cbValues;
                      continue;
                   }

                    _sc = MyStrToBYTE( vstrValues[ idx ], &pByte[ idx ] );
                    if ( _sc != ERROR_SUCCESS )
                    {
                        ::LocalFree( pByte );
                        break;
                    }

                     ++idx;
                }

                if ( _sc == ERROR_SUCCESS )
                {
                    _sc = NewProps.ScAddProp(
                                strPropName,
                                pByte,
                                (DWORD) cbValues,
                                CurrentProps.CbhCurrentValue().pb,
                                CurrentProps.CbCurrentValueLength()
                                 );
                    ::LocalFree( pByte );
                }
            }
            break;

            case vfULargeInt:
            {
                ULONGLONG ullValue = 0;
                ULARGE_INTEGER ullOldValue;

                if ( vstrValues.size() != 1 )
                {
                    // Only one value must be specified for the format.
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, strPropName );
                    throw se;
                }

                _sc = MyStrToULongLong( vstrValues[ 0 ], &ullValue );
                if ( _sc != ERROR_SUCCESS )
                {
                    break;
                }

                if ( bKnownProperty )
                {
                   // Pass the old value only if this property already
                   // exists. copy as two DWORDS since the large int in the
                   // property list might not be properly aligned.
                    ullOldValue.u = CurrentProps.CbhCurrentValue().pULargeIntegerValue->li.u;
                }
                else
                {
                   // Otherwise pass a value different from the new value.
                    ullOldValue.QuadPart = ullValue - 1;
                }
                _sc = NewProps.ScAddProp( strPropName, ullValue, ullOldValue.QuadPart );
            }
            break;

            case vfSecurity:
            {
                PBYTE pSelfRelativeSD = NULL;

                _sc = ScMakeSecurityDescriptor(
                            strPropName,
                            CurrentProps,
                            vstrValues,
                            reinterpret_cast< PSECURITY_DESCRIPTOR * >( &pSelfRelativeSD ),
                            bClusterSecurity
                          );

                if ( _sc != ERROR_SUCCESS )
                {
                    ::LocalFree( pSelfRelativeSD );
                    goto Cleanup;
                }

                if ( bClusterSecurity != FALSE )
                {
                    _sc = CheckForRequiredACEs( pSelfRelativeSD );
                    if ( _sc != ERROR_SUCCESS )
                    {
                        _sc = CheckForRequiredACEs( pSelfRelativeSD );
                        if ( _sc != ERROR_SUCCESS )
                        {
                            break;
                        }
                    }
                }

                _sc = NewProps.ScAddProp(
                            strPropName,
                            pSelfRelativeSD,
                            ::GetSecurityDescriptorLength( static_cast< PSECURITY_DESCRIPTOR >( pSelfRelativeSD ) ),
                            CurrentProps.CbhCurrentValue().pb,
                            CurrentProps.CbCurrentValueLength()
                            );

                ::LocalFree( pSelfRelativeSD );
            }
            break;

            default:
            {
                se.LoadMessage( MSG_PARAM_CANNOT_SET_PARAMETER,
                                strPropName,
                                curParam->GetValueFormatName() );
                throw se;
            }
        } // switch: format
    } // for: each property

Cleanup:

    return _sc;

} //*** ConstructPropertyList()


DWORD MyStrToULongLong( LPCWSTR lpwszNum, ULONGLONG * pullValue )
{
    // This string stores any extra characters that may be present in
    // lpwszNum. The presence of extra characters after the integer
    // is an error.
    WCHAR wszExtraCharBuffer[ 2 ];
    DWORD sc = ERROR_SUCCESS;
    int nFields;

    *pullValue = 0;

    // Check for valid params
    if (!lpwszNum || !pullValue)
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    // Do the conversion
    nFields = swscanf( lpwszNum, L"%I64u %1s", pullValue, wszExtraCharBuffer );

    // check if there was an overflow
    if ( ( errno == ERANGE ) || ( *pullValue > _UI64_MAX ) || ( nFields != 1 ) )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

Cleanup:

    return sc;

} //*** MyStrToULongLong


DWORD MyStrToBYTE(LPCWSTR lpszNum, BYTE *pByte )
{
    DWORD dwValue = 0;
    LPWSTR lpszEndPtr;

    *pByte = 0;

    // Check for valid params
    if (!lpszNum || !pByte)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Do the conversion
    dwValue = _tcstoul( lpszNum,  &lpszEndPtr, 0 );

    // check if there was an overflow
    if ( ( errno == ERANGE ) || ( dwValue > UCHAR_MAX ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwValue == 0 && lpszNum == lpszEndPtr)
    {
        // wcsto[u]l was unable to perform the conversion
        return ERROR_INVALID_PARAMETER;
    }

    // Skip whitespace characters, if any, at the end of the input.
    while ( ( *lpszEndPtr != L'\0' && ( ::iswspace( *lpszEndPtr ) != 0 ) ) )
    {
        ++lpszEndPtr;
    }

    // Check if there are additional junk characters in the input.
    if (*lpszEndPtr != L'\0' )
    {
        // wcsto[u]l was able to partially convert the number,
        // but there was extra junk on the end
        return ERROR_INVALID_PARAMETER;
    }

    *pByte = (BYTE)dwValue;
    return ERROR_SUCCESS;
}


DWORD MyStrToDWORD (LPCWSTR lpszNum, DWORD *lpdwVal )
{
    DWORD dwTmp;
    LPWSTR lpszEndPtr;

    // Check for valid params
    if (!lpszNum || !lpdwVal)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Do the conversion
    if (lpszNum[0] != L'-')
    {
        dwTmp = wcstoul(lpszNum, &lpszEndPtr, 0);
        if (dwTmp == ULONG_MAX)
        {
            // check if there was an overflow
            if (errno == ERANGE)
            {
                return ERROR_ARITHMETIC_OVERFLOW;
            }
        }
    }
    else
    {
        dwTmp = wcstol(lpszNum, &lpszEndPtr, 0);
        if (dwTmp == LONG_MAX || dwTmp == LONG_MIN)
        {
            // check if there was an overflow
            if (errno == ERANGE)
            {
                return ERROR_ARITHMETIC_OVERFLOW;
            }
        }
    }

    if (dwTmp == 0 && lpszNum == lpszEndPtr)
    {
        // wcsto[u]l was unable to perform the conversion
        return ERROR_INVALID_PARAMETER;
    }

    // Skip whitespace characters, if any, at the end of the input.
    while ( ( *lpszEndPtr != L'\0' && ( ::iswspace( *lpszEndPtr ) != 0 ) ) )
    {
        ++lpszEndPtr;
    }

    // Check if there are additional junk characters in the input.
    if (*lpszEndPtr != L'\0' )
    {
        // wcsto[u]l was able to partially convert the number,
        // but there was extra junk on the end
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwVal = dwTmp;
    return ERROR_SUCCESS;
}

DWORD MyStrToLONG (LPCWSTR lpszNum, LONG *lplVal )
{
    LONG    lTmp;
    LPWSTR  lpszEndPtr;

    // Check for valid params
    if (!lpszNum || !lplVal)
    {
        return ERROR_INVALID_PARAMETER;
    }

    lTmp = wcstol(lpszNum, &lpszEndPtr, 0);
    if (lTmp == LONG_MAX || lTmp == LONG_MIN)
    {
        // check if there was an overflow
        if (errno == ERANGE)
        {
            return ERROR_ARITHMETIC_OVERFLOW;
        }
    }

    if (lTmp == 0 && lpszNum == lpszEndPtr)
    {
        // wcstol was unable to perform the conversion
        return ERROR_INVALID_PARAMETER;
    }

    // Skip whitespace characters, if any, at the end of the input.
    while ( ( *lpszEndPtr != L'\0' && ( ::iswspace( *lpszEndPtr ) != 0 ) ) )
    {
        ++lpszEndPtr;
    }

    // Check if there are additional junk characters in the input.
    if (*lpszEndPtr != L'\0' )
    {
        // wcstol was able to partially convert the number,
        // but there was extra junk on the end
        return ERROR_INVALID_PARAMETER;
    }

    *lplVal = lTmp;
    return ERROR_SUCCESS;
}



DWORD
WaitGroupQuiesce(
    IN HCLUSTER hCluster,
    IN HGROUP   hGroup,
    IN LPWSTR   lpszGroupName,
    IN DWORD    dwWaitTime
    )

/*++

Routine Description:

    Waits for a group to quiesce, i.e. the state of all resources to
    transition to a stable state.

Arguments:

    hCluster - the handle to the cluster.

    lpszGroupName - the name of the group.

    dwWaitTime - the wait time (in seconds) to wait for the group to stabilize.
               Zero implies a default wait interval.

Return Value:

    Status of the wait.
    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD       _sc;
    HRESOURCE   hResource;
    LPWSTR      lpszName;
    DWORD       dwIndex;
    DWORD       dwType;

    LPWSTR      lpszEnumGroupName;
    LPWSTR      lpszEnumNodeName;

    CLUSTER_RESOURCE_STATE nState;

    if ( dwWaitTime == 0 ) 
    {
        return(ERROR_SUCCESS);
    }

    HCLUSENUM   hEnum = ClusterOpenEnum( hCluster,
                                         CLUSTER_ENUM_RESOURCE );
    if ( hEnum == NULL ) 
    {
        return GetLastError();
    }

    // Wait for a group state change event
    CClusterNotifyPort port;
    _sc = port.Create( (HCHANGE)INVALID_HANDLE_VALUE, hCluster );
    if ( _sc != ERROR_SUCCESS ) 
    {
        return(_sc);
    }

    port.Register( CLUSTER_CHANGE_GROUP_STATE, hGroup );

retry:
    for ( dwIndex = 0; (--dwWaitTime !=0 );  dwIndex++ ) 
    {

        _sc = WrapClusterEnum( hEnum,
                                   dwIndex,
                                   &dwType,
                                   &lpszName );
        if ( _sc == ERROR_NO_MORE_ITEMS ) {
            _sc = ERROR_SUCCESS;
            break;
        }

        if ( _sc != ERROR_SUCCESS ) {
            break;
        }
        hResource = OpenClusterResource( hCluster,
                                         lpszName );
        //LocalFree( lpszName );
        if ( !hResource ) {
            _sc = GetLastError();
            LocalFree( lpszName );
            break;
        }

        nState = WrapGetClusterResourceState( hResource,
                                              &lpszEnumNodeName,
                                              &lpszEnumGroupName );
        LocalFree( lpszEnumNodeName );
        //LocalFree( lpszName );
        if ( nState == ClusterResourceStateUnknown ) 
        {
            _sc = GetLastError();
            CloseClusterResource( hResource );
            LocalFree( lpszEnumGroupName );
            LocalFree( lpszName );
            break;
        }

        CloseClusterResource( hResource );

        _sc = ERROR_SUCCESS;
        //
        // If this group is the correct group make sure the resource state
        // is stable...
        //
        if ( lpszEnumGroupName && *lpszEnumGroupName &&
             (lstrcmpiW( lpszGroupName, lpszEnumGroupName ) == 0) &&
             (nState >= ClusterResourceOnlinePending) ) 
        {
            LocalFree( lpszEnumGroupName );
            LocalFree( lpszName );
            port.GetNotify();
            goto retry;
        }
        LocalFree( lpszName );
        LocalFree( lpszEnumGroupName );
    }

    ClusterCloseEnum( hEnum );

    return(_sc);

} // WaitGroupQuiesce


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetLocalNodeFQDNName(
//      BSTR *  pbstrFQDNOut
//      )
//
//  Description:
//      Gets the FQDN for the local node.
//      
//  Arguments:
//      pbstrFQDNOut    -- FQDN being returned.  Caller must free using
//                          SysFreeString().
//
//  Exceptions:
//      None.
//
//  Return Values:
//      S_OK    -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetLocalNodeFQDNName(
    BSTR *  pbstrFQDNOut
    )
{
    HRESULT                 hr = S_OK;
    WCHAR                   wszHostname[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD                   cchHostname = RTL_NUMBER_OF( wszHostname );
    BOOL                    fReturn;
    DWORD                   dwErr;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;

    //
    // DsGetDcName will give us access to a usable domain name, regardless of whether we are
    // currently in a W2k or a NT4 domain. On W2k and above, it will return a DNS domain name,
    // on NT4 it will return a NetBIOS name.
    //
    fReturn = GetComputerNameEx( ComputerNamePhysicalDnsHostname, wszHostname, &cchHostname );
    if ( fReturn == FALSE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    }

    dwErr = DsGetDcName(
                      NULL
                    , NULL
                    , NULL
                    , NULL
                    , DS_DIRECTORY_SERVICE_PREFERRED
                    , &pdci
                    );
    if ( dwErr != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Cleanup;
    } // if: DsGetDcName failed

    // 
    // now, append the domain name (might be either NetBIOS or DNS style, depending on whether or nor
    // we are in a legacy domain)
    //
    if ( ( wcslen( pdci->DomainName ) + cchHostname + 1 ) > DNS_MAX_NAME_BUFFER_LENGTH )
    {
        hr = HRESULT_FROM_WIN32( ERROR_MORE_DATA );
        goto Cleanup;
    } // if:

    hr = StringCchCatW( wszHostname, RTL_NUMBER_OF( wszHostname ), L"." );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = StringCchCatW( wszHostname, RTL_NUMBER_OF( wszHostname ), pdci->DomainName );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Construct the BSTR.
    *pbstrFQDNOut = SysAllocString( wszHostname );
    if ( *pbstrFQDNOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    if ( pdci != NULL )
    {
        NetApiBufferFree( pdci );
    }

    return hr;

} //*** HrGetLocalNodeFQDNName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrGetLoggedInUserDomain(
//      BSTR *  pbstrDomainOut
//      )
//
//  Description:
//      Gets the domain name of the currently logged in user.
//      
//  Arguments:
//      pbstrDomainOut  -- Domain being returned.  Caller must free using
//                          SysFreeString().
//
//  Exceptions:
//      None.
//
//  Return Values:
//      S_OK    -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrGetLoggedInUserDomain( BSTR * pbstrDomainOut )
{
    HRESULT hr          = S_OK;
    DWORD   sc;
    BOOL    fSuccess;
    LPWSTR  pwszSlash;
    LPWSTR  pwszUser    = NULL;
    ULONG   nSize       = 0;

    // Get the size of the user.
    fSuccess = GetUserNameEx( NameSamCompatible, NULL, &nSize );
    sc = GetLastError();
    if ( sc != ERROR_MORE_DATA )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    }

    // Allocate the name buffer.
    pwszUser = new WCHAR[ nSize ];
    if ( pwszUser == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get the username with domain.
    fSuccess = GetUserNameEx( NameSamCompatible, pwszUser, &nSize );
    if ( fSuccess == FALSE )
    {
        sc = GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    }

    // Find the end of the domain name and truncate.
    pwszSlash = wcschr( pwszUser, L'\\' );
    if ( pwszSlash == NULL )
    {
        // we're in trouble
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }
    *pwszSlash = L'\0';

    // Create the BSTR.
    *pbstrDomainOut = SysAllocString( pwszUser );
    if ( *pbstrDomainOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    delete [] pwszUser;

    return hr;

} //*** HrGetLoggedInUserDomain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  ScGetPassword(
//        LPWSTR    pwszPasswordOut
//      , DWORD     cchPasswordIn
//      )
//
//  Description:
//      Reads a password from the console.
//      
//  Arguments:
//      pwszPasswordOut -- Buffer in which to return the password.
//      cchPasswordIn   -- Size of password buffer.
//
//  Exceptions:
//      None.
//
//  Return Values:
//      ERROR_SUCCESS   -- Operation was successufl.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
ScGetPassword(
      LPWSTR    pwszPasswordOut
    , DWORD     cchPasswordIn
    )
{
    DWORD   sc    = ERROR_SUCCESS;
    DWORD   cchRead;
    DWORD   cchMax;
    DWORD   cchTotal    = 0;
    WCHAR   wch;
    WCHAR * pwsz;
    BOOL    fSuccess;
    DWORD   dwConsoleMode;

    cchMax = cchPasswordIn - 1;     // Make room for the terminating NULL.
    pwsz = pwszPasswordOut;

    // Set the console mode to prevent echoing characters typed.
    GetConsoleMode( GetStdHandle( STD_INPUT_HANDLE ), &dwConsoleMode );
    SetConsoleMode(
          GetStdHandle( STD_INPUT_HANDLE )
        , dwConsoleMode & ~( ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT )
        );

    // Read from the console.
    for ( ;; )
    {
        fSuccess = ReadConsoleW(
                          GetStdHandle( STD_INPUT_HANDLE )
                        , &wch
                        , 1
                        , &cchRead
                        , NULL
                        );
        if ( ! fSuccess || ( cchRead != 1 ) )
        {
            sc = GetLastError();
            wch = 0xffff;
        }

        if ( ( wch == L'\r' ) || ( wch == 0xffff ) )    // end of the line
        {
            break;
        }

        if ( wch == L'\b' )                             // back up one or two
        {
            //
            // IF pwsz == pwszPasswordOut then we are at the
            // beginning of the line and the next two lines are
            // a no op.
            //
            if ( pwsz != pwszPasswordOut )
            {
                pwsz--;
                cchTotal--;
            }
        } // if: BACKSPACE
        else
        {
            //
            //  If we haven't already filled the buffer then assign the
            //  next letter.  Otherwise don't keep overwriting the 
            //  last character before the null.
            //
            if ( cchTotal < cchMax )
            {
                *pwsz = wch;
                pwsz++;
                cchTotal++;
            }
        } // else: not BACKSPACE
    } // for: ever

    // Reset the console mode and NUL-terminate the string.
    SetConsoleMode( GetStdHandle( STD_INPUT_HANDLE ), dwConsoleMode );
    *pwsz = L'\0';
    putwchar( L'\n' );

    return sc;

} //*** ScGetPassword()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  MatchCRTLocaleToConsole( void )
//
//  Description:
//      Set's C runtime library's locale to match the console's output code page.
//      
//  Exceptions:
//      None.
//
//  Return Values:
//      TRUE   -- Operation was successful.
//      FALSE  -- _wsetlocale returned null, indicating an error.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
MatchCRTLocaleToConsole( void )
{
    UINT    nCodepage;
    WCHAR   szCodepage[ 16 ] = L".OCP"; // Defaults to the current OEM
                                        // code page obtained from the
                                        // operating system in case the
                                        // logic below fails.
    WCHAR*  wszResult = NULL;
    HRESULT hr = S_OK;

    nCodepage = GetConsoleOutputCP();
    if ( nCodepage != 0 )
    {
        hr = THR( StringCchPrintfW( szCodepage, RTL_NUMBER_OF( szCodepage ), L".%u", nCodepage ) );
    } // if:

    wszResult = _wsetlocale( LC_ALL, szCodepage );

    return ( wszResult != NULL );

} //*** MatchCRTLocaleToConsole
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\admnetutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AdmNetUtils.cpp
//
//	Abstract:
//		Implementation of network utility functions.
//
//	Author:
//		David Potter (davidp)	February 19, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <wtypes.h>
#include "clusrtl.h"
#include "AdmNetUtils.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsValidIpAddress
//
//	Routine Description:
//		Determine if the specified string is a valid IP address.
//
//	Arguments:
//		pszAddress	[IN] Address string to validate.
//
//	Return Value:
//		TRUE		String is valid IP address.
//		FALSE		String is not a valid IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsValidIpAddress( IN LPCWSTR pszAddress )
{
	ULONG	nAddress;
	DWORD	nStatus;
	BOOL	bIsValid = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
	if ( nStatus == ERROR_SUCCESS )
	{
		bIsValid = ClRtlIsValidTcpipAddress( nAddress );
	} // if:  converted address successfully

	return bIsValid;

}  //*** BIsValidIpAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsValidSubnetMask
//
//	Routine Description:
//		Determine if the specified string is a valid IP subnet mask.
//
//	Arguments:
//		pszMask	[IN] Subnet mask string to validate.
//
//	Return Value:
//		TRUE		String is a valid subnet mask.
//		FALSE		String is not a valid subnet mask.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsValidSubnetMask( IN LPCWSTR pszMask )
{
	ULONG	nMask;
	DWORD	nStatus;
	BOOL	bIsValid = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszMask, &nMask );
	if ( nStatus == ERROR_SUCCESS )
	{
		bIsValid = ClRtlIsValidTcpipSubnetMask( nMask );
	} // if:  converted mask successfully

	return bIsValid;

}  //*** BIsValidSubnetMask()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsValidIpAddressAndSubnetMask
//
//	Routine Description:
//		Determine if the specified IP address and subnet mask strings are
//		valid when used together.
//
//	Arguments:
//		pszAddress	[IN] Address string to validate.
//		pszMask	[IN] Subnet mask string to validate.
//
//	Return Value:
//		TRUE		Address and mask are valid together.
//		FALSE		Address and mask are not valid when used together.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsValidIpAddressAndSubnetMask( IN LPCWSTR pszAddress, IN LPCWSTR pszMask )
{
	ULONG	nAddress;
	ULONG	nMask;
	DWORD	nStatus;
	BOOL	bIsValid = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
	if ( nStatus == ERROR_SUCCESS )
	{
		nStatus = ClRtlTcpipStringToAddress( pszMask, &nMask );
		if ( nStatus == ERROR_SUCCESS )
		{
			bIsValid = ClRtlIsValidTcpipAddressAndSubnetMask( nAddress, nMask );
		} // if:  converted mask successfully
	} // if:  converted address successfully

	return bIsValid;

}  //*** BIsValidIpAddressAndSubnetMask()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	BIsIpAddressInUse
//
//	Routine Description:
//		Determine if the specified IP address is already in use (exists
//		on the network).
//
//	Arguments:
//		pszAddress	[IN] Address string to check.
//
//	Return Value:
//		TRUE		Address is already in use.
//		FALSE		Address is available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BIsIpAddressInUse( IN LPCWSTR pszAddress )
{
	ULONG	nAddress;
	DWORD	nStatus;
	BOOL	bIsInUse = FALSE;

	nStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
	if ( nStatus == ERROR_SUCCESS )
	{
		bIsInUse = ClRtlIsDuplicateTcpipAddress( nAddress );
	} // if:  converted address successfully

	return bIsInUse;

} //*** BIsIpAddressInUse()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbaseapp.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      AtlBaseApp.inl
//
//  Description:
//      Inline definitions of the CBaseApp class.
//
//  Author:
//      Galen Barbee (galenb)   May 21, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __ATLBASEAPP_INL_
#define __ATLBASEAPP_INL_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <AtlBaseApp.h>

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseApp::PszHelpFilePath
//
//  Description:
//      Return the path to the help file.  Generate if necessary.
//
//  Arguments:
//      None.
//
//  Return Values:
//      String containing the help file path.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline LPCTSTR CBaseApp::PszHelpFilePath( void )
{
    //
    // If no help file path has been specified yet, generate
    // it from the module path name.
    //
    if ( m_pszHelpFilePath == NULL )
    {
        TCHAR szPath[_MAX_PATH];
        TCHAR szDrive[_MAX_PATH]; // not _MAX_DRIVE so we can support larger device names
        TCHAR szDir[_MAX_DIR];

        //
        // Get the path to this module.  Split out the drive and
        // directory and set the help file path to that combined
        // with the help file name.
        //
        if ( ::GetModuleFileName( GetModuleInstance(), szPath, _MAX_PATH ) > 0 )
        {
            size_t  cch;
            HRESULT hr;

            szPath[ RTL_NUMBER_OF( szPath ) - 1 ] = _T('\0');

            _tsplitpath( szPath, szDrive, szDir, NULL, NULL );
            _tmakepath( szPath, szDrive, szDir, PszHelpFileName(), NULL );

            cch = _tcslen( szPath ) + 1;
            m_pszHelpFilePath = new TCHAR[ cch ];
            ATLASSERT( m_pszHelpFilePath != NULL );
            if ( m_pszHelpFilePath != NULL )
            {
                hr = StringCchCopyN( m_pszHelpFilePath, cch, szPath, RTL_NUMBER_OF( szPath ) );
                ATLASSERT( SUCCEEDED( hr ) );
            } // if:  buffer allocated successfully
        } // if:  module path obtained successfully
    } // if:  no help file path specified yet

    return m_pszHelpFilePath;

} //*** CBaseApp::PszHelpFilePath

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEAPP_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseDlg.h
//
//	Desription:
//		Definition of the CBaseDlg class.
//
//	Author:
//		David Potter (davidp)	February 9, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEDLG_H_
#define __ATLBASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T > class CBaseDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for DBG_xxx routines
#endif

#ifndef __ATLPOPUPHELP_H_
#include "AtlPopupHelp.h"	// for COnlineHelp
#endif

#ifndef __CTRLUTIL_H
#include "DlgItemUtils.h"	// for CDlgItemUtils
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseDlg
//
//	Description:
//		Base dialog class.  Provides the following features:
//		-- Popup help.
//		-- Dialog item utilities.
//		-- Debugging support.
//
//	Inheritance:
//		CBaseDlg< T >
//		CDialogImpl< T >, CPopupHelp< T >, CDlgItemUtils
//
//--
/////////////////////////////////////////////////////////////////////////////

template< class T >
class CBaseDlg
	: public CDialogImpl< T >
	, public CPopupHelp< T >
	, public CDlgItemUtils
{
	typedef CBaseDlg< T > thisClass;
	typedef CDialogImpl< T > baseClass;

public:
	//
	// Construction
	//

	// Constructor taking a string pointer for the title
	CBaseDlg(
		IN OUT LPCTSTR	lpszTitle = NULL
		)
	{
		if ( lpszTitle != NULL )
		{
			m_strTitle = lpszTitle;
		} // if:  title specified

	} //*** CBaseDlg( lpszTitle )

	// Constructor taking a resource ID for the title
	CBaseDlg( IN UINT nIDTitle )
	{
		m_strTitle.LoadString( nIDTitle );

	} //*** CBaseDlg( nIDTitle )

	// Initialize the page
	virtual BOOL BInit( void )
	{
		return TRUE;

	} //*** BInit()

protected:
	//
	// CBasePage helper methods.
	//

	// Attach a control to a dialog item.
	void AttachControl( CWindow & rwndControl, UINT idc )
	{
		HWND hwndControl = GetDlgItem( idc );
		ATLASSERT( hwndControl != NULL );
		rwndControl.Attach( hwndControl );

	} //*** AttachControl()

public:
	//
	// CBaseDlg public methods to override.
	//

	// Update data on or from the page
	virtual BOOL UpdateData( BOOL bSaveAndValidate )
	{
		return TRUE;

	} //*** UpdateData()

public:
	//
	// Message handler functions.
	//

	BEGIN_MSG_MAP( CBaseDlg< T > )
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
#if DBG
#ifdef _DBG_MSG
		MESSAGE_RANGE_HANDLER( 0, 0xffffffff, OnMsg )
#endif // _DBG_MSG
#ifdef _DBG_MSG_NOTIFY
		MESSAGE_HANDLER( WM_NOTIFY, OnNotify )
#endif // _DBG_MSG_NOTIFY
#ifdef _DBG_MSG_COMMAND
		MESSAGE_HANDLER( WM_COMMAND, OnCommand )
#endif // _DBG_MSG_COMMAND
#endif // DBG
		CHAIN_MSG_MAP( CPopupHelp< T > )
	END_MSG_MAP()

	// Handler for the WM_INITDIALOG message
	LRESULT OnInitDialog(
				UINT	uMsg,
				WPARAM	wParam,
				LPARAM	lParam,
				BOOL &	bHandled
				)
	{
		T * pT = static_cast< T * >( this );
		return pT->OnInitDialog();

	} //*** OnInitDialog()

	// Handler for the WM_INITDIALOG message
	LRESULT OnInitDialog( void )
	{
		return TRUE;

	} //*** OnInitDialog()

#if DBG && defined( _DBG_MSG )
	// Handler for any message
	LRESULT OnMsg( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnMsg( uMsg, wParam, lParam, bHandled, T::s_pszClassName );

	} //*** OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
	// Handler for the WM_NOTIFY message
	LRESULT OnNotify( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnNotify( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
	// Handler for the WM_COMMAND message
	LRESULT OnCommand( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnCommand( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )

// Implementation
protected:
	CString m_strTitle;		// Used to support resource IDs for the title.

	const CString & StrTitle( void ) const	{ return m_strTitle; }

}; //*** class CBaseDlg

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbaseapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      AtlBaseApp.h
//
//  Description:
//      Definition of the CBaseApp class.
//
//  Author:
//      Galen Barbee (galenb)   May 21, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __ATLBASEAPP_H_
#define __ATLBASEAPP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseApp
//
//  Description:
//      Base application class.  The following functionality is provided:
//      -- Help file support.
//
//  Inheritance:
//      CBaseApp
//      CComModule
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBaseApp : public CComModule
{
public:
    //
    // Construction.
    //

    // Default constructor
    CBaseApp( void )
        : m_pszHelpFilePath( NULL )
    {
    } //*** CBaseApp()

    // Destructor
    ~CBaseApp( void )
    {
        delete m_pszHelpFilePath;

    } //*** ~CBaseApp()

    // Return the path to the help file, generate if necessary
    virtual LPCTSTR PszHelpFilePath( void );

    // Return the name of the help file
    virtual LPCTSTR PszHelpFileName( void )
    {
        //
        // Override this method or no help file name will
        // be specified for this application.
        //
        return NULL;

    } //*** PszHelpFileName()

private:
    LPTSTR  m_pszHelpFilePath;

}; //*** class CBaseApp

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBasePage.h
//
//	Description:
//		Definition of the CBasePageWindow and CBasePageImpl classes.
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPAGE_H_
#define __ATLBASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePageWindow;
template < class T, class TBase > class CBasePageImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseSheetWindow;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for DBG_xxx routines
#endif

#ifndef __DLGITEMUTILS_H_
#include "DlgItemUtils.h"	// for CDlgItemUtils
#endif

#ifndef __ATLBASESHEET_H_
#include "AtlBaseSheet.h"	// for CBaseSheetWindow for BReadOnly()
#endif

#ifndef __ATLPOPUPHELP_H_
#include "AtlPopupHelp.h"	// for COnlineHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePageWindow
//
//	Description:
//		Base property sheet page window for all kinds of property sheets.
//
//	Inheritance:
//		CBasePageWindow
//		CPropertyPageWindow, CDlgItemUtils
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePageWindow
	: public CPropertyPageWindow
	, public CDlgItemUtils
{
	typedef CPropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_bReadOnly( FALSE )
		, m_psht( NULL )
		, m_ppsp( NULL )
	{
	} //*** CBasePageWindow()

	// Destructor
	virtual ~CBasePageWindow( void )
	{
		//
		// This must be virtual so that a pointer to an object
		// of type CBasePropertyPageWindow can be held and then later
		// deleted.  That way the derived class's destructor will
		// be called.
		//

	} //*** ~CBasePageWindow()

	// Initialize the page
	virtual BOOL BInit( IN CBaseSheetWindow * psht )
	{
		ATLASSERT( psht != NULL );
		ATLASSERT( m_psht == NULL );
		m_psht = psht;
		return TRUE;

	} //*** BInit()

protected:
	//
	// CBasePageWindow helper methods.
	//

	// Attach a control to a dialog item.
	void AttachControl( CWindow & rwndControl, UINT idc )
	{
		HWND hwndControl = GetDlgItem( idc );
		ATLASSERT( hwndControl != NULL );
		rwndControl.Attach( hwndControl );

	} //*** AttachControl()

public:
	//
	// CBasePageWindow public methods to override.
	//

	// Update data on or from the page
	virtual BOOL UpdateData( IN BOOL bSaveAndValidate )
	{
		return TRUE;

	} //*** UpdateData()

	// Apply changes made on this page to the sheet
	virtual BOOL BApplyChanges( void )
	{
		return TRUE;

	} //*** BApplyChanges()

public:
	//
	// Message handler functions.
	//

	// Handler for WM_INITDIALOG
	BOOL OnInitDialog( void )
	{
		return TRUE;

	} //*** OnInitDialog()

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void )
	{
		return UpdateData( FALSE /*bSaveAndValidate*/ );

	} //*** OnSetActive()

	// Handler for PSN_APPLY
	BOOL OnApply( void )
	{
		// Update the data in the class from the page.
		if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
		{
			return FALSE;
		} // if:  error updating data

		// Save the data in the sheet.
		if ( ! BApplyChanges() )
		{
			return FALSE;
		} // if:  error applying changes

		return TRUE;

	} //*** OnApply()

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;

	} //*** OnWizardNext()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		return TRUE;

	} //*** OnWizardFinish()

	// Handler for PSN_RESET
	void OnReset( void )
	{
	} //*** OnReset()

// Implementation
protected:
	PROPSHEETPAGE * 	m_ppsp; 		// Pointer to property sheet header in impl class.
	CBaseSheetWindow *	m_psht; 		// Pointer to sheet this page belongs to.
	BOOL				m_bReadOnly;	// Set if the page cannot be changed.
	CString 			m_strTitle; 	// Used to support resource IDs for the title.

	CBaseSheetWindow *	Psht( void ) const		{ return m_psht; }
	BOOL				BReadOnly( void ) const { return m_bReadOnly || Psht()->BReadOnly(); }
	const CString & 	StrTitle( void ) const	{ return m_strTitle; }

public:
	// Return a pointer to the property page header
	PROPSHEETPAGE * Ppsp( void ) const
	{
		ATLASSERT( m_ppsp != NULL );
		return m_ppsp;

	} //*** Ppsp()

}; //*** class CBasePageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePageImpl
//
//	Purpose:
//		Base property sheet page implementation for all kinds of property
//		sheets.
//
//	Inheritance:
//		CBasePageImpl< T, TBase >
//		CPropertyPageImpl< T, TBase >, CPopupHelp< T >
//		<TBase>
//		...
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CBasePageWindow >
class CBasePageImpl
	: public CPropertyPageImpl< T, TBase >
	, public CPopupHelp< T >
{
	typedef CBasePageImpl< T, TBase > thisClass;
	typedef CPropertyPageImpl< T, TBase > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePageImpl(
		LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CBasePageImpl()

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
#if DBG
#ifdef _DBG_MSG
		MESSAGE_RANGE_HANDLER( 0, 0xffffffff, OnMsg )
#endif // _DBG_MSG
#ifdef _DBG_MSG_NOTIFY
		MESSAGE_HANDLER( WM_NOTIFY, OnNotify )
#endif // _DBG_MSG_NOTIFY
#ifdef _DBG_MSG_COMMAND
		MESSAGE_HANDLER( WM_COMMAND, OnCommand )
#endif // _DBG_MSG_COMMAND
#endif // DBG
		MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
		CHAIN_MSG_MAP( CPopupHelp< T > )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

#if DBG && defined( _DBG_MSG )
	// Handler for any message
	LRESULT OnMsg( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnMsg( uMsg, wParam, lParam, bHandled, T::s_pszClassName );

	} //*** OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
	// Handler for the WM_NOTIFY message
	LRESULT OnNotify( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnNotify( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
	// Handler for the WM_COMMAND message
	LRESULT OnCommand( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnCommand( uMsg, wParam, lParam, bHandled, T::s_pszClassName, T::s_rgmapCtrlNames );

	} //*** OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )

	//
	// Message handler functions.
	//

	// Handler for WM_INITDIALOG
	LRESULT OnInitDialog(
				UINT	uMsg,
				WPARAM	wParam,
				LPARAM	lParam,
				BOOL &	bHandled
				)
	{
		T * pT = static_cast< T * >( this );
		return pT->OnInitDialog();

	} //*** OnInitDialog()

	// Handler for WM_INITDIALOG
	BOOL OnInitDialog( void )
	{
		return baseClass::OnInitDialog();

	} //*** OnInitDialog()

	//
	// These notification handlers are needed because CPropertyPageImpl
	// implements them itself, which prevents the call from making it
	// to the window class.
	//

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnSetActive();

	} //*** OnSetActive()

	// Handler for PSN_APPLY
	BOOL OnApply( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnApply();

	} //*** OnApply()

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnWizardBack();

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnWizardNext();

	} //*** OnWizardNext()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		return TBase::OnWizardFinish();

	} //*** OnWizardFinish()

	// Handler for PSN_RESET
	void OnReset( void )
	{
		// Call the TBase method to avoid the CPropertySheetImpl empty method
		TBase::OnReset();

	} //*** OnReset()

// Implementation
protected:

public:

}; //*** class CBasePageImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasepropsheet.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      AtlBasePropSheet.cpp
//
//  Abstract:
//      Implementation of the CBasePropertySheetWindow class.
//
//  Author:
//      David Potter (davidp)   February 26, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlBasePropSheet.h"
#include "AtlBasePropPage.h"
#include "AtlExtDll.h"
#include "StlUtils.h"
#include "ExcOper.h"
#include "AdmCommonRes.h"

/////////////////////////////////////////////////////////////////////////////
// class CBasePropertySheetWindow
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::~CBasePropertySheetWindow
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertySheetWindow::~CBasePropertySheetWindow( void )
{
    //
    // Delete pages from the page list.
    //
    if ( m_plppPages != NULL )
    {
        DeleteAllPtrListItems( m_plppPages );
        delete m_plppPages;
    } // if:  page array has been allocated

} //*** CBasePropertySheetWindow::~CBasePropertySheetWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::BInit
//
//  Routine Description:
//      Initialize the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Property sheet initialized successfully.
//      FALSE   Error initializing the property sheet.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheetWindow::BInit( void )
{
    ATLASSERT( PlppPages()->size() > 0 );
    ATLASSERT( m_hWnd == NULL );

    BOOL                        bSuccess = TRUE;
    CPropertyPageList::iterator itCurrent = PlppPages()->begin();
    CPropertyPageList::iterator itLast = PlppPages()->end();
    CStaticPropertyPageWindow * pspp;

    //
    // Add static pages.
    //
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        //
        // If this is a static page, add it to the list.
        //
        pspp = dynamic_cast< CStaticPropertyPageWindow * >( *itCurrent );
        if ( pspp != NULL )
        {
            //
            // Initialize the page.
            //
            bSuccess = pspp->BInit( this );
            if ( ! bSuccess )
            {
                break;
            } // if:  error initializing the page

            //
            // Add the page.
            //
            bSuccess = AddPage( pspp->Ppsp() );
            if ( ! bSuccess )
            {
                CNTException nte(
                    GetLastError(),
                    ADMC_IDS_ADD_PAGE_TO_PROP_SHEET_ERROR,
                    NULL,
                    NULL,
                    FALSE
                    );
                nte.ReportError();
                break;
            } // if:  error adding the page
        } // if:  static page
    }  // for:  each page

    return bSuccess;

} //*** CBasePropertySheetWindow::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::BAddPage
//
//  Routine Description:
//      Add a page to the page list.
//
//  Arguments:
//      ppp     [IN] Property page to add.
//
//  Return Value:
//      TRUE    Page added successfully.
//      FALSE   Error adding page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheetWindow::BAddPage( IN CBasePropertyPageWindow * ppp )
{
    ATLASSERT( ppp != NULL );

    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate the page array if it doesn't exist yet.
        //
        if ( m_plppPages == NULL )
        {
            m_plppPages = new CPropertyPageList;
            ATLASSERT( m_plppPages != NULL );
            if ( m_plppPages == NULL )
            {
                CNTException nte(
                    GetLastError(),
                    ADMC_IDS_ADD_FIRST_PAGE_TO_PROP_SHEET_ERROR,
                    NULL,
                    NULL,
                    FALSE
                    );
                nte.ReportError();
                break;
            } // if:  error allocating page list
        } // if:  no page array yet

        //
        // Insert the page at the end of the list.
        //
        PlppPages()->insert( PlppPages()->end(), ppp );

        bSuccess = TRUE;
    } while ( 0 );

    return bSuccess;

} //*** CBasePropertySheetWindow::BAddPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::OnSheetInitialized
//
//  Routine Description:
//      Handler for PSCB_INITIALIZED.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::OnSheetInitialized( void )
{
    //
    // Add dynamic pages, including extension pages.
    //
    {
        //
        // Get pointers to beginning and end of list.
        //
        CPropertyPageList::iterator itCurrent = PlppPages()->begin();
        CPropertyPageList::iterator itLast = PlppPages()->end();

        //
        // Loop through the list and add each dynamic page.
        //
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicPropertyPageWindow * pdpp = dynamic_cast< CDynamicPropertyPageWindow * >( *itCurrent );
            if ( pdpp != NULL )
            {
                if ( pdpp->Hpage() != NULL )
                {
                    AddPage( pdpp->Hpage() );
                    pdpp->SetPageAdded( TRUE );
                } // if:  page has already been created
            } // if:  dynamic page found
        } // for:  each item in the list

    } // Add dynamic pages, including extension pages

    //
    // Call the base class method.
    //
    CBaseSheetWindow::OnSheetInitialized();

} //*** CBasePropertySheetWindow::OnSheetInitialized()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      hfont       [IN] Font to use for the extension pages.
//      hicon       [IN] Icon to use for the extension pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::AddExtensionPages(
    IN HFONT    hfont,
    IN HICON    hicon
    )
{
    ATLASSERT( PcoObjectToExtend() != NULL );

    //
    // Add extension pages if there any extensions.
    //
    if (   (PcoObjectToExtend()->PlstrAdminExtensions() != NULL)
        && (PcoObjectToExtend()->PlstrAdminExtensions()->size() > 0) )
    {
        //
        // Get the currently selected page so we can reset it when we're done.
        //
        CTabCtrl tabc( GetTabControl() );
        int nCurPage = tabc.GetCurSel();

        //
        // Prepare to add extension pages.
        //
        CDynamicPropertyPageList ldpp;
        PrepareToAddExtensionPages( ldpp );

        //
        // If no extensions object has been created yet, create it now.
        //
        if ( Pext() == NULL )
        {
            m_pext = new CCluAdmExtensions;
            ATLASSERT( m_pext != NULL );
        } // if:  no extensions list yet

        //
        // Enclose the loading of the extension in a try/catch block so
        // that the loading of the extension won't prevent all pages
        // from being displayed.
        //
        try
        {
            Pext()->CreatePropertySheetPages(
                    this,
                    *PcoObjectToExtend()->PlstrAdminExtensions(),
                    PcoObjectToExtend(),
                    hfont,
                    hicon
                    );
        } // try
        catch (...)
        {
        } // catch:  anything

        //
        // Complete the process of adding extension pages.
        //
        CompleteAddingExtensionPages( ldpp );

        //
        // Restore the current selection.
        // This has to be done because sometimes the above process causes
        // the current page to be set to the last page added, which prevents
        // the next page from being displayed.
        //
        SetActivePage( nCurPage );
    } // if:  object has extensions
    else
    {
        //
        // Remove extension pages.
        //
        RemoveAllExtensionPages();
    } // else:  object doesn't have extensions

}  //*** CBasePropertySheetWindow::AddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::PrepareToAddExtensionPages
//
//  Routine Description:
//      Prepare to add extension pages by deleting existing extension
//      pages and removing dynamic pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::PrepareToAddExtensionPages(
    CDynamicPropertyPageList & rldpp
    )
{
    //
    // Delete all extension pages.
    //
    RemoveAllExtensionPages();

    //
    // Move all dynamic pages to the temporary list.
    //
    ATLASSERT( rldpp.size() == 0);
    MovePtrListItems< CBasePropertyPageWindow *, CDynamicPropertyPageWindow * >( PlppPages(), &rldpp );

    //
    // Remove all pages in the temporary list from the property sheet.
    // The page must have already been created because we don't have
    // any access to the PROPSHEETPAGE structure to create it
    // during the completion phase.
    //
    {
        CDynamicPropertyPageList::iterator itCurrent;
        CDynamicPropertyPageList::iterator itLast;

        itCurrent = rldpp.begin();
        itLast = rldpp.end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicPropertyPageWindow * pdpp = *itCurrent;
            ATLASSERT( pdpp != NULL );
            if ( pdpp->Hpage() != NULL )
            {
                RemovePage( pdpp->Hpage() );
                pdpp->SetPageAdded( FALSE );
            } // if:  page already created
        } // for:  each page in the list
    } // Remove dynamic pages

} //*** CBasePropertySheetWindow::PrepareToAddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::HrAddExtensionPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      ppage       [IN OUT] Page to be added.
//
//  Return Value:
//      S_OK        Page added successfully.
//      S_FALSE     Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertySheetWindow::HrAddExtensionPage( IN CBasePageWindow * ppage )
{
    ATLASSERT( ppage != NULL );

    HRESULT hr = S_OK;

    CExtensionPropertyPageWindow * pepp = dynamic_cast< CExtensionPropertyPageWindow * >( ppage );
    ATLASSERT( pepp != NULL );

    if (   (ppage == NULL)
        || (pepp == NULL ) )
    {
        return S_FALSE;
    } // if:  invalid arguments

    //
    // Add the page to the sheet.
    //
    if ( m_hWnd != NULL )
    {
        AddPage( pepp->Hpage() );
        pepp->SetPageAdded( TRUE );
    } // if:  sheet is being displayed

    //
    // Add the page to the end of the list.
    //
    PlppPages()->insert( PlppPages()->end(), reinterpret_cast< CBasePropertyPageWindow * >( ppage ) );

    return hr;

}  //*** CBasePropertySheetWindow::HrAddExtensionPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::CompleteAddingExtensionPages
//
//  Routine Description:
//      Complete the process of adding extension pages to the sheet by
//      re-adding dynamic pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::CompleteAddingExtensionPages(
    CDynamicPropertyPageList & rldpp
    )
{
    DWORD                           sc;
    CDynamicPropertyPageWindow *    pdpp;

    //
    // Move all pages from the temporary list to the real list and
    // add them to the end of the sheet.
    //
    CDynamicPropertyPageList::iterator itCurrent = rldpp.begin();
    CDynamicPropertyPageList::iterator itLast = rldpp.end();
    while ( itCurrent != itLast )
    {
        pdpp = *itCurrent;
        ATLASSERT( pdpp != NULL );

        //
        // Create the page.
        //
        sc = pdpp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, ADMC_IDS_CREATE_EXT_PAGE_ERROR, NULL, NULL, FALSE );
            delete pdpp;
            itCurrent = rldpp.erase( itCurrent );
            continue;
        } // if:  error creating the page

        //
        // Add the page to the sheet.
        //
        ATLASSERT( pdpp->Hpage() != NULL );
        AddPage( pdpp->Hpage() );
        pdpp->SetPageAdded( TRUE );

        //
        // Move the page to real list.
        //
        PlppPages()->insert( PlppPages()->end(), pdpp );
        itCurrent = rldpp.erase( itCurrent );
    } // while:  not at last page

} //*** CBasePropertySheetWindow::CompleteAddingExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheetWindow::RemoveAllExtensionPages
//
//  Routine Description:
//      Remove all extension pages from the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheetWindow::RemoveAllExtensionPages( void )
{
    //
    // Remove the extension pages.
    //
    CExtensionPropertyPageList lepp;
    MovePtrListItems< CBasePropertyPageWindow *, CExtensionPropertyPageWindow * >( PlppPages(), &lepp );
    CExtensionPropertyPageList::iterator itCurrent = lepp.begin();
    CExtensionPropertyPageList::iterator itLast = lepp.end();
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        CExtensionPropertyPageWindow * pepp = *itCurrent;
        ATLASSERT( pepp != NULL );
        if ( pepp->Hpage() != NULL )
        {
            RemovePage( pepp->Hpage() );
            pepp->SetPageAdded( FALSE );
        } // if:  page already created
    } // for:  each page in the list
    DeleteAllPtrListItems( &lepp );

} //*** CBasePropertySheetWindow::RemoveAllExtensionPages()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbaseproppage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBasePropPage.cpp
//
//	Description:
//		Definition of the CBasePropertyPageWindow and CBasePropertyPageImpl
//		classes.
//
//	Implementation File:
//		None.
//
//	Author:
//		David Potter (davidp)	February 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPROPPAGE_H_
#define __ATLBASEPROPPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPageWindow;
class CStaticPropertyPageWindow;
class CDynamicPropertyPageWindow;
class CExtensionPropertyPageWindow;
template < class T, class TWin > class CBasePropertyPageImpl;
template < class T > class CStaticPropertyPageImpl;
template < class T > class CDynamicPropertyPageImpl;
template < class T > class CExtensionPropertyPageImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheetWindow;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPAGE_H_
#include "AtlBasePage.h"	// for CBasePageWindow, CBasePageImpl
#endif

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for debugging definitions
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef std::list< CBasePropertyPageWindow * > CPropertyPageList;
typedef std::list< CStaticPropertyPageWindow * > CStaticPropertyPageList;
typedef std::list< CDynamicPropertyPageWindow * > CDynamicPropertyPageList;
typedef std::list< CExtensionPropertyPageWindow * > CExtensionPropertyPageList;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertyPageWindow
//
//	Description:
//		Base property sheet page window for standard property sheets.
//
//	Inheritance:
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPageWindow : public CBasePageWindow
{
	typedef CBasePageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CBasePropertyPageWindow()

public:
	//
	// Message handler functions.
	//

	// Handler for PSN_KILLACTIVE
	BOOL OnKillActive( void )
	{
		return UpdateData( TRUE /*bSaveAndValidate*/ );

	} //*** OnKillActive()

// Implementation
protected:
	// Return pointer to the base sheet object
	CBasePropertySheetWindow * Pbsht( void ) const
	{
		return (CBasePropertySheetWindow *) Psht();

	} //*** Pbsht()

public:

}; //*** class CBasePropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticPropertyPageWindow
//
//	Description:
//		Base property sheet page window for pages added to a standard
//		property sheet before the call to PropertySheet().  This page cannot
//		be removed from the sheet.
//
//	Inheritance:
//		CStaticPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CStaticPropertyPageWindow : public CBasePropertyPageWindow
{
	typedef CBasePropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CStaticPropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CStaticPropertyPageWindow()

}; //*** class CStaticPropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicPropertyPageWindow
//
//	Description:
//		Base property sheet page window for pages added to a standard
//		property sheet after the call to PropertySheet().  This page may be
//		removed from the sheet.
//
//	Inheritance:
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CDynamicPropertyPageWindow : public CBasePropertyPageWindow
{
	typedef CBasePropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CDynamicPropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_hpage( NULL )
		, m_bPageAddedToSheet( FALSE )
	{
	} //*** CDynamicPropertyPageWindow()

	// Destructor
	~CDynamicPropertyPageWindow( void )
	{
		//
		// Destroy the page if it hasn't been added to the sheet yet.
		// If it has been added to the sheet, the sheet will destroy it.
		//
		if (   (m_hpage != NULL)
			&& ! m_bPageAddedToSheet )
		{
			DestroyPropertySheetPage( m_hpage );
			m_hpage = NULL;
		} // if:  page not deleted yet

	} //*** ~CDynamicPropertyPageWindow()

	// Create the page
	virtual DWORD ScCreatePage( void ) = 0;

protected:
	HPROPSHEETPAGE	m_hpage;
	BOOL			m_bPageAddedToSheet;

public:
	// Property page handle
	HPROPSHEETPAGE Hpage( void ) const { return m_hpage; }

	// Set whether the page has been added to the sheet or not
	void SetPageAdded( IN BOOL bAdded = TRUE )
	{
		m_bPageAddedToSheet = bAdded;
		if ( ! bAdded )
		{
			m_hpage = NULL;
		} // if:  removing page

	} //*** SetPageAdded()

}; //*** class CDynamicPropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizardPageWindow
//
//	Description:
//		Base property sheet page window for pages added to a standard
//		property sheet after the call to PropertySheet() identified as an
//		extension to the list of standard pages (whether static or dynamic).
//		This page may be removed from the sheet.
//
//	Inheritance:
//		CExtensionPropertyPageWindow
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CExtensionPropertyPageWindow : public CDynamicPropertyPageWindow
{
	typedef CDynamicPropertyPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CExtensionPropertyPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CExtensionPropertyPageWindow()

}; //*** class CExtensionPropertyPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for standard property sheets.
//
//	Inheritance:
//		CBasePropertyPageImpl< T, TWin >
//		CBasePageImpl< T, TWin >
//		CPropertyPageImpl< T, TWin >
//		<TWin>
//		...
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TWin = CBasePropertyPageWindow >
class CBasePropertyPageImpl : public CBasePageImpl< T, TWin >
{
	typedef CBasePropertyPageImpl< T, TWin > thisClass;
	typedef CBasePageImpl< T, TWin > baseClass;

public:

	//
	// Construction
	//

	// Standard constructor
	CBasePropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CBasePropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CBasePropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CBasePropertyPageImpl( nIDCaption )

	// Initialize the page
	virtual BOOL BInit( CBaseSheetWindow * psht )
	{
		if ( ! baseClass::BInit( psht ) )
			return FALSE;
		return TRUE;

	} //*** BInit()

public:
	//
	// Message handler functions.
	//

	// Handler for PSN_KILLACTIVE
	BOOL OnKillActive( void )
	{
		// Call the TWin method
		return TWin::OnKillActive();

	} //*** OnKillActive()

// Implementation
protected:

public:

}; //*** class CBasePropertyPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticPropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for pages added to a standard
//		property sheet before the call to PropertySheet().  This page cannot
//		be removed from the sheet.
//
//	Inheritance:
//		CStaticPropertyPageImpl< T >
//		CBasePropertyPageImpl< T, CStaticPropertyPageWindow >
//		CBasePageImpl< T, CStaticPropertyPageWindow >
//		CPropertyPageImpl< T, CStaticPropertyPageWindow >
//		CStaticPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CStaticPropertyPageImpl : public CBasePropertyPageImpl< T, CStaticPropertyPageWindow >
{
	typedef CStaticPropertyPageImpl< T > thisClass;
	typedef CBasePropertyPageImpl< T, CStaticPropertyPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CStaticPropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CStaticPropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CStaticPropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CStaticPropertyPageImpl( nIDTitle )

}; //*** class CStaticPropertyPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicPropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for pages added to a standard
//		property sheet after the call to PropertySheet() identified as an
//		Extension to the list of standard pages (whether static or dynamic).
//		This page may be removed from the sheet.
//
//	Inheritance:
//		CDynamicPropertyPageImpl< T >
//		CBasePropertyPageImpl< T, CDynamicPropertyPageWindow >
//		CBasePageImpl< T, CDynamicPropertyPageWindow >
//		CPropertyPageImpl< T, CDynamicPropertyPageWindow >
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CDynamicPropertyPageImpl : public CBasePropertyPageImpl< T, CDynamicPropertyPageWindow >
{
	typedef CDynamicPropertyPageImpl< T > thisClass;
	typedef CBasePropertyPageImpl< T, CDynamicPropertyPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CDynamicPropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CDynamicPropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CDynamicPropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CDynamicPropertyPageImpl( nIDTitle )

	// Create the page
	DWORD ScCreatePage( void )
	{
		ATLASSERT( m_hpage == NULL );

		m_hpage = CreatePropertySheetPage( &m_psp );
		if ( m_hpage == NULL )
		{
			return GetLastError();
		} // if:  error creating the page

		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CDynamicPropertyPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionPropertyPageImpl
//
//	Description:
//		Base property sheet page implementation for pages added to a standard
//		property sheet after the call to PropertySheet() identified as an
//		extension to the list of standard pages (whether static or dynamic).
//		This page may be removed from the sheet.
//
//	Inheritance:
//		CExtensionPropertyPageImpl< T >
//		CBasePropertyPageImpl< T, CExtensionPropertyPageWindow >
//		CBasePageImpl< T, CExtensionPropertyPageWindow >
//		CPropertyPageImpl< T, CExtensionPropertyPageWindow >
//		CExtensionPropertyPageWindow
//		CDynamicPropertyPageWindow
//		CBasePropertyPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CExtensionPropertyPageImpl : public CBasePropertyPageImpl< T, CExtensionPropertyPageWindow >
{
	typedef CExtensionPropertyPageImpl< T > thisClass;
	typedef CBasePropertyPageImpl< T, CExtensionPropertyPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CExtensionPropertyPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CExtensionPropertyPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CExtensionPropertyPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CExtensionPropertyPageImpl( nIDTitle )

}; //*** class CExtensionPropertyPageImpl


/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEPROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasepropsheet.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBasePropSheet.h
//
//	Implementation File:
//		AtlBasePropSheet.cpp.
//
//	Description:
//		Definition of the CBasePropertySheetWindow and CBasePropertySheetImpl
//		classes.
//
//	Author:
//		David Potter (davidp)	February 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPROPSHEET_H_
#define __ATLBASEPROPSHEET_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters in the browser information

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheetWindow;
template < class T, class TBase > class CBasePropertySheetImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASESHEET_H_
#include "AtlBaseSheet.h"		// for CBaseSheetWindow;
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"	// for CPropertyPageList
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertySheetWindow
//
//	Description:
//		Base standard property sheet window.
//
//	Inheritance:
//		CBasePropertySheetWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheetWindow : public CBaseSheetWindow
{
	typedef CBaseSheetWindow baseClass;

	friend class CBasePropertyPageWindow;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePropertySheetWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_plppPages( NULL )
		, m_pcoObjectToExtend( NULL )
	{
	} //*** CBasePropertySheetWindow()

	// Destructor
	~CBasePropertySheetWindow( void );

	// Initialize the sheet
	BOOL BInit( void );

protected:
	CPropertyPageList *	m_plppPages;			// List of pages in the sheet.
	CClusterObject *	m_pcoObjectToExtend;	// Cluster object to extend.

public:
	// Access list of pages in the sheet
	CPropertyPageList * PlppPages( void )
	{
		ATLASSERT( m_plppPages != NULL );
		return m_plppPages;

	} //*** PlppPages()

	// Access the cluster object to extend
	CClusterObject * PcoObjectToExtend( void ) { return m_pcoObjectToExtend; }

	// Set the object to extend
	void SetObjectToExtend( IN CClusterObject * pco )
	{
		ATLASSERT( pco != NULL );
		m_pcoObjectToExtend = pco;

	} //*** SetObjectToExtend()

public:
	// Add a page (required to get to base class method)
	void AddPage( HPROPSHEETPAGE hPage )
	{
		baseClass::AddPage( hPage );

	} //*** AddPage( hPage )

	// Add a page (required to get to base class method)
	BOOL AddPage( LPCPROPSHEETPAGE pPage )
	{
		return baseClass::AddPage( pPage );

	} //*** AddPage( pPage )

	// Add a page to sheet
	BOOL BAddPage( IN CBasePropertyPageWindow * ppp );

public:
	//
	// Overrides of abstract methods.
	//

	// Add extension pages to the sheet
	virtual void AddExtensionPages( IN HFONT hfont, IN HICON hicon );

	// Add a page (called by extension)
	virtual HRESULT HrAddExtensionPage( IN CBasePageWindow * ppage );

public:
	//
	// Message handler functions.
	//

	// Handler for PSCB_INITIALIZED
	void OnSheetInitialized( void );

// Implementation
protected:
	// Prepare to add exension pages to the sheet
	void PrepareToAddExtensionPages( CDynamicPropertyPageList & rldpp );

	// Complete the process of adding extension pages
	void CompleteAddingExtensionPages( CDynamicPropertyPageList & rldpp );

	// Remove all extension pages from the property sheet
	void RemoveAllExtensionPages( void );

}; //*** class CBasePropertySheetWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBasePropertySheetImpl
//
//	Description:
//		Base standard property sheet implementation.
//
//	Inheritance:
//		CBasePropertySheetImpl< T, TBase >
//		CBaseSheetImpl< T, TBase >
//		CPropertySheetImpl< T, TBase >
//		<TBase>
//		...
//		CBasePropertySheetWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CBasePropertySheetWindow >
class CBasePropertySheetImpl : public CBaseSheetImpl< T, TBase >
{
	typedef CBasePropertySheetImpl< T, TBase > thisClass;
	typedef CBaseSheetImpl< T, TBase > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CBasePropertySheetImpl(
		IN LPCTSTR	lpszTitle = NULL,
		IN UINT		uStartPage = 0
		)
		: baseClass( lpszTitle, uStartPage )
	{
		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CBasePropertySheetWindow( lpszTitle )

	// Constructor taking a resource ID for the title
	CBasePropertySheetImpl(
		IN UINT nIDTitle,
		IN UINT uStartPage = 0
		)
		: baseClass( NULL, uStartPage )
	{
		m_strTitle.LoadString( nIDTitle );
		m_psh.pszCaption = m_strTitle;

		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CBasePropertySheetImpl( nIDTitle )

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( thisClass )
//		CHAIN_MSG_MAP( baseClass );
//	END_MSG_MAP()

	//
	// Message handler functions.
	//

// Implementation
protected:
	CString				m_strTitle;		// Used to support resource IDs for the title.

public:
	const CString &		StrTitle( void ) const					{ return m_strTitle; }
	void				SetTitle( LPCTSTR lpszText, UINT nStyle = 0 )
	{
		baseClass::SetTitle( lpszText, nStyle );
		m_strTitle = lpszText;

	} //*** SetTitle()

}; //*** class CBasePropertySheetImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEPROPSHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasesheet.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlBaseSheet.cpp
//
//  Abstract:
//      Implementation of the CBaseSheetWindow class.
//
//  Author:
//      David Potter (davidp)   December 4, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <StrSafe.h>
#include "AtlBaseSheet.h"
#include "AtlExtDll.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static LPCTSTR g_pszDefaultFontFaceName = _T("MS Shell Dlg");

/////////////////////////////////////////////////////////////////////////////
// class CBaseSheetWindow
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseSheetWindow::~CBaseSheetWindow
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheetWindow::~CBaseSheetWindow( void )
{
    //
    // Delete the extension information.
    //
    delete m_pext;

} //*** CBaseSheetWindow::~CBaseSheetWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CBaseSheetWindow::BCreateFont
//
//  Routine Description:
//      Create a font with only point size and type face name.
//
//  Arguments:
//      rfont       [OUT] Font to create.
//      nPoints     [IN] Point size.
//      pszFaceName [IN] Font face name.  Defaults to "MS Shell Dlg".
//      bBold       [IN] Font should be bold.
//      bItalic     [IN] Font should be italic.
//      bUnderline  [IN] Font should be underline.
//
//  Return Value:
//      TRUE        Font created successfully.
//      FALSE       Error creating font.  Call GetLastError() for more details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheetWindow::BCreateFont(
    OUT CFont & rfont,
    IN LONG     nPoints,
    IN LPCTSTR  pszFaceName,    // = _T("MS Shell Dlg")
    IN BOOL     bBold,          // = FALSE
    IN BOOL     bItalic,        // = FALSE
    IN BOOL     bUnderline      // = FALSE
    )
{
    HRESULT hr;
    HFONT   hfont = NULL;

    //
    // Get non-client metrics for basing the new font off of.
    //
    NONCLIENTMETRICS ncm = { 0 };
    ncm.cbSize = sizeof( ncm );
    SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );

    //
    // Copy the message font and set the face name and point size to what
    // was passed in.  The point size needs to be multiplied by 10 due to how
    // the CFont::CreatePointFontIndirect calculates the actual font height.
    //
    LOGFONT lfNewFont = ncm.lfMessageFont;
    if ( pszFaceName == NULL )
    {
        pszFaceName = g_pszDefaultFontFaceName;
    } // if:  no type face name specified
    ATLASSERT( _tcslen( pszFaceName ) + 1 < RTL_NUMBER_OF( lfNewFont.lfFaceName ) );
    hr = StringCchCopy( lfNewFont.lfFaceName, RTL_NUMBER_OF( lfNewFont.lfFaceName ), pszFaceName );
    if ( FAILED( hr ) )
    {
        SetLastError( hr );
        goto Cleanup;
    }
    lfNewFont.lfHeight = nPoints * 10;

    //
    // Set bold, italic, and underline values.
    //
    if ( bBold )
    {
        lfNewFont.lfWeight = FW_BOLD;
    } // if:  bold font requested
    if ( bItalic )
    {
        lfNewFont.lfItalic = TRUE;
    } // if:  italic font requested
    if ( bUnderline )
    {
        lfNewFont.lfUnderline = TRUE;
    } // if:  underlined font requested

    //
    // Create the font.
    //
    hfont = rfont.CreatePointFontIndirect( &lfNewFont );

Cleanup:

    return ( hfont != NULL );

}  //*** BCreateFont()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CBaseSheetWindow::BCreateFont
//
//  Routine Description:
//      Create a font with only point size and type face name.
//
//  Arguments:
//      rfont       [OUT] Font to create.
//      idsPoints   [IN] Resource ID for the font point size.
//      idsFaceName [IN] Resource ID for the font face name.  Defaults to "MS Shell Dlg".
//      bBold       [IN] Font should be bold.
//      bItalic     [IN] Font should be italic.
//      bUnderline  [IN] Font should be underline.
//
//  Return Value:
//      TRUE        Font created successfully.
//      FALSE       Error creating font.  Call GetLastError() for more details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheetWindow::BCreateFont(
    OUT CFont & rfont,
    IN UINT     idsPoints,
    IN UINT     idsFaceName,
    IN BOOL     bBold,          // = FALSE
    IN BOOL     bItalic,        // = FALSE
    IN BOOL     bUnderline      // = FALSE
    )
{
    BOOL    bSuccess;
    CString strFaceName;
    CString strPoints;
    LONG    nPoints;

    //
    // Load the face name.
    //
    bSuccess = strFaceName.LoadString( idsFaceName );
    ATLASSERT( bSuccess );
    if ( ! bSuccess )
    {
        strFaceName = g_pszDefaultFontFaceName;
    } // if:  no errors loading the string

    //
    // Load the point size.
    //
    bSuccess = strPoints.LoadString( idsPoints );
    ATLASSERT( bSuccess );
    if ( ! bSuccess)
    {
        nPoints = 12;
    } // if:  no errors loading the string
    else
    {
        nPoints = _tcstoul( strPoints, NULL, 10 );
    } // else:  error loading the string

    //
    // Create the font.
    //
    return BCreateFont( rfont, nPoints, strFaceName, bBold, bItalic, bUnderline );

}  //*** CBaseSheetWindow::BCreateFont()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasesheet.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBaseSheet.h
//
//	Implementation File:
//		AtlBaseSheet.cpp
//
//	Description:
//		Definition of the CBaseSheetWindow and CBaseSheetImpl classes.
//
//	Author:
//		David Potter (davidp)	December 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASESHEET_H_
#define __ATLBASESHEET_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseSheetWindow;
template < class T, class TBase > class CBaseSheetImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExtensions;
class CBasePageWindow;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for DBG_xxx routines
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseSheetWindow
//
//	Description:
//		Base property sheet window for all kinds of property sheets.
//
//	Inheritance:
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CBaseSheetWindow : public CPropertySheetWindow
{
	typedef CPropertySheetWindow baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CBaseSheetWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_bReadOnly( FALSE )
		, m_bNeedToLoadExtensions( TRUE )
		, m_ppsh( NULL )
		, m_pext( NULL )
	{
	} //*** CBaseSheetWindow()

	// Destructor
	virtual ~CBaseSheetWindow( void );
		//
		// This must be virtual so that a pointer to an object
		// of type CBaseSheetWindow can be held and then later
		// deleted.  That way the derived class's destructor will
		// be called.
		//

	// Initialize the sheet
	BOOL BInit( void )
	{
		return TRUE;
	}

public:
	//
	// CPropertySheetWindow methods.
	//

	// Add a page (allows other AddPage method to be virtual)
	void AddPage( HPROPSHEETPAGE hPage )
	{
		baseClass::AddPage( hPage );

	} //*** AddPage( hPage )

	// Add a page (virtual so this class can call derived class method)
	virtual BOOL AddPage( LPCPROPSHEETPAGE pPage )
	{
		return baseClass::AddPage( pPage );

	} //*** AddPage( pPage )

	// Add a page to the propsheetheader page list
	virtual BAddPageToSheetHeader( IN HPROPSHEETPAGE hPage ) = 0;

public:
	//
	// CBaseSheetWindow public methods.
	//

	// Create a font for use on the sheet
	static BOOL BCreateFont(
					OUT CFont &	rfont,
					IN LONG		nPoints,
					IN LPCTSTR	pszFaceName	= _T("MS Shell Dlg"),
					IN BOOL		bBold		= FALSE,
					IN BOOL		bItalic		= FALSE,
					IN BOOL		bUnderline	= FALSE
					);

	// Create a font for use on the sheet
	static BOOL BCreateFont(
					OUT CFont &	rfont,
					IN UINT		idsPoints,
					IN UINT		idsFaceName,
					IN BOOL		bBold		= FALSE,
					IN BOOL		bItalic		= FALSE,
					IN BOOL		bUnderline	= FALSE
					);

public:
	//
	// Abstract override methods.
	//

	// Add extension pages to the sheet
	virtual void AddExtensionPages( IN HFONT hfont, IN HICON hicon ) = 0;

	// Add a page (called by extension)
	virtual HRESULT HrAddExtensionPage( IN CBasePageWindow * ppage ) = 0;

public:
	//
	// Message handler functions.
	//

	// Handler for PSCB_INITIALIZED
	void OnSheetInitialized( void )
	{
	} //*** OnSheetInitialized()

// Implementation
protected:
	PROPSHEETHEADER *	m_ppsh;
	BOOL				m_bReadOnly;	// Set if the sheet cannot be changed.
	BOOL				m_bNeedToLoadExtensions;
	CCluAdmExtensions *	m_pext;

public:
	BOOL				BNeedToLoadExtensions( void ) const		{ return m_bNeedToLoadExtensions; }
	BOOL				BReadOnly( void ) const					{ return m_bReadOnly; }
	void				SetReadOnly( IN BOOL bReadOnly = TRUE )	{ m_bReadOnly = bReadOnly; }

	// Return a pointer to the property sheet header
	PROPSHEETHEADER * Ppsh( void ) const
	{
		ATLASSERT( m_ppsh != NULL );
		return m_ppsh;

	} //*** Ppsh()

	CCluAdmExtensions *	Pext( void ) const { return m_pext; }

}; //*** class CBaseSheetWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CBaseSheetImpl
//
//	Description:
//		Base property sheet implementation for all kinds of property sheets.
//
//	Inheritance
//		CBaseSheetImpl< T, TBase >
//		CPropertySheetImpl< T, TBase >
//		<TBase>
//		...
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CBaseSheetWindow >
class CBaseSheetImpl : public CPropertySheetImpl< T, TBase >
{
	typedef CBaseSheetImpl< T, TBase > thisClass;
	typedef CPropertySheetImpl< T, TBase > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CBaseSheetImpl(
		IN LPCTSTR	lpszTitle = NULL,
		IN UINT		uStartPage = 0,
		IN HWND		hWndParent = NULL
		)
		: baseClass( lpszTitle, uStartPage, hWndParent )
	{
	} //*** CBaseSheetImpl()

	static int CALLBACK PropSheetCallback( HWND hWnd, UINT uMsg, LPARAM lParam )
	{
		//
		// If we are initialized, let the sheet do further initialization.
		// We have to subclass here because otherwize we won't have a
		// pointer to the class instance.
		//
		if ( uMsg == PSCB_INITIALIZED )
		{
			ATLASSERT( hWnd != NULL );
			T * pT = static_cast< T * >( _Module.ExtractCreateWndData() );
			ATLASSERT( pT != NULL );
			pT->SubclassWindow(hWnd);
			pT->OnSheetInitialized();
		} // if:  sheet has been initialized

		return 0;

	} //*** PropSheetCallback()

public:
	//
	// CPropertySheetImpl methods.
	//

	// Add a page to the propsheetheader page list
	virtual BAddPageToSheetHeader( IN HPROPSHEETPAGE hPage )
	{
		return AddPage( hPage );

	} //*** BAddPageToHeader()

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
#if DBG
#ifdef _DBG_MSG
		MESSAGE_RANGE_HANDLER( 0, 0xffffffff, OnMsg )
#endif // _DBG_MSG
#ifdef _DBG_MSG_NOTIFY
		MESSAGE_HANDLER( WM_NOTIFY, OnNotify )
#endif // _DBG_MSG_NOTIFY
#ifdef _DBG_MSG_COMMAND
		MESSAGE_HANDLER( WM_COMMAND, OnCommand )
#endif // _DBG_MSG_COMMAND
#endif // DBG
//		CHAIN_MSG_MAP( baseClass ) // doesn't work because base class doesn't have a message map
	END_MSG_MAP()

public:
	//
	// Message handler functions.
	//

#if DBG && defined( _DBG_MSG )
	// Handler for any message
	LRESULT OnMsg( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnMsg( uMsg, wParam, lParam, bHandled, T::s_pszClassName );

	} //*** OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
	// Handler for the WM_NOTIFY message
	LRESULT OnNotify( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnNotify( uMsg, wParam, lParam, bHandled, T::s_pszClassName, NULL );

	} //*** OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
	// Handler for the WM_COMMAND message
	LRESULT OnCommand( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
	{
		return DBG_OnCommand( uMsg, wParam, lParam, bHandled, T::s_pszClassName, NULL );

	} //*** OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )

// Implementation
protected:

public:

}; //*** class CBaseSheetImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASESHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasewizpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizPage.cpp
//
//	Abstract:
//		Implementation of wizard page classes
//
//	Author:
//		David Potter (davidp)	May 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlBaseWizPage.h"

/////////////////////////////////////////////////////////////////////////////
// class CWizardPageList
///////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizardPageList::PwpageFromID
//
//	Routine Description:
//		Get a pointer to a page from a dialog ID.
//
//	Arguments:
//		psz		[IN] Dialog ID.
//
//	Return Value:
//		pwpage	Pointer to page corresponding to the dialog ID.
//		NULL	Page wasn't found.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardPageWindow * CWizardPageList::PwpageFromID( IN LPCTSTR psz )
{
	ATLASSERT( psz != NULL );

	CWizardPageWindow * pwpage = NULL;
	iterator itCurrent = begin();
	iterator itLast = end();
	for ( ; itCurrent != itLast ; itCurrent++ )
	{
		ATLASSERT( *itCurrent != NULL );
		if ( (*itCurrent)->Ppsp()->pszTemplate == psz )
		{
			pwpage = *itCurrent;
			break;
		} // if:  found match
	} // for:  each item in the list

	return pwpage;

} //*** CWizardPageList::PwpageFromID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizardPageList::PwpageFromID
//
//	Routine Description:
//		Get a pointer to the next page from a dialog ID.
//
//	Arguments:
//		psz		[IN] Dialog ID.
//
//	Return Value:
//		pwpage	Pointer to page corresponding to the dialog ID.
//		NULL	Page wasn't found.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardPageWindow * CWizardPageList::PwpageNextFromID( IN LPCTSTR psz )
{
	ATLASSERT( psz != NULL );

	CWizardPageWindow * pwpage = NULL;
	iterator itCurrent = begin();
	iterator itLast = end();
	for ( ; itCurrent != itLast ; itCurrent++ )
	{
		ATLASSERT( *itCurrent != NULL );
		if ( (*itCurrent)->Ppsp()->pszTemplate == psz )
		{
			itCurrent++;
			if ( itCurrent != end() )
			{
				pwpage = *itCurrent;
			} // if:  not last page
			break;
		} // if:  found match
	} // for:  each item in the list

	return pwpage;

} //*** CWizardPageList::PwpageNextFromID()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasewizpage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizPage.h
//
//	Implementation File:
//		AtlBaseWizPage.cpp
//
//	Description:
//		Definition of the CWizardPageWindow and CWizardPageImpl classes.
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEWIZPAGE_H_
#define __ATLBASEWIZPAGE_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters in the browser information

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CStaticWizardPageList;
class CDynamicWizardPageList;
class CExtensionWizardPageList;
class CExtensionWizard97PageList;
class CWizardPageList;
class CWizardPageWindow;
class CStaticWizardPageWindow;
class CDynamicWizardPageWindow;
class CExtensionWizardPageWindow;
class CExtensionWizard97PageWindow;
template < class T, class TWin > class CWizardPageImpl;
template < class T > class CStaticWizardPageImpl;
template < class T > class CDynamicWizardPageImpl;
template < class T > class CExtensionWizardPageImpl;
template < class T > class CExtensionWizard97PageImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardWindow;
class CCluAdmExDll;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEPAGE_H_
#include "AtlBasePage.h"	// for CBasePageWindow, CBasePageImpl
#endif

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"		// for debugging definitions
#endif

#ifndef __ATLBASEWIZ_H_
#include "AtlBaseWiz.h"		// for CWizardWindow (Pwiz() usage)
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

class CStaticWizardPageList : public std::list< CStaticWizardPageWindow * >
{
}; //*** class CStaticWizardPageList

class CDynamicWizardPageList : public std::list< CDynamicWizardPageWindow * >
{
}; //*** class CDynamicWizardPageList

class CExtensionWizardPageList : public std::list< CExtensionWizardPageWindow * >
{
}; //*** class CExtensionWizardPageList

class CExtensionWizard97PageList : public std::list< CExtensionWizard97PageWindow * >
{
}; //*** class CExtensionWizard97PageList

#define WIZARDPAGE_HEADERTITLEID( ids ) \
static UINT GetWizardPageHeaderTitleId(void) \
{ \
	return ids; \
}

#define WIZARDPAGE_HEADERSUBTITLEID( ids ) \
static UINT GetWizardPageHeaderSubTitleId(void) \
{ \
	return ids; \
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardPageList
//
//	Description:
//		List of wizard pages.
//
//	Inheritance:
//		CWizardPageList
//		std::list< CWizardPageWindow * >
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWizardPageList : public std::list< CWizardPageWindow * >
{
	typedef std::list< CWizardPageWindow * > baseClass;

public:
	// Find page by resource ID
	CWizardPageWindow * PwpageFromID( IN LPCTSTR psz );

	// Find next page by resource ID
	CWizardPageWindow * PwpageNextFromID( IN LPCTSTR psz );

}; //*** class CWizardPageList

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window.
//
//	Inheritance:
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWizardPageWindow : public CBasePageWindow
{
	typedef CBasePageWindow baseClass;

	friend CWizardWindow;
	friend CCluAdmExDll;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_fWizardButtons( 0 )
		, m_bBackPressed( FALSE )
		, m_bIsPageEnabled( FALSE )
		, m_bIsNextPageSet( FALSE )
	{
	} //*** CWizardPageWindow()

	// Destructor
	virtual ~CWizardPageWindow( void )
	{
	} //*** ~CWizardPageWindow()

public:
	//
	// CWizardPageWindow public methods.
	//

	// Enable or disable the Next button
	void EnableNext( IN BOOL bEnable = TRUE )
	{
		ATLASSERT( Pwiz() != NULL );

		//
		// Ask the wizard to enable or disable the Next button.
		//
		Pwiz()->EnableNext( bEnable, FWizardButtons() );

	} //*** EnableNext()

	// Set the next page to be enabled
	void SetNextPage( IN LPCTSTR pszNextPage )
	{
		Pwiz()->SetNextPage( this, pszNextPage );
		m_bIsNextPageSet = TRUE;

	} //*** SetNextPage()

	// Set the next page to be enabled from a dialog ID
	void SetNextPage( IN UINT idNextPage )
	{
		Pwiz()->SetNextPage( this, idNextPage );
		m_bIsNextPageSet = TRUE;

	} //*** SetNextPage()

public:
	//
	// Message handler functions.
	//

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void )
	{
		if ( ! m_bIsPageEnabled )
		{
			return FALSE;
		} // if:  page is not enabled to be displayed

		SetWizardButtons();
		m_bBackPressed = FALSE;

		return baseClass::OnSetActive();

	} //*** OnSetActive()

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		m_bBackPressed = TRUE;
		int nResult = baseClass::OnWizardBack();
		if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
		{
			nResult = -1;
		} // if:  error updating data
		if ( nResult == -1 ) // if not successful
		{
			m_bBackPressed = FALSE;
		} // if:  failure occurred
		else if ( nResult == 0 ) // defaulting to go to next page
		{
		} // else if:  no next page specified

		return nResult;

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		// Update the data in the class from the page.
		if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
		{
			return -1;
		} // if:  error updating data

		// Save the data in the sheet.
		if ( ! BApplyChanges() )
		{
			return -1;
		} // if:  error applying changes

		int nResult = baseClass::OnWizardNext();

		return nResult;

	} //*** OnWizardNext()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		if ( BIsPageEnabled() )
		{
			// Update the data in the class from the page.
			if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
			{
				return FALSE;
			} // if:  error updating data

			// Save the data in the sheet.
			if ( ! BApplyChanges() )
			{
				return FALSE;
			} // if:  error applying changes
		} // if: page is enabled

		return baseClass::OnWizardFinish();

	} //*** OnWizardFinish()

	// Handler for PSN_RESET
	void OnReset( void )
	{
		Pwiz()->OnReset();
		baseClass::OnReset();

	} //*** OnReset()

// Implementation
protected:
	DWORD			m_fWizardButtons;
	BOOL			m_bBackPressed;
	BOOL			m_bIsPageEnabled;
	BOOL			m_bIsNextPageSet;
	CString			m_strHeaderTitle;
	CString			m_strHeaderSubTitle;

	DWORD			FWizardButtons( void ) const	{ return m_fWizardButtons; }
	BOOL			BBackPressed( void ) const		{ return m_bBackPressed; }
	BOOL			BIsPageEnabled( void ) const	{ return m_bIsPageEnabled; }
	BOOL			BIsNextPageSet( void ) const	{ return m_bIsNextPageSet; }
	const CString &	StrHeaderTitle( void ) const	{ return m_strHeaderTitle; }
	const CString &	StrHeaderSubTitle( void ) const	{ return m_strHeaderSubTitle; }

	CWizardWindow *	Pwiz( void ) const				{ return (CWizardWindow *) Psht(); }

	// Set default wizard buttons to be displayed with page
	void SetDefaultWizardButtons( IN DWORD fWizardButtons )
	{
		ATLASSERT( fWizardButtons != 0 );
		m_fWizardButtons = fWizardButtons;

	} //*** SetDefaultWizardButtons()

public:
	// Set wizard buttons on the wizard
	void SetWizardButtons( void )
	{
		ATLASSERT( m_fWizardButtons != 0 );
		Pwiz()->SetWizardButtons( m_fWizardButtons );

	} //*** SetWizardButtons()

	// Enable or disable the page
	void EnablePage( IN BOOL bEnable = TRUE )
	{
		m_bIsPageEnabled = bEnable;

	} //*** EnablePage()

}; //*** class CWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet before the call to PropertySheet().  This page cannot
//		be removed from the sheet.
//
//	Inheritance:
//		CStaticWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CStaticWizardPageWindow : public CWizardPageWindow
{
	typedef CWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CStaticWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CStaticWizardPageWindow()

}; //*** class CStaticWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet after the call to PropertySheet().  This page may be
//		removed from the sheet.
//
//	Inheritance:
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

class CDynamicWizardPageWindow : public CWizardPageWindow
{
	typedef CWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CDynamicWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_hpage( NULL )
		, m_bPageAddedToSheet( FALSE )
	{
	} //*** CDynamicWizardPageWindow()

	// Destructor
	~CDynamicWizardPageWindow( void )
	{
		//
		// Destroy the page if it hasn't been added to the sheet yet.
		// If it has been added to the sheet, the sheet will destroy it.
		//
		if (   (m_hpage != NULL)
			&& ! m_bPageAddedToSheet )
		{
			DestroyPropertySheetPage( m_hpage );
			m_hpage = NULL;
		} // if:  page not deleted yet and not added to the sheet

	} //*** ~CDynamicWizardPageWindow()

	// Create the page
	virtual DWORD ScCreatePage( void ) = 0;

protected:
	HPROPSHEETPAGE	m_hpage;
	BOOL			m_bPageAddedToSheet;

public:
	// Property page handle
	HPROPSHEETPAGE Hpage( void ) const { return m_hpage; }

	// Returns whether page has been added to the sheet or not
	BOOL BPageAddedToSheet( void ) const { return m_bPageAddedToSheet; }

	// Set whether the page has been added to the sheet or not
	void SetPageAdded( IN BOOL bAdded = TRUE )
	{
		m_bPageAddedToSheet = bAdded;
		if ( ! bAdded )
		{
			m_hpage = NULL;
		} // if:  removing page

	} //*** SetPageAdded()

}; //*** class CDynamicWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizardPageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet after the call to PropertySheet() identified as a
//		non-Wizard97 extension to the list of standard pages.  This page may
//		be removed from the sheet.
//
//	Inheritance:
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

class CExtensionWizardPageWindow : public CDynamicWizardPageWindow
{
	typedef CDynamicWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CExtensionWizardPageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CExtensionWizardPageWindow()

}; //*** class CExtensionWizardPageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizard97PageWindow
//
//	Description:
//		Base wizard property sheet page window for pages added to a wizard
//		property sheet after the call to PropertySheet() identified as a
//		Wizard97 extension to the list of standard pages.  This page may be
//		removed from the sheet.
//
//	Inheritance:
//		CExtensionWizard97PageWindow
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

class CExtensionWizard97PageWindow : public CExtensionWizardPageWindow
{
	typedef CExtensionWizardPageWindow baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CExtensionWizard97PageWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
	{
	} //*** CExtensionWizard97PageWindow()

}; //*** class CExtensionWizard97PageWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation.
//
//	Inheritance:
//		CWizardPageImpl< T, TWin >
//		CBasePageImpl< T, TWin >
//		CPropertyPageImpl< T, TWin >
//		<TWin>
//		...
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class TWin = CWizardPageWindow >
class CWizardPageImpl : public CBasePageImpl< T, TWin >
{
	typedef CWizardPageImpl< T, TWin > thisClass;
	typedef CBasePageImpl< T, TWin > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
		// Set the pointer in the base window class to our prop page header.
		m_ppsp = &m_psp;

	} //*** CWizardPageImpl( nIDTitle )

	// Initialize the page
	virtual BOOL BInit( IN CBaseSheetWindow * psht )
	{
		if ( ! baseClass::BInit( psht ) )
		{
			return FALSE;
		} // if:  base class failed
		if (   (Pwiz()->Ppsh()->dwFlags & PSH_WIZARD97)
			&& (Pwiz()->Ppsh()->dwFlags & PSH_HEADER) )
		{
			//
			// Get the header title.
			//
			UINT idsTitle = T::GetWizardPageHeaderTitleId();
			if ( idsTitle != 0 )
			{
				m_strHeaderTitle.LoadString( idsTitle );
				m_psp.pszHeaderTitle = m_strHeaderTitle;
				m_psp.dwFlags |= PSP_USEHEADERTITLE;
				m_psp.dwFlags &= ~PSP_HIDEHEADER;

				//
				// Get the header subtitle.
				//
				UINT idsSubTitle = T::GetWizardPageHeaderSubTitleId();
				if ( idsSubTitle != 0 )
				{
					m_strHeaderSubTitle.LoadString( idsSubTitle );
					m_psp.pszHeaderSubTitle = m_strHeaderSubTitle;
					m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
				} // if:  subtitle specified
			} // if:  title specified
			else
			{
				m_psp.dwFlags |= PSP_HIDEHEADER;
			} // else:  no title specified
		} // if:  Wizard97 with a header

		return TRUE;

	} //*** BInit()

public:
	//
	// CWizardPageImpl public methods.
	//

	// Get the next page we're going to
	CWizardPageWindow * PwizpgNext( IN LPCTSTR psz = NULL )
	{
		ATLASSERT( psz != (LPCTSTR) -1 );
		CWizardPageWindow * ppage = NULL;
		if ( psz == NULL )
		{
			//
			// There will not be a resource ID for extension pages, so check
			// for that before calling PwpageNextFromID.  This allows us to
			// leave the assert in there for a non-NULL resource.
			//
			if ( T::IDD != 0 )
			{
				ppage = Pwiz()->PlwpPages()->PwpageNextFromID( MAKEINTRESOURCE( T::IDD ) );
			} // if:  there is a resource ID for this page
		} // if:  no next page specified
		else
		{
			ppage = Pwiz()->PlwpPages()->PwpageFromID( psz );
		} // else:  next page specified
		return ppage;

	} //*** PwizpgNext()

	// Enable or disable the next page
	void EnableNextPage( IN BOOL bEnable = TRUE )
	{
		CWizardPageWindow * pwp = PwizpgNext();
		if ( pwp != NULL )
		{
			pwp->EnablePage( bEnable );
		} // if:  next page found

	} //*** EnableNextPage()

public:
	//
	// Message handler functions.
	//

	//
	// Message handler override functions.
	//

	// Handler for PSN_WIZBACK
	int OnWizardBack( void )
	{
		//
		// Make sure back button is marked as last button pressed.
		//
		Pwiz()->SetLastWizardButton( ID_WIZBACK );

		return baseClass::OnWizardBack();

	} //*** OnWizardBack()

	// Handler for PSN_WIZNEXT
	int OnWizardNext( void )
	{
		//
		// Make sure next button is marked as last button pressed.
		//
		Pwiz()->SetLastWizardButton( ID_WIZNEXT );

		int nResult = baseClass::OnWizardNext();
		if ( nResult != -1 )
		{
			if ( ! BIsNextPageSet() )
			{
				EnableNextPage();
			} // if:  next page not set yet
			m_bIsNextPageSet = FALSE;
		} // if:  changing pages

		return nResult;

	} //*** OnWizardNext()

// Implementation
protected:

public:

}; //*** class CWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CStaticWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet before the call to PropertySheet().  This page
//		cannot be removed from the sheet.
//
//	Inheritance:
//		CStaticWizardPageImpl< T >
//		CWizardPageImpl< T, CStaticWizardPageWindow >
//		CBasePageImpl< T, CStaticWizardPageWindow >
//		CPropertyPageImpl< T, CStaticWizardPageWindow >
//		CStaticWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CStaticWizardPageImpl : public CWizardPageImpl< T, CStaticWizardPageWindow >
{
	typedef CStaticWizardPageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CStaticWizardPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CStaticWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CStaticWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CStaticWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CStaticWizardPageImpl( nIDTitle )

}; //*** class CStaticWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDynamicWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet after the call to PropertySheet().  This page
//		may be removed from the sheet.
//
//	Inheritance:
//		CDynamicWizardPageImpl< T >
//		CWizardPageImpl< T, CDynamicWizardPageWindow >
//		CBasePageImpl< T, CDynamicWizardPageWindow >
//		CPropertyPageImpl< T, CDynamicWizardPageWindow >
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CDynamicWizardPageImpl : public CWizardPageImpl< T, CDynamicWizardPageWindow >
{
	typedef CDynamicWizardPageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CDynamicWizardPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CDynamicWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CDynamicWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CDynamicWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CDynamicWizardPageImpl( nIDTitle )

	// Create the page
	DWORD ScCreatePage( void )
	{
		ATLASSERT( m_hpage == NULL );

		m_hpage = CreatePropertySheetPage( &m_psp );
		if ( m_hpage == NULL )
		{
			return GetLastError();
		} // if:  error creating the page

		return ERROR_SUCCESS;

	} //*** ScCreatePage()

}; //*** class CDynamicWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizardPageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet after the call to PropertySheet() identified
//		as a non-Wizard97 extension to the list of standard pages.  This
//		page may be removed from the sheet.
//
//	Inheritance:
//		CExtensionWizardPageImpl< T >
//		CWizardPageImpl< T, CExtensionWizardPageWindow >
//		CBasePageImpl< T, CExtensionWizardPageWindow >
//		CPropertyPageImpl< T, CExtensionWizardPageWindow >
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CExtensionWizardPageImpl : public CWizardPageImpl< T, CExtensionWizardPageWindow >
{
	typedef CExtensionWizardPageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CExtensionWizardPageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CExtensionWizardPageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CExtensionWizardPageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CExtensionWizardPageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CExtensionWizardPageImpl( nIDTitle )

}; //*** class CExtensionWizardPageImpl

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CExtensionWizard97PageImpl
//
//	Description:
//		Base wizard property sheet page implementation for pages added to a
//		wizard property sheet after the call to PropertySheet() identified
//		as a Wizard97 extension to the list of standard pages.  This page
//		may be removed from the sheet.
//
//	Inheritance:
//		CExtensionWizard97PageImpl< T >
//		CWizardPageImpl< T, CExtensionWizard97PageWindow >
//		CBasePageImpl< T, CExtensionWizard97PageWindow >
//		CPropertyPageImpl< T, CExtensionWizard97PageWindow >
//		CExtensionWizard97PageWindow
//		CExtensionWizardPageWindow
//		CDynamicWizardPageWindow
//		CWizardPageWindow
//		CBasePageWindow
//		CPropertyPageWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CExtensionWizard97PageImpl : public CWizardPageImpl< T, CExtensionWizard97PageWindow >
{
	typedef CExtensionWizard97PageImpl< T > thisClass;
	typedef CWizardPageImpl< T, CExtensionWizard97PageWindow > baseClass;

public:
	//
	// Construction.
	//

	// Standard constructor
	CExtensionWizard97PageImpl(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: baseClass( lpszTitle )
	{
	} //*** CExtensionWizard97PageImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CExtensionWizard97PageImpl(
		IN UINT nIDTitle
		)
		: baseClass( nIDTitle )
	{
	} //*** CExtensionWizard97PageImpl( nIDTitle )

}; //*** class CExtensionWizard97PageImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEWIZPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasewiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlBaseWiz.cpp
//
//  Abstract:
//      Implementation of the CWizardWindow class.
//
//  Author:
//      David Potter (davidp)   December 2, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <StrSafe.h>
#include "AtlBaseWiz.h"
#include "AtlBaseWizPage.h"
#include "AtlExtDll.h"
#include "StlUtils.h"
#include "ExcOper.h"
#include "AdmCommonRes.h"

/////////////////////////////////////////////////////////////////////////////
// Local Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardGuardPage
//
//  Purpose:
//      Guard page transferring control between the main wizard and the
//      alternate extension wizard.
//
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CAltExtWizardGuardPage
    : public CExtensionWizardPageImpl< T >
{
    typedef CAltExtWizardGuardPage< T > thisClass;
    typedef CExtensionWizardPageImpl< T > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardGuardPage(
        DLGTEMPLATE * pdt
        )
        : m_pdt( pdt )
    {
        ATLASSERT( pdt != NULL );

    } //*** CAltExtWizardGuardPage()

    // Destructor
    ~CAltExtWizardGuardPage( void )
    {
        delete m_pdt;

    } //*** ~CAltExtWizardGuardPage()

    WIZARDPAGE_HEADERTITLEID( 0 )
    WIZARDPAGE_HEADERSUBTITLEID( 0 )

    enum { IDD = 0 };
    DECLARE_CLASS_NAME()

    // Return the help ID map
    static const DWORD * PidHelpMap( void )
    {
        static const DWORD s_aHelpIDs[] = { 0, 0 };
        return s_aHelpIDs;

    } //*** PidHelpMap()

    // Create the page
    DWORD ScCreatePage( void )
    {
        ATLASSERT( m_hpage == NULL );

        m_psp.dwFlags |= PSP_DLGINDIRECT;
        m_psp.pResource = m_pdt;

        m_hpage = CreatePropertySheetPage( &m_psp );
        if ( m_hpage == NULL )
        {
            return GetLastError();
        } // if:  error creating the page

        return ERROR_SUCCESS;

    } //*** ScCreatePage()

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        MESSAGE_HANDLER( WM_ACTIVATE, OnActivate )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for the WM_ACTIVATE message
    LRESULT OnActivate(
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL & bHandled
        )
    {
        //
        // Don't allow us to be activated.
        //
        //WORD fActive = LOWORD( wParam );
        HWND hwndPrevious = (HWND) lParam;
        if ( wParam != WA_INACTIVE )
        {
            ::SetActiveWindow( hwndPrevious );
        }
        return 0;

    } //*** OnActivate()

    //
    // Message handler override functions.
    //

protected:
    DLGTEMPLATE *   m_pdt;

}; //*** class CAltExtWizardGuardPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPreLauncherPage
//
//  Purpose:
//      Extension launcher wizard page used to display Wizard97 pages in
//      a non-Wizard97 sheet or vice-versa.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPreLauncherPage
    : public CAltExtWizardGuardPage< CAltExtWizardPreLauncherPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPreLauncherPage > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardPreLauncherPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPreLauncherPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPreLauncherPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler overrides functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

}; //*** class CAltExtWizardPreLauncherPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPostLauncherPage
//
//  Purpose:
//      Page use to switch between the main wizard and the alternate
//      extension wizard when moving backwards.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPostLauncherPage
    : public CAltExtWizardGuardPage< CAltExtWizardPostLauncherPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPostLauncherPage > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardPostLauncherPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPostLauncherPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPostLauncherPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler override functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

}; //*** class CAltExtWizardPostLauncherPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizard
//
//  Purpose:
//      Dummy wizard to host pages that are not of the same type as the main
//      wizard, e.g. non-Wizard97 pages in a Wizard97 wizard.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizard : public CWizardImpl< CAltExtWizard >
{
    typedef CWizardImpl< CAltExtWizard > baseClass;

    friend class CWizardWindow;
    friend class CAltExtWizardPreLauncherPage;
    friend class CAltExtWizardPostLauncherPage;
    friend class CAltExtWizardPrefixPage;
    friend class CAltExtWizardPostfixPage;

public:
    //
    // Construction
    //

    // Standard constructor
    CAltExtWizard( void )
        : CWizardImpl< CAltExtWizard >( _T("") )
        , m_pwizMain( NULL )
        , m_bWindowMoved( FALSE )
        , m_bExitMsgLoop( FALSE )
        , m_nExitButton( 0 )
    {
    } //*** CExtensionAltWizard()

    // Initialize the sheet
    BOOL BInit( IN CWizardWindow * pwiz );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CAltExtWizard )
        COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnCancel )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for BN_CLICKED on the Cancel button
    LRESULT OnCancel(
        WORD wNotifyCode,
        WORD idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        //
        // Notify the main wizard that the user pressed the cancel button.
        //
        ExitMessageLoop( PSBTN_CANCEL );
        bHandled = FALSE;
        return 0;

    } //*** OnCancel()

    //
    // Message handler override functions.
    //

    // Handler for the final message after WM_DESTROY
    void OnFinalMessage( HWND hWnd )
    {
        PwizMain()->DeleteAlternateWizard();

    } //*** OnFinalMessage()

protected:
    CWizardWindow * m_pwizMain;     // Pointer to the main wizard.
    BOOL            m_bWindowMoved; // Indicates whether this window has been
                                    //   repositioned over main wizard or not.
    BOOL            m_bExitMsgLoop; // Indicates whether the message loop
                                    //   should be exited or not.
    DWORD           m_nExitButton;  // Button to press after exiting.

protected:
    // Return a pointer to the main wizard
    CWizardWindow * PwizMain( void ) { return m_pwizMain; }

    // Return whether the wizard has been moved yet
    BOOL BWindowMoved( void ) const { return m_bWindowMoved; }

    // Return whether the message loop should be exited or not
    BOOL BExitMessageLoop( void ) const { return m_bExitMsgLoop; }

    // Change whether the message loop should be exited or not
    void ExitMessageLoop( IN DWORD nButton )
    {
        ATLASSERT( (nButton == PSBTN_BACK) || (nButton == PSBTN_NEXT) || (nButton == PSBTN_CANCEL) );
        m_bExitMsgLoop = TRUE;
        m_nExitButton = nButton;

    } //*** ExitMessageLoop()

    // Return the button to press in the main wizard after exiting
    DWORD NExitButton( void ) const { return m_nExitButton; }

protected:
    // Add the prefix page
    BOOL BAddPrefixPage( IN WORD cx, IN WORD cy );

    // Add the postfix page
    BOOL BAddPostfixPage( IN WORD cx, IN WORD cy );

    // Display the alternate wizard
    void DisplayAlternateWizard( void );

    // Display the main wizard
    void DisplayMainWizard( void );

    // Destroy the alternate extension wizard
    void DestroyAlternateWizard( void );

    // Message loop for the modeless wizard
    void MessageLoop( void );

}; //*** class CAltExtWizard

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPrefixPage
//
//  Purpose:
//      Wizard page which precedes the first alternate page.  This page
//      handles transferring control between the main wizard and the
//      alternate wizard.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPrefixPage
    : public CAltExtWizardGuardPage< CAltExtWizardPrefixPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPrefixPage > baseClass;

public:
    //
    // Construction.
    //

    // Standard constructor
    CAltExtWizardPrefixPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPrefixPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPrefixPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler override functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

protected:
    // Return the alternate wizard object
    CAltExtWizard * PwizThis( void ) { return (CAltExtWizard *) Pwiz(); }

}; //*** class CAltExtWizardPrefixPage

/////////////////////////////////////////////////////////////////////////////
//
//  class CAltExtWizardPostfixPage
//
//  Purpose:
//      Wizard page which follows the last alternate page.  This page
//      handles transferring control between the main wizard and the
//      alternate wizard.
//
/////////////////////////////////////////////////////////////////////////////

class CAltExtWizardPostfixPage
    : public CAltExtWizardGuardPage< CAltExtWizardPostfixPage >
{
    typedef CAltExtWizardGuardPage< CAltExtWizardPostfixPage > baseClass;

public:
    //
    // Construction.
    //
    // Standard constructor
    CAltExtWizardPostfixPage(
        DLGTEMPLATE * pdt
        )
        : baseClass( pdt )
    {
    } //*** CAltExtWizardPostfixPage()

    DECLARE_CLASS_NAME()

public:
    //
    // Message map.
    //
    //BEGIN_MSG_MAP( CAltExtWizardPostfixPage )
    //  CHAIN_MSG_MAP( baseClass )
    //END_MSG_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler override functions.
    //

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

protected:
    // Return the alternate wizard object
    CAltExtWizard * PwizThis( void ) { return (CAltExtWizard *) Pwiz(); }

}; //*** class CAltExtWizardPostfixPage


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CWizardWindow
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::~CWizardWindow
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardWindow::~CWizardWindow( void )
{
    //
    // Delete the alternate wizard, if it exists.
    //
    if ( (PwizAlternate() != NULL) && (PwizAlternate()->m_hWnd != NULL) )
    {
        reinterpret_cast< CAltExtWizard * >( PwizAlternate() )->DestroyAlternateWizard();
    } // if:  alternate wizard exists

    //
    // Delete pages from the page list.
    //
    if ( m_plwpPages != NULL )
    {
        DeleteAllPtrListItems( m_plwpPages );
        delete m_plwpPages;
    } // if:  page array has been allocated

    if ( m_plewpNormal != NULL )
    {
        DeleteAllPtrListItems( m_plewpNormal );
        delete m_plewpNormal;
    } // if:  list already exists

    if ( m_plewpAlternate != NULL )
    {
        DeleteAllPtrListItems( m_plewpAlternate );
        delete m_plewpAlternate;
    } // if:  list already exists

} //*** CWizardWindow::~CWizardWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::BAddPage
//
//  Routine Description:
//      Add a page to the page list.  If it is the first page, it won't have
//      a BACK button.  If it isn't the first page, the last page will have
//      its FINISH button changed to a NEXT button and this page will have
//      both a FINISH button and a BACK button.
//
//  Arguments:
//      pwp     [IN] Wizard page to add.
//
//  Return Value:
//      TRUE    Page added successfully.
//      FALSE   Error adding page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardWindow::BAddPage( IN CWizardPageWindow * pwp )
{
    ATLASSERT( pwp != NULL );

    // Make sure specified page hasn't already been added.
    ATLASSERT( (m_plwpPages == NULL)
            || (std::find( PlwpPages()->begin(), PlwpPages()->end(), pwp ) == PlwpPages()->end()) );

    BOOL bSuccess = FALSE;
    ULONG fWizardButtons = PSWIZB_FINISH;
    ULONG fPrevWizardButtons;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate the page list if it doesn't exist yet.
        //
        if ( m_plwpPages == NULL )
        {
            m_plwpPages = new CWizardPageList;
            if ( m_plwpPages == NULL )
            {
                CNTException nte(
                                static_cast< DWORD >( E_OUTOFMEMORY ),
                                ADMC_IDS_ADD_FIRST_PAGE_TO_PROP_SHEET_ERROR,
                                NULL,   // pszOperArg1
                                NULL,   // pszOperArg2
                                FALSE   // bAutoDelete
                                );
                nte.ReportError();
                break;
            } // if:  error allocating page list
        } // if:  no page array yet

        //
        // If this is not the first page in the list, set the previous
        // page's wizard buttons to have a NEXT button instead of a
        // FINISH button and set this page to have a BACK button.
        //
        if ( PlwpPages()->size() > 0 )
        {
            //
            // Get the current last page.
            //
            CWizardPageList::iterator itFirst = PlwpPages()->begin();
            CWizardPageList::iterator itLast  = PlwpPages()->end();
            ATLASSERT( itFirst != itLast );
            CWizardPageWindow * pwpPrev = *(--PlwpPages()->end());
            ATLASSERT( pwpPrev != NULL );

            //
            // Set the wizard buttons on that page.
            //
            fPrevWizardButtons = pwpPrev->FWizardButtons();
            fPrevWizardButtons &= ~PSWIZB_FINISH;
            fPrevWizardButtons |= PSWIZB_NEXT;
            pwpPrev->SetDefaultWizardButtons( fPrevWizardButtons );

            fWizardButtons |= PSWIZB_BACK;
        } // if:  not the first page added

        pwp->SetDefaultWizardButtons( fWizardButtons );

        //
        // Insert the page at the end of the list.
        //
        PlwpPages()->insert( PlwpPages()->end(), pwp );

        //
        // Add the page to the sheet.  If the sheet hasn't been created yet,
        // add it to the sheet header list.  If the sheet has been created,
        // add it to the sheet dynamically.  Note that the page must not be a
        // static page.
        //
        if ( m_hWnd == NULL )
        {
            //
            // If this is a dynamic page, add it using its hpage.  Otherwise
            // it must be a static page.  Add it by its property sheet page header.
            //
            CDynamicWizardPageWindow * pdwp = dynamic_cast< CDynamicWizardPageWindow * >( pwp );
            if ( pdwp != NULL )
            {
                if ( pdwp->Hpage() != NULL )
                {
                    ATLASSERT( ! pdwp->BPageAddedToSheet() );
                    bSuccess = BAddPageToSheetHeader( pdwp->Hpage() );
                    if ( ! bSuccess )
                    {
                        CNTException nte(
                            GetLastError(),
                            ADMC_IDS_ADD_PAGE_TO_WIZARD_ERROR,
                            NULL,
                            NULL,
                            FALSE
                            );
                        nte.ReportError();
                        break;
                    } // if:  error adding the page to the sheet header
                    pdwp->SetPageAdded( TRUE );
                } // if:  page already created
            } // if:  dynamic page
            else
            {
                // Must be static page
                ATLASSERT( dynamic_cast< CStaticWizardPageWindow * >( pwp ) != NULL );

                //
                // Initialize the page.
                //
                bSuccess = pwp->BInit( this );
                if ( ! bSuccess )
                {
                    break;
                } // if:  error initializing the page

                //
                // Add the page.
                //
                bSuccess = AddPage( pwp->Ppsp() );
                if ( ! bSuccess )
                {
                    CNTException nte(
                        GetLastError(),
                        ADMC_IDS_ADD_PAGE_TO_WIZARD_ERROR,
                        NULL,
                        NULL,
                        FALSE
                        );
                    nte.ReportError();
                    break;
                } // if:  error adding the page
            } // else:  not dynamic page
        } // if:  sheet has been created
        else
        {
            // Can't be static page.  Must be dynamic page.
            ATLASSERT( dynamic_cast< CStaticWizardPageWindow * >( pwp ) == NULL );
            CDynamicWizardPageWindow * pdwp = dynamic_cast< CDynamicWizardPageWindow * >( pwp );
            ATLASSERT( pdwp != NULL );
            AddPage( pdwp->Hpage() );
            pdwp->SetPageAdded( TRUE );
        } // else:  sheet already created

        //
        // If we get to here we are successfully.
        //
        bSuccess = TRUE;
    } while ( 0 );
        
    return bSuccess;

} //*** CWizardWindow::BAddPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::OnSheetInitialized
//
//  Routine Description:
//      Handler for PSCB_INITIALIZED.
//      Add pages that haven't been added yet, which will only be dynamic
//      pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::OnSheetInitialized( void )
{
    //
    // Remove the system menu.
    //
    ModifyStyle( WS_SYSMENU, 0 );

    //
    // Add dynamic pages, including extension pages, if not added yet.
    //
    {
        //
        // Get pointers to beginning and end of list.
        //
        CWizardPageList::iterator itCurrent = PlwpPages()->begin();
        CWizardPageList::iterator itLast = PlwpPages()->end();

        //
        // Loop through the list and add each dynamic page.
        //
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicWizardPageWindow * pdwp = dynamic_cast< CDynamicWizardPageWindow * >( *itCurrent );
            if ( pdwp != NULL )
            {
                if ( ! pdwp->BPageAddedToSheet() && (pdwp->Hpage() != NULL) )
                {
                    AddPage( pdwp->Hpage() );
                    pdwp->SetPageAdded( TRUE );
                } // if:  page not added yet and page has already been created
            } // if:  dynamic page found
        } // for:  each item in the list

    } // Add dynamic pages, including extension pages

    //
    // Call the base class method.
    //
    CBaseSheetWindow::OnSheetInitialized();

} //*** CWizardWindow::OnSheetInitialized()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::SetNextPage
//
//  Routine Description:
//      Set the next page to be displayed.
//
//  Arguments:
//      pwCurrentPage   [IN] Current page whose next page is to be enabled.
//      pszNextPage     [IN] Page ID.
//
//  Return Value:
//      pwizpg
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::SetNextPage(
    IN CWizardPageWindow *  pwCurrentPage,
    IN LPCTSTR              pszNextPage
    )
{
    ATLASSERT( pwCurrentPage != NULL );
    ATLASSERT( pszNextPage != NULL );

    BOOL                        bFoundCurrent = FALSE;
    CWizardPageWindow *         pwPage;
    CWizardPageList::iterator   itCurrent = PlwpPages()->begin();
    CWizardPageList::iterator   itLast = PlwpPages()->end();

    //
    // Skip pages until the current page is found.
    //
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pwPage = *itCurrent;
        if ( pwPage == pwCurrentPage )
        {
            bFoundCurrent = TRUE;
            break;
        } // if:  found the current page
    } // for:  each page in the list

    ATLASSERT( bFoundCurrent );

    //
    // Disable all succeeding pages until the desired next page
    // is found.  Enable that page and then exit.
    //
    for ( itCurrent++ ; itCurrent != itLast ; itCurrent++ )
    {
        if ( (*itCurrent)->Ppsp()->pszTemplate == pszNextPage )
        {
            (*itCurrent)->EnablePage( TRUE );
            break;
        } // if:  found the page
        (*itCurrent)->EnablePage( FALSE );
    } // for:  each page in the list

    ATLASSERT( itCurrent != itLast );

} //*** CWizardWindow::SetNextPage( pszNextPage )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      hfont       [IN] Font to use for the extension pages.
//      hicon       [IN] Icon to use for the extension pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::AddExtensionPages( IN HFONT hfont, IN HICON hicon )
{
    ATLASSERT( PcoObjectToExtend() != NULL );

    //
    // Add extension pages if there any extensions.
    //
    if (   (PcoObjectToExtend()->PlstrAdminExtensions() != NULL)
        && (PcoObjectToExtend()->PlstrAdminExtensions()->size() > 0) )
    {
        //
        // Get the currently selected page so we can reset it when we're done.
        //
        CTabCtrl tabc( GetTabControl() );
        int nCurPage = tabc.GetCurSel();

        //
        // Prepare to add extension pages.
        //
        CDynamicWizardPageList ldwp;
        PrepareToAddExtensionPages( ldwp );

        //
        // If no extensions object has been created yet, create it now.
        //
        if ( Pext() == NULL )
        {
            m_pext = new CCluAdmExtensions;
            ATLASSERT( m_pext != NULL );
            if ( m_pext == NULL )
            {
                return;
            } // if: error allocating the extension object
        } // if:  no extensions list yet

        //
        // Enclose the loading of the extension in a try/catch block so
        // that a failure to load the extension won't prevent all pages
        // from being displayed.
        //
        try
        {
            if ( BWizard97() )
            {
                Pext()->CreateWizard97Pages(
                        this,
                        *PcoObjectToExtend()->PlstrAdminExtensions(),
                        PcoObjectToExtend(),
                        hfont,
                        hicon
                        );
            } // if:  Wizard97 wizard
            else
            {
                Pext()->CreateWizardPages(
                        this,
                        *PcoObjectToExtend()->PlstrAdminExtensions(),
                        PcoObjectToExtend(),
                        hfont,
                        hicon
                        );
            } // else:  non-Wizard97 wizard
        } // try
        catch (...)
        {
        } // catch:  anything

        //
        // Complete the process of adding extension pages.
        //
        CompleteAddingExtensionPages( ldwp );

        //
        // Restore the current selection.
        // This has to be done because sometimes the above process causes
        // the current page to be set to the last page added, which prevents
        // the next page from being displayed.
        //
        SetActivePage( nCurPage );
    } // if:  object has extensions
    else
    {
        //
        // Remove extension pages.
        //
        RemoveAllExtensionPages();
    } // else:  object doesn't have extensions

}  //*** CWizardWindow::AddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::PrepareToAddExtensionPages
//
//  Routine Description:
//      Prepare to add extension pages by deleting existing extension
//      pages and removing dynamic pages.
//
//  Arguments:
//      rldwp       [IN OUT] List of dynamic wizard pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::PrepareToAddExtensionPages(
    IN OUT CDynamicWizardPageList & rldwp
    )
{
    //
    // Delete all extension pages from this wizard.  This also
    // includes destroy the alternate wizard if it exists.
    //
    RemoveAllExtensionPages();

    //
    // Delete the lists of extension pages and make sure the lists exist.
    //
    if ( PlewpNormal() != NULL )
    {
        DeleteAllPtrListItems( PlewpNormal() );
    } // if:  list already exists
    else
    {
        m_plewpNormal = new CExtensionWizardPageList;
        if ( m_plewpNormal == NULL )
        {
            return;
        } // if: error allocating the page list
    } // else:  list doesn't exist yet
    if ( PlewpAlternate() != NULL )
    {
        DeleteAllPtrListItems( PlewpAlternate() );
    } // if:  list already exists
    else
    {
        m_plewpAlternate = new CExtensionWizardPageList;
        if ( m_plewpAlternate == NULL )
        {
            return;
        } // if: error allocating the page list
    } // else:  list doesn't exist yet

    //
    // Move all dynamic pages to the temporary list.
    //
    ATLASSERT( rldwp.size() == 0 );
    MovePtrListItems< CWizardPageWindow *, CDynamicWizardPageWindow * >( PlwpPages(), &rldwp );

    //
    // Remove all pages in the temporary list from the wizard.
    //
    {
        CDynamicWizardPageList::iterator itCurrent;
        CDynamicWizardPageList::iterator itLast;

        itCurrent = rldwp.begin();
        itLast = rldwp.end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CDynamicWizardPageWindow * pdwp = *itCurrent;
            ATLASSERT( pdwp != NULL );
            if ( pdwp->Hpage() != NULL )
            {
                RemovePage( pdwp->Hpage() );
                pdwp->SetPageAdded( FALSE );
            } // if:  page already created
        } // for:  each page in the list
    } // Remove dynamic pages

} //*** CWizardWindow::PrepareToAddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::HrAddExtensionPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      ppage       [IN] Page to be added.
//
//  Return Value:
//      S_OK        Page added successfully.
//      S_FALSE     Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CWizardWindow::HrAddExtensionPage( IN CBasePageWindow * ppage )
{
    ATLASSERT( ppage != NULL );

    HRESULT hr = S_OK;

    //
    // Make sure this is an extension wizard page object.
    //
    CExtensionWizardPageWindow * pewp = dynamic_cast< CExtensionWizardPageWindow * >( ppage );
    ATLASSERT( pewp != NULL );

    if (   (ppage == NULL)
        || (pewp == NULL ) )
    {
        return S_FALSE;
    } // if:  invalid arguments

    //
    // If the page is not the same as the type of wizard, add it to the
    // alternate list of extension pages and indicate we need a dummy sheet.
    // Otherwise, add it to the standard list of extension pages.
    //
    CExtensionWizard97PageWindow * pew97p = dynamic_cast< CExtensionWizard97PageWindow * >( ppage );
    if (   ((pew97p != NULL) && ! BWizard97())
        || ((pew97p == NULL) && BWizard97()) )
    {
        PlewpAlternate()->insert( PlewpAlternate()->end(), pewp );
    } // if:  trying to add the wrong type of page
    else
    {
        PlewpNormal()->insert( PlewpNormal()->end(), pewp );
    } // else:  adding page of matching type

    return hr;

}  //*** CWizardWindow::HrAddExtensionPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::CompleteAddingExtensionPages
//
//  Routine Description:
//      Complete the process of adding extension pages to the wizard by
//      re-adding dynamic pages.
//
//  Arguments:
//      rldwp       [IN OUT] List of dynamic wizard pages.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::CompleteAddingExtensionPages(
    IN OUT CDynamicWizardPageList & rldwp
    )
{
    //
    // If there are any normal pages, add them here.
    // There will be normal pages if pages of the same type as the wizard
    // were added.
    //
    if ( PlewpNormal()->size() > 0 )
    {
        //
        // Add pages to the sheet.
        //
        if ( m_hWnd != NULL )
        {
            CExtensionWizardPageList::iterator itCurrent = PlewpNormal()->begin();
            CExtensionWizardPageList::iterator itLast = PlewpNormal()->end();

            for ( ; itCurrent != itLast ; itCurrent++ )
            {
                CExtensionWizardPageWindow * pewp = *itCurrent;
                ATLASSERT( pewp != NULL );
                BAddPage( pewp );
            } // for:  each page in the list
        } // if:  sheet is currently being displayed
    } // if:  there are normal pages

    //
    // If there are any alternate pages, add a pre-extension launcher page
    // and a post-extension launcher page.  The pre-extension launcher page
    // will display an alternate wizard of the appropriate type and hide the
    // main wizard before displaying these pages.  After the final page it
    // will display the original sheet and hide the other sheet.  The
    // post-extension launcher page is used to transition between the main
    // wizard and the alternate wizard when moving backwards into the
    // alternate wizard.
    //
    if ( PlewpAlternate()->size() > 0 )
    {
        DLGTEMPLATE *                   pdt         = NULL;
        CAltExtWizardPreLauncherPage *  pelwpPre    = NULL;
        CAltExtWizardPostLauncherPage * pelwpPost   = NULL;

        // Loop to avoid goto's
        do
        {
            //
            // Add the pre-extension launcher page.
            //
            {
                //
                // Create the dialog template.
                //
                pdt = PdtCreateDummyPageDialogTemplate( 10, 10 );
                ATLASSERT( pdt != NULL );
                if ( pdt == NULL )
                {
                    break;
                } // if: error creating the dialog template

                //
                // Allocate and initialize the launcher page.
                //
                pelwpPre = new CAltExtWizardPreLauncherPage( pdt );
                ATLASSERT( pelwpPre != NULL );
                if ( pelwpPre == NULL )
                {
                    break;
                } // if: error allocating the page
                pdt = NULL;
                if ( ! pelwpPre->BInit( this ) )
                {
                    break;
                } // if:  error initializing the page

                //
                // Create the launcher page.
                //
                DWORD sc = pelwpPre->ScCreatePage();
                if ( sc != ERROR_SUCCESS )
                {
                    CNTException nte(
                        sc,
                        ADMC_IDS_INIT_EXT_PAGES_ERROR,
                        NULL,
                        NULL,
                        FALSE
                        );
                    nte.ReportError();
                    break;
                } // if:  error creating the page

                //
                // Add the launcher page to the wizard.
                //
                BAddPage( pelwpPre );
                pelwpPre = NULL;
            } // Add the pre-extension launcher page

            //
            // Add the post-extension launcher page
            //
            {
                //
                // Create the dialog template.
                //
                pdt = PdtCreateDummyPageDialogTemplate( 10, 10 );
                ATLASSERT( pdt != NULL );
                if ( pdt == NULL )
                {
                    break;
                } // if: error creating the dialog template

                //
                // Allocate and initialize the launcher page.
                //
                pelwpPost = new CAltExtWizardPostLauncherPage( pdt );
                ATLASSERT( pelwpPost != NULL );
                if ( pelwpPost == NULL )
                {
                    break;
                } // if: error allocating page
                pdt = NULL;
                if ( ! pelwpPost->BInit( this ) )
                {
                    break;
                } // if:  error initializing the page

                //
                // Create the launcher page.
                //
                DWORD sc = pelwpPost->ScCreatePage();
                if ( sc != ERROR_SUCCESS )
                {
                    CNTException nte(
                        sc,
                        ADMC_IDS_INIT_EXT_PAGES_ERROR,
                        NULL,
                        NULL,
                        FALSE
                        );
                    nte.ReportError();
                    break;
                } // if:  error creating the page

                //
                // Add the launcher page to the wizard.
                //
                BAddPage( pelwpPost );
                pelwpPost = NULL;
            } // Add the post-extension launcher page
        } while ( 0 );

        //
        // Cleanup;
        //
        delete pelwpPre;
        delete pelwpPost;
        delete pdt;
        
    } // if:  there are alternate pages

    //
    // Move all pages from the temporary list to the real list and
    // add them to the end of the wizard.
    //
    CDynamicWizardPageList::iterator itCurrent = rldwp.begin();
    CDynamicWizardPageList::iterator itLast = rldwp.end();
    while ( itCurrent != itLast )
    {
        CDynamicWizardPageWindow * pdwp = *itCurrent;
        ATLASSERT( pdwp != NULL );

        //
        // Create the page.
        //
        DWORD sc = pdwp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte(
                sc,
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            delete pdwp;
            itCurrent = rldwp.erase( itCurrent );
            continue;
        } // if:  error creating the page

        //
        // Add the page to the wizard.
        // This adds it to the real page list as well.
        //
        BAddPage( pdwp );

        //
        // Remove the page from the temporary list.
        //
        itCurrent = rldwp.erase( itCurrent );
    } // while:  not at last page

} //*** CWizardWindow::CompleteAddingExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardWindow::RemoveAllExtensionPages
//
//  Routine Description:
//      Remove all extension pages from the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizardWindow::RemoveAllExtensionPages( void )
{
    //
    // Delete the alternate extension wizard.
    //
    if ( PwizAlternate() != NULL )
    {
        reinterpret_cast< CAltExtWizard * >( PwizAlternate() )->DestroyAlternateWizard();
    } // if:  alternate wizard being displayed

    //
    // Remove the extension pages.
    //
    CExtensionWizardPageList lewp;
    MovePtrListItems< CWizardPageWindow *, CExtensionWizardPageWindow * >( PlwpPages(), &lewp );
    CExtensionWizardPageList::iterator itCurrent = lewp.begin();
    CExtensionWizardPageList::iterator itLast = lewp.end();
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        CExtensionWizardPageWindow * pewp = *itCurrent;
        ATLASSERT( pewp != NULL );
        if ( pewp->Hpage() != NULL )
        {
            RemovePage( pewp->Hpage() );
            pewp->SetPageAdded( FALSE );
        } // if:  page already created
    } // for:  each page in the list
    DeleteAllPtrListItems( &lewp );

} //*** CWizardWindow::RemoveAllExtensionPages()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPreLauncherPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPreLauncherPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page will be displayed if there are pages that are not of the
//      same type as the wizard (e.g. non-Wizard97 pages in a Wizard97
//      wizard).
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPreLauncherPage::OnSetActive( void )
{
    CAltExtWizard * pwizAlt;

    //
    // When moving forward, create the alternate extension wizard and return
    // TRUE so that the main wizard will wait here.  The alternate wizard
    // will cause the proper button to be pressed so we can do the proper
    // thing when we're done.
    //
    // When moving backward, just return FALSE so we won't be displayed.
    //

    //
    // Create the alternate wizard if moving forward.
    //
    if ( Pwiz()->BNextPressed() )
    {
        // We could have got here by pressing 'Back' on the alternate wizard,
        // and then pressing 'Next' on the normal wizard. So, first check if
        // the alternate wizard has already been created.
        if ( Pwiz()->PwizAlternate() == NULL )
        {
            //
            // Create the alternate extension wizard.
            // It is expected that the wizard doesn't exist yet and that there are
            // alternate extension pages to be displayed.
            //
            ATLASSERT( Pwiz()->PlewpAlternate()->size() > 0 );
            pwizAlt = new CAltExtWizard;
            ATLASSERT( pwizAlt != NULL );
            if ( pwizAlt == NULL )
            {
                return FALSE;
            } // if: error allocating the alternate wizard
            Pwiz()->SetAlternateWizard( pwizAlt );

            //
            // Initialize the alternate extension wizard.
            //
            if ( pwizAlt->BInit( Pwiz() ) )
            {
                //
                // Display the alternate extension wizard.
                // The alternate extension wizard is being displayed as a modeless
                // wizard so that when the user presses the Next button in the
                // wizard and then presses the Back button on the next main wizard
                // page we need the wizard to still exist.
                //
                pwizAlt->Create( GetActiveWindow() );

                //
                // Execute the alternate wizard message loop.
                // This required so that tabs and accelerator keys will work.
                //
                pwizAlt->MessageLoop();
            } // if:  wizard initialized successfully

            return TRUE;
        } // if:    alternate wizard does not exist
        else
        {
            //
            // Display the existing alternate wizard.
            // Press the alternate wizard's Next button because it is waiting at 
            // the prefix page.
            //
            pwizAlt = reinterpret_cast< CAltExtWizard * >( Pwiz()->PwizAlternate() );
            pwizAlt->PressButton( PSBTN_NEXT );
            pwizAlt->DisplayAlternateWizard();

            //
            // Execute the alternate wizard message loop.
            // This required so that tabs and accelerator keys will work.
            //
            pwizAlt->MessageLoop();

            return TRUE;
        } // else: alternate wizard exists already
    } // if:  next button pressed
    else
    {
        ATLASSERT( Pwiz()->BBackPressed() );
        return FALSE;
    } // else:  back button pressed

} //*** CAltExtWizardPreLauncherPage::OnSetActive()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPostLauncherPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPostLauncherPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page will be displayed if there are pages that are not of the
//      same type as the wizard (e.g. non-Wizard97 pages in a Wizard97
//      wizard).
//             
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPostLauncherPage::OnSetActive( void )
{
    //
    // When moving forward just return FALSE so that we won't be displayed.
    //
    // When moving backward, display the alternate extension wizard and
    // return TRUE so that we will be waiting for the alternate wizard to
    // move us to the right place.  Press the alternate wizard's Back button
    // because it is waiting at the postfix page.
    //

    if ( Pwiz()->BNextPressed() )
    {
        return FALSE;
    } // if:  moving forward
    else
    {
        ATLASSERT( Pwiz()->BBackPressed() );

        //
        // Display the alternate wizard.
        //
        CAltExtWizard * pwizAlt = reinterpret_cast< CAltExtWizard * >( Pwiz()->PwizAlternate() );
        pwizAlt->PressButton( PSBTN_BACK );
        pwizAlt->DisplayAlternateWizard();

        //
        // Execute the alternate wizard message loop.
        // This required so that tabs and accelerator keys will work.
        //
        pwizAlt->MessageLoop();

        return TRUE;
    } // else:  moving backward

} //*** CAltExtWizardPostLauncherPage::OnSetActive()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizard
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//      This wizard is used to display extension pages that are different
//      than the type of the main wizard, e.g. displaying non-Wizard97 pages
//      in a Wizard97 wizard.  This wizard will have a dummy prefix page
//      and a dummy postfix page, which are only here to handle entering and
//      exiting the wizard.  This routine will add the prefix page, add the
//      alternate extension pages from the main wizard, then add the postfix
//      page.
//
//  Arguments:
//      pwizMain    [IN] Main wizard.
//
//  Return Value:
//      TRUE        Wizard initialized successfully.
//      FALSE       Error initializing wizard.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizard::BInit( IN CWizardWindow * pwizMain )
{
    ATLASSERT( pwizMain != NULL );
    ATLASSERT( m_pwizMain == NULL );

    BOOL bSuccess;

    m_pwizMain = pwizMain;

    //
    // Setup the type of wizard to be the opposite of the main wizard.
    //
    m_psh.dwFlags &= ~PSH_PROPSHEETPAGE; // Using HPROPSHEETPAGEs.
    if ( ! PwizMain()->BWizard97() )
    {
        // Don't add a watermark since we don't have a watermark bitmap.
        m_psh.dwFlags &= ~(PSH_WIZARD
                            | PSH_WATERMARK
                            );
        m_psh.dwFlags |= (PSH_WIZARD97
                            | PSH_HEADER
                            );
    } // if:  Wizard97 wizard
    else
    {
        m_psh.dwFlags |= PSH_WIZARD;
        m_psh.dwFlags &= ~(PSH_WIZARD97
                            | PSH_WATERMARK
                            | PSH_HEADER
                            );
    } // else:  non-Wizard97 wizard

    // Loop to avoid goto's
    do
    {
        //
        // Get the first page in the main wizard.
        //
        HWND hwndChild = PwizMain()->GetWindow( GW_CHILD );
        ATLASSERT( hwndChild != NULL );

        //
        // Get the current width and height of the child window.
        //
        CRect rect;
        bSuccess = ::GetClientRect( hwndChild, &rect );

        if ( ! bSuccess )
        {
            CNTException nte(
                GetLastError(),
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            nte.ReportError();
            break;
        } // if:  error getting client rectangle

        //
        // Add a prefix page.
        //
        bSuccess = BAddPrefixPage( (WORD)rect.Width(), (WORD)rect.Height() );

        if ( ! bSuccess )
        {
            break;
        } // if:  error adding the prefix page

        //
        // Add alternate pages from the main wizard to the wizard page list.
        // They will be added to the wizard at sheet initialization time.
        //
        CExtensionWizardPageList::iterator itCurrent = PwizMain()->PlewpAlternate()->begin();
        CExtensionWizardPageList::iterator itLast = PwizMain()->PlewpAlternate()->end();

        while ( itCurrent != itLast )
        {
            CExtensionWizardPageWindow * pewp = *itCurrent;
            ATLASSERT( pewp != NULL );
            PlwpPages()->insert( PlwpPages()->end(), pewp );
            PwizMain()->PlewpAlternate()->erase( itCurrent );
            itCurrent = PwizMain()->PlewpAlternate()->begin();
        } // for:  each page in the list

        //
        // Add a postfix page.
        //
        bSuccess = BAddPostfixPage( (WORD) rect.Width(), (WORD) rect.Height() );
        if ( ! bSuccess )
        {
            break;
        } // if:  error adding the postfix page
    } while ( 0 );

    //
    // Call the base class.
    //
    if ( ! baseClass::BInit() )
    {
        return FALSE;
    } // if:  error initializing the base class

    return bSuccess;

} //*** CAltExtWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::BAddPrefixPage
//
//  Routine Description:
//      Add a prefix page to the wizard.
//
//  Arguments:
//      cx          [IN] Width of the page.
//      cy          [IN] Height of the page.
//
//  Return Value:
//      TRUE        Page added successfully.
//      FALSE       Error adding the page.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizard::BAddPrefixPage( IN WORD cx, IN WORD cy )
{
    ATLASSERT( cx > 0 );
    ATLASSERT( cy > 0 );

    BOOL                        bSuccess;
    DLGTEMPLATE *               pdt = NULL;
    CAltExtWizardPrefixPage *   pwp = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Create the dialog template for the page.
        //
        pdt = PdtCreateDummyPageDialogTemplate( cx, cy );
        ATLASSERT( pdt != NULL );
        if ( pdt == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error creating the dialog template

        //
        // Adjust the page size so that we will be creating the same size
        // wizard as the main wizard.  Non-Wizard97 wizards add padding
        // (7 DLUs on each side) whereas Wizard97 wizards add no padding
        // to the first page, which is where we are expecting these
        // dimensions to come from.
        //
        if ( BWizard97() )
        {
            pdt->cx += 7 * 2;
            pdt->cy += 7 * 2;
        } // if:  Wizard97 wizard
        else
        {
            pdt->cx -= 7 * 2;
            pdt->cy -= 7 * 2;
        } // else:  non-Wizard97 wizard

        //
        // Allocate and initialize the page.
        //
        pwp = new CAltExtWizardPrefixPage( pdt );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error allocating the page
        pdt = NULL;
        bSuccess = pwp->BInit( this );
        if ( ! bSuccess )
        {
            break;
        } // if:  error initializing the page

        //
        // Create the page.
        //
        DWORD sc = pwp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte(
                sc,
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            nte.ReportError();
            bSuccess = FALSE;
            break;
        } // if:  error creating the page

        //
        // Add the page to the wizard.
        //
        bSuccess = BAddPage( pwp );
        pwp = NULL;
    } while ( 0 );

    delete pwp;
    delete pdt;

    return bSuccess;

} //*** CAltExtWizard::BAddPrefixPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::BAddPostfixPage
//
//  Routine Description:
//      Add a postfix page to the wizard.
//
//  Arguments:
//      cx          [IN] Width of the page.
//      cy          [IN] Height of the page.
//
//  Return Value:
//      TRUE        Page added successfully.
//      FALSE       Error adding the page.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizard::BAddPostfixPage( IN WORD cx, IN WORD cy )
{
    ATLASSERT( cx > 0 );
    ATLASSERT( cy > 0 );

    BOOL                        bSuccess;
    DLGTEMPLATE *               pdt = NULL;
    CAltExtWizardPostfixPage *  pwp = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Create the dialog template for the page.
        //
        pdt = PdtCreateDummyPageDialogTemplate( cx, cy );
        ATLASSERT( pdt != NULL );
        if ( pdt == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error creating the dialog template

        //
        // Adjust the page size so that we will be creating the same size
        // wizard as the main wizard.  Non-Wizard97 wizards add padding
        // (7 DLUs on each side) whereas Wizard97 wizards add no padding
        // to the first page, which is where we are expecting these
        // dimensions to come from.
        //
        if ( BWizard97() )
        {
            pdt->cx += 7 * 2;
            pdt->cy += 7 * 2;
        } // if:  Wizard97 wizard
        else
        {
            pdt->cx -= 7 * 2;
            pdt->cy -= 7 * 2;
        } // else:  non-Wizard97 wizard

        //
        // Allocate and initialize the page.
        //
        pwp = new CAltExtWizardPostfixPage( pdt );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            bSuccess = FALSE;
            break;
        } // if: error allocating the page
        pdt = NULL;
        bSuccess = pwp->BInit( this );
        if ( ! bSuccess )
        {
            break;
        } // if:  error initializing the page

        //
        // Create the page.
        //
        DWORD sc = pwp->ScCreatePage();
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte(
                sc,
                ADMC_IDS_INIT_EXT_PAGES_ERROR,
                NULL,
                NULL,
                FALSE
                );
            nte.ReportError();
            bSuccess = FALSE;
            break;
        } // if:  error creating the page

        //
        // Add the page to the page list.  It will be added to the wizard
        // at sheet initialization time.
        //
        PlwpPages()->insert( PlwpPages()->end(), pwp );
        pwp = NULL;

        bSuccess = TRUE;
    } while ( 0 );

    delete pwp;
    delete pdt;

    return bSuccess;

} //*** CAltExtWizard::BAddPostfixPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::DisplayAlternateWizard
//
//  Routine Description:
//      Display the alternate wizard.  This involved the following steps:
//      -- Move the alternate wizard to the position of the main wizard.
//      -- Show the alternate wizard.
//      -- Hide the main wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::DisplayAlternateWizard( void )
{
    //
    // Move the alternate wizard to where the main wizard is positioned.
    //
    CRect rectMain;
    CRect rectAlt;
    CRect rectNew;
    if ( PwizMain()->GetWindowRect( &rectMain ) )
    {
        if ( GetWindowRect( &rectAlt ) )
        {
            //ATLTRACE( _T("CAltExtWizard::DisplayAlternateWizard() - Main = (%d,%d) (%d,%d) Alt = (%d,%d) (%d,%d)\n"),
            //  rectMain.left, rectMain.right, rectMain.top, rectMain.bottom,
            //  rectAlt.left, rectAlt.right, rectAlt.top, rectAlt.bottom );
            rectNew.left = rectMain.left;
            rectNew.top = rectMain.top;
            rectNew.right = rectNew.left + rectAlt.Width();
            rectNew.bottom = rectNew.top + rectAlt.Height();
            MoveWindow( &rectNew );
        } // if:  got the alternate wizard's window rectangle successfully
    } // if:  got the main wizard's window rectangle successfully

    //
    // Show the alternate wizard and hide the main wizard.
    //
    ShowWindow( SW_SHOW );
    PwizMain()->ShowWindow( SW_HIDE );
    SetActiveWindow();
    PwizMain()->SetCurrentWizard( this );

} //*** CAltExtWizard::DisplayAlternateWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::DisplayMainWizard
//
//  Routine Description:
//      Display the main wizard.  This involved the following steps:
//      -- Move the main wizard to the position of the alternate wizard.
//      -- Show the main wizard.
//      -- Hide the alternate wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::DisplayMainWizard( void )
{
    //
    // Move the main wizard to where the alternate wizard is positioned.
    //
    CRect rectMain;
    CRect rectAlt;
    CRect rectNew;
    if ( PwizMain()->GetWindowRect( &rectMain ) )
    {
        if ( GetWindowRect( &rectAlt ) )
        {
            //ATLTRACE( _T("CAltExtWizard::DisplayMainWizard() - Main = (%d,%d) (%d,%d) Alt = (%d,%d) (%d,%d)\n"),
            //  rectMain.left, rectMain.right, rectMain.top, rectMain.bottom,
            //  rectAlt.left, rectAlt.right, rectAlt.top, rectAlt.bottom );
            rectNew.left = rectAlt.left;
            rectNew.top = rectAlt.top;
            rectNew.right = rectNew.left + rectMain.Width();
            rectNew.bottom = rectNew.top + rectMain.Height();
            PwizMain()->MoveWindow( &rectNew );
        } // if:  got the alternate wizard's window rectangle successfully
    } // if:  got the main wizard's window rectangle successfully

    //
    // Show the main wizard and hide the alternate wizard.
    //
    PwizMain()->ShowWindow( SW_SHOW );
    PwizMain()->SetActiveWindow();
    ShowWindow( SW_HIDE );
    PwizMain()->SetCurrentWizard( PwizMain() );

} //*** CAltExtWizard::DisplayMainWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::DestroyAlternateWizard
//
//  Routine Description:
//      Destroy the alternate extension wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::DestroyAlternateWizard( void )
{
    ATLASSERT( m_hWnd != NULL );

    //
    // Press the Cancel button on the alternate wizard.
    //
    PressButton( PSBTN_CANCEL );

    //
    // Destroy the wizard.
    //
    DestroyWindow();

} //*** CAltExtWizard::DestroyAlternateWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizard::MessageLoop
//
//  Routine Description:
//      Message loop for this wizard as a modeless wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAltExtWizard::MessageLoop( void )
{
    MSG     msg;

    m_bExitMsgLoop = FALSE;
    while (    (GetActivePage() != NULL)
            && GetMessage( &msg, NULL, 0, 0 ) )
    {
        //
        // Ask the wizard if it wants to process it.  If not, go ahead
        // and translate it and dispatch it.
        //
        if ( ! IsDialogMessage( &msg ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        } // if:  not a property sheet dialog message

        //
        // If the dialog is done, exit this loop.
        //
        if ( BExitMessageLoop() )
        {
            DisplayMainWizard();
            PwizMain()->PostMessage( PSM_PRESSBUTTON, NExitButton(), 0 );
            break;
        } // if:  exiting the wizard
    } // while:  active page and not quitting

} //*** CAltExtWizard::MessageLoop()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPrefixPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPrefixPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page manages the transfer of control between the main wizard
//      and the first page of the alternate wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPrefixPage::OnSetActive( void )
{
    //
    // When moving forward, display the alternate wizard and return FALSE
    // so that this page won't be displayed.
    //
    // When moving backward, display the main wizard and return TRUE so that
    // we'll be waiting for the main wizard to do something with us.
    //

    if ( Pwiz()->BBackPressed() )
    {
        PwizThis()->ExitMessageLoop( PSBTN_BACK );
        return TRUE;
    } // if:  moving backward
    else
    {
        PwizThis()->DisplayAlternateWizard();
        return FALSE;
    } // if:  moving forward

} //*** CAltExtWizardPrefixPage::OnSetActive()


//*************************************************************************//


////////////////////////////////////////////////////////////////////////////
// class CAltExtWizardPostfixPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CAltExtWizardPostfixPage::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//      This page manages the transfer of control between the main wizard
//      and the last page of the alternate wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAltExtWizardPostfixPage::OnSetActive( void )
{
    //
    // When moving forward display the main wizard and return TRUE so that
    // we'll be waiting for the main wizard to tell us what to do next.
    //
    // This routine should never be called when moving backward.
    //

    ATLASSERT( Pwiz()->BNextPressed() );

    //
    // Display the main wizard.
    //
    PwizThis()->ExitMessageLoop( PSBTN_NEXT );
    return TRUE;

} //*** CAltExtWizardPostfixPage::OnSetActive()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  PdtCreateDummyPageDialogTemplate
//
//  Routine Description:
//      Create a dialog template in memory for use on a dummy page.
//
//  Arguments:
//      cx              [IN] Width of the dialog in pixels.
//      cy              [IN] Height of the dialog in pixels.
//
//  Return Value:
//      ppDlgTemplate   Dialog template.
//
//--
/////////////////////////////////////////////////////////////////////////////
DLGTEMPLATE * PdtCreateDummyPageDialogTemplate( IN WORD cx, IN WORD cy )
{
    static const WCHAR s_szFontName[] = L"MS Shell Dlg";
    struct FULLDLGTEMPLATE : public DLGTEMPLATE
    {
        WORD        nMenuID;
        WORD        nClassID;
        WORD        nTitle;
        WORD        nFontSize;
        WCHAR       szFontName[ RTL_NUMBER_OF( s_szFontName ) ];
    };
    HRESULT hr;

    FULLDLGTEMPLATE * pDlgTemplate = new FULLDLGTEMPLATE;
    ATLASSERT( pDlgTemplate != NULL );
    if ( pDlgTemplate != NULL )
    {
        pDlgTemplate->style = WS_CHILD | WS_DISABLED | WS_SYSMENU | DS_SETFONT;
        pDlgTemplate->dwExtendedStyle = 0;
        pDlgTemplate->cdit = 0;
        pDlgTemplate->x = 0;
        pDlgTemplate->y = 0;
        pDlgTemplate->cx = ((cx * 2) + (3 / 2)) / 3; // round off
        pDlgTemplate->cy = ((cy * 8) + (13 / 2)) / 13; // round off
        pDlgTemplate->nMenuID = 0;
        pDlgTemplate->nClassID = 0;
        pDlgTemplate->nTitle = 0;
        pDlgTemplate->nFontSize = 8;
        hr = StringCchCopyNW( pDlgTemplate->szFontName, RTL_NUMBER_OF( pDlgTemplate->szFontName ), s_szFontName, RTL_NUMBER_OF( s_szFontName ) );
        ATLASSERT( SUCCEEDED( hr ) );
    } // if: dialog template allocated successfully

    return pDlgTemplate;

} //*** PdtCreateDummyPageDialogTemplate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlbasewiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWiz.h
//
//	Implementation File:
//		AtlBaseWiz.cpp
//
//	Description:
//		Definition of the CWizardWindow and CWizardImpl classes.
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEWIZ_H_
#define __ATLBASEWIZ_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters in the browser information

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardWindow;
template < class T, class TBase > class CWizardImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardPageWindow;
class CWizardPageList;
class CDynamicWizardPageList;
class CExtensionWizardPageList;
class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#include "AdmCommonRes.h"	// for ID_WIZNEXT, etc.
#endif

#ifndef __ATLBASESHEET_H_
#include "AtlBaseSheet.h"	// for CBaseSheetWindow
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardWindow
//
//	Description:
//		Base wizard property sheet window.
//
//	Inheritance:
//		CWizardWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWizardWindow : public CBaseSheetWindow
{
	typedef CBaseSheetWindow baseClass;

	friend class CWizardPageWindow;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardWindow( HWND hWnd = NULL )
		: baseClass( hWnd )
		, m_plwpPages( NULL )
		, m_plewpNormal( NULL )
		, m_plewpAlternate( NULL )
		, m_pwizAlternate( NULL )
		, m_pcoObjectToExtend( NULL )
		, m_nLastWizardButton( 0 )
	{
		m_pwizCurrent = this;

	} //*** CWizardWindow()

	// Destructor
	~CWizardWindow( void );

protected:
	CWizardPageList *			m_plwpPages;			// List of pages in the wizard.
	CExtensionWizardPageList *	m_plewpNormal;			// List of normal extension pages.
	CExtensionWizardPageList *	m_plewpAlternate;		// List of alternate extension pages.
	CWizardWindow *				m_pwizAlternate;		// Alternate extension wizard.
	CWizardWindow *				m_pwizCurrent;			// Currently visible wizard.
	CClusterObject *			m_pcoObjectToExtend;	// Cluster object to extend.
	int							m_nLastWizardButton;	// Indicates the last wizard button pressed.

public:
	//
	// Access methods.
	//

	// Access list of pages in the wizard
	CWizardPageList * PlwpPages( void )
	{
		ATLASSERT( m_plwpPages != NULL );
		return m_plwpPages;

	} //*** PlwpPages()

	// Access list of normal extension pages
	CExtensionWizardPageList * PlewpNormal( void ) { return m_plewpNormal; }

	// Access list of alternate extension pages
	CExtensionWizardPageList * PlewpAlternate( void ) { return m_plewpAlternate; }

	// Access alternate extension wizard
	CWizardWindow * PwizAlternate( void ) { return m_pwizAlternate; }

	// Access currently visible wizard
	CWizardWindow * PwizCurrent( void ) { return m_pwizCurrent; }

	// Set the current wizard
	void SetCurrentWizard( CWizardWindow * pwizCurrent )
	{
		ATLASSERT( pwizCurrent != NULL );
		ATLASSERT( ( pwizCurrent == this ) || ( pwizCurrent == m_pwizAlternate ) );
		m_pwizCurrent = pwizCurrent;

	} //*** SetCurrentWizard()

	// Set the alternate extension wizard
	void SetAlternateWizard( IN CWizardWindow * pwiz )
	{
		ATLASSERT( pwiz != NULL );
		m_pwizAlternate = pwiz;

	} //*** SetAlternateWizard()

	// Delete the alternate extension wizard
	void DeleteAlternateWizard( void )
	{
		ATLASSERT( m_pwizAlternate != NULL );
		ATLASSERT( m_pwizCurrent != m_pwizAlternate );
		delete m_pwizAlternate;
		m_pwizAlternate = NULL;

	} //*** ClearAlternateWizard()

	// Access the cluster object to extend
	CClusterObject * PcoObjectToExtend( void ) { return m_pcoObjectToExtend; }

	// Set the object to extend
	void SetObjectToExtend( IN CClusterObject * pco )
	{
		ATLASSERT( pco != NULL );
		m_pcoObjectToExtend = pco;

	} //*** SetObjectToExtend()

	// Returns the last wizard button pressed
	int NLastWizardButton( void ) const { return m_nLastWizardButton; }

	// Set the last wizard button pressed
	void SetLastWizardButton( IN int idCtrl )
	{
		ATLASSERT( (idCtrl == ID_WIZBACK) || (idCtrl == ID_WIZNEXT) || (idCtrl == IDCANCEL) );
		m_nLastWizardButton = idCtrl;

	} //*** SetLastWizardButton()

	// Returns whether the Back button was pressed
	BOOL BBackPressed( void ) const { return (m_nLastWizardButton == ID_WIZBACK); }

	// Returns whether the Next button was pressed
	BOOL BNextPressed( void ) const { return (m_nLastWizardButton == ID_WIZNEXT); }

	// Returns whether the Cancel button was pressed
	BOOL BCancelPressed( void ) const { return (m_nLastWizardButton == IDCANCEL); }

	// Returns whether the wizard is Wizard97 compliant or not
	BOOL BWizard97( void ) const { return (Ppsh()->dwFlags & PSH_WIZARD97) == PSH_WIZARD97; }

public:
	// Add a page (required to get to base class method)
	void AddPage( HPROPSHEETPAGE hPage )
	{
		CBaseSheetWindow::AddPage( hPage );

	} //*** AddPage( hPage )

	// Add a page (required to get to base class method)
	BOOL AddPage( LPCPROPSHEETPAGE pPage )
	{
		return CBaseSheetWindow::AddPage( pPage );

	} //*** AddPage( pPage )

	// Add a page to wizard
	BOOL BAddPage( IN CWizardPageWindow * pwp );

	// Set the next page to be displayed
	void SetNextPage( IN CWizardPageWindow * pwCurrentPage, IN LPCTSTR pszNextPage );

	// Set the next page to be displayed from a dialog ID
	void SetNextPage( IN CWizardPageWindow * pwCurrentPage, IN UINT idNextPage )
	{
		SetNextPage( pwCurrentPage, MAKEINTRESOURCE( idNextPage ) );

	} //*** SetNextPage( idNextPage )

	// Handler for BN_CLICKED for ID_WIZFINISH
	LRESULT OnWizFinish(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		EnumChildWindows( m_hWnd, &ECWCallback, (LPARAM) this );

		if ( m_pwizAlternate != NULL )
		{
			return m_pwizAlternate->OnWizFinish( wNotifyCode, idCtrl, hwndCtrl, bHandled );
		} // if: alternate wizard exists

		bHandled = FALSE;
		return FALSE;

	} //*** OnWizFinish()

	static BOOL CALLBACK ECWCallback( HWND hWnd, LPARAM lParam )
	{
		CWizardWindow *pww = (CWizardWindow *) lParam;
		NMHDR nmhdr;

		// If we enumerated ourself, skip
		if ( pww->m_hWnd == hWnd )
		{
			return TRUE;
		} // if: enumerating ourself

		nmhdr.hwndFrom = pww->m_hWnd;
		nmhdr.idFrom = 0;
		nmhdr.code = PSN_WIZFINISH;

		SendMessage( hWnd, WM_NOTIFY, 0, (LPARAM) &nmhdr );

		return TRUE;

	} //*** ECWCallback()


public:
	//
	// CWizardWindow methods.
	//

	// Enable or disable the Next button
	void EnableNext( IN BOOL bEnable, IN DWORD fDefaultWizardButtons )
	{
		ATLASSERT( fDefaultWizardButtons != 0 );

		//
		// If there is an alternate wizard, send this message to it.
		//
		if ( PwizCurrent() == PwizAlternate() )
		{
			PwizAlternate()->EnableNext( bEnable, fDefaultWizardButtons );
		} // if:  there is an alternate wizard
		else
		{
			//
			// Get the buttons for the wizard.
			//
			DWORD fWizardButtons = fDefaultWizardButtons;

			//
			// If the Next button is to be disabled, make sure we show a
			// disabled Finish button if the Finish button is supposed to be
			// displayed.  Otherwise a disabled Next button will be displayed.
			//
			if ( ! bEnable )
			{
				fWizardButtons &= ~(PSWIZB_NEXT | PSWIZB_FINISH);
				if ( fDefaultWizardButtons & PSWIZB_FINISH )
				{
					fWizardButtons |= PSWIZB_DISABLEDFINISH;
				} // if:  finish button displayed
			}  // if:  disabling the button

			//
			// Set the new button states.
			//
			SetWizardButtons( fWizardButtons );

		} // else:  no alternate wizard

	} //*** EnableNext()

public:
	//
	// Overrides of abstract methods.
	//

	// Add extension pages to the sheet
	virtual void AddExtensionPages( IN HFONT hfont, IN HICON hicon );

	// Add a page (called by extension)
	virtual HRESULT HrAddExtensionPage( IN CBasePageWindow * ppage );

	// Handle a reset from one of the pages
	virtual void OnReset( void )
	{
	} //*** OnReset()

public:
	//
	// Message handler functions.
	//

	// Handler for PSCB_INITIALIZED
	void OnSheetInitialized( void );

// Implementation
protected:
	// Prepare to add exension pages to the wizard
	void PrepareToAddExtensionPages( IN OUT CDynamicWizardPageList & rldwp );

	// Complete the process of adding extension pages
	void CompleteAddingExtensionPages( IN OUT CDynamicWizardPageList & rldwp );

	// Remove all extension pages from the wizard
	void RemoveAllExtensionPages( void );

}; //*** class CWizardWindow

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWizardImpl
//
//	Description:
//		Base wizard property sheet implementation.
//
//	Inheritance:
//		CWizardImpl< T, TBase >
//		CBaseSheetImpl< T, TBase >
//		CPropertySheetImpl< T, TBase >
//		<TBase>
//		...
//		CWizardWindow
//		CBaseSheetWindow
//		CPropertySheetWindow
//
//--		
/////////////////////////////////////////////////////////////////////////////

template < class T, class TBase = CWizardWindow >
class CWizardImpl : public CBaseSheetImpl< T, TBase >
{
	typedef CWizardImpl< T, TBase > thisClass;
	typedef CBaseSheetImpl< T, TBase > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizardImpl(
		IN LPCTSTR	lpszTitle = NULL,
		IN UINT		uStartPage = 0
		)
		: CBaseSheetImpl< T, TBase >( lpszTitle, uStartPage )
	{
		// Make this sheet a wizard.
		SetWizardMode();

		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CWizardImpl( lpszTitle )

	// Constructor taking a resource ID for the title
	CWizardImpl(
		IN UINT nIDTitle,
		IN UINT uStartPage = 0
		)
		: CBaseSheetImpl< T, TBase >( NULL, uStartPage )
	{
		m_strTitle.LoadString( nIDTitle );
		m_psh.pszCaption = m_strTitle;

		// Make this sheet a wizard.
		SetWizardMode();

		// Set the pointer in the base window class to our prop sheet header.
		m_ppsh = &m_psh;

	} //*** CWizardImpl( nIDTitle )

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( thisClass )
		COMMAND_HANDLER( ID_WIZBACK, BN_CLICKED, OnButtonPressed )
		COMMAND_HANDLER( ID_WIZNEXT, BN_CLICKED, OnButtonPressed )
		COMMAND_HANDLER( ID_WIZFINISH, BN_CLICKED, OnWizFinish )
		COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnButtonPressed )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	//
	// Message handler functions.
	//

	// Handler for BN_CLICKED on wizard buttons
	LRESULT OnButtonPressed(
		WORD wNotifyCode,
		WORD idCtrl,
		HWND hwndCtrl,
		BOOL & bHandled
		)
	{
		m_nLastWizardButton = idCtrl;
		bHandled = FALSE;
		return 0;

	} //*** OnButtonPressed()

// Implementation
protected:
	CString			m_strTitle;				// Used to support resource IDs for the title.

public:
	const CString &	StrTitle( void ) const			{ return m_strTitle; }

	// Set the title of the sheet
	void SetTitle( LPCTSTR lpszText, UINT nStyle = 0 )
	{
		baseClass::SetTitle( lpszText, nStyle );
		m_strTitle = lpszText;

	} //*** SetTitle()

}; //*** class CWizardImpl

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

// Create a dialog template for use with a dummy page
DLGTEMPLATE * PdtCreateDummyPageDialogTemplate( IN WORD cx, IN WORD cy );

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASEWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atldbgwin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlDbgWin.cpp
//
//  Abstract:
//      Implementation of the ATL window debugging functions.
//
//  Author:
//      David Potter (davidp)   June 2, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlDbgWin.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
extern const ID_MAP_ENTRY s_rgmapWindowMsgs[];
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapWindowMsgs[] =
{
    DECLARE_ID_STRING( WM_NULL )
    DECLARE_ID_STRING( WM_CREATE )
    DECLARE_ID_STRING( WM_DESTROY )
    DECLARE_ID_STRING( WM_MOVE )
    DECLARE_ID_STRING( WM_SIZE )
    DECLARE_ID_STRING( WM_ACTIVATE )
    DECLARE_ID_STRING( WM_SETFOCUS )
    DECLARE_ID_STRING( WM_KILLFOCUS )
    DECLARE_ID_STRING( WM_ENABLE )
    DECLARE_ID_STRING( WM_SETREDRAW )
    DECLARE_ID_STRING( WM_SETTEXT )
    DECLARE_ID_STRING( WM_GETTEXT )
    DECLARE_ID_STRING( WM_GETTEXTLENGTH )
    DECLARE_ID_STRING( WM_PAINT )
    DECLARE_ID_STRING( WM_CLOSE )
#ifndef _WIN32_WCE
    DECLARE_ID_STRING( WM_QUERYENDSESSION )
    DECLARE_ID_STRING( WM_QUERYOPEN )
    DECLARE_ID_STRING( WM_ENDSESSION )
#endif // _WIN32_WCE
    DECLARE_ID_STRING( WM_QUIT )
    DECLARE_ID_STRING( WM_ERASEBKGND )
    DECLARE_ID_STRING( WM_SYSCOLORCHANGE )
    DECLARE_ID_STRING( WM_SHOWWINDOW )
    DECLARE_ID_STRING_EX( WM_WININICHANGE, _T(" / WM_SETTINGCHANGE") )
    DECLARE_ID_STRING( WM_DEVMODECHANGE )
    DECLARE_ID_STRING( WM_ACTIVATEAPP )
    DECLARE_ID_STRING( WM_FONTCHANGE )
    DECLARE_ID_STRING( WM_TIMECHANGE )
    DECLARE_ID_STRING( WM_CANCELMODE )
    DECLARE_ID_STRING( WM_SETCURSOR )
    DECLARE_ID_STRING( WM_MOUSEACTIVATE )
    DECLARE_ID_STRING( WM_CHILDACTIVATE )
    DECLARE_ID_STRING( WM_QUEUESYNC )
    DECLARE_ID_STRING( WM_GETMINMAXINFO )
    DECLARE_ID_STRING( WM_PAINTICON )
    DECLARE_ID_STRING( WM_ICONERASEBKGND )
    DECLARE_ID_STRING( WM_NEXTDLGCTL )
    DECLARE_ID_STRING( WM_SPOOLERSTATUS )
    DECLARE_ID_STRING( WM_DRAWITEM )
    DECLARE_ID_STRING( WM_MEASUREITEM )
    DECLARE_ID_STRING( WM_DELETEITEM )
    DECLARE_ID_STRING( WM_VKEYTOITEM )
    DECLARE_ID_STRING( WM_CHARTOITEM )
    DECLARE_ID_STRING( WM_SETFONT )
    DECLARE_ID_STRING( WM_GETFONT )
    DECLARE_ID_STRING( WM_SETHOTKEY )
    DECLARE_ID_STRING( WM_GETHOTKEY )
    DECLARE_ID_STRING( WM_QUERYDRAGICON )
    DECLARE_ID_STRING( WM_COMPAREITEM )
#ifndef _WIN32_WCE
    DECLARE_ID_STRING( WM_GETOBJECT )
#endif // _WIN32_WCE
    DECLARE_ID_STRING( WM_COMPACTING )
    DECLARE_ID_STRING( WM_COMMNOTIFY )
    DECLARE_ID_STRING( WM_WINDOWPOSCHANGING )
    DECLARE_ID_STRING( WM_WINDOWPOSCHANGED )
    DECLARE_ID_STRING( WM_POWER )
    DECLARE_ID_STRING( WM_COPYDATA )
    DECLARE_ID_STRING( WM_CANCELJOURNAL )
    DECLARE_ID_STRING( WM_NOTIFY )
    DECLARE_ID_STRING( WM_INPUTLANGCHANGEREQUEST )
    DECLARE_ID_STRING( WM_INPUTLANGCHANGE )
    DECLARE_ID_STRING( WM_TCARD )
    DECLARE_ID_STRING( WM_HELP )
    DECLARE_ID_STRING( WM_USERCHANGED )
    DECLARE_ID_STRING( WM_NOTIFYFORMAT )
    DECLARE_ID_STRING( WM_CONTEXTMENU )
    DECLARE_ID_STRING( WM_STYLECHANGING )
    DECLARE_ID_STRING( WM_STYLECHANGED )
    DECLARE_ID_STRING( WM_DISPLAYCHANGE )
    DECLARE_ID_STRING( WM_GETICON )
    DECLARE_ID_STRING( WM_SETICON )
    DECLARE_ID_STRING( WM_NCCREATE )
    DECLARE_ID_STRING( WM_NCDESTROY )
    DECLARE_ID_STRING( WM_NCCALCSIZE )
    DECLARE_ID_STRING( WM_NCHITTEST )
    DECLARE_ID_STRING( WM_NCPAINT )
    DECLARE_ID_STRING( WM_NCACTIVATE )
    DECLARE_ID_STRING( WM_GETDLGCODE )
#ifndef _WIN32_WCE
    DECLARE_ID_STRING( WM_SYNCPAINT )
#endif // _WIN32_WCE
    DECLARE_ID_STRING( WM_NCMOUSEMOVE )
    DECLARE_ID_STRING( WM_NCLBUTTONDOWN )
    DECLARE_ID_STRING( WM_NCLBUTTONUP )
    DECLARE_ID_STRING( WM_NCLBUTTONDBLCLK )
    DECLARE_ID_STRING( WM_NCRBUTTONDOWN )
    DECLARE_ID_STRING( WM_NCRBUTTONUP )
    DECLARE_ID_STRING( WM_NCRBUTTONDBLCLK )
    DECLARE_ID_STRING( WM_NCMBUTTONDOWN )
    DECLARE_ID_STRING( WM_NCMBUTTONUP )
    DECLARE_ID_STRING( WM_NCMBUTTONDBLCLK )
    DECLARE_ID_STRING( WM_KEYDOWN )
    DECLARE_ID_STRING( WM_KEYUP )
    DECLARE_ID_STRING( WM_CHAR )
    DECLARE_ID_STRING( WM_DEADCHAR )
    DECLARE_ID_STRING( WM_SYSKEYDOWN )
    DECLARE_ID_STRING( WM_SYSKEYUP )
    DECLARE_ID_STRING( WM_SYSCHAR )
    DECLARE_ID_STRING( WM_SYSDEADCHAR )
    DECLARE_ID_STRING( WM_IME_STARTCOMPOSITION )
    DECLARE_ID_STRING( WM_IME_ENDCOMPOSITION )
    DECLARE_ID_STRING( WM_IME_COMPOSITION )
    DECLARE_ID_STRING( WM_INITDIALOG )
    DECLARE_ID_STRING( WM_COMMAND )
    DECLARE_ID_STRING( WM_SYSCOMMAND )
    DECLARE_ID_STRING( WM_TIMER )
    DECLARE_ID_STRING( WM_HSCROLL )
    DECLARE_ID_STRING( WM_VSCROLL )
    DECLARE_ID_STRING( WM_INITMENU )
    DECLARE_ID_STRING( WM_INITMENUPOPUP )
    DECLARE_ID_STRING( WM_MENUSELECT )
    DECLARE_ID_STRING( WM_MENUCHAR )
    DECLARE_ID_STRING( WM_ENTERIDLE )
#ifndef _WIN32_WCE
    DECLARE_ID_STRING( WM_MENURBUTTONUP )
    DECLARE_ID_STRING( WM_MENUDRAG )
    DECLARE_ID_STRING( WM_MENUGETOBJECT )
    DECLARE_ID_STRING( WM_UNINITMENUPOPUP )
    DECLARE_ID_STRING( WM_MENUCOMMAND )
#ifndef _WIN32_WCE
    DECLARE_ID_STRING( WM_KEYBOARDCUES )
#endif // _WIN32_WCE
#endif // _WIN32_WCE
    DECLARE_ID_STRING( WM_CTLCOLORMSGBOX )
    DECLARE_ID_STRING( WM_CTLCOLOREDIT )
    DECLARE_ID_STRING( WM_CTLCOLORLISTBOX )
    DECLARE_ID_STRING( WM_CTLCOLORBTN )
    DECLARE_ID_STRING( WM_CTLCOLORDLG )
    DECLARE_ID_STRING( WM_CTLCOLORSCROLLBAR )
    DECLARE_ID_STRING( WM_CTLCOLORSTATIC )
    DECLARE_ID_STRING( WM_MOUSEMOVE )
    DECLARE_ID_STRING( WM_LBUTTONDOWN )
    DECLARE_ID_STRING( WM_LBUTTONUP )
    DECLARE_ID_STRING( WM_LBUTTONDBLCLK )
    DECLARE_ID_STRING( WM_RBUTTONDOWN )
    DECLARE_ID_STRING( WM_RBUTTONUP )
    DECLARE_ID_STRING( WM_RBUTTONDBLCLK )
    DECLARE_ID_STRING( WM_MBUTTONDOWN )
    DECLARE_ID_STRING( WM_MBUTTONUP )
    DECLARE_ID_STRING( WM_MBUTTONDBLCLK )
    DECLARE_ID_STRING( WM_MOUSEWHEEL )
    DECLARE_ID_STRING( WM_PARENTNOTIFY )
    DECLARE_ID_STRING( WM_ENTERMENULOOP )
    DECLARE_ID_STRING( WM_EXITMENULOOP )
    DECLARE_ID_STRING( WM_NEXTMENU )
    DECLARE_ID_STRING( WM_SIZING )
    DECLARE_ID_STRING( WM_CAPTURECHANGED )
    DECLARE_ID_STRING( WM_MOVING )
    DECLARE_ID_STRING( WM_POWERBROADCAST )
    DECLARE_ID_STRING( WM_DEVICECHANGE )
    DECLARE_ID_STRING( WM_MDICREATE )
    DECLARE_ID_STRING( WM_MDIDESTROY )
    DECLARE_ID_STRING( WM_MDIACTIVATE )
    DECLARE_ID_STRING( WM_MDIRESTORE )
    DECLARE_ID_STRING( WM_MDINEXT )
    DECLARE_ID_STRING( WM_MDIMAXIMIZE )
    DECLARE_ID_STRING( WM_MDITILE )
    DECLARE_ID_STRING( WM_MDICASCADE )
    DECLARE_ID_STRING( WM_MDIICONARRANGE )
    DECLARE_ID_STRING( WM_MDIGETACTIVE )
    DECLARE_ID_STRING( WM_MDISETMENU )
    DECLARE_ID_STRING( WM_ENTERSIZEMOVE )
    DECLARE_ID_STRING( WM_EXITSIZEMOVE )
    DECLARE_ID_STRING( WM_DROPFILES )
    DECLARE_ID_STRING( WM_MDIREFRESHMENU )
    DECLARE_ID_STRING( WM_IME_SETCONTEXT )
    DECLARE_ID_STRING( WM_IME_NOTIFY )
    DECLARE_ID_STRING( WM_IME_CONTROL )
    DECLARE_ID_STRING( WM_IME_COMPOSITIONFULL )
    DECLARE_ID_STRING( WM_IME_SELECT )
    DECLARE_ID_STRING( WM_IME_CHAR )
    DECLARE_ID_STRING( WM_IME_REQUEST )
    DECLARE_ID_STRING( WM_IME_KEYDOWN )
    DECLARE_ID_STRING( WM_IME_KEYUP )
    DECLARE_ID_STRING( WM_MOUSEHOVER )
    DECLARE_ID_STRING( WM_MOUSELEAVE )
    DECLARE_ID_STRING( WM_NCMOUSEHOVER )
    DECLARE_ID_STRING( WM_NCMOUSELEAVE )
    DECLARE_ID_STRING( WM_CUT )
    DECLARE_ID_STRING( WM_COPY )
    DECLARE_ID_STRING( WM_PASTE )
    DECLARE_ID_STRING( WM_CLEAR )
    DECLARE_ID_STRING( WM_UNDO )
    DECLARE_ID_STRING( WM_RENDERFORMAT )
    DECLARE_ID_STRING( WM_RENDERALLFORMATS )
    DECLARE_ID_STRING( WM_DESTROYCLIPBOARD )
    DECLARE_ID_STRING( WM_DRAWCLIPBOARD )
    DECLARE_ID_STRING( WM_PAINTCLIPBOARD )
    DECLARE_ID_STRING( WM_VSCROLLCLIPBOARD )
    DECLARE_ID_STRING( WM_SIZECLIPBOARD )
    DECLARE_ID_STRING( WM_ASKCBFORMATNAME )
    DECLARE_ID_STRING( WM_CHANGECBCHAIN )
    DECLARE_ID_STRING( WM_HSCROLLCLIPBOARD )
    DECLARE_ID_STRING( WM_QUERYNEWPALETTE )
    DECLARE_ID_STRING( WM_PALETTEISCHANGING )
    DECLARE_ID_STRING( WM_PALETTECHANGED )
    DECLARE_ID_STRING( WM_HOTKEY )
    DECLARE_ID_STRING( WM_PRINT )
    DECLARE_ID_STRING( WM_PRINTCLIENT )
    DECLARE_ID_STRING_2( WM_AFXFIRST+0, WM_QUERYAFXWNDPROC )
    DECLARE_ID_STRING_2( WM_AFXFIRST+1, WM_SIZEPARENT )
    DECLARE_ID_STRING_2( WM_AFXFIRST+2, WM_SETMESSAGESTRING )
    DECLARE_ID_STRING_2( WM_AFXFIRST+3, WM_IDLEUPDATECMDUI )
    DECLARE_ID_STRING_2( WM_AFXFIRST+4, WM_INITIALUPDATE )
    DECLARE_ID_STRING_2( WM_AFXFIRST+5, WM_COMMANDHELP )
    DECLARE_ID_STRING_2( WM_AFXFIRST+6, WM_HELPHITTEST )
    DECLARE_ID_STRING_2( WM_AFXFIRST+7, WM_EXITHELPMODE )
    DECLARE_ID_STRING_2( WM_AFXFIRST+8, WM_RECALCPARENT )
    DECLARE_ID_STRING_2( WM_AFXFIRST+9, WM_SIZECHILD )
    DECLARE_ID_STRING_2( WM_AFXFIRST+10, WM_KICKIDLE )
    DECLARE_ID_STRING_2( WM_AFXFIRST+11, WM_QUERYCENTERWND )
    DECLARE_ID_STRING_2( WM_AFXFIRST+12, WM_DISABLEMODAL )
    DECLARE_ID_STRING_2( WM_AFXFIRST+13, WM_FLOATSTATUS )
    DECLARE_ID_STRING_2( WM_AFXFIRST+14, WM_ACTIVATETOPLEVEL )
    DECLARE_ID_STRING_2( WM_AFXFIRST+15, WM_QUERY3DCONTROLS )
    DECLARE_ID_STRING_2( WM_AFXFIRST+16, WM_RESERVED_0370 )
    DECLARE_ID_STRING_2( WM_AFXFIRST+17, WM_RESERVED_0371 )
    DECLARE_ID_STRING_2( WM_AFXFIRST+18, WM_RESERVED_0372 )
    DECLARE_ID_STRING_2( WM_AFXFIRST+19, WM_SOCKET_NOTIFY )
    DECLARE_ID_STRING_2( WM_AFXFIRST+20, WM_SOCKET_DEAD )
    DECLARE_ID_STRING_2( WM_AFXFIRST+21, WM_POPMESSAGESTRING )
    DECLARE_ID_STRING_2( WM_AFXFIRST+22, WM_OCC_LOADFROMSTREAM )
    DECLARE_ID_STRING_2( WM_AFXFIRST+23, WM_OCC_LOADFROMSTORAGE )
    DECLARE_ID_STRING_2( WM_AFXFIRST+24, WM_OCC_INITNEW )
    DECLARE_ID_STRING_2( WM_AFXFIRST+25, WM_OCC_LOADFROMSTREAM_EX )
    DECLARE_ID_STRING_2( WM_AFXFIRST+26, WM_OCC_LOADFROMSTORAGE_EX )
    DECLARE_ID_STRING_2( WM_AFXFIRST+27, WM_QUEUE_SENTINEL )
    DECLARE_ID_STRING_2( WM_AFXFIRST+28, WM_RESERVED_037C )
    DECLARE_ID_STRING_2( WM_AFXFIRST+29, WM_RESERVED_037D )
    DECLARE_ID_STRING_2( WM_AFXFIRST+30, WM_RESERVED_037E )
    DECLARE_ID_STRING_2( WM_AFXFIRST+31, WM_RESERVED_037F )
    DECLARE_ID_STRING( WM_APP )
    { NULL, 0 }
};
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_COMMAND )
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapButtonMsgs[] =
{
    DECLARE_ID_STRING( BN_CLICKED )
    DECLARE_ID_STRING( BN_PAINT )
    DECLARE_ID_STRING_EX( BN_HILITE, _T(" / BN_PUSHED") )
    DECLARE_ID_STRING_EX( BN_UNHILITE, _T(" / BN_UNPUSHED") )
    DECLARE_ID_STRING( BN_DISABLE )
    DECLARE_ID_STRING( BN_DOUBLECLICKED )
    DECLARE_ID_STRING( BN_SETFOCUS )
    DECLARE_ID_STRING( BN_KILLFOCUS )
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapComboBoxMsgs[] =
{
    DECLARE_ID_STRING_2( (UINT) CBN_ERRSPACE, CBN_ERRSPACE )
    DECLARE_ID_STRING( CBN_SELCHANGE )
    DECLARE_ID_STRING( CBN_DBLCLK )
    DECLARE_ID_STRING( CBN_SETFOCUS )
    DECLARE_ID_STRING( CBN_KILLFOCUS )
    DECLARE_ID_STRING( CBN_EDITCHANGE )
    DECLARE_ID_STRING( CBN_EDITUPDATE )
    DECLARE_ID_STRING( CBN_DROPDOWN )
    DECLARE_ID_STRING( CBN_CLOSEUP )
    DECLARE_ID_STRING( CBN_SELENDOK )
    DECLARE_ID_STRING( CBN_SELENDCANCEL )
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapEditMsgs[] =
{
    DECLARE_ID_STRING( EN_SETFOCUS )
    DECLARE_ID_STRING( EN_KILLFOCUS )
    DECLARE_ID_STRING( EN_CHANGE )
    DECLARE_ID_STRING( EN_UPDATE )
    DECLARE_ID_STRING( EN_ERRSPACE )
    DECLARE_ID_STRING( EN_MAXTEXT )
    DECLARE_ID_STRING( EN_HSCROLL )
    DECLARE_ID_STRING( EN_VSCROLL )
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapListBoxMsgs[] =
{
    DECLARE_ID_STRING( LBN_ERRSPACE )
    DECLARE_ID_STRING( LBN_SELCHANGE )
    DECLARE_ID_STRING( LBN_DBLCLK )
    DECLARE_ID_STRING( LBN_SELCANCEL )
    DECLARE_ID_STRING( LBN_SETFOCUS )
    DECLARE_ID_STRING( LBN_KILLFOCUS )
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapScrollBarMsgs[] =
{
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapStaticMsgs[] =
{
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapListViewMsgs[] =
{
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapTreeViewMsgs[] =
{
    { NULL, 0 }
};
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapIPAddressMsgs[] =
{
    DECLARE_ID_STRING( IPN_FIELDCHANGE )
    DECLARE_ID_STRING_EX( EN_SETFOCUS, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_KILLFOCUS, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_CHANGE, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_UPDATE, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_ERRSPACE, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_MAXTEXT, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_HSCROLL, _T(" (IPN)") )
    DECLARE_ID_STRING_EX( EN_VSCROLL, _T(" (IPN)") )
    { NULL, 0 }
};
#endif // DBG && defined( _DBG_MSG_COMMAND )

#if DBG && defined( _DBG_MSG_NOTIFY )
_declspec( selectany ) const ID_MAP_ENTRY s_rgmapPropSheetNotifyMsgs[] =
{
    DECLARE_ID_STRING( PSN_SETACTIVE )
    DECLARE_ID_STRING( PSN_KILLACTIVE )
    DECLARE_ID_STRING( PSN_APPLY )
    DECLARE_ID_STRING( PSN_RESET )
    DECLARE_ID_STRING( PSN_HELP )
    DECLARE_ID_STRING( PSN_WIZBACK )
    DECLARE_ID_STRING( PSN_WIZNEXT )
    DECLARE_ID_STRING( PSN_WIZFINISH )
    DECLARE_ID_STRING( PSN_QUERYCANCEL )
    { NULL, 0 }
};
#endif // DBG && defined( _DBG_MSG_NOTIFY )

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
/////////////////////////////////////////////////////////////////////////////
//++
//
//  DBG_OnMsg
//
//  Routine Description:
//      Debug handler for any message.
//
//  Arguments:
//      uMsg            [IN] Message causing this function to be called.
//      wParam          [IN] Message specific parameter.
//      lParam          [IN] Message specific parameter.
//      bHandled        [IN OUT] TRUE = message has been handled (we set to FALSE).
//      pszClassName    [IN] Name of class calling this function.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT DBG_OnMsg(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL &  bHandled,
    LPCTSTR pszClassName
    )
{
    ATLASSERT( pszClassName != NULL );

    const ID_MAP_ENTRY * pmap;

    //
    // Display the message code.
    //
    ATLTRACE( _T("%s::OnMsg() - Message = %08.8X"), pszClassName, uMsg );
    pmap = s_rgmapWindowMsgs;
    if (   (WM_USER <= uMsg)
        && (uMsg < WM_APP) )
    {
        ATLTRACE( _T(" (WM_USER + %d)"), uMsg - WM_USER );
    } // if:  user message
    else if (  (WM_HANDHELDFIRST <= uMsg)
            && (uMsg <= WM_HANDHELDLAST) )
    {
        ATLTRACE( _T(" (WM_HANDHELDFIRST + %d)"), uMsg - WM_HANDHELDFIRST );
    } // else if:  handheld PC message
    else if (  (WM_PENWINFIRST <= uMsg)
            && (uMsg <= WM_PENWINLAST) )
    {
        ATLTRACE( _T(" (WM_PENWINFIRST + %d)"), uMsg - WM_PENWINFIRST );
    } // else if:  pen windows message
    else
    {
        for ( ; pmap->pszName != NULL ; pmap++ )
        {
            if ( uMsg == pmap->id )
            {
                ATLTRACE( _T(" (%s)"), pmap->pszName );
                break;
            } // if:  message found
        } // for:  each code in the map
    } // else:  not range message
    if (   (WM_AFXFIRST <= uMsg)
        && (uMsg <= WM_AFXLAST) )
    {
        ATLTRACE( _T(" (WM_AFXFIRST + %d)"), uMsg - WM_AFXFIRST );
    } // if:  MFC message
    ATLTRACE( _T("\n") );

    bHandled = FALSE;
    return 1;

} //*** DBG_OnMsg()
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
/////////////////////////////////////////////////////////////////////////////
//++
//
//  DBG_OnNotify
//
//  Routine Description:
//      Debug handler for the WM_NOTIFY message.
//
//  Arguments:
//      uMsg            [IN] Message causing this function to be called (WM_NOTIFY).
//      wParam          [IN] Unused.
//      lParam          [IN] Pointer to notification message header (NMHDR).
//      bHandled        [IN OUT] TRUE = message has been handled (we set to FALSE).
//      pszClassName    [IN] Name of class calling this function.
//      pmapCtrlNames   [IN] Map of control IDs to control names.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT DBG_OnNotify(
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL &          bHandled,
    LPCTSTR         pszClassName,
    ID_MAP_ENTRY *  pmapCtrlNames
    )
{
    ATLASSERT( ::IsWindow( m_hWnd ) );
    ATLASSERT( pszClassName != NULL );

    NMHDR * pNMHDR = (NMHDR *) lParam;
    const ID_MAP_ENTRY * pmap;

    //
    // Display the control ID.
    //
    ATLTRACE( _T("%s::OnNotify() - idFrom = %d"), pszClassName, pNMHDR->idFrom );
    if ( pmapCtrlNames != NULL )
    {
        pmap = pmapCtrlNames;
        for ( ; pmap->pszName != NULL ; pmap++ )
        {
            if ( pNMHDR->idFrom == pmap->id )
            {
                ATLTRACE( _T(" (%s)"), pmap->pszName );
            } // if:  control ID found
        } // for:  each control in the map
    } // if:  control names array specified

    //
    // Display the notification code.
    //
    ATLTRACE( _T(" code = %08.8X"), pNMHDR->code );
    pmap = s_rgmapPropSheetNotifyMsgs;
    for ( ; pmap->pszName != NULL ; pmap++ )
    {
        if ( pNMHDR->code == pmap->id )
        {
            ATLTRACE( _T(" (%s)"), pmap->pszName );
            break;
        } // if:  code found
    } // for:  each code in the map
    ATLTRACE( _T("\n") );

    bHandled = FALSE;
    return 1;

} //*** DBG_OnNotify()
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
/////////////////////////////////////////////////////////////////////////////
//++
//
//  DBG_OnCommand
//
//  Routine Description:
//      Debug handler for the WM_COMMAND message.
//
//  Arguments:
//      uMsg            [IN] Message causing this function to be called (WM_COMMAND).
//      wParam          [IN] Notification code and control ID.
//      lParam          [IN] Window handle to the control.
//      bHandled        [IN OUT] TRUE = message has been handled (we set to FALSE).
//      pszClassName    [IN] Name of class calling this function.
//      pmapCtrlNames   [IN] Map of control IDs to control names.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT DBG_OnCommand(
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL &          bHandled,
    LPCTSTR         pszClassName,
    ID_MAP_ENTRY *  pmapCtrlNames
    )
{
    ATLASSERT( pszClassName != NULL );

    WORD wNotifyCode = HIWORD( wParam );
    WORD idCtrl = LOWORD ( wParam );
    HWND hwndCtrl = (HWND) lParam;
    const ID_MAP_ENTRY * pmap;

    //
    // Display the control ID.
    //
    ATLTRACE( _T("%s::OnCommand() - idCtrl = %d"), pszClassName, idCtrl );
    if ( pmapCtrlNames != NULL )
    {
        pmap = pmapCtrlNames;
        for ( ; pmap->pszName != NULL ; pmap++ )
        {
            if ( idCtrl == pmap->id )
            {
                ATLTRACE( _T(" (%s)"), pmap->pszName );
            } // if:  control ID found
        } // for:  each control in the map
    } // if:  control names array specified

    //
    // Get the window class.
    //
    TCHAR szWindowClass[256];
    ::GetClassName( hwndCtrl, szWindowClass, (sizeof( szWindowClass ) / sizeof( TCHAR )) - 1 );
    ATLTRACE( _T(" (%s)"), szWindowClass );

    //
    // Display the notification code.
    //
    ATLTRACE( _T(" wNotifyCode = %04.4X"), wNotifyCode );
    if ( _tcsncmp( szWindowClass, _T("Button"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapButtonMsgs;
    }
    else if ( _tcsncmp( szWindowClass, _T("ComboBox"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapComboBoxMsgs;
    }
    else if ( _tcsncmp( szWindowClass, _T("Edit"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapEditMsgs;
    }
    else if ( _tcsncmp( szWindowClass, _T("ListBox"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapListBoxMsgs;
    }
    else if ( _tcsncmp( szWindowClass, _T("ScrollBar"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapScrollBarMsgs;
    }
    else if ( _tcsncmp( szWindowClass, _T("Static"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapStaticMsgs;
    }
    else if ( _tcsncmp( szWindowClass, WC_LISTVIEW, RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapListViewMsgs;
    }
    else if ( _tcsncmp( szWindowClass, WC_TREEVIEW, RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapTreeViewMsgs;
    }
    else if ( _tcsncmp( szWindowClass, WC_IPADDRESS, RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        pmap = s_rgmapIPAddressMsgs;
    }
    else
    {
        pmap = NULL;
    }
    if ( pmap != NULL )
    {
        for ( ; pmap->pszName != NULL ; pmap++ )
        {
            if ( wNotifyCode == pmap->id )
            {
                ATLTRACE( _T(" (%s)"), pmap->pszName );
                break;
            } // if:  code found
        } // for:  each code in the map
    } // if:  known control

    ATLTRACE( _T("\n") );

    bHandled = FALSE;
    return 1;

} //*** DBG_OnCommand()
#endif // DBG && defined( _DBG_MSG_COMMAND )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlextdll.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlExtDll.h
//
//  Implementation File:
//      AtlExtDll.cpp
//
//  Description:
//      Definition of the Cluster Administrator extension classes.
//
//  Author:
//      David Potter (davidp)   May 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLEXTDLL_H_
#define __ATLEXTDLL_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters ni the browser information

/////////////////////////////////////////////////////////////////////////////
//  Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>           // for extension DLL definitions
#endif

#ifndef __cluadmexhostsvr_h__
#include "CluAdmExHostSvr.h"    // for CLSIDs
#endif

#ifndef __CLUADMEXDATAOBJ_H_
#include "CluAdmExDataObj.h"    // for CCluAdmExDataObject
#endif

//#ifndef _TRACETAG_H_
//#include "TraceTag.h"         // for CTraceTag, Trace
//#endif

#ifndef __ATLEXTMENU_H_
#include "AtlExtMenu.h"         // for CCluAdmExMenuItemList
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"    // for CBasePropertyPageImpl
#endif

#ifndef __ATLBASEWIZPAGE_H_
#include "AtlBaseWizPage.h"     // for CBaseWizardPageImpl
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExtensions;
class CCluAdmExDll;
class CCluAdmExPropPage;
class CCluAdmExWizPage;
class CCluAdmExWiz97Page;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;
class CBaseSheetWindow;
class CBasePropertySheetWindow;
class CWizardWindow;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define CAEXT_MENU_FIRST_ID     35000

typedef CComObject< CCluAdmExDll > CComCluAdmExDll;
typedef std::list< CComCluAdmExDll * > CCluAdmExDllList;
typedef std::list< CString > CStringList;

/////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
/////////////////////////////////////////////////////////////////////////////

//#if DBG
//extern CTraceTag g_tagExtDll;
//extern CTraceTag g_tagExtDllRef;
//#endif // DBG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluAdmExtensions
//
//  Description:
//      Encapsulates access to a list of extension DLLs.
//
//  Inheritance:
//      CCluAdmExtensions
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExtensions
{
    friend class CCluAdmExDll;

public:
    //
    // Construction.
    //

    // Default constructor
    CCluAdmExtensions( void )
        : m_pco( NULL )
        , m_hfont( NULL )
        , m_hicon( NULL )

        , m_pdoData( NULL )
        , m_plextdll( NULL )
        , m_psht( NULL )
        , m_pmenu( NULL )
        , m_plMenuItems( NULL )

        , m_nFirstCommandID( (ULONG) -1 )
        , m_nNextCommandID( (ULONG) -1 )
        , m_nFirstMenuID( (ULONG) -1 )
        , m_nNextMenuID( (ULONG) -1 )
    {
    } //*** CCluAdmExtensions()

    // Destructor
    virtual ~CCluAdmExtensions( void )
    {
        UnloadExtensions();

    } //*** ~CCluAdmExtensions()

protected:
    // Initialize the list
    void Init(
            IN const CStringList &  rlstrExtensions,
            IN OUT CClusterObject * pco,
            IN HFONT                hfont,
            IN HICON                hicon
            );

    // Unload all the extensions
    void UnloadExtensions( void );

// Attributes
private:
    const CStringList * m_plstrExtensions;  // List of extensions.
    CClusterObject *    m_pco;              // Cluster item being administered.
    HFONT               m_hfont;            // Font for dialog text.
    HICON               m_hicon;            // Icon for upper left corner.

protected:
    //
    // Accessor methods.
    //

    const CStringList * PlstrExtensions( void ) const   { return m_plstrExtensions; }
    CClusterObject *    Pco( void ) const               { return m_pco; }
    HFONT               Hfont( void ) const             { return m_hfont; }
    HICON               Hicon( void ) const             { return m_hicon; }

// Operations
public:
    //
    // IWEExtendPropertySheet methods.
    //

    // Create extension property sheet pages
    void CreatePropertySheetPages(
            IN OUT CBasePropertySheetWindow *   psht,
            IN const CStringList &              rlstrExtensions,
            IN OUT CClusterObject *             pco,
            IN HFONT                            hfont,
            IN HICON                            hicon
            );

public:
    //
    // IWEExtendWizard methods.
    //

    // Create extension wizard pages
    void CreateWizardPages(
            IN OUT CWizardWindow *  psht,
            IN const CStringList &  rlstrExtensions,
            IN OUT CClusterObject * pco,
            IN HFONT                hfont,
            IN HICON                hicon
            );

public:
    //
    // IWEExtendWizard97 methods.
    //

    // Create extension Wizard97 wizard pages
    void CreateWizard97Pages(
            IN OUT CWizardWindow *  psht,
            IN const CStringList &  rlstrExtensions,
            IN OUT CClusterObject * pco,
            IN HFONT                hfont,
            IN HICON                hicon
            );

public:
    //
    // IWEExtendContextMenu methods.
    //

    // Add extension context menu items
    void AddContextMenuItems(
            IN OUT CMenu *              pmenu,
            IN const CStringList &      rlstrExtensions,
            IN OUT CClusterObject *     pco
            );

    // Execute an extension context menu item
    BOOL BExecuteContextMenuItem( IN ULONG nCommandID );

    // Get a command string to display on the status bar
    BOOL BGetCommandString( IN ULONG nCommandID, OUT CString & rstrMessage );

    // Set the GetResNetName function pointer
    void SetPfGetResNetName( PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext )
    {
        if ( Pdo() != NULL )
        {
            Pdo()->SetPfGetResNetName( pfGetResNetName, pvContext );
        } // if:  data object specified

    } //*** SetPfGetResNetName()

// Implementation
private:
    CComObject< CCluAdmExDataObject > * m_pdoData;  // Data object for exchanging data.
    CCluAdmExDllList *          m_plextdll;         // List of extension DLLs.
    CBaseSheetWindow *          m_psht;             // Property sheet for IWEExtendPropertySheet.
    CMenu *                     m_pmenu;            // Menu for IWEExtendContextMenu.
    CCluAdmExMenuItemList *     m_plMenuItems;

    ULONG                       m_nFirstCommandID;
    ULONG                       m_nNextCommandID;
    ULONG                       m_nFirstMenuID;
    ULONG                       m_nNextMenuID;

protected:
    CComObject< CCluAdmExDataObject > * Pdo( void )             { return m_pdoData; }
    CCluAdmExDllList *          Plextdll( void ) const          { return m_plextdll; }
    CBaseSheetWindow *          Psht( void ) const              { return m_psht; }
    CMenu *                     Pmenu( void ) const             { return m_pmenu; }
    CCluAdmExMenuItemList *     PlMenuItems( void ) const       { return m_plMenuItems; }
    CCluAdmExMenuItem *         PemiFromCommandID( ULONG nCommandID ) const;
#if DBG
    CCluAdmExMenuItem *         PemiFromExtCommandID( ULONG nExtCommandID ) const;
#endif // DBG
    ULONG                       NFirstCommandID( void ) const   { return m_nFirstCommandID; }
    ULONG                       NNextCommandID( void ) const    { return m_nNextCommandID; }
    ULONG                       NFirstMenuID( void ) const      { return m_nFirstMenuID; }
    ULONG                       NNextMenuID( void ) const       { return m_nNextMenuID; }

    // Get the wizard page pointer from an HPROPSHEETPAGE
    CWizardPageWindow *         PwpPageFromHpage( IN HPROPSHEETPAGE hpage );

public:
//  void                        OnUpdateCommand( CCmdUI * pCmdUI );
//  BOOL                        OnCmdMsg( UINT nID, int nCode, void * pExtra, AFX_CMDHANDLERINFO * pHandlerInfo );

}; //*** class CCluAdmExtensions

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluAdmExDll
//
//  Description:
//      Encapsulates access to an extension DLL.
//
//  Inheritance:
//      CCluAdmExDll
//      CComObjectRootEx<>, CComCoClass<>, <interface classes>
//
//--
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CCluAdmExDll :
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CCluAdmExDll, &CLSID_CoCluAdmExHostSvr >,
    public ISupportErrorInfo,
    public IWCPropertySheetCallback,
    public IWCWizardCallback,
    public IWCWizard97Callback,
    public IWCContextMenuCallback
{
    friend class CCluAdmExtensions;

public:
    //
    // Object construction and destruction.
    //

    // Default constructor
    CCluAdmExDll( void )
        : m_piExtendPropSheet( NULL )
        , m_piExtendWizard( NULL )
        , m_piExtendWizard97( NULL )
        , m_piExtendContextMenu( NULL )
        , m_piInvokeCommand( NULL )
        , m_pext( NULL )
    {
    } //*** CCluAdmExDll()

    // Destructor
    virtual ~CCluAdmExDll( void )
    {
        UnloadExtension();

    } //*** ~CCluAdmExDll()

    //
    // Map interfaces to this class.
    //
    BEGIN_COM_MAP( CCluAdmExDll )
        COM_INTERFACE_ENTRY( IWCPropertySheetCallback )
        COM_INTERFACE_ENTRY( IWCWizardCallback )
        COM_INTERFACE_ENTRY( IWCWizard97Callback )
        COM_INTERFACE_ENTRY( IWCContextMenuCallback )
        COM_INTERFACE_ENTRY( ISupportErrorInfo )
    END_COM_MAP()

    DECLARE_NO_REGISTRY()

    DECLARE_NOT_AGGREGATABLE( CCluAdmExDll ) 

// Attributes
private:
    CString m_strCLSID;     // Name of extension DLL.

protected:
    const CString &     StrCLSID( void ) const  { return m_strCLSID; }
    CClusterObject *    Pco( void ) const       { return Pext()->Pco(); }

// Operations
public:

    void Init(
            IN const CString &          rstrExtension,
            IN OUT CCluAdmExtensions *  pext
            );

    IUnknown * LoadInterface( IN /*const*/ REFIID riid );
    void UnloadExtension( void );

public:
    //
    // IWEExtendPropertySheet methods.
    //

    // Create extension property sheet pages
    void CreatePropertySheetPages( void );

public:
    //
    // IWEExtendWizard methods.
    //

    // Create extension wizard pages
    void CreateWizardPages( void );

public:
    //
    // IWEExtendWizard97 methods.
    //

    // Create extension wizard pages
    void CreateWizard97Pages( void );

public:
    //
    // IWEExtendContextMenu methods.
    //

    // Add extension context menu items
    void AddContextMenuItems( void );

public:
    //
    // ISupportsErrorInfo methods.
    //

    STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

public:
    //
    // IWCPropertySheetCallback methods.
    //

    // Callback to add extension property sheet pages
    STDMETHOD( AddPropertySheetPage )(
                    IN LONG *       hpage   // really should be HPROPSHEETPAGE
                    );

public:
    //
    // IWCWizardCallback methods.
    //

    // Callback to add extension wizard pages
    STDMETHOD( AddWizardPage )(
                    IN LONG *       hpage   // really should be HPROPSHEETPAGE
                    );

public:
    //
    // IWCWizard97Callback methods.
    //

    // Callback to add extension wizard 97 pages
    STDMETHOD( AddWizard97Page )(
                    IN LONG *       hpage   // really should be HPROPSHEETPAGE
                    );

public:
    //
    // IWCWizardCallback and IWCWizard97Callback methods.
    //

    // Callback to enable the next button
    STDMETHOD( EnableNext )(
                    IN LONG *       hpage,
                    IN BOOL         bEnable
                    );

public:
    //
    // IWCContextMenuCallback methods.
    //

    // Callback to add extension context menu items
    STDMETHOD( AddExtensionMenuItem )(
                    IN BSTR     lpszName,
                    IN BSTR     lpszStatusBarText,
                    IN ULONG    nCommandID,
                    IN ULONG    nSubmenuCommandID,
                    IN ULONG    uFlags
                    );

// Implementation
private:
    CCluAdmExtensions *         m_pext;
    CLSID                       m_clsid;
    IWEExtendPropertySheet *    m_piExtendPropSheet;    // Pointer to an IWEExtendPropertySheet interface.
    IWEExtendWizard *           m_piExtendWizard;       // Pointer to an IWEExtendWizard interface.
    IWEExtendWizard97 *         m_piExtendWizard97;     // Pointer to an IWEExtendWizard97 interface.
    IWEExtendContextMenu *      m_piExtendContextMenu;  // Pointer to an IWEExtendContextMenu interface.
    IWEInvokeCommand *          m_piInvokeCommand;      // Pointer to an IWEInvokeCommand interface.

protected:
    CCluAdmExtensions *         Pext( void ) const                  { ATLASSERT( m_pext != NULL ); return m_pext; }
    const CLSID &               Rclsid( void ) const                { return m_clsid; }
    IWEExtendPropertySheet *    PiExtendPropSheet( void ) const     { return m_piExtendPropSheet; }
    IWEExtendWizard *           PiExtendWizard( void ) const        { return m_piExtendWizard; }
    IWEExtendWizard97 *         PiExtendWizard97( void ) const      { return m_piExtendWizard97; }
    IWEExtendContextMenu *      PiExtendContextMenu( void ) const   { return m_piExtendContextMenu; }
    IWEInvokeCommand *          PiInvokeCommand( void ) const       { return m_piInvokeCommand; }

    CComObject< CCluAdmExDataObject > * Pdo( void ) const           { return Pext()->Pdo(); }
    CBaseSheetWindow *          Psht( void ) const                  { return Pext()->Psht(); }
    CMenu *                     Pmenu( void ) const                 { return Pext()->Pmenu(); }
    CCluAdmExMenuItemList *     PlMenuItems( void ) const           { return Pext()->PlMenuItems(); }
    ULONG                       NFirstCommandID( void ) const       { return Pext()->NFirstCommandID(); }
    ULONG                       NNextCommandID( void ) const        { return Pext()->NNextCommandID(); }
    ULONG                       NFirstMenuID( void ) const          { return Pext()->NFirstMenuID(); }
    ULONG                       NNextMenuID( void ) const           { return Pext()->NNextMenuID(); }

    void ReleaseInterface(
            IN OUT IUnknown ** ppi
#if DBG
            , IN LPCTSTR szClassName
#endif
            )
    {
        ATLASSERT( ppi != NULL );
        if ( *ppi != NULL )
        {
#if DBG
            ULONG ulNewRefCount;

//          Trace( g_tagExtDllRef, _T("Releasing %s"), szClassName );
            ulNewRefCount =
#endif // DBG
            (*ppi)->Release();
            *ppi = NULL;
#if DBG
//          Trace( g_tagExtDllRef, _T("  Reference count = %d"), ulNewRefCount );
//          Trace( g_tagExtDllRef, _T("ReleaseInterface() - %s = %08.8x"), szClassName, *ppi );
#endif // DBG
        }  // if:  interface specified
    } //*** ReleaseInterface( IUnknown )

    void ReleaseInterface( IN OUT IWEExtendPropertySheet ** ppi )
    {
        ReleaseInterface(
            (IUnknown **) ppi
#if DBG
            , _T("IWEExtendPropertySheet")
#endif // DBG
            );
    } //*** ReleaseInterface( IWEExtendPropertySheet )

    void ReleaseInterface( IN OUT IWEExtendWizard ** ppi )
    {
        ReleaseInterface(
            (IUnknown **) ppi
#if DBG
            , _T("IWEExtendWizard")
#endif // DBG
            );
    } //*** ReleaseInterface( IWEExtendWizard )

    void ReleaseInterface( IN OUT IWEExtendWizard97 ** ppi )
    {
        ReleaseInterface(
            (IUnknown **) ppi
#if DBG
            , _T("IWEExtendWizard97")
#endif // DBG
            );
    } //*** ReleaseInterface( IWEExtendWizard97 )

    void ReleaseInterface( IN OUT IWEExtendContextMenu ** ppi )
    {
        ReleaseInterface(
            (IUnknown **) ppi
#if DBG
            , _T("IWEExtendContextMenu")
#endif // DBG
            );
    } //*** ReleaseInterface( IWEExtendContextMenu )

    void ReleaseInterface( IN OUT IWEInvokeCommand ** ppi )
    {
        ReleaseInterface(
            (IUnknown **) ppi
#if DBG
            , _T("IWEInvokeCommand")
#endif // DBG
            );
    } //*** ReleaseInterface( IWEInvokeCommand )

}; //*** class CCluAdmExDll

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluAdmExPropPage
//
//  Description:
//      Encapsulates an extension property page.
//
//  Inheritance:
//      CCluAdmExPropPage
//      CExtensionPropertyPageImpl< CCluAdmExPropPage >
//      CBasePropertyPageImpl< CCluAdmExPropPage, CExtensionPropertyPageWindow >
//      CBasePageImpl< CCluAdmExPropPage, CExtensionPropertyPageWindow >
//      CPropertyPageImpl< CCluAdmExPropPage, CExtensionPropertyPageWindow >
//      CExtensionPropertyPageWindow
//      CDynamicPropertyPageWindow
//      CBasePropertyPageWindow
//      CBasePageWindow
//      CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExPropPage : public CExtensionPropertyPageImpl< CCluAdmExPropPage >
{
public:
    //
    // Construction.
    //

    // Standard constructor
    CCluAdmExPropPage(
        HPROPSHEETPAGE hpage
        )
    {
        ATLASSERT( hpage != NULL );
        m_hpage = hpage;

    } //*** CCluAdmExPropPage()

    enum { IDD = 0 };
    DECLARE_CLASS_NAME()

    // Return the help ID map
    static const DWORD * PidHelpMap( void )
    {
        static const DWORD s_aHelpIDs[] = { 0, 0 };
        return s_aHelpIDs;

    } //*** PidHelpMap()

    // Create the page
    DWORD ScCreatePage( void )
    {
        //
        // This method is required by CDynamicPropertyPageWindow.
        //
        return ERROR_SUCCESS;

    } //*** ScCreatePage()

}; //*** class CCluAdmExPropPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluAdmExWizPage
//
//  Description:
//      Encapsulates an extension wizard page.
//
//  Inheritance:
//      CCluAdmExWizPage
//      CExtensionWizardPageImpl< CCluAdmExWizPage >
//      CWizardPageImpl< CCluAdmExWizPage, CExtensionWizardWindow >
//      CBasePageImpl< CCluAdmExWizPage, CExtensionWizardWindow >
//      CPropertyPageImpl< CCluAdmExWizPage, CExtensionWizardWindow >
//      CExtensionWizardPageWindow
//      CDynamicWizardPageWindow
//      CWizardPageWindow
//      CBasePageWindow
//      CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExWizPage : public CExtensionWizardPageImpl< CCluAdmExWizPage >
{
public:
    //
    // Construction.
    //

    // Standard constructor
    CCluAdmExWizPage(
        HPROPSHEETPAGE hpage
        )
    {
        ATLASSERT( hpage != NULL );
        m_hpage = hpage;

    } //*** CCluAdmExWizPage()

    WIZARDPAGE_HEADERTITLEID( 0 )
    WIZARDPAGE_HEADERSUBTITLEID( 0 )

    enum { IDD = 0 };
    DECLARE_CLASS_NAME()

    // Return the help ID map
    static const DWORD * PidHelpMap( void )
    {
        static const DWORD s_aHelpIDs[] = { 0, 0 };
        return s_aHelpIDs;

    } //*** PidHelpMap()

    // Create the page
    DWORD ScCreatePage( void )
    {
        //
        // This method is required by CDynamicWizardPageWindow.
        //
        return ERROR_SUCCESS;

    } //*** ScCreatePage()

}; //*** class CCluAdmExWizPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluAdmExWiz97Page
//
//  Description:
//      Encapsulates an extension Wizard 97 page.
//
//  Inheritance:
//      CCluAdmExWiz97Page
//      CExtensionWizard97PageImpl< CCluAdmExWiz97Page >
//      CWizardPageImpl< CCluAdmExWiz97Page, CExtensionWizard97Window >
//      CBasePageImpl< CCluAdmExWiz97Page, CExtensionWizard97Window >
//      CPropertyPageImpl< CCluAdmExWiz97Page, CExtensionWizard97Window >
//      CExtensionWizard97PageWindow
//      CExtensionWizardPageWindow
//      CDynamicWizardPageWindow
//      CWizardPageWindow
//      CBasePageWindow
//      CPropertyPageWindow
//
//--
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExWiz97Page : public CExtensionWizard97PageImpl< CCluAdmExWiz97Page >
{
public:
    //
    // Construction.
    //

    // Standard constructor
    CCluAdmExWiz97Page(
        HPROPSHEETPAGE hpage
        )
    {
        ATLASSERT( hpage != NULL );
        m_hpage = hpage;

    } //*** CCluAdmExWiz97Page()

    WIZARDPAGE_HEADERTITLEID( 0 )
    WIZARDPAGE_HEADERSUBTITLEID( 0 )

    enum { IDD = 0 };
    DECLARE_CLASS_NAME()

    // Return the help ID map
    static const DWORD * PidHelpMap( void )
    {
        static const DWORD s_aHelpIDs[] = { 0, 0 };
        return s_aHelpIDs;

    } //*** PidHelpMap()

    // Create the page
    DWORD ScCreatePage( void )
    {
        //
        // This method is required by CDynamicWizardPageWindow.
        //
        return ERROR_SUCCESS;

    } //*** ScCreatePage()

}; //*** class CCluAdmExWiz97Page

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CCluAdmExPropPage )
DEFINE_CLASS_NAME( CCluAdmExWizPage )
DEFINE_CLASS_NAME( CCluAdmExWiz97Page )

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLEXTDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atldbgwin.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlDbgWin.cpp
//
//	Description:
//		Definitions for debugging windowing classes.
//
//	Author:
//		David Potter (davidp)	February 10, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#define __ATLDBGWIN_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if DBG
struct ID_MAP_ENTRY
{
	UINT	id;			// control ID
	LPCTSTR	pszName;	// control name

}; //*** struct ID_MAP_ENTRY
#endif // DBG

#if DBG && ( defined( _DBG_MSG_NOTIFY ) || defined( _DBG_MSG_COMMAND ) || defined( _DBG_MSG ) )

// Define the class name for use without a control name map.
#define DECLARE_CLASS_NAME() static LPCTSTR s_pszClassName;

#define DEFINE_CLASS_NAME( T ) \
_declspec( selectany ) LPCTSTR T::s_pszClassName = _T( #T );

// Declaration of a control name map.
#define DECLARE_CTRL_NAME_MAP() \
DECLARE_CLASS_NAME() \
static const ID_MAP_ENTRY s_rgmapCtrlNames[];

// Beginning of a control name map.
#define BEGIN_CTRL_NAME_MAP( T ) \
DEFINE_CLASS_NAME( T ) \
_declspec( selectany ) const ID_MAP_ENTRY T::s_rgmapCtrlNames[] = {

// Entry in a control name map.
#define DEFINE_CTRL_NAME_MAP_ENTRY( id ) { id, _T( #id ) },

// End of a control name map.
#define END_CTRL_NAME_MAP() { 0, NULL } };

#define DECLARE_ID_STRING( _id ) { _id, _T(#_id) },
#define DECLARE_ID_STRING_2( _id1, _id2 ) { _id1, _T(#_id2) },
#define DECLARE_ID_STRING_EX( _id, _t ) { _id, _T(#_id) _t },

#else // DBG && (defined( _DBG_MSG_NOTIFY ) || defined( _DBG_MSG_COMMAND ))

#define DECLARE_CLASS_NAME()
#define DEFINE_CLASS_NAME( T )
#define DECLARE_CTRL_NAME_MAP()
#define BEGIN_CTRL_NAME_MAP( T )
#define DEFINE_CTRL_NAME_MAP_ENTRY( id )
#define END_CTRL_NAME_MAP()

#endif // DBG && (defined( _DBG_MSG_NOTIFY ) || defined( _DBG_MSG_COMMAND ) || defined( _DBG_MSG ))

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
extern const ID_MAP_ENTRY s_rgmapWindowMsgs[];
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_COMMAND )
extern const ID_MAP_ENTRY s_rgmapButtonMsgs[];
extern const ID_MAP_ENTRY s_rgmapComboBoxMsgs[];
extern const ID_MAP_ENTRY s_rgmapEditMsgs[];
extern const ID_MAP_ENTRY s_rgmapListBoxMsgs[];
extern const ID_MAP_ENTRY s_rgmapScrollBarMsgs[];
extern const ID_MAP_ENTRY s_rgmapStaticMsgs[];
extern const ID_MAP_ENTRY s_rgmapListViewMsgs[];
extern const ID_MAP_ENTRY s_rgmapTreeViewMsgs[];
extern const ID_MAP_ENTRY s_rgmapIPAddressMsgs[];
#endif // DBG && defined( _DBG_MSG_COMMAND )

#if DBG && defined( _DBG_MSG_NOTIFY )
extern const ID_MAP_ENTRY s_rgmapPropSheetNotifyMsgs[];
#endif // DBG && defined( _DBG_MSG_NOTIFY )

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#if DBG && defined( _DBG_MSG )
// Debug handler for any message
LRESULT DBG_OnMsg(
	UINT	uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL &	bHandled,
	LPCTSTR	pszClassName
	);
#endif // DBG && defined( _DBG_MSG )

#if DBG && defined( _DBG_MSG_NOTIFY )
// Debug handler for the WM_NOTIFY message
LRESULT DBG_OnNotify(
	UINT			uMsg,
	WPARAM			wParam,
	LPARAM			lParam,
	BOOL &			bHandled,
	LPCTSTR			pszClassName,
	ID_MAP_ENTRY *	pmapCtrlNames
	);
#endif // DBG && defined( _DBG_MSG_NOTIFY )

#if DBG && defined( _DBG_MSG_COMMAND )
// Debug handler for the WM_COMMAND message
LRESULT DBG_OnCommand(
	UINT			uMsg,
	WPARAM			wParam,
	LPARAM			lParam,
	BOOL &			bHandled,
	LPCTSTR			pszClassName,
	ID_MAP_ENTRY *	pmapCtrlNames
	);
#endif // DBG && defined( _DBG_MSG_COMMAND )

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLDBGWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlextdll.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlExtDll.cpp
//
//  Abstract:
//      Implementation of the Cluster Administrator extension classes.
//
//  Author:
//      David Potter (davidp)   May 31, 1996
//
//  Revision History:
//
//  Notes:
//      This file is intended to be included in a stub file which includes
//      the ATL header files and defines _Module.  This allos _Module to be
//      defined as an instance of some application-specific class.
//
/////////////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <CluAdmEx.h>
#include "CluAdmExHostSvr.h"
#include "AtlExtDll.h"
#include "AdmCommonRes.h"
#include "AtlExtMenu.h"
//#include "TraceTag.h"
#include "ExcOper.h"
#include "ClusObj.h"
#include "AtlBaseSheet.h"
#include "AtlBasePropSheet.h"
#include "AtlBaseWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#if DBG
//CTraceTag g_tagExtDll(_T("UI"), _T("EXTENSION DLL"), 0);
//CTraceTag g_tagExtDllRef(_T("UI"), _T("EXTENSION DLL References"), 0);
#endif // DBG

/////////////////////////////////////////////////////////////////////////////
// class CCluAdmExtensions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::Init
//
//  Routine Description:
//      Common initializer for all interfaces.
//
//  Arguments:
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::Init(
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ATLASSERT( rlstrExtensions.size() > 0 );
    ATLASSERT( pco != NULL );

    CWaitCursor wc;

    UnloadExtensions();

    //
    // Save parameters.
    //
    m_plstrExtensions = &rlstrExtensions;
    m_pco = pco;
    m_hfont = hfont;
    m_hicon = hicon;

    //
    // Allocate a new Data Object.
    //
    m_pdoData = new CComObject< CCluAdmExDataObject >;
    if ( m_pdoData == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    m_pdoData->AddRef();

    // Construct the Data Object.
    Pdo()->Init( pco, GetUserDefaultLCID(), hfont, hicon );

    // Allocate the extension list.
    m_plextdll = new CCluAdmExDllList;
    if ( m_plextdll == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    ATLASSERT( Plextdll() != NULL );

    //
    // Loop through the extensions and load each one.
    //
    {
        CComCluAdmExDll *           pextdll = NULL;
        CStringList::iterator       itCurrent = rlstrExtensions.begin();
        CStringList::iterator       itLast = rlstrExtensions.end();
        CCluAdmExDllList::iterator  itDll;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            //
            // Allocate an extension DLL object and add it to the list.
            //
            pextdll = new CComCluAdmExDll;
            if ( pextdll == NULL )
            {
                goto MemoryError;
            } // if: error allocating memory
            pextdll->AddRef();
            itDll = Plextdll()->insert( Plextdll()->end(), pextdll );
            try
            {
                pextdll->Init( *itCurrent, this );
            } // try
            catch ( CException * pe )
            {
                pe->ReportError();
                pe->Delete();

                ATLASSERT( itDll != Plextdll()->end() );
                Plextdll()->erase( itDll );
                delete pextdll;
            } // catch:  CException
        } // while:  more items in the list
    } // Loop through the extensions and load each one

Cleanup:
    return;

MemoryError:
    CNTException nte(
                    static_cast< DWORD >( E_OUTOFMEMORY ),
                    ADMC_IDS_INIT_EXT_PAGES_ERROR,
                    NULL,   // pszOperArg1
                    NULL,   // pszOperArg2
                    FALSE   // bAutoDelete
                    );
    nte.ReportError();
    goto Cleanup;

} //*** CCluAdmExtensions::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::UnloadExtensions
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::UnloadExtensions( void )
{
    //
    // Delete all the extension DLL objects.
    //
    if ( Plextdll() != NULL )
    {
        CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
        CCluAdmExDllList::iterator  itLast = Plextdll()->end();
        CComCluAdmExDll *           pextdll;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pextdll = *itCurrent;
            pextdll->AddRef(); // See comment below.
            pextdll->UnloadExtension();
            if ( pextdll->m_dwRef != 2 )
            {
                Trace( g_tagError, _T("CCluAdmExtensions::UnloadExtensions() - Extension DLL has ref count = %d"), pextdll->m_dwRef );
            } // if:  not last reference

            // We added a reference above.  Combined with the reference that
            // was added when the object was created, we typically will need
            // to release two references.  However, due to bogus code
            // generated by earlier versions of the custom AppWizard where the
            // extension was releasing the interface but not zeroing out its
            // pointer in the error case, we may not need to release the
            // second reference.
            if ( pextdll->Release() != 0 )
            {
                pextdll->Release();
            } // if: more references to release
        } // while:  more items in the list
        delete m_plextdll;
        m_plextdll = NULL;
    } // if:  there is a list of extensions

    if ( m_pdoData != NULL )
    {
        if ( m_pdoData->m_dwRef != 1 )
        {
            Trace( g_tagError, _T("CCluAdmExtensions::UnloadExtensions() - Data Object has ref count = %d"), m_pdoData->m_dwRef );
        } // if:  not last reference
        m_pdoData->Release();
        m_pdoData = NULL;
    } // if:  data object allocated

    m_pco = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    //
    // Delete all menu items.
    //
    if ( PlMenuItems() != NULL )
    {
        CCluAdmExMenuItemList::iterator itCurrent = PlMenuItems()->begin();
        CCluAdmExMenuItemList::iterator itLast = PlMenuItems()->end();
        CCluAdmExMenuItem *             pemi;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pemi = *itCurrent;
            delete pemi;
        } // while:  more items in the list
        delete m_plMenuItems;
        m_plMenuItems = NULL;
    } // if:  there is a list of menu items

} //*** CCluAdmExtensions::UnloadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::PwpPageFromHpage
//
//  Routine Description:
//      Get the wizard page pointer from an HPROPSHEETPAGE.
//
//  Arguments:
//      hpage   [IN] Page handle.
//
//  Return Value:
//      pwp     Pointer to wizard page object.
//      NULL    Page not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizardPageWindow * CCluAdmExtensions::PwpPageFromHpage( IN HPROPSHEETPAGE hpage )
{
    ATLASSERT( hpage != NULL );

    //
    // Get a pointer to the wizard object so we can traverse the page list.
    //
    CWizardWindow * pwiz = dynamic_cast< CWizardWindow * >( Psht() );
    ATLASSERT( pwiz != NULL );

    //
    // Loop through each page looking for an extension page whose
    // page handle matches the one specified.
    //
    CWizardPageList::iterator itCurrent = pwiz->PlwpPages()->begin();
    CWizardPageList::iterator itLast = pwiz->PlwpPages()->end();
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        CCluAdmExWizPage * pewp = dynamic_cast< CCluAdmExWizPage * >( *itCurrent );
        if ( pewp != NULL )
        {
            if ( pewp->Hpage() == hpage )
            {
                return pewp;
            } // if:  found the matching page
        } // if:  found an extension page
    } // for:  each page in the list

    //
    // Look at the alternate wizard if there is one.
    //
    pwiz = pwiz->PwizAlternate();
    if ( pwiz != NULL )
    {
        itCurrent = pwiz->PlwpPages()->begin();
        itLast = pwiz->PlwpPages()->end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CCluAdmExWizPage * pewp = dynamic_cast< CCluAdmExWizPage * >( *itCurrent );
            if ( pewp != NULL )
            {
                if ( pewp->Hpage() == hpage )
                {
                    return pewp;
                } // if:  found the matching page
            } // if:  found an extension page
        } // for:  each page in the list
    } // if:  alternate wizard exists

    return NULL;

} //*** CCluAdmExtensions::PwpPageFromHpage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::CreatePropertySheetPages(
    IN OUT CBasePropertySheetWindow *   psht,
    IN const CStringList &              rlstrExtensions,
    IN OUT CClusterObject *             pco,
    IN HFONT                            hfont,
    IN HICON                            hicon
    )
{
    ATLASSERT( psht != NULL );
    ATLASSERT( pco != NULL );

    m_psht = psht;

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, hfont, hicon );
    ATLASSERT( Plextdll() != NULL );

    //
    // Let each extension create property pages.
    //
    CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
    CCluAdmExDllList::iterator  itLast = Plextdll()->end();
    CComCluAdmExDll *           pextdll;
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pextdll = *itCurrent;
        try
        {
            pextdll->CreatePropertySheetPages();
        } // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // while:  more items in the list

} //*** CCluAdmExtensions::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::CreateWizardPages(
    IN OUT CWizardWindow *  psht,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ATLASSERT( psht != NULL );
    ATLASSERT( pco != NULL );

    m_psht = psht;

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, hfont, hicon );
    ATLASSERT( Plextdll() != NULL );

    //
    // Let each extension create wizard pages.
    //
    CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
    CCluAdmExDllList::iterator  itLast = Plextdll()->end();
    CComCluAdmExDll *           pextdll;
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pextdll = *itCurrent;
        try
        {
            pextdll->CreateWizardPages();
        } // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // while:  more items in the list

} //*** CCluAdmExtensions::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::CreateWizard97Pages
//
//  Routine Description:
//      Add pages to a Wizard 97 wizard.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::CreateWizard97Pages(
    IN OUT CWizardWindow *  psht,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ATLASSERT( psht != NULL );
    ATLASSERT( pco != NULL );

    m_psht = psht;

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, hfont, hicon );
    ATLASSERT( Plextdll() != NULL );

    //
    // Let each extension create wizard pages.
    //
    CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
    CCluAdmExDllList::iterator  itLast = Plextdll()->end();
    CComCluAdmExDll *           pextdll;
    for ( ; itCurrent != itLast ; itCurrent++ )
    {
        pextdll = *itCurrent;
        try
        {
            pextdll->CreateWizard97Pages();
        } // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // while:  more items in the list

} //*** CCluAdmExtensions::CreateWizard97Pages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::AddContextMenuItems
//
//  Routine Description:
//      Query the extension DLL for new menu items to be added to the context
//      menu.
//
//  Arguments:
//      pmenu           [IN OUT] Menu to which items are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pco             [IN OUT] Cluster object to be administered.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::AddContextMenuItems() or
//          CExtMenuItemList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExtensions::AddContextMenuItems(
    IN OUT CMenu *          pmenu,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterObject * pco
    )
{
    ATLASSERT( m_pmenu == NULL );
    ATLASSERT( pmenu != NULL );

    //
    // Initialize for all extensions.
    //
    Init( rlstrExtensions, pco, NULL, NULL );
    ATLASSERT( Plextdll() != NULL );

    m_pmenu = pmenu;
    m_nFirstCommandID = CAEXT_MENU_FIRST_ID;
    m_nNextCommandID = m_nFirstCommandID;
    m_nFirstMenuID = 0;
    m_nNextMenuID = m_nFirstMenuID;

    //
    // Create the list of menu items.
    //
    ATLASSERT( m_plMenuItems == NULL );
    m_plMenuItems = new CCluAdmExMenuItemList;
    if ( m_plMenuItems == NULL )
    {
        CNTException nte(
                        static_cast< DWORD >( E_OUTOFMEMORY ),
                        ADMC_IDS_INIT_EXT_PAGES_ERROR,
                        NULL,   // pszOperArg1
                        NULL,   // pszOperArg2
                        FALSE   // bAutoDelete
                        );
        nte.ReportError();
    } // if: error allocating memory
    else
    {
        CCluAdmExDllList::iterator  itCurrent = Plextdll()->begin();
        CCluAdmExDllList::iterator  itLast = Plextdll()->end();
        CComCluAdmExDll *           pextdll;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pextdll = *itCurrent;
            try
            {
                pextdll->AddContextMenuItems();
            } // try
            catch ( CException * pe )
            {
                pe->ReportError();
                pe->Delete();
            } // catch:  CException
        } // while:  more items in the list
    } // else: memory allocated successfully

} //*** CCluAdmExtensions::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::BExecuteContextMenuItem
//
//  Routine Description:
//      Execute a command associated with a menu item added to a context menu
//      by the extension DLL.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item chosen by the user.
//
//  Return Value:
//      TRUE            Context menu item was executed.
//      FALSE           Context menu item was not executed.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExceptionDll::BExecuteContextMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluAdmExtensions::BExecuteContextMenuItem( IN ULONG nCommandID )
{
    BOOL                bHandled    = FALSE;
    HRESULT             hr;
    CCluAdmExMenuItem * pemi;

    //
    // Find the item in our list.
    //
    pemi = PemiFromCommandID( nCommandID );
    if ( pemi != NULL )
    {
        ATLASSERT( pemi->PiCommand() != NULL );
        Pdo()->AddRef();
        hr = pemi->PiCommand()->InvokeCommand( pemi->NExtCommandID(), Pdo()->GetUnknown() );
        if ( hr == NOERROR )
        {
            bHandled = TRUE;
        } // if:  no error occurred
    } // if:  found an item for the command ID

    return bHandled;

} //*** CCluAdmExtensions::BExecuteContextMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::BGetCommandString
//
//  Routine Description:
//      Get a command string from a menu ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//      rstrMessage     [OUT] String in which to return the message.
//
//  Return Value:
//      TRUE            String is being returned.
//      FALSE           No string is being returned.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::BGetCommandString().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluAdmExtensions::BGetCommandString(
    IN ULONG        nCommandID,
    OUT CString &   rstrMessage
    )
{
    BOOL                bHandled    = FALSE;
    CCluAdmExMenuItem * pemi;

    //
    // Find the item in our list.
    //
    pemi = PemiFromCommandID( nCommandID );
    if ( pemi != NULL )
    {
        rstrMessage = pemi->StrStatusBarText();
        bHandled = TRUE;
    } // if:  found an item for the command ID

    return bHandled;

} //*** CCluAdmExtensions::BGetCommandString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::OnUpdateCommand
//
//  Routine Description:
//      Determines whether extension DLL menu items should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CCluAdmExDll::BOnUpdateCommand().
//
//--
/////////////////////////////////////////////////////////////////////////////
#if 0
void CCluAdmExtensions::OnUpdateCommand( CCmdUI * pCmdUI )
{
    CCluAdmExMenuItem * pemi;

    ATLASSERT( Plextdll() != NULL );

    //
    // Find the item in our list.
    //
//  Trace( g_tagExtDll, _T("OnUpdateCommand() - ID = %d"), pCmdUI->m_nID );
    pemi = PemiFromCommandID( pCmdUI->m_nID );
    if ( pemi != NULL )
    {
//      Trace( g_tagExtDll, _T("OnUpdateCommand() - Found a match with '%s' ExtID = %d"), pemi->StrName(), pemi->NExtCommandID() );
        pCmdUI->Enable();
    } // if:  found an item for the command ID

} //*** CCluAdmExtensions::OnUpdateCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
#if 0
BOOL CCluAdmExtensions::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    return BExecuteContextMenuItem( nID );

} //*** CCluAdmExtensions::OnCmdMsg()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::PemiFromCommandID
//
//  Routine Description:
//      Find the menu item for the specified command ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluAdmExMenuItem * CCluAdmExtensions::PemiFromCommandID( IN ULONG nCommandID ) const
{
    CCluAdmExMenuItem * pemiReturn = NULL;

    if ( PlMenuItems() != NULL )
    {
        CCluAdmExMenuItemList::iterator itCurrent = PlMenuItems()->begin();
        CCluAdmExMenuItemList::iterator itLast = PlMenuItems()->end();
        CCluAdmExMenuItem *             pemi;
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pemi = *itCurrent;
            if ( pemi->NCommandID() == nCommandID )
            {
                pemiReturn = pemi;
                break;
            } // if:  match was found
        } // while:  more items in the list
    } // if:  item list exists

    return pemiReturn;

} //*** CCluAdmExtensions::PemiFromCommandID()

#if DBG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExtensions::PemiFromExtCommandID
//
//  Routine Description:
//      Find the menu item for the specified extension command ID.
//
//  Arguments:
//      nExtCommandID   [IN] Extension command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluAdmExMenuItem * CCluAdmExtensions::PemiFromExtCommandID( IN ULONG nExtCommandID ) const
{
    CCluAdmExMenuItem * pemiReturn = NULL;

    if ( PlMenuItems() != NULL )
    {
        CCluAdmExMenuItemList::iterator itCurrent = PlMenuItems()->begin();
        CCluAdmExMenuItemList::iterator itLast = PlMenuItems()->end();
        CCluAdmExMenuItem *             pemi;

        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            pemi = *itCurrent;
            if ( pemi->NExtCommandID() == nExtCommandID )
            {
                pemiReturn = pemi;
                break;
            } // if:  match was found
        } // while:  more items in the list
    } // if:  item list exists

    return pemiReturn;

} //*** CCluAdmExtensions::PemiFromExtCommandID()
#endif // DBG


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CComObject< CCluAdmExDll >
/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP( AtlExtDll_ObjectMap )
    OBJECT_ENTRY( CLSID_CoCluAdmExHostSvr, CComCluAdmExDll )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::Init
//
//  Routine Description:
//      Initialize this class in preparation for accessing the extension.
//
//  Arguments:
//      rstrCLSID       [IN] CLSID of the extension in string form.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    0 (error converting CLSID from string)
//      Any exceptions thrown by CString::operater=().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::Init(
    IN const CString &          rstrCLSID,
    IN OUT CCluAdmExtensions *  pext
    )
{
    ATLASSERT( pext != NULL );

    HRESULT     hr;
    CWaitCursor wc;

    //
    // Save parameters.
    //
    ATLASSERT( StrCLSID().IsEmpty() || (StrCLSID() == rstrCLSID) );
    m_strCLSID = rstrCLSID;
    m_pext = pext;

    //
    // Convert the CLSID string to a CLSID.
    //
    hr = ::CLSIDFromString( (LPWSTR) (LPCTSTR) rstrCLSID, &m_clsid );
    if ( hr != S_OK )
    {
        ThrowStaticException( hr, ADMC_IDS_CLSIDFROMSTRING_ERROR, rstrCLSID );
    } // if:  error converting CLSID

} //*** CCluAdmExDll::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::LoadInterface
//
//  Routine Description:
//      Load an extension DLL.
//
//  Arguments:
//      riid            [IN] Interface ID.
//
//  Return Value:
//      piUnk           IUnknown interface pointer for interface.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_CREATE_INSTANCE_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
IUnknown * CCluAdmExDll::LoadInterface( IN /*const*/ REFIID riid )
{
    HRESULT     hr;
    IUnknown *  piUnk;
    CWaitCursor wc;

    //
    // Load the inproc server and get the specified interface pointer.
    //
//  Trace( g_tagExtDllRef, _T("LoadInterface() - Getting interface pointer") );
    hr = ::CoCreateInstance(
                Rclsid(),
                NULL,
                CLSCTX_INPROC_SERVER,
                riid,
                (LPVOID *) &piUnk
                );
    if (   (hr != S_OK)
        && (hr != REGDB_E_CLASSNOTREG)
        && (hr != E_NOINTERFACE)
        )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_CREATE_INSTANCE_ERROR, StrCLSID() );
    } // if:  error creating the object instance

    return piUnk;

} //*** CCluAdmExDll::LoadInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::UnloadExtension
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::UnloadExtension( void )
{
    //
    // Release the interface pointers in the opposite order in which they
    //
    // were obtained.
    ReleaseInterface( &m_piExtendPropSheet );
    ReleaseInterface( &m_piExtendWizard );
    ReleaseInterface( &m_piExtendWizard97 );
    ReleaseInterface( &m_piExtendContextMenu );
    ReleaseInterface( &m_piInvokeCommand );

    m_strCLSID.Empty();

} //*** CCluAdmExDll::UnloadExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::CreatePropertySheetPages( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Psht() != NULL );
    ATLASSERT( m_piExtendPropSheet == NULL );

    HRESULT     hr;

    //
    // Load the interface.
    //
    m_piExtendPropSheet = reinterpret_cast< interface IWEExtendPropertySheet * >( LoadInterface( IID_IWEExtendPropertySheet ) );
    if ( m_piExtendPropSheet == NULL )
    {
        return;
    } // if:  error loading the interface
    ATLASSERT( m_piExtendPropSheet != NULL );

    //
    // Add pages from the extension.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        hr = PiExtendPropSheet()->CreatePropertySheetPages( Pdo()->GetUnknown(), this );
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( (hr != NOERROR) && (hr != E_NOTIMPL) )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_ADD_PAGES_ERROR, StrCLSID() );
    } // if:  error creating property sheet pages

} //*** CCluAdmExDll::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::CreateWizardPages( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Psht() != NULL );
    ATLASSERT( m_piExtendWizard == NULL );
    ATLASSERT( m_piExtendWizard97 == NULL );

    HRESULT     hr;

    //
    // Load the interface.  If it can't be loaded, try to load the
    // Wizard97 interface so that Wizard97 pages can be added.
    //
    m_piExtendWizard = reinterpret_cast< interface IWEExtendWizard * >( LoadInterface( IID_IWEExtendWizard ) );
    if ( m_piExtendWizard == NULL )
    {
        //
        // Try to load the Wizard97 interface.
        //
        m_piExtendWizard97 = reinterpret_cast< interface IWEExtendWizard97 * >( LoadInterface( IID_IWEExtendWizard97 ) );
        if ( m_piExtendWizard97 == NULL )
        {
            return;
        } // if:  error loading the non-Wizard97 interface
    } // if:  error loading the interface
    ATLASSERT( (m_piExtendWizard != NULL) || (m_piExtendWizard97 != NULL) );

    //
    // Add pages from the extension.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        if ( PiExtendWizard() != NULL )
        {
            hr = PiExtendWizard()->CreateWizardPages( Pdo()->GetUnknown(), this );
        } // if:  extension supports non-Wizard97 interface
        else
        {
            ATLASSERT( PiExtendWizard97() != NULL );
            hr = PiExtendWizard97()->CreateWizard97Pages( Pdo()->GetUnknown(), this );
        } // else:  extension doesn't support non-Wizard97 interface
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( (hr != NOERROR) && (hr != E_NOTIMPL) )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_ADD_PAGES_ERROR, StrCLSID() );
    } // if:  error creating wizard pages

} //*** CCluAdmExDll::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::CreateWizard97Pages
//
//  Routine Description:
//      Add pages to a Wizard 97 wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::CreateWizard97Pages( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Psht() != NULL );
    ATLASSERT( m_piExtendWizard == NULL );
    ATLASSERT( m_piExtendWizard97 == NULL );

    HRESULT     hr;

    //
    // Load the interface.  If it can't be loaded, try to load the non-
    // Wizard97 interface so that non-Wizard97 pages can be added.
    //
    m_piExtendWizard97 = reinterpret_cast< interface IWEExtendWizard97 * >( LoadInterface( IID_IWEExtendWizard97 ) );
    if ( m_piExtendWizard97 == NULL )
    {
        //
        // Try to load the non-Wizard97 interface.
        //
        m_piExtendWizard = reinterpret_cast< interface IWEExtendWizard * >( LoadInterface( IID_IWEExtendWizard ) );
        if ( m_piExtendWizard == NULL )
        {
            return;
        } // if:  error loading the non-Wizard97 interface
    } // if:  error loading the Wizard97 interface
    ATLASSERT( (m_piExtendWizard97 != NULL) || (m_piExtendWizard != NULL) );

    //
    // Add pages from the extension.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        if ( PiExtendWizard97() != NULL )
        {
            hr = PiExtendWizard97()->CreateWizard97Pages( Pdo()->GetUnknown(), this );
        } // if:  extension supports Wizard97 interface
        else
        {
            ATLASSERT( PiExtendWizard() != NULL );
            hr = PiExtendWizard()->CreateWizardPages( Pdo()->GetUnknown(), this );
        } // else:  extension doesn't support Wizard97 interface
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( (hr != NOERROR) && (hr != E_NOTIMPL) )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_ADD_PAGES_ERROR, StrCLSID() );
    } // if:  error creating wizard pages

} //*** CCluAdmExDll::CreateWizard97Pages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddContextMenuItems
//
//  Routine Description:
//      Ask the extension DLL to add items to the menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdmExDll::AddContextMenuItems( void )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Pmenu() != NULL );
    ATLASSERT( m_piExtendContextMenu == NULL );

    HRESULT     hr;

    //
    // Load the interfaces.
    //
    m_piExtendContextMenu = reinterpret_cast< interface IWEExtendContextMenu * >( LoadInterface( IID_IWEExtendContextMenu ) );
    if ( m_piExtendContextMenu == NULL )
    {
        return;
    } // if:  error loading the interface
    ATLASSERT( m_piExtendContextMenu != NULL );

    hr = PiExtendContextMenu()->QueryInterface( IID_IWEInvokeCommand, (LPVOID *) &m_piInvokeCommand );
    if ( hr != NOERROR )
    {
        PiExtendContextMenu()->Release();
        m_piExtendContextMenu = NULL;
        ThrowStaticException( hr, ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID() );
    } // if:  error getting the InvokeCommand interface

    //
    // Add context menu items.
    //
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
//  Trace( g_tagExtDll, _T("CCluAdmExDll::AddContextMenuItem() - Adding context menu items from '%s'"), StrCLSID() );
    try
    {
        hr = PiExtendContextMenu()->AddContextMenuItems( Pdo()->GetUnknown(), this );
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( hr != NOERROR )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID() );
    } // if:  error occurred

    //
    // Add a separator after the extension's items.
    //
//  Trace( g_tagExtDll, _T("CCluAdmExDll::AddContextMenuItem() - Adding separator") );
    try
    {
        hr = AddExtensionMenuItem( NULL, NULL, (ULONG) -1, 0, MF_SEPARATOR );
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if ( hr != NOERROR )
    {
        ThrowStaticException( hr, ADMC_IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID() );
    } // if:  error adding a separator

} //*** CCluAdmExDll::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Determines whether the interface supports error info (???).
//
//  Arguments:
//      riid        [IN] Reference to the interface ID.
//
//  Return Value:
//      S_OK        Interface supports error info.
//      S_FALSE     Interface does not support error info.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::InterfaceSupportsErrorInfo( REFIID riid )
{
    static const IID * rgiid[] =
    {
        &IID_IWCPropertySheetCallback,
        &IID_IWCWizardCallback,
        &IID_IWCWizard97Callback,
        &IID_IWCContextMenuCallback,
    };
    int     iiid;

    for ( iiid = 0 ; iiid < sizeof( rgiid ) / sizeof( rgiid[0] ) ; iiid++ )
    {
        if ( InlineIsEqualGUID( *rgiid[iiid], riid ) )
        {
            return S_OK;
        } // if:  found a match
    }
    return S_FALSE;

} //*** CCluAdmExDll::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddPropertySheetPage [IWCPropertySheetCallback]
//
//  Routine Description:
//      Add a page to the property sheet.
//
//  Arguments:
//      plong_hpage     [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CBasePropertySheetWindow::HrAddExtensionPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddPropertySheetPage( IN LONG * plong_hpage )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    HRESULT hr;

    // Loop to avoid goto's.
    do
    {
        //
        // Do this for the release build.
        //
        if (   (plong_hpage == NULL)
            || (Psht() == NULL) )
        {
            hr = E_INVALIDARG;
            break;
        } // if:  no page or sheet

        //
        // Allocate a new page object.
        //
        CCluAdmExPropPage * ppp = new CCluAdmExPropPage( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
        ATLASSERT( ppp != NULL );
        if ( ppp == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory

        //
        // Initialize the page object.
        //
        if ( ! ppp->BInit( Psht() ) )
        {
            delete ppp;
            hr = E_FAIL;
            break;
        } // if:  error initializing the page object

        //
        // Add the page to the sheet.
        //
        CBasePropertySheetWindow * psht = dynamic_cast< CBasePropertySheetWindow * >( Psht() );
        ATLASSERT( psht != NULL );
        hr = psht->HrAddExtensionPage( ppp );
        if ( hr != NOERROR )
        {
            delete ppp;
            break;
        } // if:  error adding the extension page
    } while ( 0 );

    return hr;

} //*** CCluAdmExDll::AddPropertySheetPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddWizardPage [IWCWizardCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      plong_hpage     [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CWizardWindow::HrAddExtensionPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddWizardPage( IN LONG * plong_hpage )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    HRESULT hr;

    // Loop to avoid goto's.
    do
    {
        //
        // Do this for the release build.
        //
        if (   (plong_hpage == NULL)
            || (Psht() == NULL) )
        {
            hr = E_INVALIDARG;
            break;
        } // if:  no page or sheet

        //
        // Allocate a new page object.
        //
        CCluAdmExWizPage * pwp = new CCluAdmExWizPage( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory

        //
        // Initialize the page object.
        //
        if ( ! pwp->BInit( Psht() ) )
        {
            delete pwp;
            hr = E_FAIL;
            break;
        } // if:  error initializing the page object

        //
        // Set the default buttons to display.  This assumes that there is
        // a non-extension page already in the sheet and that there will
        // be a page added after all extension pages have been added.
        //
        pwp->SetDefaultWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

        //
        // Add the page to the sheet.
        //
        CWizardWindow * pwiz = dynamic_cast< CWizardWindow * >( Psht() );
        ATLASSERT( pwiz != NULL );
        hr = pwiz->HrAddExtensionPage( pwp );
        if ( hr != NOERROR )
        {
            delete pwp;
            break;
        } // if:  error adding the extension page
    } while ( 0 );

    return hr;

} //*** CCluAdmExDll::AddWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddWizard97Page [IWCWizard97Callback]
//
//  Routine Description:
//      Add a page to the Wizard97 wizard.
//
//  Arguments:
//      plong_hpage     [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CWizardWindow::HrAddExtensionPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddWizard97Page( IN LONG * plong_hpage )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    HRESULT hr;

    // Loop to avoid goto's.
    do
    {
        //
        // Do this for the release build.
        //
        if (   (plong_hpage == NULL)
            || (Psht() == NULL) )
        {
            hr = E_INVALIDARG;
            break;
        } // if:  no page or sheet

        //
        // Allocate a new page object.
        //
        CCluAdmExWiz97Page * pwp = new CCluAdmExWiz97Page( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
        ATLASSERT( pwp != NULL );
        if ( pwp == NULL )
        {
            hr = E_OUTOFMEMORY;
            break;
        } // if: error allocating memory

        //
        // Initialize the page object.
        //
        if ( ! pwp->BInit( Psht() ) )
        {
            delete pwp;
            hr = E_FAIL;
            break;
        } // if:  error initializing the page object

        //
        // Set the default buttons to display.  This assumes that there is
        // a non-extension page already in the sheet and that there will
        // be a page added after all extension pages have been added.
        //
        pwp->SetDefaultWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );

        //
        // Add the page to the sheet.
        //
        CWizardWindow * pwiz = dynamic_cast< CWizardWindow * >( Psht() );
        ATLASSERT( pwiz != NULL );
        hr = pwiz->HrAddExtensionPage( pwp );
        if ( hr != NOERROR )
        {
            delete pwp;
            break;
        } // if:  error adding the extension page
    } while ( 0 );

    return hr;

} //*** CCluAdmExDll::AddWizard97Page()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::EnableNext [IWCWizardCallback/IWCWizard97Callback]
//
//  Routine Description:
//      Enable or disable the NEXT button.  If it is the last page, the
//      FINISH button will be enabled or disabled.
//
//  Arguments:
//      hpage           [IN] Page for which the button is being enabled or
//                          disabled.
//      bEnable         [IN] TRUE = Enable the button, FALSE = disable.
//
//  Return Value:
//      NOERROR         Success.
//      E_INVALIDARG    Unknown hpage specified.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::EnableNext(
    IN LONG *   plong_hpage,
    IN BOOL     bEnable
    )
{
    ATLASSERT( plong_hpage != NULL );
    ATLASSERT( Psht() != NULL );

    //
    // Find the page in the extension page list.
    //
    CWizardPageWindow * pwp = Pext()->PwpPageFromHpage( reinterpret_cast< HPROPSHEETPAGE >( plong_hpage ) );
    if ( pwp == NULL )
    {
        return E_INVALIDARG;
    } // if:  page not found

    //
    // Let the page enable/disable the Next button.
    //
    pwp->EnableNext( bEnable );

    return NOERROR;

} //*** CCluAdmExDll::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExDll::AddExtensionMenuItem [IWCContextMenuCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      lpszName            [IN] Name of item.
//      lpszStatusBarText   [IN] Text to appear on the status bar when the
//                              item is highlighted.
//      nCommandID          [IN] ID for the command when menu item is invoked.
//                              Must not be -1.
//      nSubmenuCommandID   [IN] ID for a submenu.
//      uFlags              [IN] Menu flags.  The following are not supported:
//                              MF_OWNERDRAW, MF_POPUP
//
//  Return Value:
//      NOERROR             Item added successfully.
//      E_INVALIDARG        MF_OWNERDRAW or MF_POPUP were specified.
//      E_OUTOFMEMORY       Error allocating the item.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluAdmExDll::AddExtensionMenuItem(
    IN BSTR     lpszName,
    IN BSTR     lpszStatusBarText,
    IN ULONG    nCommandID,
    IN ULONG    nSubmenuCommandID,
    IN ULONG    uFlags
    )
{
    ATLASSERT( Pext() != NULL );
    ATLASSERT( Pmenu() != NULL );
    ATLASSERT( !(uFlags & (MF_OWNERDRAW | MF_POPUP)) );

    HRESULT             hr      = NOERROR;
    CCluAdmExMenuItem * pemi    = NULL;

    //
    // Do this for the release build.
    //
    if ( (uFlags & (MF_OWNERDRAW | MF_POPUP)) != 0 )
    {
        hr = E_INVALIDARG;
    } // if:  invalid menu flags specified
    else
    {
        ATLASSERT( Pext()->PemiFromExtCommandID( nCommandID ) == NULL );

        try
        {
//          Trace( g_tagExtDll, _T("CCluAdmExDll::AddExtensionMenuItem() - Adding menu item '%s', ExtID = %d"), lpszName, nCommandID );

            //
            // Allocate a new item.
            //
            pemi = new CCluAdmExMenuItem(
                            OLE2CT( lpszName ),
                            OLE2CT( lpszStatusBarText ),
                            nCommandID,
                            NNextCommandID(),
                            NNextMenuID(),
                            uFlags,
                            FALSE, /*bMakeDefault*/
                            PiInvokeCommand()
                            );
            if ( pemi == NULL )
            {
                ThrowStaticException( static_cast< DWORD >( E_OUTOFMEMORY ), static_cast< UINT >( 0 ) );
            } // if: error allocating memory

            //
            // Insert the item in the menu.
            //
            if ( ! Pmenu()->InsertMenu( NNextMenuID(), MF_BYPOSITION | uFlags, NNextCommandID(), pemi->StrName() ) )
            {
                ThrowStaticException( ::GetLastError(), ADMC_IDS_INSERT_MENU_ERROR, pemi->StrName() );
            } // if:  error inserting the menu

            //
            // Add the item to the tail of the list.
            //
            Pext()->PlMenuItems()->insert( Pext()->PlMenuItems()->end(), pemi );
            pemi = NULL;

            //
            // Update the counters.
            //
            Pext()->m_nNextCommandID++;
            Pext()->m_nNextMenuID++;
        } // try
        catch ( CNTException * pnte )
        {
            hr = pnte->Sc();
            pnte->ReportError();
            pnte->Delete();
        } // catch:  CNTException
        catch ( CException * pe )
        {
            hr = E_OUTOFMEMORY;
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // else:  we can add the item

    delete pemi;
    return hr;

} //*** CCluAdmExDll::AddExtensionMenuItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlutil.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlUtil.cpp
//
//  Abstract:
//      Implementation of helper functions for use in an ATL project.
//
//  Author:
//      David Potter (davidp)   December 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <StrSafe.h>
#include "AtlUtil.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_GetText
//
//  Routine Description:
//      Get a text value from a control on a dialog.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] ID of control to get value from.
//      rstrValue   [IN OUT] String in which to return value.
//
//  Return Value:
//      TRUE        Value retrieved successfully.
//      FALSE       Error retrieving value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_GetText(
    IN HWND             hwndDlg,
    IN int              nIDC,
    IN OUT CString &    rstrValue
    )
{
    ATLASSERT( hwndDlg != NULL );

    //
    // Get the handle for the control.
    //
    HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hwndCtrl != NULL );

    //
    // Get the text from the control.
    //
    int cch = GetWindowTextLength( hwndCtrl );
    if ( cch == 0 )
    {
        rstrValue = _T("");
    } // if:  edit control is empty
    else
    {
        LPTSTR pszValue = rstrValue.GetBuffer( cch + 1 );
        ATLASSERT( pszValue != NULL );
#if DBG
        int cchRet =
#endif
        GetWindowText( hwndCtrl, pszValue, cch + 1 );
        ATLASSERT( cchRet > 0 );
        rstrValue.ReleaseBuffer();
    } // else:  length of text retrieved

    return TRUE;

} //*** DDX_GetText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_SetText
//
//  Routine Description:
//      Set a text value into a control on a dialog.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] ID of control to set value to.
//      rstrValue   [IN] String to set into the dialog.
//
//  Return Value:
//      TRUE        Value set successfully.
//      FALSE       Error setting value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_SetText(
    IN HWND             hwndDlg,
    IN int              nIDC,
    IN const CString &  rstrValue
    )
{
    ATLASSERT( hwndDlg != NULL );

    //
    // Set the text into the control.
    //
    BOOL bSuccess = SetDlgItemText( hwndDlg, nIDC, rstrValue );
    ATLASSERT( bSuccess );

    return bSuccess;

} //*** DDX_SetText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_SetComboBoxText
//
//  Routine Description:
//      Set a text value into a control on a dialog.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] ID of control to set value to.
//      rstrValue   [IN] String to set into the dialog.
//      bRequired   [IN] TRUE = text must already exist in the combobox.
//
//  Return Value:
//      TRUE        Value set successfully.
//      FALSE       Error setting value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_SetComboBoxText(
    IN HWND             hwndDlg,
    IN int              nIDC,
    IN const CString &  rstrValue,
    IN BOOL             bRequired
    )
{
    ATLASSERT( hwndDlg != NULL );

    BOOL bSuccess = TRUE;

    //
    // Get the handle for the control.
    //
    HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hwndCtrl != NULL );

#if DBG
    TCHAR szWindowClass[256];
    ::GetClassName( hwndCtrl, szWindowClass, (sizeof( szWindowClass ) / sizeof( TCHAR )) - 1 );
    ATLASSERT( _tcsncmp( szWindowClass, _T("ComboBox"), RTL_NUMBER_OF( szWindowClass ) ) == 0 );
#endif // DBG

    int idx = (int) SendMessage( hwndCtrl, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM)(LPCTSTR) rstrValue );
    if ( idx != CB_ERR )
    {
        SendMessage( hwndCtrl, CB_SETCURSEL, idx, 0 );
    } // if:  message sent successfully
    else
    {
        if ( bRequired )
        {
            ATLASSERT( idx != CB_ERR );
        } // if:  string was supposed to be present already
        bSuccess = FALSE;
    } // else if:  error sending message

    return bSuccess;

} //*** DDX_SetComboBoxText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_GetNumber
//
//  Routine Description:
//      Get a numeric value from a control on a dialog.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] ID of control to get value from.
//      rnValue     [IN OUT] Number in which to return value.
//      nMin        [IN] Minimum value.
//      nMax        [IN] Maximum value.
//      bSigned     [IN] TRUE = value is signed, FALSE = value is unsigned
//
//  Return Value:
//      TRUE        Value retrieved successfully.
//      FALSE       Error retrieving value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_GetNumber(
    IN HWND         hwndDlg,
    IN int          nIDC,
    IN OUT ULONG &  rnValue,
    IN ULONG        nMin,
    IN ULONG        nMax,
    IN BOOL         bSigned
    )
{
    ATLASSERT( hwndDlg != NULL );

    BOOL    bSuccess = TRUE;
    BOOL    bTranslated;
    ULONG   nValue;

    //
    // Get the handle for the control.
    //
    HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hwndCtrl != NULL );

    //
    // Get the number from the control.
    //
    nValue = GetDlgItemInt( hwndDlg, nIDC, &bTranslated, bSigned );

    //
    // If the retrival failed, it is a signed number, and the minimum
    // value is the smallest negative value possible, check the string itself.
    //
    if ( ! bTranslated && bSigned && (nMin == 0x80000000) )
    {
        UINT    cch;
        TCHAR   szNumber[20];

        //
        // See if it is the smallest negative number.
        //
        cch = GetWindowText( hwndCtrl, szNumber, sizeof( szNumber ) / sizeof(TCHAR ) );
        if ( (cch != 0) && (_tcsncmp( szNumber, _T("-2147483648"), RTL_NUMBER_OF( szNumber ) ) == 0) )
        {
            nValue = 0x80000000;
            bTranslated = TRUE;
        }  // if:  text retrieved successfully and is highest negative number
    }  // if:  error translating number and getting signed number

    //
    // If the retrieval failed or the specified number is
    // out of range, display an error.
    //
    if (   ! bTranslated
        || (bSigned && (((LONG) nValue < (LONG) nMin) || ((LONG) nValue > (LONG) nMax)))
        || (! bSigned && ((nValue < nMin) || (nValue > nMax)))
        )
    {
        TCHAR   szMin[32];
        TCHAR   szMax[32];
        CString strPrompt;
        HRESULT hr;

        bSuccess = FALSE;
        if ( bSigned )
        {
            hr = StringCchPrintf( szMin, RTL_NUMBER_OF( szMin ), _T("%d%"), nMin );
            ATLASSERT( SUCCEEDED( hr ) );
            hr = StringCchPrintf( szMax, RTL_NUMBER_OF( szMax ), _T("%d%"), nMax );
            ATLASSERT( SUCCEEDED( hr ) );
        }  // if:  signed number
        else
        {
            hr = StringCchPrintf( szMin, RTL_NUMBER_OF( szMin ), _T("%u%"), nMin );
            ATLASSERT( SUCCEEDED( hr ) );
            hr = StringCchPrintf( szMax, RTL_NUMBER_OF( szMax ), _T("%u%"), nMax );
            ATLASSERT( SUCCEEDED( hr ) );
        }  // else:  unsigned number
        strPrompt.FormatMessage( IDP_PARSE_INT_RANGE, szMin, szMax );
        AppMessageBox( hwndDlg, strPrompt, MB_ICONEXCLAMATION );
        SetFocus( hwndCtrl );
    }  // if:  invalid string
    else
    {
        rnValue = nValue;
    } // else:  valid string

    return bSuccess;

} //*** DDX_GetNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_GetNumber
//
//  Routine Description:
//      Set a numeric value into a control on a dialog.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] ID of control to get value from.
//      nValue      [IN] Number value to set into the control.
//      nMin        [IN] Minimum value.
//      nMax        [IN] Maximum value.
//      bSigned     [IN] TRUE = value is signed, FALSE = value is unsigned
//
//  Return Value:
//      TRUE        Value retrieved successfully.
//      FALSE       Error retrieving value.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDX_SetNumber(
    IN HWND     hwndDlg,
    IN int      nIDC,
    IN ULONG    nValue,
    IN ULONG    nMin,
    IN ULONG    nMax,
    IN BOOL     bSigned
    )
{
    ATLASSERT( hwndDlg != NULL );

    CString     strMinValue;
    CString     strMaxValue;
    UINT        cchMax;

    //
    // Get the handle for the control.
    //
    HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hwndCtrl != NULL );

    //
    // Set the maximum number of characters that can be entered.
    //
    if ( bSigned )
    {
        strMinValue.Format( _T("%d"), nMin );
        strMaxValue.Format( _T("%d"), nMax );
    }  // if:  signed value
    else
    {
        strMinValue.Format( _T("%u"), nMin );
        strMaxValue.Format( _T("%u"), nMax );
    }  // else:  unsigned value
    cchMax = max( strMinValue.GetLength(), strMaxValue.GetLength() );
    SendMessage( hwndCtrl, EM_LIMITTEXT, cchMax, 0 );

    // Set the value into the control.
    BOOL bSuccess = SetDlgItemInt( hwndDlg, nIDC, nValue, bSigned );
    ATLASSERT( bSuccess );

    return bSuccess;

} //*** DDX_SetNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDV_RequiredText
//
//  Routine Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] Control ID.
//      nIDCLabel   [IN] Label control ID.
//      rstrValue   [IN] Value to set or get.
//
//  Return Value:
//      TRUE        Required value is present.
//      FALSE       Required value is not present.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DDV_RequiredText(
    IN HWND             hwndDlg,
    IN int              nIDC,
    IN int              nIDCLabel,
    IN const CString &  rstrValue
    )
{
    ATLASSERT( hwndDlg != NULL );

    BOOL    bSuccess = TRUE;
    BOOL    bIsBlank;

    //
    // Get the handle for the control.
    //
    HWND hwndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hwndCtrl != NULL );

    //
    // Get the window class name.
    //
    TCHAR szWindowClass[256];
    GetClassName( hwndCtrl, szWindowClass, (sizeof( szWindowClass ) / sizeof( TCHAR )) - 1 );

    //
    // If this is the IP Address control, send a special message to
    // determine if it is empty or not.
    //
    if ( _tcsncmp( szWindowClass, WC_IPADDRESS, RTL_NUMBER_OF( szWindowClass ) ) == 0 )
    {
        bIsBlank = static_cast< BOOL >( SendMessage( hwndCtrl, IPM_ISBLANK, 0, 0 ) );
    } // if:  IP Address control
    else
    {
        bIsBlank = rstrValue.GetLength() == 0;
    } // else:  edit control

    if ( bIsBlank )
    {
        TCHAR       szLabel[1024];

        bSuccess = FALSE;

        //
        // Get the text of the label.
        //
        GetDlgItemText( hwndDlg, nIDCLabel, szLabel, sizeof( szLabel ) / sizeof( TCHAR ) );

        //
        // Remove ampersands (&) and colons (:).
        //
        CleanupLabel( szLabel );

        //
        // Format and display a message.
        //
        CString strPrompt;
        strPrompt.FormatMessage( IDS_REQUIRED_FIELD_EMPTY, szLabel );
        AppMessageBox( hwndDlg, strPrompt, MB_ICONEXCLAMATION );

        //
        // Set focus to the control.
        hwndCtrl = GetDlgItem( hwndDlg, nIDC );
        ATLASSERT( hwndCtrl != NULL );
        SetFocus( hwndCtrl );
    }  // if:  field not specified

    return bSuccess;

} //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupLabel
//
//  Routine Description:
//      Prepare a label read from a dialog to be used as a string in a
//      message by removing ampersands (&) and colons (:).
//
//  Arguments:
//      pszLabel    [IN OUT] Label to be cleaned up.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel( IN OUT LPTSTR pszLabel )
{
    LPTSTR  pIn, pOut;
    LANGID  langid;
    WORD    primarylangid;
    BOOL    bFELanguage;

    //
    // Get the language ID.
    //
    langid = GetUserDefaultLangID();
    primarylangid = (WORD) PRIMARYLANGID( langid );
    bFELanguage = ((primarylangid == LANG_JAPANESE)
                    || (primarylangid == LANG_CHINESE)
                    || (primarylangid == LANG_KOREAN));

    //
    // Copy the name sans '&' and ':' chars
    //

    pIn = pOut = pszLabel;
    do
    {
        //
        // Strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
        //
        if (   bFELanguage
            && (pIn[0] == _T('('))
            && (pIn[1] == _T('&'))
            && (pIn[2] != _T('\0'))
            && (pIn[3] == _T(')')))
        {
            pIn += 3;
        } // if:  FE language and parenthesized hotkey present
        else if ( (*pIn != _T('&')) && (*pIn != _T(':')) )
        {
            *pOut++ = *pIn;
        } // if:  found hotkey
    } while ( *pIn++ != _T('\0') ) ;

} //*** CleanupLabel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDV_GetCheck
//
//  Routine Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] Control ID.
//      rnValue     [OUT] Value to get.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_GetCheck( IN HWND hwndDlg, IN int nIDC, OUT int & rnValue )
{
    ATLASSERT( hwndDlg != NULL );

    //
    // Get the handle for the control.
    //
    HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hWndCtrl != NULL );

    rnValue = (int)::SendMessage( hWndCtrl, BM_GETCHECK, 0, 0L );
    ATLASSERT( (rnValue >= 0) && (rnValue <= 2) );

} //*** DDX_GetCheck()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_SetCheck
//
//  Routine Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] Control ID.
//      nValue      [IN] Value to set.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_SetCheck( IN HWND hwndDlg, IN int nIDC, IN int nValue )
{
    ATLASSERT( hwndDlg != NULL );

    //
    // Get the handle for the control.
    //
    HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hWndCtrl != NULL );

    ATLASSERT( (nValue >= 0) && (nValue <= 2) );
    if ( (nValue < 0) || (nValue > 2) )
    {
        ATLTRACE( _T("Warning: dialog data checkbox value (%d) out of range.\n"), nValue );
        nValue = 0;  // default to off
    } // if:  value is out of range
    ::SendMessage( hWndCtrl, BM_SETCHECK, (WPARAM) nValue, 0L );

} //*** DDX_SetCheck()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_GetRadio
//
//  Routine Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] Control ID of first radio button in a group.
//      rnValue     [OUT] Value to get.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_GetRadio( IN HWND hwndDlg, IN int nIDC, IN int & rnValue )
{
    ATLASSERT( hwndDlg != NULL );

    //
    // Get the handle for the control.
    //
    HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hWndCtrl != NULL );

    ATLASSERT( ::GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP );
    ATLASSERT( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON );

    rnValue = -1;     // value if none found

    // walk all children in group
    int iButton = 0;
    do
    {
        if ( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON )
        {
            // control in group is a radio button
            if ( ::SendMessage( hWndCtrl, BM_GETCHECK, 0, 0L ) != 0 )
            {
                ASSERT( rnValue == -1 );    // only set once
                rnValue = iButton;
            } // if:  button is set
            iButton++;
        } // if:  control is a radio button
        else
        {
            ATLTRACE( _T("Warning: skipping non-radio button in group.\n") );
        } // else:  control is not a radio button
        hWndCtrl = ::GetWindow( hWndCtrl, GW_HWNDNEXT );

    } while ( hWndCtrl != NULL &&
        !(GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP) );

} //*** DDX_GetRadio()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_SetRadio
//
//  Routine Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      hwndDlg     [IN] Dialog window handle.
//      nIDC        [IN] Control ID of first radio button in a group.
//      nValue      [IN] Value to set.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DDX_SetRadio( IN HWND hwndDlg, IN int nIDC, IN int nValue )
{
    ATLASSERT( hwndDlg != NULL );

    //
    // Get the handle for the control.
    //
    HWND hWndCtrl = GetDlgItem( hwndDlg, nIDC );
    ATLASSERT( hWndCtrl != NULL );

    ATLASSERT( ::GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP );
    ATLASSERT( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON );

    // walk all children in group
    int iButton = 0;
    do
    {
        if ( ::SendMessage( hWndCtrl, WM_GETDLGCODE, 0, 0L ) & DLGC_RADIOBUTTON )
        {
            // control in group is a radio button
            // select button
            ::SendMessage( hWndCtrl, BM_SETCHECK, (iButton == nValue), 0L );
            iButton++;
        } // if:  control is a radio button
        else
        {
            ATLTRACE( _T("Warning: skipping non-radio button in group.\n") );
        } // else:  control is not a radio button
        hWndCtrl = ::GetWindow( hWndCtrl, GW_HWNDNEXT );

    } while (  (hWndCtrl != NULL)
            && ! (GetWindowLong( hWndCtrl, GWL_STYLE ) & WS_GROUP) );

} //*** DDX_SetRadio()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atllcpair.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlLCPair.cpp
//
//	Abstract:
//		Implementation of the CListCtrlPair class.
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AtlLCPair.h"
#include "AtlUtil.h"		// for DDX_xxx
#include "AdmCommonRes.h"	// for ADMC_IDC_LCP_xxx

/////////////////////////////////////////////////////////////////////////////
// class CListCtrlPair
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::BInitDialog
//
//	Routine Description:
//		Generic dialog initialization routine.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Dialog was initialized successfully.
//		FALSE	Error initializing the dialog.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
BOOL CListCtrlPair::BInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_lvcRight, ADMC_IDC_LCP_RIGHT_LIST );
	AttachControl( m_lvcLeft, ADMC_IDC_LCP_LEFT_LIST );
	AttachControl( m_pbAdd, ADMC_IDC_LCP_ADD );
	AttachControl( m_pbRemove, ADMC_IDC_LCP_REMOVE );
	if ( BPropertiesButton() )
	{
		AttachControl( m_pbProperties, ADMC_IDC_LCP_PROPERTIES );
	} // if:  dialog has Properties button

//	if ( BShowImages() )
//	{
//		CClusterAdminApp * papp = GetClusterAdminApp();
//
//		m_lvcLeft.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//		m_lvcRight.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//	} // if:  showing images

	//
	// Disable buttons by default.
	//
	m_pbAdd.EnableWindow( FALSE );
	m_pbRemove.EnableWindow( FALSE );
	if ( BPropertiesButton() )
	{
		m_pbProperties.EnableWindow( FALSE );
	} // if:  dialog has Properties button

	//
	// Set the right list to sort.  Set both to show selection always.
	//
	m_lvcRight.ModifyStyle( 0, LVS_SHOWSELALWAYS | LVS_SORTASCENDING, 0 );
	m_lvcLeft.ModifyStyle( 0, LVS_SHOWSELALWAYS, 0 );

	//
	// Change left list view control extended styles.
	//
	m_lvcLeft.SetExtendedListViewStyle(
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
		);

	//
	// Change right list view control extended styles.
	//
	m_lvcRight.SetExtendedListViewStyle(
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
		LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
		);

	// Duplicate lists.
	DuplicateLists();

	//
	// Insert all the columns.
	//
	{
		int			icol;
		int			ncol;
		int			nUpperBound = m_aColumns.size();
		CString		strColText;

		ATLASSERT( nUpperBound >= 0 );

		for ( icol = 0 ; icol <= nUpperBound ; icol++ )
		{
			strColText.LoadString( m_aColumns[icol].m_idsText );
			ncol = m_lvcLeft.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
			ATLASSERT( ncol == icol );
			ncol = m_lvcRight.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
			ATLASSERT( ncol == icol );
		} // for:  each column
	} // Insert all the columns

	//
	// Fill the list controls.
	//
	FillList( m_lvcRight, LpobjRight() );
	FillList( m_lvcLeft, LpobjLeft() );

	//
	// If read-only, set all controls to be either disabled or read-only.
	//
	if ( BReadOnly() )
	{
		m_lvcRight.EnableWindow( FALSE );
		m_lvcLeft.EnableWindow( FALSE );
	} // if:  sheet is read-only

	return TRUE;

} //*** CListCtrlPair::BInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
BOOL CListCtrlPair::OnSetActive( void )
{
	UINT	nSelCount;

	// Set the focus to the left list.
	m_lvcLeft.SetFocus();
	m_plvcFocusList = &m_lvcLeft;

	// Enable/disable the Properties button.
	nSelCount = m_lvcLeft.GetSelectedCount();
	if ( BPropertiesButton() )
	{
		m_pbProperties.EnableWindow( nSelCount == 1 );
	} // if:  dialog has Properties button

	// Enable or disable the other buttons.
	if ( ! BReadOnly() )
	{
		m_pbAdd.EnableWindow( nSelCount > 0 );
		nSelCount = m_lvcRight.GetSelectedCount();
		m_pbRemove.EnableWindow( nSelCount > 0 );
	} // if:  not read-only page

	return TRUE;

} //*** CListCtrlPair::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU method.
//
//	Arguments:
//		pWnd		Window in which the user right clicked the mouse.
//		point		Position of the cursor, in screen coordinates.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
LRESULT CListCtrlPair::OnContextMenu(
	IN UINT			uMsg,
	IN WPARAM		wParam,
	IN LPARAM		lParam,
	IN OUT BOOL &	bHandled
	)
{
	BOOL			bDisplayed	= FALSE;
	CMenu *			pmenu		= NULL;
	HWND			hWnd		= (HWND) wParam;
	WORD			xPos		= LOWORD( lParam );
	WORD			yPos		= HIWORD( lParam );
	CListViewCtrl *	plvc;
	CString			strMenuName;
	CWaitCursor		wc;

	//
	// If focus is not in a list control, don't handle the message.
	//
	if ( hWnd == m_lvcLeft.m_hWnd )
	{
		plvc = &m_lvcLeft;
	} // if:  context menu on left list
	else if ( hWnd == m_lvcRight.m_hWnd )
	{
		plvc = &m_lvcRight;
	} // else if:  context menu on right list
	else
	{
		bHandled = FALSE;
		return 0;
	} // else:  focus not in a list control
	ATLASSERT( plvc != NULL );

	//
	// If the properties button is not enabled, don't display a menu.
	//
	if ( ! BPropertiesButton() )
	{
		bHandled = FALSE;
		return 0;
	} // if:  no properties button

	//
	// Create the menu to display.
	//
	pmenu = new CMenu;
	if ( pmenu->CreatePopupMenu() )
	{
		UINT nFlags = MF_STRING;

		//
		// If there are no items in the list, disable the menu item.
		//
		if ( plvc->GetItemCount() == 0 )
		{
			nFlags |= MF_GRAYED;
		} // if:  no items in the list

		//
		// Add the Properties item to the menu.
		//
		strMenuName.LoadString( ADMC_ID_MENU_PROPERTIES );
		if ( pmenu->AppendMenu( nFlags, ADMC_ID_MENU_PROPERTIES, strMenuName ) )
		{
			m_plvcFocusList = plvc;
			bDisplayed = TRUE;
		} // if:  successfully added menu item
	}  // if:  menu created successfully

	if ( bDisplayed )
	{
		//
		// Display the menu.
		//
		if ( ! pmenu->TrackPopupMenu(
						TPM_LEFTALIGN | TPM_RIGHTBUTTON,
						xPos,
						yPos,
						m_hWnd
						) )
		{
		}  // if:  unsuccessfully displayed the menu
	}  // if:  there is a menu to display

	delete pmenu;
	return 0;

} //*** CListCtrlPair::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListCtrlPair::OnColumnClickList
//
//	Routine Description:
//		Handler method for the LVN_COLUMNCLICK message on the left or
//		right list.
//
//	Arguments:
//		idCtrl		[IN] ID of control sending the message.
//		pnmh		[IN] Notify header.
//		bHandled	[IN OUT] Indicates if we handled or not.  Defaults to TRUE.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class ObjT, class BaseT>
void CListCtrlPair::OnColumnClickList(
	IN int			idCtrl,
	IN LPNMHDR		pnmh,
	IN OUT BOOL &	bHandled
	)
{
	NM_LISTVIEW *	pNMListView = (NM_LISTVIEW *) pnmh;
	SortInfo *		psi;

	if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
	{
		m_plvcFocusList = &m_lvcLeft;
		m_psiCur = &SiLeft();
	} // if:  column clicked in left list
	else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
	{
		m_plvcFocusList = &m_lvcRight;
		m_psiCur = &SiRight();
	} // else if:  column clicked in right list
	else
	{
		ATLASSERT( 0 );
		bHandled = FALSE;
		return 0;
	} // else:  column clicked in unknown list

	// Save the current sort column and direction.
	if ( pNMListView->iSubItem == psi->m_nColumn )
	{
		m_psiCur->m_nDirection ^= -1;
	} // if:  sorting same column again
	else
	{
		m_psiCur->m_nColumn = pNMListView->iSubItem;
		m_psiCur->m_nDirection = 0;
	} // else:  different column

	// Sort the list.
	if ( ! m_plvcFocusList->SortItems( CompareItems, (LPARAM) this ) )
	{
		ATLASSERT( 0 );
	} // if:  error sorting items

	*pResult = 0;

} //*** CListCtrlPair::OnColumnClickList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlextmenu.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlExtMenu.h
//
//	Implementation File:
//		AtlExtMenu.cpp
//
//	Description:
//		Definition of the Cluster Administrator extension menu classes.
//
//	Author:
//		David Potter (davidp)	August 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLEXTMENU_H_
#define __ATLEXTMENU_H_

// Required because of class names longer than 16 characters in lists.
#pragma warning( disable : 4786 ) // identifier was truncated to '255' characters ni the browser information

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExMenuItem;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

interface IWEInvokeCommand;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef std::list< CCluAdmExMenuItem * > CCluAdmExMenuItemList;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluAdmExMenuItem
//
//	Description:
//		Represents one extension DLL's menu item.
//
//	Inheritance:
//		CCluAdmExMenuItem
//
//--
/////////////////////////////////////////////////////////////////////////////
class CCluAdmExMenuItem
{
public:
	//
	// Constructors.
	//

	// Default constructor
	CCluAdmExMenuItem( void )
	{
		CommonConstruct();

	} //*** CCluAdmExMenuItem()

	// Fully specified constructor
	CCluAdmExMenuItem(
				IN LPCTSTR				lpszName,
				IN LPCTSTR				lpszStatusBarText,
				IN ULONG				nExtCommandID,
				IN ULONG				nCommandID,
				IN ULONG				nMenuItemID,
				IN ULONG				uFlags,
				IN BOOL					bMakeDefault,
				IN IWEInvokeCommand *	piCommand
				)
	{
		ATLASSERT( piCommand != NULL );

		CommonConstruct();

		m_strName = lpszName;
		m_strStatusBarText = lpszStatusBarText;
		m_nExtCommandID = nExtCommandID;
		m_nCommandID = nCommandID;
		m_nMenuItemID = nMenuItemID;
		m_uFlags = uFlags;
		m_bDefault = bMakeDefault;
		m_piCommand = piCommand;

		// will throw its own exception if it fails
		if ( uFlags & MF_POPUP )
		{
			m_plSubMenuItems = new CCluAdmExMenuItemList;
		} // if:  popup menu

#if DBG
		AssertValid();
#endif // DBG

	} //*** CCluAdmExMenuItem()

	virtual ~CCluAdmExMenuItem( void )
	{
		delete m_plSubMenuItems;

		// Nuke data so it can't be used again
		CommonConstruct();

	} //*** ~CCluAdmExMenuItem()

protected:
	void CommonConstruct( void )
	{
		m_strName.Empty();
		m_strStatusBarText.Empty();
		m_nExtCommandID = (ULONG) -1;
		m_nCommandID = (ULONG) -1;
		m_nMenuItemID = (ULONG) -1;
		m_uFlags = (ULONG) -1;
		m_bDefault = FALSE;
		m_piCommand = NULL;

		m_plSubMenuItems = NULL;
		m_hmenuPopup = NULL;

	} //*** CommonConstruct()

protected:
	//
	// Attributes.
	//

	CString				m_strName;
	CString				m_strStatusBarText;
	ULONG				m_nExtCommandID;
	ULONG				m_nCommandID;
	ULONG				m_nMenuItemID;
	ULONG				m_uFlags;
	BOOL				m_bDefault;
	IWEInvokeCommand *	m_piCommand;

public:
	//
	// Accessor methods.
	//

	const CString &		StrName( void ) const			{ return m_strName; }
	const CString &		StrStatusBarText( void ) const	{ return m_strStatusBarText; }
	ULONG				NExtCommandID( void ) const		{ return m_nExtCommandID; }
	ULONG				NCommandID( void ) const		{ return m_nCommandID; }
	ULONG				NMenuItemID( void ) const		{ return m_nMenuItemID; }
	ULONG				UFlags( void ) const			{ return m_uFlags; }
	BOOL				BDefault( void ) const			{ return m_bDefault; }
	IWEInvokeCommand *	PiCommand( void )				{ return m_piCommand; }

// Operations
public:
	void SetPopupMenuHandle( IN HMENU hmenu ) { m_hmenuPopup = hmenu; }

// Implementation
protected:
	HMENU					m_hmenuPopup;
	CCluAdmExMenuItemList *	m_plSubMenuItems;

public:
	HMENU					HmenuPopup( void ) const		{ return m_hmenuPopup; }
	CCluAdmExMenuItemList *	PlSubMenuItems( void ) const	{ return m_plSubMenuItems; }

protected:
#if DBG
	void AssertValid( void )
	{
		if (   (m_nExtCommandID == -1)
			|| (m_nCommandID == -1)
			|| (m_nMenuItemID == -1)
			|| (m_uFlags == -1)
			|| (((m_uFlags & MF_POPUP) == 0) && (m_plSubMenuItems != NULL))
			|| (((m_uFlags & MF_POPUP) != 0) && (m_plSubMenuItems == NULL))
			)
		{
			ATLASSERT( FALSE );
		}

	}  //*** AssertValid()
#endif // DBG

}; //*** class CCluAdmExMenuItem

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLEXTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlutil.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlUtil.h
//
//	Abstract:
//		Definitions of helper functions for use in an ATL project.
//
//	Implementation File:
//		AtlUtils.cpp
//
//	Author:
//		David Potter (davidp)	December 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLUTIL_H_
#define __ATLUTIL_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

// Get a text value from a control on a dialog
BOOL DDX_GetText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT CString &	rstrValue
	);

// Set a text value into a control on a dialog
BOOL DDX_SetText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN const CString &	rstrValue
	);

// Set a text value into a combobox control on a dialog
BOOL DDX_SetComboBoxText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN const CString &	rstrValue,
	IN BOOL				bRequired = FALSE
	);

// Get a numeric value from a control on a dialog
BOOL DDX_GetNumber(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT ULONG &		rnValue,
	IN ULONG			nMin,
	IN ULONG			nMax,
	IN BOOL				bSigned
	);

// Get a numeric value from a control on a dialog
inline BOOL DDX_GetNumber(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN OUT LONG &		rnValue,
	IN LONG				nMin,
	IN LONG				nMax
	)
{
	return DDX_GetNumber(
		hwndDlg,
		nIDC,
		reinterpret_cast< ULONG & >( rnValue ),
		static_cast< ULONG >( nMin ),
		static_cast< ULONG >( nMax ),
		TRUE /*bSigned*/
		);

} //*** DDX_GetNumber( LONG & )

// Set a numeric value into a control on a dialog dialog
BOOL DDX_SetNumber(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN ULONG			nValue,
	IN ULONG			nMin,
	IN ULONG			nMax,
	IN BOOL				bSigned
	);

// Validate that the dialog string is present
BOOL DDV_RequiredText(
	IN HWND				hwndDlg,
	IN int				nIDC,
	IN int				nIDCLabel,
	IN const CString &	rstrValue
	);

// Get the value of a checkbox
void DDX_GetCheck( IN HWND hwndDlg, IN int nIDC, OUT int & rnValue );

// Set the value of a checkbox
void DDX_SetCheck( IN HWND hwndDlg, IN int nIDC, IN int nValue );

// Get the number of the radio button that is slected in a group
void DDX_GetRadio( IN HWND hwndDlg, IN int nIDC, OUT int & rnValue );

// Set the radio button states in a group
void DDX_SetRadio( IN HWND hwndDlg, IN int nIDC, IN int nValue );

// Remove ampersands and colons from a label
void CleanupLabel( IN OUT LPTSTR psz );

/////////////////////////////////////////////////////////////////////////////

#endif //__ATLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atllcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      AtlLCPair.h
//
//  Implementation File:
//      None.
//
//  Description:
//      Definition of the CListCtrlPair dialog.
//      Derive from CDialogImpl<> or CPropertyPageImpl<>.
//
//  Author:
//      David Potter (davidp)   August 8, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLLCPAIR_H_
#define __ATLLCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T, class ObjT, class BaseT > class CListCtrlPair;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#include "AdmCommonRes.h"   // for ADMC_IDC_LCP_xxx
#endif

#ifndef __ATLUTIL_H_
#include "AtlUtil.h"        // for DDX_xxx
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CLcpColumn
{
    UINT m_idsText;
    int m_nWidth;
};

#define LCPS_SHOW_IMAGES            0x1
#define LCPS_ALLOW_EMPTY            0x2
#define LCPS_CAN_BE_ORDERED         0x4
#define LCPS_ORDERED                0x8
#define LCPS_DONT_OUTPUT_RIGHT_LIST 0x10
#define LCPS_READ_ONLY              0x20
#define LCPS_PROPERTIES_BUTTON      0x40
#define LCPS_MAX                    0x40

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CListCtrlPair
//
//  Description:
//      Class to support dual list box.
//
//  Inheritance:
//      CListCtrlPair< T, ObjT, BaseT >
//      <BaseT>
//      ...
//      CDialogImpl< T >
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T, class ObjT, class BaseT >
class CListCtrlPair : public BaseT
{
//  friend class CListCtrlPairDlg;
//  friend class CListCtrlPairPage;
//  friend class CListCtrlPairWizPage;

    typedef CListCtrlPair< T, ObjT, BaseT > thisClass;
    typedef std::list< ObjT * >             _objptrlist;
    typedef typename std::list< ObjT * >::iterator   _objptrlistit;

protected:
    // Column structure and collection.
    typedef std::vector< CLcpColumn > CColumnArray;
    CColumnArray    m_aColumns;

    // Sort information.
    struct SortInfo
    {
        int     m_nDirection;
        int     m_nColumn;
    };

public:
    //
    // Construction
    //

    // Default constructor
    CListCtrlPair( void )
    {
        CommonConstruct();

    } //*** CListCtrlPair()

    // Constructor with style specified
    CListCtrlPair(
        IN DWORD    dwStyle,
        IN LPCTSTR  lpszTitle = NULL
        )
        : BaseT( lpszTitle )
    {
        CommonConstruct();
        m_dwStyle = dwStyle;

    } //*** CListCtrlPair( lpszTitle )

    // Constructor with style specified
    CListCtrlPair(
        IN DWORD    dwStyle,
        IN UINT     nIDTitle
        )
        : BaseT( nIDTitle )
    {
        CommonConstruct();
        m_dwStyle = dwStyle;

    } //*** CListCtrlPair( nIDTitle )

    // Common object construction
    void CommonConstruct( void )
    {
        m_dwStyle = LCPS_ALLOW_EMPTY;
        m_plvcFocusList = NULL;

        // Set the sort info.
        SiLeft().m_nDirection = -1;
        SiLeft().m_nColumn = -1;
        SiRight().m_nDirection = -1;
        SiRight().m_nColumn = -1;

    } //*** CommonConstruct()

public:
    //
    // Functions that are required to be implemented by derived class.
    //

    // Return list of objects for right list control
    _objptrlist * PlpobjRight( void ) const
    {
        ATLTRACE( _T("PlpobjRight() - Define in derived class\n") );
        ATLASSERT( 0 );
        return NULL;

    } //*** PlpobjRight()

    // Return list of objects for left list control
    const _objptrlist * PlpobjLeft( void ) const
    {
        ATLTRACE( _T("PlpobjLeft() - Define in derived class\n") );
        ATLASSERT( 0 );
        return NULL;
    
    } //*** PlpobjLeft()

    // Get column text and image
    void GetColumnInfo(
        IN OUT ObjT *   pobj,
        IN int          iItem,
        IN int          icol,
        OUT CString &   rstr,
        OUT int *       piimg
        )
    {
        ATLTRACE( _T("GetColumnInfo() - Define in derived class\n") );
        ATLASSERT( 0 );

    } //*** GetColumnInfo()

    // Display properties for the object
    int BDisplayProperties( IN OUT ObjT * pobj )
    {
        ATLTRACE( _T("BDisplayProperties() - Define in derived class\n") );
        ATLASSERT( 0 );
        return FALSE;

    } //*** BDisplayProperties()

    // Display an application-wide message box
    virtual int AppMessageBox( LPCWSTR lpszText, UINT fuStyle )
    {
        ATLTRACE( _T("BDisplayProperties() - Define in derived class\n") );
        ATLASSERT( 0 );
        return MessageBox( lpszText, _T(""), fuStyle );

    } //*** AppMessageBox()

    // Display an application-wide message box
    int AppMessageBox( UINT nID, UINT fuStyle )
    {
        CString strMsg;
        strMsg.LoadString( nID );
        return AppMessageBox( strMsg, fuStyle );

    } //*** AppMessageBox()

protected:
    //
    // List control pair style.
    //

    DWORD m_dwStyle;

    BOOL BIsStyleSet( IN DWORD dwStyle ) const  { return (m_dwStyle & dwStyle) == dwStyle; }
    void ModifyStyle( IN DWORD dwRemove, IN DWORD dwAdd )
    {
        ATLASSERT( (dwRemove & dwAdd) == 0 );
        if ( dwRemove != 0 )
        {
            m_dwStyle &= ~dwRemove;
        } // if:  removing some styles
        if ( dwAdd != 0 )
        {
            m_dwStyle |= dwAdd;
        } // if:  adding some styles

    } //*** ModifyStyle()

    DWORD       DwStyle( void ) const               { return m_dwStyle; }
    BOOL        BShowImages( void ) const           { return BIsStyleSet( LCPS_SHOW_IMAGES ); }
    BOOL        BAllowEmpty( void ) const           { return BIsStyleSet( LCPS_ALLOW_EMPTY ); }
    BOOL        BCanBeOrdered( void ) const         { return BIsStyleSet( LCPS_CAN_BE_ORDERED ); }
    BOOL        BOrdered( void ) const              { return BIsStyleSet( LCPS_ORDERED ); }
    BOOL        BReadOnly( void ) const             { return BIsStyleSet( LCPS_READ_ONLY ); }
    BOOL        BPropertiesButton( void ) const     { return BIsStyleSet( LCPS_PROPERTIES_BUTTON ); }

// Operations
public:

    // Add column to list of columns displayed in each list control
    void AddColumn( IN UINT idsText, IN int nWidth )
    {
        CLcpColumn col;

        ATLASSERT( idsText != 0 );
        ATLASSERT( nWidth > 0 );
        ATLASSERT( LpobjRight().empty() );

        col.m_idsText = idsText;
        col.m_nWidth = nWidth;

        m_aColumns.insert( m_aColumns.end(), col );

    } //*** AddColumn()

    // Insert an item in a list control
    int NInsertItemInListCtrl(
            IN int                  iitem,
            IN OUT ObjT *           pobj,
            IN OUT CListViewCtrl &  rlc
            )
    {
        int         iRetItem;
        CString     strText;
        int         iimg = 0;
        int         icol;

        // Insert the first column.
        ((T *) this)->GetColumnInfo( pobj, iitem, 0, strText, &iimg );
        iRetItem = rlc.InsertItem(
                        LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM,    // nMask
                        iitem,                                  // nItem
                        strText,                                // lpszItem
                        0,                                      // nState
                        0,                                      // nStateMask
                        iimg,                                   // nImage
                        (LPARAM) pobj                           // lParam
                        );
        ATLASSERT( iRetItem != -1 );

        for ( icol = 1 ; icol < (int) m_aColumns.size() ; icol++ )
        {
            ((T *) this)->GetColumnInfo( pobj, iRetItem, icol, strText, NULL );
            rlc.SetItemText( iRetItem, icol, strText );
        } // for:  each column

        return iRetItem;

    } //*** NInsertItemInListCtrl()

    // Update data on or from the dialog
    BOOL UpdateData( IN BOOL bSaveAndValidate )
    {
        BOOL bSuccess = TRUE;

        if ( bSaveAndValidate )
        {
            //
            // Verify that the list is not empty.
            //
            if ( ! BAllowEmpty() && (m_lvcRight.GetItemCount() == 0) )
            {
                CString     strMsg;
                CString     strLabel;
                TCHAR *     pszLabel;

                DDX_GetText( m_hWnd, ADMC_IDC_LCP_RIGHT_LABEL, strLabel );

                //
                // Remove ampersands (&) and colons (:).
                //
                pszLabel = strLabel.GetBuffer( 1 );
                CleanupLabel( pszLabel );
                strLabel.ReleaseBuffer();

                //
                // Display an error message.
                //
                strMsg.FormatMessage( ADMC_IDS_EMPTY_RIGHT_LIST, pszLabel );
                AppMessageBox( strMsg, MB_OK | MB_ICONWARNING );

                bSuccess = FALSE;
            } // if:  list is empty and isn't allowed to be
        } // if:  saving data from the dialog
        else
        {
        } // else:  setting data to the dialog

        return bSuccess;

    } //*** UpdateData()

    // Apply changes made on this dialog
    BOOL BApplyChanges( void )
    {
        ATLASSERT( ! BIsStyleSet( LCPS_DONT_OUTPUT_RIGHT_LIST ) );
        ATLASSERT( ! BReadOnly() );

        T * pT = static_cast< T * >( this );

        //
        // Copy the Nodes list.
        //
        *pT->PlpobjRight() = LpobjRight();

        //
        // Call the base class method.
        //
        return BaseT::BApplyChanges();

    } //*** BApplyChanges()

// Implementation
protected:
    _objptrlist     m_lpobjRight;
    _objptrlist     m_lpobjLeft;
    CListViewCtrl   m_lvcRight;
    CListViewCtrl   m_lvcLeft;
    CListViewCtrl * m_plvcFocusList;
    CButton         m_pbAdd;
    CButton         m_pbRemove;
    CButton         m_pbMoveUp;
    CButton         m_pbMoveDown;
    CButton         m_pbProperties;

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        MESSAGE_HANDLER( WM_CONTEXTMENU, OnContextMenu )
        COMMAND_HANDLER( ADMC_IDC_LCP_ADD,        BN_CLICKED, OnAdd )
        COMMAND_HANDLER( ADMC_IDC_LCP_REMOVE,     BN_CLICKED, OnRemove )
        COMMAND_HANDLER( ADMC_IDC_LCP_MOVE_UP,    BN_CLICKED, OnMoveUp )
        COMMAND_HANDLER( ADMC_IDC_LCP_MOVE_DOWN,  BN_CLICKED, OnMoveDown )
        COMMAND_HANDLER( ADMC_IDC_LCP_PROPERTIES, BN_CLICKED, OnProperties )
        COMMAND_HANDLER( IDOK,                    BN_CLICKED, OnOK )
        COMMAND_HANDLER( IDCANCEL,                BN_CLICKED, OnCancel )
        COMMAND_HANDLER( ADMC_ID_MENU_PROPERTIES, 0, OnProperties )
        NOTIFY_HANDLER( ADMC_IDC_LCP_LEFT_LIST,   NM_DBLCLK, OnDblClkList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_RIGHT_LIST,  NM_DBLCLK, OnDblClkList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_LEFT_LIST,   LVN_ITEMCHANGED, OnItemChangedList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_RIGHT_LIST,  LVN_ITEMCHANGED, OnItemChangedList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_LEFT_LIST,   LVN_COLUMNCLICK, OnColumnClickList )
        NOTIFY_HANDLER( ADMC_IDC_LCP_RIGHT_LIST,  LVN_COLUMNCLICK, OnColumnClickList )
        CHAIN_MSG_MAP( BaseT )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for WM_CONTEXTMENU
    LRESULT OnContextMenu(
        IN UINT         uMsg,
        IN WPARAM       wParam,
        IN LPARAM       lParam,
        IN OUT BOOL &   bHandled
        )
    {
        BOOL            bDisplayed  = FALSE;
        CMenu *         pmenu       = NULL;
        HWND            hWnd        = (HWND) wParam;
        WORD            xPos        = LOWORD( lParam );
        WORD            yPos        = HIWORD( lParam );
        CListViewCtrl * plvc;
        CString         strMenuName;
        CWaitCursor     wc;

        //
        // If focus is not in a list control, don't handle the message.
        //
        if ( hWnd == m_lvcLeft.m_hWnd )
        {
            plvc = &m_lvcLeft;
        } // if:  context menu on left list
        else if ( hWnd == m_lvcRight.m_hWnd )
        {
            plvc = &m_lvcRight;
        } // else if:  context menu on right list
        else
        {
            bHandled = FALSE;
            return 0;
        } // else:  focus not in a list control
        ATLASSERT( plvc != NULL );

        //
        // If the properties button is not enabled, don't display a menu.
        //
        if ( ! BPropertiesButton() )
        {
            bHandled = FALSE;
            return 0;
        } // if:  no properties button

        //
        // Create the menu to display.
        //
        pmenu = new CMenu;
        ATLASSERT( pmenu != NULL );
        if ( pmenu == NULL )
        {
            bHandled = FALSE;
            return 0;
        } // if: error allocating memory for the new menu

        if ( pmenu->CreatePopupMenu() )
        {
            UINT nFlags = MF_STRING;

            //
            // If there are no items in the list, disable the menu item.
            //
            if ( plvc->GetItemCount() == 0 )
            {
                nFlags |= MF_GRAYED;
            } // if:  no items in the list

            //
            // Add the Properties item to the menu.
            //
            strMenuName.LoadString( ADMC_ID_MENU_PROPERTIES );
            if ( pmenu->AppendMenu( nFlags, ADMC_ID_MENU_PROPERTIES, strMenuName ) )
            {
                m_plvcFocusList = plvc;
                bDisplayed = TRUE;
            } // if:  successfully added menu item
        }  // if:  menu created successfully

        if ( bDisplayed )
        {
            //
            // Display the menu.
            //
            if ( ! pmenu->TrackPopupMenu(
                            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                            xPos,
                            yPos,
                            m_hWnd
                            ) )
            {
            }  // if:  unsuccessfully displayed the menu
        }  // if:  there is a menu to display

        delete pmenu;
        return 0;

    } //*** OnContextMenu()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_ADD
    LRESULT OnAdd(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        ATLASSERT( ! BReadOnly() );

        //
        // Move selected items from the left list to the right list.
        //
        MoveItems( m_lvcRight, LpobjRight(), m_lvcLeft, LpobjLeft() );

        return 0;

    } //*** OnAdd()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_REMOVE
    LRESULT OnRemove(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        ATLASSERT( ! BReadOnly() );

        //
        // Move selected items from the right list to the left list.
        //
        MoveItems( m_lvcLeft, LpobjLeft(), m_lvcRight, LpobjRight() );

        return 0;

    } //*** OnRemove()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_MOVE_UP
    LRESULT OnMoveUp(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        int     nItem;
        ObjT *  pobj;

        //
        // Find the index of the selected item.
        //
        nItem = m_lvcRight.GetNextItem( -1, LVNI_SELECTED );
        ATLASSERT( nItem != -1 );

        //
        // Get the item pointer.
        //
        pobj = (ObjT *) m_lvcRight.GetItemData( nItem );
        ATLASSERT( pobj != NULL );

        // Remove the selected item from the list and add it back in.
        {
            _objptrlistit   itRemove;
            _objptrlistit   itAdd;

            // Find the position of the item to be removed and the item before
            // which the item is to be inserted.
            itRemove = std::find( LpobjRight().begin(), LpobjRight().end(), pobj );
            ATLASSERT( itRemove != LpobjRight().end() );
            itAdd = itRemove--;
            LpobjRight().insert( itAdd, pobj );
            LpobjRight().erase( itRemove );
        }  // Remove the selected item from the list and add it back in

        // Remove the selected item from the list control and add it back in.
        m_lvcRight.DeleteItem( nItem );
        NInsertItemInListCtrl( nItem - 1, pobj, m_lvcRight );
        m_lvcRight.SetItemState(
            nItem - 1,
            LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED
            );
        m_lvcRight.EnsureVisible( nItem - 1, FALSE /*bPartialOK*/ );
        m_lvcRight.SetFocus();

        return 0;

    }  //*** OnMoveUp()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_MOVE_DOWN
    LRESULT OnMoveDown(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        int     nItem;
        ObjT *  pobj;

        //
        // Find the index of the selected item.
        //
        nItem = m_lvcRight.GetNextItem( -1, LVNI_SELECTED );
        ATLASSERT( nItem != -1 );

        //
        // Get the item pointer.
        //
        pobj = (ObjT *) m_lvcRight.GetItemData( nItem );
        ATLASSERT( pobj != NULL );

        // Remove the selected item from the list and add it back in.
        {
            _objptrlistit   itRemove;
            _objptrlistit   itAdd;

            // Find the position of the item to be removed and the item after
            // which the item is to be inserted.
            itRemove = std::find( LpobjRight().begin(), LpobjRight().end(), pobj );
            ATLASSERT( itRemove != LpobjRight().end() );
            itAdd = itRemove++;
            LpobjRight().insert( itAdd, pobj );
            LpobjRight().erase( itRemove );
        }  // Remove the selected item from the list and add it back in

        // Remove the selected item from the list control and add it back in.
        m_lvcRight.DeleteItem( nItem );
        NInsertItemInListCtrl( nItem + 1, pobj, m_lvcRight );
        m_lvcRight.SetItemState(
            nItem + 1,
            LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED
            );
        m_lvcRight.EnsureVisible( nItem + 1, FALSE /*bPartialOK*/ );
        m_lvcRight.SetFocus();

        return 0;

    }  //*** OnMoveDown()

    // Handler for BN_CLICKED on ADMC_IDC_LCP_PROPERTIES
    LRESULT OnProperties(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        int     iitem;
        ObjT *  pobj;

        ATLASSERT( m_plvcFocusList != NULL );

        // Get the index of the item with the focus.
        iitem = m_plvcFocusList->GetNextItem( -1, LVNI_FOCUSED );
        ATLASSERT( iitem != -1 );

        // Get a pointer to the selected item.
        pobj = (ObjT *) m_plvcFocusList->GetItemData( iitem );
        ATLASSERT( pobj != NULL );

        T * pT = static_cast< T * >( this );

        if ( pT->BDisplayProperties( pobj ) )
        {
            // Update this item.
            {
                CString     strText;
                int         iimg = 0;
                int         icol;

                pT->GetColumnInfo( pobj, iitem, 0, strText, &iimg );
                m_plvcFocusList->SetItem( iitem, 0, LVIF_TEXT /*| LVIF_IMAGE*/, strText, iimg, 0, 0, 0 );

                for ( icol = 1 ; icol < (int) m_aColumns.size() ; icol++ )
                {
                    pT->GetColumnInfo( pobj, iitem, icol, strText, NULL );
                    m_plvcFocusList->SetItemText( iitem, icol, strText );
                } // for:  each column
            } // Update this item
        } // if:  properties changed

        return 0;

    } //*** OnProperties()

    // Handler for BN_CLICKED on IDOK
    LRESULT OnOK(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        //
        // Save dialog data and exit the dialog.
        //
        if ( BSaveChanges() )
        {
            EndDialog( IDOK );
        } // if:  dialgo data saved

        return 0;

    } //*** OnOK()

    // Handler for BN_CLICKED on IDCANCEL
    LRESULT OnCancel(
        IN WORD         wNotifyCode,
        IN int          idCtrl,
        IN HWND         hwndCtrl,
        IN OUT BOOL &   bHandled
        )
    {
        //
        // Exit the dialog.
        //
        EndDialog( IDCANCEL );
        return 0;

    } //*** OnCancel()

    // Handler for NM_DBLCLK on ADMC_IDC_LCP_LEFT_LIST & ADMC_IDC_LCP_RIGHT_LIST
    LRESULT OnDblClkList(
        IN int          idCtrl,
        IN LPNMHDR      pnmh,
        IN OUT BOOL &   bHandled
        )
    {
        ATLASSERT( ! BReadOnly() );

        LRESULT lResult;

        if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
        {
            m_plvcFocusList = &m_lvcLeft;
            lResult = OnAdd( BN_CLICKED, idCtrl, pnmh->hwndFrom, bHandled );
        } // if:  double-clicked in left list
        else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
        {
            m_plvcFocusList = &m_lvcRight;
            lResult = OnRemove( BN_CLICKED, idCtrl, pnmh->hwndFrom, bHandled );
        } // else if:  double-clicked in right list
        else
        {
            ATLASSERT( 0 );
            lResult = 0;
        } // else:  double-clicked in an unknown location

        return lResult;

    } //*** OnDblClkList()

    // Handler for LVN_ITEMCHANGED on ADMC_IDC_LCP_LEFT_LIST & ADMC_IDC_LCP_RIGHT_LIST
    LRESULT OnItemChangedList(
        IN int          idCtrl,
        IN LPNMHDR      pnmh,
        IN OUT BOOL &   bHandled
        )
    {
        NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pnmh;
        BOOL            bEnable;
        CButton *       ppb;

        if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
        {
            m_plvcFocusList = &m_lvcLeft;
            ppb = &m_pbAdd;
        } // if:  item changed in left list
        else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
        {
            m_plvcFocusList = &m_lvcRight;
            ppb = &m_pbRemove;
        } // else if:  item changed in right list
        else
        {
            ATLASSERT( 0 );
            bHandled = FALSE;
            return 0;
        } // else:  unknown list
        ATLASSERT( ppb != NULL );

        // If the selection changed, enable/disable the Add button.
        if (   (pNMListView->uChanged & LVIF_STATE)
            && (   (pNMListView->uOldState & LVIS_SELECTED)
                || (pNMListView->uNewState & LVIS_SELECTED) )
            && ! BReadOnly() )
        {
            UINT cSelected = m_plvcFocusList->GetSelectedCount();

            //
            // If there is a selection, enable the Add or Remove button.
            // Otherwise disable it.
            //
            bEnable = (cSelected != 0);
            ppb->EnableWindow( bEnable );
            if ( BPropertiesButton() )
            {
                m_pbProperties.EnableWindow( (cSelected == 1) ? TRUE : FALSE );
            } // if:  dialog has Properties button

            //
            // If the right list is ordered, setup the state of the Up/Down buttons.
            //
            if ( BOrdered() )
            {
                SetUpDownState();
            } // if:  right list is ordered
        }  // if:  selection changed

        return 0;

    } //*** OnItemChangedList()

    // Handler for LVN_COLUMNCLICK on ADMC_IDC_LCP_LEFT_LIST & ADMC_IDC_LCP_RIGHT_LIST
    LRESULT OnColumnClickList(
        IN int          idCtrl,
        IN LPNMHDR      pnmh,
        IN OUT BOOL &   bHandled
        )
    {
        NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pnmh;

        if ( idCtrl == ADMC_IDC_LCP_LEFT_LIST )
        {
            m_plvcFocusList = &m_lvcLeft;
            m_psiCur = &SiLeft();
        } // if:  column clicked in left list
        else if ( idCtrl == ADMC_IDC_LCP_RIGHT_LIST )
        {
            m_plvcFocusList = &m_lvcRight;
            m_psiCur = &SiRight();
        } // else if:  column clicked in right list
        else
        {
            ATLASSERT( 0 );
            bHandled = FALSE;
            return 0;
        } // else:  column clicked in unknown list

        // Save the current sort column and direction.
        if ( pNMListView->iSubItem == m_psiCur->m_nColumn )
        {
            m_psiCur->m_nDirection ^= -1;
        } // if:  sorting same column again
        else
        {
            m_psiCur->m_nColumn = pNMListView->iSubItem;
            m_psiCur->m_nDirection = 0;
        } // else:  different column

        // Sort the list.
        if ( ! m_plvcFocusList->SortItems( CompareItems, (LPARAM) this ) )
        {
            ATLASSERT( 0 );
        } // if:  error sorting items

        return 0;

    } //*** OnColumnClickList

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void )
    {
#if DBG
        T * pT = static_cast< T * >( this );
        ATLASSERT( pT->PlpobjRight() != NULL );
        ATLASSERT( pT->PlpobjLeft() != NULL );
#endif // DBG

        BOOL fReturn = FALSE;

        //
        // Attach the controls to control member variables.
        //
        AttachControl( m_lvcRight, ADMC_IDC_LCP_RIGHT_LIST );
        AttachControl( m_lvcLeft, ADMC_IDC_LCP_LEFT_LIST );
        AttachControl( m_pbAdd, ADMC_IDC_LCP_ADD );
        AttachControl( m_pbRemove, ADMC_IDC_LCP_REMOVE );
        if ( BPropertiesButton() )
        {
            AttachControl( m_pbProperties, ADMC_IDC_LCP_PROPERTIES );
        } // if:  dialog has Properties button
        if ( BCanBeOrdered() )
        {
            AttachControl( m_pbMoveUp, ADMC_IDC_LCP_MOVE_UP );
            AttachControl( m_pbMoveDown, ADMC_IDC_LCP_MOVE_DOWN );
        } // if:  left list can be ordered

//      if ( BShowImages() )
//      {
//          CClusterAdminApp * papp = GetClusterAdminApp();
//
//          m_lvcLeft.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//          m_lvcRight.SetImageList( papp->PilSmallImages(), LVSIL_SMALL );
//      } // if:  showing images

        //
        // Disable buttons by default.
        //
        m_pbAdd.EnableWindow( FALSE );
        m_pbRemove.EnableWindow( FALSE );
        if ( BPropertiesButton() )
        {
            m_pbProperties.EnableWindow( FALSE );
        } // if:  dialog has Properties button

        //
        // Set the right list to sort if not ordered.  Set both to show selection always.
        //
        if ( BOrdered() )
        {
            m_lvcRight.ModifyStyle( 0, LVS_SHOWSELALWAYS, 0 );
        } // if:  right list is ordered
        else
        {
            m_lvcRight.ModifyStyle( 0, LVS_SHOWSELALWAYS | LVS_SORTASCENDING, 0 );
        } // else:  right list is not ordered
        m_lvcLeft.ModifyStyle( 0, LVS_SHOWSELALWAYS, 0 );


        //
        // If this is an ordered list, show the Move buttons.
        // Otherwise, hide them.
        //
        if ( BCanBeOrdered() )
        {
            SetUpDownState();
        } // if:  list can be ordered

        //
        // Change left list view control extended styles.
        //
        m_lvcLeft.SetExtendedListViewStyle(
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
            );

        //
        // Change right list view control extended styles.
        //
        m_lvcRight.SetExtendedListViewStyle(
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
            );

        // Duplicate lists.
        DuplicateLists();

        //
        // Insert all the columns.
        //
        {
            int         icol;
            int         ncol;
            size_t      nUpperBound = m_aColumns.size();
            CString     strColText;

            ATLASSERT( nUpperBound > 0 );

            for ( icol = 0 ; icol < static_cast< int >( nUpperBound ) ; icol++ )
            {
                strColText.LoadString( m_aColumns[icol].m_idsText );
                ncol = m_lvcLeft.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
                ATLASSERT( ncol == icol );
                ncol = m_lvcRight.InsertColumn( icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0 );
                ATLASSERT( ncol == icol );
            } // for:  each column
        } // Insert all the columns

        //
        // Fill the list controls.
        //
        FillList( m_lvcRight, LpobjRight() );
        FillList( m_lvcLeft, LpobjLeft() );

        //
        // If read-only, set all controls to be either disabled or read-only.
        //
        if ( BReadOnly() )
        {
            m_lvcRight.EnableWindow( FALSE );
            m_lvcLeft.EnableWindow( FALSE );
        } // if:  sheet is read-only

        //
        // Call the base class method.
        //
        fReturn = static_cast< BOOL >( BaseT::OnInitDialog() );

        return fReturn;

    } //*** OnInitDialog()

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void )
    {
        UINT    nSelCount;

        // Set the focus to the left list.
        m_lvcLeft.SetFocus();
        m_plvcFocusList = &m_lvcLeft;

        // Enable/disable the Properties button.
        nSelCount = m_lvcLeft.GetSelectedCount();
        if ( BPropertiesButton() )
        {
            m_pbProperties.EnableWindow( nSelCount == 1 );
        } // if:  dialog has Properties button

        // Enable or disable the other buttons.
        if ( ! BReadOnly() )
        {
            m_pbAdd.EnableWindow( nSelCount > 0 );
            nSelCount = m_lvcRight.GetSelectedCount();
            m_pbRemove.EnableWindow( nSelCount > 0 );
            SetUpDownState();
        } // if:  not read-only page

        return TRUE;

    } //*** OnSetActive()

public:
    _objptrlist & LpobjRight( void )    { return m_lpobjRight; }
    _objptrlist & LpobjLeft( void )     { return m_lpobjLeft; }

protected:
    void DuplicateLists( void )
    {
        LpobjRight().erase( LpobjRight().begin(), LpobjRight().end() );
        LpobjLeft().erase( LpobjLeft().begin(), LpobjLeft().end() );

        T * pT = static_cast< T * >( this );

        if ( (pT->PlpobjRight() == NULL) || (pT->PlpobjLeft() == NULL) )
        {
            return;
        } // if:  either list is empty

        //
        // Duplicate the lists.
        //
        LpobjRight() = *pT->PlpobjRight();
        LpobjLeft() = *pT->PlpobjLeft();

        //
        // Remove all the items that are in the right list from
        // the left list.
        //
        _objptrlistit itRight;
        _objptrlistit itLeft;
        for ( itRight = LpobjRight().begin()
            ; itRight != LpobjRight().end()
            ; itRight++ )
        {
            //
            // Find the item in the left list.
            //
            itLeft = std::find( LpobjLeft().begin(), LpobjLeft().end(), *itRight );
            if ( itLeft != LpobjLeft().end() )
            {
                LpobjLeft().erase( itLeft );
            } // if:  object found in left list
        } // for:  each item in the right list

    } //*** DuplicateLists()

    // Fill a list control
    void FillList( IN OUT CListViewCtrl & rlvc, IN const _objptrlist & rlpobj )
    {
        _objptrlistit   itpobj;
        ObjT *          pobj;
        int             iItem;

        // Initialize the control.
        if ( ! rlvc.DeleteAllItems() )
        {
            ATLASSERT( 0 );
        } // if:  error deleting all items

        rlvc.SetItemCount( static_cast< int >( rlpobj.size() ) );

        // Add the items to the list.
        itpobj = rlpobj.begin();
        for ( iItem = 0 ; itpobj != rlpobj.end() ; iItem++, itpobj++ )
        {
            pobj = *itpobj;
            NInsertItemInListCtrl( iItem, pobj, rlvc );
        } // for:  each string in the list

        // If there are any items, set the focus on the first one.
        if ( rlvc.GetItemCount() != 0)
        {
            rlvc.SetItemState( 0, LVIS_FOCUSED, LVIS_FOCUSED );
        } // if:  items were added to the list

    } //*** FillList()

    // Move items from one list to another
    void MoveItems(
            IN OUT CListViewCtrl &  rlvcDst,
            IN OUT _objptrlist &    rlpobjDst,
            IN OUT CListViewCtrl &  rlvcSrc,
            IN OUT _objptrlist &    rlpobjSrc
            )
    {
        int             iSrcItem;
        int             iDstItem;
        int             nItem   = -1;
        ObjT *          pobj;
        _objptrlistit   itpobj;

        ATLASSERT( ! BReadOnly() );

        iDstItem = rlvcDst.GetItemCount();
        while ( (iSrcItem = rlvcSrc.GetNextItem( -1, LVNI_SELECTED )) != -1 )
        {
            // Get the item pointer.
            pobj = (ObjT *) rlvcSrc.GetItemData( iSrcItem );
            ATLASSERT( pobj );

            // Remove the item from the source list.
            itpobj = std::find( rlpobjSrc.begin(), rlpobjSrc.end(), pobj );
            ATLASSERT( itpobj != rlpobjSrc.end() );
            rlpobjSrc.remove( *itpobj );

            // Add the item to the destination list.
            rlpobjDst.insert( rlpobjDst.end(), pobj );

            // Remove the item from the source list control and
            // add it to the destination list control.
            if ( ! rlvcSrc.DeleteItem( iSrcItem ) )
            {
                ATLASSERT( 0 );
            } // if:  error deleting the item
            nItem = NInsertItemInListCtrl( iDstItem++, pobj, rlvcDst );
            rlvcDst.SetItemState(
                nItem,
                LVIS_SELECTED | LVIS_FOCUSED,
                LVIS_SELECTED | LVIS_FOCUSED
                );
        } // while:  more items

        ATLASSERT( nItem != -1 );

        rlvcDst.EnsureVisible( nItem, FALSE /*bPartialOK*/ );
        rlvcDst.SetFocus();

        // Indicate that the data has changed.
        ::SendMessage( GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, NULL );

    } //*** MoveItems()
    BOOL BSaveChanges( void )
    {
        ATLASSERT( ! BIsStyleSet( LCPS_DONT_OUTPUT_RIGHT_LIST ) );
        ATLASSERT( ! BReadOnly() );

        T * pT = static_cast< T * >( this );

        //
        // Update the data first.
        //
        if ( ! pT->UpdateData( TRUE /*bSaveAndValidate*/ ) )
        {
            return FALSE;
        } // if:  error updating data

        //
        // Copy the object list.
        //
        *pT->PlpobjRight() = LpobjRight();

        return TRUE;

    }  //*** BSaveChanges()

    // Set the state of the Up/Down buttons based on the selection.
    void SetUpDownState( void )
    {
        BOOL    bEnableUp;
        BOOL    bEnableDown;

        if (   BOrdered()
            && ! BReadOnly()
            && (m_lvcRight.GetSelectedCount() == 1) )
        {
            int     nItem;

            bEnableUp = TRUE;
            bEnableDown = TRUE;

            //
            // Find the index of the selected item.
            //
            nItem = m_lvcRight.GetNextItem( -1, LVNI_SELECTED );
            ATLASSERT( nItem != -1 );

            //
            // If the first item is selected, can't move up.
            //
            if ( nItem == 0 )
            {
                bEnableUp = FALSE;
            } // if:  first item is selected

            //
            // If the last item is selected, can't move down.
            //
            if ( nItem == m_lvcRight.GetItemCount() - 1 )
            {
                bEnableDown = FALSE;
            } // if:  last item is selected
        }  // if:  only one item selected
        else
        {
            bEnableUp = FALSE;
            bEnableDown = FALSE;
        }  // else:  zero or more than one item selected

        m_pbMoveUp.EnableWindow( bEnableUp );
        m_pbMoveDown.EnableWindow( bEnableDown );

    }  //*** SetUpDownState()
    
    static int CALLBACK CompareItems( LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort )
    {
        ObjT *      pobj1   = reinterpret_cast< ObjT * >( lparam1 );
        ObjT *      pobj2   = reinterpret_cast< ObjT * >( lparam2 );
        T *         plcp    = reinterpret_cast< T * >( lparamSort );
        SortInfo *  psiCur  = plcp->PsiCur();
        int         icol    = psiCur->m_nColumn;
        int         nResult;
        CString     str1;
        CString     str2;

        ATLASSERT( pobj1 != NULL );
        ATLASSERT( pobj2 != NULL );
        ATLASSERT( plcp != NULL );
        ATLASSERT( psiCur->m_nColumn >= 0 );
        ATLASSERT( icol >= 0 );

        plcp->GetColumnInfo( pobj1, 0, icol, str1, NULL );
        plcp->GetColumnInfo( pobj2, 0, icol, str2, NULL );

        nResult = str1.Compare( str2 );

        // Return the result based on the direction we are sorting.
        if ( psiCur->m_nDirection != 0 )
        {
            nResult = -nResult;
        } // if:  sorting in reverse direction

        return nResult;

    } //*** CompareItems()

    SortInfo            m_siLeft;
    SortInfo            m_siRight;
    SortInfo *          m_psiCur;

    SortInfo &          SiLeft( void )          { return m_siLeft; }
    SortInfo &          SiRight( void )         { return m_siRight; }

public:
    SortInfo *          PsiCur( void ) const    { return m_psiCur; }

};  //*** class CListCtrlPair

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLLCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\atlpopuphelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      AtlPopusHelp.h
//
//  Implementation File:
//      None.
//
//  Description:
//      Definition of the CPopusHelp
//
//  Author:
//      Galen Barbee (galenb)   May 18, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLPOPUPHELP_H_
#define __ATLPOPUPHELP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID;
template < class T > class CPopupHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ADMCOMMONRES_H_
#include "AdmCommonRes.h"
#endif // __ADMCOMMONRES_H_

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// struct CMapCtrlToHelpID
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
    DWORD   m_nCtrlID;
    DWORD   m_nHelpCtrlID;

}; //*** struct CMapCtrlToHelpID

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPopupHelp
//
//  Description:
//      Provide popup-help functionality.
//
//  Inheritance:
//      CPopupHelp
//
//--
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CPopupHelp
{
    typedef CPopupHelp< T > thisClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CPopupHelp( void )
    {
    } //*** CPopupHelp()

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisclass )
        MESSAGE_HANDLER( WM_HELP, LrOnHelp )
        MESSAGE_HANDLER( WM_CONTEXTMENU, LrOnContextMenu )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    /////////////////////////////////////////////////////////////////////////////
    //++
    //
    //  LrOnContextMenu
    //
    //  Routine Description:
    //      Message handler for WM_CONTEXTMENU
    //
    //  Arguments:
    //      uMsg        [IN]    Message (WM_CONTEXT)
    //      wParam      [IN]    Window handle of the control being queried
    //      lParam      [IN]    Pointer coordinates.  LOWORD xPos, HIWORD yPos
    //      bHandled    [OUT]
    //
    //  Return Value:
    //
    //
    //--
    /////////////////////////////////////////////////////////////////////////////
    LRESULT LrOnContextMenu(
        IN UINT     uMsg,
        IN WPARAM   wParam,
        IN LPARAM   lParam,
        OUT BOOL &  bHandled
        )
    {
        DWORD   nHelpID = 0;
        DWORD   nCtrlID = 0;
        CWindow cwnd( (HWND) wParam );
        WORD    xPos = LOWORD( lParam );
        WORD    yPos = HIWORD( lParam );

        //
        // Only display help if the window is visible.
        //
        if ( cwnd.GetStyle() & WS_VISIBLE )
        {
            nCtrlID = cwnd.GetDlgCtrlID();
            if ( nCtrlID != 0 )
            {
                nHelpID = NHelpFromCtrlID( nCtrlID, reinterpret_cast< const CMapCtrlToHelpID * >( T::PidHelpMap() ) );
            } // if: control has an ID
        }  // if:  over a child window

        //
        // Display a popup menu.
        //
        if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
        {
            bHandled = BContextMenu( cwnd, nHelpID, xPos, yPos );

        }  // if:  over a child window of this dialog with a tabstop

        return 1L;

    } //*** LrOnContextMenu()

    /////////////////////////////////////////////////////////////////////////////
    //++
    //
    //  LrOnHelp
    //
    //  Routine Description:
    //      Message handler for WM_HELP.
    //
    //  Arguments:
    //      uMsg        [IN]    Message (WM_HELP)
    //      wParam      [IN]
    //      lParam      [IN]    pointer to a HELPINFO struct
    //      bHandled    [OUT]
    //
    //  Return Value:
    //
    //
    //--
    /////////////////////////////////////////////////////////////////////////////
    LRESULT LrOnHelp(
        IN UINT     uMsg,
        IN WPARAM   wParam,
        IN LPARAM   lParam,
        OUT BOOL &  bHandled
        )
    {
        LPHELPINFO  phi = (LPHELPINFO) lParam;

        if ( phi->iContextType == HELPINFO_WINDOW )
        {
            DWORD   nHelpID = 0;

            nHelpID = NHelpFromCtrlID( phi->iCtrlId & 0xFFFF, (const CMapCtrlToHelpID *) T::PidHelpMap() );
            if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
            {
                T *         pT   = static_cast< T * >( this );
                CBaseApp *  pbap = dynamic_cast< CBaseApp * >( &_Module );
                ATLASSERT( pbap != NULL );

                bHandled = pT->WinHelp( pbap->PszHelpFilePath(), HELP_CONTEXTPOPUP, nHelpID );
            }
        }

        return 1L;

    } //*** LrOnHelp()

protected:

    /////////////////////////////////////////////////////////////////////////////
    //++
    //
    //  NHelpFromCtrlID
    //
    //  Routine Description:
    //      Return the help ID from a control ID.
    //
    //  Arguments:
    //      nCtrlID     [IN] ID of control to search for.
    //
    //  Return Value:
    //      nHelpID     Help ID associated with the control.
    //
    //--
    /////////////////////////////////////////////////////////////////////////////
    DWORD NHelpFromCtrlID(
        IN DWORD                    nCtrlID,
        IN const CMapCtrlToHelpID * pMap
        ) const
    {
        ASSERT( pMap != NULL );
        ASSERT( nCtrlID != 0 );

        DWORD   nHelpID = 0;

        for ( ; pMap->m_nCtrlID != 0 ; pMap++ )
        {
            if ( pMap->m_nCtrlID == nCtrlID )
            {
                nHelpID = pMap->m_nHelpCtrlID;
                break;
            }  // if:  found a match
        }  // for:  each control

        Trace( g_tagAlways, _T( "NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x" ), nCtrlID, nHelpID );

        return nHelpID;

    }  //*** NHelpFromCtrlID()

    /////////////////////////////////////////////////////////////////////////////
    //++
    //
    //  BContextMenu
    //
    //  Routine Description:
    //      Return the help ID from a control ID.
    //
    //  Arguments:
    //      cwnd        [IN]    - control's window
    //      nHelpID     [IN]    - help context ID
    //      xPos        [IN]    - xpos of the context menu
    //      yPos        [IN]    - ypos of the context menu
    //
    //  Return Value:
    //      TRUE for success, FALSE for failure
    //
    //--
    /////////////////////////////////////////////////////////////////////////////
    BOOL BContextMenu(
        IN CWindow &    cwnd,
        IN DWORD        nHelpID,
        IN WORD         xPos,
        IN WORD         yPos
        )
    {
        CString strMenu;
        CMenu   menu;
        BOOL    bRet = FALSE;

        //
        // The context menu key was pressed.  Get the current mouse position and use that
        //
        if ( ( xPos == 0xffff ) || ( yPos == 0xffff ) )
        {
            POINT   pPos;

            if ( GetCursorPos( &pPos ) )
            {
                xPos = static_cast< WORD >( pPos.x );
                yPos = static_cast< WORD >( pPos.y );
            } // if:  current cursor position retrieved successfully
        } // if:  context menu key was pressed

        if ( strMenu.LoadString( ADMC_ID_MENU_WHATS_THIS ) )
        {
            if ( menu.CreatePopupMenu() )
            {
                if ( menu.AppendMenu( MF_STRING | MF_ENABLED, ADMC_ID_MENU_WHATS_THIS, strMenu ) )
                {
                    DWORD   nCmd;

                    nCmd = menu.TrackPopupMenu(
                        TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                        xPos,
                        yPos,
                        cwnd
                        );

                    if ( nCmd != 0 )
                    {
                        CBaseApp *  pbap = dynamic_cast< CBaseApp * >( &_Module );
                        ATLASSERT( pbap != NULL );

                        bRet = cwnd.WinHelp( pbap->PszHelpFilePath(), HELP_CONTEXTPOPUP, nHelpID );
                    } // if: any command chosen
                    else
                    {
                        Trace( g_tagError, _T( "OnContextMenu() - Last Error = %x" ), GetLastError() );
                    } // else:  unknown command
                }  // if:  menu item added successfully
            }  // if:  popup menu created successfully
        } // if: string could be loaded

        return bRet;

    }  //*** BContextMenu()

}; //*** class CPopupHelp

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLPOPUPHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\cluadmexdataobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      CluAdmExDataObj.h
//
//  Implementation File:
//      CCluAdmExDataObject.cpp
//
//  Description:
//      Definition of the CCluAdmExDataObject class, which is the IDataObject
//      class used to transfer data between a cluster management tool and the
//      extension DLL handlers.
//
//  Author:
//      David Potter (davidp)   June 4, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __CLUADMEXDATAOBJ_H_
#define __CLUADMEXDATAOBJ_H_

/////////////////////////////////////////////////////////////////////////////
//  Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include "CluAdmEx.h"           // for IIDs
#endif

#ifndef __cluadmexhostsvr_h__
#include "CluAdmExHostSvr.h"    // for CLSIDs
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"            // for CClusterObject
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Declarations
/////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFGETRESOURCENETWORKNAME)(
                    OUT BSTR lpszNetName,
                    IN OUT DWORD * pcchNetName,
                    IN OUT PVOID pvContext
                    );

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExDataObject;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCluAdmExDataObject
//
//  Description:
//      Encapsulates the IDataObject interface for exchanging data with
//      extension DLL handlers.
//
//  Inheritance:
//      CCluAdmExDataObject
//      CComObjectRootEx<>, CComCoClass<>, <interface classes>
//
//--
/////////////////////////////////////////////////////////////////////////////
class CCluAdmExDataObject :
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CCluAdmExDataObject, &CLSID_CoCluAdmExHostSvrData >,
    public ISupportErrorInfo,
    public IGetClusterUIInfo,
    public IGetClusterDataInfo,
    public IGetClusterObjectInfo,
    public IGetClusterNodeInfo,
    public IGetClusterGroupInfo,
    public IGetClusterResourceInfo,
    public IGetClusterNetworkInfo,
    public IGetClusterNetInterfaceInfo
{
public:
    //
    // Construction
    //

    // Default constructor
    CCluAdmExDataObject( void )
    {
        m_pco = NULL;
        m_lcid = NULL;
        m_hfont = NULL;
        m_hicon = NULL;

        m_pfGetResNetName = NULL;

//      m_pModuleState = AfxGetModuleState();
//      ATLASSERT( m_pModuleState != NULL );

    } //*** CCluAdmExDataObject()

    // Destructor
    virtual ~CCluAdmExDataObject( void )
    {
//      m_pModuleState = NULL;

    } //*** ~CCluAdmExDataObject()

    // Second-phase constructor.
    void Init(
        IN OUT CClusterObject * pco,
        IN LCID                 lcid,
        IN HFONT                hfont,
        IN HICON                hicon
        )
    {
        ATLASSERT( pco != NULL );
        ATLASSERT( pco->Pci() != NULL );
        ATLASSERT( pco->Pci()->Hcluster() != NULL );

        // Save parameters.
        m_pco = pco;
        m_lcid = lcid;
        m_hfont = hfont;
        m_hicon = hicon;

    } //*** Init()

    //
    // Map interfaces to this class.
    //
    BEGIN_COM_MAP( CCluAdmExDataObject )
        COM_INTERFACE_ENTRY( IGetClusterUIInfo )
        COM_INTERFACE_ENTRY( IGetClusterDataInfo )
        COM_INTERFACE_ENTRY( IGetClusterObjectInfo )
        COM_INTERFACE_ENTRY( IGetClusterNodeInfo )
        COM_INTERFACE_ENTRY( IGetClusterGroupInfo )
        COM_INTERFACE_ENTRY( IGetClusterResourceInfo )
        COM_INTERFACE_ENTRY( IGetClusterNetworkInfo )
        COM_INTERFACE_ENTRY( IGetClusterNetInterfaceInfo )
        COM_INTERFACE_ENTRY( ISupportErrorInfo )
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE( CCluAdmExDataObject )

protected:
    //
    // Properties of this data object.
    //

    CClusterObject *    m_pco;          // Cluster object being extended.
    LCID                m_lcid;         // Locale ID of resources to be loaded by extension.
    HFONT               m_hfont;        // Font for all text.
    HICON               m_hicon;        // Icon for upper left corner.

    PFGETRESOURCENETWORKNAME    m_pfGetResNetName;          // Pointer to static function for getting net name for resource.
    PVOID                       m_pvGetResNetNameContext;   // Context for m_pfGetResNetName;

    static const IID * s_rgiid[];       // Array of interface IDs supported by this class.

    //
    // Accessor methods.
    //

    HCLUSTER Hcluster( void ) const
    {
        ATLASSERT( m_pco != NULL );
        ATLASSERT( m_pco->Pci() != NULL );

        return m_pco->Pci()->Hcluster();

    } //*** Hcluster()

    CClusterObject *    Pco( void ) const       { return m_pco; }
    LCID                Lcid( void ) const      { return m_lcid; }
    HFONT               Hfont( void ) const     { return m_hfont; }
    HICON               Hicon( void ) const     { return m_hicon; }

public:
    PFGETRESOURCENETWORKNAME PfGetResNetName( void ) const { return m_pfGetResNetName; }

    // Set the function pointer for getting the resource name
    void SetPfGetResNetName( PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext )
    {
        m_pfGetResNetName = pfGetResNetName;
        m_pvGetResNetNameContext = pvContext;

    } //*** SetPfGetResNetName()

public:
    //
    // ISupportsErrorInfo methods.
    //

    // Determine if interface supports IErrorInfo
    STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid )
    {
        const IID ** piid;

        for ( piid = s_rgiid ; *piid != NULL ; piid++ )
        {
            if ( InlineIsEqualGUID( **piid, riid ) )
            {
                return S_OK;
            } // if:  matching IID found
        }
        return S_FALSE;

    } //*** InterfaceSupportsErrorInfo()

public:
    //
    // IGetClusterUIInfo methods.
    //

    // Get the locale of the running program
    STDMETHOD_( LCID, GetLocale )( void )
    {
        return Lcid();

    } //*** GetLocale()

    // Get the font to use for text on property pages
    STDMETHOD_( HFONT, GetFont )( void )
    {
        return Hfont();

    } //*** GetFont()

    // Get the icon to use for the upper left corner
    STDMETHOD_( HICON, GetIcon )( void )
    {
        return Hicon();

    } //*** GetIcon()

public:
    //
    // IGetClusterDataInfo methods.
    //

    // Get the name of the cluster
    STDMETHOD( GetClusterName )(
        OUT BSTR        lpszName,
        IN OUT LONG *   pcchName
        )
    {
        ATLASSERT( Pco() != NULL );
        ATLASSERT( Pco()->Pci() != NULL );

        HRESULT hr;

        //
        // Validate parameters.
        //
        if ( pcchName == NULL )
        {
            return E_INVALIDARG;
        }

        //
        // Copy the name to the caller's buffer.
        //
        hr = GetStringProperty(
                Pco()->Pci()->RstrName(),
                lpszName,
                pcchName
                );

        return hr;

    } //*** GetClusterName()

    // Get a handle to the cluster
    STDMETHOD_( HCLUSTER, GetClusterHandle )( void )
    {
        return Hcluster();

    } //*** GetClusterHandle()

    // Get the number of objects currently selected
    STDMETHOD_( LONG, GetObjectCount )( void )
    {
        //
        // We only support one selected object at a time for now.
        //
        return 1;

    } //*** GetObjectCount()

public:
    //
    // IGetClusterObjectInfo methods.
    //

    // Get the name of the object at the specified index
    STDMETHOD( GetObjectName )(
        IN LONG         nObjIndex,
        OUT BSTR        lpszName,
        IN OUT LONG *   pcchName
        )
    {
        ATLASSERT( Pco() != NULL );

        HRESULT hr;

        //
        // Validate parameters.
        // We only support one selected object at a time for now.
        //
        if ( (nObjIndex != 0) || (pcchName == NULL) )
        {
            return E_INVALIDARG;
        } // if:  wrong object index or no count buffer

        //
        // Copy the name to the caller's buffer.
        //
        hr = GetStringProperty(
                Pco()->RstrName(),
                lpszName,
                pcchName
                );

        return hr;

    } //*** GetObjectName()

    // Get the type of the object at the specified index
    STDMETHOD_( CLUADMEX_OBJECT_TYPE, GetObjectType )(
        IN LONG nObjIndex
        )
    {
        ATLASSERT( Pco() != NULL );

        //
        // Validate parameters.
        // We only support one selected object at a time for now.
        //
        if ( nObjIndex == 1 )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return (CLUADMEX_OBJECT_TYPE) -1;
        }  // if:  invalid argument

        return Pco()->Cot();

    } //*** GetObjectType()

public:
    //
    // IGetClusterNodeInfo methods.
    //

    // Get the handle to the node at the specified index
    STDMETHOD_( HNODE, GetNodeHandle )(
        IN LONG nObjIndex
        )
    {
        ATLASSERT( Pco() != NULL );

        //
        // Validate parameters.
        // We only support one selected object at a time for now.
        //
        if (   (nObjIndex == 1)
            || (Pco()->Cot() != CLUADMEX_OT_NODE) )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return NULL;
        }  // if:  invalid argument

        CClusNodeInfo * pni = reinterpret_cast< CClusNodeInfo * >( Pco() );
        return pni->Hnode();

    } //*** GetNodeHandle()

public:
    //
    // IGetClusterGroupInfo methods.
    //

    // Get the handle to the group at the specified index
    STDMETHOD_( HGROUP, GetGroupHandle )(
        IN LONG nObjIndex
        )
    {
        ATLASSERT( Pco() != NULL );

        //
        // Validate parameters.
        // We only support one selected object at a time for now.
        //
        if (   (nObjIndex == 1)
            || (Pco()->Cot() != CLUADMEX_OT_GROUP) )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return NULL;
        }  // if:  invalid argument

        CClusGroupInfo * pgi = reinterpret_cast< CClusGroupInfo * >( Pco() );
        return pgi->Hgroup();

    } //*** GetGroupHandle()

public:
    //
    // IGetClusterResourceInfo methods.
    //

    // Get the handle to the resource at the specified index
    STDMETHOD_( HRESOURCE, GetResourceHandle )(
        IN LONG nObjIndex
        )
    {
        ATLASSERT( Pco() != NULL );

        //
        // Validate parameters.
        // We only support one selected object at a time for now.
        //
        if (   (nObjIndex == 1)
            || (Pco()->Cot() != CLUADMEX_OT_RESOURCE) )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return NULL;
        }  // if:  invalid argument

        CClusResInfo * pri = reinterpret_cast< CClusResInfo * >( Pco() );
        return pri->Hresource();

    } //*** GetResourceHandle()

    // Get the type of the resource at the specified index
    STDMETHOD( GetResourceTypeName )(
        IN LONG         nObjIndex,
        OUT BSTR        lpszResourceTypeName,
        IN OUT LONG *   pcchResTypeName
        )
    {
        ATLASSERT( Pco() != NULL );

        HRESULT         hr;
        CClusResInfo *  pri = reinterpret_cast< CClusResInfo * >( Pco() );

        //
        // Validate parameters.
        // We only support one selected object at a time for now.
        //
        if (   (nObjIndex != 0)
            || (pcchResTypeName == NULL)
            || (Pco()->Cot() != CLUADMEX_OT_RESOURCE) )
        {
            return E_INVALIDARG;
        }  // if:  invalid argument

        //
        // Copy the name to the caller's buffer.
        //
        ATLASSERT( pri->Prti() != NULL );
        hr = GetStringProperty(
                pri->Prti()->RstrName(),
                lpszResourceTypeName,
                pcchResTypeName
                );

        return hr;

    } //*** GetResourceTypeName()

    // Get the network name for the resource at the specified index
    STDMETHOD_( BOOL, GetResourceNetworkName )(
        IN LONG         nObjIndex,
        OUT BSTR        lpszNetName,
        IN OUT ULONG *  pcchNetName
        )
    {
        ATLASSERT( Pco() != NULL );

        BOOL            bSuccess = FALSE;
        CClusResInfo *  pri = reinterpret_cast< CClusResInfo * >( Pco() );

        try
        {
            //
            // Validate parameters.
            // We only support one selected object at a time for now.
            //
            if (   (nObjIndex != 0)
                || (pcchNetName == NULL)
                || (*pcchNetName < MAX_COMPUTERNAME_LENGTH)
                || (Pco()->Cot() != CLUADMEX_OT_RESOURCE) )
            {
                SetLastError( (DWORD) E_INVALIDARG );
                return FALSE;
            }  // if:  invalid argument

            //
            // If there is a function for getting this information, call it.
            // Otherwise, handle it ourselves.
            //
            if ( PfGetResNetName() != NULL )
            {
                bSuccess = (*PfGetResNetName())( lpszNetName, pcchNetName, m_pvGetResNetNameContext );
            } // if:  function specified for getting this info
            else
            {
                bSuccess = pri->BGetNetworkName( lpszNetName, pcchNetName );
            } // if:  no function specified for getting this info
        } // try
        catch (...)
        {
            bSuccess = FALSE;
            SetLastError( (DWORD) E_INVALIDARG );
        }  // catch:  anything

        return bSuccess;

    } //*** GetResourceNetworkName()

public:
    //
    // IGetClusterNetworkInfo methods.
    //

    // Get the handle to the network at the specified index
    STDMETHOD_( HNETWORK, GetNetworkHandle )(
        IN LONG nObjIndex
        )
    {
        ATLASSERT( Pco() != NULL );

        // Validate parameters.
        // We only support one selected object at a time for now.
        if (   (nObjIndex == 1)
            || (Pco()->Cot() != CLUADMEX_OT_NETWORK) )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return NULL;
        }  // if:  invalid argument

        CClusNetworkInfo * pni = reinterpret_cast< CClusNetworkInfo * >( Pco() );
        return pni->Hnetwork();

    } //*** GetNetworkHandle()

public:
    //
    // IGetClusterNetInterfaceInfo methods.
    //

    // Get the handle to the network interface at the specified index
    STDMETHOD_( HNETINTERFACE, GetNetInterfaceHandle )(
        IN LONG nObjIndex
        )
    {
        ATLASSERT( Pco() != NULL );

        // Validate parameters.
        // We only support one selected object at a time for now.
        if (   (nObjIndex == 1)
            || (Pco()->Cot() != CLUADMEX_OT_NETINTERFACE) )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return NULL;
        }  // if:  invalid argument

        CClusNetIFInfo * pnii = reinterpret_cast< CClusNetIFInfo * >( Pco() );
        return pnii->Hnetinterface();

    } //*** GetNetInterfaceHandle()

// Implementation
protected:
//  AFX_MODULE_STATE *          m_pModuleState;         // Required for resetting our state during callbacks.

    // Get a string property
    STDMETHOD( GetStringProperty )(
        IN const CString &  rstrNameSource,
        OUT BSTR            lpszName,
        IN OUT LONG *       pcchName
        )
    {
        ATLASSERT( pcchName != NULL );

        LONG    cchName = 0;
        HRESULT hr = S_OK;

        //
        // Save the length to copy.
        //
        try
        {
            cchName = *pcchName;
            *pcchName = rstrNameSource.GetLength() + 1;
        } // try
        catch (...)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }  // catch:  anything

        //
        // If only the length is being requested, return it now.
        //
        if ( lpszName == NULL )
        {
            hr = S_OK;
            goto Cleanup;
        } // if:  no name buffer specified

        //
        // If a buffer is specified and it is too small, return an error.
        //
        if ( cchName < *pcchName )
        {
            hr = ERROR_MORE_DATA;
            goto Cleanup;
        } // if:  buffer too small

        //
        // Copy the data.
        //
        hr = StringCchCopyNW( lpszName, cchName, rstrNameSource, rstrNameSource.GetLength() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:  error copying data

    Cleanup:

        return hr;

    } //*** GetStringProperty()

};  //*** class CCluAdmExDataObject

/////////////////////////////////////////////////////////////////////////////
// Class Data
/////////////////////////////////////////////////////////////////////////////
_declspec( selectany ) const IID * CCluAdmExDataObject::s_rgiid[] = 
{
    &IID_IGetClusterDataInfo,
    &IID_IGetClusterObjectInfo,
    &IID_IGetClusterNodeInfo,
    &IID_IGetClusterGroupInfo,
    &IID_IGetClusterResourceInfo,
    &IID_IGetClusterNetworkInfo,
    &IID_IGetClusterNetInterfaceInfo,
    NULL
};

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUADMEXDATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\clusobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ClusObj.cpp
//
//	Description:
//		Implementation of the CClusterObject classes.
//
//	Author:
//		David Potter (davidp)	September 15, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClusObj.h"
#include "AdmCommonRes.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusResInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResInfo::BRequiredDependenciesPresent
//
//	Routine Description:
//		Determine if the resource contains each required resource for this
//		type of resource.
//
//	Arguments:
//		plpri			[IN] List of resources.  Defaults to this resource's
//							dependency list.
//		rstrMissing		[OUT] String in which to return a missing resource
//							class name or type name.
//		rbMissingTypeName
//						[OUT] TRUE = missing resource type name
//							FALSE = missing resource class
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CString::LoadString() or CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusResInfo::BRequiredDependenciesPresent(
	IN CClusResPtrList const *	plpri,
	OUT CString &				rstrMissing,
	OUT BOOL &					rbMissingTypeName
	)
{
	ATLASSERT( Prti() != NULL );

	BOOL					bFound = TRUE;
	CLUSPROP_BUFFER_HELPER	buf;
	const CClusResInfo *	pri;

	// Loop to avoid goto's.
	do
	{
		//
		// We're done if there are no required dependencies.
		//
		if ( Prti()->Pcrd() == NULL )
		{
			break;
		} // if:  no required dependencies

		//
		// Default the list of resources if none specified.
		//
		if ( plpri == NULL )
		{
			plpri = PlpriDependencies();
		} // if:  no list of dependencies specified

		//
		// Get the list of required dependencies.
		//
		buf.pRequiredDependencyValue = Prti()->Pcrd();

		//
		// Loop through each required dependency and make sure
		// there is a dependency on a resource of that type.
		//
		for ( ; buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK
			  ; buf.pb += sizeof( *buf.pValue ) + ALIGN_CLUSPROP( buf.pValue->cbLength )
			  )
		{
			bFound = FALSE;
			CClusResPtrList::iterator itCurrent = plpri->begin();
			CClusResPtrList::iterator itLast = plpri->end();
			for ( ; itCurrent != itLast ; itCurrent++ )
			{
				pri = *itCurrent;

				//
				// If this is the right type, we've satisfied the
				// requirement so exit the loop.
				//
				if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS )
				{
					if ( buf.pResourceClassValue->rc == pri->ResClass() )
					{
						bFound = TRUE;
					}  // if:  match found
				}  // if:  resource class
				else if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_NAME )
				{
					if ( pri->Prti()->RstrName().CompareNoCase( buf.pStringValue->sz ) == 0 )
					{
						bFound = TRUE;
					}  // if:  match found
				}  // else if:  resource name
				if ( bFound )
				{
					break;
				} // if:  found a match
			}  // while:  more items in the list

			//
			// If a match was not found, changes cannot be applied.
			//
			if ( ! bFound )
			{
				if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS )
				{
					if ( ! rstrMissing.LoadString( ADMC_IDS_RESCLASS_UNKNOWN + buf.pResourceClassValue->rc ) )
					{
						rstrMissing.LoadString( ADMC_IDS_RESCLASS_UNKNOWN );
					} // if:  error loading specific class name
					rbMissingTypeName = FALSE;
				}  // if:  resource class not found
				else if ( buf.pSyntax->dw == CLUSPROP_SYNTAX_NAME )
				{
					rstrMissing = buf.pStringValue->sz;
					rbMissingTypeName = TRUE;
				}  // else if:  resource type name not found
				break;
			}  // if:  not found

		}  // while:  more dependencies required
	} while ( 0 );

	return bFound;

}  //*** CClusResInfo::BRequiredDependenciesPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\critsec.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CritSec.h
//
//	Abstract:
//		Definition of the CCritSec class.
//
//	Author:
//		David Potter (davidp)	November 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CRITSEC_H_
#define __CRITSEC_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCritSec;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CCritSec
/////////////////////////////////////////////////////////////////////////////

class CCritSec
{
protected:
	CRITICAL_SECTION	m_critsec;	// Critical section data.

public:
	CCritSec(void)
	{
		InitializeCriticalSection(&m_critsec);
	}

	~CCritSec(void)
	{
		// Make sure no one is holding the critical section
		// before we delete it.
		Lock();
		Unlock();
		DeleteCriticalSection(&m_critsec);
	}

	// Acquire the critical section
	void Lock(void)
	{
		EnterCriticalSection(&m_critsec);
	}

	// Release the critical section
	void Unlock(void)
	{
		LeaveCriticalSection(&m_critsec);
	}

};  //*** class CCritSec

/////////////////////////////////////////////////////////////////////////////

#endif // __CRITSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\cluswrap.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ClusWrap.cpp
//
//  Description:
//      Wrapper functions for Cluster APIs.
//
//  Author:
//      Galen Barbee    (GalenB)    15-Aug-1998
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <clusapi.h>
#include "cluswrap.h"
//#include "ClusWrap.tmh"

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterInformation
//
//  Description:
//      Wraps the GetClusterInformation function.
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapGetClusterInformation(
    IN HCLUSTER                         hCluster,
    OUT LPWSTR *                        ppszClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO   pClusterInfo
    )
{
    DWORD   dwStatus;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameter.
    if ( ppszClusterName != NULL )
    {
        *ppszClusterName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = GetClusterInformation( hCluster, pwszName, &cchTempName, pClusterInfo );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = GetClusterInformation( hCluster, pwszName, &cchTempName, pClusterInfo );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppszClusterName != NULL ) )
    {
        *ppszClusterName = pwszName;
    }

    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppszClusterName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapGetClusterInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterQuorumResource
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapGetClusterQuorumResource(
    IN  HCLUSTER    hCluster,
    OUT LPWSTR *    ppwszResourceName,
    OUT LPWSTR *    ppwszDeviceName,
    OUT LPDWORD     pdwMaxQuorumLogSize
    )
{
    DWORD   dwStatus;
    LPWSTR  pwszResourceName = NULL;
    DWORD   cchResourceName = 128;
    DWORD   cchTempResourceName = cchResourceName;
    LPWSTR  pwszDeviceName = NULL;
    DWORD   cchDeviceName = 128;
    DWORD   cchTempDeviceName = cchDeviceName;
    DWORD   dwMaxQuorumLogSize = 0;

    // Zero the out parameters
    if ( ppwszResourceName != NULL )
    {
        *ppwszResourceName = NULL;
    }

    if ( ppwszDeviceName != NULL )
    {
        *ppwszDeviceName = NULL;
    }

    if ( pdwMaxQuorumLogSize != NULL )
    {
        *pdwMaxQuorumLogSize = 0;
    }

    // Allocate the resource name buffer
    pwszResourceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchResourceName * sizeof( *pwszResourceName ) );
    if ( pwszResourceName != NULL )
    {
        // Allocate the device name buffer
        pwszDeviceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchDeviceName * sizeof( *pwszDeviceName ) );
        if ( pwszDeviceName != NULL )
        {
            dwStatus = GetClusterQuorumResource( hCluster,
                                                 pwszResourceName,
                                                 &cchTempResourceName,
                                                 pwszDeviceName,
                                                 &cchTempDeviceName,
                                                 &dwMaxQuorumLogSize );
            if ( dwStatus == ERROR_MORE_DATA )
            {
                LocalFree( pwszResourceName );
                pwszResourceName = NULL;

                cchResourceName = ++cchTempResourceName;
                // Allocate the resource name buffer
                pwszResourceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchResourceName * sizeof( *pwszResourceName ) );
                if ( pwszResourceName != NULL )
                {
                    LocalFree( pwszDeviceName );
                    pwszDeviceName = NULL;

                    cchDeviceName = ++cchTempDeviceName;
                    // Allocate the device name buffer
                    pwszDeviceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchDeviceName * sizeof( *pwszDeviceName ) );
                    if ( pwszDeviceName != NULL )
                    {
                        dwStatus = GetClusterQuorumResource( hCluster,
                                                             pwszResourceName,
                                                             &cchTempResourceName,
                                                             pwszDeviceName,
                                                             &cchTempDeviceName,
                                                             &dwMaxQuorumLogSize );
                    }
                    else
                    {
                        dwStatus = GetLastError();
                    }
                }
                else
                {
                    dwStatus = GetLastError();
                }
            }
        }
        else
        {
            dwStatus = GetLastError();
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszResourceName != NULL ) )
    {
        *ppwszResourceName = pwszResourceName;
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszDeviceName != NULL ) )
    {
        *ppwszDeviceName = pwszDeviceName;
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwMaxQuorumLogSize != NULL ) )
    {
        *pdwMaxQuorumLogSize = dwMaxQuorumLogSize;
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszResourceName == NULL ) )
    {
        LocalFree( pwszResourceName );
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszDeviceName == NULL ) )
    {
        LocalFree( pwszDeviceName );
    }

    return dwStatus;

} //*** WrapGetClusterQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Function:   WrapClusterEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterEnum(
    IN HCLUSENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;
            cchName = ++cchTempName;

            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if we succeeded and if the string argument is not NULL then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterNodeId
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapGetClusterNodeId(
    IN HNODE        hNode,
    OUT LPWSTR *    ppwszNodeId
    )
{
    DWORD   dwStatus;
    LPWSTR  pwszNodeId = NULL;
    DWORD   cchNodeId = 128;
    DWORD   cchTempNodeId = cchNodeId;

    // Zero the out parameters
    if ( ppwszNodeId != NULL )
    {
        *ppwszNodeId = NULL;
    }

    pwszNodeId = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeId * sizeof( *pwszNodeId ) );
    if ( pwszNodeId != NULL)
    {
        dwStatus = GetClusterNodeId( hNode, pwszNodeId, &cchTempNodeId );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszNodeId );
            pwszNodeId = NULL;

            cchNodeId = ++cchTempNodeId;
            pwszNodeId = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeId * sizeof( *pwszNodeId ) );
            if ( pwszNodeId != NULL)
            {
                dwStatus = GetClusterNodeId( hNode, pwszNodeId, &cchTempNodeId );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if we succeeded and if the argument is not NULL then return it.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszNodeId != NULL ) )
    {
        *ppwszNodeId = pwszNodeId;
    }

    //
    // if we didn't succeeded or if the string argument is NULL then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszNodeId == NULL ) )
    {
        LocalFree( pwszNodeId );
    }

    return dwStatus;

} //*** WrapGetClusterNodeId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterGroupState
//
//  Description:
//      Wrapper function for GetClusterGroupState.
//
//  Arguments:
//      hGroup          [IN]    - The group handle.
//      ppwszNodeName   [OUT]   - Catches the name of the node that the group
//                              is online, if not NULL.
//
//  Return Value:
//      A cluster group state enum.
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_GROUP_STATE WINAPI WrapGetClusterGroupState(
    IN  HGROUP              hGroup,
    OUT OPTIONAL LPWSTR *   ppwszNodeName   // = NULL
    )
{
    CLUSTER_GROUP_STATE cState = ClusterGroupStateUnknown;

    if ( ppwszNodeName == NULL )
    {
        // The caller is not interested in the node name.
        // So, just call the actual function.
        cState = GetClusterGroupState( hGroup, NULL, 0 );
    } // if: the pointer to the node name pointer is not provided.
    else
    {
        LPWSTR              pwszNodeName = NULL;
        DWORD               cchNodeName = 128;
        DWORD               cchTempNodeName = cchNodeName;

        // Zero the out parameters
        *ppwszNodeName = NULL;

        pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
        if ( pwszNodeName != NULL )
        {
            cState = GetClusterGroupState( hGroup, pwszNodeName, &cchTempNodeName );
            if ( GetLastError() == ERROR_MORE_DATA )
            {
                cState = ClusterGroupStateUnknown;      // reset to error condition

                LocalFree( pwszNodeName );

                cchNodeName = ++cchTempNodeName;
                pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
                if ( pwszNodeName != NULL )
                {
                    cState = GetClusterGroupState( hGroup, pwszNodeName, &cchTempNodeName );
                }
                else
                {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                } // else:
            }
        }
        else
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        } // else:

        //
        // if there was not an error, then return the string.
        //
        if ( cState != ClusterGroupStateUnknown )
        {
            *ppwszNodeName = pwszNodeName;
        }
        else
        {
            LocalFree( pwszNodeName );
        }
    } // else: the pointer to the node name pointer is not NULL.

    return cState;

} //*** WrapGetClusterGroupState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterGroupEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterGroupEnum(
    IN HGROUPENUM   hGroupEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = NULL;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterGroupEnum( hGroupEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterGroupEnum( hGroupEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterGroupEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterNetworkEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterNetworkEnum(
    IN HNETWORKENUM hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterNetworkEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterNetworkEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterNetworkEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterNodeEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterNodeEnum(
    IN HNODEENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterNodeEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterNodeEnum( hEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterNodeEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterResourceState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_RESOURCE_STATE WINAPI WrapGetClusterResourceState(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR * ppwszNodeName,
    OUT OPTIONAL LPWSTR * ppwszGroupName
    )
{
    CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;
    LPWSTR                  pwszNodeName = NULL;
    DWORD                   cchNodeName = 128;
    LPWSTR                  pwszGroupName = NULL;
    DWORD                   cchGroupName = 128;
    DWORD                   cchTempNodeName = cchNodeName;
    DWORD                   cchTempGroupName = cchGroupName;

    //printf( "Entering... " );

    // Zero the out parameters
    if ( ppwszNodeName != NULL )
    {
        *ppwszNodeName = NULL;
    }

    if ( ppwszGroupName != NULL )
    {
        *ppwszGroupName = NULL;
    }

    pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
    if ( pwszNodeName != NULL )
    {
        pwszGroupName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchGroupName * sizeof( *pwszGroupName ) );
        if ( pwszGroupName != NULL )
        {
            cState = GetClusterResourceState( hResource, pwszNodeName, &cchTempNodeName, pwszGroupName, &cchTempGroupName );
            if ( GetLastError() == ERROR_MORE_DATA )
            {
                cState = ClusterResourceStateUnknown;   // reset to error condition

                LocalFree( pwszNodeName );
                pwszNodeName = NULL;
                cchNodeName = ++cchTempNodeName;

                LocalFree( pwszGroupName );
                pwszGroupName = NULL;
                cchGroupName = ++cchTempGroupName;

                pwszNodeName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchNodeName * sizeof( *pwszNodeName ) );
                if ( pwszNodeName != NULL )
                {
                    pwszGroupName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchGroupName * sizeof( *pwszGroupName ) );
                    if ( pwszGroupName != NULL )
                    {
                        cState = GetClusterResourceState( hResource, pwszNodeName, &cchNodeName, pwszGroupName, &cchGroupName );
                    } // if: LocalAlloc succeeded
                    else
                    {
                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    } // else: LocalAlloc failed
                } // if: LocalAlloc succeeded
                else
                {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                } // else: LocalAlloc failed
            } // if: ERROR_MORE_DATA
        } // if: LocalAlloc succeeded
        else
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        } // else: LocalAlloc failed
    } // if: LocalAlloc succeeded
    else
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    } // else: LocalAlloc failed

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszNodeName != NULL ) )
    {
        *ppwszNodeName = pwszNodeName;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszGroupName != NULL ) )
    {
        *ppwszGroupName = pwszGroupName;
    }

    //
    // if there was an error or the argument was NULL, then free the string.
    //
    if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszNodeName == NULL ) )
    {
        LocalFree( pwszNodeName );
    }

    //
    // if there was an error or the argument was NULL, then free the string.
    //
    if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszGroupName == NULL ) )
    {
        LocalFree( pwszGroupName );
    }

    //printf( "Exiting.  Resource state is %d.", cState );

    return cState;

} //*** WrapGetClusterResourceState()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterNetInterfaceState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETINTERFACE_STATE WINAPI WrapGetClusterNetInterfaceState(
    IN HNETINTERFACE hNetInterface
    )
{

    return GetClusterNetInterfaceState( hNetInterface );

} //*** WrapGetClusterNetInterfaceState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapGetClusterNetworkState
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETWORK_STATE WINAPI WrapGetClusterNetworkState(
    IN HNETWORK hNetwork
    )
{

    return GetClusterNetworkState( hNetwork );

} //*** WrapGetClusterNetworkState()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterResourceEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterResourceEnum(
    IN HRESENUM  hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterResourceEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WrapClusterResourceTypeEnum
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI WrapClusterResourceTypeEnum(
    IN HRESTYPEENUM hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD  pdwType,
    OUT LPWSTR *    ppwszName
    )
{
    DWORD   dwStatus;
    DWORD   dwType = 0;
    LPWSTR  pwszName = NULL;
    DWORD   cchName = 128;
    DWORD   cchTempName = cchName;

    // Zero the out parameters
    if ( pdwType != NULL )
    {
        *pdwType = 0;
    }

    if ( ppwszName != NULL )
    {
        *ppwszName = NULL;
    }

    pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
    if ( pwszName != NULL )
    {
        dwStatus = ClusterResourceTypeEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            LocalFree( pwszName );
            pwszName = NULL;

            cchName = ++cchTempName;
            pwszName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, cchName * sizeof( *pwszName ) );
            if ( pwszName != NULL )
            {
                dwStatus = ClusterResourceTypeEnum( hResEnum, dwIndex, &dwType, pwszName, &cchTempName );
            }
            else
            {
                dwStatus = GetLastError();
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
    }

    //
    // if there was not an error and the argument was not NULL, then return the value.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( pdwType != NULL ) )
    {
        *pdwType = dwType;
    }

    //
    // if there was not an error and the argument was not NULL, then return the string.
    //
    if ( ( dwStatus == ERROR_SUCCESS ) && ( ppwszName != NULL ) )
    {
        *ppwszName = pwszName;
    }

    //
    // if there was an error and the argument was NULL, then free the string.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( ppwszName == NULL ) )
    {
        LocalFree( pwszName );
    }

    return dwStatus;

} //*** WrapClusterResourceTypeEnum()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Misc helper functions, etc.
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyPort
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::CClusterNotifyPort
//
//  Description:    This class is a wrapper for the cluster notify port
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyPort::CClusterNotifyPort( void )
{
    m_dwNotifyKey = 0;
    m_dwFilterType = 0;
    m_szName = NULL;
    m_cchName = 0;
    m_hChange = NULL;

} //*** CClusterNotifyPort::CClusterNotifyPort()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::~CClusterNotifyPort
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyPort::~CClusterNotifyPort( void )
{
    if( NULL != m_szName )
    {
        delete [] m_szName;
    }

    Close();

} //*** CClusterNotifyPort::~CClusterNotifyPort()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::Create
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::Create(
    HCHANGE     hChange,
    HCLUSTER    hCluster,
    DWORD       dwFilter,
    DWORD_PTR   dwNotifyKey
    )
{
    DWORD sc = ERROR_SUCCESS;

    //printf( "Entering..." );

    m_hChange = CreateClusterNotifyPort( hChange, hCluster, dwFilter, dwNotifyKey );
    if ( m_hChange == NULL )
    {
        sc = GetLastError();
    }

    //printf( "Exiting. sc = %#08x", sc );

    return sc;

} //*** CClusterNotifyPort::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::Close
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::Close( void )
{
    DWORD sc = ERROR_SUCCESS;

    //printf( "Entering..." );

    if ( m_hChange != NULL )
    {
        sc = CloseClusterNotifyPort( m_hChange );
    }

    //printf( "Exiting. sc = %#08x", sc );

    return sc;

} //*** CClusterNotifyPort::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::Register
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::Register(
    DWORD       dwFilterType,
    HANDLE      hObject,
    DWORD_PTR   dwNotifyKey
    )
{
    DWORD   _sc = ERROR_SUCCESS;

    //printf( "Entering..." );

    _sc = RegisterClusterNotify( m_hChange, dwFilterType, hObject, dwNotifyKey );

    //printf( "Exiting. sc = %#08x", _sc );

    return _sc;

} //*** CClusterNotifyPort::Register()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyPort::GetNotify
//
//  Description:
//
//  Arguments:
//
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNotifyPort::GetNotify( void )
{
    DWORD sc = ERROR_SUCCESS;
    DWORD cchName;

    //printf( "Entering..." );

    cchName = m_cchName;

    //
    // Wait until state changes or 1 second elapses
    //
    sc = GetClusterNotify( m_hChange, &m_dwNotifyKey, &m_dwFilterType, m_szName, &cchName, 1000 );
    //printf( "GetClusterNotify() returned. sc = %#08x", sc );

    //
    // If we got an error_more_data or we passed in a NULL buffer pointer and got error_success
    // then we have to resize our buffer.  Member m_szName is initialized to NULL.
    //
    if ( sc == ERROR_MORE_DATA ||
       ( m_szName == NULL && sc == ERROR_SUCCESS )  )
    {
        //
        // resize the buffer
        //
        delete [] m_szName;

        cchName++;          // add one for NULL

        m_cchName = cchName;
        m_szName = new WCHAR[ m_cchName ];
        if ( m_szName == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
        } // if:
        else
        {
            cchName = m_cchName;
            sc = GetClusterNotify( m_hChange, &m_dwNotifyKey, &m_dwFilterType, m_szName, &cchName, 0 );
        } // else:
    } // if:

    //printf( "Exiting. sc = %#08x", sc );

    return sc;

} //*** CClusterNotifyPort::GetNotify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForResourceStateChange
//
//  Description:
//      Wait for the resource state to change to a non pending state.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      pwszName        [IN]        - name of the resource to wait on
//      pPort           [IN]        - notification port to use
//      pnWait          [IN OUT]    - ~ number of seconds to wait
//
//  Return Value:
//      ERROR_SUCCESS       The resource is not in a pending state or pnWait is NULL.
//      ERROR_IO_PENDING    The resource is in a pending state (wait expired).
//      Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForResourceStateChange(
    IN      HCLUSTER                hCluster,
    IN      LPWSTR                  pwszName,
    IN      CClusterNotifyPort *    pPort,
    IN OUT  DWORD *                 pnWait
    )
{
    CLUSTER_RESOURCE_STATE  crs = ClusterResourceStateUnknown;
    HRESOURCE               hResource = NULL;
    DWORD                   _sc = ERROR_SUCCESS;

    if ( pnWait != NULL )
    {
        hResource = OpenClusterResource( hCluster, pwszName );
        if ( hResource != NULL )
        {
            while ( *pnWait > 0 )
            {
                crs = WrapGetClusterResourceState( hResource, NULL, NULL );
                if ( crs != ClusterResourceStateUnknown )
                {
                    //
                    // if the state is greater than ClusterResourcePending then it's
                    // in a pending state and we want to wait for the next notification.
                    //
                    if ( crs > ClusterResourcePending )
                    {
                        pPort->GetNotify();  // this will only wait for up to 1 second.
                        --(*pnWait);
                    } // if: resource is in pending state
                    else
                    {
                        break;
                    } // else if: resource is no longer in a pending state
                } // if: WrapClusterResourceState
                else
                {
                    _sc = GetLastError();
                    break;
                } // else: WrapClusterResourceState failed
            } // while: *pnWait > 0

            //
            //  Either it's transitioned to a non-pending state, the wait
            //  has expired, or the wait was zero to begin with.
            //
            if ( _sc == ERROR_SUCCESS )
            {
                crs = WrapGetClusterResourceState( hResource, NULL, NULL );
                if ( crs > ClusterResourcePending )
                {
                    _sc = ERROR_IO_PENDING;
                }
            } // if: we didn't get an error above

            CloseClusterResource( hResource );
        } // if: OpenClusterResource ok
        else
        {
            _sc = GetLastError();
        } // else: OpenClusterResource failed
    } // if: pnWait not NULL, this is for safety only

    return _sc;

} //*** WaitForResourceStateChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForResourceGroupStateChange
//
//  Description:
//      Wait for the resource group state to change to a non pending state.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      hGroup          [IN]        - handle to the group to wait on
//      pnWait          [IN OUT]    - ~ number of seconds to wait
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForResourceGroupStateChange(
    IN      HCLUSTER    hCluster,
    IN      HGROUP      hGroup,
    IN OUT  DWORD *     pnWait
    )
{
    CLUSTER_GROUP_STATE _cgs = ClusterGroupStateUnknown;
    DWORD               _sc = ERROR_SUCCESS;

    if ( pnWait != NULL )
    {
        CClusterNotifyPort _port;       // Wait for a group state change event

        _sc = _port.Create( (HCHANGE) INVALID_HANDLE_VALUE, hCluster );
        if ( _sc == ERROR_SUCCESS )
        {
            _sc = _port.Register( CLUSTER_CHANGE_GROUP_STATE, hGroup );
            if ( _sc == ERROR_SUCCESS )
            {
                while ( *pnWait > 0 )
                {
                    _cgs = WrapGetClusterGroupState( hGroup, NULL );
                    if ( _cgs != ClusterGroupStateUnknown )
                    {
                        //
                        // if the state is ClusterGroupPending then it's
                        // in a pending state and we want to wait for the next notification.
                        //
                        if ( _cgs == ClusterGroupPending )
                        {
                            _port.GetNotify();   // this will only wait for up to 1 second.
                            --(*pnWait);
                        } // if: resource is in pending state
                        else
                        {
                            break;
                        } // else if: resource is no longer in a pending state
                    } // if: WrapClusterResourceState
                    else
                    {
                        _sc = GetLastError();
                        break;
                    } // else: WrapClusterResourceState failed
                } // while: *pnWait > 0
            } // if: port created
            else
            {
                _sc = GetLastError();
            } // else: port registration failed
        } // if: create notification port
    } // if: pnWait not NULL, this is for safety only

    return _sc;

} //*** WaitForResourceGroupStateChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForGroupToQuiesce
//
//  Description:
//      Wait for each of the resources in the group to leave a pending state.
//
//  Arguments:
//      hCluster        [IN]        - handle to the cluster
//      hGroup          [IN]        - handle to the group
//      pnWait          [IN OUT]    - ~ seconds to wait
//
//  Return Value:
//      ERROR_SUCCESS       No resources are pending or pnWait is NULL.
//      ERROR_IO_PENDING    At least one resource is still pending (timeout expired).
//      Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForGroupToQuiesce(
    IN      HCLUSTER    hCluster,
    IN      HGROUP      hGroup,
    IN OUT  DWORD *     pnWait
    )
{
    HGROUPENUM  hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    if ( pnWait != NULL )
    {
        hEnum = ClusterGroupOpenEnum( hGroup, CLUSTER_GROUP_ENUM_CONTAINS );
        if ( hEnum != NULL)
        {
            CClusterNotifyPort port;        // Wait for a group state change event

            _sc = port.Create( (HCHANGE) INVALID_HANDLE_VALUE, hCluster );
            if ( _sc == ERROR_SUCCESS )
            {
                LPWSTR  pwszName = NULL;
                DWORD   dwIndex = 0;
                DWORD   dwType = 0;

                _sc = port.Register( CLUSTER_CHANGE_GROUP_STATE, hGroup );
                if ( _sc == ERROR_SUCCESS )
                {
                    //
                    //  Enumerate each of the resources in the group.  If WaitForResourceStateChange
                    //  returns ERROR_IO_PENDING then we know that our wait expired and there's
                    //  still a pending resource, so we break.
                    //
                    for ( dwIndex = 0; _sc == ERROR_SUCCESS; dwIndex++ )
                    {
                        _sc = WrapClusterGroupEnum( hEnum, dwIndex, &dwType, &pwszName );
                        if ( _sc == ERROR_NO_MORE_ITEMS )
                        {
                            _sc = ERROR_SUCCESS;
                            break;
                        } // if: WrapClusterGroupEnum out of items -- leave!    we are done...
                        else if ( _sc == ERROR_SUCCESS )
                        {
                            _sc = WaitForResourceStateChange( hCluster, pwszName, &port, pnWait );
                            ::LocalFree( pwszName );
                            pwszName = NULL;
                        } // if: WrapClusterGroupEnum succeeded
                        else
                        {
                            _sc = GetLastError();
                        } // else: WrapClusterGroupEnum failed!
                    } // for: enum the resources in the group
                } // if: notification port registered
                else
                {
                    _sc = GetLastError();
                } // else: port registration failed
            } // if: create notification port

            ClusterGroupCloseEnum( hEnum );
        } // if: ClusterGroupOpenEnum succeeds
        else
        {
            _sc = GetLastError();
        } // else: ClusterGroupOpenEnum failed
    } // if: no wait time....

    return _sc;

} //*** WaitForGroupToQuiesce()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WaitForResourceToQuiesce
//
//  Description:
//      Wrapper function that is called after OnlineClusterResouce  and
//      OfflineClusterResource that waits for the resource to finish its
//      state change.  Returns the pending state of the resource after the
//      wait period has expired and the state has not changed.
//
//  Arguments:
//      hCluster        [IN]    -   the cluster handle
//      hResource       [IN]    -   the resource handle to take on or offline
//      crsDesiredState [IN]    -   the desired end state of the resource
//      nWait           [IN]    -   ~ how many seconds to wait
//      pbPending       [OUT]   -   true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD WaitForResourceToQuiesce(
    IN      HCLUSTER                hCluster,
    IN      HRESOURCE               hResource,
    IN      CLUSTER_RESOURCE_STATE  crsDesiredState,
    IN      DWORD                   nWait,
    OUT     long    *               pbPending
    )
{
    CLUSTER_RESOURCE_STATE  crs = ClusterResourceStateUnknown;
    DWORD                   _sc = ERROR_SUCCESS;
    CClusterNotifyPort      port;        // if wait is specified open a notify port.

    //printf( "Entering..." );

    if ( crsDesiredState >= ClusterResourcePending )
    {
        _sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    //
    //  nWait should never be zero, but leaving this test in is a good idea
    //  since someone may call it with zero someday...
    //

    if ( nWait == 0 )
    {
        //printf( "A wait time was not specified. Returning ClusterResourcePending" );
        crs = ClusterResourcePending;
        goto Cleanup;
    } // if: no wait time was specified...

    _sc = port.Create( (HCHANGE) INVALID_HANDLE_VALUE, hCluster );
    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: port was not created ok

    _sc = port.Register( CLUSTER_CHANGE_RESOURCE_STATE, hResource );
    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: port was not registered ok

    do
    {
        crs = WrapGetClusterResourceState( hResource, NULL, NULL );
        if ( crs == ClusterResourceFailed )
        {
            _sc = ERROR_INVALID_STATE;
            break;
        } // if:
        else if ( crs == ClusterResourceStateUnknown )
        {
            _sc = GetLastError();
            break;
        } // else if:
        else if ( crs == crsDesiredState )
        {
            break;
        } // else if:

        port.GetNotify();       // waits for ~ 1 second

        nWait--;
    } while ( nWait > 0 );

    //printf( "Exiting wait loop. Time remaining is %d seconds and resource state is %d", nWait, crs );

Cleanup:

    //
    // return the pending state if the caller has asked for it
    //

    if ( pbPending != NULL )
    {
        if ( crs >= ClusterResourcePending )
        {
            *pbPending = TRUE;
        } // if: is the resource still in a pending state
    } // if: does the argument exist?

    //printf( "Exiting. sc = %#08x. Pending = %d", _sc, *pbPending );

    return _sc;

} //*** WaitForResourceToQuiesce()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOnlineClusterResource
//
//  Description:
//      Wrapper function for OnlineClusterResouce that returns the pending
//      state of the resource after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      nWait       [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOnlineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ERROR_SUCCESS;

    //printf( "Entering..." );

    _sc = OnlineClusterResource( hResource );
    if ( _sc == ERROR_IO_PENDING )
    {
        //printf( "OnlineClusterResource() returned ERROR_IO_PENDING." );
        if ( nWait > 0 )
        {
            _sc = WaitForResourceToQuiesce( hCluster, hResource, ClusterResourceOnline, nWait, pbPending );
        } // if:
    } // if: ERROR_IO_PENDING
    else if ( _sc == ERROR_SUCCESS )
    {
        //printf( "OnlineClusterResource() returned ERROR_SUCCESS." );
        if ( pbPending != NULL )
        {
            *pbPending = FALSE;
        }
    } // else if: ERROR_SUCCESS, resource must  be online!

    //printf( "Exiting. sc = %#08x.", _sc );

    return _sc;

} //*** ScWrapOnlineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOnlineClusterResource
//
//  Description:
//      Wrapper function for WrapOnlineClusterResouce
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      nWait       [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOnlineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    //printf( "Entering..." );

    DWORD   _sc = ScWrapOnlineClusterResource( hCluster, hResource, nWait, pbPending );

    //printf( "Exiting. sc = %#08x.", _sc );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOnlineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOfflineClusterResource
//
//  Description:
//      Wrapper function for OfflineClusterResouce that returns the pending
//      state of the resource after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOfflineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ERROR_SUCCESS;

    //printf( "Entering..." );

    _sc = OfflineClusterResource( hResource );
    if ( _sc == ERROR_IO_PENDING )
    {
        //printf( "OfflineClusterResource() returned ERROR_IO_PENDING." );
        if ( nWait > 0 )
        {
            _sc = WaitForResourceToQuiesce( hCluster, hResource, ClusterResourceOffline, nWait, pbPending );
        } // if:
    } // if: ERROR_IO_PENDING
    else if ( _sc == ERROR_SUCCESS )
    {
        //printf( "OfflineClusterResource() returned ERROR_SUCCESS." );
        if ( pbPending != NULL )
        {
            *pbPending = FALSE;
        }
    } // else if: ERROR_SUCCESS, resource must  be online!

    //printf( "Exiting. sc = %#08x.", _sc );

    return _sc;

} //*** ScWrapOfflineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOfflineClusterResource
//
//  Description:
//      Wrapper function for ScWrapOfflineClusterResource
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hResource   [IN]    - the resource handle to take on or offline
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOfflineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    //printf( "Entering..." );

    DWORD   _sc = ScWrapOfflineClusterResource( hCluster, hResource, nWait, pbPending );

    //printf( "Exiting. sc = %#08x.", _sc );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOfflineClusterResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOnlineClusterGroup
//
//  Description:
//      Wrapper function for OnlineClusterGroup that returns the pending state
//      of the group after the wait period has expired or the group quiesces.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      hNode       [IN]    - the node the group should be brought online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT] - true if the resource group is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode,          //=NULL
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    CLUSTER_GROUP_STATE cgs = ClusterGroupStateUnknown;
    DWORD               _sc = ERROR_SUCCESS;
    BOOL                bPending = FALSE;

    _sc = OnlineClusterGroup( hGroup, hNode );
    if ( _sc == ERROR_IO_PENDING )
    {
        //
        // Check the group state before we check the state of the resources. When reporting the
        // group state the cluster API pulls the resource states online and offline pending up
        // to online or offline respectivly.    It also pulls the failed state up to offline.   This
        // means that a group state of online or offline is misleading because one or more
        // resources could be in a pending state.   The only absolute state is PartialOnline, at
        // least one resource is offline (or failed).
        //
        cgs = WrapGetClusterGroupState( hGroup, NULL );
        if ( cgs == ClusterGroupPending )
        {
            _sc = WaitForResourceGroupStateChange( hCluster, hGroup, &nWait );

            cgs = WrapGetClusterGroupState( hGroup, NULL );
            if ( cgs == ClusterGroupPending )
            {
                bPending = TRUE;
            }
        } // if: group state is pending
        else if ( ( cgs == ClusterGroupOnline ) || ( cgs == ClusterGroupPartialOnline ) )
        {
            _sc = WaitForGroupToQuiesce( hCluster, hGroup, &nWait );
            if ( _sc == ERROR_IO_PENDING )
            {
                bPending = TRUE;
                _sc = ERROR_SUCCESS;
            } // if: HrWaitForGroupToQuiesce returned pending
        } // else if: group is online -- we have to check all of the resources, on downlevel clusters...
        else if ( cgs == ClusterGroupStateUnknown )
        {
            _sc = GetLastError();
        } // else if: get group state failed
    } // if: OnlineClusterGroup returned ERROR_IO_PENDING

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        *pbPending = bPending;
    } // if: does the argument exist?

    return _sc;

} //*** ScWrapOnlineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOnlineClusterGroup
//
//  Description:
//      Wrapper function for ScWrapOnlineClusterGroup
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      hNode       [IN]    - the node the group should be brought online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT] - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode,          //=NULL
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ScWrapOnlineClusterGroup( hCluster, hGroup, hNode, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOnlineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapOfflineClusterGroup
//
//  Description:
//      Wrapper function for OfflineClusterGroup that returns the pending
//      state of the group after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    CLUSTER_GROUP_STATE cgs = ClusterGroupStateUnknown;
    DWORD               _sc = ERROR_SUCCESS;
    BOOL                bPending = FALSE;

    _sc = OfflineClusterGroup( hGroup );
    if ( _sc == ERROR_IO_PENDING )
    {
        //
        // Check the group state before we check the state of the resources. When reporting the
        // group state the cluster API pulls the resource states online and offline pending up
        // to online or offline respectivly.    It also pulls the failed state up to offline.   This
        // means that a group state of online or offline is misleading because one or more
        // resources could be in a pending state.
        //
        cgs = WrapGetClusterGroupState( hGroup, NULL );
        if ( cgs == ClusterGroupPending )
        {
            _sc = WaitForResourceGroupStateChange( hCluster, hGroup, &nWait );

            cgs = WrapGetClusterGroupState( hGroup, NULL );
            if ( cgs == ClusterGroupPending )
            {
                bPending = TRUE;
            }
        } // if: group state is pending
        else if ( ( cgs == ClusterGroupOffline ) || ( cgs == ClusterGroupPartialOnline ) )
        {
            _sc = WaitForGroupToQuiesce( hCluster, hGroup, &nWait );
            if ( _sc == ERROR_IO_PENDING )
            {
                bPending = TRUE;
                _sc = ERROR_SUCCESS;
            } // if: HrWaitForGroupToQuiesce returned pending
        } // else if: group is offline -- we have to check all of the resources...
        else if ( cgs == ClusterGroupStateUnknown )
        {
            _sc = GetLastError();
        } // else if: get group state failed
    } // if: OfflineClusterGroup returned ERROR_IO_PENDING

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        *pbPending = bPending;
    } // if: does the argument exist?

    return _sc;

} //*** ScWrapOfflineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapOfflineClusterGroup
//
//  Description:
//      Wrapper function for OfflineClusterGroup that returns the pending
//      state of the group after the wait period has expired.
//
//  Arguments:
//      hCluster    [IN]    - the cluster handle
//      hGroup      [IN]    - the group handle to online
//      pnWait      [IN]    - ~ how many seconds to wait
//      pbPending   [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait,          //=0
    OUT long *      pbPending       //=NULL
    )
{
    DWORD   _sc = ScWrapOfflineClusterGroup( hCluster, hGroup, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapOfflineClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapMoveClusterGroup
//
//  Description:
//      Wrapper function for MoveClusterGroup that returns the pending state
//      of the group after the wait period has expired.
//
//  Arguments:
//      hCluster        [IN]    - the cluster handle
//      hGroup          [IN]    - the group handle to online
//      hNode           [IN]    - the node the group should be brought online
//      pnWait          [IN]    - ~ how many seconds to wait
//      pbPending       [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      ERROR_SUCCESS or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ScWrapMoveClusterGroup(
    IN  HCLUSTER                hCluster,
    IN  HGROUP                  hGroup,
    IN  HNODE                   hNode,              //=NULL
    IN  DWORD                   nWait,              //=0
    OUT long *                  pbPending           //=NULL
    )
{
    LPWSTR              pszOriginNodeName           = NULL;
    BOOL                bPending                    = FALSE;
    DWORD               _sc;

    CLUSTER_GROUP_STATE cgsInitialState             = ClusterGroupStateUnknown;
    CLUSTER_GROUP_STATE cgsCurrentState             = ClusterGroupStateUnknown;
    LPWSTR              pszCurrentNodeName          = NULL;

    // Get the initial group state.
    cgsInitialState = WrapGetClusterGroupState( hGroup, &pszOriginNodeName );
    if ( cgsInitialState == ClusterGroupStateUnknown )
    {
        // Error getting the group state
        _sc = GetLastError();
        goto Cleanup;
    }

    // Move the cluster group.
    _sc = MoveClusterGroup( hGroup, hNode );

    //
    // When MoveClusterGroup returns ERROR_SUCCESS, it just means that the group
    // has changed ownership successfully, but it does not mean that the group is
    // back to the state it was in before the move. Therefore, we still need to
    // wait, if a wait time is provided. If not, we are done.
    //
    if ( nWait <= 0 )
    {
        goto Cleanup;
    }

    //
    // MoveClusterGroup is not done yet
    //
    if ( _sc == ERROR_IO_PENDING )
    {
        _sc = ERROR_SUCCESS;

        do  // while (nWait > 0)
        {
            //
            // Get the name of the node which currently owns this group.
            //
            cgsCurrentState = WrapGetClusterGroupState( hGroup, &pszCurrentNodeName );
            if ( cgsCurrentState == ClusterGroupStateUnknown )
            {
                // Error getting the group state
                _sc = GetLastError();
                break;
            }

            if ( ClRtlStrICmp( pszOriginNodeName, pszCurrentNodeName ) != 0 )
            {
                //
                // If the current owner node is not the original owner, then the call to
                // move group has succeeded. So quit this loop (we still have to see
                // if the group is stable though)
                //
                break;
            } // if: current owner node is not the same as the original owner node
            else
            {
                //
                // Current owner is the same as the original owner.
                // Wait for one second and check again.
                //
                LocalFree( pszCurrentNodeName );
                pszCurrentNodeName = NULL;      // Required to prevent freeing memory twice
                --nWait;
                Sleep( 1000 );
            } // if: current owner node is the same as the original owner node
        }
        while ( nWait > 0 );

        LocalFree( pszCurrentNodeName );

        //
        // If we ran out of time waiting for MoveClusterGroup to complete, then
        // set the pending flag and quit.
        //
        if ( nWait <= 0 )
        {
            bPending = TRUE;
            goto Cleanup;
        }
    } // if: MoveClusterGroup returned ERROR_IO_PENDING
    else
    {
        cgsCurrentState = WrapGetClusterGroupState( hGroup, NULL );
        if ( cgsCurrentState == ClusterGroupStateUnknown )
        {
            // Error getting the group state
            _sc = GetLastError();
        }
    } // else: MoveClusterGroup returned ERROR_SUCCESS

    //
    // if something went wrong with MoveClusterGroup, while waiting
    // for it to comeplete or with WrapGetClusterGroupState, then quit.
    //
    if ( _sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    // If the state of the group on the destination node is ClusterGroupFailed
    // then there is nothing much we can do.
    //
    if ( cgsCurrentState == ClusterGroupFailed )
    {
        goto Cleanup;
    }

    //
    // Check the group state before we check the state of the resources. When reporting the
    // group state the cluster API of a NT4 node pulls the resource states online and offline
    // pending up to online or offline respectivly. It also pulls the failed state up to offline.
    // This means that a group state of online or offline is misleading because one or more
    // resources could be in a pending state. The only absolute state is PartialOnline, at
    // least one resource is offline (or failed).
    //

    if ( cgsCurrentState == ClusterGroupPending )
    {
        // The current state is pending. So wait for a state change.
        _sc = WaitForResourceGroupStateChange( hCluster, hGroup, &nWait );
    } // if: the group state is pending.
    else
    {
        _sc = WaitForGroupToQuiesce( hCluster, hGroup, &nWait );
    } // else: group state is online, offline or partial online

    if ( _sc == ERROR_SUCCESS )
    {
        bPending = ( nWait == 0 );
    } // if: everything ok so far

 Cleanup:

    LocalFree( pszOriginNodeName );

    //
    // return the pending state if the caller has asked for it
    //
    if ( pbPending != NULL )
    {
        *pbPending = bPending;
    } // if: does the argument exist?

    return _sc;

} //*** ScWrapMoveClusterGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrWrapMoveClusterGroup
//
//  Description:
//      Wrapper function for ScWrapMoveClusterGroup that returns the pending state
//      of the group after the wait period has expired.
//
//  Arguments:
//      hCluster        [IN]    - the cluster handle
//      hGroup          [IN]    - the group handle to online
//      hNode           [IN]    - the node the group should be brought online
//      pnWait          [IN]    - ~ how many seconds to wait
//      pbPending       [OUT]   - true if the resource is in a pending state
//
//  Return Value:
//      S_OK or Win32 error code
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrWrapMoveClusterGroup(
    IN  HCLUSTER                hCluster,
    IN  HGROUP                  hGroup,
    IN  HNODE                   hNode,              //=NULL
    IN  DWORD                   nWait,              //=0
    OUT long *                  pbPending           //=NULL
    )
{
    DWORD   _sc = ScWrapMoveClusterGroup ( hCluster, hGroup, hNode, nWait, pbPending );

    return HRESULT_FROM_WIN32( _sc );

} //*** HrWrapMoveClusterGroup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScWrapClusterResourceControlGet
//
//  Routine Description:
//      Wrap a call to ClusterResourceControl with a "GET" control code.
//      If lppOutBufferOut is not NULL this will allocate the buffer if
//      needed, Call ClusterResourceControl, and return the out buffer
//      data through the BufferOut parameter.
//
//  Arguments:
//      hResourceIn         Passed to ClusterResourceControl.
//      hHostNodeIn         Optional handle to a node.
//      dwControlCodeIn     Passed to ClusterResourceControl.
//      lpInBufferIn        Passed to ClusterResourceControl.
//      cbInBufferSizeIn    Passed to ClusterResourceControl.
//      lppOutBufferOut     Optional (may be NULL).  On input pointer to a
//                          pointer to receive the buffer.  On output set
//                          to the buffer (if one was allocated).  Use
//                           LocalFree to deallocate this buffer.
//      lpcbBytesReturnedOut Pointer to receive the count of bytes
//                          allocated for the lppOutBufferOut buffer.
//
//
//  Return Value:
//      ERROR_SUCCESS on success.
//          The number of characters written (including NULL) is returned
//          via lpcbBytesReturnedOut.  A pointer to the allocated buffer is
//          returned via lppOutBufferOut.
//
//      Win32 Error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
ScWrapClusterResourceControlGet(
      HRESOURCE hResourceIn
    , HNODE     hHostNodeIn
    , DWORD     dwControlCodeIn
    , LPVOID    lpInBufferIn
    , DWORD     cbInBufferSizeIn
    , LPVOID *  lppOutBufferOut
    , LPDWORD   lpcbBytesReturnedOut
      )
{
    DWORD       sc = ERROR_SUCCESS;
    LPVOID      lpOutBuffer = NULL;
    DWORD       cbBytesReturned = 0;

    //
    //  Call it once to get the needed buffer sizes.
    //
    sc = ClusterResourceControl(
              hResourceIn
            , hHostNodeIn
            , dwControlCodeIn
            , lpInBufferIn
            , cbInBufferSizeIn
            , NULL
            , 0
            , &cbBytesReturned
            );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  If for some reason we don't need to allocate a buffer then skip that step.
    //
    if ( cbBytesReturned != 0 )
    {
        //
        //  Some codes return the length of a needed string (in bytes).  I think some
        //  don't account for the NULL, but that may be other API's.
        //
        cbBytesReturned += ( 1 * sizeof( WCHAR ) );

        lpOutBuffer = (PVOID) LocalAlloc( LMEM_ZEROINIT, cbBytesReturned );
        if ( lpOutBuffer == NULL )
        {
            sc = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        //
        //  Do the real call.
        //
        sc = ClusterResourceControl(
                  hResourceIn
                , hHostNodeIn
                , dwControlCodeIn
                , lpInBufferIn
                , cbInBufferSizeIn
                , lpOutBuffer
                , cbBytesReturned
                , &cbBytesReturned
                );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    //
    //  If the caller wanted the number of bytes returned.
    //
    if ( lpcbBytesReturnedOut != NULL )
    {
        *lpcbBytesReturnedOut = cbBytesReturned;
    }

    //
    //  If the caller actually wanted the out buffer contents.
    //
    if ( lppOutBufferOut != NULL )
    {
        *lppOutBufferOut = lpOutBuffer;
    }
    else
    {
        // Avoid a memory leak.
        LocalFree( lpOutBuffer );
    }

Cleanup:

    return sc;

} //*** ScWrapClusterResourceControlGet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Abstract:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Author:
//		David Potter (davidp)	September 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);

void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

void AFXAPI DDV_Path(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(pDX, nIDC, (DWORD &) rnValue, (DWORD) nMin, (DWORD) nMax, bSigned);
}

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\cluswrap.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//  Module Name:
//      ClusWrap.h
//
//  Description:
//      Wrapper functions for Cluster APIs.
//
//  Author:
//      Galen Barbee    (galenb)    15-Aug-1998
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#ifndef __CLUSWRAP_H
#define __CLUSWRAP_H

#include "clusapi.h"
#include "clstrcmp.h"

#define CLUS_DEFAULT_TIMEOUT    10000

//////////////////////////////////////////////////////////////////////////
// Standard cluster API wrappers.
//////////////////////////////////////////////////////////////////////////

DWORD WINAPI WrapGetClusterInformation(
    IN HCLUSTER                         hCluster,
    OUT LPWSTR *                        ppwszClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO   pClusterInfo
    );

DWORD WINAPI WrapGetClusterQuorumResource(
    IN HCLUSTER     hCluster,
    OUT LPWSTR *    ppwszResourceName,
    OUT LPWSTR *    ppwszDeviceName,
    OUT LPDWORD     pdwMaxQuorumLogSize
    );

DWORD WINAPI WrapClusterEnum(
    IN HCLUSENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    plpwszName
    );

DWORD WINAPI WrapGetClusterNodeId(
    IN HNODE        hNode,
    OUT LPWSTR *    ppwszNodeId
    );

CLUSTER_GROUP_STATE WINAPI WrapGetClusterGroupState(
    IN HGROUP                   hGroup,
    OUT OPTIONAL    LPWSTR *    ppwszNodeName = NULL
    );

DWORD WINAPI WrapClusterGroupEnum(
    IN HGROUPENUM   hGroupEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszGroupName
    );

DWORD WINAPI WrapClusterNodeEnum(
    IN HNODEENUM    hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszNodeName
    );

DWORD WINAPI WrapClusterNetworkEnum(
    IN HNETWORKENUM hEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszNetworkName
    );

CLUSTER_RESOURCE_STATE WINAPI WrapGetClusterResourceState(
    IN HRESOURCE            hResource,
    OUT OPTIONAL LPWSTR *   ppwszNodeName,
    OUT OPTIONAL LPWSTR *   ppwszGroupName
    );

DWORD WINAPI WrapClusterResourceEnum(
    IN HRESENUM     hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszResourceName
    );

DWORD WINAPI WrapClusterResourceTypeEnum(
    IN HRESTYPEENUM hResEnum,
    IN DWORD        dwIndex,
    OUT LPDWORD     pdwType,
    OUT LPWSTR *    ppwszResTyoeName
    );

HRESULT HrWrapOnlineClusterResource(
    HCLUSTER    hCluster,
    HRESOURCE   hResource,
    DWORD       nWait = 0,
    long *      pbPending = NULL
    );

DWORD ScWrapOnlineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapOfflineClusterResource(
    HCLUSTER    hCluster,
    HRESOURCE   hResource,
    DWORD       nWait = 0,
    long *      pbPending = NULL
    );

DWORD ScWrapOfflineClusterResource(
    IN  HCLUSTER    hCluster,
    IN  HRESOURCE   hResource,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapOnlineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapOfflineClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );


HRESULT HrWrapMoveClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapMoveClusterGroup(
    IN  HCLUSTER    hCluster,
    IN  HGROUP      hGroup,
    IN  HNODE       hNode = NULL,
    IN  DWORD       nWait = 0,
    OUT long *      pbPending = NULL
    );

DWORD ScWrapClusterResourceControlGet(
      HRESOURCE hResourceIn
    , HNODE     hHostNodeIn
    , DWORD     dwControlCodeIn
    , LPVOID    lpInBufferIn
    , DWORD     cbInBufferSizeIn
    , LPVOID *  lppOutBufferOut
    , LPDWORD   lpcbBytesReturnedOut
    );

////////////////////////////////////////////////////////////////////
// Custom helper functions/classes/etc.
////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterNotifyPort
//
//  Description:
//      This class is a wrapper for the cluster notify port
//
//  Inheritance:
//      CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusterNotifyPort
{
public:
    CClusterNotifyPort();
    ~CClusterNotifyPort();

    DWORD Create(
            HCHANGE     hChange = (HCHANGE) INVALID_HANDLE_VALUE,
            HCLUSTER    hCluster = (HCLUSTER) INVALID_HANDLE_VALUE,
            DWORD       dwFilter = 0,
            DWORD_PTR   dwNotifyKey = 0
            );

    DWORD Close();

    DWORD Register( DWORD dwFilterType, HANDLE hObject, DWORD_PTR dwNotifyKey = 0 );

    DWORD GetNotify();

    DWORD_PTR   m_dwNotifyKey;
    DWORD       m_dwFilterType;
    WCHAR*      m_szName;
    DWORD       m_cchName;

protected:
    HCHANGE m_hChange;

}; //*** class CClusterNotifyPort

#endif __CLUSWRAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\clusobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ClusObj.h
//
//	Implementation File:
//		ClusObj.h (this file) and ClusObj.cpp
//
//	Description:
//		Definition of the CClusterObject classes.
//
//	Author:
//		David Potter (davidp)	April 7, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSOBJ_H_
#define __CLUSOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterObject;
class CClusterInfo;
class CClusNodeInfo;
class CClusGroupInfo;
class CClusResInfo;
class CClusResTypeInfo;
class CClusNetworkInfo;
class CClusNetIFInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _LIST_
#include <list>			// for std::list
#endif

#ifndef _CLUSTER_API_
#include <ClusApi.h>	// for cluster types
#endif

#ifndef __cluadmex_h__
#include "CluAdmEx.h"	// for CLUADMEX_OBJECT_TYPE
#endif

#ifndef _CLUSUDEF_H_
#include "ClusUDef.h"	// for default values
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef std::list< CClusterObject * >	CClusObjPtrList;
typedef std::list< CClusterInfo * >		CClusterPtrList;
typedef std::list< CClusNodeInfo * >	CClusNodePtrList;
typedef std::list< CClusGroupInfo * >	CClusGroupPtrList;
typedef std::list< CClusResInfo * >		CClusResPtrList;
typedef std::list< CClusResTypeInfo * >	CClusResTypePtrList;
typedef std::list< CClusNetworkInfo * >	CClusNetworkPtrList;
typedef std::list< CClusNetIFInfo * >	CClusNetIFPtrList;

union CLUSTER_REQUIRED_DEPENDENCY
{
	CLUSTER_RESOURCE_CLASS	rc;
	LPWSTR					pszTypeName;
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusterObject
//
//	Description:
//		Base class for all cluster object classes.  Provides base
//		functionality.
//
//	Inheritance:
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusterObject( IN CLUADMEX_OBJECT_TYPE cot )
	{
		ATLASSERT( cot > CLUADMEX_OT_NONE );

		m_nReferenceCount = 0;
		Reset( NULL, NULL, cot );

	} //*** CClusterObject()

	// Constructor taking group name
	CClusterObject(
		IN CLUADMEX_OBJECT_TYPE	cot,
		IN CClusterInfo *		pci,
		IN LPCTSTR				pszName
		)
	{
		ATLASSERT( cot > CLUADMEX_OT_NONE );

		m_nReferenceCount = 0;
		Reset( pci, pszName, cot );

	} //*** CClusterObject(pszName)

	virtual ~CClusterObject( void )
	{
	} //*** ~CClusterObject()

	// Copy another object into this one.
	void Copy( IN const CClusterObject & rco )
	{
		m_pci = rco.m_pci;
		m_bQueried = rco.m_bQueried;
		m_bCreated = rco.m_bCreated;
		m_cot = rco.m_cot;
		m_strName = rco.m_strName;
		m_strDescription = rco.m_strDescription;

	} //*** Copy()

	// Reset the data back to default values
	void Reset(
		IN CClusterInfo *		pci,
		IN LPCTSTR				pszName = NULL,
		IN CLUADMEX_OBJECT_TYPE	cot = CLUADMEX_OT_NONE
		)
	{
		m_pci = pci;

		m_bQueried = FALSE;
		m_bCreated = FALSE;

		if ( cot != CLUADMEX_OT_NONE )
		{
			m_cot = cot;
		} // if:  valid object type specified

		if ( pszName == NULL )
		{
			m_strName.Empty();
		} // if:  no name specified
		else
		{
			m_strName = pszName;
		} // else:  name specified

		m_strDescription.Empty();

	} //*** Reset()

protected:
	//
	// Reference counting properties.
	//

	ULONG		m_nReferenceCount;

public:
	//
	// Reference counting methods.
	//

	// Get the current count of references
	ULONG NReferenceCount( void ) const { return m_nReferenceCount; }

	// Add a reference to this object
	ULONG AddRef( void )
	{
		ATLASSERT( m_nReferenceCount != (ULONG) -1 );
		return ++m_nReferenceCount;

	} //*** AddRef()

	// Release a reference to this object
	ULONG Release( void )
	{
		ULONG nReferenceCount;

		ATLASSERT( m_nReferenceCount != 0 );

		nReferenceCount = --m_nReferenceCount;
		if ( m_nReferenceCount == 0 )
		{
			delete this;
		} // if:  no more references

		return nReferenceCount;

	} //*** Release()

protected:
	//
	// Properties of a cluster object.
	//

	CClusterInfo *	m_pci;

	BOOL			m_bQueried;
	BOOL			m_bCreated;

	CLUADMEX_OBJECT_TYPE
					m_cot;

	CString			m_strName;
	CString			m_strDescription;

	// Set query state
	BOOL BSetQueried( BOOL bQueried = TRUE )
	{
		BOOL bPreviousValue = m_bQueried;
		m_bQueried = bQueried;
		return bPreviousValue;

	} //*** BSetQueried()

	// Set created state
	BOOL BSetCreated( BOOL bCreated = TRUE )
	{
		BOOL bPreviousValue = m_bCreated;
		m_bCreated = bCreated;
		return bPreviousValue;

	} //*** BSetCreated()

public:
	//
	// Accessor functions for cluster object properties.
	//

	CClusterInfo *	Pci( void ) const				{ ATLASSERT( m_pci != NULL ); return m_pci; }

	BOOL BQueried( void ) const						{ return m_bQueried; }
	BOOL BCreated( void ) const						{ return m_bCreated; }

	CLUADMEX_OBJECT_TYPE Cot( void ) const			{ return m_cot; }

	const CString & RstrName( void ) const			{ return m_strName; }
	const CString & RstrDescription( void ) const	{ return m_strDescription; }

	// Set the cluster info pointer
	void SetClusterInfo( IN CClusterInfo * pci )
	{
		ATLASSERT( pci != NULL );
		ATLASSERT( m_pci == NULL );
		m_pci = pci;

	} //*** SetClusterInfo()

	// Set the name of the cluster object.
	void SetName( IN LPCTSTR pszName )
	{
		ATLASSERT( pszName != NULL );
		m_strName = pszName;

	} //*** SetName()

	// Set the description of the cluster object
	void SetDescription( IN LPCTSTR pszDescription )
	{
		ATLASSERT( pszDescription != NULL );
		m_strDescription = pszDescription;

	} //*** SetDescription()

	// Return the list of extensions for this object
	virtual const std::list< CString > * PlstrAdminExtensions( void ) const { return NULL; }

}; //*** class CClusterObject

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusterInfo
//
//	Description:
//		Class for the information about the cluster object itself.  Treats
//		the cluster as an object like other objects.
//
//	Inheritance:
//		CClusterInfo
//		CClusterObject
//
//	Notes:
//		1)  m_hCluster is not owned by this class.
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusterInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusterInfo( void )
		: CClusterObject( CLUADMEX_OT_CLUSTER )
	{
		Reset();

	} //*** CClusterInfo()

	// Constructor taking cluster name
	CClusterInfo( IN LPCTSTR pszName )
		: CClusterObject( CLUADMEX_OT_CLUSTER, NULL, pszName )
	{
		Reset( pszName );

	} //*** CClusterInfo( pszName )

	// Copy another object into this one.
	void Copy( IN const CClusterInfo & rci )
	{
		CClusterObject::Copy( rci );
		m_hCluster = rci.m_hCluster;

	} //*** Copy()

	// Reset the data back to default values
	void Reset( IN LPCTSTR pszName = NULL )
	{
		CClusterObject::Reset( NULL, pszName, CLUADMEX_OT_CLUSTER );
		m_hCluster = NULL;

	} //*** Reset()

protected:
	//
	// Properties of a cluster.
	//

	HCLUSTER m_hCluster;
	std::list< CString >	m_lstrClusterAdminExtensions;
	std::list< CString >	m_lstrNodesAdminExtensions;
	std::list< CString >	m_lstrGroupsAdminExtensions;
	std::list< CString >	m_lstrResourcesAdminExtensions;
	std::list< CString >	m_lstrResTypesAdminExtensions;
	std::list< CString >	m_lstrNetworksAdminExtensions;
	std::list< CString >	m_lstrNetInterfacesAdminExtensions;

public:
	//
	// Accessor functions for cluster properties.
	//

	HCLUSTER Hcluster( void )
	{
		ATLASSERT( m_hCluster != NULL );
		return m_hCluster;

	} //*** Hcluster()

	// Set the cluster handle managed by this object
	void SetClusterHandle( IN HCLUSTER hCluster )
	{
		ATLASSERT( hCluster != NULL );
		m_hCluster = hCluster;

	} //*** SetClusterHandle()

	const std::list< CString > * PlstrAdminExtensions( void ) const					{ return &m_lstrClusterAdminExtensions; }
	const std::list< CString > * PlstrNodesAdminExtensions( void ) const			{ return &m_lstrNodesAdminExtensions; }
	const std::list< CString > * PlstrGroupsAdminExtensions( void ) const			{ return &m_lstrGroupsAdminExtensions; }
	const std::list< CString > * PlstrResourcesAdminExtensions( void ) const		{ return &m_lstrResourcesAdminExtensions; }
	const std::list< CString > * PlstrResTypesAdminExtensions( void ) const			{ return &m_lstrResTypesAdminExtensions; }
	const std::list< CString > * PlstrNetworksAdminExtensions( void ) const			{ return &m_lstrNetworksAdminExtensions; }
	const std::list< CString > * PlstrNetInterfacesAdminExtensions( void ) const	{ return &m_lstrNetInterfacesAdminExtensions; }

}; //*** class CClusterInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNodeInfo
//
//	Description:
//		Cluster node object.
//
//	Inheritance:
//		CClusNodeInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusNodeInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusNodeInfo( void )
		: CClusterObject( CLUADMEX_OT_NODE )
		, m_hNode( NULL )
	{
		Reset( NULL );

	} //*** CClusNodeInfo()

	// Constructor taking cluster info pointer
	CClusNodeInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_NODE, pci, pszName )
		, m_hNode( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusNodeInfo( pci )

	~CClusNodeInfo( void )
	{
		Close();

	} //*** ~CClusNodeInfo()

	// Operator = is not allowed
	CClusNodeInfo & operator=( IN const CClusNodeInfo & rni )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_NODE );

	} //*** Reset()

protected:
	//
	// Properties of a node.
	//

	HNODE m_hNode;

public:
	//
	// Accessor functions for node properties.
	//

	HNODE Hnode( void ) { return m_hNode; }

	// Return the list of extensions for nodes
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrNodesAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hNode == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hNode = OpenClusterNode( m_pci->Hcluster(), m_strName );
		if ( m_hNode == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusNodeInfo & rni )
	{
		ATLASSERT( rni.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rni );

		//
		// Initialize the object.
		//
		if ( rni.m_hNode != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object opened

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		if ( m_hNode != NULL )
		{
			CloseClusterNode( m_hNode );
		} // if:  node is open
		m_hNode = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusNodeInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusGroupInfo
//
//	Description:
//		Cluster group object.
//
//	Inheritance:
//		CClusGroupInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusGroupInfo( void )
		: CClusterObject( CLUADMEX_OT_GROUP )
		, m_hGroup( NULL )
	{
		Reset( NULL );

	} //*** CClusGroupInfo()

	// Constructor taking cluster info pointer
	CClusGroupInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_GROUP, pci, pszName )
		, m_hGroup( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusGroupInfo( pci )

	// Destructor
	~CClusGroupInfo( void )
	{
		Close();

	} //*** ~CClusGroupInfo()

	// Operator = is not allowed
	CClusGroupInfo & operator=( IN const CClusGroupInfo & rgi )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_GROUP );

		m_bCollectedOwners = FALSE;
		m_bCollectedResources = FALSE;

		m_lpniPreferredOwners.erase( m_lpniPreferredOwners.begin(), m_lpniPreferredOwners.end() );
		m_lpriResources.erase( m_lpriResources.begin(), m_lpriResources.end() );

		m_bHasIPAddress = FALSE;
		m_bHasNetName = FALSE;

		m_nPersistentState = 0;
		m_nFailoverThreshold = CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD;
		m_nFailoverPeriod = CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD;
		m_cgaftAutoFailbackType = CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE;
		m_nFailbackWindowStart = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START;
		m_nFailbackWindowEnd = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END;

	} //*** Reset()

protected:
	//
	// Properties of a group.
	//

	HGROUP				m_hGroup;

	BOOL				m_bHasIPAddress;
	BOOL				m_bHasNetName;

	DWORD				m_nPersistentState;
	DWORD				m_nFailoverThreshold;
	DWORD				m_nFailoverPeriod;
	CGAFT				m_cgaftAutoFailbackType;
	DWORD				m_nFailbackWindowStart;
	DWORD				m_nFailbackWindowEnd;

	CString				m_strNetworkName;
	CString				m_strIPAddress;
	CString				m_strNetwork;

	BOOL				m_bCollectedOwners;
	BOOL				m_bCollectedResources;
	CClusNodePtrList	m_lpniPreferredOwners;
	CClusResPtrList		m_lpriResources;

	// Set virtual server properties
	void SetVirtualServerProperties(
		IN LPCWSTR pszNetworkName,
		IN LPCWSTR pszIPAddress,
		IN LPCWSTR pszNetwork
		)
	{
		if ( pszNetworkName != NULL )
		{
			m_strNetworkName = pszNetworkName;
		} // if:  network name specified

		if ( pszIPAddress != NULL )
		{
			m_strIPAddress = pszIPAddress;
		} // if:  IP address specified

		if ( pszNetwork != NULL )
		{
			m_strNetwork = pszNetwork;
		} // if:  network specified

	} //*** SetVirtualServerProperties()

public:
	//
	// Accessor functions for group properties.
	//

	HGROUP Hgroup( void ) const					{ return m_hGroup; }

	BOOL BHasIPAddress( void ) const			{ return m_bHasIPAddress; }
	BOOL BHasNetName( void ) const				{ return m_bHasNetName; }

	DWORD NPersistentState( void ) const		{ return m_nPersistentState; }
	DWORD NFailoverThreshold( void ) const		{ return m_nFailoverThreshold; }
	DWORD NFailoverPeriod( void ) const			{ return m_nFailoverPeriod; }
	CGAFT CgaftAutoFailbackType( void ) const	{ return m_cgaftAutoFailbackType; }
	DWORD NFailbackWindowStart( void ) const	{ return m_nFailbackWindowStart; }
	DWORD NFailbackWindowEnd( void ) const		{ return m_nFailbackWindowEnd; }

	const CString & RstrNetworkName( void ) const	{ return m_strNetworkName; }
	const CString & RstrIPAddress( void ) const		{ return m_strIPAddress; }
	const CString & RstrNetwork( void ) const		{ return m_strNetwork; }

	BOOL BCollectedOwners( void ) const				{ return m_bCollectedOwners; }
	CClusNodePtrList * PlpniPreferredOwners( void )	{ return &m_lpniPreferredOwners; }
	CClusResPtrList * PlpriResources( void )		{ return &m_lpriResources; }

	// Returns whether the group is a virtual server or not
	BOOL BIsVirtualServer( void ) const
	{
		return m_bQueried && m_bHasIPAddress & m_bHasNetName;

	} //*** BIsVirtualServer()

	// Set failover properties for the group
	BOOL BSetFailoverProperties(
		IN DWORD nFailoverThreshold,
		IN DWORD nFailoverPeriod
		)
	{
		BOOL bChanged = FALSE;

		if ( m_nFailoverThreshold != nFailoverThreshold )
		{
			m_nFailoverThreshold = nFailoverThreshold;
			bChanged = TRUE;
		} // if:  threshold changed

		if ( m_nFailoverPeriod != nFailoverPeriod )
		{
			m_nFailoverPeriod = nFailoverPeriod;
			bChanged = TRUE;
		} // if:  period changed

		return bChanged;

	} //*** BSetFailoverProperties()

	// Set failback properties for the group
	BOOL BSetFailbackProperties(
		IN CGAFT cgaft,
		IN DWORD nFailbackWindowStart,
		IN DWORD nFailbackWindowEnd
		)
	{
		BOOL bChanged = FALSE;

		if ( m_cgaftAutoFailbackType != cgaft )
		{
			m_cgaftAutoFailbackType = cgaft;
			bChanged = TRUE;
		} // if:  autofailback type changed

		if ( m_nFailbackWindowStart != nFailbackWindowStart )
		{
			m_nFailbackWindowStart = nFailbackWindowStart;
			bChanged = TRUE;
		} // if:  failback start window changed

		if ( m_nFailbackWindowEnd != nFailbackWindowEnd )
		{
			m_nFailbackWindowEnd = nFailbackWindowEnd;
			bChanged = TRUE;
		} // if:  failback end window changed

		return bChanged;

	} //*** BSetFailbackProperties()

	// Return the list of extensions for groups
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrGroupsAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hGroup == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hGroup = OpenClusterGroup( m_pci->Hcluster(), m_strName );
		if ( m_hGroup == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Create the object
	DWORD ScCreate( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hGroup == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Create the object.
		//
		m_hGroup = CreateClusterGroup( m_pci->Hcluster(), m_strName );
		if ( m_hGroup == NULL )
		{
			sc = GetLastError();
		} // if:  error creating the object

		return sc;

	} //*** ScCreate()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusGroupInfo & rgi )
	{
		ATLASSERT( rgi.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rgi );

		m_bHasIPAddress = rgi.m_bHasIPAddress;
		m_bHasNetName = rgi.m_bHasNetName;
		m_nPersistentState = rgi.m_nPersistentState;
		m_nFailoverThreshold = rgi.m_nFailoverThreshold;
		m_nFailoverPeriod = rgi.m_nFailoverPeriod;
		m_cgaftAutoFailbackType = rgi.m_cgaftAutoFailbackType;
		m_nFailbackWindowStart = rgi.m_nFailbackWindowStart;
		m_nFailbackWindowEnd = rgi.m_nFailbackWindowEnd;

		//
		// Copy the preferred owners and resources lists.
		//
		m_lpniPreferredOwners = rgi.m_lpniPreferredOwners;
		m_lpriResources = rgi.m_lpriResources;

		//
		// Initialize the object.
		//
		if ( rgi.m_hGroup != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Delete the object
	DWORD ScDelete( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_hGroup != NULL );

		DWORD sc = ERROR_SUCCESS;

		sc = DeleteClusterGroup( m_hGroup );
		if ( sc == ERROR_SUCCESS )
		{
			Close();
			m_bCreated = FALSE;
		} // if:  objected deleted successfully

		return sc;

	} //*** ScDelete()

	// Close the object
	void Close( void )
	{
		if ( m_hGroup != NULL )
		{
			CloseClusterGroup( m_hGroup );
		} // if:  group is open
		m_hGroup = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusGroupInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypeInfo
//
//	Description:
//		Cluster resource type object.
//
//	Inheritance:
//		CClusResTypeInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusResTypeInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusResTypeInfo( void )
		: CClusterObject( CLUADMEX_OT_RESOURCETYPE )
		, m_pcrd( NULL )
	{
		Reset( NULL );

	} //*** CClusResTypeInfo()

	// Constructor taking cluster info pointer
	CClusResTypeInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_RESOURCETYPE, pci, pszName )
		, m_pcrd( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusResTypeInfo( pci )

	// Destructor
	~CClusResTypeInfo( void )
	{
		Close();

		delete [] m_pcrd;
		m_pcrd = NULL;

	} //*** ~CClusGroupInfo()

	// Operator = is not allowed
	CClusResTypeInfo & operator=( IN const CClusResTypeInfo & rrti )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_RESOURCETYPE );

		m_strDisplayName.Empty();
		m_strResDLLName.Empty();

		m_lstrAdminExtensions.erase( m_lstrAdminExtensions.begin(), m_lstrAdminExtensions.end() );
		m_lstrAllAdminExtensions.erase( m_lstrAllAdminExtensions.begin(), m_lstrAllAdminExtensions.end() );
		m_lstrResourceAdminExtensions.erase( m_lstrResourceAdminExtensions.begin(), m_lstrResourceAdminExtensions.end() );

		m_nLooksAlive = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
		m_nIsAlive = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
		m_rciResClassInfo.rc = CLUS_RESCLASS_UNKNOWN;
		m_rciResClassInfo.SubClass = 0;
		m_fCharacteristics = CLUS_CHAR_UNKNOWN;
		m_fFlags = 0;

		delete [] m_pcrd;
		m_pcrd = NULL;

	} //*** Reset()

protected:
	//
	// Properties of a resource type.
	//

	CString						m_strDisplayName;
	CString						m_strResDLLName;

	std::list< CString >		m_lstrAdminExtensions;
	std::list< CString >		m_lstrAllAdminExtensions;
	std::list< CString >		m_lstrResourceAdminExtensions;

	DWORD						m_nLooksAlive;
	DWORD						m_nIsAlive;
	CLUS_RESOURCE_CLASS_INFO	m_rciResClassInfo;
	DWORD						m_fCharacteristics;
	DWORD						m_fFlags;

	CLUSPROP_REQUIRED_DEPENDENCY *	m_pcrd;

public:
	//
	// Accessor functions for resource type properties
	//

	const CString & RstrDisplayName( void ) const	{ return m_strDisplayName; }
	const CString & RstrResDLLName( void ) const	{ return m_strResDLLName; }

	// Return list of extensions for this resource type
	const std::list< CString > * PlstrAdminExtensions( void )
	{
		//
		// If not done already, construct the complete list of extensions
		// from the extensions for this resource type and the extensions
		// for all resource types.
		//
		if ( m_lstrAllAdminExtensions.size() == 0 )
		{
			ATLASSERT( Pci() != NULL );
			m_lstrAllAdminExtensions = m_lstrAdminExtensions;
			m_lstrAllAdminExtensions.insert(
				m_lstrAllAdminExtensions.end(),
				Pci()->PlstrResTypesAdminExtensions()->begin(),
				Pci()->PlstrResTypesAdminExtensions()->end()
				);
		} // if:  full list not constructed yet

		return &m_lstrAllAdminExtensions;

	} //*** PlstrAdminExtensions()

	// Return list of extensions for resources of this type
	const std::list< CString > * PlstrResourceAdminExtensions( void )
	{
		//
		// If not done already, construct the complete list of extensions
		// from the extensions for this resource type and the extensions
		// for all resources.
		//
		if ( m_lstrResourceAdminExtensions.size() == 0 )
		{
			ATLASSERT( Pci() != NULL );
			m_lstrResourceAdminExtensions = m_lstrAdminExtensions;
			m_lstrResourceAdminExtensions.insert(
				m_lstrResourceAdminExtensions.end(),
				Pci()->PlstrResourcesAdminExtensions()->begin(),
				Pci()->PlstrResourcesAdminExtensions()->end()
				);
		} // if:  full list not constructed yet

		return &m_lstrResourceAdminExtensions;

	} //*** PlstrAdminExtensions()

	DWORD NLooksAlive( void ) const						{ return m_nLooksAlive; }
	DWORD NIsAlive( void ) const						{ return m_nIsAlive; }
	DWORD FCharacteristics( void ) const				{ return m_fCharacteristics; }
	DWORD FFlags( void ) const							{ return m_fFlags; }

	CLUS_RESOURCE_CLASS_INFO *	PrciResClassInfo( void )	{ return &m_rciResClassInfo; }
	CLUSTER_RESOURCE_CLASS		ResClass( void ) const		{ return m_rciResClassInfo.rc; }

	CLUSPROP_REQUIRED_DEPENDENCY * Pcrd( void )			{ return m_pcrd; }

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		return sc;

	} //*** ScOpen()

	// Create the object
	DWORD ScCreate( IN HGROUP hGroup, IN DWORD dwFlags )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_strName.GetLength() > 0 );
		ATLASSERT( m_strDisplayName.GetLength() > 0 );
		ATLASSERT( m_strResDLLName.GetLength() > 0 );
		ATLASSERT( m_nLooksAlive != 0 );
		ATLASSERT( m_nIsAlive != 0 );

		DWORD sc;

		//
		// Create the object.
		//
		sc = CreateClusterResourceType(
			Pci()->Hcluster(),
			m_strName,
			m_strDisplayName,
			m_strResDLLName,
			m_nLooksAlive,
			m_nIsAlive
			);

		return sc;

	} //*** ScCreate()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusResTypeInfo & rrti )
	{
		ATLASSERT( rrti.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rrti );

		m_strDisplayName = rrti.m_strDisplayName;
		m_strResDLLName = rrti.m_strResDLLName;

		m_lstrAdminExtensions = m_lstrAdminExtensions;
		m_lstrResourceAdminExtensions = rrti.m_lstrResourceAdminExtensions;

		m_nLooksAlive = rrti.m_nLooksAlive;
		m_nIsAlive = rrti.m_nIsAlive;
		m_rciResClassInfo.rc = rrti.m_rciResClassInfo.rc;
		m_rciResClassInfo.SubClass = rrti.m_rciResClassInfo.SubClass;
		m_fCharacteristics = rrti.m_fCharacteristics;
		m_fFlags = rrti.m_fFlags;

		//
		// Initialize the object.
		//
		// sc = ScOpen();

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		// Dummy function to support similar semantics as other objects.
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close();

}; //*** class CClusResTypeInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResInfo
//
//	Description:
//		Cluster resource object.
//
//	Inheritance:
//		CClusResInfo
//		CClusterObject
//
//	Notes:
//		1)	Must appear after definition of CClusResTypeInfo because
//			CClusResTypeInfo methods are referenced in this class's methods.
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusResInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusResInfo( void )
		: CClusterObject( CLUADMEX_OT_RESOURCE )
		, m_hResource( NULL )
	{
		Reset( NULL );

	} //*** CClusResInfo()

	// Constructor taking cluster info pointer
	CClusResInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_RESOURCE, pci, pszName )
		, m_hResource( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusResInfo( pci )

	~CClusResInfo( void )
	{
		Close();

	} //*** ~CClusResInfo()

	// Operator = is not allowed
	CClusResInfo & operator=( IN const CClusResInfo & rri )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_RESOURCE );

		m_prti = NULL;
		m_pgi = NULL;
		m_pniOwner = NULL;

		m_bCollectedOwners = FALSE;
		m_bCollectedDependencies = FALSE;

		m_lpniPossibleOwners.erase( m_lpniPossibleOwners.begin(), m_lpniPossibleOwners.end() );
		m_lpriDependencies.erase( m_lpriDependencies.begin(), m_lpriDependencies.end() );

		m_bSeparateMonitor = FALSE;
		m_nPersistentState = 0;
		m_nLooksAlive = CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE;
		m_nIsAlive = CLUSTER_RESOURCE_DEFAULT_IS_ALIVE;
		m_crraRestartAction = CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION;
		m_nRestartThreshold = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
		m_nRestartPeriod = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
		m_nPendingTimeout = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;

	} //*** Reset()

protected:
	//
	// Properties of a resource.
	//

	HRESOURCE			m_hResource;

	CClusResTypeInfo *	m_prti;
	CClusGroupInfo *	m_pgi;
	CClusNodeInfo *		m_pniOwner;

	BOOL				m_bSeparateMonitor;
	DWORD				m_nPersistentState;
	DWORD				m_nLooksAlive;
	DWORD				m_nIsAlive;
	CRRA				m_crraRestartAction;
	DWORD				m_nRestartThreshold;
	DWORD				m_nRestartPeriod;
	DWORD				m_nPendingTimeout;

	BOOL				m_bCollectedOwners;
	BOOL				m_bCollectedDependencies;
	CClusNodePtrList	m_lpniPossibleOwners;
	CClusResPtrList		m_lpriDependencies;

public:
	//
	// Accessor functions for resource properties
	//

	HRESOURCE Hresource( void ) const { return m_hResource; }

	CClusResTypeInfo * Prti( void ) const	{ ATLASSERT( m_prti != NULL ); return m_prti; }
	CClusGroupInfo * Pgi( void ) const		{ ATLASSERT( m_pgi != NULL ); return m_pgi; }
	CClusNodeInfo * PniOwner( void ) const	{ ATLASSERT( m_pniOwner != NULL ); return m_pniOwner; }

	BOOL BSeparateMonitor( void ) const		{ return m_bSeparateMonitor; }
	DWORD NPersistentState( void ) const	{ return m_nPersistentState; }
	DWORD NLooksAlive( void ) const			{ return m_nLooksAlive; }
	DWORD NIsAlive( void ) const			{ return m_nIsAlive; }
	CRRA CrraRestartAction( void ) const	{ return m_crraRestartAction; }
	DWORD NRestartThreshold( void ) const	{ return m_nRestartThreshold; }
	DWORD NRestartPeriod( void ) const		{ return m_nRestartPeriod; }
	DWORD NPendingTimeout( void ) const		{ return m_nPendingTimeout; }

	BOOL BCollectedOwners( void ) const			{ return m_bCollectedOwners; }
	BOOL BCollectedDependencies( void ) const	{ return m_bCollectedDependencies; }
	CClusNodePtrList *	PlpniPossibleOwners( void )	{ return &m_lpniPossibleOwners; }
	CClusResPtrList *	PlpriDependencies( void )	{ return &m_lpriDependencies; }

	CLUSTER_RESOURCE_CLASS ResClass( void ) const	{ return Prti()->ResClass(); }

	// Set the group
	void SetGroup( IN CClusGroupInfo * pgi )
	{
		ATLASSERT( pgi != NULL );

		m_pgi = pgi;

	} //*** SetGroup()

	// Set the resource type of the resource
	BOOL BSetResourceType( IN CClusResTypeInfo * prti )
	{
		ATLASSERT( prti != NULL );

		BOOL bChanged = FALSE;

		//
		// If the resource type changed, set it.
		//
		if ( m_prti != prti )
		{
			m_prti = prti;
			bChanged = TRUE;
		} // if:  resource type changed

		return bChanged;

	} //*** BSetResourceType()

	// Set the separate monitor property for the resource
	BOOL BSetSeparateMonitor( IN BOOL bSeparateMonitor )
	{
		BOOL bChanged = FALSE;

		if ( m_bSeparateMonitor != bSeparateMonitor )
		{
			m_bSeparateMonitor = bSeparateMonitor;
			bChanged = TRUE;
		} // if:  separate monitor changed

		return bChanged;

	} //*** BSetSeparateMonitor()

	// Set advanced properties for the resource
	BOOL BSetAdvancedProperties(
		IN CRRA crra,
		IN DWORD nRestartThreshold,
		IN DWORD nRestartPeriod,
		IN DWORD nLooksAlive,
		IN DWORD nIsAlive,
		IN DWORD nPendingTimeout
		)
	{
		BOOL bChanged = FALSE;

		if ( m_crraRestartAction != crra )
		{
			m_crraRestartAction = crra;
			bChanged = TRUE;
		} // if:  restart action changed

		if ( m_nRestartThreshold != nRestartThreshold )
		{
			m_nRestartThreshold = nRestartThreshold;
			bChanged = TRUE;
		} // if:  restart threshold changed

		if ( m_nRestartPeriod != nRestartPeriod )
		{
			m_nRestartPeriod = nRestartPeriod;
			bChanged = TRUE;
		} // if:  restart period changed

		if ( m_nLooksAlive != nLooksAlive )
		{
			m_nLooksAlive = nLooksAlive;
			bChanged = TRUE;
		} // if:  looks alive period changed

		if ( m_nIsAlive != nIsAlive )
		{
			m_nIsAlive = nIsAlive;
			bChanged = TRUE;
		} // if:  is alive period changed

		if ( m_nPendingTimeout != nPendingTimeout )
		{
			m_nPendingTimeout = nPendingTimeout;
			bChanged = TRUE;
		} // if:  pending timeout changed

		return bChanged;

	} //*** BSetAdvancedProperties()

	// Return the list of extensions for resources
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( m_prti != NULL );
		return m_prti->PlstrResourceAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hResource == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hResource = OpenClusterResource( m_pci->Hcluster(), m_strName );
		if ( m_hResource == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Create the object
	DWORD ScCreate( IN HGROUP hGroup, IN DWORD dwFlags )
	{
		ATLASSERT( hGroup != NULL );
		ATLASSERT( Prti() != NULL );
		ATLASSERT( Prti()->RstrName().GetLength() > 0 );
		ATLASSERT( m_hResource == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		m_bSeparateMonitor = ( dwFlags & CLUSTER_RESOURCE_SEPARATE_MONITOR ) == CLUSTER_RESOURCE_SEPARATE_MONITOR;

		//
		// Create the object.
		//
		m_hResource = CreateClusterResource( hGroup, m_strName, Prti()->RstrName(), dwFlags );
		if ( m_hResource == NULL )
		{
			sc = GetLastError();
		} // if:  error creating the object

		return sc;

	} //*** ScCreate()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusResInfo & rri )
	{
		ATLASSERT( rri.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rri );

		m_prti = rri.m_prti;
		m_pgi = rri.m_pgi;
		m_pniOwner = rri.m_pniOwner;

		m_bSeparateMonitor = rri.m_bSeparateMonitor;
		m_nPersistentState = rri.m_nPersistentState;
		m_nLooksAlive = rri.m_nLooksAlive;
		m_nIsAlive = rri.m_nIsAlive;
		m_crraRestartAction = rri.m_crraRestartAction;
		m_nRestartThreshold = rri.m_nRestartThreshold;
		m_nRestartPeriod = rri.m_nRestartPeriod;
		m_nPendingTimeout = rri.m_nPendingTimeout;

		//
		// Copy the possible owners and dependencies lists.
		//
		m_lpniPossibleOwners = rri.m_lpniPossibleOwners;
		m_lpriDependencies = rri.m_lpriDependencies;

		//
		// Initialize the object.
		//
		if ( rri.m_hResource != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Delete the object
	DWORD ScDelete( void )
	{
		ATLASSERT( m_hResource != NULL );

		DWORD sc = ERROR_SUCCESS;

		sc = DeleteClusterResource( m_hResource );
		if ( sc == ERROR_SUCCESS )
		{
			Close();
			m_bCreated = FALSE;
		} // if:  objected deleted successfully

		return sc;

	} //*** ScDelete()

	// Close the object
	void Close( void )
	{
		if ( m_hResource != NULL )
		{
			CloseClusterResource( m_hResource );
		} // if:  resource is open
		m_hResource = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

	// Get network name of first Network Name resource we are dependent on
	BOOL BGetNetworkName(
		OUT WCHAR *		lpszNetName,
		IN OUT DWORD *	pcchNetName
		)
	{
		ATLASSERT( m_hResource != NULL );
		ATLASSERT( lpszNetName != NULL );
		ATLASSERT( pcchNetName != NULL );

		return GetClusterResourceNetworkName(
					m_hResource,
					lpszNetName,
					pcchNetName
					);

	} //*** BGetNetworkName()

	// Determine whether required dependencies are specified or not
	BOOL BRequiredDependenciesPresent(
		IN CClusResPtrList const *	plpri,
		OUT CString &				rstrMissing,
		OUT BOOL &					rbMissingTypeName
		);

}; //*** class CClusResInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetworkInfo
//
//	Description:
//		Cluster network object.
//
//	Inheritance:
//		CClusNetworkInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusNetworkInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusNetworkInfo( void )
		: CClusterObject( CLUADMEX_OT_NETWORK )
		, m_hNetwork( NULL )
	{
		Reset( NULL );

	} //*** CClusNetworkInfo()

	// Constructor taking cluster info pointer
	CClusNetworkInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_NETWORK, pci, pszName )
		, m_hNetwork( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusNetworkInfo( pci )

	~CClusNetworkInfo( void )
	{
		Close();

	} //*** ~CClusterNetworkInfo()

	// Operator = is not allowed
	CClusNetworkInfo & operator=( IN const CClusNetworkInfo & rni )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_NETWORK );

		m_nRole = ClusterNetworkRoleNone;
		m_strAddress.Empty();
		m_strAddressMask.Empty();

		m_nAddress = 0;
		m_nAddressMask = 0;

	} //*** Reset()

protected:
	//
	// Properties of a network.
	//

	HNETWORK				m_hNetwork;

	CLUSTER_NETWORK_ROLE	m_nRole;
	CString					m_strAddress;
	CString					m_strAddressMask;

	DWORD					m_nAddress;
	DWORD					m_nAddressMask;

public:
	//
	// Accessor functions for network properties
	//

	HNETWORK Hnetwork( void ) const					{ return m_hNetwork; }

	CLUSTER_NETWORK_ROLE NRole( void ) const		{ return m_nRole; }
	const CString & RstrAddress( void ) const		{ return m_strAddress; }
	const CString & RstrAddressMask( void ) const	{ return m_strAddressMask; }

	DWORD NAddress( void ) const					{ return m_nAddress; }
	DWORD NAddressMask( void ) const				{ return m_nAddressMask; }

	// Returns whether the network is used for client access
	BOOL BIsClientNetwork( void ) const
	{
		return m_bQueried && (m_nRole & ClusterNetworkRoleClientAccess);

	} //*** BIsClientNetwork()

	// Returns whether the network is used for internal cluster use
	BOOL BIsInternalNetwork( void ) const
	{
		return m_bQueried && (m_nRole & ClusterNetworkRoleInternalUse);

	} //*** BIsInternalNetwork()

	// Return the list of extensions for networks
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrNetworksAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hNetwork == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hNetwork = OpenClusterNetwork( m_pci->Hcluster(), m_strName );
		if ( m_hNetwork == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusNetworkInfo & rni )
	{
		ATLASSERT( rni.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rni );

		m_nRole = rni.m_nRole;
		m_strAddress = rni.m_strAddress;
		m_strAddressMask = rni.m_strAddressMask;

		m_nAddress = rni.m_nAddress;
		m_nAddressMask = rni.m_nAddressMask;

		//
		// Initialize the object.
		//
		if ( rni.m_hNetwork != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		if ( m_hNetwork != NULL )
		{
			CloseClusterNetwork( m_hNetwork );
		} // if:  network is open
		m_hNetwork = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusNetworkInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetIFInfo
//
//	Description:
//		Cluster network interface object.
//
//	Inheritance:
//		CClusNetIFInfo
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusNetIFInfo : public CClusterObject
{
	friend class CWizardThread;

public:
	//
	// Construction.
	//

	// Default constructor
	CClusNetIFInfo( void )
		: CClusterObject( CLUADMEX_OT_NETINTERFACE )
		, m_hNetInterface( NULL )
	{
		Reset( NULL );

	} //*** CClusNetworkInfo()

	// Constructor taking cluster info pointer
	CClusNetIFInfo( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
		: CClusterObject( CLUADMEX_OT_NETINTERFACE, pci, pszName )
		, m_hNetInterface( NULL )
	{
		Reset( pci, pszName );

	} //*** CClusNetIFInfo( pci )

	~CClusNetIFInfo( void )
	{
		Close();

	} //*** ~CClusNetIFInfo()

	// Operator = is not allowed
	CClusNetIFInfo & operator=( IN const CClusNetIFInfo & rnii )
	{
		ATLASSERT( FALSE );
		return *this;

	} //*** operator=()

	// Reset the data back to default values
	void Reset( IN CClusterInfo * pci, IN LPCTSTR pszName = NULL )
	{
		Close();
		CClusterObject::Reset( pci, pszName, CLUADMEX_OT_NETINTERFACE );

	} //*** Reset()

protected:
	//
	// Properties of a network interface.
	//

	HNETINTERFACE m_hNetInterface;

public:
	//
	// Accessor functions for network properties
	//

	HNETINTERFACE Hnetinterface( void ) const { return m_hNetInterface; }

	// Return the list of extensions for network interfaces
	const std::list< CString > * PlstrAdminExtensions( void ) const
	{
		ATLASSERT( Pci() != NULL );
		return Pci()->PlstrNetInterfacesAdminExtensions();

	} //*** PlstrAdminExtensions()

public:
	//
	// Operations.
	//

	// Open the object
	DWORD ScOpen( void )
	{
		ATLASSERT( m_pci != NULL );
		ATLASSERT( m_pci->Hcluster() != NULL );
		ATLASSERT( m_hNetInterface == NULL );
		ATLASSERT( m_strName.GetLength() > 0 );

		DWORD sc = ERROR_SUCCESS;

		//
		// Open a handle to the object.
		//
		m_hNetInterface = OpenClusterNetInterface( m_pci->Hcluster(), m_strName );
		if ( m_hNetInterface == NULL )
		{
			sc = GetLastError();
		} // if:  error opening the object

		return sc;

	} //*** ScOpen()

	// Copy another object into this one.
	DWORD ScCopy( IN const CClusNetIFInfo & rnii )
	{
		ATLASSERT( rnii.m_pci != NULL );

		DWORD sc = ERROR_SUCCESS;

		Close();
		CClusterObject::Copy( rnii );

		//
		// Initialize the object.
		//
		if ( rnii.m_hNetInterface != NULL )
		{
			sc = ScOpen();
		} // if:  source object had the object open

		return sc;

	} //*** ScCopy()

	// Close the object
	void Close( void )
	{
		if ( m_hNetInterface != NULL )
		{
			CloseClusterNetInterface( m_hNetInterface );
		} // if:  network interface is open
		m_hNetInterface = NULL;
		m_bQueried = FALSE;
		m_bCreated = FALSE;

	} //*** Close()

}; //*** class CClusNetIFInfo

/////////////////////////////////////////////////////////////////////////////
// Global Template Functions
/////////////////////////////////////////////////////////////////////////////

// Delete all list items from a pointer list
template < class ListT, class ObjT >
void DeleteListItems( ListT * ppl )
{
	ListT::iterator it;
	for ( it = ppl->begin() ; it != ppl->end() ; it++ )
	{
		ObjT * pco = *it;
		delete pco;
	} // for:  each item in the list

} //*** DeleteListItems< ListT, ObjT >()

// Retrieve an object from a list by its name
template < class ObjT >
ObjT PobjFromName( std::list< ObjT > * pList, IN LPCTSTR pszName )
{
	ATLASSERT( pList != NULL );
	ATLASSERT( pszName != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< ObjT >::iterator itCurrent = pList->begin();
	std::list< ObjT >::iterator itLast = pList->end();

	//
	// Loop through the list looking for the object with the specified name.
	//
	while ( itCurrent != itLast )
	{
		if ( (*itCurrent)->RstrName() == pszName )
		{
			return *itCurrent;
		} // if:  found a match
		itCurrent++;
	} // while:  more items in the list

	return NULL;

} //*** PobjFromName< ObjT >()

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUSOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.cpp
//
//	Abstract:
//		Implementation of the CDialogHelp class.
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagDlgHelp(_T("Help"), _T("DLG HELP"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDialogHelp, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CDialogHelp
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pmap		[IN] Map array mapping control IDs to help IDs.
//		dwMask		[IN] Mask to use for the low word of the help ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp(IN const DWORD * pdwHelpMap, IN DWORD dwMask)
{
	ASSERT(pdwHelpMap != NULL);

	CommonConstruct();
	SetMap(pdwHelpMap);
	m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CommonConstruct
//
//	Routine Description:
//		Do common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct(void)
{
	m_pmap = NULL;
	m_dwMask = 0;
	m_nHelpID = 0;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::NHelpFromCtrlID
//
//	Routine Description:
//		Return the help ID from a control ID.
//
//	Arguments:
//		nCtrlID		[IN] ID of control to search for.
//
//	Return Value:
//		nHelpID		Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID(IN DWORD nCtrlID) const
{
	DWORD						nHelpID = 0;
	const CMapCtrlToHelpID *	pmap = Pmap();

	ASSERT(pmap != NULL);
	ASSERT(nCtrlID != 0);

	for ( ; pmap->m_nCtrlID != 0 ; pmap++)
	{
		if (pmap->m_nCtrlID == nCtrlID)
		{
			nHelpID = pmap->m_nHelpCtrlID;
			break;
		}  // if:  found a match
	}  // for:  each control

	Trace(g_tagDlgHelp, _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID);

	return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu(CWnd * pWnd, CPoint point)
{
	CWnd *	pwndChild;
	CPoint	ptDialog;
	DWORD	nHelpID = 0;

	ASSERT(pWnd != NULL);

	m_nHelpID = 0;

	// Convert the point into dialog coordinates.
	ptDialog = point;
	pWnd->ScreenToClient(&ptDialog);

	// Find the control the cursor is over.
	{
		DWORD	nCtrlID;

		pwndChild = pWnd->ChildWindowFromPoint(ptDialog);
		if ((pwndChild != NULL) && (pwndChild->GetStyle() & WS_VISIBLE))
		{
			nCtrlID = pwndChild->GetDlgCtrlID();
			if (nCtrlID != 0)
				nHelpID = NHelpFromCtrlID(nCtrlID);
		}  // if:  over a child window
	}  // Find the control the cursor is over

	// Display a popup menu.
	if ((nHelpID != 0) && (nHelpID != -1))
	{
		CString	strMenu;
		CMenu	menu;

		try
		{
			strMenu.LoadString(IDS_MENU_WHATS_THIS);
		}  // try
		catch (CMemoryException * pme)
		{
			pme->Delete();
			return;
		}  // catch:  CMemoryException

		if (menu.CreatePopupMenu())
		{
			if (menu.AppendMenu(MF_STRING | MF_ENABLED, ID_HELP, strMenu))
			{
				DWORD	nCmd;
				m_nHelpID = nHelpID;
				nCmd = menu.TrackPopupMenu(
					TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
					point.x,
					point.y,
					AfxGetMainWnd()
					);
				if (nCmd != 0)
					AfxGetApp()->WinHelp(m_nHelpID, HELP_CONTEXTPOPUP);
			}  // if:  menu item added successfully
			menu.DestroyMenu();
		}  // if:  popup menu created successfully
	}  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo(HELPINFO * pHelpInfo)
{
	// If this is for a control, display control-specific help.
	if ((pHelpInfo->iContextType == HELPINFO_WINDOW)
			&& (pHelpInfo->iCtrlId != 0))
	{
		DWORD	nHelpID = NHelpFromCtrlID(pHelpInfo->iCtrlId);
		if (nHelpID != 0)
		{
			if (nHelpID != -1)
				AfxGetApp()->WinHelp(nHelpID, HELP_CONTEXTPOPUP);
			return TRUE;
		}  // if:  found the control in the list
	}  // if:  need help on a specific control

	// Display dialog help.
	return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		WPARAM		[IN] Passed on to base class method.
//		lParam		[IN] Help ID.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );
	return TRUE;

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      DDxDDv.cpp
//
//  Abstract:
//      Implementation of custom dialog data exchange/dialog data validation
//      routines.
//
//  Author:
//      David Potter (davidp)   September 5, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>
#include <resapi.h>
#include <StrSafe.h>
#include "DDxDDv.h"
#include "AdmCommonRes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel(LPTSTR psz);

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_Number
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      dwValue     [IN OUT] Value to set or get.
//      dwMin       [IN] Minimum value.
//      dwMax       [IN] Maximum value.
//      bSigned     [IN] TRUE = value is signed, FALSE = value is unsigned
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN OUT DWORD &          rdwValue,
    IN DWORD                dwMin,
    IN DWORD                dwMax,
    IN BOOL                 bSigned
    )
{
    HWND    hwndCtrl;
    DWORD   dwValue;

    ASSERT(pDX != NULL);
#ifdef _DEBUG
    if (bSigned)
    {
        ASSERT((LONG) dwMin < (LONG) dwMax);
    }
    else
    {
        ASSERT(dwMin < dwMax);
    }
#endif // _DEBUG

    // Get the control window handle.
    hwndCtrl = pDX->PrepareEditCtrl(nIDC);

    if (pDX->m_bSaveAndValidate)
    {
        BOOL    bTranslated;

        // Get the number from the control.
        dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);

        // If the retrival failed, it is a signed number, and the minimum
        // value is the smallest negative value possible, check the string itself.
        if (!bTranslated && bSigned && (dwMin == 0x80000000))
        {
            UINT    cch;
            TCHAR   szNumber[20];

            // See if it is the smallest negative number.
            cch = GetDlgItemText(pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof(szNumber) / sizeof(TCHAR));
            if ((cch != 0) && (_tcsncmp( szNumber, _T("-2147483648"), RTL_NUMBER_OF( szNumber ) ) == 0))
            {
                dwValue = 0x80000000;
                bTranslated = TRUE;
            }  // if:  text retrieved successfully and is highest negative number
        }  // if:  error translating number and getting signed number

        // If the retrieval failed or the specified number is
        // out of range, display an error.
        if (   !bTranslated
            || (bSigned && (((LONG) dwValue < (LONG) dwMin) || ((LONG) dwValue > (LONG) dwMax)))
            || (!bSigned && ((dwValue < dwMin) || (dwValue > dwMax)))
            )
        {
            TCHAR   szMin[32];
            TCHAR   szMax[32];
            CString strPrompt;
            HRESULT hr;

            if (bSigned)
            {
                hr = StringCchPrintf(szMin, RTL_NUMBER_OF( szMin ), _T("%d%"), dwMin);
                ASSERT( SUCCEEDED( hr ) );
                hr = StringCchPrintf(szMax, RTL_NUMBER_OF( szMax ), _T("%d%"), dwMax);
                ASSERT( SUCCEEDED( hr ) );
            }  // if:  signed number
            else
            {
                hr = StringCchPrintf(szMin, RTL_NUMBER_OF( szMin ), _T("%u%"), dwMin);
                ASSERT( SUCCEEDED( hr ) );
                hr = StringCchPrintf(szMax, RTL_NUMBER_OF( szMax ), _T("%u%"), dwMax);
                ASSERT( SUCCEEDED( hr ) );
            }  // else:  unsigned number
            AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
            AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
            strPrompt.Empty(); // exception prep
            pDX->Fail();
        }  // if:  invalid string
        else
            rdwValue = dwValue;
    }  // if:  saving data
    else
    {
        CString     strMinValue;
        CString     strMaxValue;
        UINT        cchMax;

        // Set the maximum number of characters that can be entered.
        if (bSigned)
        {
            strMinValue.Format(_T("%d"), dwMin);
            strMaxValue.Format(_T("%d"), dwMax);
        }  // if:  signed value
        else
        {
            strMinValue.Format(_T("%u"), dwMin);
            strMaxValue.Format(_T("%u"), dwMax);
        }  // else:  unsigned value
        cchMax = max(strMinValue.GetLength(), strMaxValue.GetLength());
        SendMessage(hwndCtrl, EM_LIMITTEXT, cchMax, 0);

        // Set the value into the control.
        if (bSigned)
        {
            LONG lValue = (LONG) rdwValue;
            DDX_Text(pDX, nIDC, lValue);
        }  // if:  signed value
        else
            DDX_Text(pDX, nIDC, rdwValue);
    }  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDV_RequiredText
//
//  Routine Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      nIDCLabel   [IN] Label control ID.
//      rstrValue   [IN] Value to set or get.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN int                  nIDCLabel,
    IN const CString &      rstrValue
    )
{
    ASSERT(pDX != NULL);

    if (pDX->m_bSaveAndValidate)
    {
        if (rstrValue.GetLength() == 0)
        {
            HWND        hwndLabel;
            TCHAR       szLabel[1024];
            CString     strPrompt;

            // Get the label window handle
            hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

            // Get the text of the label.
            GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

            // Remove ampersands (&) and colons (:).
            CleanupLabel(szLabel);

            // Format and display a message.
            strPrompt.FormatMessage(ADMC_IDS_REQUIRED_FIELD_EMPTY, szLabel);
            AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

            // Do this so that the control receives focus.
            (void) pDX->PrepareEditCtrl(nIDC);

            // Fail the call.
            strPrompt.Empty();  // exception prep
            pDX->Fail();
        }  // if:  field not specified
    }  // if:  saving data

}  //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDV_Path
//
//  Routine Description:
//      Validate that the path string contains valid characters.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      nIDCLabel   [IN] Label control ID.
//      rstrValue   [IN] Path to validate.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_Path(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN int                  nIDCLabel,
    IN const CString &      rstrValue
    )
{
    ASSERT(pDX != NULL);

    if (pDX->m_bSaveAndValidate)
    {
        if (!ResUtilIsPathValid(rstrValue))
        {
            HWND        hwndLabel;
            TCHAR       szLabel[1024];
            CString     strPrompt;

            // Get the label window handle
            hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

            // Get the text of the label.
            GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

            // Remove ampersands (&) and colons (:).
            CleanupLabel(szLabel);

            // Format and display a message.
            strPrompt.FormatMessage(ADMC_IDS_PATH_IS_INVALID, szLabel);
            AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

            // Do this so that the control receives focus.
            (void) pDX->PrepareEditCtrl(nIDC);

            // Fail the call.
            strPrompt.Empty();  // exception prep
            pDX->Fail();
        }  // if:  path is invalid
    }  // if:  saving data

}  //*** DDV_Path()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupLabel
//
//  Routine Description:
//      Prepare a label read from a dialog to be used as a string in a
//      message by removing ampersands (&) and colons (:).
//
//  Arguments:
//      pszLabel    [IN OUT] Label to be cleaned up.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupLabel(LPTSTR pszLabel)
{
    LPTSTR  pIn, pOut;
    LANGID  langid;
    WORD    primarylangid;
    BOOL    bFELanguage;

    // Get the language ID.
    langid = GetUserDefaultLangID();
    primarylangid = (WORD) PRIMARYLANGID(langid);
    bFELanguage = ((primarylangid == LANG_JAPANESE)
                    || (primarylangid == LANG_CHINESE)
                    || (primarylangid == LANG_KOREAN));

    //
    // copy the name sans '&' and ':' chars
    //

    pIn = pOut = pszLabel;
    do
    {
        //
        // strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
        //
        if (   bFELanguage
            && (pIn[0] == _T('('))
            && (pIn[1] == _T('&'))
            && (pIn[2] != _T('\0'))
            && (pIn[3] == _T(')')))
        {
            pIn += 3;
        }
        else if ((*pIn != _T('&')) && (*pIn != _T(':')))
            *pOut++ = *pIn;
    } while (*pIn++ != _T('\0')) ;

}  //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.h
//
//	Abstract:
//		Definition of the CDialogHelp class.
//
//	Implementation File:
//		DlgHelp.cpp
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#define _DLGHELP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
	DWORD	m_nCtrlID;
	DWORD	m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
	DECLARE_DYNAMIC(CDialogHelp)

// Construction
public:
	CDialogHelp(void) { CommonConstruct(); }
	CDialogHelp(const DWORD * pdwHelpMap, DWORD dwMask);

	void CommonConstruct(void);

// Attributes
protected:
	const CMapCtrlToHelpID *	m_pmap;
	DWORD						m_dwMask;
	DWORD						m_nHelpID;

public:
	const CMapCtrlToHelpID *	Pmap(void) const	{ return m_pmap; }
	DWORD						DwMask(void) const	{ return m_dwMask; }
	DWORD						NHelpID(void) const	{ return m_nHelpID; }

	DWORD						NHelpFromCtrlID(IN DWORD nCtrlID) const;
	void						SetMap(IN const DWORD * pdwHelpMap)
	{
		ASSERT(pdwHelpMap != NULL);
		m_pmap = (const CMapCtrlToHelpID *) pdwHelpMap;
	}

// Operations
public:
	void		SetHelpMask(IN DWORD dwMask)	{ ASSERT(dwMask != 0); m_dwMask = dwMask; }

	void		OnContextMenu(CWnd * pWnd, CPoint point);
	BOOL		OnHelpInfo(HELPINFO * pHelpInfo);
	LRESULT		OnCommandHelp(WPARAM wParam, LPARAM lParam);

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // _DLGHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\excoper.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ExcOper.cpp
//
//  Abstract:
//      Implementation of exception classes.
//
//  Author:
//      David Potter (davidp)   May 20, 1996
//
//  Revision History:
//
//  Notes:
//      TraceTag.h and resource.h are pulled from the project directory.
//
//      stdafx.h must disable some W4 warnings.
//
//      TraceTag.h must define TraceError.
//
//      resource.h must define IDS_ERROR_MSG_ID, and the string must be
//      defined something like "\n\nError ID: %d (%08.8x)." in the resource file.
//
//      IDP_NO_ERROR_AVAILABLE must defined as a string for displaying when
//      no error code is available.
//
//      EXC_AppMessageBox(LPCTSTR...) and EXC_AppMessageBox(UINT...) must be
//      defined and implemented.
//
//      EXC_GetResourceInstance must be defined and implemented to return the
//      resource instance handle of the application or DLL.
//
/////////////////////////////////////////////////////////////////////////////

#include <StrSafe.h>
#include <string.h>
#include "ExcOper.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CException
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CException::ReportError
//
//  Routine Description:
//      Report an error from the exception.  Overriding to get a bigger
//      error message buffer.
//
//  Arguments:
//      nType       [IN] Type of message box.
//      nError      [IN] ID of a mesage to display if exception has no message.
//
//  Return Value:
//      Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CException::ReportError( UINT nType /* = MB_OK */, UINT nError /* = 0 */ )
{
    TCHAR   szErrorMessage[128];
    int     nDisposition;
    UINT    nHelpContext;

    if ( GetErrorMessage(szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
    {
        nDisposition = EXC_AppMessageBox( szErrorMessage, nType, nHelpContext );
    } // if:  error message retrieved successfully
    else
    {
        if ( nError == 0 )
        {
            nError = IDP_NO_ERROR_AVAILABLE;
        } // if:  no error code
        nDisposition = EXC_AppMessageBox( nError, nType, nHelpContext );
    } // else:  error retrieving error message
    return nDisposition;

} //*** CException::ReportError()

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// class CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC(CExceptionWithOper, CException)
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExceptionWithOper::ReportError
//
//  Routine Description:
//      Report an error from the exception.  Overriding to get a bigger
//      error message buffer.
//
//  Arguments:
//      nType       [IN] Type of message box.
//      nError      [IN] ID of a mesage to display if exception has no message.
//
//  Return Value:
//      Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
    UINT nType /* = MB_OK */,
    UINT nError /* = 0 */
    )
{
    TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
    int     nDisposition;
    UINT    nHelpContext;

    if ( GetErrorMessage( szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
    {
        nDisposition = EXC_AppMessageBox( szErrorMessage, nType, nHelpContext );
    } // if:  error message retrieved successfully
    else
    {
        if ( nError == 0 )
        {
            nError = IDP_NO_ERROR_AVAILABLE;
        } // if:  no error code
        nDisposition = EXC_AppMessageBox( nError, nType, nHelpContext );
    } // else:  error retrieving error message
    return nDisposition;

} //*** CExceptionWithOper::ReportError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExceptionWithOper::ReportError
//
//  Routine Description:
//      Report an error from the exception.  This method should be used from
//      all threads except the main thread.
//
//  Arguments:
//      pfnMsgBox   [IN] Message box function pointer.
//      dwParam     [IN] Parameter to pass to the message box function.
//      nType       [IN] Type of message box.
//      nError      [IN] ID of a mesage to display if exception has no message.
//
//  Return Value:
//      Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
    PFNMSGBOX   pfnMsgBox,
    DWORD       dwParam,
    UINT        nType /* = MB_OK */,
    UINT        nError /* = 0 */
    )
{
    TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
    int     nDisposition;
    UINT    nHelpContext;

    ASSERT( pfnMsgBox != NULL );

    if ( GetErrorMessage( szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
    {
        nDisposition = (*pfnMsgBox)( dwParam, szErrorMessage, nType, nHelpContext );
    } // if:  error message retrieved successfully
    else
    {
        if ( nError == 0 )
        {
            nError = IDP_NO_ERROR_AVAILABLE;
        } // if:  no error code
        CString strMsg;
        strMsg.LoadString( nError );
        nDisposition = (*pfnMsgBox)( dwParam, strMsg, nType, nHelpContext );
    } // else:  error retrieving error message
    return nDisposition;

}  //*** CExceptionWithOper::ReportError( pfnMsgBox )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExceptionWithOper::ReportError
//
//  Routine Description:
//      Report an error from the exception.  This method should be used from
//      all threads except the main thread.
//
//  Arguments:
//      hwndParent  [IN] Parent window.
//      nType       [IN] Type of message box.
//      nError      [IN] ID of a mesage to display if exception has no message.
//
//  Return Value:
//      Return value from MessageBox.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CExceptionWithOper::ReportError(
    HWND    hwndParent,
    UINT    nType /* = MB_OK */,
    UINT    nError /* = 0 */
    )
{
    ASSERT(hwndParent != NULL);

    TCHAR   szErrorMessage[EXCEPT_MAX_OPER_ARG_LENGTH * 3];
    int     nDisposition;
    UINT    nHelpContext;

    if ( GetErrorMessage( szErrorMessage, sizeof( szErrorMessage ) / sizeof( TCHAR ), &nHelpContext ) )
    {
        nDisposition = EXC_AppMessageBox( hwndParent, szErrorMessage, nType, nHelpContext );
    } // if:  error message retrieved successfully
    else
    {
        if ( nError == 0 )
        {
            nError = IDP_NO_ERROR_AVAILABLE;
        } // if:  no error code
        CString strMsg;
        strMsg.LoadString( nError );
        nDisposition = EXC_AppMessageBox( hwndParent, szErrorMessage, nType, nHelpContext );
    } // else:  error retrieving error message
    return nDisposition;

} //*** CExceptionWithOper::ReportError( pfnMsgBox )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExceptionWithOper::SetOperation
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idsOperation    [IN] String ID for operation occurring during exception.
//      pszOperArg1     [IN] 1st argument to operation string.
//      pszOperArg2     [IN] 2nd argument to operation string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::SetOperation(
    IN UINT         idsOperation,
    IN LPCTSTR      pszOperArg1,
    IN LPCTSTR      pszOperArg2
    )
{
    m_idsOperation = idsOperation;

    if ( pszOperArg1 == NULL )
    {
        m_szOperArg1[0] = _T('\0');
    } // if:  first argument not specified
    else
    {
        ::_tcsncpy( m_szOperArg1, pszOperArg1, (sizeof( m_szOperArg1 ) / sizeof( TCHAR )) - 1 );
        m_szOperArg1[(sizeof( m_szOperArg1 ) / sizeof( TCHAR ))- 1] = _T('\0');
    }  // else:  first argument specified

    if ( pszOperArg2 == NULL )
    {
        m_szOperArg2[0] = _T('\0');
    } // if:  second argument not specified
    else
    {
        ::_tcsncpy( m_szOperArg2, pszOperArg2, (sizeof( m_szOperArg2 ) / sizeof( TCHAR )) - 1 );
        m_szOperArg2[(sizeof( m_szOperArg2 ) / sizeof( TCHAR )) - 1] = _T('\0');
    }  // else:  second argument specified

} //*** CExceptionWithOper::SetOperation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExceptionWithOper::FormatWithOperation
//
//  Routine Description:
//      Get the error message represented by the exception.
//
//  Arguments:
//      lpszError       [OUT] String in which to return the error message.
//      nMaxError       [IN] Maximum length of the output string.
//      pszMsg          [IN] Message to format with the operation string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExceptionWithOper::FormatWithOperation(
    OUT LPTSTR  lpszError,
    IN UINT     nMaxError,
    IN LPCTSTR  pszMsg
    )
{
    DWORD       dwResult;
    TCHAR       szOperation[EXCEPT_MAX_OPER_ARG_LENGTH];
    TCHAR       szFmtOperation[EXCEPT_MAX_OPER_ARG_LENGTH * 3];

    ASSERT( lpszError != NULL );
    ASSERT( nMaxError > 0 );

    // Format the operation string.
    if ( m_idsOperation )
    {
        void *      rgpvArgs[2] = { m_szOperArg1, m_szOperArg2 };

        // Load the operation string.
        dwResult = ::LoadString( EXC_GetResourceInstance(), m_idsOperation, szOperation, RTL_NUMBER_OF( szOperation ) );
        ASSERT( dwResult != 0 );

        // Format the operation string.
        ::FormatMessage(
                    FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    szOperation,
                    0,
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                    szFmtOperation,
                    RTL_NUMBER_OF( szFmtOperation ),
                    (va_list *) rgpvArgs
                    );
        szFmtOperation[ RTL_NUMBER_OF( szFmtOperation ) - 1 ] = _T('\0');

        // Format the final error message.
        if ( pszMsg != NULL )
        {
            dwResult = StringCchPrintf( lpszError, nMaxError, _T("%s\n\n%s"), szFmtOperation, pszMsg );
            lpszError[ nMaxError - 1 ] = _T('\0');
        } // if:  additional message specified
        else
        {
            dwResult = StringCchCopyN( lpszError, nMaxError, szFmtOperation, RTL_NUMBER_OF( szFmtOperation ) );
        } // else:  no additional message specified
    }  // if:  operation string specified
    else
    {
        if ( pszMsg != NULL )
        {
            dwResult = StringCchCopy( lpszError, nMaxError, pszMsg );
        }  // if:  additional message specified
        else
        {
            lpszError[0] = _T('\0');
        } // if:  no additional message specified
    }  // else:  no operation string specified

} //*** CExceptionWithOper::FormatWithOperation()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// class CNTException
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CNTException, CExceptionWithOper )
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNTException::FormatErrorMessage
//
//  Routine Description:
//      Format the error message represented by the exception.
//
//  Arguments:
//      lpszError       [OUT] String in which to return the error message.
//      nMaxError       [IN] Maximum length of the output string.
//      pnHelpContext   [OUT] Help context for the error message.
//      bIncludeID      [IN] Include the ID in the message.
//
//  Return Value:
//      TRUE        Message available.
//      FALSE       No message available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNTException::FormatErrorMessage(
    LPTSTR  lpszError,
    UINT    nMaxError,
    PUINT   pnHelpContext,
    BOOL    bIncludeID
    )
{
    DWORD       dwResult;
    TCHAR       szNtMsg[1024];

    UNREFERENCED_PARAMETER( pnHelpContext );

    // Format the NT status code.
    ::FormatErrorMessage( m_sc, szNtMsg, sizeof( szNtMsg ) / sizeof( TCHAR ) );

    // Format the message with the operation string.
    FormatWithOperation( lpszError, nMaxError, szNtMsg );

    // Add the error ID.
    if ( bIncludeID )
    {
        UINT    nMsgLength = static_cast< UINT >( _tcslen( lpszError ) );
        TCHAR   szErrorFmt[EXCEPT_MAX_OPER_ARG_LENGTH];

        if ( nMsgLength - 1 < nMaxError )
        {
            dwResult = ::LoadString( EXC_GetResourceInstance(), IDS_ERROR_MSG_ID, szErrorFmt, RTL_NUMBER_OF( szErrorFmt ) );
            ASSERT( dwResult != 0 );
            dwResult = StringCchPrintf( &lpszError[ nMsgLength ], nMaxError - nMsgLength, szErrorFmt, m_sc, m_sc );
        }  // if:  there is room for the error ID
    }  // if:  error ID should be included

    return TRUE;

} //*** CNTException::FormatErrorMessage()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

static CNTException         gs_nte( ERROR_SUCCESS, NULL, NULL, NULL, FALSE );
static CExceptionWithOper   gs_ewo( NULL, NULL, NULL, FALSE );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ThrowStaticException
//
//  Purpose:
//      Throw the static NT Exception.
//
//  Arguments:
//      sc              [IN] NT status code.
//      idsOperation    [IN] String ID for operation occurring during exception.
//      pszOperArg1     [IN] 1st argument to operation string.
//      pszOperArg2     [IN] 2nd argument to operation string.
//
//  Returns:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
    IN SC           sc,
    IN UINT         idsOperation,
    IN LPCTSTR      pszOperArg1,
    IN LPCTSTR      pszOperArg2
    )
{
    gs_nte.SetOperation( sc, idsOperation, pszOperArg1, pszOperArg2 );
    TraceError( gs_nte );
    throw &gs_nte;

} //*** ThrowStaticException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ThrowStaticException
//
//  Purpose:
//      Throw the static Cluster Administrator Exception.
//
//  Arguments:
//      idsOperation    [IN] String ID for operation occurring during exception.
//      pszOperArg1     [IN] 1st argument to operation string.
//      pszOperArg2     [IN] 2nd argument to operation string.
//
//  Returns:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ThrowStaticException(
    IN UINT         idsOperation,
    IN LPCTSTR      pszOperArg1,
    IN LPCTSTR      pszOperArg2
    )
{
    gs_ewo.SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
    TraceError( gs_ewo );
    throw &gs_ewo;

} //*** ThrowStaticException()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatErrorMessage
//
//  Routine Description:
//      Format the error message represented by the exception.
//
//  Arguments:
//      sc              [IN] Status code.
//      lpszError       [OUT] String in which to return the error message.
//      nMaxError       [IN] Maximum length of the output string.
//
//  Return Value:
//      TRUE        Message available.
//      FALSE       No message available.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL FormatErrorMessage(
    DWORD   sc,
    LPTSTR  lpszError,
    UINT    nMaxError
    )
{
    DWORD       _cch;

    // Format the NT status code from the system.
    _cch = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    sc,
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                    lpszError,
                    nMaxError,
                    0
                    );
    if ( _cch == 0 )
    {
        Trace( g_tagError, _T("Error %d getting message from system for error code %d"), GetLastError(), sc );

        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        GetModuleHandle( _T("NTDLL.DLL") ),
                        sc,
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                        lpszError,
                        nMaxError,
                        0
                        );
        if ( _cch == 0 )
        {

#ifdef _DEBUG

            DWORD   _sc = GetLastError();
                        _sc=_sc;
            Trace( g_tagError, _T("Error %d getting message from NTDLL.DLL for error code %d"), _sc, sc );

#endif

            lpszError[0] = _T('\0');

        }  // if:  error formatting status code from NTDLL
    }  // if:  error formatting status code from system

    return TRUE;

} //*** FormatErrorMessage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\quorumutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2001 Microsoft Corporation
//
//  Module Name:
//      QuorumUtils.h
//
//  Description:
//      Header file for the utility functions to retrieve, split, and format
//      quorum path.
//
//  Maintained By:
//      George Potts    (GPotts)    22-OCT-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <windows.h>
#include <cluster.h>
#include "cluswrap.h"

DWORD SplitRootPath(
      HCLUSTER  hClusterIn
    , WCHAR *   pszPartitionNameOut
    , DWORD *   pcchPartitionInout
    , WCHAR *   pszRootPathOut
    , DWORD *   pcchRootPathInout
    );

DWORD ConstructQuorumPath(
      HRESOURCE hResourceIn
    , const WCHAR * pszRootPathIn
    , WCHAR *       pszQuorumPathOut
    , DWORD *       pcchQuorumPathInout
    );

DWORD TrimLeft(
      const WCHAR * pszTargetIn
    , const WCHAR * pszCharsIn
    , WCHAR *       pszTrimmedOut
    );

DWORD TrimRight(
      const WCHAR * pszTargetIn
    , const WCHAR * pszCharsIn
    , WCHAR *       pszTrimmedOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\excoper.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ExcOper.h
//
//  Implementation File:
//      ExcOper.cpp
//
//  Description:
//      Definition of the exception classes.
//
//  Author:
//      David Potter (davidp)   May 20, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXCOPER_H_
#define _EXCOPER_H_

/////////////////////////////////////////////////////////////////////////////
//  Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExceptionWithOper;
class CNTException;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef DWORD SC;

#define EXCEPT_MAX_OPER_ARG_LENGTH  260

/////////////////////////////////////////////////////////////////////////////
// Wire in MFC if this is an MFC image.
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__

#define IDP_NO_ERROR_AVAILABLE AFX_IDP_NO_ERROR_AVAILABLE

inline int EXC_AppMessageBox( LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 )
{
    return AfxMessageBox( lpszText, nType, nIDHelp );
}

inline int EXC_AppMessageBox( UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1 )
{
    return AfxMessageBox( nIDPrompt, nType, nIDHelp );
}

inline int EXC_AppMessageBox( HWND hwndParent, LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 )
{
    return AfxMessageBox( lpszText, nType, nIDHelp );
}

inline int EXC_AppMessageBox( HWND hwndParent, UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1 )
{
    return AfxMessageBox( nIDPrompt, nType, nIDHelp );
}

inline HINSTANCE EXC_GetResourceInstance( void )
{
    return AfxGetApp()->m_hInstance;
}

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// class CException
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFX_H__

class CException
{
public:
    BOOL m_bAutoDelete;
#if DBG || defined( _DEBUG )
protected:
    BOOL m_bReadyForDelete;
public:
#endif // DBG || defined( _DEBUG )

    CException( void )
    {
        m_bAutoDelete = TRUE;
#if DBG || defined( _DEBUG )
        m_bReadyForDelete = FALSE;
#endif // DBG || defined( _DEBUG )
    }

    CException( BOOL bAutoDelete )
    {
        m_bAutoDelete = bAutoDelete;
#if DBG || defined( _DEBUG )
        m_bReadyForDelete = FALSE;
#endif // DBG || defined( _DEBUG )
    }

    virtual ~CException( void )
    {
    }

    void Delete( void ) // use to delete exception in 'catch' block
    {
        // delete exception if it is auto-deleting
        if ( m_bAutoDelete > 0 )
        {
#if DBG || defined( _DEBUG )
            m_bReadyForDelete = TRUE;
#endif // DBG || defined( _DEBUG )
            delete this;
        }
    }

    virtual BOOL GetErrorMessage(
        LPTSTR lpszError,
        UINT nMaxError,
        PUINT pnHelpContext = NULL
        )
    {
        if ( pnHelpContext != NULL )
        {
            *pnHelpContext = 0;
        }

        if ( nMaxError != 0 && lpszError != NULL )
        {
            *lpszError = '\0';
        }

        return FALSE;
    }

    virtual int ReportError( UINT nType = MB_OK, UINT nError = 0 );

#if DBG || defined( _DEBUG )
    void PASCAL operator delete( void * pbData )
    {
        // check for proper exception object deletion
        CException * pException = (CException *) pbData;

        // use: pException->Delete(), do not use: delete pException
        ASSERT( pException->m_bReadyForDelete );
        ASSERT( pException->m_bAutoDelete > 0 );

        // avoid crash when assert above is ignored
        if ( pException->m_bReadyForDelete && pException->m_bAutoDelete > 0 )
        {
            ::operator delete( pbData );
        }
    }
#endif // DBG || defined( _DEBUG )

}; // class CException

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// class CExceptionWithOper
/////////////////////////////////////////////////////////////////////////////

typedef int (WINAPI *PFNMSGBOX)( DWORD dwParam, LPCTSTR lpszText, UINT nType, UINT nIDHelp );

class CExceptionWithOper : public CException
{
#ifdef __AFX_H__
    // abstract class for dynamic type checking
    DECLARE_DYNAMIC( CExceptionWithOper )
#endif // __AFX_H__

public:
// Constructors
    CExceptionWithOper(
        IN UINT     idsOperation,
        IN LPCTSTR  pszOperArg1     = NULL,
        IN LPCTSTR  pszOperArg2     = NULL
        )
    {
        SetOperation(idsOperation, pszOperArg1, pszOperArg2);

    } // CExceptionWithOper()

    CExceptionWithOper(
        IN UINT     idsOperation,
        IN LPCTSTR  pszOperArg1,
        IN LPCTSTR  pszOperArg2,
        IN BOOL     bAutoDelete
        )
        : CException( bAutoDelete )
    {
        SetOperation( idsOperation, pszOperArg1, pszOperArg2 );

    } // CExceptionWithOper(bAutoDelete)

// Operations
public:
    virtual BOOL    GetErrorMessage(
                        LPTSTR  lpszError,
                        UINT    nMaxError,
                        PUINT   pnHelpContext = NULL
                        )
    {
        UNREFERENCED_PARAMETER( pnHelpContext );

        // Format the operation string.
        FormatWithOperation( lpszError, nMaxError, NULL );

        return TRUE;

    } // GetErrorMessage()
    virtual int     ReportError(
                        UINT        nType   = MB_OK,
                        UINT        nError  = 0
                        );

    virtual int     ReportError(
                        HWND        hwndParent,
                        UINT        nType   = MB_OK,
                        UINT        nError  = 0
                        );

    virtual int     ReportError(
                        PFNMSGBOX   pfnMsgBox,
                        DWORD       dwParam,
                        UINT        nType   = MB_OK,
                        UINT        nError  = 0
                        );

    void            SetOperation(
                        IN UINT     idsOperation,
                        IN LPCTSTR  pszOperArg1 = NULL,
                        IN LPCTSTR  pszOperArg2 = NULL
                        );

    void            SetOperationIfEmpty(
                        IN UINT     idsOperation,
                        IN LPCTSTR  pszOperArg1 = NULL,
                        IN LPCTSTR  pszOperArg2 = NULL
                        )
    {
        if ( m_idsOperation == 0 )
        {
            SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
        } // if:  exception is empty

    } //*** SetOperationIfEmpty()

    void            FormatWithOperation(
                        OUT LPTSTR  lpszError,
                        IN UINT     nMaxError,
                        IN LPCTSTR  pszMsg
                        );

// Implementation
protected:
    UINT            m_idsOperation;
    TCHAR           m_szOperArg1[EXCEPT_MAX_OPER_ARG_LENGTH];
    TCHAR           m_szOperArg2[EXCEPT_MAX_OPER_ARG_LENGTH];

public:
    UINT            IdsOperation( void ) const  { return m_idsOperation; }
    LPTSTR          PszOperArg1( void )         { return m_szOperArg1; }
    LPTSTR          PszOperArg2( void )         { return m_szOperArg2; }

};  //*** class CExceptionWithOper

/////////////////////////////////////////////////////////////////////////////
// class CNTException
/////////////////////////////////////////////////////////////////////////////

class CNTException : public CExceptionWithOper
{
#ifdef __AFX_H__
    // abstract class for dynamic type checking
    DECLARE_DYNAMIC( CNTException )
#endif // __AFX_H__

public:
// Constructors
    CNTException(
        IN SC       sc,
        IN UINT     idsOperation    = NULL,
        IN LPCTSTR  pszOperArg1     = NULL,
        IN LPCTSTR  pszOperArg2     = NULL
        )
        : CExceptionWithOper( idsOperation, pszOperArg1, pszOperArg2 )
        , m_sc( sc )
    {
    } // CNTException()

    CNTException(
        IN SC       sc,
        IN UINT     idsOperation,
        IN LPCTSTR  pszOperArg1,
        IN LPCTSTR  pszOperArg2,
        IN BOOL     bAutoDelete
        )
        : CExceptionWithOper( idsOperation, pszOperArg1, pszOperArg2, bAutoDelete )
        , m_sc( sc )
    {
    } // CNTException( bAutoDelete )

// Operations
public:
    virtual BOOL    GetErrorMessage(
                        LPTSTR  lpszError,
                        UINT    nMaxError,
                        PUINT   pnHelpContext = NULL
                        )
    {
        return FormatErrorMessage( lpszError, nMaxError, pnHelpContext, TRUE /*bIncludeID*/ );

    } //*** GetErrorMessage()

    BOOL            FormatErrorMessage(
                        LPTSTR  lpszError,
                        UINT    nMaxError,
                        PUINT   pnHelpContext = NULL,
                        BOOL    bIncludeID = FALSE
                        );

    void            SetOperation(
                        IN SC       sc,
                        IN UINT     idsOperation,
                        IN LPCTSTR  pszOperArg1 = NULL,
                        IN LPCTSTR  pszOperArg2 = NULL
                        )
    {
        m_sc = sc;
        CExceptionWithOper::SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
    } //*** SetOperation()

    void            SetOperationIfEmpty(
                        IN SC       sc,
                        IN UINT     idsOperation,
                        IN LPCTSTR  pszOperArg1 = NULL,
                        IN LPCTSTR  pszOperArg2 = NULL
                        )
    {
        if ( (m_sc == ERROR_SUCCESS) && (m_idsOperation == 0) )
        {
            m_sc = sc;
            CExceptionWithOper::SetOperation( idsOperation, pszOperArg1, pszOperArg2 );
        } // if:  exception is empty
    } //*** SetOperationIfEmpty()

// Implementation
protected:
    SC              m_sc;

public:
    SC              Sc( void )      { return m_sc; }

};  //*** class CNTException

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void ThrowStaticException(
    IN UINT         idsOperation    = NULL,
    IN LPCTSTR      pszOperArg1     = NULL,
    IN LPCTSTR      pszOperArg2     = NULL
    );
void ThrowStaticException(
    IN SC           sc,
    IN UINT         idsOperation    = NULL,
    IN LPCTSTR      pszOperArg1     = NULL,
    IN LPCTSTR      pszOperArg2     = NULL
    );
BOOL FormatErrorMessage(
    DWORD   sc,
    LPTSTR  lpszError,
    UINT    nMaxError
    );

/////////////////////////////////////////////////////////////////////////////

#endif // _EXCOPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Abstract:
//		Definitions of routines for extension registration.
//
//	Implementation File:
//		RegExt.cpp
//
//	Author:
//		David Potter (davidp)	April 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGEXT_H_
#define _REGEXT_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _REGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\dlgitemutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      DlgItemUtils.h
//
//  Abstract:
//      Definition of the CDlgItemUtils class.
//
//  Author:
//      David Potter (davidp)   February 10, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DLGITEMUTILS_H_
#define __DLGITEMUTILS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDlgItemUtils;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  class CDlgItemUtils
//
//  Purpose:
//      Utilities for manipulating dialog items.
//
//  Inheritance:
//      CDlgItemUtils
//
/////////////////////////////////////////////////////////////////////////////

class CDlgItemUtils
{
public:
    //
    // Construction
    //

public:
    //
    // CDlgItemUtils public methods.
    //

    // Set a control to be read-only
    static BOOL SetDlgItemReadOnly( HWND hwndCtrl )
    {
        ATLASSERT( hwndCtrl != NULL );
        ATLASSERT( IsWindow( hwndCtrl ) );

        TCHAR   szWindowClass[256];
        BOOL    fReturn = FALSE;

        //
        // Get the class of the control
        //
        ::GetClassName( hwndCtrl, szWindowClass, ( RTL_NUMBER_OF( szWindowClass ) ) - 1 );

        //
        // If it is an edit control or an IP Address control we can handle it.
        //
        if ( _tcsncmp( szWindowClass, _T("Edit"), RTL_NUMBER_OF( szWindowClass ) ) == 0 )
        {
            fReturn = static_cast< BOOL >( ::SendMessage( hwndCtrl, EM_SETREADONLY, TRUE, 0 ) );
        } // if:  edit control

        if ( _tcsncmp( szWindowClass, WC_IPADDRESS, RTL_NUMBER_OF( szWindowClass ) ) == 0 )
        {
            fReturn = static_cast< BOOL >( ::EnumChildWindows( hwndCtrl, s_SetEditReadOnly, NULL ) );
        } // if:  IP Address control

        //
        // If we didn't handle it, it is an error.
        //

        return fReturn;

    } //*** SetDlgItemReadOnly()

// Implementation
protected:

    // Static method to set an edit control read only as a callback
    static BOOL CALLBACK s_SetEditReadOnly( HWND hwnd, LPARAM lParam )
    {
        return static_cast< BOOL >( ::SendMessage( hwnd, EM_SETREADONLY, TRUE, 0 ) );

    } //*** s_SetEditReadOnly()

}; //*** class CDlgItemUtils

/////////////////////////////////////////////////////////////////////////////

#endif // __DLGITEMUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      RegExt.cpp
//
//  Abstract:
//      Implementation of routines for extension registration.
//
//  Author:
//      David Potter (davidp)   April 9, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

//#include <stdafx.h>
#include <ole2.h>
#include <StrSafe.h>
#include "clstrcmp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    );
static HRESULT RegisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    );
static HRESULT UnregisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    );
static HRESULT UnregisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    );
static DWORD ReadValue(
    IN HKEY         hkey,
    IN LPCWSTR      pwszValueName,
    OUT LPWSTR *    ppwszValue,
    OUT size_t *    pcchSize
    );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminClusterExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends the cluster object.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the cluster registry key.
    hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
    if (hkey == NULL)
        hr = GetLastError();
    else
    {
        // Register the extension.
        hr = RegisterAnyCluAdminExtension(hkey, pClsid);

        ClusterRegCloseKey(hkey);
    }  // else:  GetClusterKey succeeded

    return hr;

}  //*** RegisterCluAdminClusterExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNodesExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all nodes.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

    return hr;

}  //*** RegisterCluAdminAllNodesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllGroupsExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all groups.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

    return hr;

}  //*** RegisterCluAdminAllGroupsExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllResourcesExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all resources.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

    return hr;

}  //*** RegisterCluAdminAllResourcesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllResourceTypesExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all resource types.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

    return hr;

}  //*** RegisterCluAdminAllResourceTypesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNetworksExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all networks.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

    return hr;

}  //*** RegisterCluAdminAllNetworksExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNetInterfacesExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all network interfaces.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension(hCluster, L"NetworkInterfaces", pClsid);

    return hr;

}  //*** RegisterCluAdminAllNetInterfacesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminResourceTypeExtension
//
//  Routine Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends resources of a specific type, or the resource type
//      itself.
//
//  Arguments:
//      hCluster            [IN] Handle to the cluster to modify.
//      pwszResourceType    [IN] Resource type name.
//      pClsid              [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszResourceType,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the resource type registry key.
    hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
    if (hkey == NULL)
        hr = GetLastError();
    else
    {
        // Register the extension.
        hr = RegisterAnyCluAdminExtension(hkey, pClsid);

        ClusterRegCloseKey(hkey);
    }  // else:  GetClusterResourceTypeKey succeeded

    return hr;

}  //*** RegisterCluAdminResourceTypeExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminClusterExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends the cluster object.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the cluster registry key.
    hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
    if (hkey == NULL)
        hr = GetLastError();
    else
    {
        // Unregister the extension.
        hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

        ClusterRegCloseKey(hkey);
    }  // else:  GetClusterKey succeeded

    return hr;

}  //*** UnregisterCluAdminClusterExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNodesExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all nodes.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

    return hr;

}  //*** UnregisterCluAdminAllNodesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllGroupsExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all groups.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

    return hr;

}  //*** UnregisterCluAdminAllGroupsExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllResourcesExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all resources.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

    return hr;

}  //*** UnregisterCluAdminAllResourcesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllResourceTypesExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all resource types.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

    return hr;

}  //*** UnregisterCluAdminAllResourceTypesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNetworksExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all networks.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

    return hr;

}  //*** UnregisterCluAdminAllNetworksExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNetInterfacesExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all network interfaces.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension(hCluster, L"NetworkInterfaces", pClsid);

    return hr;

}  //*** UnregisterCluAdminAllNetInterfacesExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminResourceTypeExtension
//
//  Routine Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends resources of a specific type, or the resource type
//      itself.
//
//  Arguments:
//      hCluster            [IN] Handle to the cluster to modify.
//      pwszResourceType    [IN] Resource type name.
//      pClsid              [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszResourceType,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the resource type registry key.
    hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
    if (hkey == NULL)
        hr = GetLastError();
    else
    {
        // Unregister the extension.
        hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

        ClusterRegCloseKey(hkey);
    }  // else:  GetClusterResourceTypeKey succeeded

    return hr;

}  //*** UnregisterCluAdminResourceTypeExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterAnyCluAdminExtension
//
//  Routine Description:
//      Register any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pwszKeyName     [IN] Key name.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkeyCluster;
    HKEY        hkey;

    // Get the cluster key.
    hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
    if (hkeyCluster == NULL)
        hr = GetLastError();
    else
    {
        // Get the specified key.
        hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
        if (hr == ERROR_SUCCESS)
        {
            // Register the extension.
            hr = RegisterAnyCluAdminExtension(hkey, pClsid);

            ClusterRegCloseKey(hkey);
        }  // else:  GetClusterResourceTypeKey succeeded

        ClusterRegCloseKey(hkeyCluster);
    }  // if:  CLSID converted to a string successfully

    return hr;

}  //*** RegisterAnyCluAdminExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterAnyCluAdminExtension
//
//  Routine Description:
//      Register any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hkey            [IN] Cluster database key.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    DWORD       sc;
    LPOLESTR    pwszClsid;
    size_t      cchSize;
    size_t      cchNewSize;
    LPWSTR      pwszValue;
    LPWSTR      pwszNewValue = NULL;
    BOOL        bAlreadyRegistered;

    // Convert the CLSID to a string.
    hr = StringFromCLSID(*pClsid, &pwszClsid);
    if (hr == S_OK)
    {
        // Read the current value.
        sc = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cchSize);
        if (sc == ERROR_SUCCESS)
        {
            // Check to see if the extension has been registered yet.
            if (pwszValue == NULL)
            {
                bAlreadyRegistered = FALSE;
            }
            else
            {
                LPCWSTR pwszValueBuf = pwszValue;
                size_t  cchValueBuf = cchSize;
                size_t  cch;

                while (*pwszValueBuf != L'\0')
                {
                    if ( ClRtlStrNICmp( pwszClsid, pwszValueBuf, cchValueBuf) == 0)
                    {
                        break;
                    }
                    cch = wcslen(pwszValueBuf) + 1;
                    pwszValueBuf += cch;
                    cchValueBuf -= cch;
                }  // while:  more strings in the extension list
                bAlreadyRegistered = (*pwszValueBuf != L'\0');
            }  // else:  extension value exists

            // Register the extension.
            if (!bAlreadyRegistered)
            {
                // Allocate a new buffer.
                cchNewSize = cchSize + wcslen(pwszClsid) + 1;
                if (cchSize == 0) // Add size of final NULL if first entry.
                {
                    cchNewSize++;
                }
                pwszNewValue = new WCHAR[ cchNewSize ];
                if (pwszNewValue == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                else
                {
                    LPCWSTR pwszValueBuf    = pwszValue;
                    LPWSTR  pwszNewValueBuf = pwszNewValue;
                    size_t  cchNewValueBuf  = cchNewSize;
                    size_t  cch;
                    DWORD   dwType;

                    // Copy the existing extensions to the new buffer.
                    if (pwszValue != NULL)
                    {
                        while (*pwszValueBuf != L'\0')
                        {
                            hr = StringCchCopyW( pwszNewValueBuf, cchNewValueBuf, pwszValueBuf );
                            if ( FAILED( hr ) )
                            {
                                goto Cleanup;
                            } // if:
                            cch = wcslen(pwszValueBuf) + 1;
                            pwszValueBuf += cch;
                            pwszNewValueBuf += cch;
                            cchNewValueBuf -= cch;
                        }  // while:  more strings in the extension list
                    }  // if:  previous value buffer existed

                    // Add the new CLSID to the list.
                    hr = StringCchCopyW( pwszNewValueBuf, cchNewValueBuf, pwszClsid );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    } // if:

                    //
                    // Add the double NULL termination.
                    //
                    pwszNewValueBuf += wcslen( pwszClsid ) + 1;
                    *pwszNewValueBuf = L'\0';

                    // Write the value to the cluster database.
                    dwType = REG_MULTI_SZ;
                    hr = ClusterRegSetValue(
                                    hkey,
                                    REG_VALUE_ADMIN_EXTENSIONS,
                                    dwType,
                                    (LPBYTE) pwszNewValue,
                                    static_cast< DWORD >( cchNewSize * sizeof( *pwszNewValue ) )
                                    );
                    if ( hr != ERROR_SUCCESS )
                    {
                        goto Cleanup;
                    }
                }  // else:  new buffer allocated successfully
            }  // if:  extension not registered yet
        }  // if:  value read successfully
        else
        {
            hr = HRESULT_FROM_WIN32( sc );
        }
    }  // if:  CLSID converted to a string successfully

Cleanup:

    delete [] pwszNewValue;
    delete [] pwszValue;
    CoTaskMemFree( pwszClsid );

    return hr;

}  //*** RegisterAnyCluAdminExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterAnyCluAdminExtension
//
//  Routine Description:
//      Unregister any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pwszKeyName     [IN] Key name.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkeyCluster;
    HKEY        hkey;

    // Get the cluster key.
    hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
    if (hkeyCluster == NULL)
        hr = GetLastError();
    else
    {
        // Get the specified key.
        hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
        if (hr == ERROR_SUCCESS)
        {
            // Unregister the extension.
            hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

            ClusterRegCloseKey(hkey);
        }  // else:  GetClusterResourceTypeKey succeeded

        ClusterRegCloseKey(hkeyCluster);
    }  // if:  CLSID converted to a string successfully

    return hr;

}  //*** UnregisterAnyCluAdminExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterAnyCluAdminExtension
//
//  Routine Description:
//      Unregister any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hkey            [IN] Cluster database key.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    DWORD       sc;
    LPOLESTR    pwszClsid;
    size_t      cchSize;
    size_t      cchNewSize;
    LPWSTR      pwszValue = NULL;
    LPWSTR      pwszNewValue = NULL;
    BOOL        bAlreadyUnregistered;

    // Convert the CLSID to a string.
    hr = StringFromCLSID(*pClsid, &pwszClsid);
    if (hr == S_OK)
    {
        // Read the current value.
        sc = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cchSize);
        if (sc == ERROR_SUCCESS)
        {
            // Check to see if the extension has been unregistered yet.
            if (pwszValue == NULL)
            {
                bAlreadyUnregistered = TRUE;
            }
            else
            {
                LPCWSTR pwszValueBuf = pwszValue;
                size_t  cch;
                size_t  cchValueBuf = cchSize;

                while (*pwszValueBuf != L'\0')
                {
                    if ( ClRtlStrNICmp( pwszClsid, pwszValueBuf, cchValueBuf ) == 0 )
                    {
                        break;
                    }
                    cch = wcslen(pwszValueBuf) + 1;
                    pwszValueBuf += cch;
                    cchValueBuf -= cch;
                }  // while:  more strings in the extension list
                bAlreadyUnregistered = (*pwszValueBuf == L'\0');
            }  // else:  extension value exists

            // Unregister the extension.
            if (!bAlreadyUnregistered)
            {
                // Allocate a new buffer.
                cchNewSize = cchSize - ( wcslen( pwszClsid ) + 1 );
                if (cchNewSize == 1) // only the final null left
                {
                    cchNewSize = 0;
                }
                pwszNewValue = new WCHAR[ cchNewSize ];
                if (pwszNewValue == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                else
                {
                    LPCWSTR pwszValueBuf    = pwszValue;
                    LPWSTR  pwszNewValueBuf = pwszNewValue;
                    size_t  cchValueBuf = cchSize;
                    size_t  cchNewValueBuf  = cchNewSize;
                    size_t  cch;
                    DWORD   dwType;

                    // Copy the existing extensions to the new buffer.
                    if ((cchNewSize > 0) && (pwszValue != NULL))
                    {
                        while (*pwszValueBuf != L'\0')
                        {
                            if ( ClRtlStrNICmp( pwszClsid, pwszValueBuf, cchValueBuf ) != 0 )
                            {
                                hr = StringCchCopyNW( pwszNewValueBuf, cchNewValueBuf, pwszValueBuf, cchValueBuf );
                                if ( FAILED( hr ) )
                                {
                                    goto Cleanup;
                                }
                                cch = wcslen(pwszNewValueBuf) + 1;
                                pwszNewValueBuf += cch;
                                cchNewValueBuf -= cch;
                            }  // if:  not CLSID being removed
                            cch = wcslen(pwszValueBuf) + 1;
                            pwszValueBuf += cch;
                            cchValueBuf -= cch;
                        }  // while:  more strings in the extension list
                        *pwszNewValueBuf = L'\0';
                    }  // if:  previous value buffer existed

                    // Write the value to the cluster database.
                    dwType = REG_MULTI_SZ;
                    hr = ClusterRegSetValue(
                                    hkey,
                                    REG_VALUE_ADMIN_EXTENSIONS,
                                    dwType,
                                    (LPBYTE) pwszNewValue,
                                    static_cast< DWORD >( cchNewSize * sizeof( *pwszNewValue ) )
                                    );
                    if ( hr != ERROR_SUCCESS )
                    {
                        goto Cleanup;
                    }
                }  // else:  new buffer allocated successfully
            }  // if:  extension not unregistered yet
        }  // if:  value read successfully
        else
        {
            hr = HRESULT_FROM_WIN32( sc );
        }
    }  // if:  CLSID converted to a string successfully

Cleanup:

    delete [] pwszNewValue;
    delete [] pwszValue;
    CoTaskMemFree( pwszClsid );

    return hr;

}  //*** UnregisterAnyCluAdminExtension

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ReadValue
//
//  Routine Description:
//      Reads a value from the cluster database.
//
//  Arguments:
//      hkey            [IN] Handle for the key to read from.
//      pwszValueName   [IN] Name of value to read.
//      ppwszValue      [OUT] Address of pointer in which to return data.
//                          The string is allocated using new [] and must
//                          be deallocated by the calling delete [].
//      pcchSize        [OUT] Size in characters of the allocated value buffer.
//
//  Return Value:
//      Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
    IN HKEY         hkey,
    IN LPCWSTR      pwszValueName,
    OUT LPWSTR *    ppwszValue,
    OUT size_t *    pcchSize
    )
{
    DWORD       dwStatus;
    DWORD       cbSize;
    DWORD       cchSize;
    DWORD       dwType;
    LPWSTR      pwszValue = NULL;

    *ppwszValue = NULL;
    *pcchSize = 0;

    // Get the length of the value.
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pwszValueName,
                    &dwType,
                    NULL,
                    &cbSize
                    );
    if (   (dwStatus != ERROR_SUCCESS)
        && (dwStatus != ERROR_MORE_DATA))
    {
        if (dwStatus  == ERROR_FILE_NOT_FOUND)
        {
            dwStatus = ERROR_SUCCESS;
        }
        goto Cleanup;
    }  // if:  error occurred

    ASSERT( (cbSize % sizeof( WCHAR ) ) == 0 ); // must be even
    cchSize = cbSize / sizeof( WCHAR );

    if (cbSize > 0)
    {
        // Allocate a value string.
        pwszValue = new WCHAR[ cchSize ];
        if (pwszValue == NULL)
        {
            dwStatus = GetLastError();
            goto Cleanup;
        }  // if:  error allocating memory

        // Read the the value.
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pwszValueName,
                        &dwType,
                        (LPBYTE) pwszValue,
                        &cbSize
                        );
        if (dwStatus != ERROR_SUCCESS)
        {
            delete [] pwszValue;
            pwszValue = NULL;
            cbSize = 0;
        }  // if:  error occurred
        else
        {
            ASSERT( cchSize * sizeof( WCHAR ) == cbSize );
        }

        *ppwszValue = pwszValue;
        *pcchSize = static_cast< size_t >( cchSize );
        pwszValue = NULL;
    }  // if:  value is not empty

Cleanup:

    delete [] pwszValue;
    return dwStatus;

}  //*** ReadValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\quorumutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:                                                    
//      QuorumUtils.cpp
//
//  Description:
//      Utility functions for retrieving the root path from a cluster.
//
//  Maintained By:
//      George Potts (GPotts)               22-OCT-2001
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <StrSafe.h>
#include "QuorumUtils.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  SplitRootPath
//
//  Routine Description:
//      Take the current quorum path (from GetClusterQuorumResource) and compare
//      it to the device names returned from the resource.  From this take the
//      additional path from the quorum path and set that as our root path.
//
//      It is expected that the IN buffers are at least of size _MAX_PATH.
//
//  Arguments:
//      hClusterIn          Handle to the cluster.
//
//      pszPartitionNameOut Partition name buffer to fill.  
//
//      pcchPartitionIn     Max char count of buffer.
//
//      pszRootPathOut      Root path buffer to fill.  
//
//      pcchRootPathIn      Max char count of buffer. 
//
//  Return Value:
//      ERROR_SUCCESS on success.
//
//      ERROR_MORE_DATA
//          pcchPartitionInout and pcchRootPathInout will contain the
//          minimum sizes needed for the buffers.
//
//      Win32 Error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD SplitRootPath(
      HCLUSTER  hClusterIn
    , WCHAR *   pszPartitionNameOut
    , DWORD *   pcchPartitionInout
    , WCHAR *   pszRootPathOut
    , DWORD *   pcchRootPathInout
    )
{
    HRESOURCE               hQuorumResource = NULL;
    WCHAR *                 pszResourceName = NULL;
    WCHAR *                 pszQuorumPath = NULL;
    WCHAR *                 pszDeviceTemp = NULL;
    WCHAR *                 pszTemp = NULL;
    CLUSPROP_BUFFER_HELPER  buf;
    DWORD                   cbData;
    DWORD                   cchDeviceName;
    WCHAR *                 pszDevice;
    DWORD                   dwVal;
    DWORD                   sc;
    PVOID                   pbDiskInfo = NULL;
    DWORD                   cbDiskInfo = 0;
    HRESULT                 hr;

    //
    //  Validate parameters.
    //
    if ( hClusterIn == NULL || 
         pszPartitionNameOut == NULL || pcchPartitionInout == NULL ||
         pszRootPathOut == NULL || pcchRootPathInout == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  Get the info about the quorum resource.
    //
    sc = WrapGetClusterQuorumResource( hClusterIn, &pszResourceName, &pszQuorumPath, NULL );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Open a handle to the quorum resource to interrogate it.
    //
    hQuorumResource = OpenClusterResource( hClusterIn, pszResourceName );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Get the disk info from the resource.
    //
    sc = ScWrapClusterResourceControlGet( 
              hQuorumResource
            , NULL
            , CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO
            , NULL
            , 0
            , &pbDiskInfo
            , &cbDiskInfo 
            );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Cycle through the buffer looking for the first partition.
    //
    buf.pb = (BYTE*)pbDiskInfo;
    while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
    {
        //  Calculate the size of the value.
        cbData = sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);

        //  Parse the value.
        if (buf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
        {
            //
            //  A resource may have multiple partitions defined - make sure that ours matches the quorum path.
            //  For any partition that is an SMB share we have to be careful - the quorum path may differ from the device name
            //  by the first 8 characters - "\\" vs. "\\?\UNC\".  If it's an SMB path do special parsing, otherwise compare
            //  the beginning of the quorum path against the full device name.  The reason for this is 
            //  that SetClusterQuorumResource will convert any given SMB path to a UNC path.
            //

            //  Make it easier to follow.
            pszDevice = buf.pPartitionInfoValue->szDeviceName;

            if ( (wcslen( pszDevice ) >= 2) && (ClRtlStrNICmp( L"\\\\", pszDevice, 2 ) == 0 ) )
            {
                //
                //  We found an SMB/UNC match.
                //

                //
                //  SMB and UNC paths always lead off with two leading backslashes - remove these from the 
                //  partition name since a compare of "\\<part>" and "\\?\UNC\<part>" will never match.
                //  Instead, we'll just search for "<part>" in the quorum path. 
                //
               
                //  Allocate a new buffer to copy the trimmed code to.
                //  You can use the same buffer for both params of TrimLeft and TrimRight.
                pszDeviceTemp = (WCHAR *) LocalAlloc( LMEM_ZEROINIT, ( wcslen( pszDevice ) + 1 ) * sizeof( WCHAR ) );
                if ( pszDeviceTemp == NULL )
                {
                    sc = ERROR_OUTOFMEMORY;
                    goto Cleanup;
                }

                //  This will remove all leading backslashes.
                dwVal = TrimLeft( pszDevice, L"\\", pszDeviceTemp );

                //  It may end with a \ - remove this if present.
                dwVal = TrimRight( pszDeviceTemp, L"\\", pszDeviceTemp );

                //  Find out if pszDeviceTemp is a substring of pszQuorumPath.
                pszTemp = wcsstr( pszQuorumPath, pszDeviceTemp );
                if ( pszTemp != NULL )
                {
                    //  We found a match, now find the offset of the root path. 
                    pszTemp += wcslen( pszDeviceTemp );

                    //  Make sure our buffers are big enough.
                    if ( wcslen( pszDevice ) >= *pcchPartitionInout )
                    {
                        sc = ERROR_MORE_DATA;
                    }

                    if ( wcslen( pszTemp ) >= *pcchRootPathInout )
                    { 
                        sc = ERROR_MORE_DATA;
                    }

                    *pcchPartitionInout = static_cast< DWORD >( wcslen( pszDevice ) + 1 );
                    *pcchRootPathInout = static_cast< DWORD >( wcslen( pszTemp ) + 1 );

                    if ( sc != ERROR_SUCCESS )
                    {
                        goto Cleanup;
                    }

                    //  Copy the partition and NULL terminate it.
                    hr = StringCchCopyW( pszPartitionNameOut, *pcchPartitionInout, pszDevice );
                    if ( FAILED( hr ) )
                    {
                        sc = HRESULT_CODE( hr );
                        break;
                    }

                    //  Copy the root path and NULL terminate it.
                    hr = StringCchCopyW( pszRootPathOut, *pcchRootPathInout, pszTemp );
                    if ( FAILED( hr ) )
                    {
                        sc = HRESULT_CODE( hr );
                        break;
                    }

                    break;

                } // if: pszDeviceTemp is a substring of pszQuorumPath
            } // if: SMB or UNC path
            else if ( ClRtlStrNICmp( pszQuorumPath, pszDevice, wcslen( pszDevice )) == 0 ) 
            {
                //  We found a non-SMB match match - pszDevice is a substring of pszQuorumPath.
                cchDeviceName = static_cast< DWORD >( wcslen( pszDevice ) );

                if ( cchDeviceName >= *pcchPartitionInout )
                {
                    sc = ERROR_MORE_DATA;
                }

                if ( wcslen( &(pszQuorumPath[cchDeviceName]) ) >= *pcchRootPathInout )
                {
                    sc = ERROR_MORE_DATA;
                }

                *pcchPartitionInout = cchDeviceName + 1; 
                *pcchRootPathInout = static_cast< DWORD >( wcslen( &(pszQuorumPath[cchDeviceName]) ) + 1 );

                if ( sc != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }

                hr = StringCchCopyW( pszPartitionNameOut, *pcchPartitionInout, pszDevice );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    break;
                }
                
                hr = StringCchCopyW( pszRootPathOut, *pcchRootPathInout, &(pszQuorumPath[cchDeviceName]) );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    break;
                }
                break;

            } // if: same partition

        }  // if: partition info

        //  Advance the buffer pointer
        buf.pb += cbData;
    } // while:  more values

    //
    //  Something failed - we weren't able to find a partition.  Default to the quorum path
    //  and a single backslash.
    //
    if ( wcslen( pszPartitionNameOut ) == 0 )
    {
        hr = StringCchCopyW( pszPartitionNameOut, *pcchPartitionInout, pszQuorumPath );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }
    }  

    if ( wcslen( pszRootPathOut ) == 0 )
    {
        hr = StringCchCopyW( pszRootPathOut, *pcchRootPathInout, L"\\" );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }
    }  

Cleanup:

    LocalFree( pszResourceName );
    LocalFree( pszQuorumPath );
    LocalFree( pbDiskInfo );

    if ( hQuorumResource != NULL )
    {
        CloseClusterResource( hQuorumResource );
    }

    return sc;

}  // *** SplitRootPath()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConstructQuorumPath
//
//  Routine Description:
//      Construct a quorum path to pass to SetClusterQuorumResource given
//      the parsed root path.  This function enumerates the resources
//      partitions and the first one that it finds it takes the device name
//      and appends the rootpath to it.
//
//  Arguments:
//      hResourceIn         Resource that is going to become the quorum.
//
//      pszRootPathIn       Root path to append to one of the resource's partitions.
//
//      pszQuorumPathOut    Buffer to receive the constructed quorum path.
//
//      pcchQuorumPathInout Count of characters in pszQuorumPathOut.
//
//
//  Return Value:
//      ERROR_SUCCESS on success.
//          The number of characters written (including NULL) is in 
//          pcchQuorumPathInout.
//
//      ERROR_MORE_DATA
//          pszQuorumPathOut is too small.  The necessary buffer size 
//          in characters (including NULL) is in pcchQuorumPathInout.
//
//      Win32 Error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConstructQuorumPath(
              HRESOURCE     hResourceIn
            , const WCHAR * pszRootPathIn
            , WCHAR *       pszQuorumPathOut
            , DWORD *       pcchQuorumPathInout
            )
{
    DWORD   sc = ERROR_SUCCESS;
    PVOID   pbDiskInfo = NULL;
    DWORD   cbDiskInfo = 0;
    DWORD   cbData = 0;
    WCHAR * pszDevice = NULL;
    size_t  cchNeeded = 0;
    HRESULT hr;
    CLUSPROP_BUFFER_HELPER  buf;

    //
    //  Check params.
    //
    if ( pszRootPathIn == NULL || pszQuorumPathOut == NULL || pcchQuorumPathInout == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  Get the disk info from the resource.
    //
    sc = ScWrapClusterResourceControlGet( 
              hResourceIn
            , NULL
            , CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO
            , NULL
            , 0
            , &pbDiskInfo
            , &cbDiskInfo 
            );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    buf.pb = (BYTE*) pbDiskInfo;
    while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
    {
        // Calculate the size of the value.
        cbData = sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);

        //
        //  See if this property contains partition info.  We grab the first partition.
        //
        if (buf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
        {
            pszDevice = buf.pPartitionInfoValue->szDeviceName;

            //
            //  Calculate the size of the buffer that we need.
            //
            cchNeeded = wcslen( pszDevice ) + 1;
            cchNeeded += wcslen( pszRootPathIn );

            if ( pszDevice[ wcslen( pszDevice ) - 1 ] == L'\\' && pszRootPathIn[ 0 ] == L'\\' ) 
            {
                //
                //  We'd have two backslashes if we concatenated them.  Prune one of them off.  
                //

                //  Decrement one for the removed backslash.
                cchNeeded--;

                if ( cchNeeded > *pcchQuorumPathInout )
                {
                    sc = ERROR_MORE_DATA;
                    *pcchQuorumPathInout = static_cast< DWORD >( cchNeeded );
                    goto Cleanup;
                }

                //
                //  Construct the path.
                //
                hr = StringCchPrintfW( pszQuorumPathOut, *pcchQuorumPathInout, L"%ws%ws", pszDevice, &pszRootPathIn[ 1 ] );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                }

            } // if: concatenating would introduce double backslashes
            else if( pszDevice[ wcslen( pszDevice ) - 1 ] != L'\\' && pszRootPathIn[ 0 ] != L'\\' )
            {
                //
                //  We need to insert a backslash between the concatenated strings.
                //

                //  Increment by one for the added backslash.
                cchNeeded++;

                if ( cchNeeded > *pcchQuorumPathInout )
                {
                    sc = ERROR_MORE_DATA;
                    *pcchQuorumPathInout = static_cast< DWORD >( cchNeeded );
                    goto Cleanup;
                }

                //
                //  Construct the path.
                //
                hr = StringCchPrintfW( pszQuorumPathOut, *pcchQuorumPathInout, L"%s\\%s", pszDevice, pszRootPathIn );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                }

            } // if: we need to introduce a backslash between the concatenation
            else
            {
                //
                //  We're fine to just construct the path.
                //
                if ( cchNeeded > *pcchQuorumPathInout )
                {
                    sc = ERROR_MORE_DATA;
                    *pcchQuorumPathInout = static_cast< DWORD >( cchNeeded );
                    goto Cleanup;
                }

                //
                //  Construct the path.
                //
                hr = StringCchPrintfW( pszQuorumPathOut, *pcchQuorumPathInout, L"%s%s", pszDevice, pszRootPathIn );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                }

            } // if: we can just concatenate the strings
            
            //
            //  Return the number of bytes that we needed in the buffer.
            //
            *pcchQuorumPathInout = static_cast< DWORD >( cchNeeded );

            break;
        }  // if:  partition info

        // Advance the buffer pointer
        buf.pb += cbData;

    }  // while:  more values

Cleanup:
    LocalFree( pbDiskInfo );

    return sc;

} //*** ConstructQuorumPath


/////////////////////////////////////////////////////////////////////////////
//++
//
//  TrimLeft
//
//  Routine Description:
//      Trim all leading whitespace as well as any leading characters specified.
//
//  Arguments:
//      pszTargetIn         String to trim characters from.
//
//      pszCharsIn          List of characters to remove in addition to white space.
//
//      pszTrimmedOut       Target buffer in which the trimmed string will be 
//                          placed.  This may be the same buffer as pszTargetIn.
//                          This buffer is expected to be at least the size of
//                          pszTargetIn (in case no characters are removed).
//
//  Return Value:
//      The count of characters trimmed.
//
//      -1.  Call GetLastError for more information.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD TrimLeft( 
          const WCHAR * pszTargetIn
        , const WCHAR * pszCharsIn
        , WCHAR *       pszTrimmedOut 
        )
{
    const WCHAR *   pszTargetPtr = pszTargetIn;
    const WCHAR *   pszTemp = NULL;
    BOOL            fContinue;
    DWORD           sc = ERROR_SUCCESS;
    DWORD           cchTrimmed = 0;            // Number of characters trimmed.

    if ( pszTargetIn == NULL || pszTrimmedOut == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  Loop until we find non-whitespace or a char not in pszCharsIn or 
    //  we've reached the end of the string.
    //
    fContinue = TRUE;
    while ( *pszTargetPtr != L'\0' && fContinue == TRUE )
    {
        fContinue = FALSE;

        //
        //  Is the character white space?
        //
        if ( 0 == iswspace( pszTargetPtr[0] ) )
        {
            //
            //  No, it's not.  Does it match CharsIn?
            //
            for( pszTemp = pszCharsIn; pszTemp != NULL && *pszTemp != L'\0'; pszTemp++ )
            {
                if ( pszTargetPtr[ 0 ] == pszTemp[ 0 ] )
                {
                    //
                    //  We've got a match - trim it and loop on the next character.
                    //
                    fContinue = TRUE;
                    cchTrimmed++;
                    pszTargetPtr++;
                    break;
                } // if:
            } // for:
        } // if:
        else 
        {
            //
            // We've got some whitespace - trim it.
            //
            fContinue = TRUE;
            cchTrimmed++;
            pszTargetPtr++;
        } // else: 
    } // while: 

    //
    //  Copy the truncated string to the pszTrimmedOut buffer.  
    //  If we truncated everything from the string make sure 
    //  we NULL terminate the string.
    //
    if ( wcslen( pszTargetPtr ) == 0 )
    {
        *pszTrimmedOut = L'\0';

    }
    else
    {
        // Use memmove because the caller may have passed in the same buffer for both variables.
        memmove( pszTrimmedOut, pszTargetPtr, ( wcslen( pszTargetPtr ) + 1 ) * sizeof( WCHAR ) );
    }

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        cchTrimmed = static_cast< DWORD >( -1 );
    }
    SetLastError( sc );
    return cchTrimmed;

} //*** TrimLeft


/////////////////////////////////////////////////////////////////////////////
//++
//
//  TrimRight
//
//  Routine Description:
//      Trim all trailing whitespace as well as any trailing characters specified.
//
//  Arguments:
//      pszTargetIn         String to trim characters from.
//
//      pszCharsIn          List of characters to remove in addition to white space.
//
//      pszTrimmedOut       Target buffer in which the trimmed string will be 
//                          placed.  This may be the same buffer as pszTargetIn.
//                          This buffer is expected to be at least the size of
//                          pszTargetIn (in case no characters are removed).
//
//  Return Value:
//      The count of characters trimmed.
//
//      -1.  Call GetLastError for more information.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD TrimRight( 
          const WCHAR * pszTargetIn
        , const WCHAR * pszCharsIn
        , WCHAR *       pszTrimmedOut 
        )
{
    const WCHAR *   pszTargetPtr = pszTargetIn;
    const WCHAR *   pszTemp = NULL;
    BOOL            fContinue;
    DWORD           sc = ERROR_SUCCESS;
    DWORD           cchTrimmed = 0;            // Number of characters trimmed.
    size_t          cchLen = 0;

    if ( pszTargetIn == NULL || pszTrimmedOut == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    cchLen = wcslen( pszTargetIn );

    if ( cchLen == 0 )
    {
        //
        //  We've got an empty string.
        //
        pszTargetPtr = pszTargetIn;
    }
    else
    {
        //
        //  Point to the last character in the string.
        //
        pszTargetPtr = &(pszTargetIn[ cchLen - 1 ] );
    }

    //
    //  Loop until we find non-whitespace or a char not in pszCharsIn or 
    //  we've reached the beginning of the string.
    //
    fContinue = TRUE;
    while ( pszTargetPtr >= pszTargetIn && fContinue == TRUE )
    {
        fContinue = FALSE;

        //
        //  Is the character white space?
        //
        if ( 0 == iswspace( pszTargetPtr[0] ) )
        {
            //
            //  No, it's not.  Does it match CharsIn?
            //
            for( pszTemp = pszCharsIn; pszTemp != NULL && *pszTemp != L'\0'; pszTemp++ )
            {
                if ( pszTargetPtr[ 0 ] == pszTemp[ 0 ] )
                {
                    //
                    //  We've got a match - trim it and loop on the next character.
                    //
                    fContinue = TRUE;
                    cchTrimmed++;
                    pszTargetPtr--;
                    break;
                } // if:
            } // for:
        } // if:
        else 
        {
            //
            // We've got some whitespace - trim it.
            //
            fContinue = TRUE;
            cchTrimmed++;
            pszTargetPtr--;
        } // else: 
    } // while: 

    //
    //  Copy the truncated string to the pszTrimmedOut buffer.  
    //  If we truncated everything from the string make sure 
    //  we NULL terminate the string.
    //
    if ( wcslen( pszTargetPtr ) == 0 )
    {
        *pszTrimmedOut = L'\0';
    }
    else
    {
        // Use memmove because they may have passed in the same buffer for both variables.
        memmove( pszTrimmedOut, pszTargetIn, ( cchLen - cchTrimmed ) * sizeof( WCHAR ) );
        pszTrimmedOut[ cchLen - cchTrimmed ] = L'\0';
    }

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        cchTrimmed = static_cast< DWORD >( -1 );
    }
    SetLastError( sc );

    return cchTrimmed;

} //*** TrimRight
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\restypeutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ResTypeUtils.cpp
//
//  Description:
//      Resource type utilities.
//
//  Author:
//      Galen Barbee    (galenb)    11-Jan-1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <StrSafe.h>

#include <clusapi.h>
#include "ResTypeUtils.h"
#include "PropList.h"
#include "ClusWrap.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScResTypeNameToDisplayName
//
//  Description:
//      Retrieve the display name for a specified resource type name.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster containing the resource type.
//      pszTypeName     [IN] Name of resource type.
//      ppszDisplayName [IN] Pointer in which to return string containing
//                          the resource type display name.  Caller must
//                          deallocate this buffer by calling LocalFree().
//
//  Return Value:
//      Any status returns from CClusPropList::ScGetResourceTypeProperties(),
//      CClusPropList::ScMoveToPropertyByName(), or LocalAlloc().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ScResTypeNameToDisplayName(
    HCLUSTER    hCluster,
    LPCWSTR     pszTypeName,
    LPWSTR *    ppszDisplayName
    )
{
    DWORD           _sc = ERROR_SUCCESS;
    size_t          _cbSize;
    CClusPropList   _PropList;

    // Use the proplist helper class.

    *ppszDisplayName = NULL;

    _sc = _PropList.ScGetResourceTypeProperties(
                hCluster,
                pszTypeName,
                CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                );

    if ( _sc != ERROR_SUCCESS )
    {
        return _sc;
    } // if: error getting common properties

    // Find the name property.
    _sc = _PropList.ScMoveToPropertyByName( L"Name" );
    if ( _sc != ERROR_SUCCESS )
    {
        return _sc;
    } // if:  property not found

    _cbSize = wcslen( _PropList.CbhCurrentValue().pStringValue->sz ) + 1;
    _cbSize *= sizeof( *(_PropList.CbhCurrentValue().pStringValue->sz) );

    *ppszDisplayName = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_ZEROINIT, _cbSize ) );
    if ( *ppszDisplayName != NULL )
    {
        size_t _cchSize = _cbSize / sizeof( **ppszDisplayName );
        HRESULT _hr = StringCchCopyNW(
                              *ppszDisplayName
                            , _cchSize
                            , _PropList.CbhCurrentValue().pStringValue->sz
                            , _PropList.CbhCurrentValue().pStringValue->cbLength
                            );
        ASSERT( SUCCEEDED( _hr ) );
        if ( FAILED( _hr ) )
        {
            _sc = HRESULT_CODE( _hr );
        }
    } // if:  buffer allocated successfully
    else
    {
        _sc = GetLastError();
    } // else: error allocating buffer

    return _sc;

} //*** ScResTypeNameToDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ScResDisplayNameToTypeName
//
//  Routine Description:
//      Retrieve the type name for a specified resource type display name.
//
//  Arguments:
//      pszTypeName     [IN] Name of resource type.
//      ppszTypeyName   [IN] Pointer in which to return string containing
//                          the resource type name.  Caller must deallocate
//                          this buffer by calling LocalFree().
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ScResDisplayNameToTypeName(
    HCLUSTER    hCluster,
    LPCWSTR     pszDisplayName,
    LPWSTR *    ppszTypeName
    )
{
    DWORD       _sc = ERROR_SUCCESS;
    HCLUSENUM   _hEnum;
    DWORD       _dwIndex;
    DWORD       _dwType;
    DWORD       _cbSize;
    LPWSTR      _pszName = NULL;
    LPWSTR      _pszTestDisplayName = NULL;
    BOOL        _bFound = FALSE;

    // Enumerate resources
    _hEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESTYPE );
    if ( _hEnum == NULL )
    {
        return GetLastError();
    } // if:  error opening the enumeration

    for ( _dwIndex = 0 ; ! _bFound && _sc == ERROR_SUCCESS ; _dwIndex++ )
    {
        _pszName = NULL;
        _pszTestDisplayName = NULL;

        _sc = WrapClusterEnum( _hEnum, _dwIndex, &_dwType, &_pszName );
        if ( _sc == ERROR_SUCCESS )
        {
            _sc = ScResTypeNameToDisplayName( hCluster, _pszName, &_pszTestDisplayName );
            if ( _sc == ERROR_SUCCESS )
            {
                ASSERT( _pszTestDisplayName != NULL );
                _bFound = ClRtlStrICmp( pszDisplayName, _pszTestDisplayName ) == 0;

                if ( _bFound )
                {
                    _cbSize = static_cast< DWORD >( wcslen( _pszName ) + 1 );
                    _cbSize *= sizeof( *_pszName );

                    *ppszTypeName = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_ZEROINIT, _cbSize ) );
                    if ( *ppszTypeName == NULL )
                    {
                        _sc = GetLastError();
                    } // if:  error allocating memory
                    else
                    {
                        size_t _cchSize = _cbSize / sizeof( **ppszTypeName );
                        HRESULT _hr = StringCchCopyW( *ppszTypeName, _cchSize, _pszName );
                        ASSERT( SUCCEEDED( _hr ) );
                        if ( FAILED( _hr ) )
                        {
                            _sc = HRESULT_CODE( _hr );
                        }
                    } // else:  memory allocated successfully
                } // if:  found the display name
            } // if:  retrieved display name
            else
            {
                // If there was an error getting the display name of this resource type,
                // continue with the enumeration, so that if one resource type fails, we do
                // not abort getting the display name of resources further down in the 
                // enumeration list.
                _sc = ERROR_SUCCESS;
            } // else:  could not retrieve the display name.

        } // if: successfully retrieved next resource type from enumeration

        LocalFree( _pszName );
        LocalFree( _pszTestDisplayName );
    } // for:  each resource type

    if ( ( _sc == ERROR_NO_MORE_ITEMS ) || ( _bFound == FALSE ) )
    {
        _sc = ERROR_INVALID_PARAMETER;
    } // if:  resource type not found

    return _sc;

} //*** ScResDisplayNameToTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\stlutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		StlUtils.h
//
//	Abstract:
//		Definition of STL utility classes and functions.
//
//	Implementation File:
//		None.
//
//	Author:
//		David Potter (davidp)	May 21, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __STLUTUILS_H_
#define __STLUTUILS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

// Delete all items from a pointer list
template < class T >
void DeleteAllPtrListItems( std::list< T > * pList )
{
	ATLASSERT( pList != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< T >::iterator itCurrent = pList->begin();
	std::list< T >::iterator itLast = pList->end();

	//
	// Loop through the list and delete each objects.
	//
	while ( itCurrent != itLast )
	{
		T pT = *itCurrent;
		ATLASSERT( pT != NULL );
		delete pT;
		itCurrent = pList->erase( itCurrent );
	} // while:  more items in the list

} //*** DeleteAllPtrListItems()

// Delete items of a desired type from a pointer list
template < class TBase, class T >
void DeletePtrListItems( std::list< TBase > * pList )
{
	ATLASSERT( pList != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< TBase >::iterator itCurrent = pList->begin();
	std::list< TBase >::iterator itLast = pList->end();

	//
	// Loop through the list looking for objects of the
	// desired type and delete those objects.
	//
	while ( itCurrent != itLast )
	{
		T pT = dynamic_cast< T >( *itCurrent );
		if ( pT != NULL )
		{
			delete pT;
			itCurrent = pList->erase( itCurrent );
		} // if:  object has desired type
		else
		{
			itCurrent++;
		} // else:  object has different type
	} // while:  more items in the list

} //*** DeletePtrListItems()

// Move items of a desired type from one pointer list to another list
template < class TBase, class T >
void MovePtrListItems(
	std::list< TBase > * pSrcList,
	std::list< T > * pDstList
	)
{
	ATLASSERT( pSrcList != NULL );
	ATLASSERT( pDstList != NULL );

	//
	// Get pointers to beginning and end of list.
	//
	std::list< TBase >::iterator itCurrent = pSrcList->begin();
	std::list< TBase >::iterator itLast = pSrcList->end();

	//
	// Loop through the source list looking for objects of the
	// desired type and move those objects to the
	// destination list.
	//
	while ( itCurrent != itLast )
	{
		T pT = dynamic_cast< T >( *itCurrent );
		if ( pT != NULL )
		{
			itCurrent = pSrcList->erase( itCurrent );
			pDstList->insert( pDstList->end(), pT );
		} // if:  object has desired type
		else
		{
			itCurrent++;
		} // else:  object has different type
	} // while:  more items in the list

} //*** MovePtrListItems()

/////////////////////////////////////////////////////////////////////////////

#endif // __STLUTUILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\restypeutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ResTypeUtils.h
//
//	Description:
//		Resource type utilities.
//
//	Author:
//		Galen Barbee	(galenb)	11-Jan-1999
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESUTILS_H
#define __RESUTILS_H

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI ScResTypeNameToDisplayName(
	HCLUSTER	hCluster,
	LPCWSTR		pszTypeName,
	LPWSTR *	ppszDisplayName
	);

DWORD WINAPI ScResDisplayNameToTypeName(
	HCLUSTER	hCluster,
	LPCWSTR		pszDisplayName,
	LPWSTR *	ppszTypeName
	);

/////////////////////////////////////////////////////////////////////////////

#endif // __RESUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\waitcrsr.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		WaitCrsr.h
//
//	Abstract:
//		Definition of the CWaitCursor class for changing the cursor to
//		an hourglass for the lifetime of the instantiation of the class.
//		Needed this because ATL doesn't provide it.
//
//	Author:
//		David Potter (davidp)	November 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WAITCRSR_H_
#define __WAITCRSR_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWaitCursor;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor
/////////////////////////////////////////////////////////////////////////////

class CWaitCursor
{
public:
	CWaitCursor(LPCTSTR lpCursorName = IDC_WAIT)
	{
		m_curOld = SetCursor(LoadCursor(NULL, lpCursorName));
	}

	~CWaitCursor(void)
	{
		SetCursor(m_curOld);
	}

protected:
	HCURSOR	m_curOld;

}; // class CWaitCursor

/////////////////////////////////////////////////////////////////////////////

#endif // __WAITCRSR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\workthrd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		WorkThrd.h
//
//	Abstract:
//		Definition of the CWorkerThread class.
//
//	Implementation File:
//		WorkThrd.cpp
//
//	Author:
//		David Potter (davidp)	November 17, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WORKTHRD_H_
#define __WORKTHRD_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWorkerThread;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXCOPER_H_
#include "ExcOper.h"	// for CNTException
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

// Worker thread function codes.
enum
{
	WTF_EXIT = -1,		// Ask the thread to exit.
	WTF_NONE = 0,		// No function.
	WTF_USER = 1000		// User functions start here.
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CWorkerThread
//
//	Purpose:
//		This class provides a means of calling functions in a worker thread
//		and allowing a UI application to still respond to Windows messages.
//		The user of this class owns the input and output data pointed to
//		by this class.
//
//	Inheritance:
//		CWorkerThread
//
//--
/////////////////////////////////////////////////////////////////////////////

class CWorkerThread
{
public:
	//
	// Construction and destruction.
	//

	// Default constructor
	CWorkerThread( void )
		: m_hThread( NULL )
		, m_hMutex( NULL )
		, m_hInputEvent( NULL )
		, m_hOutputEvent( NULL)
		, m_idThread( 0 )
		, m_bThreadExiting( FALSE )
		, m_nFunction( WTF_NONE )
		, m_pvParam1( NULL )
		, m_pvParam2( NULL )
		, m_dwOutputStatus( ERROR_SUCCESS )
		, m_nte( ERROR_SUCCESS )
		, m_pfnOldWndProc( NULL )
		, m_hCurrentCursor( NULL )
	{
	} //*** CWorkerThread()

	// Destructor
	~CWorkerThread( void )
	{
		ATLASSERT( m_nFunction == WTF_NONE );
		ATLASSERT( m_pvParam1 == NULL );
		ATLASSERT( m_pvParam2 == NULL );

		Cleanup();

		ATLASSERT( m_bThreadExiting );

	} //*** ~CWorkerThread()

	// Create the thread
	DWORD CreateThread( void );

	// Ask the thread to exit
	void QuitThread( IN HWND hwnd = NULL )
	{
		ATLASSERT( ! m_bThreadExiting );
		CWaitCursor wc;
		CallThreadFunction( hwnd, WTF_EXIT, NULL, NULL );

	} //*** QuitThread()

	// Call a function supported by the thread
	DWORD CallThreadFunction(
			IN HWND			hwnd,
			IN LONG			nFunction,
			IN OUT PVOID	pvParam1 = NULL,
			IN OUT PVOID	pvParam2 = NULL
			);

	// Wait for the thread to exit
	DWORD WaitForThreadToExit( IN HWND hwnd );

public:
	//
	// Accessor functions.
	//

	// Get the thread handle
	operator HANDLE( void ) const
	{
		return m_hThread;

	} //*** operator HANDLE()

	// Get the thread handle
	HANDLE HThreadHandle( void ) const
	{
		return m_hThread;

	} //*** HThreadHandle()

	// Get the thread ID
	operator DWORD( void ) const
	{
		return m_idThread;

	} //*** operator DWORD()

	// Get exception information resulting from a thread function call
	CNTException & Nte( void )
	{
		return m_nte;

	} //*** Nte()

	// Get exception information resulting from a thread function call
	operator CNTException *( void )
	{
		return &m_nte;

	} //*** operator CNTException *()

protected:
	//
	// Synchronization data.
	//
	HANDLE			m_hThread;			// Handle for the thread.
	HANDLE			m_hMutex;			// Handle for the mutex used to call a
										//	function in the thread.
	HANDLE			m_hInputEvent;		// Handle for the event used by the calling
										//	thread to signal the worker thread that
										//	there is work to do.
	HANDLE			m_hOutputEvent;		// Handle for the event used by the worker
										//	thread to signal the calling thread
										//	that the work has been completed.
	UINT			m_idThread;			// ID for the thread.
	BOOL			m_bThreadExiting;	// Determine if thread is exiting or not.

	//
	// Data used as input or produced by the thread.
	//
	LONG			m_nFunction;		// ID of the function to perform.
	PVOID			m_pvParam1;			// Parameter 1 with function-specific data.
	PVOID			m_pvParam2;			// Parameter 2 with function-specific data.
	DWORD			m_dwOutputStatus;	// Status returned from the function.
	CNTException	m_nte;				// Exception information from the function.

	//
	// Data and methods for handling WM_SETCURSOR messages.
	//
	WNDPROC			m_pfnOldWndProc;	// Old window procedure for the parent window.
	HCURSOR			m_hCurrentCursor;	// Cursor to display while waiting for thread call to complete.

	// Window procedure for subclassing the parent window
	static LRESULT WINAPI S_ParentWndProc(
							IN HWND		hwnd,
							IN UINT		uMsg,
							IN WPARAM	wParam,
							IN LPARAM	lParam
							);

	//
	// Thread worker functions.
	//

	// Static thread procedure
	static UINT __stdcall S_ThreadProc( IN OUT LPVOID pvThis );

	// Thread function handler
	virtual DWORD ThreadFunctionHandler(
						IN LONG			nFunction,
						IN OUT PVOID	pvParam1,
						IN OUT PVOID	pvParam2
						) = 0;

	//
	// Helper functions.
	//

	// Prepare a window to wait for a thread operation
	void PrepareWindowToWait( IN HWND hwnd );

	// Cleanup a window after waiting for a thread operation
	void CleanupWindowAfterWait( IN HWND hwnd );

	// Cleanup objects
	virtual void Cleanup( void )
	{
		if ( m_hThread != NULL )
		{
			if ( ! m_bThreadExiting && (m_nFunction != WTF_EXIT) )
			{
				QuitThread();
			} // if:  thread hasn't exited yet
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing thread handle\n") );
			CloseHandle( m_hThread );
			m_hThread = NULL;
		}  // if:  thread created
		if ( m_hMutex != NULL )
		{
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing mutex handle\n") );
			CloseHandle( m_hMutex );
			m_hMutex = NULL;
		}  // if:  mutex created
		if ( m_hInputEvent != NULL )
		{
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing input event handle\n") );
			CloseHandle( m_hInputEvent );
			m_hInputEvent = NULL;
		}  // if:  input event created
		if ( m_hOutputEvent != NULL )
		{
			ATLTRACE( _T("CWorkerThread::Cleanup() - Closing output event handle\n") );
			CloseHandle( m_hOutputEvent );
			m_hOutputEvent = NULL;
		}  // if:  output event created

	} //*** Cleanup()

}; // class CWorkerThread

/////////////////////////////////////////////////////////////////////////////

#endif // __WORKTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\common\workthrd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		WorkThrd.cpp
//
//	Abstract:
//		Implementation of the CWorkerThread class.
//
//	Author:
//		David Potter (davidp)	November 17, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "AdmCommonRes.h"
#include "WorkThrd.h"
#include <process.h>

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

TCHAR g_szOldWndProc[] = _T("CLADMWIZ_OldWndProc");
TCHAR g_szThreadObj[] = _T("CLADMWIZ_ThreadObj");

/////////////////////////////////////////////////////////////////////////////
// class CWorkerThread
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::CreateThread
//
//	Routine Description:
//		Create the thread.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any error values returned by CreateMutex(), CreateEvent(), or
//		CreateThread().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWorkerThread::CreateThread( void )
{
	ATLASSERT( m_hThread == NULL );
	ATLASSERT( m_hMutex == NULL );
	ATLASSERT( m_hInputEvent == NULL );
	ATLASSERT( m_hOutputEvent == NULL );
	ATLASSERT( m_idThread == 0 );

	DWORD	_sc = ERROR_SUCCESS;

	// Loop to avoid goto's.
	do
	{
		//
		// Create the mutex.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateMutex()\n") );
		m_hMutex = CreateMutex(
						NULL,	// lpMutexAttributes
						FALSE,	// bInitialOwner
						NULL	// lpName
						);
		if ( m_hMutex == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the mutex

		//
		// Create the input event.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateEvent() for input event\n") );
		m_hInputEvent = CreateEvent(
							NULL,	// lpEventAttributes
							TRUE,	// bManualReset
							FALSE,	// bInitialState
							NULL	// lpName
							);
		if ( m_hInputEvent == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the input event

		//
		// Create the output event.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateEvent() for output event\n") );
		m_hOutputEvent = CreateEvent(
							NULL,	// lpEventAttributes
							TRUE,	// bManualReset
							FALSE,	// bInitialState
							NULL	// lpName
							);
		if ( m_hOutputEvent == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the output event

		//
		// Create the thread.
		//
		ATLTRACE( _T("CWorkerThread::CreateThread() - Calling CreateThread()\n") );
		m_hThread = reinterpret_cast< HANDLE >( _beginthreadex(
						NULL,			// security
						0,				// stack_size
						S_ThreadProc,	// start_address,
						(LPVOID) this,	// arglist
						0,				// initflag
						&m_idThread		// thrdaddr
						) );
		if ( m_hThread == NULL )
		{
			_sc = GetLastError();
			break;
		}  // if:  error creating the thread

	} while ( 0 );

	//
	// Handle errors by cleaning up objects we created.
	//
	if ( _sc != ERROR_SUCCESS )
	{
		Cleanup();
	} // if:  error occurred

	return _sc;

} //*** CWorkerThread::CreateThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::PrepareWindowToWait
//
//	Routine Description:
//		Prepare to wait for a long operation.  This involves disabling the
//		window and displaying a wait cursor.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWorkerThread::PrepareWindowToWait( IN HWND hwnd )
{
	m_hCurrentCursor = GetCursor();

	if ( hwnd != NULL )
	{
		//
		// Subclass the window procedure so we can set the cursor properly.
		//
		m_pfnOldWndProc = reinterpret_cast< WNDPROC >( GetWindowLongPtr( hwnd, GWLP_WNDPROC ) );
		SetProp( hwnd, g_szOldWndProc, m_pfnOldWndProc );
		SetProp( hwnd, g_szThreadObj, this );
		SetWindowLongPtr( hwnd, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( S_ParentWndProc ) );

		//
		// Disable property sheet and wizard buttons.
		//
		EnableWindow( hwnd, FALSE );

	} // if:  parent window specified

} //*** CWorkerThread::PrepareWindowToWait()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::CleanupWindowAfterWait
//
//	Routine Description:
//		Prepare to wait for a long operation.  This involves disabling the
//		window and displaying a wait cursor.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWorkerThread::CleanupWindowAfterWait( IN HWND hwnd )
{
	if ( hwnd != NULL )
	{
		//
		// Unsubclass the window procedure.
		//
		SetWindowLongPtr( hwnd, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( m_pfnOldWndProc ) );
		m_pfnOldWndProc = NULL;
		RemoveProp( hwnd, g_szOldWndProc );
		RemoveProp( hwnd, g_szThreadObj );

		//
		// Re-enable property sheet and wizard buttons.
		//
		EnableWindow( hwnd, TRUE );
	} // if:  parent window specified

	m_hCurrentCursor = NULL;

} //*** CWorkerThread::CleanupWindowAfterWait()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::CallThreadFunction
//
//	Routine Description:
//		Call a function supported by the thread.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//		nFunction	[IN] Code representing the function to perform.
//		pvParam1	[IN OUT] Parameter 1 with function-specific data.
//		pvParam2	[IN OUT] Parameter 2 with function-specific data.
//
//	Return Value:
//		Any error values returned by AtlWaitWithMessageLoop() or PulseEvent().
//		Status return from the function.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWorkerThread::CallThreadFunction(
	IN HWND			hwnd,
	IN LONG			nFunction,
	IN OUT PVOID	pvParam1,	// = NULL,
	IN OUT PVOID	pvParam2	// = NULL
	)
{
	ATLASSERT( m_hThread != NULL );			// Thread must already be created.
	ATLASSERT( m_hMutex != NULL );			// Mutex must already be created.
	ATLASSERT( m_hInputEvent != NULL );		// Input event must already be created.
	ATLASSERT( m_hOutputEvent != NULL );	// Output event must already be created.
	ATLASSERT( m_pfnOldWndProc == NULL );	// Parent window not already subclassed.

	DWORD		_sc;
	CWaitCursor	_wc;

	//
	// Prepare the window to wait for the thread operation.
	//
	PrepareWindowToWait( hwnd );

	// Loop to avoid goto's.
	do
	{
		//
		// Wait for the thread to become available.
		//
		ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Waiting on mutex\n") );
		if ( ! AtlWaitWithMessageLoop( m_hMutex ) )
		{
			_sc = GetLastError();
			break;
		}  // if:  error waiting on the mutex

		// Loop to avoid using goto's.
		do
		{
			//
			// Pass this caller's data to the thread.
			//
			ATLASSERT( m_nFunction == 0 );
			ATLASSERT( m_pvParam1 == NULL );
			ATLASSERT( m_pvParam2 == NULL );
			ATLASSERT( m_dwOutputStatus == ERROR_SUCCESS );
			m_nFunction = nFunction;
			m_pvParam1 = pvParam1;
			m_pvParam2 = pvParam2;

			//
			// Signal the thread that there is work to do.
			//
			ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Setting input event\n") );
			if ( ! SetEvent( m_hInputEvent ) )
			{
				_sc = GetLastError();
				break;
			}  // if:  error pulsing the event

			//
			// Wait for the thread to complete the function.
			//
			ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Waiting on output event\n") );
			if ( ! AtlWaitWithMessageLoop( m_hOutputEvent ) )
			{
				_sc = GetLastError();
				break;
			}  // if:  error waiting for the event
			ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Resetting output event\n") );
			ResetEvent( m_hOutputEvent );

			//
			// Retrieve the results of the function to return
			// to the caller.
			//
			_sc = m_dwOutputStatus;

			//
			// Clear input parameters.
			//
			m_nFunction = WTF_NONE;
			m_pvParam1 = NULL;
			m_pvParam2 = NULL;
			m_dwOutputStatus = ERROR_SUCCESS;

		} while ( 0 );

		ATLTRACE( _T("CWorkerThread::CallThreadFunction() - Releasing mutex\n") );
		ReleaseMutex( m_hMutex );

	} while ( 0 );

	//
	// Cleanup windows after the wait operation.
	//
	CleanupWindowAfterWait( hwnd );

	return _sc;

} //*** CWorkerThread::CallThreadFunction()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWorkerThread::WaitForThreadToExit
//
//	Routine Description:
//		Wait for the thread to exit.
//
//	Arguments:
//		hwnd		[IN] Handle for the window to disable while the
//						operation is being performed.
//
//	Return Value:
//		ERROR_SUCCESS	Operation completed successfully.
//		Any error values returned by AtlWaitWithMessageLoop().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWorkerThread::WaitForThreadToExit( IN HWND hwnd )
{
	ATLASSERT( m_hThread != NULL );			// Thread must already be created.

	DWORD		_sc = ERROR_SUCCESS;
	CWaitCursor	_wc;

	//
	// Prepare the window to wait for the thread operation.
	//
	PrepareWindowToWait( hwnd );

	//
	// Wait for the thread to exit.
	//
	AtlWaitWithMessageLoop( m_hThread );
	if ( ! AtlWaitWithMessageLoop( m_hThread ) )
	{
		_sc = GetLastError();
	}  // if:  error waiting for the thread to exit

	//
	// Cleanup windows after the wait operation.
	//
	CleanupWindowAfterWait( hwnd );

	return _sc;

} //*** CWorkerThread::WaitForThreadToExit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	static
//	CWorkerThread::S_ParentWndProc
//
//	Routine Description:
//		Static parent window procedure.  This procedure handles the
//		WM_SETCURSOR message while the thread is processing a request.
//
//	Arguments:
//		hwnd		[IN] Identifies the window.
//		uMsg		[IN] Specifies the message.
//		wParam		[IN] Specifies additional information based on uMsg.
//		lParam		[IN] Specifies additional information based on uMsg.
//
//	Return Value:
//		The result of the message processing.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT WINAPI CWorkerThread::S_ParentWndProc(
	IN HWND		hwnd,
	IN UINT		uMsg,
	IN WPARAM	wParam,
	IN LPARAM	lParam
	)
{
	LRESULT			lResult = 0;
	CWorkerThread * pthread = reinterpret_cast< CWorkerThread * >( GetProp( hwnd, g_szThreadObj ) );

	ATLASSERT( pthread != NULL );

	if ( pthread != NULL )
	{
		if ( uMsg == WM_SETCURSOR )
		{
			if ( GetCursor() != pthread->m_hCurrentCursor )
			{
				SetCursor( pthread->m_hCurrentCursor );
			} // if:  cursor is different
			lResult = TRUE;
		} // if:  set cursor message
		else
		{
			lResult = (*pthread->m_pfnOldWndProc)( hwnd, uMsg, wParam, lParam );
		} // else:	other message
	} // if: thread is non-null

	return lResult;

} //*** CWorkerThread::S_ParentWndProc()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	static
//	CWorkerThread::S_ThreadProc
//
//	Routine Description:
//		Static thread procedure.
//
//	Arguments:
//		pvThis		[IN OUT] this pointer for the CWorkerThread instance.
//
//	Return Value:
//		None (ignored).
//
//--
/////////////////////////////////////////////////////////////////////////////
UINT __stdcall CWorkerThread::S_ThreadProc( IN OUT LPVOID pvThis )
{
	ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Beginning thread\n") );

	DWORD			_sc;
	LONG			_nFunction;
	CWorkerThread * _pThis = reinterpret_cast< CWorkerThread * >( pvThis );

	ATLASSERT( pvThis != NULL );
	ATLASSERT( _pThis->m_hMutex != NULL );
	ATLASSERT( _pThis->m_hInputEvent != NULL );
	ATLASSERT( _pThis->m_hOutputEvent != NULL );

	do
	{
		//
		// Wait for work.
		//
		ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Waiting on input event\n") );
		_sc = WaitForSingleObject( _pThis->m_hInputEvent, INFINITE );
		if ( _sc == WAIT_FAILED )
		{
			_sc = GetLastError();
			break;
		}  // if:  error waiting for the event
		ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Resetting input event\n") );
		ResetEvent( _pThis->m_hInputEvent );

		//
		// Handle the exit request.
		//
		if ( _pThis->m_nFunction == WTF_EXIT )
		{
			_pThis->m_bThreadExiting =  TRUE;
		} // if:  exiting
		else
		{
			//
			// Call the function handler.
			//
			ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Calling thread function handler\n") );
			ATLASSERT( _pThis->m_nFunction != 0 );
			_pThis->m_dwOutputStatus = _pThis->ThreadFunctionHandler(
												_pThis->m_nFunction,
												_pThis->m_pvParam1,
												_pThis->m_pvParam2
												);
		} // else:  not exiting

		//
		// Save locally data that we need to access once we have signalled
		// the caller's event.  If we don't do this, we won't be referencing
		// the proper function code after that point.
		//
		_nFunction = _pThis->m_nFunction;

		//
		// Signal the calling thread that the work has been completed.
		//
		ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Setting output event\n") );
		if ( ! SetEvent( _pThis->m_hOutputEvent ) )
		{
			_sc = GetLastError();
			break;
		}  // if:  error pulsing

		//
		// Set the status in case we are exiting.
		//
		_sc = ERROR_SUCCESS;

	} while ( _nFunction != WTF_EXIT );

	ATLTRACE( _T("CWorkerThread::S_ThreadProc() - Exiting thread\n") );
//	Sleep( 10000 ); // Test thread synchronization
	return _sc;

} //*** CWorkerThread::S_ThreadProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Cot();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Description:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Implementation File:
//		BasePage.cpp
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__

#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"		// for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN const DWORD *	pdwWizardHelpMap,
		IN UINT				nIDCaption = 0
		);
	virtual ~CBasePropertyPage(void) { }

	// Second phase construction.
	virtual BOOL			BInit(IN OUT CExtObject * peo);
	BOOL					BCreateParamsKey(void);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	CExtObject *			m_peo;
	HPROPSHEETPAGE			m_hpage;

	IDD						m_iddPropertyPage;
	IDD						m_iddWizardPage;
	IDS						m_idsCaption;

	CExtObject *			Peo(void) const					{ return m_peo; }
	HPROPSHEETPAGE			Hpage(void) const				{ return m_hpage; }

	IDD						IddPropertyPage(void) const		{ return m_iddPropertyPage; }
	IDD						IddWizardPage(void) const		{ return m_iddWizardPage; }
	IDS						IdsCaption(void) const			{ return m_idsCaption; }

public:
	void					SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }
	CLUADMEX_OBJECT_TYPE	Cot(void) const;

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual DWORD			DwParseUnknownProperty(
								IN LPCWSTR							pwszName,
								IN const CLUSPROP_BUFFER_HELPER &	rvalue,
								IN DWORD							cbBuf
								)		
                                { 
                                    UNREFERENCED_PARAMETER( pwszName );
                                    UNREFERENCED_PARAMETER( rvalue );
                                    UNREFERENCED_PARAMETER( cbBuf );
                                    return ERROR_SUCCESS; 
                                }
	virtual BOOL			BApplyChanges(void);
	virtual void			BuildPropList(IN OUT CClusPropList & rcpl);

	virtual const CObjectProperty *	Pprops(void) const	{ return NULL; }
	virtual DWORD					Cprops(void) const	{ return 0; }

// Implementation
protected:
	BOOL					m_bBackPressed;
	const DWORD *			m_pdwWizardHelpMap;
	BOOL					m_bDoDetach;

	BOOL					BBackPressed(void) const		{ return m_bBackPressed; }
	BOOL					BWizard(void) const;
	HCLUSTER				Hcluster(void) const;

	DWORD					DwParseProperties(IN const CClusPropList & rcpl);
	DWORD					DwSetCommonProps(IN const CClusPropList & rcpl);

	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Description:
//      Implementation of the CBasePropertyPage class.
//
//  Maintained By:
//      David Potter (DavidP) Mmmm DD, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <clusapi.h>
#include "DebugEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      idd                 [IN] Dialog template resource ID.
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//      nIDCaption          [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap,
    IN UINT             nIDCaption
    )
    : CPropertyPage(idd, nIDCaption)
    , m_dlghelp(pdwHelpMap, idd)
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idsCaption = NULL;

    m_pdwWizardHelpMap = NULL;

    m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
    ASSERT(peo != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    m_peo = peo;

    // Change the help map if this is a wizard page.
    if (Peo()->BWizard())
        m_dlghelp.SetMap(m_pdwWizardHelpMap);

    // Don't display a help button.
    m_psp.dwFlags &= ~PSP_HASHELP;

    // Construct the property page.
    if (Peo()->BWizard())
    {
        ASSERT(IddWizardPage() != NULL);
        Construct(IddWizardPage(), IdsCaption());
        m_dlghelp.SetHelpMask(IddWizardPage());
    }  // if:  adding page to wizard
    else
    {
        ASSERT(IddPropertyPage() != NULL);
        Construct(IddPropertyPage(), IdsCaption());
        m_dlghelp.SetHelpMask(IddPropertyPage());
    }  // else:  adding page to property sheet

    // Read the properties common to this resource and parse them.
    {
        DWORD           dwStatus;
        CClusPropList   cpl;

        // Read the properties.
        ASSERT(Peo() != NULL);

        if (Peo()->PodObjData()->m_cot == CLUADMEX_OT_RESOURCE)
        {
            ASSERT(Peo()->PrdResData() != NULL);
            ASSERT(Peo()->PrdResData()->m_hresource != NULL);
            dwStatus = cpl.ScGetResourceProperties(
                                    Peo()->PrdResData()->m_hresource,
                                    CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES
                                    );
        }  // if:  resource object
        else
        {
            ASSERT(Peo()->PodObjData() != NULL);
            ASSERT(Peo()->PodObjData()->m_strName.GetLength() != 0);
            dwStatus = cpl.ScGetResourceTypeProperties(
                                    Hcluster(),
                                    Peo()->PodObjData()->m_strName,
                                    CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                                    );
        }  // else:  resource type object

        // Parse the properties.
        if (dwStatus == ERROR_SUCCESS)
        {
            // Parse the properties.
            try
            {
                dwStatus = DwParseProperties(cpl);
            }  // try
            catch (CMemoryException * pme)
            {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties read successfully

        if (dwStatus != ERROR_SUCCESS)
        {
            return FALSE;
        }  // if:  error parsing getting or parsing properties
    }  // Read the properties private to this resource and parse them

    return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from BInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN const CClusPropList & rcpl)
{
    DWORD                           cProps;
    DWORD                           cprop;
    DWORD                           cbProps;
    const CObjectProperty *         pprop;
    CLUSPROP_BUFFER_HELPER          props;
    CLUSPROP_PROPERTY_NAME const *  pName;

    ASSERT(rcpl.PbPropList() != NULL);

    props.pb = rcpl.PbPropList();
    cbProps = static_cast< DWORD >( rcpl.CbPropList() );

    // Loop through each property.
    for (cProps = *(props.pdw++) ; cProps > 0 ; cProps--)
    {
        pName = props.pName;
        ASSERT(pName->Syntax.dw == CLUSPROP_SYNTAX_NAME);
        props.pb += sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

        // Decrement the counter by the size of the name.
        ASSERT(cbProps > sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength));
        cbProps -= sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

        ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));

        // Parse known properties.
        for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
        {
            if (lstrcmpiW(pName->sz, pprop->m_pwszName) == 0)
            {
                ASSERT(props.pSyntax->wFormat == pprop->m_propFormat);
                switch (pprop->m_propFormat)
                {
                    case CLUSPROP_FORMAT_SZ:
                        ASSERT((props.pValue->cbLength == (lstrlenW(props.pStringValue->sz) + 1) * sizeof(WCHAR))
                                || ((props.pValue->cbLength == 0) && (props.pStringValue->sz[0] == L'\0')));
                        *pprop->m_value.pstr = props.pStringValue->sz;
                        *pprop->m_valuePrev.pstr = props.pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT(props.pValue->cbLength == sizeof(DWORD));
                        *pprop->m_value.pdw = props.pDwordValue->dw;
                        *pprop->m_valuePrev.pdw = props.pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        *pprop->m_value.ppb = props.pBinaryValue->rgb;
                        *pprop->m_value.pcb = props.pBinaryValue->cbLength;
                        *pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
                        *pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT(0);  // don't know how to deal with this type
                }  // switch:  property format

                // Exit the loop since we found the parameter.
                break;
            }  // if:  found a match
        }  // for:  each property

        // If the property wasn't known, ask the derived class to parse it.
        if (cprop == 0)
        {
            DWORD       dwStatus;

            dwStatus = DwParseUnknownProperty(pName->sz, props, cbProps);
            if (dwStatus != ERROR_SUCCESS)
                return dwStatus;
        }  // if:  property not parsed

        // Advance the buffer pointer past the value in the value list.
        while ((props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
                && (cbProps > 0))
        {
            ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));
            cbProps -= sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
            props.pb += sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
        }  // while:  more values in the list

        // Advance the buffer pointer past the value list endmark.
        ASSERT(cbProps >= sizeof(*props.pSyntax));
        cbProps -= sizeof(*props.pSyntax);
        props.pb += sizeof(*props.pSyntax); // endmark
    }  // for:  each property

    return ERROR_SUCCESS;

}  //*** CBasePropertyPage::DwParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCreate
//
//  Routine Description:
//      Handler for the WM_CREATE message.
//
//  Arguments:
//      lpCreateStruct  [IN OUT] Window create structure.
//
//  Return Value:
//      -1      Error.
//      0       Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Attach the window to the property page structure.
    // This has been done once already in the main application, since the
    // main application owns the property sheet.  It needs to be done here
    // so that the window handle can be found in the DLL's handle map.
    if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
    {
        HWND hWnd = m_hWnd;
        m_hWnd = NULL;
        Attach(hWnd);
        m_bDoDetach = TRUE;
    } // if: is the window handle in the handle map

    return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Detach the window from the property page structure.
    // This will be done again by the main application, since it owns the
    // property sheet.  It needs to be done here so that the window handle
    // can be removed from the DLL's handle map.
    if (m_bDoDetach)
    {
        if (m_hWnd != NULL)
        {
            HWND hWnd = m_hWnd;

            Detach();
            m_hWnd = hWnd;
        } // if: do we have a window handle?
    } // if: do we need to balance the attach we did with a detach?

    CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //{{AFX_DATA_MAP(CBasePropertyPage)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
    DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
    DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

    if (!pDX->m_bSaveAndValidate)
    {
        // Set the title.
        DDX_Text(pDX, IDC_PP_TITLE, m_strTitle);
    }  // if:  not saving data

    CPropertyPage::DoDataExchange(pDX);

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
    ASSERT(Peo() != NULL);
    ASSERT(Peo()->PodObjData() != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Set the title string.
    m_strTitle = Peo()->PodObjData()->m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if (Peo()->Hicon() != NULL)
        m_staticIcon.SetIcon(Peo()->Hicon());

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
    HRESULT     hr;

    ASSERT(Peo() != NULL);
    ASSERT(Peo()->PodObjData() != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Reread the data.
    hr = Peo()->HrGetObjectInfo();
    if (hr != NOERROR)
        return FALSE;

    // Set the title string.
    m_strTitle = Peo()->PodObjData()->m_strName;

    m_bBackPressed = FALSE;
    return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
    ASSERT(!BWizard());

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    // Update the data in the class from the page.
    if (!UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    if (!BApplyChanges())
        return FALSE;

    return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Routine Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
    DWORD           dwStatus    = ERROR_SUCCESS;
    CClusPropList   cpl(BWizard() /*bAlwaysAddProp*/);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    // Save data.
    {
        // Build the property list.
        try
        {
            BuildPropList(cpl);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }  // catch:  CMemoryException

        // Set the data.
        if (dwStatus == ERROR_SUCCESS)
            dwStatus = DwSetCommonProps(cpl);

        // Handle errors.
        if (dwStatus != ERROR_SUCCESS)
        {
            CString     strError;
            CString     strMsg;

            AFX_MANAGE_STATE(AfxGetStaticModuleState());

            FormatError(strError, dwStatus);
            if (dwStatus == ERROR_RESOURCE_PROPERTIES_STORED)
            {
                AfxMessageBox(strError, MB_OK | MB_ICONEXCLAMATION);
                dwStatus = ERROR_SUCCESS;
            }  // if:  properties were stored
            else
            {
                strMsg.FormatMessage(IDS_APPLY_PARAM_CHANGES_ERROR, strError);
                AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }  // else:  error setting properties.
        }  // if:  error setting properties

        if (dwStatus == ERROR_SUCCESS)
        {
            // Save new values as previous values.
            try
            {
                DWORD                   cprop;
                const CObjectProperty * pprop;

                for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
                {
                    switch (pprop->m_propFormat)
                    {
                        case CLUSPROP_FORMAT_SZ:
                            ASSERT(pprop->m_value.pstr != NULL);
                            ASSERT(pprop->m_valuePrev.pstr != NULL);
                            *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                            break;
                        case CLUSPROP_FORMAT_DWORD:
                            ASSERT(pprop->m_value.pdw != NULL);
                            ASSERT(pprop->m_valuePrev.pdw != NULL);
                            *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                            break;
                        case CLUSPROP_FORMAT_BINARY:
                        case CLUSPROP_FORMAT_MULTI_SZ:
                            ASSERT(pprop->m_value.ppb != NULL);
                            ASSERT(*pprop->m_value.ppb != NULL);
                            ASSERT(pprop->m_value.pcb != NULL);
                            ASSERT(pprop->m_valuePrev.ppb != NULL);
                            ASSERT(*pprop->m_valuePrev.ppb != NULL);
                            ASSERT(pprop->m_valuePrev.pcb != NULL);
                            delete [] *pprop->m_valuePrev.ppb;
                            *pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
                            CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
                            *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                            break;
                        default:
                            ASSERT(0);  // don't know how to deal with this type
                    }  // switch:  property format
                }  // for:  each property
            }  // try
            catch (CMemoryException * pme)
            {
                pme->ReportError();
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  properties set successfully
    }  // Save data

    return TRUE;

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
    IN OUT CClusPropList & rcpl
    )
{
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
    {
        switch (pprop->m_propFormat)
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT(0);  // don't know how to deal with this type
                return;
        }  // switch:  property format
    }  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DwSetCommonProps
//
//  Routine Description:
//      Set the private properties for this object.
//
//  Arguments:
//      rcpl        [IN] Property list to set on the object.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwSetCommonProps(
    IN const CClusPropList &    rcpl
    )
{
    DWORD       dwStatus;
    DWORD       cbProps;

    ASSERT(Peo() != NULL);
    ASSERT(Peo()->PrdResData());
    ASSERT(Peo()->PrdResData()->m_hresource);

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        // Set private properties.
        if (Cot() == CLUADMEX_OT_RESOURCE)
            dwStatus = ClusterResourceControl(
                            Peo()->PrdResData()->m_hresource,
                            NULL,   // hNode
                            CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
                            rcpl.PbPropList(),
                            static_cast< DWORD >( rcpl.CbPropList() ),
                            NULL,   // lpOutBuffer
                            0,      // nOutBufferSize
                            &cbProps
                            );
        else
            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            Peo()->PodObjData()->m_strName,
                            NULL,   // hNode
                            CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES,
                            rcpl.PbPropList(),
                            static_cast< DWORD >( rcpl.CbPropList() ),
                            NULL,   // lpOutBuffer
                            0,      // nOutBufferSize
                            &cbProps
                            );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CBasePropertyPage::DwSetCommonProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
    BOOL    bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
    if (!bProcessed)
        bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
    return bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    LRESULT lProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    lProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
    if (!lProcessed)
        lProcessed = CPropertyPage::OnCommandHelp(wParam, lParam);

    return lProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\debugex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DebugEx.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		DebugEx.cpp
//
//	Author:
//		David Potter (davidp) September 19, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DEBUGEX_H_
#define _DEBUGEX_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_PARAMETERS			L"Parameters"
#define REGPARAM_DEBUG_PREFIX	    L"DebugPrefix"
#define REGPARAM_SEPARATE_MONITOR	L"SeparateMonitor"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

/////////////////////////////////////////////////////////////////////////////

#endif // _DEBUGEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\regexts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExtS.cpp
//
//	Abstract:
//		Stub for implementation of extension registration classes.
//
//	Author:
//		David Potter (davidp)	May 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegExt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ExtObj.cpp
//
//  Description:
//      Implementation of the CExtObject class, which implements the
//      extension interfaces required by a Microsoft Windows NT Cluster
//      Administrator Extension DLL.
//
//  Maintained By:
//      David Potter (DavidP) Mmmm DD, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DebugEx.h"
#include "ExtObj.h"
#include "ResProp.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static CRuntimeClass * g_rgprtcResPSPages[] = {
    RUNTIME_CLASS(CDebugParamsPage),
    NULL
    };
static CRuntimeClass ** g_rgpprtcResPSPages[]   = {
    g_rgprtcResPSPages,
    };
static CRuntimeClass * g_rgprtcResTypePSPages[] = {
    RUNTIME_CLASS(CDebugParamsPage),
    NULL
    };
static CRuntimeClass ** g_rgpprtcResTypePSPages[]   = {
    g_rgprtcResTypePSPages,
    };

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CExtObject
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
    m_piData = NULL;
    m_bWizard = FALSE;
    m_istrResTypeName = 0;

    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;
    m_hcluster = NULL;
    m_cobj = 0;
    m_podObjData = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::~CExtObject
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
    // Release the data interface.
    if (PiData() != NULL)
    {
        PiData()->Release();
        m_piData = NULL;
    }  // if:  we have a data interface pointer

    // Delete the pages.
    {
        POSITION    pos;

        pos = Lpg().GetHeadPosition();
        while (pos != NULL)
            delete Lpg().GetNext(pos);
    }  // Delete the pages

    delete m_podObjData;

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//  Routine Description:
//      Indicates whether an interface suportes the IErrorInfo interface.
//      This interface is provided by ATL.
//
//  Arguments:
//      riid        Interface ID.
//
//  Return Value:
//      S_OK        Interface supports IErrorInfo.
//      S_FALSE     Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * rgiid[] = 
    {
        &IID_IWEExtendPropertySheet,
    };
    int     iiid;

    for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
    {
        if (InlineIsEqualGUID(*rgiid[iiid], riid))
            return S_OK;
    }
    return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//  Routine Description:
//      Create property sheet pages and add them to the sheet.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the sheet is being displayed.
//      piCallback      Pointer to an IWCPropertySheetCallback interface
//                          for adding pages to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
    IN IUnknown *                   piData,
    IN IWCPropertySheetCallback *   piCallback
    )
{
    HRESULT             hr      = NOERROR;
    HPROPSHEETPAGE      hpage   = NULL;
    CException          exc(FALSE /*bAutoDelete*/);
    CRuntimeClass **    pprtc   = NULL;
    int                 irtc;
    CBasePropertyPage * ppage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try 
    {
        // Get info about displaying UI.
        hr = HrGetUIInfo(piData);
        if (hr != NOERROR)
            throw &exc;

        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while (pos != NULL)
                delete Lpg().GetNext(pos);
            Lpg().RemoveAll();
        }  // Delete any previous pages

        // Create property pages.
        ASSERT(PodObjData() != NULL);
        switch (PodObjData()->m_cot)
        {
            case CLUADMEX_OT_RESOURCE:
                pprtc = g_rgpprtcResPSPages[0];
                break;
            case CLUADMEX_OT_RESOURCETYPE:
                pprtc = g_rgpprtcResTypePSPages[0];
                break;
            default:
                hr = E_NOTIMPL;
                throw &exc;
                break;
        }  // switch:  object type

        // Create each page.
        for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
        {
            // Create the page.
            ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
            ASSERT(ppage->IsKindOf(pprtc[irtc]));

            // Add it to the list.
            Lpg().AddTail(ppage);

            // Initialize the property page.
            if (!ppage->BInit(this))
                throw &exc;

            // Create the page.
            hpage = ::CreatePropertySheetPage(&ppage->m_psp);
            if (hpage == NULL)
                throw &exc;

            // Save the hpage in the page itself.
            ppage->SetHpage(hpage);

            // Add it to the property sheet.
            hr = piCallback->AddPropertySheetPage((LONG *) hpage);
            if (hr != NOERROR)
                throw &exc;
        }  // for:  each page in the list

    }  // try
    catch (CMemoryException * pme)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  anything
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  anything

    if (hr != NOERROR)
    {
        if (hpage != NULL)
            ::DestroyPropertySheetPage(hpage);
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    piCallback->Release();
    return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetUIInfo
//
//  Routine Description:
//      Get info about displaying UI.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
    HRESULT         hr  = NOERROR;

    ASSERT(piData != NULL);

    // Save info about all types of objects.
    {
        IGetClusterUIInfo * pi;

        hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
        if (hr != NOERROR)
            return hr;

        m_lcid = pi->GetLocale();
        m_hfont = pi->GetFont();
        m_hicon = pi->GetIcon();

        pi->Release();
    }  // Save info about all types of objects

    return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrSaveData
//
//  Routine Description:
//      Save data from the object so that it can be used for the life
//      of the object.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
    HRESULT         hr  = NOERROR;

    ASSERT(piData != NULL);

    if (piData != m_piData)
    {
        if (m_piData != NULL)
            m_piData->Release();
        m_piData = piData;
    }  // if:  different data interface pointer

    // Save info about all types of objects.
    {
        IGetClusterDataInfo *   pi;

        hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
        if (hr != NOERROR)
            return hr;

        m_hcluster = pi->GetClusterHandle();
        m_cobj = pi->GetObjectCount();
        if (Cobj() != 1)    // Only have support for one selected object.
            hr = E_NOTIMPL;

        pi->Release();
        if (hr != NOERROR)
            return hr;
    }  // Save info about all types of objects

    // Save info about this object.
    hr = HrGetObjectInfo();
    if (hr != NOERROR)
        return hr;

    return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectInfo
//
//  Routine Description:
//      Get information about the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
    HRESULT                     hr  = NOERROR;
    IGetClusterObjectInfo *     piGcoi;
    CLUADMEX_OBJECT_TYPE        cot;
    CException                  exc(FALSE /*bAutoDelete*/);

    ASSERT(PiData() != NULL);

    // Get object info.
    {
        // Get an IGetClusterObjectInfo interface pointer.
        hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
        if (hr != NOERROR)
            return hr;

        // Read the object data.
        try
        {
            // Delete the previous object data.
            delete m_podObjData;
            m_podObjData = NULL;

            // Get the type of the object.
            cot = piGcoi->GetObjectType(0);
            switch (cot)
            {
                case CLUADMEX_OT_RESOURCE:
                    {
                        IGetClusterResourceInfo *   pi;

                        m_podObjData = new CResData;

                        // Get an IGetClusterResourceInfo interface pointer.
                        hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &pi);
                        if (hr != NOERROR)
                            throw &exc;

                        PrdResDataRW()->m_hresource = pi->GetResourceHandle(0);
                        hr = HrGetResourceTypeName(pi);
                        pi->Release();
                        if (hr != NOERROR)
                            throw &exc;
                    }  // if:  object is a node
                    break;
                case CLUADMEX_OT_RESOURCETYPE:
                    m_podObjData = new CObjData;
                    break;
                default:
                    hr = E_NOTIMPL;
                    throw &exc;
            }  // switch:  object type

            PodObjDataRW()->m_cot = cot;
            hr = HrGetObjectName(piGcoi);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException

        piGcoi->Release();
        if (hr != NOERROR)
            return hr;
    }  // Get object info

    return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectName
//
//  Routine Description:
//      Get the name of the object.
//
//  Arguments:
//      piData          IGetClusterObjectInfo interface pointer for getting
//                          the object name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
    IN OUT IGetClusterObjectInfo *  pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;
    BSTR        bstr        = NULL;

    ASSERT(pi != NULL);

    hr = pi->GetObjectName(0, NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    bstr = SysAllocStringLen( NULL, cchName );
    if ( bstr != NULL )
    {
        try
        {
            hr = pi->GetObjectName(0, bstr, &cchName);
            if (hr == NOERROR)
            {
                pwszName = new WCHAR[cchName];
                hr = StringCchCopyNW( pwszName, cchName, bstr, SysStringLen( bstr ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }

            PodObjDataRW()->m_strName = pwszName;
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        }  // catch:  CMemoryException
    } // if: ( bstr != NULL )
    else
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:

    delete [] pwszName;
    SysFreeString( bstr );
    return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetResourceTypeName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      piData          IGetClusterResourceInfo interface pointer for getting
//                          the resource type name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IGetClusterResourceInfo::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
    IN OUT IGetClusterResourceInfo *    pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;
    BSTR        bstr        = NULL;

    ASSERT(pi != NULL);

    hr = pi->GetResourceTypeName(0, NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    bstr = SysAllocStringLen( NULL, cchName );
    if ( bstr != NULL )
    {
        try
        {
            hr = pi->GetResourceTypeName(0, bstr, &cchName);
            if (hr == NOERROR)
            {
                pwszName = new WCHAR[cchName];
                hr = StringCchCopyNW( pwszName, cchName, bstr, SysStringLen( bstr ) );
                if ( FAILED( hr ) );
                {
                    goto Cleanup;
                }
            }

            PrdResDataRW()->m_strResTypeName = pwszName;
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        }  // catch:  CMemoryException
    } // if: ( bstr != NULL )
    else
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:

    delete [] pwszName;
    SysFreeString( bstr );
    return hr;

}  //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\helparr.h ===
#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_PP_RESOURCE_DEBUG_PAGE[]=
{
	IDC_PP_ICON,	((DWORD) -1),	// Debug: "" (Static)
	IDC_PP_DEBUG_DEBUGPREFIX_LABEL,	IDH_110_1071,	// Debug: "&Debug Command Prefix:" (Static)
	IDC_PP_TITLE,	((DWORD) -1),	// Debug: "" (Static)
	IDC_PP_DEBUG_DEBUGPREFIX,	IDH_110_1071,	// Debug: "" (Edit)
	IDC_PP_DEBUG_TEXT,	((DWORD) -1),	// Debug: "" (Static)
	0, 0
};




const DWORD g_a30721HelpIDs[]=
{
	0, 0
};



#else

extern const DWORD g_aHelpIDs_IDD_PP_RESOURCE_DEBUG_PAGE[];
extern const DWORD g_a30721HelpIDs[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\debugex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      DebugEx.cpp
//
//  Abstract:
//      Implementation of the CDebugexApp class and DLL initialization
//      routines.
//
//  Author:
//      David Potter (davidp) September 19, 1996
//
//  Revision History:
//
//  Notes:
//      NOTE: You must use the MIDL compiler from NT 4.0,
//      version 3.00.44 or greater
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "DebugEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning( push )
#pragma warning( disable : 4701 ) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning( pop )

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CoDebugEx, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CDebugexApp
/////////////////////////////////////////////////////////////////////////////

class CDebugexApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
// The one and only CDebugexApp object

CDebugexApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDebugexApp::InitInstance
//
//  Routine Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugexApp::InitInstance(void)
{
    _Module.Init(ObjectMap, m_hInstance);

    // Construct the help path.
    {
        TCHAR   szPath[_MAX_PATH];
        TCHAR   szDrive[_MAX_PATH];
        TCHAR   szDir[_MAX_DIR];
        size_t  cchPath;
        DWORD   sc;
        
        VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
        cchPath = _tcslen(szPath);
        if (szPath[cchPath - 1] != _T('\\'))
        {
            szPath[cchPath++] = _T('\\');
            szPath[cchPath] = _T('\0');
        } // if: no backslash on the end of the path
        sc = StringCchCopy( &szPath[ cchPath ], RTL_NUMBER_OF( szPath ) - cchPath, _T("Help\\") );
        _tsplitpath(szPath, szDrive, szDir, NULL, NULL);
        _tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
        free((void *) m_pszHelpFilePath);
        BOOL bEnable;
        bEnable = AfxEnableMemoryTracking(FALSE);
        m_pszHelpFilePath = _tcsdup(szPath);
        AfxEnableMemoryTracking(bEnable);
    }  // Construct the help path

    return CWinApp::InitInstance();

}  //*** CDebugexApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDebugexApp::ExitInstance
//
//  Routine Description:
//      Deinitialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CDebugexApp::ExitInstance(void)
{
    _Module.Term();
    return CWinApp::ExitInstance();

}  //*** CDebugexApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatError
//
//  Routine Description:
//      Format an error.
//
//  Arguments:
//      rstrError   [OUT] String in which to return the error message.
//      dwError     [IN] Error code to format.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
    DWORD   _cch;
    TCHAR   _szError[512];

    _cch = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    _szError,
                    sizeof(_szError) / sizeof(TCHAR),
                    0
                    );
    if (_cch == 0)
    {
        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ::GetModuleHandle(_T("NTDLL.DLL")),
                        dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                        _szError,
                        sizeof(_szError) / sizeof(TCHAR),
                        0
                        );
    }  // if:  error formatting status code from system

    if (_cch > 0)
    {
        rstrError = _szError;
    }  // if:  no error
    else
    {

#ifdef _DEBUG

        DWORD   _sc = GetLastError();

        TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

        rstrError.Format(_T("Error 0x%08.8x"), dwError);

    }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.RegisterServer(FALSE /*bRegTypeLib*/);
    return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.UnregisterServer();
    return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterCluAdminExtension
//
//  Routine Description:
//      Register the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
    HRESULT     hr;

    hr = RegisterCluAdminAllResourcesExtension(hCluster, &CLSID_CoDebugEx);
    if (hr == S_OK)
        hr = RegisterCluAdminAllResourceTypesExtension(hCluster, &CLSID_CoDebugEx);

    return hr;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterCluAdminExtension
//
//  Routine Description:
//      Unregister the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
    HRESULT     hr;

    hr = UnregisterCluAdminAllResourcesExtension(hCluster, &CLSID_CoDebugEx);
    if (hr == S_OK)
        hr = UnregisterCluAdminAllResourceTypesExtension(hCluster, &CLSID_CoDebugEx);

    return hr;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoDebugEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoDebugEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.DebugEx"), _T("CLUADMEX.DebugEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) m_podObjData; }

	CLUADMEX_OBJECT_TYPE		Cot(void) const					{ ASSERT(PodObjData() != NULL); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DebugEx.rc
//
#define IDD_PP_RESOURCE_DEBUG_PAGE      110
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_DEBUG_DEBUGPREFIX_LABEL  1070
#define IDC_PP_DEBUG_DEBUGPREFIX        1071
#define IDC_PP_DEBUG_TEXT               1072
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_NOT_IN_SEPARATE_MONITOR     31102
#define IDS_RESOURCE_TEXT               31103
#define IDS_RESOURCE_TYPE_TEXT          31104
#define IDS_MENU_WHATS_THIS             31105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\helpids.h ===
#define IDH_110_1071	70189166	// Debug: "" (Edit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      PropLstS.cpp
//
//  Abstract:
//      Stub for implementation of property list classes.
//
//  Author:
//      David Potter    (DavidP)   February 24, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ResProp.h
//
//	Description:
//		Definition of the resource extension property page classes.
//
//	Implementation File:
//		ResProp.cpp
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDebugParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CDebugParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CDebugParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CDebugParamsPage)

// Construction
public:
	CDebugParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CDebugParamsPage)
	enum { IDD = IDD_PP_RESOURCE_DEBUG_PAGE };
	CEdit	m_editPrefix;
	CString	m_strText;
	CString	m_strDebugPrefix;
	//}}AFX_DATA
	CString	m_strPrevDebugPrefix;
	BOOL	m_bPrevSeparateMonitor;
	BOOL	m_bSeparateMonitor;

protected:
	enum
	{
		epropDebugPrefix,
		epropSeparateMonitor,
		epropMAX
	};
	CObjectProperty		m_rgProps[epropMAX];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDebugParamsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual BOOL		BInit(IN OUT CExtObject * peo);
	virtual BOOL		BApplyChanges(void);
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return m_cprops; }

// Implementation
protected:
	DWORD		m_cprops;

	// Generated message map functions
	//{{AFX_MSG(CDebugParamsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDebugParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DebugEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE            // Microsoft Windows NT Cluster Administrator
                            //   Extension DLLs need to be Unicode
                            //   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <StrSafe.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT    IDS;
typedef UINT    IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ResProp.cpp
//
//	Description:
//		Implementation of the resource extension property page classes.
//
//	Maintained By:
//		David Potter (DavidP) Mmmm DD, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DebugEx.h"
#include "ResProp.h"
#include "ExtObj.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDebugParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CDebugParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CDebugParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CDebugParamsPage)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
	ON_EN_CHANGE(IDC_PP_DEBUG_DEBUGPREFIX, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::CDebugParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDebugParamsPage::CDebugParamsPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RESOURCE_DEBUG_PAGE, NULL)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CDebugParamsPage)
	m_strText = _T("");
	m_strDebugPrefix = _T("");
	//}}AFX_DATA_INIT

	m_cprops = 0;

	m_iddPropertyPage = IDD_PP_RESOURCE_DEBUG_PAGE;

}  //*** CDebugParamsPage::CDebugParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugParamsPage::BInit(IN OUT CExtObject * peo)
{
	ASSERT(peo != NULL);

	m_peo = peo;

	// Setup the property array.
	m_rgProps[epropDebugPrefix].Set(REGPARAM_DEBUG_PREFIX, m_strDebugPrefix, m_strPrevDebugPrefix);
	if (Cot() == CLUADMEX_OT_RESOURCE)
	{
		m_rgProps[epropSeparateMonitor].Set(REGPARAM_SEPARATE_MONITOR, m_bSeparateMonitor, m_bPrevSeparateMonitor);
		m_cprops = sizeof(m_rgProps) / sizeof(CObjectProperty);
	}  // if:  resource object
	else if (Cot() == CLUADMEX_OT_RESOURCETYPE)
		m_cprops = (sizeof(m_rgProps) / sizeof(CObjectProperty)) - 1;
	else
	{
		ASSERT(0);
		return FALSE;
	}  // else:  unsupport object type

	// Call the base class method.
	return CBasePropertyPage::BInit(peo);

}  //*** CDebugParamsPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDebugParamsPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CDebugParamsPage)
	DDX_Control(pDX, IDC_PP_DEBUG_DEBUGPREFIX, m_editPrefix);
	DDX_Text(pDX, IDC_PP_DEBUG_TEXT, m_strText);
	DDX_Text(pDX, IDC_PP_DEBUG_DEBUGPREFIX, m_strDebugPrefix);
	//}}AFX_DATA_MAP

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CDebugParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Load the help text.
	{
		UINT	ids;

		if (Cot() == CLUADMEX_OT_RESOURCE)
			ids = IDS_RESOURCE_TEXT;
		else
			ids = IDS_RESOURCE_TYPE_TEXT;
		m_strText.LoadString(ids);
	}  // Load the help text.

	// Call the base class method.
	CBasePropertyPage::OnInitDialog();

	// Limit the size of the text that can be entered in edit controls.
	m_editPrefix.SetLimitText(_MAX_PATH);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CDebugParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDebugParamsPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDebugParamsPage::BApplyChanges(void)
{
	// If the debug prefix string is not empty but the resource is not being
	// run in a separate resource monitor, ask the user if we should change
	// that setting now.  Only do this for resources.
	if (   (Cot() == CLUADMEX_OT_RESOURCE)
		&& (m_strDebugPrefix.GetLength() > 0)
		&& !m_bSeparateMonitor)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		if (AfxMessageBox(IDS_NOT_IN_SEPARATE_MONITOR, MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
			m_bSeparateMonitor = TRUE;
	}  // if:  debug prefix string specified for resource but not in separate monitor

	return CBasePropertyPage::BApplyChanges();

}  //*** CDebugParamsPage::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Description:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	Dec 20, 1998
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\debugex\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL)
    {
        UNREFERENCED_PARAMETER( pszSubsystem );
        UNREFERENCED_PARAMETER( pszName );
        UNREFERENCED_PARAMETER( uiFlagsDefault );
    }

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
#ifdef _DEBUG
 inline void TraceError(IN OUT CException & rexcept)		{ }
 inline void TraceError(IN LPCTSTR pszModule, IN DWORD sc)	{ }
 inline void TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix) { }
 inline void InitAllTraceTags(void)							{ }
 inline void CleanupAllTraceTags(void)						{ }
#else
 #define TraceError(_rexcept)
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 #define InitAllTraceTags()
 #define CleanupAllTraceTags()
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusapp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      ClusApp.cpp
//
//  Description:
//      Implementation of the application class
//
//  Author:
//      Galen Barbee    (GalenB)    10-Dec-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <StrSafe.h>

#include "ClusterObject.h"
#include "property.h"
#include "ClusNeti.h"
#include "ClusNetw.h"
#include "ClusRes.h"
#include "ClusResg.h"
#include "ClusRest.h"
#include "ClusNode.h"
#include "ClusApp.h"
#include "cluster.h"

#define SERVER_INFO_LEVEL       101
#define MAX_BUF_SIZE            0x00100000

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusterNames[] =
{
    &IID_ISClusterNames
};

static const IID *  iidCDomainNames[] =
{
    &IID_ISDomainNames
};

static const IID *  iidCClusApplication[] =
{
    &IID_ISClusApplication
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterNames class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::CClusterNames
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNames::CClusterNames( void )
{
    m_piids  = (const IID *) iidCClusterNames;
    m_piidsSize = ARRAYSIZE( iidCClusterNames );

} //*** CClusterNames::CClusterNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::~CClusterNames
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNames::~CClusterNames( void )
{
    Clear();

} //*** CClusterNames::~CClusterNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::Create
//
//  Description:
//      Finish creating the object.
//
//  Arguments:
//      bstrDomainName  [IN]    - Name of the domain this collection of
//      cluster names is for.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterNames::Create( IN BSTR bstrDomainName )
{
    //ASSERT( bstrDomainName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrDomainName )
    {
        if ( *bstrDomainName != L'\0' )
        {
            m_bstrDomainName = bstrDomainName;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusterNames::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::get_DomainName
//
//  Description:
//      Return the domain that this collection of cluster names is for.
//
//  Arguments:
//      pbstrDomainName [OUT]   - Catches the domain name.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_DomainName( OUT BSTR * pbstrDomainName )
{
    //ASSERT( pbstrDomainName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrDomainName != NULL )
    {
        *pbstrDomainName = m_bstrDomainName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusterNames::get_DomainName()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::get_Count
//
//  Description:
//      Get the count of objects in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Clusters.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusterNames::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::Clear
//
//  Description:
//      Empty the vector of cluster names.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNames::Clear( void )
{
    if ( ! m_Clusters.empty() )
    {
        ClusterNameList::iterator   _itCurrent = m_Clusters.begin();
        ClusterNameList::iterator   _itLast = m_Clusters.end();

        for ( ; _itCurrent != _itLast; _itCurrent++ )
        {
            delete (*_itCurrent);
        } // for:

        m_Clusters.erase( m_Clusters.begin(), _itLast );
    } // if:

} //*** CClusterNames::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::GetIndex
//
//  Description:
//      Convert the passed in 1 based index into a 0 based index.
//
//  Arguments:
//      varIndex    [IN]    - holds the 1 based index.
//      pnIndex     [OUT]   - catches the 0 based index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterNames::GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex )
{
    //ASSERT( pnIndex != NULL);

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            if ( --nIndex < m_Clusters.size() ) // Adjust index to be 0 relative instead of 1 relative
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusterNames::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::get_Item
//
//  Description:
//      Get the item (cluster name) at the passes in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index of the requested item.
//      ppbstrClusterName   [OUT]   - Catches the cluster name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_Item(
    IN  VARIANT varIndex,
    OUT BSTR *  ppbstrClusterName
    )
{
    //ASSERT( ppbstrClusterName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppbstrClusterName != NULL )
    {
        UINT nIndex = 0;

        // Zero the out param
        SysFreeString( *ppbstrClusterName );

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            *ppbstrClusterName = m_Clusters[ nIndex ]->Copy();
        }
    }

    return _hr;

} //*** CClusterNames::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::Refresh
//
//  Description:
//      Gets the list of cluster servers for the domain that this list is
//      for.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Win32 error passed in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::Refresh( void )
{
    SERVER_INFO_101 *   _pServerInfoList;
    DWORD               _cReturnCount = 0;
    DWORD               _cTotalServers = 0;
    DWORD               _sc;
    CComBSTR *          _pbstr = NULL;

    _sc = ::NetServerEnum(
                    0,                              // servername = where command executes 0 = local
                    SERVER_INFO_LEVEL,              // level = type of structure to return.
                    (LPBYTE *) &_pServerInfoList,   // bufptr = returned array of server info structures
                    MAX_BUF_SIZE,                   // prefmaxlen = preferred max of returned data
                    &_cReturnCount,                 // entriesread = number of enumerated elements returned
                    &_cTotalServers,                // totalentries = total number of visible machines on the network
                    SV_TYPE_CLUSTER_NT,             // servertype = filters the type of info returned
                    m_bstrDomainName,               // domain = domain to limit search
                    0                               // resume handle
                    );

    if ( _sc == ERROR_SUCCESS )
    {
        size_t  _index;

        Clear();

        for( _index = 0; _index < _cReturnCount; _index++ )
        {
            _pbstr = new CComBSTR( _pServerInfoList[ _index ].sv101_name );
            if ( _pbstr != NULL )
            {
                m_Clusters.insert( m_Clusters.end(), _pbstr );
            } // if:
            else
            {
                _sc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } // else:
        } // for:

        ::NetApiBufferFree( _pServerInfoList );
    }

    return HRESULT_FROM_WIN32( _sc );

} //*** CClusterNames::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get__NewEnum(
    IUnknown ** ppunk
    )
{
    return ::HrNewCComBSTREnum< ClusterNameList >( ppunk, m_Clusters );

} //*** CClusterNames::get__NewEnum()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNames::get_Application
//
//  Description:
//      Return the parent application object.
//
//  Arguments:
//      ppParentApplication [OUT]   - Catches the parent app object.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterNames::get_Application(
    OUT ISClusApplication ** ppParentApplication
    )
{
    //ASSERT( ppParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParentApplication != NULL )
    {
        _hr = E_NOTIMPL;
    }

    return _hr;

} //*** CClusterNames::get_Application()
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CDomainNames class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::CDomainNames
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDomainNames::CDomainNames( void )
{
    m_piids     = (const IID *) iidCDomainNames;
    m_piidsSize = ARRAYSIZE( iidCDomainNames );

} //*** CDomainNames::CDomainNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::~CDomainNames
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDomainNames::~CDomainNames( void )
{
    Clear();

} //*** CDomainNames::~CDomainNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::get_Count
//
//  Description:
//      Get the count of objects in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_DomainList.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CDomainNames::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::Clear
//
//  Description:
//      Empty the vector of domain names.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDomainNames::Clear( void )
{
    if ( ! m_DomainList.empty() )
    {
        DomainList::iterator    _itCurrent = m_DomainList.begin();
        DomainList::iterator    _itLast = m_DomainList.end();

        for ( ; _itCurrent != _itLast; _itCurrent++ )
        {
            delete (*_itCurrent);
        } // for:

        m_DomainList.erase( m_DomainList.begin(), _itLast );
    } // if:

} //*** CDomainNames::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::ScBuildTrustList
//
//  Description:
//      Attempts to find the domain that we are in.  If it can then it also
//      tries to enum the domains trusted domains.
//
//  Arguments:
//      pszTarget   [IN]    - A server name, or NULL to indicate this machine.
//
//  Return Value:
//      ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::ScBuildTrustList( IN LPWSTR pszTarget )
{
    LSA_HANDLE                  PolicyHandle = INVALID_HANDLE_VALUE;
    DWORD                       _sc;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain = NULL;
    BOOL                        bDC;
    LPWSTR                      pwszPrimaryDomainName = NULL;
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    size_t                      cchPrimaryDomainNanme = 0;
    HRESULT                     _hr = S_OK;

    do
    {
        //
        // open the policy on the specified machine
        //
        _sc = ScOpenPolicy( pszTarget, POLICY_VIEW_LOCAL_INFORMATION, &PolicyHandle );
        if ( _sc != ERROR_SUCCESS )
        {
            _hr = HRESULT_FROM_WIN32( _sc );
            break;
        }

        //
        // obtain the AccountDomain, which is common to all three cases
        //
        ntStatus = ::LsaQueryInformationPolicy( PolicyHandle, PolicyAccountDomainInformation, (void **) &AccountDomain );
        if ( ntStatus != STATUS_SUCCESS )
        {
            _sc = RtlNtStatusToDosError( ntStatus );
            _hr = HRESULT_FROM_WIN32( _sc );
            break;
        }

        //
        // find out if the pszTarget machine is a domain controller
        //
        _sc = ScIsDomainController( pszTarget, &bDC );
        if ( _sc != ERROR_SUCCESS )
        {
            _hr = HRESULT_FROM_WIN32( _sc );
            break;
        }

        if ( bDC == FALSE )
        {
            PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain = NULL;

            //
            // get the primary domain
            //
            ntStatus = ::LsaQueryInformationPolicy( PolicyHandle, PolicyPrimaryDomainInformation, (void **) &PrimaryDomain );
            if ( ntStatus != STATUS_SUCCESS )
            {
                _sc = RtlNtStatusToDosError( ntStatus );
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            }

            //
            // if the primary domain Sid is NULL, we are a non-member, and
            // our work is done.
            //
            if ( PrimaryDomain->Sid == NULL )
            {
                ::LsaFreeMemory( PrimaryDomain );
                PrimaryDomain = NULL;
                _hr = S_OK;
                break;
            }

            _sc = ScAddTrustToList( &PrimaryDomain->Name );
            if ( _sc != ERROR_SUCCESS )
            {
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            } // if:

            //
            // build a copy of what we just added.  This is necessary in order
            // to lookup the domain controller for the specified domain.
            // the Domain name must be NULL terminated for NetGetDCName(),
            // and the LSA_UNICODE_STRING buffer is not necessarilly NULL
            // terminated.  Note that in a practical implementation, we
            // could just extract the element we added, since it ends up
            // NULL terminated.
            //

            cchPrimaryDomainNanme = ( PrimaryDomain->Name.Length / sizeof( WCHAR ) ) + 1;   // existing length + NULL

            pwszPrimaryDomainName = new WCHAR [ cchPrimaryDomainNanme ];
            if ( pwszPrimaryDomainName != NULL )
            {
                //
                // copy the existing buffer to the new storage, appending a NULL
                //
                _hr = StringCchCopy( pwszPrimaryDomainName, cchPrimaryDomainNanme, PrimaryDomain->Name.Buffer );
                if ( FAILED( _hr ) )
                {
                    break;
                } // if:
            }
            else
            {
                _hr = E_OUTOFMEMORY;
                break;
            }

            ::LsaFreeMemory( PrimaryDomain );
            PrimaryDomain = NULL;

            //
            // get the primary domain controller computer name
            //
            PDOMAIN_CONTROLLER_INFO pdci;

            _sc = ::DsGetDcName( NULL,
                                    pwszPrimaryDomainName,
                                    NULL,
                                    NULL,
                                    DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
                                    &pdci );
            if ( _sc != ERROR_SUCCESS )
            {
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            }

            //
            // close the policy handle, because we don't need it anymore
            // for the workstation case, as we open a handle to a DC
            // policy below
            //
            ::LsaClose( PolicyHandle );
            PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

            //
            // open the policy on the domain controller
            //
            _sc = ScOpenPolicy( ( pdci->DomainControllerName + 2 ), POLICY_VIEW_LOCAL_INFORMATION, &PolicyHandle );
            if ( _sc != ERROR_SUCCESS )
            {
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            }
        }
        else
        {
            //
            // Note: AccountDomain->DomainSid will contain binary Sid
            //
            _sc = ScAddTrustToList( &AccountDomain->DomainName );
            if ( _sc != ERROR_SUCCESS )
            {
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            } // if:
        }

        //
        // free memory allocated for account domain
        //
        ::LsaFreeMemory( AccountDomain );
        AccountDomain = NULL;

        //
        // build additional trusted domain(s) list and indicate if successful
        //
        _sc = ScEnumTrustedDomains( PolicyHandle );
        _hr = HRESULT_FROM_WIN32( _sc );
        break;
    }
    while( TRUE );

    delete [] pwszPrimaryDomainName;

    //
    // close the policy handle
    //
    if ( PolicyHandle != INVALID_HANDLE_VALUE )
    {
        ::LsaClose( PolicyHandle );
    }

    return _hr;

} //*** CDomainNames::ScBuildTrustList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::ScOpenPolicy
//
//  Description:
//      Returns an open policy handle for the passed in machine name.
//
//  Arguments:
//      ServerName      [IN]    - The machine name.  Could be NULL.
//      DesiredAccess   [IN]    - The level of the information requested.
//      PolicyHandle    [OUT]   - Catches the policy handle.
//
//  Return Value:
//      ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScOpenPolicy(
    IN  LPWSTR      ServerName,
    IN  DWORD       DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    LSA_UNICODE_STRING      ServerString;
    PLSA_UNICODE_STRING     Server;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    DWORD                   _sc = ERROR_SUCCESS;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if ( ServerName != NULL )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString( &ServerString, ServerName );

        Server = &ServerString;
    }
    else
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    ntStatus = ::LsaOpenPolicy( Server, &ObjectAttributes, DesiredAccess, PolicyHandle );
    if ( ntStatus != STATUS_SUCCESS )
    {
        _sc = RtlNtStatusToDosError( ntStatus );
    } // if:

    return _sc;

} //*** CDomainNames::ScOpenPolicy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::InitLsaString
//
//  Description:
//      Initialize the passed in LSA string with either default or the value
//      of the passed in server name string.
//
//  Arguments:
//      LsaString   [OUT]   - Catches the LSA string.
//      psz         [IN]    - Server name -- could be NULL.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDomainNames::InitLsaString(
    OUT PLSA_UNICODE_STRING LsaString,
    IN  LPWSTR              psz
    )
{
    if ( psz == NULL )
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
    } // if: psz is NULL
    else
    {
        size_t  cchpsz = wcslen( psz );

        LsaString->Buffer = psz;
        LsaString->Length = (USHORT) ( cchpsz * sizeof( WCHAR ) );
        LsaString->MaximumLength = (USHORT) ( ( cchpsz + 1 ) * sizeof( WCHAR ) );
    } // else: it's not NULL

} //*** CDomainNames::InitLsaString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::ScIsDomainController
//
//  Description:
//      Is the passed in server a DC?
//
//  Arguments:
//      pszServer   [IN]    - The server name.
//      pbIsDC      [OUT]   - Catches the "Is DC" bool.
//
//  Return Value:
//      ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScIsDomainController(
    IN  LPWSTR  pszServer,
    OUT LPBOOL  pbIsDC
    )
{
    PSERVER_INFO_101    si101;
    NET_API_STATUS      nas;

    nas = ::NetServerGetInfo( pszServer, SERVER_INFO_LEVEL, (LPBYTE *) &si101 );
    if ( nas == NERR_Success )
    {
        if ( ( si101->sv101_type & SV_TYPE_DOMAIN_CTRL )    ||
             ( si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) )
        {
            *pbIsDC = TRUE; // we are dealing with a DC
        }
        else
        {
            *pbIsDC = FALSE;
        }

        ::NetApiBufferFree( si101 );
    }

    return nas;

} //*** CDomainNames::ScIsDomainController()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::ScEnumTrustedDomains
//
//  Description:
//      Enumerate the the trusted domains of the passed in policy handle.
//
//  Arguments:
//      PolicyHandle    [IN]    - Contains out domain.
//
//  Return Value:
//      ERROR_SUCCESS if successful, or Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScEnumTrustedDomains( LSA_HANDLE IN PolicyHandle )
{
    LSA_ENUMERATION_HANDLE  lsaEnumHandle = 0;      // start an enum
    PLSA_TRUST_INFORMATION  TrustInfo;
    ULONG                   ulReturned;             // number of items returned
    ULONG                   ulCounter;              // counter for items returned
    DWORD                   _sc = ERROR_SUCCESS;
    NTSTATUS                ntStatus = STATUS_SUCCESS;

    do
    {
        ntStatus = ::LsaEnumerateTrustedDomains(
                                PolicyHandle,           // open policy handle
                                &lsaEnumHandle,         // enumeration tracker
                                (void **) &TrustInfo,   // buffer to receive data
                                32000,                  // recommended buffer size
                                &ulReturned             // number of items returned
                                );
        //
        // get out if an error occurred
        //
        if ( ( ntStatus != STATUS_SUCCESS )         &&
             ( ntStatus != STATUS_MORE_ENTRIES )    &&
             ( ntStatus != STATUS_NO_MORE_ENTRIES ) )
        {
            break;
        }

        //
        // Display results
        // Note: Sids are in TrustInfo[ ulCounter ].Sid
        //
        for ( ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++ )
        {
            _sc = ScAddTrustToList( &TrustInfo[ ulCounter ].Name );
            if ( _sc != ERROR_SUCCESS )
            {
                break;
            } // if:
        } // for:

        //
        // free the buffer
        //
        ::LsaFreeMemory( TrustInfo );

    } while ( ntStatus == STATUS_MORE_ENTRIES );

    if ( ntStatus == STATUS_NO_MORE_ENTRIES )
    {
        ntStatus = STATUS_SUCCESS;
    } // if:

    if ( ntStatus != STATUS_SUCCESS )
    {
        _sc = RtlNtStatusToDosError( ntStatus );
    } // if:

    return _sc;

} //*** CDomainNames::ScEnumTrustedDomains()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::ScAddTrustToList
//
//  Description:
//      Add the trusted domain to the collection of domains.
//
//  Arguments:
//      UnicodeString   [IN]    - Contains the domain name.
//
//  Return Value:
//      ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDomainNames::ScAddTrustToList(
    IN PLSA_UNICODE_STRING UnicodeString
    )
{
    DWORD   _sc = ERROR_SUCCESS;

    CComBSTR *  pstr = new CComBSTR( ( UnicodeString->Length / sizeof( WCHAR ) ) + 1, UnicodeString->Buffer );
    if ( pstr != NULL )
    {
        m_DomainList.insert( m_DomainList.end(), pstr );
    }
    else
    {
        _sc = ERROR_NOT_ENOUGH_MEMORY;
    } // else:

    return _sc;

} //*** CDomainNames::ScAddTrustToList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::Refresh
//
//  Description:
//      Gets the list of domains that this collection contains.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Win32 error passed in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::Refresh( void )
{
    Clear();

    return ScBuildTrustList( NULL );

} //*** CDomainNames::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewCComBSTREnum< DomainList >( ppunk, m_DomainList );

} //*** CDomainNames::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::GetIndex
//
//  Description:
//      Convert the passed in 1 based index into a 0 based index.
//
//  Arguments:
//      varIndex    [IN]    - holds the 1 based index.
//      pnIndex     [OUT]   - catches the 0 based index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CDomainNames::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL);

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            if ( --nIndex < m_DomainList.size() )   // Adjust index to be 0 relative instead of 1 relative
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CDomainNames::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::get_Item
//
//  Description:
//      Get the item (domain name) at the passes in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index of the requested item.
//      p_pbstrClusterName  [OUT]   - Catches the cluster name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get_Item(
    VARIANT varIndex,
    BSTR *  bstrDomainName
    )
{
    //ASSERT( bstrDomainName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrDomainName != NULL )
    {
        UINT nIndex = 0;

        // Zero the out param
        SysFreeString( *bstrDomainName );

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            *bstrDomainName = m_DomainList [nIndex]->Copy();
        }
    }

    return _hr;

} //*** CDomainNames::get_Item()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDomainNames::get_Application
//
//  Description:
//      Returns the parent ClusApplication object.
//
//  Arguments:
//      ppParentApplication [OUT]   - Catches the parent app object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDomainNames::get_Application(
    OUT ISClusApplication ** ppParentApplication
    )
{
    //ASSERT( ppParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParentApplication != NULL )
    {
        _hr = E_NOTIMPL;
    }

    return _hr;

} //*** CDomainNames::get_Application()
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusApplication class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusApplication::CClusApplication
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusApplication::CClusApplication( void )
{
    m_pDomainNames  = NULL;
    m_piids  = (const IID *) iidCClusApplication;
    m_piidsSize = ARRAYSIZE( iidCClusApplication );

} //*** CClusApplication::CClusApplication()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusApplication::~CClusApplication
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusApplication::~CClusApplication( void )
{
    if ( m_pDomainNames != NULL )
    {
        m_pDomainNames->Release();
        m_pDomainNames = NULL;
    }

} //*** CClusApplication::~CClusApplication()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusApplication::get_DomainNames
//
//  Description:
//      Returns the collection of domain names for the domain that we are
//      joined to.
//
//  Arguments:
//      ppDomainNames   [OUT]   - Catches the collection of domain names.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::get_DomainNames(
    OUT ISDomainNames ** ppDomainNames
    )
{
    //ASSERT( ppDomainNames != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppDomainNames != NULL )
    {
        *ppDomainNames = NULL;
        _hr = S_OK;

        if ( m_pDomainNames == NULL )
        {
            CComObject< CDomainNames > *    pDomainNames = NULL;

            _hr = CComObject< CDomainNames >::CreateInstance( &pDomainNames );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< CComObject< CDomainNames > > ptrDomainNames( pDomainNames );

                _hr = ptrDomainNames->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    m_pDomainNames = ptrDomainNames;
                    ptrDomainNames->AddRef();
                }
            }
        }

        if ( SUCCEEDED( _hr ) )
        {
            _hr = m_pDomainNames->QueryInterface( IID_ISDomainNames, (void **) ppDomainNames );
        }
    } // if: args are not NULL

    return _hr;

} //*** CClusApplication::get_DomainNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusApplication::get_ClusterNames
//
//  Description:
//      Returns the clusters in the passed in domain.
//
//  Arguments:
//      bstrDomainName  [IN]    - The domain name to search for clusters.
//      ppClusterNames  [OUT]   - Catches the collection of cluster names.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::get_ClusterNames(
    IN  BSTR                bstrDomainName,
    OUT ISClusterNames **   ppClusterNames
    )
{
    //ASSERT( bstrDomainName != NULL );
    //ASSERT( ppClusterNames != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNames != NULL )
    {
        *ppClusterNames = NULL;
        _hr = S_OK;

        CComObject< CClusterNames > *   pClusterNames = NULL;

        _hr = CComObject< CClusterNames >::CreateInstance( &pClusterNames );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusterNames > >    ptrClusterNames( pClusterNames );

            _hr = ptrClusterNames->Create( bstrDomainName );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrClusterNames->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusterNames->QueryInterface( IID_ISClusterNames, (void **) ppClusterNames );
                } // if: collection was filled
            } // if: collection was created
        } // if: collection was allocated
    } // if: args are not NULL

    return _hr;

} //*** CClusApplication::get_ClusterNames()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusApplication::OpenCluster
//
//  Description:
//      Open the passed in cluster name.
//
//  Arguments:
//      bstrClusterName [IN]    - The name of the cluster to open.
//      ppCluster       [OUT]   - Catches the newly created cluster obj.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::OpenCluster(
    IN  BSTR            bstrClusterName,
    OUT ISCluster **    ppCluster
    )
{
    //ASSERT( bstrClusterName != NULL );
    //ASSERT( ppCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrClusterName != NULL ) && ( ppCluster != NULL ) )
    {
        CComObject< CCluster > *    pCluster = NULL;

        *ppCluster = NULL;

        _hr = CComObject< CCluster >::CreateInstance( &pCluster );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CCluster > > ptrCluster( pCluster );

            _hr = ptrCluster->Create( this );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrCluster->Open( bstrClusterName );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrCluster->QueryInterface( IID_ISCluster, (void **) ppCluster );
                } // if: cluster object was opened
            } // if: cluster object was created
        } // if: cluster object was allocated
    } // if: args are not NULL

    return _hr;

} //*** CClusApplication::OpenCluster()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusApplication::get_Application
//
//  Description:
//      Returns the parent ClusApplication object.  In this case "this".
//
//  Arguments:
//      ppParentApplication [OUT]   - Catches the parent app object.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusApplication::get_Application(
    OUT ISClusApplication ** ppParentApplication
    )
{
    //ASSERT( ppParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParentApplication != NULL )
    {
        _hr = _InternalQueryInterface( IID_ISClusApplication, (void **) ppParentApplication );
    }

    return _hr;

} //*** CClusApplication::get_Application()
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusdisk.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClusDisk.h
//
//	Description:
//		Definition of the cluster disk class for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusDisk.cpp
//
//	Author:
//		Galen Barbee	(galenb)	11-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSDISK_H_
#define __CLUSDISK_H__

#ifndef __PARTITION_H__
	#include "Partition.h"
#endif // __PARTITION_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusDisk;
class CClusDisks;
class CClusScsiAddress;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusDisk
//
//	Description:
//		Cluster Disk Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusDisk, &IID_ISClusDisk, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusDisk, &CLSID_ClusDisk >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusDisk :
	public IDispatchImpl< ISClusDisk, &IID_ISClusDisk, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusDisk, &CLSID_ClusDisk >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusDisk( void );
	~CClusDisk( void );

BEGIN_COM_MAP(CClusDisk)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusDisk)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusDisk)
DECLARE_NO_REGISTRY()

private:
	CComObject< CClusPartitions > *	m_pPartitions;
	DWORD							m_dwSignature;
	DWORD							m_dwDiskNumber;
	CLUS_SCSI_ADDRESS				m_csaScsiAddress;

public:
	HRESULT Create( IN HRESOURCE hResource );

	HRESULT HrCreate( IN OUT CClusPropValueList & rcpvl, OUT BOOL * pbEndFound );

	STDMETHODIMP get_Signature( OUT long * plSignature );

	STDMETHODIMP get_ScsiAddress( OUT ISClusScsiAddress ** ppScsiAddress );

	STDMETHODIMP get_DiskNumber( OUT long * plDiskNumber );

	STDMETHODIMP get_Partitions( OUT ISClusPartitions ** ppPartitions );

}; //*** Class CClusDisk

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusDisks
//
//	Description:
//		Cluster Disk Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusDisks, &IID_ISClusDisks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusDisks, &CLSID_ClusDisks >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusDisks :
	public IDispatchImpl< ISClusDisks, &IID_ISClusDisks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusDisks, &CLSID_ClusDisks >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusDisks( void );
	~CClusDisks( void );

BEGIN_COM_MAP(CClusDisks)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusDisks)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusDisks)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN const CClusPropValueList & rcpvl );

	HRESULT Create( ISClusRefObject * pClusRefObject, BSTR bstrResTypeName );

private:
	typedef std::vector< CComObject< CClusDisk > * >	DiskVector;

	DiskVector			m_dvDisks;
	CComBSTR			m_bstrResTypeName;
	ISClusRefObject *	m_pClusRefObject;

	void	Clear( void );

	HRESULT GetIndex( VARIANT varIndex, UINT *pnIndex );

	HRESULT HrCreateDisk( IN OUT CClusPropValueList & rcpvl, OUT BOOL * pbEndFound );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusDisk ** ppDisk );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusDisks

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusScsiAddress
//
//	Description:
//		Cluster SCSI Address Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusScsiAddress, &IID_ISClusScsiAddress, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusScsiAddress, &CLSID_ClusScsiAddress >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusScsiAddress :
	public IDispatchImpl< ISClusScsiAddress, &IID_ISClusScsiAddress, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusScsiAddress, &CLSID_ClusScsiAddress >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusScsiAddress( void );

BEGIN_COM_MAP(CClusScsiAddress)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusScsiAddress)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusScsiAddress)
DECLARE_NO_REGISTRY()

private:
	CLUS_SCSI_ADDRESS	m_csa;

public:
	HRESULT Create( IN const CLUS_SCSI_ADDRESS & rcsa );

	STDMETHODIMP get_PortNumber( OUT VARIANT * pvarPortNumber );

	STDMETHODIMP get_PathId( OUT VARIANT * pvarPathId );

	STDMETHODIMP get_TargetId( OUT VARIANT * pvarTargetId );

	STDMETHODIMP get_Lun( OUT VARIANT * pvarLun );

}; //*** Class CClusScsiAddress

#endif // __CLUSDISK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\cluskeys.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusKeys.cpp
//
//  Description:
//      Implementation of the cluster registry and crypto key collection
//      classes for the MSCLUS automation classes.
//
//  Author:
//      Galen Barbee    (galenb)    12-Feb-1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#if CLUSAPI_VERSION >= 0x0500
    #include <PropList.h>
#else
    #include "PropList.h"
#endif // CLUSAPI_VERSION >= 0x0500

#include "ClusKeys.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusRegistryKeys[] =
{
    &IID_ISClusRegistryKeys
};

static const IID *  iidCClusCryptoKeys[] =
{
    &IID_ISClusCryptoKeys
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::CKeys
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CKeys::CKeys( void )
{
    m_pClusRefObject = NULL;

} //*** CKeys::CKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::~CKeys
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CKeys::~CKeys( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CKeys::~CKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrCreate
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrCreate( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CKeys::HrCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::Clear
//
//  Description:
//      Empty the vector of keys.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CKeys::Clear( void )
{
    if ( ! m_klKeys.empty() )
    {
        KeyList::iterator   _itCurrent = m_klKeys.begin();
        KeyList::iterator   _itLast = m_klKeys.end();

        for ( ; _itCurrent != _itLast; _itCurrent++ )
        {
            delete (*_itCurrent);
        } // for:

        m_klKeys.erase( m_klKeys.begin(), _itLast );
    } // if:

} //*** CKeys::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::FindItem
//
//  Description:
//      Find the passed in key in the vector and return its index.
//
//  Arguments:
//      pwsKey  [IN]    - The node to find.
//      pnIndex [OUT]   - Catches the node's index.
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::FindItem(
    IN  LPWSTR  pwsKey,
    OUT ULONG * pnIndex
    )
{
    //ASSERT( pwsKey != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pwsKey != NULL ) && ( pnIndex != NULL ) )
    {
        _hr = E_INVALIDARG;

        if ( ! m_klKeys.empty() )
        {
            CComBSTR *          _pKey = NULL;
            KeyList::iterator   _itCurrent = m_klKeys.begin();
            KeyList::iterator   _itLast = m_klKeys.end();
            ULONG               _iIndex;

            for ( _iIndex = 0; _itCurrent != _itLast; _itCurrent++, _iIndex++ )
            {
                _pKey = *_itCurrent;

                if ( _pKey && ( ClRtlStrICmp( pwsKey, (*_pKey) ) == 0 ) )
                {
                    *pnIndex = _iIndex;
                    _hr = S_OK;
                    break;
                } // if: match!
            } // for: each item in the vector
        } // if: the vector is not empty
    } // if: args not NULL

    return _hr;

} //*** CKeys::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrGetIndex
//
//  Description:
//      Convert the passed in 1 based index into a 0 based index.
//
//  Arguments:
//      varIndex    [IN]    - holds the 1 based index.
//      pnIndex     [OUT]   - catches the 0 based index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrGetIndex( IN VARIANT varIndex, OUT ULONG * pnIndex )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        ULONG       _nIndex = 0;
        CComVariant _var;

        *pnIndex = 0;

        _hr = _var.Attach( &varIndex );
        if ( SUCCEEDED( _hr ) )
        {
            // Check to see if the index is a number.
            _hr = _var.ChangeType( VT_I4 );
            if ( SUCCEEDED( _hr ) )
            {
                _nIndex = _var.lVal;
                _nIndex--; // Adjust index to be 0 relative instead of 1 relative
            } // if: the variant is a number
            else
            {
                // Check to see if the index is a string
                _hr = _var.ChangeType( VT_BSTR );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = FindItem( _var.bstrVal, &_nIndex );
                } // if: the variant is a string
            } // else:

            if ( SUCCEEDED( _hr ) )
            {
                if ( _nIndex < m_klKeys.size() )
                {
                    *pnIndex = _nIndex;
                } // if: in range
                else
                {
                    _hr = E_INVALIDARG;
                } // else: out of range
            } // if: we found an index value

            _var.Detach( &varIndex );
        } // if: we attched to the variant
    } // if: args not NULL

    return _hr;

} //*** CKeys::HrGetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrGetItem
//
//  Description:
//      Get the key at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the requested key.
//      ppKey       [OUT]   - Catches the key.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrGetItem( IN VARIANT varIndex, OUT BSTR * ppKey )
{
    //ASSERT( ppKey != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppKey != NULL )
    {
        ULONG   _nIndex = 0;

        _hr = HrGetIndex( varIndex, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            *ppKey = m_klKeys[ _nIndex ]->Copy();
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CKeys::HrGetItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrRemoveAt
//
//  Description:
//      Remove the object from the vector at the passed in position.
//
//  Arguments:
//      pos [IN]    - the position of the object to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the position is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrRemoveAt( size_t pos )
{
    KeyList::iterator       _itCurrent = m_klKeys.begin();
    KeyList::const_iterator _itLast = m_klKeys.end();
    HRESULT                 _hr = E_INVALIDARG;
    size_t                  _iIndex;

    for ( _iIndex = 0; ( _iIndex < pos ) && ( _itCurrent != _itLast ); _iIndex++, _itCurrent++ )
    {
    } // for:

    if ( _itCurrent != _itLast )
    {
        m_klKeys.erase( _itCurrent );
        _hr = S_OK;
    }

    return _hr;

} //*** CKeys::HrRemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrFindItem
//
//  Description:
//      Find the passed in key in the collection.
//
//  Arguments:
//      bstrKey [IN]    - The key to find.
//      pnIndex [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if found, or E_INVALIDARG if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrFindItem( IN BSTR bstrKey, OUT ULONG * pnIndex )
{
    HRESULT _hr = E_INVALIDARG;

    if ( ! m_klKeys.empty() )
    {
        KeyList::iterator   _itCurrent = m_klKeys.begin();
        KeyList::iterator   _itLast = m_klKeys.end();
        ULONG               _iIndex;

        for ( _iIndex = 0; _itCurrent != _itLast; _itCurrent++, _iIndex++ )
        {
            if ( lstrcmp( *(*_itCurrent), bstrKey ) == 0 )
            {
                *pnIndex = _iIndex;
                _hr = S_OK;
                break;
            }
        }
    } // if:

    return _hr;

} //*** CKeys::HrFindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrGetCount
//
//  Description:
//      Get the count of objects in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrGetCount( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_klKeys.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CKeys::HrGetCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrAddItem
//
//  Description:
//      Create a new key and add it to the collection.
//
//  Arguments:
//      bstrKey [IN]    - Registry key to add to the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrAddItem( IN BSTR bstrKey )
{
    //ASSERT( bstrKey != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrKey != NULL )
    {
        ULONG _nIndex;

        _hr = HrFindItem( bstrKey, &_nIndex );
        if ( FAILED( _hr ) )
        {
            CComBSTR *  pbstr = NULL;

            pbstr = new CComBSTR( bstrKey );
            if ( pbstr != NULL )
            {
                m_klKeys.insert( m_klKeys.end(), pbstr );
                _hr = S_OK;
            } // if:
            else
            {
                _hr = E_OUTOFMEMORY;
            } // else:
        }
        else
        {
            _hr = E_INVALIDARG;
        } // else:
    }

    return _hr;

} //*** CKeys::HrAddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CKeys::HrRemoveItem
//
//  Description:
//      Remove the key at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - contains the index to remove.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CKeys::HrRemoveItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    ULONG   _nIndex = 0;

    _hr = HrGetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        delete m_klKeys[ _nIndex ];
        HrRemoveAt( _nIndex );
    }

    return _hr;

} //*** CKeys::HrRemoveItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceKeys::HrRefresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      dwControlCode   [IN]    - Control code
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResourceKeys::HrRefresh( IN DWORD dwControlCode )
{
    HRESULT _hr = S_FALSE;
    PWSTR   _psz = NULL;
    DWORD   _cbPsz = 512;
    DWORD   _cbRequired = 0;
    DWORD   _sc = ERROR_SUCCESS;

    _psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
    if ( _psz != NULL )
    {
        _sc = ::ClusterResourceControl(
                        m_hResource,
                        NULL,
                        dwControlCode,
                        NULL,
                        0,
                        _psz,
                        _cbPsz,
                        &_cbRequired
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            ::LocalFree( _psz );
            _psz = NULL;
            _cbPsz = _cbRequired;

            _psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
            if ( _psz != NULL )
            {
                _sc = ::ClusterResourceControl(
                                m_hResource,
                                NULL,
                                dwControlCode,
                                NULL,
                                0,
                                _psz,
                                _cbPsz,
                                &_cbRequired
                                );
                _hr = HRESULT_FROM_WIN32( _sc );
            } // if: alloc OK
            else
            {
                _sc = GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
            } // else: alloc failed
        } // if: error was no more item, re-alloc and try again.
        else
        {
            _hr = HRESULT_FROM_WIN32( _sc );
        } // else: error was not no more items -- could be no error

        if ( SUCCEEDED( _hr ) )
        {
            CComBSTR *  _pbstr = NULL;

            Clear();

            while( *_psz != L'\0' )
            {
                _pbstr = new CComBSTR( _psz );
                if ( _pbstr != NULL )
                {
                    m_klKeys.insert( m_klKeys.end(), _pbstr );
                    _psz += wcslen( _psz ) + 1;
                    _pbstr = NULL;
                } // if:
                else
                {
                    _hr = E_OUTOFMEMORY;
                    break;
                } // else:
            } // while: not EOS
        } // if: keys were retrieved ok

        ::LocalFree( _psz );
    } // if: alloc ok
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    } // else: alloc failed

    return _hr;

} //*** CResourceKeys::HrRefresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceKeys::HrAddItem
//
//  Description:
//      Create a new key and add it to the collection.
//
//  Arguments:
//      bstrKey         [IN]    - Registry key to add to the collection.
//      dwControlCode   [IN]    - Control code
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResourceKeys::HrAddItem(
    IN BSTR     bstrKey,
    IN DWORD    dwControlCode
    )
{
    //ASSERT( bstrKey != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrKey != NULL )
    {
        DWORD   _sc = ERROR_SUCCESS;

        _sc = ::ClusterResourceControl(
                        m_hResource,
                        NULL,
                        dwControlCode,
                        bstrKey,
                        ( wcslen( bstrKey ) + 1) * sizeof( WCHAR ),
                        NULL,
                        0,
                        NULL
                        );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = CKeys::HrAddItem( bstrKey );
        } // if:
    } // if:

    return _hr;

} //*** CResourceKeys::HrAddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceKeys::HrRemoveItem
//
//  Description:
//      Remove the key at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - contains the index to remove.
//      dwControlCode   [IN]    - Control code
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResourceKeys::HrRemoveItem(
    IN VARIANT  varIndex,
    IN DWORD    dwControlCode
    )
{
    HRESULT _hr = S_OK;
    ULONG   _nIndex = 0;

    _hr = HrGetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        DWORD       _sc = ERROR_SUCCESS;
        CComBSTR *  _pbstr = NULL;

        _pbstr = m_klKeys[ _nIndex ];

        _sc = ::ClusterResourceControl(
                        m_hResource,
                        NULL,
                        dwControlCode,
                        (BSTR) (*_pbstr),
                        ( _pbstr->Length() + 1 ) * sizeof( WCHAR ),
                        NULL,
                        0,
                        NULL
                        );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = CKeys::HrRemoveItem( varIndex );
        }
    }

    return _hr;

} //*** CResourceKeys::HrRemoveItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResourceRegistryKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::CClusResourceRegistryKeys
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResourceRegistryKeys::CClusResourceRegistryKeys( void )
{
    m_hResource = NULL;
    m_piids     = (const IID *) iidCClusRegistryKeys;
    m_piidsSize = ARRAYSIZE( iidCClusRegistryKeys );

} //*** CClusResourceRegistryKeys::CClusResourceRegistryKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      hResource   [IN]    - Resource this collection belongs to.
//
//  Return Value:
//      S_OK if successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResourceRegistryKeys::Create( IN HRESOURCE hResource )
{
    m_hResource = hResource;

    return S_OK;

} //*** CClusResourceRegistryKeys::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::get_Count
//
//  Description:
//      Get the count of objects in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::get_Count( OUT long * plCount )
{
    return CKeys::HrGetCount( plCount );

} //*** CClusResourceRegistryKeys::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::get_Item
//
//  Description:
//      Get the item (key) at the passed in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index requested.
//      ppbstrRegistryKey   [OUT]   - Catches the key.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::get_Item(
    IN  VARIANT varIndex,
    OUT BSTR *  ppbstrRegistryKey
    )
{
    return HrGetItem( varIndex, ppbstrRegistryKey );

} //*** CClusResourceRegistryKeys::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewCComBSTREnum< KeyList >( ppunk, m_klKeys );

} //*** CClusResourceRegistryKeys::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::AddItem
//
//  Description:
//      Create a new item (key) and add it to the collection.
//
//  Arguments:
//      bstrRegistryKey [IN]    - Registry key to add to the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::AddItem(
    IN BSTR bstrRegistryKey
    )
{
    return HrAddItem( bstrRegistryKey, CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT );

} //*** CClusResourceRegistryKeys::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::RemoveItem
//
//  Description:
//      Remove the item (key) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - contains the index to remove.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::RemoveItem( IN VARIANT varIndex )
{
    return HrRemoveItem( varIndex, CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT );

} //*** CClusResourceRegistryKeys::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceRegistryKeys::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceRegistryKeys::Refresh( void )
{
    return HrRefresh( CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS );

} //*** CClusResourceRegistryKeys::Refresh()


//*************************************************************************//


#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
// CClusResourceCryptoKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::CClusResourceCryptoKeys
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResourceCryptoKeys::CClusResourceCryptoKeys( void )
{
    m_hResource = NULL;
    m_piids     = (const IID *) iidCClusCryptoKeys;
    m_piidsSize = ARRAYSIZE( iidCClusCryptoKeys );

} //*** CClusResourceCryptoKeys::CClusResourceCryptoKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      hResource   [IN]    - Resource this collection belongs to.
//
//  Return Value:
//      S_OK if successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResourceCryptoKeys::Create( IN HRESOURCE hResource )
{
    m_hResource = hResource;

    return S_OK;

} //*** CClusResourceCryptoKeys::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::get_Count
//
//  Description:
//      Get the count of objects in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::get_Count( OUT long * plCount )
{
    return CKeys::HrGetCount( plCount );

} //*** CClusResourceCryptoKeys::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::get_Item
//
//  Description:
//      Get the item (key) at the passed in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index requested.
//      ppbstrRegistryKey   [OUT]   - Catches the key.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::get_Item(
    IN  VARIANT varIndex,
    OUT BSTR *  ppbstrRegistryKey
    )
{
    return HrGetItem( varIndex, ppbstrRegistryKey );

} //*** CClusResourceCryptoKeys::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewCComBSTREnum< KeyList >( ppunk, m_klKeys );

} //*** CClusResourceCryptoKeys::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::AddItem
//
//  Description:
//      Create a new item (key) and add it to the collection.
//
//  Arguments:
//      bstrRegistryKey [IN]    - Registry key to add to the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::AddItem(
    IN BSTR bstrRegistryKey
    )
{
    return HrAddItem( bstrRegistryKey, CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT );

} //*** CClusResourceCryptoKeys::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::RemoveItem
//
//  Description:
//      Remove the item (key) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - contains the index to remove.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::RemoveItem( IN VARIANT varIndex )
{
    return HrRemoveItem( varIndex, CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT );

} //*** CClusResourceCryptoKeys::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResourceCryptoKeys::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResourceCryptoKeys::Refresh( void )
{
    return HrRefresh( CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS );

} //*** CClusResourceCryptoKeys::Refresh()

#endif // CLUSAPI_VERSION >= 0x0500


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResTypeKeys class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeKeys::HrRefresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      dwControlCode   [IN]    - Control code
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResTypeKeys::HrRefresh( IN DWORD dwControlCode )
{
    HRESULT     _hr = S_FALSE;
    PWSTR       _psz = NULL;
    DWORD       _cbPsz = 512;
    DWORD       _cbRequired = 0;
    DWORD       _sc = ERROR_SUCCESS;
    HCLUSTER    hCluster = NULL;

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        _psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
        if ( _psz != NULL )
        {
            _sc = ::ClusterResourceTypeControl(
                            hCluster,
                            m_bstrResourceTypeName,
                            NULL,
                            dwControlCode,
                            NULL,
                            0,
                            _psz,
                            _cbPsz,
                            &_cbRequired
                            );
            if ( _sc == ERROR_MORE_DATA )
            {
                ::LocalFree( _psz );
                _psz = NULL;
                _cbPsz = _cbRequired;

                _psz = (PWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbPsz );
                if ( _psz != NULL )
                {
                    _sc = ::ClusterResourceTypeControl(
                                    hCluster,
                                    m_bstrResourceTypeName,
                                    NULL,
                                    dwControlCode,
                                    NULL,
                                    0,
                                    _psz,
                                    _cbPsz,
                                    &_cbRequired
                                    );
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // if: alloc OK
                else
                {
                    _sc = GetLastError();
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: alloc failed
            } // if: error was no more item, re-alloc and try again.
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            } // else: error was not no more items -- could be no error

            if ( SUCCEEDED( _hr ) )
            {
                CComBSTR *  _pbstr = NULL;

                Clear();

                while( *_psz != L'\0' )
                {
                    _pbstr = new CComBSTR( _psz );
                    if ( _pbstr != NULL )
                    {
                        m_klKeys.insert( m_klKeys.end(), _pbstr );
                        _psz += wcslen( _psz ) + 1;
                        _pbstr = NULL;
                    } // if:
                    else
                    {
                        _hr = E_OUTOFMEMORY;
                        break;
                    } // else:
                } // while: not EOS
            } // if: keys were retrieved ok
        } // if: alloc ok
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        } // else: alloc failed
    } // if: we got a cluster handle

    return _hr;

} //*** CResTypeKeys::HrRefresh()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\cluskeys.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		ClusKeys.h
//
//	Description:
//		Definition of the registry and crypto key collection classes for
//		the MSCLUS automation classes.
//
//	Implementation File:
//		ClusKeys.cpp
//
//	Author:
//		Galen Barbee	(galenb)	12-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSKEYS_H_
#define _CLUSKEYS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CKeys;
class CResourceKeys;
class CResTypeKeys;
class CClusResourceRegistryKeys;
class CClusResourceCryptoKeys;
class CClusResTypeRegistryKeys;
class CClusResTypeCryptoKeys;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CKeys
//
//	Description:
//		Cluster Keys Collection Implementation Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CKeys
{
public:
	CKeys( void );
	~CKeys( void );

protected:
	typedef std::vector< CComBSTR * >	KeyList;

	ISClusRefObject *	m_pClusRefObject;
	KeyList				m_klKeys;

	HRESULT HrCreate( ISClusRefObject * pClusRefObject );

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNodeName, OUT ULONG * pnIndex );

	HRESULT HrGetIndex( IN VARIANT varIndex, OUT ULONG * pnIndex );

	HRESULT HrGetItem( IN VARIANT varIndex, OUT BSTR * ppKey );

	HRESULT HrRemoveAt( IN size_t pos );

	HRESULT HrFindItem( IN BSTR bstrKey, OUT ULONG * pnIndex );

	HRESULT HrGetCount( OUT long * plCount );

	virtual HRESULT HrRemoveItem( IN VARIANT varIndex );

	virtual HRESULT HrAddItem( IN BSTR bstrKey );

}; //*** Class CKeys

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CResourceKeys
//
//	Description:
//		Cluster Resource Keys Collection Implementation Class.
//
//	Inheritance:
//		CKeys
//
//--
/////////////////////////////////////////////////////////////////////////////
class CResourceKeys: public CKeys
{
protected:
	HRESOURCE	m_hResource;

	HRESULT	HrRefresh( DWORD dwControlCode );

	virtual HRESULT HrRemoveItem( IN VARIANT varIndex, IN DWORD dwControlCode );

	virtual HRESULT HrAddItem( IN BSTR bstrKey, IN DWORD dwControlCode );

}; //*** Class CResourceKeys

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CResTypeKeys
//
//	Description:
//		Cluster Resource Keys Collection Implementation Class.
//
//	Inheritance:
//		CKeys
//
//--
/////////////////////////////////////////////////////////////////////////////
class CResTypeKeys: public CKeys
{
protected:
	CComBSTR	m_bstrResourceTypeName;

	HRESULT	HrRefresh( DWORD dwControlCode );

}; //*** Class CResTypeKeys

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResourceRegistryKeys
//
//	Description:
//		Cluster Registry Keys Collection Automation Class.
//
//	Inheritance:
//		CResourceKeys
//		IDispatchImpl< ISClusRegistryKeys, &IID_ISClusRegistryKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< ClusRegistryKeys, &CLSID_ClusRegistryKeys >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResourceRegistryKeys :
	public CResourceKeys,
	public IDispatchImpl< ISClusRegistryKeys, &IID_ISClusRegistryKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< ClusRegistryKeys, &CLSID_ClusRegistryKeys >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResourceRegistryKeys( void );

BEGIN_COM_MAP(CClusResourceRegistryKeys)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusRegistryKeys)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResourceRegistryKeys)
DECLARE_NO_REGISTRY()

	HRESULT Create( HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * ppbstrRegistryKey );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP AddItem( IN BSTR bstrRegistryKey );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResourceRegistryKeys

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResourceCryptoKeys
//
//	Description:
//		Cluster Crypto Keys Collection Automation Class.
//
//	Inheritance:
//		CResourceKeys
//		IDispatchImpl< ISClusCryptoKeys, &IID_ISClusCryptoKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< ClusCryptoKeys, &CLSID_ClusCryptoKeys >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResourceCryptoKeys :
	public CResourceKeys,
	public IDispatchImpl< ISClusCryptoKeys, &IID_ISClusCryptoKeys, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< ClusCryptoKeys, &CLSID_ClusCryptoKeys >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResourceCryptoKeys( void );

BEGIN_COM_MAP(CClusResourceCryptoKeys)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusCryptoKeys)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResourceCryptoKeys)
DECLARE_NO_REGISTRY()

	HRESULT Create( HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * ppbstrCryptoKey );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP AddItem( IN BSTR bstrCryptoKey );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResourceCryptoKeys

#endif // CLUSAPI_VERSION >= 0x0500

#endif // _CLUSKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		ClusApp.h
//
//	Description:
//		Definition of CClusApplication and it's supporting classes.
//
//	Implementation File:
//		ClusApp.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	10-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSAPPLICATION_H_
#define _CLUSAPPLICATION_H_

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusApplication;
class CClusterNames;
class CDomainNames;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusterNames
//
//	Description:
//		Cluster Names Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusterNames, &IID_ISClusterNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusterNames, &CLSID_ClusterNames >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusterNames	:
	public IDispatchImpl< ISClusterNames, &IID_ISClusterNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusterNames, &CLSID_ClusterNames >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusterNames( void );
	~CClusterNames( void );

BEGIN_COM_MAP(CClusterNames)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusterNames)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusterNames)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN BSTR bstrDomainName );

private:
	typedef std::vector< CComBSTR * >	ClusterNameList;

	ClusterNameList m_Clusters;
	CComBSTR		m_bstrDomainName;

	void Clear( void );

public:
	STDMETHODIMP get_DomainName( OUT BSTR * pbstrDomainName );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * bstrClusterName );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

//	STDMETHODIMP get_Application( OUT ISClusApplication ** ppParentApplication );

//	STDMETHODIMP get_Parent( OUT ISClusApplication ** ppParent )
//	{
//		return get_Application( ppParent );
//	}

protected:
	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

}; //*** CClusterNames

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CDomainNames
//
//	Description:
//		Cluster Domain Names Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISDomainNames, &IID_ISDomainNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CDomainNames, &CLSID_DomainNames >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CDomainNames :
	public IDispatchImpl< ISDomainNames, &IID_ISDomainNames, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CDomainNames, &CLSID_DomainNames >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CDomainNames( void );
	~CDomainNames( void );

BEGIN_COM_MAP(CDomainNames)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISDomainNames)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDomainNames)
DECLARE_NO_REGISTRY()

private:
	typedef std::vector< CComBSTR * >	DomainList;

	DomainList		m_DomainList;

	STDMETHODIMP ScBuildTrustList( IN LPWSTR pszTarget );

	DWORD ScOpenPolicy( IN LPWSTR ServerName, IN DWORD DesiredAccess, OUT PLSA_HANDLE PolicyHandle );

	void InitLsaString( OUT PLSA_UNICODE_STRING LsaString, IN LPWSTR String );

	DWORD ScIsDomainController( IN LPWSTR pszServer, OUT LPBOOL pbIsDC );

	DWORD ScEnumTrustedDomains( IN LSA_HANDLE PolicyHandle );

	DWORD ScAddTrustToList( IN PLSA_UNICODE_STRING UnicodeString );

	void Clear( void );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT BSTR * bstrDomainName );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

//	STDMETHODIMP get_Application( OUT ISClusApplication ** ppParentApplication );

//	STDMETHODIMP get_Parent( OUT ISClusApplication ** ppParent )
//	{
//		return get_Application( ppParent );
//	}

protected:
	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

}; //*** Class CDomainNames

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusApplication
//
//	Description:
//		Cluster Application Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusApplication, &IID_ISClusApplication, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusApplication, &CLSID_ClusApplication >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusApplication :
	public IDispatchImpl< ISClusApplication, &IID_ISClusApplication, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusApplication, &CLSID_ClusApplication >
{
	typedef CComObjectRootEx< CComSingleThreadModel >										BaseComClass;
	typedef CComCoClass< CClusApplication, &CLSID_ClusApplication >							BaseCoClass;
	typedef IDispatchImpl< ISClusApplication, &IID_ISClusApplication, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >	BaseDispatchClass;

public:
	CClusApplication( void );
	~CClusApplication( void );

BEGIN_COM_MAP(CClusApplication)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusApplication)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusApplication)
DECLARE_REGISTRY_RESOURCEID(IDR_MSCLUS)

public:
	STDMETHODIMP get_DomainNames( OUT ISDomainNames ** ppDomainNames );

	STDMETHODIMP OpenCluster( IN BSTR bstrClusterName, OUT ISCluster ** ppCluster );

	STDMETHODIMP get_ClusterNames( IN BSTR bstrDomainName, OUT ISClusterNames ** ppClusterNames );

//	STDMETHODIMP get_Application( OUT ISClusApplication ** ppParentApplication );

//	STDMETHODIMP get_Parent( OUT ISClusApplication ** ppParent )
//	{
//		return get_Application( ppParent );
//	}

private:
	CComObject< CDomainNames > *	m_pDomainNames;

}; //*** Class CClusApplication

#endif // _CLUSAPPLICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusneti.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusNetI.h
//
//	Description:
//		Definition of the network interface classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusNetI.cpp
//
//	Author:
//		Ramakrishna Rosanuru via David Potter	(davidp)	5-Sep-1997
//		Galen Barbee							(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNETI_H_
#define _CLUSNETI_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNetInterface;
class CNetInterfaces;
class CClusNetInterfaces;
class CClusNetworkNetInterfaces;
class CClusNodeNetInterfaces;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetInterface
//
//	Description:
//		Cluster Net Interface Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetInterface, &IID_ISClusNetInterface, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNetInterface, &CLSID_ClusNetInterface >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetInterface :
	public IDispatchImpl< ISClusNetInterface, &IID_ISClusNetInterface, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNetInterface, &CLSID_ClusNetInterface >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetInterface( void );
	~CClusNetInterface( void );

BEGIN_COM_MAP(CClusNetInterface)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetInterface)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetInterface)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *				m_pClusRefObject;
	HNETINTERFACE					m_hNetInterface;
	CComObject< CClusProperties > *	m_pCommonProperties;
	CComObject< CClusProperties > *	m_pPrivateProperties;
	CComObject< CClusProperties > *	m_pCommonROProperties;
	CComObject< CClusProperties > *	m_pPrivateROProperties;
	CComBSTR						m_bstrNetInterfaceName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Open( IN ISClusRefObject* pClusRefObject, IN BSTR bstrNetInterfaceName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP get_Name( OUT BSTR * pbstrNetInterfaceName );

	STDMETHODIMP get_State( OUT CLUSTER_NETINTERFACE_STATE * dwState );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrNetInterfaceName ; };

}; //*** Class CClusNetInterface

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CNetInterfaces
//
//	Description:
//		Cluster Net Interfaces Collection Implementation Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CNetInterfaces
{
public:
	CNetInterfaces( void );
	~CNetInterfaces( void );

	HRESULT Create( IN ISClusRefObject * pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusNetInterface > * > NetInterfacesList;

	ISClusRefObject *	m_pClusRefObject;
	NetInterfacesList	m_NetInterfaceList;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNetInterfaceName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusNetInterface * pClusterNetInterface, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetItem( IN LPWSTR lpszNetInterfaceName, OUT ISClusNetInterface ** ppClusterNetInterface );

	HRESULT GetItem( IN UINT nIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	HRESULT GetNetInterfaceItem( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

}; //*** Class CNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetInterfaces
//
//	Description:
//		Cluster Net Interfaces Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetInterfaces, &IID_ISClusNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNetInterfaces
//		CComCoClass< CClusNetInterfaces, &CLSID_ClusNetInterfaces >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetInterfaces :
	public IDispatchImpl< ISClusNetInterfaces, &IID_ISClusNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNetInterfaces,
	public CComCoClass< CClusNetInterfaces, &CLSID_ClusNetInterfaces >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetInterfaces( void );
	~CClusNetInterfaces( void );

BEGIN_COM_MAP(CClusNetInterfaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetInterfaces)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetInterfaces)
DECLARE_NO_REGISTRY()

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetworkNetInterfaces
//
//	Description:
//		Cluster Network Net Interfaces collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetworkNetInterfaces, &IID_ISClusNetworkNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >,
//		CNetInterfaces
//		CComCoClass< CClusNetworkNetInterfaces, &CLSID_ClusNetworkNetInterfaces >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetworkNetInterfaces :
	public IDispatchImpl< ISClusNetworkNetInterfaces, &IID_ISClusNetworkNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNetInterfaces,
	public CComCoClass< CClusNetworkNetInterfaces, &CLSID_ClusNetworkNetInterfaces >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetworkNetInterfaces( void );
	~CClusNetworkNetInterfaces( void );

BEGIN_COM_MAP(CClusNetworkNetInterfaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetworkNetInterfaces)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetworkNetInterfaces)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HNETWORK hNetwork );

private:
	HNETWORK	m_hNetwork;

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNetworkNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNodeNetInterfaces
//
//	Description:
//		Cluster Node Net Interfaces collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNodeNetInterfaces, &IID_ISClusNodeNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >,
//		CNetInterfaces
//		CComCoClass< CClusNodeNetInterfaces, &CLSID_ClusNodeNetInterfaces >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNodeNetInterfaces	:
	public IDispatchImpl< ISClusNodeNetInterfaces, &IID_ISClusNodeNetInterfaces, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNetInterfaces,
	public CComCoClass< CClusNodeNetInterfaces, &CLSID_ClusNodeNetInterfaces >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNodeNetInterfaces( void );
	~CClusNodeNetInterfaces( void );

BEGIN_COM_MAP(CClusNodeNetInterfaces)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNodeNetInterfaces)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNodeNetInterfaces)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HNODE hNode );

private:
	HNODE	m_hNode;

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetInterface ** ppClusterNetInterface );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNodeNetInterfaces

#endif // _CLUSNETI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusdisk.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      ClusDisk.cpp
//
//  Description:
//      Implementation of the cluster disk class for the MSCLUS
//      automation classes.
//
//  Author:
//      Galen Barbee    (galenb)    11-Feb-1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#if CLUSAPI_VERSION >= 0x0500
    #include <PropList.h>
#else
    #include "PropList.h"
#endif // CLUSAPI_VERSION >= 0x0500

#include "ClusDisk.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusDisk[] =
{
    &IID_ISClusDisk
};

static const IID *  iidCClusDisks[] =
{
    &IID_ISClusDisks
};

static const IID *  iidCClusScsiAddress[] =
{
    &IID_ISClusScsiAddress
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusDisk class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::CClusDisk
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisk::CClusDisk( void )
{
    m_pPartitions   = NULL;
    m_dwSignature   = 0;
    m_dwDiskNumber  = 0;
    m_piids         = (const IID *) iidCClusDisk;
    m_piidsSize     = ARRAYSIZE( iidCClusDisk );

}   //*** CClusDisk::CClusDisk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::~CClusDisk
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisk::~CClusDisk( void )
{
    if ( m_pPartitions != NULL )
    {
        m_pPartitions->Release();
    } // if:

}   //*** CClusDisk::~CClusDisk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::Create
//
//  Description:
//      Finish creating this object.  This method get the value list from
//      the passed in physical disk resource handle.
//
//  Arguments:
//      hResource   [IN]    - Handle to the physical disk resource.
//
//  Return Value:
//      S_OK if successful, or Win32 error wrapped in HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisk::Create( IN HRESOURCE hResource )
{
    HRESULT _hr = E_POINTER;

    DWORD               _sc = ERROR_SUCCESS;
    CClusPropValueList  _cpvl;

    _sc = _cpvl.ScGetResourceValueList( hResource, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO );
    _hr = HRESULT_FROM_WIN32( _sc );
    if ( SUCCEEDED( _hr ) )
    {
        _sc = _cpvl.ScMoveToFirstValue();
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            CLUSPROP_BUFFER_HELPER          _cbhValue = { NULL };
            CComObject< CClusPartitions > * pPartitions = NULL;

            if ( m_pPartitions != NULL )
            {
                m_pPartitions->Release();
                m_pPartitions = NULL;
            } // if: clean up any old partitions collection

            _hr = CComObject< CClusPartitions >::CreateInstance( &pPartitions );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< CComObject< CClusPartitions > >  ptrPartitions( pPartitions );

                m_pPartitions = ptrPartitions;
                ptrPartitions->AddRef();

                do
                {
                    _cbhValue = _cpvl;

                    switch ( _cbhValue.pSyntax->dw )
                    {
                        case CLUSPROP_SYNTAX_PARTITION_INFO :
                        {
                            _hr = ptrPartitions->HrCreateItem( _cbhValue.pPartitionInfoValue );
                            break;
                        } // case: CLUSPROP_SYNTAX_PARTITION_INFO

                        case CLUSPROP_SYNTAX_DISK_SIGNATURE :
                        {
                            m_dwSignature = _cbhValue.pDiskSignatureValue->dw;
                            break;
                        } // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

                        case CLUSPROP_SYNTAX_SCSI_ADDRESS :
                        {
                            m_csaScsiAddress.dw = _cbhValue.pScsiAddressValue->dw;
                            break;
                        } // case: CLUSPROP_SYNTAX_SCSI_ADDRESS

                        case CLUSPROP_SYNTAX_DISK_NUMBER :
                        {
                            m_dwDiskNumber = _cbhValue.pDiskNumberValue->dw;
                            break;
                        } // case: CLUSPROP_SYNTAX_DISK_NUMBER

                    } // switch:

                    //
                    // Move to the next value.
                    //
                    _sc = _cpvl.ScMoveToNextValue();
                    if ( _sc == ERROR_NO_MORE_ITEMS )
                    {
                        _hr = S_OK;
                        break;
                    } // if: error occurred moving to the next value

                    _hr = HRESULT_FROM_WIN32( _sc );

                } while ( SUCCEEDED( _hr ) );   // do-while: there are no errors
            } // if: created the partition collection
        } // if: move to first value ok
    } // if: get the value list ok

    return _hr;

} //*** CClusDisk::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::HrCreate
//
//  Description:
//      Finish creating this object.  This method parses a passed in value
//      list to get the values for the physical disk object.
//
//  Arguments:
//      rcpvl       [IN OUT]    - Value list to parse.
//      pbEndFound  [OUT]       - Did find the end of the value list?
//
//  Return Value:
//      S_OK, or Win32 error code wrapped in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisk::HrCreate(
    IN OUT  CClusPropValueList &    rcpvl,
    OUT     BOOL *                  pbEndFound
    )
{
    DWORD                           _sc = ERROR_SUCCESS;
    CLUSPROP_BUFFER_HELPER          _cbhValue = { NULL };
    CComObject< CClusPartitions > * pPartitions = NULL;
    HRESULT                         _hr = S_FALSE;

    if ( m_pPartitions != NULL )
    {
        m_pPartitions->Release();
        m_pPartitions = NULL;
    } // if: clean up any old partitions collection

    _hr = CComObject< CClusPartitions >::CreateInstance( &pPartitions );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject< CClusPartitions > >  ptrPartitions( pPartitions );

        m_pPartitions = ptrPartitions;
        ptrPartitions->AddRef();

        _cbhValue = rcpvl;

        do
        {
            switch ( _cbhValue.pSyntax->dw )
            {
                case CLUSPROP_SYNTAX_DISK_SIGNATURE :
                {
                    m_dwSignature = _cbhValue.pDiskSignatureValue->dw;
                    break;
                } // case: CLUSPROP_SYNTAX_DISK_SIGNATURE

                case CLUSPROP_SYNTAX_PARTITION_INFO :
                {
                    _hr = ptrPartitions->HrCreateItem( _cbhValue.pPartitionInfoValue );
                    break;
                } // case: CLUSPROP_SYNTAX_PARTITION_INFO

                case CLUSPROP_SYNTAX_SCSI_ADDRESS :
                {
                    m_csaScsiAddress.dw = _cbhValue.pScsiAddressValue->dw;
                    break;
                } // case: CLUSPROP_SYNTAX_SCSI_ADDRESS

                case CLUSPROP_SYNTAX_DISK_NUMBER :
                {
                    m_dwDiskNumber = _cbhValue.pDiskNumberValue->dw;
                    break;
                } // case: CLUSPROP_SYNTAX_DISK_NUMBER

            } // switch:

            //
            // Move to the next value.
            //
            _sc = rcpvl.ScMoveToNextValue();
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                *pbEndFound = TRUE;
                break;
            } // if: error occurred moving to the next value

            _cbhValue = rcpvl;

            if ( _cbhValue.pSyntax->dw == CLUSPROP_SYNTAX_DISK_SIGNATURE )
            {
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            } // if: exit if another signature is found before the end of the list is seen

            _hr = HRESULT_FROM_WIN32( _sc );

        } while ( SUCCEEDED( _hr ) );   // do-while: there are no errors

    } // if: the patitions collection can be created

    return _hr;

} //*** CClusDisk::HrCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::get_Signature
//
//  Description:
//      Get the disk signature.
//
//  Arguments:
//      plSignature [OUT]   - catches the signature.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_Signature( OUT long * plSignature )
{
    //ASSERT( plSignature != NULL );

    HRESULT _hr = E_POINTER;

    if ( plSignature != NULL )
    {
        *plSignature = static_cast< long >( m_dwSignature );
        _hr = S_OK;
    }

    return _hr;

} //*** CClusDisk::get_Signature()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::get_ScsiAddress
//
//  Description:
//      Get the disk's SCSI address.
//
//  Arguments:
//      ppScsiAddress   [OUT]   - catches the SCSI address..
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_ScsiAddress(
    OUT ISClusScsiAddress ** ppScsiAddress
    )
{
    //ASSERT( ppScsiAddress != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppScsiAddress != NULL )
    {
        CComObject< CClusScsiAddress > *    _pScsiAddress = NULL;

        _hr = CComObject< CClusScsiAddress >::CreateInstance( &_pScsiAddress );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusScsiAddress > > _ptrScsiAddress( _pScsiAddress );

            _hr = _ptrScsiAddress->Create( m_csaScsiAddress );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = _ptrScsiAddress->QueryInterface( IID_ISClusScsiAddress, (void **) ppScsiAddress );
            } // if:
        } // if:
    } // if:

    return _hr;

} //*** CClusDisk::get_ScsiAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::get_DiskNumber
//
//  Description:
//      Get the disk number.
//
//  Arguments:
//      plDiskNumber    [OUT]   - catches the disk number.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_DiskNumber( OUT long * plDiskNumber )
{
    //ASSERT( plDiskNumber != NULL );

    HRESULT _hr = E_POINTER;

    if ( plDiskNumber != NULL )
    {
        *plDiskNumber = static_cast< long >( m_dwDiskNumber );
        _hr = S_OK;
    }

    return _hr;

} //*** CClusDisk::get_DiskNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisk::get_Partitions
//
//  Description:
//      Get the disk partitions.
//
//  Arguments:
//      ppPartitions    [OUT]   - catches the partitions collection.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisk::get_Partitions( OUT ISClusPartitions ** ppPartitions )
{
    //ASSERT( ppPartitions != NULL );
    ASSERT( m_pPartitions != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppPartitions != NULL )
    {
        if ( ppPartitions != NULL )
        {
            _hr = m_pPartitions->QueryInterface( IID_ISClusPartitions, (void **) ppPartitions );
        } // if:
    } // if:

    return _hr;

} //*** CClusDisk::get_Partitions()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusDisks class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::CClusDisks
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisks::CClusDisks( void )
{
    m_pClusRefObject        = NULL;
    m_piids             = (const IID *) iidCClusDisks;
    m_piidsSize         = ARRAYSIZE( iidCClusDisks );

} //*** CClusDisks::CClusDisks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::~CClusDisks
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusDisks::~CClusDisks( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if: do we have a pointer to the cluster handle wrapper?

} //*** CClusDisks::~CClusDisks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::Create
//
//  Description:
//      Complete the heavy weight construction,
//
//  Arguments:
//      rpvl    [IN]    - Property value list.
//
//  Return Value:
//      E_NOTIMPL
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::Create( IN const CClusPropValueList &rpvl )
{
    HRESULT _hr = E_NOTIMPL;

    return _hr;

} //*** CClusDisks::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::GetIndex
//
//  Description:
//      Convert the passed in 1 based index into a 0 based index.
//
//  Arguments:
//      varIndex    [IN]    - holds the 1 based index.
//      pnIndex     [OUT]   - catches the 0 based index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--;                       // Adjust index to be 0 relative instead of 1 relative

            if ( nIndex < m_dvDisks.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusDisks::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::get_Count
//
//  Description:
//      Get the count of objects in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_dvDisks.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusDisks::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::Clear
//
//  Description:
//      Empty the vector of disks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusDisks::Clear( void )
{
    ::ReleaseAndEmptyCollection< DiskVector, CComObject< CClusDisk > >( m_dvDisks );

} //*** CClusDisks::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::get_Item
//
//  Description:
//      Get the item (disk) at the passed in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index requested.
//      ppbstrRegistryKey   [OUT]   - Catches the key.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusDisk **   ppDisk
    )
{
    //ASSERT( ppDisk != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppDisk != NULL )
    {
        CComObject< CClusDisk > * pDisk = NULL;

        // Zero the out param
        *ppDisk = NULL;

        UINT nIndex = 0;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pDisk = m_dvDisks[ nIndex ];
            _hr = pDisk->QueryInterface( IID_ISClusDisk, (void **) ppDisk );
        }
    }

    return _hr;

} //*** CClusDisks::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< DiskVector, CComObject< CClusDisk > >( ppunk, m_dvDisks );

} //*** CClusDisks::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrResTypeName [IN]    - The resource type this collection is for.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResTypeName
    )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        m_bstrResTypeName = bstrResTypeName;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusDisks::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusDisks::Refresh( void )
{
    HRESULT         _hr = S_OK;
    DWORD           _sc = ERROR_SUCCESS;
    HCLUSTER        _hCluster = NULL;
    BOOL            _bEndFound = FALSE;

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        CClusPropValueList  _cpvl;

        _sc = _cpvl.ScGetResourceTypeValueList(
                                        _hCluster,
                                        m_bstrResTypeName,
                                        CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS
                                        );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            Clear();

            _sc = _cpvl.ScMoveToFirstValue();
            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                CLUSPROP_BUFFER_HELPER  _cbhValue = { NULL };

                do
                {
                    _cbhValue = _cpvl;

                    if ( _cbhValue.pSyntax->dw  == CLUSPROP_SYNTAX_DISK_SIGNATURE )
                    {
                        _hr = HrCreateDisk( _cpvl, &_bEndFound );
                    } // if: value list MUST start with signature!

                } while ( ! _bEndFound );   // do-while: there are values in the list

            } // if: we moved to the first value
        } // if: the value list of available disks was retrieved
    } // if: we have a cluster handle

    return _hr;

} //*** CClusDisks::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDisks::HrCreateDisk
//
//  Description:
//      Create a CClusDisk object from the passed in value list and add it
//      to the collection.  This method assumes that the value list's curent
//      value is the disk signature.
//
//  Arguments:
//      rcpvl       [IN OUT]    - The value list to parse.
//      pbEndFound  [IN]        - Catches the end of list state.
//
//  Return Value:
//      S_OK, if successful, Win32 error code wrapped in an HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusDisks::HrCreateDisk(
    IN OUT  CClusPropValueList &    rcpvl,
    OUT     BOOL *                  pbEndFound
    )
{
    CComObject< CClusDisk > *   _pDisk = NULL;
    HRESULT                     _hr = S_FALSE;

    _hr = CComObject< CClusDisk >::CreateInstance( &_pDisk );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject< CClusDisk > >    _ptrDisk( _pDisk );

        _hr = _ptrDisk->HrCreate( rcpvl, pbEndFound );
        if ( SUCCEEDED( _hr ) )
        {
            m_dvDisks.insert( m_dvDisks.end(), _pDisk );
            _ptrDisk->AddRef();
        } // if:
    } // if:

    return _hr;

} //*** CClusDisks::HrCreateDisk()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusScsiAddress class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusScsiAddress::CClusScsiAddress
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusScsiAddress::CClusScsiAddress( void )
{
    m_piids         = (const IID *) iidCClusScsiAddress;
    m_piidsSize     = ARRAYSIZE( iidCClusScsiAddress );

}   //*** CClusScsiAddress::CClusScsiAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusScsiAddress::Create
//
//  Description:
//      Finish creating this object.
//
//  Arguments:
//      pcpi    [IN]    - points to the CLUS_PARTITION_INFO struct.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusScsiAddress::Create( IN const CLUS_SCSI_ADDRESS & rcsa )
{
    m_csa = rcsa;

    return S_OK;

} //*** CClusScsiAddress::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusScsiAddress::get_PortNumber
//
//  Description:
//      Get the disk's port number.
//
//  Arguments:
//      pvarPortNumber  [OUT]   - catches the port number.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_PortNumber( OUT VARIANT * pvarPortNumber )
{
    //ASSERT( pvarPortNumber != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPortNumber != NULL )
    {
        pvarPortNumber->bVal    = m_csa.PortNumber;
        pvarPortNumber->vt      = VT_UI1;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusScsiAddress::get_PortNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusScsiAddress::get_PathId
//
//  Description:
//      Get the disk's path id.
//
//  Arguments:
//      pvarPathId  [OUT]   - catches the path id.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_PathId( OUT VARIANT * pvarPathId )
{
    //ASSERT( pvarPathId != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPathId != NULL )
    {
        pvarPathId->bVal    = m_csa.PathId;
        pvarPathId->vt      = VT_UI1;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusScsiAddress::get_PathId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusScsiAddress::get_TargetId
//
//  Description:
//      Get the disk's target id.
//
//  Arguments:
//      pvarTargetId    [OUT]   - catches the target id.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_TargetId( OUT VARIANT * pvarTargetId )
{
    //ASSERT( pvarTargetId != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarTargetId != NULL )
    {
        pvarTargetId->bVal  = m_csa.TargetId;
        pvarTargetId->vt    = VT_UI1;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusScsiAddress::get_TargetId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusScsiAddress::get_Lun
//
//  Description:
//      Get the disk's Lun.
//
//  Arguments:
//      pvarLun [OUT]   - catches the Lun.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusScsiAddress::get_Lun( OUT VARIANT * pvarLun )
{
    //ASSERT( pvarLun != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarLun != NULL )
    {
        pvarLun->bVal   = m_csa.Lun;
        pvarLun->vt     = VT_UI1;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusScsiAddress::get_Lun()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusneti.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//       ClusNetI.cpp
//
//  Description:
//       Implementation of the network interface classes for the MSCLUS
//       automation classes.
//
//  Author:
//       Ramakrishna Rosanuru via David Potter  (davidp)    5-Sep-1997
//      Galen Barbee                            (galenb)    July 1998
//
//  Revision History:
//       July 1998  GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusneti.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID * iidCClusNetInterface[] =
{
    &IID_ISClusNetInterface
};

static const IID * iidCClusNetInterfaces[] =
{
    &IID_ISClusNetInterface
};

static const IID * iidCClusNetworkNetInterfaces[] =
{
    &IID_ISClusNetworkNetInterfaces
};

static const IID * iidCClusNodeNetInterfaces[] =
{
    &IID_ISClusNodeNetInterfaces
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetInterface class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::CClusNetInterface
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterface::CClusNetInterface( void )
{
    m_hNetInterface         = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;
    m_pClusRefObject        = NULL;
    m_piids                 = (const IID *) iidCClusNetInterface;
    m_piidsSize             = ARRAYSIZE( iidCClusNetInterface );

} //*** CClusNetInterface::CClusNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::~CClusNetInterface
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterface::~CClusNetInterface( void )
{
    if ( m_hNetInterface != NULL )
    {
        ::CloseClusterNetInterface( m_hNetInterface );
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if: do we have a pointer to the cluster handle wrapper?

} //*** CClusNetInterface::~CClusNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::Open
//
//  Description:
//      Open the passed in network interface.
//
//  Arguments:
//      pClusRefObject          [IN]    - Wraps the cluster handle.
//      bstrNetInterfaceName    [IN]    - The name of the interface to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetInterface::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrNetInterfaceName
    )
{
    ASSERT( pClusRefObject != NULL );
    //ASSERT( bstrNetInterfaceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrNetInterfaceName != NULL ) )
    {
        HCLUSTER     _hCluster;

        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            m_hNetInterface = OpenClusterNetInterface( _hCluster, bstrNetInterfaceName );
            if ( m_hNetInterface == 0 )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            } // if: it failed
            else
            {
                m_bstrNetInterfaceName = bstrNetInterfaceName;
                _hr = S_OK;
            } // else: it worked
        } // if: we have a cluster handle
    } // if: the args are not NULL

    return _hr;

} //*** CClusNetInterface::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::GetProperties
//
//  Description:
//      Creates a property collection for this object type
//      (Network Interface).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetInterface::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        *ppProperties = NULL;

        CComObject< CClusProperties > * pProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusNetInterface::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_Handle
//
//  Description:
//      Return the raw handle to this objec (Netinterface).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        *phandle = (ULONG_PTR) m_hNetInterface;
        _hr = S_OK;
    } // if: args are not NULL

    return _hr;

} //*** CClusNetInterface::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_Name
//
//  Description:
//      Return the name of this object (Network Interface).
//
//  Arguments:
//      pbstrNetInterfaceName   [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_Name( OUT BSTR * pbstrNetInterfaceName )
{
    //ASSERT( pbstrNetInterfaceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNetInterfaceName != NULL )
    {
        *pbstrNetInterfaceName = m_bstrNetInterfaceName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetInterface::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_State
//
//  Description:
//      Return the current state of the object (Netinterface).
//
//  Arguments:
//      cnisState   [OUT]   - Catches the state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_State(
    OUT CLUSTER_NETINTERFACE_STATE * cnisState
    )
{
    //ASSERT( cnisState != NULL );

    HRESULT _hr = E_POINTER;

    if ( cnisState != NULL )
    {
        CLUSTER_NETINTERFACE_STATE _cnis = GetClusterNetInterfaceState( m_hNetInterface );

        if ( _cnis == ClusterNetInterfaceStateUnknown )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *cnisState = _cnis;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusNetInterface::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_CommonProperties
//
//  Description:
//      Get this object's (Network Interface) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusNetInterface::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_PrivateProperties
//
//  Description:
//      Get this object's (Network Interface) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusNetInterface::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_CommonROProperties
//
//  Description:
//      Get this object's (Network Interface) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusNetInterface::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_PrivateROProperties
//
//  Description:
//      Get this object's (Network Interface) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusNetInterface::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::get_Cluster
//
//  Description:
//      Return the cluster this object (Netinterface) belongs to.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterface::get_Cluster( OUT ISCluster ** ppCluster )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusNetInterface::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetInterface::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;


    if ( bReadOnly )
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES
                        : CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;
    } // else:

    _sc = rcplPropList.ScGetNetInterfaceProperties( m_hNetInterface, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusNetInterface::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterface::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusNetInterface::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   _dwControlCode  = bPrivate ? CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES : CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;
    DWORD   _nBytesReturned = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterNetInterfaceControl(
                        m_hNetInterface,
                        NULL,
                        _dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &_nBytesReturned
                        );

    return _sc;

} //*** CClusNetInterface::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::CNetInterfaces
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaces::CNetInterfaces( void )
{
    m_pClusRefObject = NULL;

} //*** CNetInterfaces::CNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::~CNetInterfaces
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaces::~CNetInterfaces( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if: do we have a pointer to the cluster handle wrapper?

} //*** CNetInterfaces::~CNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful, E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CNetInterfaces::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::Clear
//
//  Description:
//      Empty the collection of net interfaces.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterfaces::Clear( void )
{
    ::ReleaseAndEmptyCollection< NetInterfacesList, CComObject< CClusNetInterface > >( m_NetInterfaceList );

} //*** CNetInterfaces::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::FindItem
//
//  Description:
//      Find a net interface in the collection by name and return its index.
//
//  Arguments:
//      pszNetInterfaceName [IN]    - The name to look for.
//      pnIndex             [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::FindItem(
    IN  LPWSTR pszNetInterfaceName,
    OUT UINT * pnIndex
    )
{
    //ASSERT( pszNetInterfaceName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pszNetInterfaceName != NULL ) && ( pnIndex != NULL ) )
    {
        CComObject< CClusNetInterface > *   _pNetInterface = NULL;
        NetInterfacesList::iterator         _first = m_NetInterfaceList.begin();
        NetInterfacesList::iterator         _last = m_NetInterfaceList.end();
        int                                 _idx = 0;

        _hr = E_INVALIDARG;

        for ( ; _first != _last; _first++, _idx++ )
        {
            _pNetInterface = *_first;

            if ( _pNetInterface && ( lstrcmpi( pszNetInterfaceName, _pNetInterface->Name() ) == 0 ) )
            {
                *pnIndex = _idx;
                _hr = S_OK;
                break;
            }
        }
    }

    return _hr;

} //*** CNetInterfaces::FindItem( pszNetInterfaceName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::FindItem
//
//  Description:
//      Find a net interface in the collection and return its index.
//
//  Arguments:
//      pClusterNetInterface    [IN]    - The net interface to look for.
//      pnIndex                 [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::FindItem(
    IN  ISClusNetInterface *    pClusterNetInterface,
    OUT UINT *                  pnIndex
    )
{
    //ASSERT( pClusterNetInterface != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusterNetInterface != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR _bstrName;

        _hr = pClusterNetInterface->get_Name( &_bstrName );

        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( _bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CNetInterfaces::FindItem( pClusterNetInterface )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        UINT        _nIndex = 0;
        CComVariant _v;

        *pnIndex = 0;

        _v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = _v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            _nIndex = _v.lVal;
            _nIndex--; // Adjust index to be 0 relative instead of 1 relative
        } // if: the index is a number
        else
        {
            // Check to see if the index is a string.
            _hr = _v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( _v.bstrVal, &_nIndex );
            } // if: the index is a string -- the net interface name
        } // else: not a number

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( _nIndex < m_NetInterfaceList.size() )
            {
                *pnIndex = _nIndex;
            } // if: index is in range
            else
            {
                _hr = E_INVALIDARG;
            } // else: index out of range
        } // if: did we find an index?
    } // if: args are not NULL

    return _hr;

} //*** CNetInterfaces::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::GetItem
//
//  Description:
//      Return the item (Netinterface) by name.
//
//  Arguments:
//      pszNetInterfaceName     [IN]    - The name of the item requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetItem(
    IN  LPWSTR                  pszNetInterfaceName,
    OUT ISClusNetInterface **   ppClusterNetInterface
    )
{
    //ASSERT( pszNetInterfaceName != NULL );
    //ASSERT( ppClusterNetInterface != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pszNetInterfaceName != NULL ) && ( ppClusterNetInterface != NULL ) )
    {
        CComObject< CClusNetInterface > *   _pNetInterface = NULL;
        NetInterfacesList::iterator         _first  = m_NetInterfaceList.begin();
        NetInterfacesList::iterator         _last   = m_NetInterfaceList.end();

        _hr = E_INVALIDARG;

        for ( ; _first != _last; _first++ )
        {
            _pNetInterface = *_first;

            if ( _pNetInterface && ( lstrcmpi( pszNetInterfaceName, _pNetInterface->Name() ) == 0 ) )
            {
                _hr = _pNetInterface->QueryInterface( IID_ISClusNetInterface, (void **) ppClusterNetInterface );
                break;
            } // if: match?
        } // for:
    } // if: args are not NULL

    return _hr;

} //*** CNetInterfaces::GetItem( pszNetInterfaceName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::GetItem
//
//  Description:
//      Return the item (Netinterface) at the passed in index.
//
//  Arguments:
//      nIndex                  [IN]    - The index of the item requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetItem(
    IN  UINT                    nIndex,
    OUT ISClusNetInterface **   ppClusterNetInterface
    )
{
    //ASSERT( ppClusterNetInterface != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetInterface != NULL )
    {
        //
        // Automation collections are 1-relative for languages like VB.
        // We are 0-relative internally.
        //
        nIndex--;

        if ( nIndex < m_NetInterfaceList.size() )
        {
            CComObject< CClusNetInterface > * _pNetInterface = m_NetInterfaceList[ nIndex ];

            _hr = _pNetInterface->QueryInterface( IID_ISClusNetInterface, (void **) ppClusterNetInterface );
        } // if: index is in range
        else
        {
            _hr = E_INVALIDARG;
        } // else: index is out of range
    }

    return _hr;

} //*** CNetInterfaces::GetItem( nIndex )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaces::GetNetInterfaceItem
//
//  Description:
//      Return the object (Netinterface) at the passed in index.
//
//  Arguments:
//      varIndex                [IN]    - Contains the index.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetInterfaces::GetNetInterfaceItem(
    IN  VARIANT                 varIndex,
    OUT ISClusNetInterface **   ppClusterNetInterface
    )
{
    //ASSERT( ppClusterNetInterface != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetInterface != NULL )
    {
        CComObject< CClusNetInterface > *   _pNetInterface = NULL;
        UINT                                _nIndex = 0;

        *ppClusterNetInterface = NULL;

        _hr = GetIndex( varIndex, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            _pNetInterface = m_NetInterfaceList[ _nIndex ];

            _hr = _pNetInterface->QueryInterface( IID_ISClusNetInterface, (void **) ppClusterNetInterface );
        } // if: we have a proper index
    } // if: args are not NULL

    return _hr;

} //*** CNetInterfaces::GetNetInterfaceItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterfaces::CClusNetInterfaces
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterfaces::CClusNetInterfaces( void )
{
    m_piids     = (const IID *) iidCClusNetInterfaces;
    m_piidsSize = ARRAYSIZE( iidCClusNetInterfaces );

} //*** CClusNetInterfaces::CClusNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterfaces::~CClusNetInterfaces
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetInterfaces::~CClusNetInterfaces( void )
{
    Clear();

} //*** CClusNetInterfaces::~CClusNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterfaces::get_Count
//
//  Description:
//      Return the count of objects (Netinterfaces) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_NetInterfaceList.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetInterfaces::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterfaces::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NetInterfacesList, CComObject< CClusNetInterface > >( ppunk, m_NetInterfaceList );

} //*** CClusNetInterfaces::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterfaces::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::Refresh( void )
{
    ASSERT( m_pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;
    HCLUSENUM   _hEnum = NULL;
    HCLUSTER    _hCluster;
    DWORD       _sc = ERROR_SUCCESS;

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        _hEnum = ::ClusterOpenEnum( _hCluster, CLUSTER_ENUM_NETINTERFACE );
        if ( _hEnum != NULL )
        {
            int                                 _nIndex = 0;
            DWORD                               _dwType;
            LPWSTR                              _pszName = NULL;
            CComObject< CClusNetInterface > *   _pNetInterface = NULL;

            Clear();

            for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( _hEnum, _nIndex, &_dwType, &_pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNetInterface >::CreateInstance( &_pNetInterface );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                    _ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNetInterface > >    _ptrNetInterface( _pNetInterface );
                        BSTR                                            _bstr = NULL;

                        _bstr = SysAllocString( _pszName );
                        if ( _bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = _ptrNetInterface->Open( _ptrRefObject, _bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _ptrNetInterface->AddRef();
                                m_NetInterfaceList.insert( m_NetInterfaceList.end(), _ptrNetInterface );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the net interface to have been deleted from the cluster
                                //  in the time between creating the enum and opening the net interface.  When
                                //  that happens we need to simply skip that net interface and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster net interface was not found

                            SysFreeString( _bstr );
                        }
                    }

                    ::LocalFree( _pszName );
                    _pszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }

            ::ClusterCloseEnum( _hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusNetInterfaces::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetInterfaces::get_Item
//
//  Description:
//      Return the object (Netinterface) at the passed in index.
//
//  Arguments:
//      varIndex                [IN]    - Contains the index requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetInterfaces::get_Item(
    IN  VARIANT                 varIndex,
    OUT ISClusNetInterface **   ppClusterNetInterface
    )
{
    //ASSERT( ppClusterNetInterface != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetInterface != NULL )
    {
        _hr = GetNetInterfaceItem( varIndex, ppClusterNetInterface );
    }

    return _hr;

} //*** CClusNetInterfaces::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetworkNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::CClusNetworkNetInterfaces
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkNetInterfaces::CClusNetworkNetInterfaces( void )
{
    m_piids     = (const IID *) iidCClusNetworkNetInterfaces;
    m_piidsSize = ARRAYSIZE( iidCClusNetworkNetInterfaces );

} //*** CClusNetworkNetInterfaces::CClusNetworkNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::~CClusNetworkNetInterfaces
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkNetInterfaces::~CClusNetworkNetInterfaces( void )
{
    Clear();

} //*** CClusNetworkNetInterfaces::~CClusNetworkNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::Create
//
//  Description:
//      Complete the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hNetwork        [IN]    - The handle of the network whose netinterfaces
//                              this collection holds.  The parent.
//
//  Return Value:
//      S_OK if successful, or E_POINTER is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworkNetInterfaces::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HNETWORK             hNetwork
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNetInterfaces::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hNetwork = hNetwork;
    } // if: args are not NULL

    return _hr;

} //*** CClusNetworkNetInterfaces::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::get_Count
//
//  Description:
//      Return the count of objects (NetworkNetinterfaces) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_NetInterfaceList.size();
        _hr = S_OK;
    } // if: args are not NULL

    return _hr;

} //*** CClusNetworkNetInterfaces::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NetInterfacesList, CComObject< CClusNetInterface > >( ppunk, m_NetInterfaceList );

} //*** CClusNetworkNetInterfaces::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::Refresh( void )
{
    HRESULT _hr = E_POINTER;
    DWORD   _sc = ERROR_SUCCESS;

    if ( m_hNetwork != NULL )
    {
        HNETWORKENUM _hEnum = NULL;

        _hEnum = ::ClusterNetworkOpenEnum( m_hNetwork, CLUSTER_NETWORK_ENUM_NETINTERFACES );
        if ( _hEnum != NULL )
        {
            int                                 _nIndex = 0;
            DWORD                               _dwType;
            LPWSTR                              _pszName = NULL;
            CComObject< CClusNetInterface > *   _pNetInterface = NULL;

            Clear();

            for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterNetworkEnum( _hEnum, _nIndex, &_dwType, &_pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNetInterface >::CreateInstance( &_pNetInterface );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                    _ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNetInterface > >    _ptrNetInterface( _pNetInterface );
                        BSTR                                            _bstr = NULL;

                        _bstr = SysAllocString( _pszName );
                        if ( _bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = _ptrNetInterface->Open( _ptrRefObject, _bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _ptrNetInterface->AddRef();
                                m_NetInterfaceList.insert( m_NetInterfaceList.end(), _ptrNetInterface );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the net interface to have been deleted from the cluster
                                //  in the time between creating the enum and opening the net interface.  When
                                //  that happens we need to simply skip that net interface and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster net interface was not found

                            SysFreeString( _bstr );
                        }
                    }

                    ::LocalFree( _pszName );
                    _pszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }

            ::ClusterNetworkCloseEnum( _hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusNetworkNetInterfaces::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworkNetInterfaces::get_Item
//
//  Description:
//      Return the object (NetworkNetinterface) at the passed in index.
//
//  Arguments:
//      varIndex                [IN]    - Contains the index requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworkNetInterfaces::get_Item(
    VARIANT                 varIndex,
    ISClusNetInterface **   ppClusterNetInterface
    )
{
    //ASSERT( ppClusterNetInterface != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetInterface != NULL )
    {
        _hr = GetNetInterfaceItem( varIndex, ppClusterNetInterface );
    }

    return _hr;

} //*** CClusNetworkNetInterfaces::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNodeNetInterfaces class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::CClusNodeNetInterfaces
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodeNetInterfaces::CClusNodeNetInterfaces( void )
{
    m_piids     = (const IID *) iidCClusNetInterfaces;
    m_piidsSize = ARRAYSIZE( iidCClusNetInterfaces );

} //*** CClusNodeNetInterfaces::CClusNodeNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::~CClusNodeNetInterfaces
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodeNetInterfaces::~CClusNodeNetInterfaces( void )
{
    Clear();

} //*** CClusNodeNetInterfaces::~CClusNodeNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::Create
//
//  Description:
//      Complete the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hNode           [IN]    - The handle of the node whose netinterfaces
//                              this collection holds.  The parent.
//
//  Return Value:
//      S_OK if successful, or E_POINTER is not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNodeNetInterfaces::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HNODE                hNode
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNetInterfaces::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hNode = hNode;
    } // if: args are not NULL

    return _hr;

} //*** CClusNodeNetInterfaces::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::get_Count
//
//  Description:
//      Return the count of objects (NodeNetinterfaces) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_NetInterfaceList.size();
        _hr = S_OK;
    } // if: args are not NULL

    return _hr;

} //*** CClusNodeNetInterfaces::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NetInterfacesList, CComObject< CClusNetInterface > >( ppunk, m_NetInterfaceList );

} //*** CClusNodeNetInterfaces::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::Refresh( void )
{
    HRESULT _hr = E_POINTER;
    DWORD   _sc = ERROR_SUCCESS;

    if ( m_hNode != NULL )
    {
        HNODEENUM   _hEnum = NULL;

        _hEnum = ::ClusterNodeOpenEnum( m_hNode, CLUSTER_NODE_ENUM_NETINTERFACES );
        if ( _hEnum != NULL )
        {
            int                                 _nIndex = 0;
            DWORD                               _dwType;
            LPWSTR                              _pszName = NULL;
            CComObject< CClusNetInterface > *   _pNetInterface = NULL;

            Clear();

            for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterNodeEnum( _hEnum, _nIndex, &_dwType, &_pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNetInterface >::CreateInstance( &_pNetInterface );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                    _ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNetInterface > >    _ptrNetInterface( _pNetInterface );
                        BSTR                                            _bstr = NULL;

                        _bstr = SysAllocString( _pszName );
                        if ( _bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = _ptrNetInterface->Open( _ptrRefObject, _bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _ptrNetInterface->AddRef();
                                m_NetInterfaceList.insert( m_NetInterfaceList.end(), _ptrNetInterface );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the net interface to have been deleted from the cluster
                                //  in the time between creating the enum and opening the net interface.  When
                                //  that happens we need to simply skip that net interface and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster net interface was not found

                            SysFreeString( _bstr );
                        }
                    }

                    ::LocalFree( _pszName );
                    _pszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }

            ::ClusterNodeCloseEnum( _hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;


} //*** CClusNodeNetInterfaces::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodeNetInterfaces::get_Item
//
//  Description:
//      Return the object (NodeNetinterface) at the passed in index.
//
//  Arguments:
//      varIndex                [IN]    - Contains the index requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodeNetInterfaces::get_Item(
    VARIANT                 varIndex,
    ISClusNetInterface **   ppClusterNetInterface
    )
{
    //ASSERT( ppClusterNetInterface != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetInterface != NULL )
    {
        _hr = GetNetInterfaceItem( varIndex, ppClusterNetInterface );
    }

    return _hr;

} //*** CClusNodeNetInterfaces::get_Item()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusnode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusNode.h
//
//	Description:
//		Definition of the node classes for the MSCLUS automation classes.
//
//	Implementation File:
//		ClusNode.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNODE_H_
#define _CLUSNODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNode;
class CNodes;
class CClusNodes;
class CClusResGroupPreferredOwnerNodes;
class CClusResPossibleOwnerNodes;

const IID IID_CClusNode = {0xf2e60800,0x2631,0x11d1,{0x89,0xf1,0x00,0xa0,0xc9,0x0d,0x06,0x1e}};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNode
//
//	Description:
//		Cluster Node Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNode, &IID_ISClusNode, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNode, &CLSID_ClusNode >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNode :
	public IDispatchImpl< ISClusNode, &IID_ISClusNode, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNode, &CLSID_ClusNode >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNode( void );
	~CClusNode( void );

BEGIN_COM_MAP(CClusNode)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNode)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IID(IID_CClusNode, CClusNode)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNode)
DECLARE_NO_REGISTRY()

private:
	HNODE				m_hNode;
	ISClusRefObject *	m_pClusRefObject;
	CComBSTR			m_bstrNodeName;

	CComObject< CClusResGroups > *			m_pResourceGroups;
	CComObject< CClusProperties > *			m_pCommonProperties;
	CComObject< CClusProperties > *			m_pPrivateProperties;
	CComObject< CClusProperties > *			m_pCommonROProperties;
	CComObject< CClusProperties > *			m_pPrivateROProperties;
	CComObject< CClusNodeNetInterfaces > *	m_pNetInterfaces;


	HRESULT Close( void );

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrNodeName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP get_Name( OUT BSTR * pbstrNodeName );

	STDMETHODIMP get_NodeID( OUT BSTR * pbstrNodeID );

	STDMETHODIMP get_State( OUT CLUSTER_NODE_STATE * dwState );

	STDMETHODIMP Pause( void );

	STDMETHODIMP Resume( void );

	STDMETHODIMP Evict( void );

	STDMETHODIMP get_ResourceGroups( OUT ISClusResGroups ** ppResourceGroups );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_NetInterfaces( OUT ISClusNodeNetInterfaces ** ppNetInterfaces );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrNodeName; };

	const HNODE & RhNode( void ) const { return m_hNode; };

}; //*** Class CClusNode

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CNodes
//
//	Description:
//		Cluster Nodes Collection Implementation Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CNodes
{
public:
	CNodes( void );
	~CNodes( void );

	HRESULT Create( ISClusRefObject * pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusNode > * >	NodeList;

	ISClusRefObject *	m_pClusRefObject;
	NodeList			m_Nodes;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNodeName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusNode * pClusterNode, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetItem( IN LPWSTR lpszNodeName, OUT ISClusNode ** ppClusterNode );

	HRESULT GetItem( IN UINT nIndex, OUT ISClusNode ** ppClusterNode );

	HRESULT GetNodeItem( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	HRESULT InsertAt( IN CComObject< CClusNode > * pNode, IN size_t pos );

	HRESULT RemoveAt( IN size_t pos );

}; //*** Class CNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNodes
//
//	Description:
//		Cluster Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNodes, &IID_ISClusNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes,
//		CComCoClass< CClusNodes, &CLSID_ClusNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNodes :
	public IDispatchImpl< ISClusNodes, &IID_ISClusNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusNodes, &CLSID_ClusNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNodes( void );
	~CClusNodes( void );

BEGIN_COM_MAP(CClusNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNodes)
DECLARE_NO_REGISTRY()

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP Refresh( void );

}; //*** CClusNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroupPreferredOwnerNodes
//
//	Description:
//		Cluster Group Owner Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroupPreferredOwnerNodes, &IID_ISClusResGroupPreferredOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes
//		CComCoClass< CClusResGroupPreferredOwnerNodes, &CLSID_ClusResGroupPreferredOwnerNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroupPreferredOwnerNodes :
	public IDispatchImpl< ISClusResGroupPreferredOwnerNodes, &IID_ISClusResGroupPreferredOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusResGroupPreferredOwnerNodes, &CLSID_ClusResGroupPreferredOwnerNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroupPreferredOwnerNodes( void );
	~CClusResGroupPreferredOwnerNodes( void );

BEGIN_COM_MAP(CClusResGroupPreferredOwnerNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroupPreferredOwnerNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroupPreferredOwnerNodes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject* pClusRefObject, IN CRefcountedHGROUP hGroup );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP InsertItem( IN ISClusNode* pNode, IN long nPostion );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP SaveChanges( void );

	STDMETHODIMP AddItem( IN ISClusNode* pNode );

private:
	CRefcountedHGROUP	m_hGroup;
	BOOL	m_bModified;

}; //*** Class CClusResGroupPreferredOwnerNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResPossibleOwnerNodes
//
//	Description:
//		Cluster Resource Owner Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResPossibleOwnerNodes, &IID_ISClusResPossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes
//		CComCoClass< CClusResPossibleOwnerNodes, &CLSID_ClusResPossibleOwnerNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResPossibleOwnerNodes :
	public IDispatchImpl< ISClusResPossibleOwnerNodes, &IID_ISClusResPossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusResPossibleOwnerNodes, &CLSID_ClusResPossibleOwnerNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResPossibleOwnerNodes( void );
	~CClusResPossibleOwnerNodes( void );

BEGIN_COM_MAP(CClusResPossibleOwnerNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResPossibleOwnerNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResPossibleOwnerNodes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP AddItem( IN ISClusNode * pNode );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

private:
	HRESOURCE	m_hResource;
	BOOL		m_bModified;

}; //*** Class CClusResPossibleOwnerNodes

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypePossibleOwnerNodes
//
//	Description:
//		Cluster Resource Type Possible Owner Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResTypePossibleOwnerNodes, &IID_ISClusResTypePossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes
//		CComCoClass< CClusResTypePossibleOwnerNodes, &CLSID_ClusResTypePossibleOwnerNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResTypePossibleOwnerNodes :
	public IDispatchImpl< ISClusResTypePossibleOwnerNodes, &IID_ISClusResTypePossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusResTypePossibleOwnerNodes, &CLSID_ClusResTypePossibleOwnerNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResTypePossibleOwnerNodes( void );
	~CClusResTypePossibleOwnerNodes( void );

BEGIN_COM_MAP(CClusResTypePossibleOwnerNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResTypePossibleOwnerNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResTypePossibleOwnerNodes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResTypeName );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

private:
	CComBSTR	m_bstrResTypeName;

}; //*** Class CClusResTypePossibleOwnerNodes

#endif // CLUSAPI_VERSION >= 0x0500

#endif // _CLUSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusnetw.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ClusNetW.cpp
//
//  Description:
//      Implementation of the network classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Ramakrishna Rosanuru via David Potter   (davidp)    5-Sep-1997
//      Galen Barbee                            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusneti.h"
#include "clusnetw.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusNetwork[] =
{
    &IID_ISClusNetwork
};

static const IID *  iidCClusNetworks[] =
{
    &IID_ISClusNetworks
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetwork class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::CClusterNetworkCClusterNetwork
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetwork::CClusNetwork( void )
{
    m_hNetwork              = NULL;
    m_pClusRefObject        = NULL;
    m_pNetInterfaces        = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;

    m_piids              = (const IID *) iidCClusNetwork;
    m_piidsSize          = ARRAYSIZE( iidCClusNetwork );

} //*** CClusNetwork::CClusNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::~CClusNetwork
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetwork::~CClusNetwork( void )
{
    if ( m_hNetwork != NULL )
    {
        CloseClusterNetwork( m_hNetwork );
    } // if:

    if ( m_pNetInterfaces != NULL )
    {
        m_pNetInterfaces->Release();
        m_pNetInterfaces = NULL;
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CClusNetwork::~CClusNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::Open
//
//  Description:
//      Open the passed in network.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrNetworkName [IN]    - The name of the interface to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetwork::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrNetworkName
    )
{
    ASSERT( pClusRefObject != NULL );
    //ASSERT( bstrNetworkName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject ) && ( bstrNetworkName != NULL ) )
    {
        HCLUSTER hCluster;

        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        _hr = m_pClusRefObject->get_Handle((ULONG_PTR *) &hCluster);
        if ( SUCCEEDED( _hr ) )
        {
            m_hNetwork = OpenClusterNetwork( hCluster, bstrNetworkName );
            if ( m_hNetwork == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            }
            else
            {
                m_bstrNetworkName = bstrNetworkName;
                _hr = S_OK;
            } // else:
        } // if:
    } // if:

    return _hr;

} //*** CClusNetwork::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Network).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetwork::GetProperties(
    OUT ISClusProperties ** ppProperties,
    IN  BOOL                bPrivate,
    IN  BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject< CClusProperties > * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusNetwork::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_Handle
//
//  Description:
//      Return the raw handle to this objec (Network).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        *phandle = (ULONG_PTR) m_hNetwork;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetwork::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::put_Name
//
//  Description:
//      Change the name of this object (Network).
//
//  Arguments:
//      bstrNetworkName [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::put_Name( IN BSTR bstrNetworkName )
{
    //ASSERT( bstrNetworkName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrNetworkName != NULL )
    {
        DWORD _sc = ERROR_SUCCESS;

        _sc = SetClusterNetworkName( m_hNetwork, bstrNetworkName );
        if ( _sc == ERROR_SUCCESS )
        {
            m_bstrNetworkName = bstrNetworkName;
        }

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;


} //*** CClusNetwork::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_Name
//
//  Description:
//      Return the name of this object (Network).
//
//  Arguments:
//      pbstrNetworkName    [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_Name( OUT BSTR * pbstrNetworkName )
{
    //ASSERT( pbstrNetworkName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNetworkName != NULL )
    {
        *pbstrNetworkName = m_bstrNetworkName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetwork::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_NetworkID
//
//  Description:
//      Get the network ID of this network.
//
//  Arguments:
//      pbstrNetworkID  [OUT]   - Catches the network ID.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_NetworkID( OUT BSTR * pbstrNetworkID )
{
    //ASSERT( pbstrNetworkID != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNetworkID != NULL )
    {
        WCHAR * pszNetworkID;
        DWORD   dwBytes = 0;
        DWORD   dwRet = ERROR_SUCCESS;

        dwRet = ::GetClusterNetworkId( m_hNetwork, NULL, &dwBytes );
        if ( SUCCEEDED( dwRet ) )
        {
            pszNetworkID = new WCHAR [ dwBytes + 1 ];
            if ( pszNetworkID != NULL )
            {
                dwRet = ::GetClusterNetworkId( m_hNetwork, pszNetworkID, &dwBytes );
                if ( SUCCEEDED( dwRet ) )
                {
                    *pbstrNetworkID = ::SysAllocString( pszNetworkID );
                    if ( *pbstrNetworkID == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        _hr = S_OK;
                    }
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( dwRet );
                }

                delete [] pszNetworkID;
            }
            else
            {
                _hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            _hr = HRESULT_FROM_WIN32( dwRet );
        }
    }

    return _hr;

} //*** CClusNetwork::get_NetworkID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_State
//
//  Description:
//      Returns the current state of this object (Network).
//
//  Arguments:
//      cnsState    [OUT]   - Catches the state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_State( OUT CLUSTER_NETWORK_STATE * cnsState )
{
    //ASSERT( cnsState != NULL );

    HRESULT _hr = E_POINTER;

    if ( cnsState != NULL )
    {
        CLUSTER_NETWORK_STATE   _cns = ::GetClusterNetworkState( m_hNetwork );

        if ( _cns == ClusterNetworkStateUnknown )
        {
            DWORD   _sc = ::GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        } // if: error
        else
        {
            *cnsState = _cns;
            _hr = S_OK;
        } // else: success
    } // if: args are not NULL

    return _hr;

} //*** CClusNetwork::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_CommonProperties
//
//  Description:
//      Get this object's (Network) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr =   m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_PrivateProperties
//
//  Description:
//      Get this object's (Network) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_CommonROProperties
//
//  Description:
//      Get this object's (Network) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_PrivateROProperties
//
//  Description:
//      Get this object's (Network) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_PrivateROProperties(
    ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusNetwork::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_NetInterfaces
//
//  Description:
//      Creates a collection of netinterfaces for this network.
//
//  Arguments:
//      ppNetInterfaces [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_NetInterfaces(
    OUT ISClusNetworkNetInterfaces ** ppNetInterfaces
    )
{
    return ::HrCreateResourceCollection< CClusNetworkNetInterfaces, ISClusNetworkNetInterfaces, HNETWORK >(
                        &m_pNetInterfaces,
                        m_hNetwork,
                        ppNetInterfaces,
                        IID_ISClusNetworkNetInterfaces,
                        m_pClusRefObject
                        );

} //*** CClusNetwork::get_NetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::get_Cluster
//
//  Description:
//      Return the cluster this object (Network) belongs to.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetwork::get_Cluster(
    ISCluster ** ppCluster
    )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusNetwork::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetwork::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;


    if ( bReadOnly )
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES
                        : CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_NETWORK_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetNetworkProperties( m_hNetwork, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusNetwork::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetwork::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusNetwork::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES : CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterNetworkControl(
                        m_hNetwork,
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusNetwork::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNetworks class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::CClusNetworks
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworks::CClusNetworks( void )
{
    m_pClusRefObject    = NULL;
    m_piids             = (const IID *) iidCClusNetworks;
    m_piidsSize         = ARRAYSIZE( iidCClusNetworks );

} //*** CClusNetworks::CClusNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::~CClusNetworks
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworks::~CClusNetworks( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CClusNetworks::~CClusNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful, E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNetworks::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::get_Count
//
//  Description:
//      Return the count of objects (Networks) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_NetworkList.size();
        _hr = S_OK;
    } // if: args are not NULL

    return _hr;

} //*** CClusNetworks::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::get__NewEnum( IUnknown ** punk )
{
    return ::HrNewIDispatchEnum< NetworkList, CComObject< CClusNetwork > >( punk, m_NetworkList );

} //*** CClusNetworks::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::Refresh( void )
{
    HRESULT     _hr = E_POINTER;
    DWORD       _sc = ERROR_SUCCESS;
    HCLUSENUM   hEnum = NULL;
    HCLUSTER    hCluster = NULL;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_NETWORK );
        if ( hEnum != NULL )
        {
            int                             _nIndex = 0;
            DWORD                           dwType = 0;
            LPWSTR                          pszName = NULL;
            CComObject< CClusNetwork > *    pNetwork = NULL;

            Clear();

            for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNetwork >::CreateInstance( &pNetwork );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNetwork > >         ptrNetwork( pNetwork );
                        BSTR                                            _bstr = NULL;

                        _bstr = SysAllocString( pszName );
                        if ( _bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = ptrNetwork->Open( ptrRefObject, _bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrNetwork->AddRef();
                                m_NetworkList.insert( m_NetworkList.end(), ptrNetwork );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NETWORK_NOT_FOUND )
                            {
                                //
                                //  It is possible for the network to have been deleted from the cluster
                                //  in the time between creating the enum and opening the network.  When
                                //  that happens we need to simply skip that network and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster network was not found

                            SysFreeString( _bstr );
                        }
                    }

                    ::LocalFree( pszName );
                    pszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }

            ::ClusterCloseEnum( hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;


} //*** CClusNetworks::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::Clear
//
//  Description:
//      Empty the collection of networks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusNetworks::Clear( void )
{
    ::ReleaseAndEmptyCollection< NetworkList, CComObject< CClusNetwork > >( m_NetworkList );

} //*** CClusNetworks::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::FindItem
//
//  Description:
//      Find a network in the collection by name and return its index.
//
//  Arguments:
//      lpszNetworkName [IN]    - The name to look for.
//      pnIndex         [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::FindItem(
    IN  LPWSTR  lpszNetworkName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( lpszNetworkName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( lpszNetworkName != NULL ) && ( pnIndex != NULL ) )
    {
        CComObject< CClusNetwork > *    pNetwork = NULL;
        NetworkList::iterator           first = m_NetworkList.begin();
        NetworkList::iterator           last    = m_NetworkList.end();
        UINT                            iIndex = 0;

        _hr = E_INVALIDARG;

        for ( ; first != last; first++, iIndex++ )
        {
            pNetwork = *first;

            if ( pNetwork && ( lstrcmpi( lpszNetworkName, pNetwork->Name() ) == 0 ) )
            {
                *pnIndex = iIndex;
                _hr = S_OK;
                break;
            }
        }
    } // if: args are not NULL

    return _hr;

} //*** CClusNetworks::FindItem( lpszNetworkName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::FindItem
//
//  Description:
//      Find a network in the collection and return its index.
//
//  Arguments:
//      pClusterNetwork [IN]    - The network to look for.
//      pnIndex         [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::FindItem(
    IN  ISClusNetwork * pClusterNetwork,
    OUT UINT *          pnIndex
    )
{
    //ASSERT( pClusterNetwork != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusterNetwork != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR    bstrName;

        _hr = pClusterNetwork->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CClusNetworks::FindItem( pClusterNetwork )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;
    UINT    nIndex = 0;

    if ( pnIndex != NULL )
    {
        CComVariant v;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_NetworkList.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusNetworks::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::GetItem
//
//  Description:
//      Return the item (Network) by name.
//
//  Arguments:
//      lpszNetworkName         [IN]    - The name of the item requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::GetItem(
    IN  LPWSTR              lpszNetworkName,
    OUT ISClusNetwork **    ppClusterNetwork
    )
{
    //ASSERT( lpszNetworkName != NULL );
    //ASSERT( ppClusterNetwork != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( lpszNetworkName != NULL ) && ( ppClusterNetwork != NULL ) )
    {
        CComObject<CClusNetwork> *  pNetwork = NULL;
        NetworkList::iterator           first = m_NetworkList.begin();
        NetworkList::iterator           last    = m_NetworkList.end();

        while ( first != last )
        {
            pNetwork = *first;

            if ( lstrcmpi( lpszNetworkName, pNetwork->Name() ) == 0 )
            {
                _hr = pNetwork->QueryInterface( IID_ISClusNetwork, (void **) ppClusterNetwork );
                break;
            }

            first++;
        }
    }

    return _hr;

} //*** CClusNetworks::GetItem( lpszNetworkName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::GetItem
//
//  Description:
//      Return the item (Network) by index.
//
//  Arguments:
//      nIndex                  [IN]    - The index of the item requested.
//      ppClusterNetInterface   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNetworks::GetItem(
    IN  UINT                nIndex,
    OUT ISClusNetwork **    ppClusterNetwork
    )
{
    //ASSERT( ppClusterNetwork != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetwork != NULL )
    {
        // Automation collections are 1-relative for languages like VB.
        // We are 0-relative internally.
        nIndex--;

        if ( nIndex < m_NetworkList.size() )
        {
            CComObject< CClusNetwork > * pNetwork = m_NetworkList[ nIndex ];

            _hr = pNetwork->QueryInterface( IID_ISClusNetwork, (void **) ppClusterNetwork );
        } // if: index is in range
        else
        {
            _hr = E_INVALIDARG;
        } // else: index is out of range
    }

    return _hr;

} //*** CClusNetworks::GetItem( nIndex )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNetworks::get_Item
//
//  Description:
//      Return the object (Network) at the passed in index.
//
//  Arguments:
//      varIndex            [IN]    - Contains the index requested.
//      ppClusterNetwork    [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNetworks::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusNetwork **    ppClusterNetwork
    )
{
    //ASSERT( ppClusterNetwork != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNetwork != NULL )
    {
        CComObject<CClusNetwork> *  pNetwork = NULL;
        UINT                            nIndex = 0;

        // Zero the out param
        *ppClusterNetwork = 0;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pNetwork = m_NetworkList[ nIndex ];
            _hr = pNetwork->QueryInterface( IID_ISClusNetwork, (void **) ppClusterNetwork );
        }
    }

    return _hr;

} //*** CClusNetworks::get_Item()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusnetw.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusNetW.h
//
//	Description:
//		Definition of the network classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusNetW.cpp
//
//	Author:
//		Ramakrishna Rosanuru via David Potter	(davidp)	5-Sep-1997
//		Galen Barbee							(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNETW_H_
#define _CLUSNETW_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNetwork;
class CClusNetworks;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetwork
//
//	Description:
//		Cluster Network Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetwork, &IID_ISClusNetwork, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo,
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNetwork, &CLSID_ClusNetwork >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetwork :
	public IDispatchImpl< ISClusNetwork, &IID_ISClusNetwork, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNetwork, &CLSID_ClusNetwork >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetwork( void );
	~CClusNetwork( void );

BEGIN_COM_MAP(CClusNetwork)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetwork)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetwork)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *	m_pClusRefObject;
	HNETWORK			m_hNetwork;
	CComBSTR			m_bstrNetworkName;

	CComObject< CClusNetworkNetInterfaces > *	m_pNetInterfaces;
	CComObject< CClusProperties > *				m_pCommonProperties;
	CComObject< CClusProperties > *				m_pPrivateProperties;
	CComObject< CClusProperties > *				m_pCommonROProperties;
	CComObject< CClusProperties > *				m_pPrivateROProperties;


	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrNetworkName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP get_Name( OUT BSTR * pbstrNetworkName );

	STDMETHODIMP put_Name( IN BSTR pbstrNetworkName );

	STDMETHODIMP get_NetworkID( OUT BSTR * pbstrNetworkID );

	STDMETHODIMP get_State( OUT CLUSTER_NETWORK_STATE * dwState );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties	);

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_NetInterfaces( OUT ISClusNetworkNetInterfaces ** ppNetInterfaces	);

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrNetworkName ; };

}; //*** Class CClusNetwork

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusNetworks
//
//	Description:
//		Cluster Networks Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusNetworks, &IID_ISClusNetworks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo,
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusNetworks, &CLSID_ClusNetworks >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusNetworks :
	public IDispatchImpl< ISClusNetworks, &IID_ISClusNetworks, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusNetworks, &CLSID_ClusNetworks >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusNetworks( void );
	~CClusNetworks( void );

BEGIN_COM_MAP(CClusNetworks)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusNetworks)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNetworks)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject* pClusRefObject );

protected:
	typedef std::vector< CComObject<CClusNetwork> * >	NetworkList;

	NetworkList			m_NetworkList;
	ISClusRefObject *	m_pClusRefObject;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszNetworkName, OUT UINT * pnIndex	);

	HRESULT FindItem( IN ISClusNetwork * pClusterNetwork, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetItem( IN LPWSTR lpszNetworkName, OUT ISClusNetwork ** ppClusterNetwork );

	HRESULT GetItem( IN UINT nIndex, OUT ISClusNetwork ** ppClusterNetwork );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNetwork ** ppClusterNetwork );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusNetworks

#endif // _CLUSNETW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusresg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ClusResG.cpp
//
//  Description:
//      Implementation of the resource group classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusneti.h"
#include "clusnode.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID * iidCClusResGroup[] =
{
    &IID_ISClusResGroup
};

static const IID * iidCClusResGroups[] =
{
    &IID_ISClusResGroups
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroup class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::CClusResGroup
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroup::CClusResGroup( void )
{
    m_hGroup                = NULL;
    m_pClusRefObject        = NULL;
    m_pClusterResources     = NULL;
    m_pPreferredOwnerNodes  = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;

    m_piids     = (const IID *) iidCClusResGroup;
    m_piidsSize = ARRAYSIZE( iidCClusResGroup );

} //*** CClusResGroup::CClusResGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::~CClusResGroup
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroup::~CClusResGroup( void )
{
    // m_hGroup will be auto released

    if ( m_pClusterResources != NULL )
    {
        m_pClusterResources->Release();
        m_pClusterResources = NULL;
    }

    if ( m_pPreferredOwnerNodes != NULL )
    {
        m_pPreferredOwnerNodes->Release();
        m_pPreferredOwnerNodes = NULL;
    }

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CClusResGroup::~CClusResGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrGroupName   [IN]    - The name of this group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrGroupName
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrGroupName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrGroupName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        HCLUSTER    _hCluster = 0;

        _hr = m_pClusRefObject->get_Handle((ULONG_PTR *) &_hCluster);
        if ( SUCCEEDED( _hr ) )
        {
            HGROUP hGroup = ::CreateClusterGroup( _hCluster, bstrGroupName );
            if ( hGroup == 0 )
            {
                DWORD   _sc = GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
            }
            else
            {
                m_hGroup = CRefCountedHandle<GroupHandle>::Create(hGroup);
                if (m_hGroup == 0)
                {
                    DWORD   _sc = GetLastError();
                    ::CloseClusterGroup(hGroup);
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
                else
                {
                    m_bstrGroupName = bstrGroupName;
                    _hr = S_OK;
                }
            }
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CClusResGroup::Create() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResGroup::Create() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResGroup::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Open
//
//  Description:
//      Open the passed group on the cluster.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrGroupName   [IN]    - The name of this group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrGroupName
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrGroupName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrGroupName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        HCLUSTER _hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            HGROUP hGroup = ::OpenClusterGroup( _hCluster, bstrGroupName );
            if ( hGroup == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            }
            else
            {
                m_hGroup = CRefCountedHandle<GroupHandle>::Create(hGroup);
                if ( m_hGroup == NULL )
                {
                    DWORD   _sc = GetLastError();
                    ::CloseClusterGroup(hGroup);
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
                else
                {
                    m_bstrGroupName = bstrGroupName;
                    _hr = S_OK;
                }
            }
        }
    }

    return _hr;

} //*** CClusResGroup::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Resource Group).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject<CClusProperties> * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusResGroup::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_Handle
//
//  Description:
//      Returns the handle to this object (Group).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        *phandle = (ULONG_PTR)m_hGroup->get_Handle();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroup::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Close
//
//  Description:
//      Close the handle to the cluster object (Group).
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Close( void )
{
    if ( m_pClusRefObject )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

    // SmartPointer will deref the handle properly when assigned NULL
    m_hGroup = NULL;

    return S_OK;

} //*** CClusResGroup::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::put_Name
//
//  Description:
//      Change the name of this object (Group).
//
//  Arguments:
//      bstrGroupName   [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::put_Name( IN BSTR bstrGroupName )
{
    //ASSERT( bstrGroupName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrGroupName != NULL )
    {
        DWORD   _sc = ::SetClusterGroupName( m_hGroup->get_Handle(), bstrGroupName );

        if ( _sc == ERROR_SUCCESS )
        {
            m_bstrGroupName = bstrGroupName;
        }

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResGroup::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_Name
//
//  Description:
//      Return the name of this object (Resource Group).
//
//  Arguments:
//      pbstrGroupName  [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Name( OUT BSTR * pbstrGroupName )
{
    //ASSERT( pbstrGroupName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrGroupName != NULL )
    {
        *pbstrGroupName = m_bstrGroupName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroup::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_State
//
//  Description:
//      Returns the current cluster group state for this group.
//
//  Arguments:
//      pcgsState   [OUT]   - Catches the cluster group state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_State( OUT CLUSTER_GROUP_STATE * pcgsState )
{
    //ASSERT( pcgsState != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcgsState != NULL )
    {
        CLUSTER_GROUP_STATE _cgsState = ::WrapGetClusterGroupState( m_hGroup->get_Handle(), NULL );

        if ( _cgsState == ClusterGroupStateUnknown )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pcgsState = _cgsState;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusResGroup::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_OwnerNode
//
//  Description:
//      Returns the owner node for this group.  The owner node is the node
//      where the group is currently online.
//
//  Arguments:
//      ppOwnerNode [OUT[   - Catches the owner node interface.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_OwnerNode( OUT ISClusNode ** ppOwnerNode )
{
    //ASSERT( ppOwnerNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppOwnerNode != NULL )
    {
        DWORD               _sc = 0;
        PWCHAR              pwszNodeName = NULL;
        CLUSTER_GROUP_STATE cgs = ClusterGroupStateUnknown;

        cgs = WrapGetClusterGroupState( m_hGroup->get_Handle(), &pwszNodeName );
        if ( cgs != ClusterGroupStateUnknown )
        {
            CComObject<CClusNode> * pNode = NULL;

            *ppOwnerNode = NULL;

            _hr = CComObject<CClusNode>::CreateInstance( &pNode );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >    ptrRefObject( m_pClusRefObject );
                BSTR                            bstr = NULL;

                bstr = SysAllocString( pwszNodeName );
                if ( bstr == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                else
                {
                    pNode->AddRef();
                    _hr = pNode->Open( ptrRefObject, bstr );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppOwnerNode );
                    }

                    pNode->Release();
                    SysFreeString( bstr );
                }
            }

            ::LocalFree( pwszNodeName );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResGroup::get_OwnerNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_Resources
//
//  Description:
//      Returns the collection of resources that belong to this group.
//
//  Arguments:
//      ppClusterGroupResources [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Resources(
    OUT ISClusResGroupResources ** ppClusterGroupResources
    )
{
    return ::HrCreateResourceCollection< CClusResGroupResources, ISClusResGroupResources, CRefcountedHGROUP >(
                        &m_pClusterResources,
                        m_hGroup,
                        ppClusterGroupResources,
                        IID_ISClusResGroupResources,
                        m_pClusRefObject
                        );

} //*** CClusResGroup::get_Resources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_PreferredOwnerNodes
//
//  Description:
//      Returns the collection of preferred owner nodes for this group.
//
//  Arguments:
//      ppOwnerNodes    [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_PreferredOwnerNodes(
    ISClusResGroupPreferredOwnerNodes ** ppOwnerNodes
    )
{
    return ::HrCreateResourceCollection< CClusResGroupPreferredOwnerNodes, ISClusResGroupPreferredOwnerNodes, CRefcountedHGROUP >(
                        &m_pPreferredOwnerNodes,
                        m_hGroup,
                        ppOwnerNodes,
                        IID_ISClusResGroupPreferredOwnerNodes,
                        m_pClusRefObject
                        );

} //*** CClusResGroup::get_PreferredOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Delete
//
//  Description:
//      Removes this object (Resource Group) from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Delete( void )
{
    DWORD   _sc = ERROR_INVALID_HANDLE;

    if ( m_hGroup != NULL )
    {
        _sc = DeleteClusterGroup( m_hGroup->get_Handle() );
        if ( _sc == ERROR_SUCCESS )
        {
            m_hGroup = NULL;
        }
    }
/*
    if ( _sc == ERROR_SUCCESS )
    {
        OutputDebugStringW( L"CClusResGroup::Delete() succeeded.\n" );
    } // if: success
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResGroup::Delete() failed. (handle = %d) (sc = %#08x)\n", m_hGroup->get_Handle(), _sc );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return HRESULT_FROM_WIN32( _sc );

} //*** CClusResGroup::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Online
//
//  Description:
//      Bring this group online on the passed in node, or on to the node
//      it is currently offline if no node is specified.
//
//  Arguments:
//      varTimeout  [IN]    - How long in seconds to wait for the group to
//                          come online.
//      varNode     [IN]    - Node to bring the group online.
//      pvarPending [OUT]   - Catches the pending state.  True if we timed
//                          out before the group came completely online.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Online(
    IN  VARIANT     varTimeout,
    IN  VARIANT     varNode,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( pNode != NULL );
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        _hr = ::VariantChangeTypeEx( &varTimeout, &varTimeout, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            HNODE                       _hNode = NULL;
            HCLUSTER                    _hCluster = NULL;
            CComObject< CClusNode > *   _pcnNode = NULL;
            ISClusNode *                _piscNode = NULL;

            pvarPending->vt         = VT_BOOL;
            pvarPending->boolVal    = VARIANT_FALSE;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                if ( varNode.vt == ( VT_VARIANT | VT_BYREF ) )
                {
                    if ( varNode.pvarVal != NULL )
                    {
                        IDispatch *     _pidNode = varNode.pvarVal->pdispVal;

                        _hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
                            _piscNode->Release();
                        } // if: did we get the ISClusNode interface?
                    } // if: we have a variant value pointer
                } // if: was the option parameter present?
                else if ( varNode.vt == VT_DISPATCH )
                {
                    IDispatch *     _pidNode = varNode.pdispVal;

                    _hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
                        _piscNode->Release();
                    } // if: did we get the ISClusNode interface?
                } // else if: we have a dispatch variant
                else if ( varNode.vt == VT_BSTR )
                {
                    _hr = CComObject< CClusNode >::CreateInstance( &_pcnNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _pcnNode->AddRef();

                        _hr = _pcnNode->Open( m_pClusRefObject, ( varNode.vt & VT_BYREF) ? (*varNode.pbstrVal) : varNode.bstrVal );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _hr = _pcnNode->get_Handle( (ULONG_PTR *) &_hNode );
                        } // if:
                    } // if:
                } // else if: we have a string variant
                else if ( varNode.vt == VT_EMPTY )
                {
                    _hNode = NULL;
                } // else if: it is empty
                else if ( ( varNode.vt == VT_ERROR ) && ( varNode.scode == DISP_E_PARAMNOTFOUND ) )
                {
                    _hNode = NULL;
                } // else if: the optional parameter was not specified
                else
                {
                    _hr = ::VariantChangeTypeEx( &varNode, &varNode, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( varNode.lVal != 0 )
                        {
                            _hr = E_INVALIDARG;
                        } // if: this is not zero then we cannot accept this parameter format.  If varNode.lVal was zero then we could assume it was a NULL arg...
                    } // if:  coerce to a long
                } // else: the node variant could be invalid -- check for a zero, and if found treat it like a NULL...

                if ( SUCCEEDED( _hr ) )
                {
                    BOOL    bPending = FALSE;

                    _hr = ::HrWrapOnlineClusterGroup(
                                        _hCluster,
                                        m_hGroup->get_Handle(),
                                        _hNode,
                                        varTimeout.lVal,
                                        (long *) &bPending
                                        );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( bPending )
                        {
                            pvarPending->boolVal = VARIANT_TRUE;
                        } // if: pending?
                    } // if: online succeeded
                } // if: we have a node handle
            } // if: get_Handle() -- cluster handle

            if ( _pcnNode != NULL )
            {
                _pcnNode->Release();
            } // if: did we create a node?
        } // if: wasn't the right type
    } //if: pvarPending != NULL

    return _hr;

} //*** CClusResGroup::Online()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Move
//
//  Description:
//      Move this group to the passed in node, or to the best available node
//      if no node was passed, and restore its online state.
//
//  Arguments:
//      varTimeout  [IN]    - How long in seconds to wait for the group to
//                          come move and complete stat restoration.
//      varNode     [IN]    - Node to move the group to.
//      pvarPending [OUT]   - Catches the pending state.  True if we timed
//                          out before the group came completely online.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Move(
    IN  VARIANT     varTimeout,
    IN  VARIANT     varNode,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( pNode != NULL );
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        _hr = ::VariantChangeTypeEx( &varTimeout, &varTimeout, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            HNODE                       _hNode = NULL;
            HCLUSTER                    _hCluster = NULL;
            CComObject< CClusNode > *   _pcnNode = NULL;
            ISClusNode *                _piscNode = NULL;

            pvarPending->vt         = VT_BOOL;
            pvarPending->boolVal    = VARIANT_FALSE;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                if ( varNode.vt == ( VT_VARIANT | VT_BYREF ) )
                {
                    ASSERT( varNode.pvarVal != NULL );

                    VARIANT * _pvar = varNode.pvarVal;

                    if ( _pvar->vt == VT_DISPATCH )
                    {
                        IDispatch *     _pidNode = _pvar->pdispVal;

                        _hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
                            _piscNode->Release();
                        } // if: did we get the ISClusNode interface?
                    } // if: variant value point is to an IDispatch
                    else if ( _pvar->vt == VT_BSTR )
                    {
                        _hr = CComObject< CClusNode >::CreateInstance( &_pcnNode );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _pcnNode->AddRef();

                            _hr = _pcnNode->Open( m_pClusRefObject, _pvar->bstrVal );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = _pcnNode->get_Handle( (ULONG_PTR *) &_hNode );
                            } // if:
                        } // if:
                    } // else if:
                } // if: was the option parameter present?
                else if ( varNode.vt == VT_DISPATCH )
                {
                    IDispatch *     _pidNode = varNode.pdispVal;

                    _hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
                        _piscNode->Release();
                    } // if: did we get the ISClusNode interface?
                } // else if: we have a dispatch variant
                else if ( varNode.vt == VT_BSTR )
                {
                    _hr = CComObject< CClusNode >::CreateInstance( &_pcnNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _pcnNode->AddRef();

                        _hr = _pcnNode->Open( m_pClusRefObject, ( varNode.vt & VT_BYREF) ? (*varNode.pbstrVal) : varNode.bstrVal );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _hr = _pcnNode->get_Handle( (ULONG_PTR *) &_hNode );
                        } // if:
                    } // if:
                } // else if: we have a string variant
                else if ( varNode.vt == VT_EMPTY )
                {
                    _hNode = NULL;
                } // else if: it is empty
                else if ( ( varNode.vt == VT_ERROR ) && ( varNode.scode == DISP_E_PARAMNOTFOUND ) )
                {
                    _hNode = NULL;
                } // else if: the optional parameter was not specified
                else
                {
                    _hr = ::VariantChangeTypeEx( &varNode, &varNode, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( varNode.lVal != 0 )
                        {
                            _hr = E_INVALIDARG;
                        } // if: this is not zero then we cannot accept this parameter format.  If varNode.lVal was zero then we could assume it was a NULL arg...
                    } // if:  coerce to a long
                } // else: the node variant could be invalid -- check for a zero, and if found treat it like a NULL...

                if ( SUCCEEDED( _hr ) )
                {
                    BOOL    bPending = FALSE;

                    _hr = ::HrWrapMoveClusterGroup(
                                    _hCluster,
                                    m_hGroup->get_Handle(),
                                    _hNode,
                                    varTimeout.lVal,
                                    (long *) &bPending
                                    );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( bPending )
                        {
                            pvarPending->boolVal = VARIANT_TRUE;
                        } // if: pending?
                    } // if: Move group succeeded
                } // if: we have all handles
            } // if: get_Handle() -- cluster handle

            if ( _pcnNode != NULL )
            {
                _pcnNode->Release();
            } // if: did we create a node?
        } // if: wasn't the right type
    } //if: pvarPending != NULL

    return _hr;

} //*** CClusResGroup::Move()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::Offline
//
//  Description:
//      Take the group offline.
//
//  Arguments:
//      varTimeout  [IN]    - How long in seconds to wait for the group to
//                          go offline.
//      pvarPending [OUT]   - Catches the pending state.  True if we timed
//                          out before the group came completely online.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Offline(
    IN  VARIANT     varTimeout,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( nTimeout >= 0 );
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        _hr = ::VariantChangeTypeEx( &varTimeout, &varTimeout, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            HCLUSTER    _hCluster;

            pvarPending->vt         = VT_BOOL;
            pvarPending->boolVal    = VARIANT_FALSE;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                BOOL    bPending = FALSE;

                _hr = ::HrWrapOfflineClusterGroup( _hCluster, m_hGroup->get_Handle(),
                    varTimeout.lVal, (long *) &bPending );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( bPending )
                    {
                        pvarPending->boolVal = VARIANT_TRUE;
                    } // if: pending?
                } // if: offline group succeeded
            } // if: get_Handle() -- cluster handle
        } // if: wasn't the right type
    } //if: pvarPending != NULL

    return _hr;

} //*** CClusResGroup::Offline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_CommonProperties
//
//  Description:
//      Get this object's (Resource Group) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusResGroup::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_PrivateProperties
//
//  Description:
//      Get this object's (Resource Group) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusResGroup::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_CommonROProperties
//
//  Description:
//      Get this object's (Resource Group) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusResGroup::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_PrivateROProperties
//
//  Description:
//      Get this object's (Resource Group) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusResGroup::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::get_Cluster
//
//  Description:
//      Returns the cluster object for the cluster where this group lives.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Cluster( OUT ISCluster ** ppCluster )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusResGroup::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;


    if ( bReadOnly )
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES
                        : CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_GROUP_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetGroupProperties( m_hGroup->get_Handle(), _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusResGroup::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroup::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResGroup::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES : CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterGroupControl(
                        m_hGroup->get_Handle(),
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusResGroup::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroups class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::CClusResGroups
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroups::CClusResGroups( void )
{
    m_pClusRefObject    = NULL;
    m_piids             = (const IID *) iidCClusResGroups;
    m_piidsSize         = ARRAYSIZE( iidCClusResGroups );

} //*** CClusResGroups::CClusResGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::~CClusResGroups
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroups::~CClusResGroups( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CClusResGroups::~CClusResGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      pwszNodeName    [IN]    - Optional node name.  If this argument
//                              is supplied then this is a collection of
//                              groups that are owned by that node.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN LPCWSTR              pwszNodeName
    )
{
    ASSERT( pClusRefObject != NULL );
    //ASSERT( pwszNodeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) /*&& ( pwszNodeName != NULL )*/ )
    {
        m_pClusRefObject= pClusRefObject;
        m_pClusRefObject->AddRef();
        m_bstrNodeName = pwszNodeName;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroups::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::FindItem
//
//  Description:
//      Find the passed in group in the collection.
//
//  Arguments:
//      pszGroupName    [IN]    - The name of the group to find.
//      pnIndex         [OUT]   - Catches the index of the group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the group was
//      not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::FindItem(
    IN  LPWSTR  pszGroupName,
    OUT ULONG * pnIndex
    )
{
    //ASSERT( pszGroupName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pszGroupName != NULL ) && ( pnIndex != NULL ) )
    {
        CComObject<CClusResGroup> * pGroup = NULL;
        int                         nMax = m_ResourceGroups.size();

        _hr = E_INVALIDARG;

        for( int i = 0; i < nMax; i++ )
        {
            pGroup = m_ResourceGroups[ i ];

            if ( pGroup && ( lstrcmpi( pszGroupName, pGroup->Name() ) == 0 ) )
            {
                *pnIndex = i;
                _hr = S_OK;
                break;
            }
        }
    }

    return _hr;

} //*** CClusResGroups::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::FindItem
//
//  Description:
//      Find the passed in group in the collection.
//
//  Arguments:
//      pResourceGroup  [IN]    - The group to find.
//      pnIndex         [OUT]   - Catches the index of the group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG is the group was
//      not found.
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::FindItem(
    IN  ISClusResGroup *    pResourceGroup,
    OUT ULONG *             pnIndex
    )
{
    //ASSERT( pResourceGroup != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pResourceGroup != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR _bstrName;

        _hr = pResourceGroup->get_Name( &_bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( _bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CClusResGroups::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::GetIndex
//
//  Description:
//      Get the index from the passed in variant.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number,
//                          or the name of the group as a string.
//      pnIndex     [OUT]   - Catches the zero based index in the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::GetIndex(
    IN  VARIANT varIndex,
    OUT ULONG * pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        ULONG       nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_ResourceGroups.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusResGroups::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::RemoveAt
//
//  Description:
//      Remove the object (Group) at the passed in index/position from the
//      collection.
//
//  Arguments:
//      nPos    [IN]    - Index of the object to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG is the index is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::RemoveAt( IN size_t pos )
{
    CComObject<CClusResGroup> * pResourceGroup = NULL;
    ResourceGroupList::iterator      first = m_ResourceGroups.begin();
    ResourceGroupList::iterator      last   = m_ResourceGroups.end();
    HRESULT                          _hr = E_INVALIDARG;

    for ( size_t t = 0; ( t < pos ) && ( first != last ); t++, first++ );

    if ( first != last )
    {
        pResourceGroup = *first;
        if ( pResourceGroup )
        {
            pResourceGroup->Release();
        }

        m_ResourceGroups.erase( first );
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroups::RemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::get_Count
//
//  Description:
//      Returns the count of elements (Groups) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_ResourceGroups.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroups::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::Clear
//
//  Description:
//      Clean out the vector of ClusResGroup objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusResGroups::Clear( void )
{
    ::ReleaseAndEmptyCollection< ResourceGroupList, CComObject< CClusResGroup > >( m_ResourceGroups );

} //*** CClusResGroups::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::get_Item
//
//  Description:
//      Returns the object (Group) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number, or
//                          a string that is the name of the group to get.
//      ppProperty  [OUT]   - Catches the property.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResGroup **   ppResourceGroup
    )
{
    //ASSERT( ppResourceGroup != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResourceGroup != NULL )
    {
        CComObject<CClusResGroup> * pGroup = NULL;

        // Zero the out param
        *ppResourceGroup = NULL;

        ULONG nIndex = 0;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pGroup = m_ResourceGroups[ nIndex ];
            _hr = pGroup->QueryInterface( IID_ISClusResGroup, (void **) ppResourceGroup );
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CClusResGroups::get_Item() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResGroups::get_Item() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResGroups::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::get__NewEnum(
    IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< ResourceGroupList, CComObject< CClusResGroup > >( ppunk, m_ResourceGroups );

} //*** CClusResGroups::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::CreateItem
//
//  Description:
//      Create a new object (Group) and add it to the collection.
//
//  Arguments:
//      bstrResourceGroupName   [IN]    - The name of the new group.
//      ppResourceGroup         [OUT]   - Catches the new object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::CreateItem(
    IN  BSTR                bstrResourceGroupName,
    OUT ISClusResGroup **   ppResourceGroup
    )
{
    //ASSERT( bstrResourceGroupName != NULL );
    //ASSERT( ppResourceGroup != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrResourceGroupName != NULL ) && ( ppResourceGroup != NULL ) )
    {
        ULONG nIndex;

        *ppResourceGroup = NULL;

        _hr = FindItem( bstrResourceGroupName, &nIndex );
        if ( FAILED( _hr ) )
        {
            CComObject< CClusResGroup > *   pResourceGroup = NULL;

            _hr = CComObject< CClusResGroup >::CreateInstance( &pResourceGroup );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResGroup > >    ptrGroup( pResourceGroup );

                _hr = ptrGroup->Create( ptrRefObject, bstrResourceGroupName );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrGroup->QueryInterface( IID_ISClusResGroup, (void **) ppResourceGroup );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrGroup->AddRef();
                        m_ResourceGroups.insert( m_ResourceGroups.end(), ptrGroup );
                    }
                }
            }
        } // if: group already exists
        else
        {
            CComObject< CClusResGroup > * pResourceGroup = NULL;

            pResourceGroup = m_ResourceGroups[ nIndex ];
            _hr = pResourceGroup->QueryInterface( IID_ISClusResGroup, (void **) ppResourceGroup );
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"ClusResGroups::CreateItem() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"Error creating group. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResGroups::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::DeleteItem
//
//  Description:
//      Deletes the object (group) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - The index of the object to delete.
//
//  Return Value:
//      S_OK if successful, E_INVALIDARG, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::DeleteItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    ULONG   nIndex = 0;

    _hr = GetIndex( varIndex, &nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        ISClusResGroup * pResourceGroup = (ISClusResGroup *) m_ResourceGroups[ nIndex ];

        // Delete the resource group.
        _hr = pResourceGroup->Delete();
        if ( SUCCEEDED( _hr ) )
        {
            RemoveAt( nIndex );
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CClusResGroups::DeleteItem() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 128 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResGroups::DeleteItem() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResGroups::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::Refresh
//
//  Description:
//      Load the collection from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::Refresh( void )
{
    Clear();

    if ( m_pClusRefObject == NULL )
    {
        return E_POINTER;
    } // if: we have a cluster handle wrapper

    if ( m_bstrNodeName == (BSTR) NULL )
    {
        return RefreshCluster();
    } // if: this collection is for a cluster
    else
    {
        return RefreshNode();
    } // else: this collection is for a node

} //*** CClusResGroups::Refresh()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::RefreshCluster
//
//  Description:
//      Load all of the groups in the cluster into this collection.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::RefreshCluster( void )
{
    HCLUSTER    _hCluster = NULL;
    HRESULT     _hr;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        HCLUSENUM   hEnum = NULL;
        DWORD       _sc = ERROR_SUCCESS;

        hEnum = ::ClusterOpenEnum( _hCluster, CLUSTER_ENUM_GROUP );
        if ( hEnum != NULL )
        {
            DWORD                           dwType;
            LPWSTR                          pwszName = NULL;
            CComObject< CClusResGroup > *   pResourceGroup = NULL;
            int                             nIndex;

            for( nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, nIndex, &dwType, &pwszName );
                if ( _sc == ERROR_NO_MORE_ITEMS)
                {
                    _hr = S_OK;
                    break;
                } // if: Enumerator is empty.  Time to leave...
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusResGroup >::CreateInstance( &pResourceGroup );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResGroup > >    ptrGroup( pResourceGroup );
                        BSTR                                        bstr = NULL;

                        bstr = SysAllocString( pwszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        } // if: failed to allocate a bstr
                        else
                        {
                            _hr = ptrGroup->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrGroup->AddRef();
                                m_ResourceGroups.insert( m_ResourceGroups.end(), ptrGroup );
                            } // if: successfully opened the group
                            else if ( HRESULT_CODE( _hr ) == ERROR_GROUP_NOT_FOUND )
                            {
                                //
                                //  It is possible for the group to have been deleted from the cluster
                                //  in the time between creating the enum and opening the group.  When
                                //  that happens we need to simply skip that group and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster group was not found

                            SysFreeString( bstr );
                        } // else: successfully allocated a bstr
                    } // if: successfully created an instance of a group object

                    ::LocalFree( pwszName );
                    pwszName = NULL;
                } // else if: successfully got a group from the enumerator
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: failed to get a group from the enumerator
            } // for: each group in the enumerator

            ::ClusterCloseEnum( hEnum ) ;
        } // if: successfully created the groups enumerator
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        } // else: failed to create the groups enumerator
    } // if: successfully got the cluster handle

    return _hr;

} //*** CClusResGroups::RefreshCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroups::RefreshNode
//
//  Description:
//      Load all of the groups owned by the node at m_bstrNodeName.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::RefreshNode( void )
{
    HCLUSTER    _hCluster = NULL;
    HRESULT  _hr;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        HCLUSENUM   hEnum = NULL;
        DWORD       _sc = ERROR_SUCCESS;

        hEnum = ::ClusterOpenEnum( _hCluster, CLUSTER_ENUM_GROUP );
        if ( hEnum != NULL )
        {
            DWORD                           dwType;
            LPWSTR                          pwszName = NULL;
            LPWSTR                          pwszNodeName = NULL;
            CComObject< CClusResGroup > *   pResourceGroup = NULL;
            CLUSTER_GROUP_STATE             cgs = ClusterGroupStateUnknown;
            int                             _nIndex;

            for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pwszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                } // if: enum is empty.  Time to leave...
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusResGroup >::CreateInstance( &pResourceGroup );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResGroup > >    ptrGroup( pResourceGroup );
                        BSTR                                        bstr = NULL;

                        bstr = SysAllocString( pwszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        } // if: could not allocate a bstr
                        else
                        {
                            _hr = ptrGroup->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                cgs = WrapGetClusterGroupState( ptrGroup->Hgroup(), &pwszNodeName );
                                if ( cgs != ClusterGroupStateUnknown )
                                {
                                    if ( lstrcmpi( m_bstrNodeName, pwszNodeName ) == 0 )
                                    {
                                        ptrGroup->AddRef();
                                        m_ResourceGroups.insert( m_ResourceGroups.end(), ptrGroup );
                                    } // if: the group is owned by this node

                                    ::LocalFree( pwszNodeName );
                                    pwszNodeName = NULL;
                                } // if: the group state is not unknown
                            } // if: the group was opened
                            else if ( HRESULT_CODE( _hr ) == ERROR_GROUP_NOT_FOUND )
                            {
                                //
                                //  It is possible for the group to have been deleted from the cluster
                                //  in the time between creating the enum and opening the group.  When
                                //  that happens we need to simply skip that group and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster group was not found

                            SysFreeString( bstr );
                        } // else: could allocated a bstr
                    } // if: sucessfully created a group object instance

                    ::LocalFree( pwszName );
                    pwszName = NULL;
                } // else if: successfully got a group from the enumerator
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: failed to get a group from the enumerator
            } // for: each group in the enumerator

            ::ClusterCloseEnum( hEnum );
        } // if: successfully created a group enumerator
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        } // else: failed to create a group enumerator
    } // if: got the cluster handle from the ref counted container
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CClusResGroups::RefreshNode() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR sz[ 128 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResGroups::RefreshNode() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResGroups::RefreshNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusRes.h
//
//	Description:
//		Definition of the resource classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusRes.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSRES_H_
#define _CLUSRES_H_

#ifndef __CLUSDISK_H_
	#include "ClusDisk.h"
#endif // __CLUSDISK_H_

#ifndef _CLUSKEYS_H_
	#include "ClusKeys.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusResource;
class CResources;
class CClusResources;
class CClusResDepends;
class CClusResDependencies;
class CClusResDependents;
class CClusResGroupResources;
class CClusResTypeResources;

const IID IID_CClusResource = {0xf2e60801,0x2631,0x11d1,{0x89,0xf1,0x00,0xa0,0xc9,0x0d,0x06,0x1e}};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResource
//
//	Description:
//		Cluster Resource Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResource, &IID_ISClusResource, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResource, &CLSID_ClusResource >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResource :
	public IDispatchImpl< ISClusResource, &IID_ISClusResource, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResource, &CLSID_ClusResource >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResource( void );
	~CClusResource( void );

BEGIN_COM_MAP(CClusResource)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResource)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IID(IID_CClusResource, CClusResource)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResource)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *				m_pClusRefObject;
	HRESOURCE						m_hResource;
	CComObject< CClusProperties > *	m_pCommonProperties;
	CComObject< CClusProperties > *	m_pPrivateProperties;
	CComObject< CClusProperties > *	m_pCommonROProperties;
	CComObject< CClusProperties > *	m_pPrivateROProperties;
	CComBSTR						m_bstrResourceName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

	DWORD ScGetResourceTypeName( OUT LPWSTR * ppwszResourceTypeName );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Create(
			IN ISClusRefObject * pClusRefObject,
			IN HGROUP hGroup,
			IN BSTR bstrResourceName,
			IN BSTR bstrResourceType,
			IN long dwFlags
			);

	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResourceName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP Close( void );

	STDMETHODIMP put_Name( IN BSTR bstrResourceName );

	STDMETHODIMP get_Name( OUT BSTR * pbstrResourceName );

	STDMETHODIMP get_State( IN CLUSTER_RESOURCE_STATE * dwState );

	STDMETHODIMP get_CoreFlag( OUT CLUS_FLAGS * dwCoreFlag );

	STDMETHODIMP BecomeQuorumResource( IN BSTR bstrDevicePath, IN long lMaxLogSize );

	STDMETHODIMP Delete( void );

	STDMETHODIMP Fail( void );

	STDMETHODIMP Online( IN long nTimeout, OUT VARIANT * pvarPending );

	STDMETHODIMP Offline( IN long nTimeout, OUT VARIANT * pvarPending );

	STDMETHODIMP ChangeResourceGroup( IN ISClusResGroup * pResourceGroup );

	STDMETHODIMP AddResourceNode( IN ISClusNode * pNode );

	STDMETHODIMP RemoveResourceNode( IN ISClusNode * pNode );

	STDMETHODIMP CanResourceBeDependent( IN ISClusResource * pResource, OUT VARIANT * pvarDependent );

	STDMETHODIMP get_Dependencies( OUT ISClusResDependencies ** ppResDependencies );

	STDMETHODIMP get_Dependents( OUT ISClusResDependents ** ppResDependents );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties	);

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PossibleOwnerNodes( OUT ISClusResPossibleOwnerNodes ** ppOwnerNodes );

	STDMETHODIMP get_Group( OUT ISClusResGroup ** ppResGroup );

	STDMETHODIMP get_OwnerNode( OUT ISClusNode ** ppNode );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	STDMETHODIMP get_ClassInfo( OUT CLUSTER_RESOURCE_CLASS * prclassInfo );

	STDMETHODIMP get_Disk( OUT ISClusDisk ** ppDisk );

	STDMETHODIMP get_RegistryKeys( OUT ISClusRegistryKeys ** ppRegistryKeys );

	STDMETHODIMP get_CryptoKeys( OUT ISClusCryptoKeys ** ppCryptoKeys );

	STDMETHODIMP get_TypeName( OUT BSTR * pbstrTypeName );

	STDMETHODIMP get_Type( OUT ISClusResType ** ppResourceType );

	virtual HRESULT HrLoadProperties( CClusPropList & rcplPropList, BOOL bReadOnly, BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrResourceName ; };

}; //*** Class CClusResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CResources
//
//	Description:
//		Cluster Resource Collection Implementation Base Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CResources
{
public:

	CResources( void );
	~CResources( void );

	HRESULT Create( ISClusRefObject* pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusResource > * >	ResourceList;

	ResourceList		m_Resources;
	ISClusRefObject *	m_pClusRefObject;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszResourceName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusResource * pResource, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetResourceItem( IN VARIANT varIndex, OUT ISClusResource ** ppResource );

	HRESULT RemoveAt( IN size_t pos );

	HRESULT DeleteItem( IN VARIANT varIndex );

}; //*** Class CResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResources
//
//	Description:
//		Cluster Resource Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResources, &IID_ISClusResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CResources
//		CComCoClass< CClusResources, &CLSID_ClusResources >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResources	:
	public IDispatchImpl< ISClusResources, &IID_ISClusResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CResources,
	public CComCoClass< CClusResources, &CLSID_ClusResources >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResources( void	);
	~CClusResources(	void );

BEGIN_COM_MAP(CClusResources)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResources)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResources)
DECLARE_NO_REGISTRY()

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	BSTR							bstrGroupName,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResDepends
//
//	Description:
//		Cluster Resource Collection Automation Base Class.
//
//	Inheritance:
//		CResources
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResDepends :
	public CResources
{
public:
	CClusResDepends( void );
	~CClusResDepends( void );

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	HRESULT HrRefresh( IN CLUSTER_RESOURCE_ENUM cre );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP AddItem( IN ISClusResource * pResource );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

protected:
	HRESOURCE	m_hResource;

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScAddDependency
	//
	//	Description:
	//		Abstracts AddClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The first resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//		hRes2	[IN]	- The second resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScAddDependency( IN HRESOURCE hRes1, IN HRESOURCE hRes2 ) = 0;

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScRemoveDependency
	//
	//	Description:
	//		Abstracts RemoveClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The first resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//		hRes2	[IN]	- The second resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScRemoveDependency( IN HRESOURCE hRes1, IN HRESOURCE hRes2 ) = 0;

}; //*** Class CClusResDepends

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResDependencies
//
//	Description:
//		Cluster Resource Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResDependencies, &IID_ISClusResDependencies, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResDependencies, &CLSID_ClusResDependencies >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResDependencies :
	public CClusResDepends,
	public IDispatchImpl< ISClusResDependencies, &IID_ISClusResDependencies, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResDependencies, &CLSID_ClusResDependencies >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResDependencies( void );

BEGIN_COM_MAP(CClusResDependencies)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResDependencies)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResDependencies)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource )
	{
		return CClusResDepends::Create( pClusRefObject, hResource );

	};

	STDMETHODIMP get_Count( OUT long * plCount )
	{
		return CClusResDepends::get_Count( plCount );

	};

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource )
	{
		return CClusResDepends::get_Item( varIndex, ppClusterResource );

	};

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk )
	{
		return CClusResDepends::get__NewEnum( ppunk );

	};

	STDMETHODIMP DeleteItem( IN VARIANT varIndex )
	{
		return CClusResDepends::DeleteItem( varIndex );

	};

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					)
	{
		return CClusResDepends::CreateItem( bstrResourceName, bstrResourceType, dwFlags, ppClusterResource );

	};

	STDMETHODIMP AddItem( IN ISClusResource * pResource )
	{
		return CClusResDepends::AddItem( pResource );

	};

	STDMETHODIMP RemoveItem( IN VARIANT varIndex )
	{
		return CClusResDepends::RemoveItem( varIndex );

	};

	STDMETHODIMP Refresh( void )
	{
		return HrRefresh( CLUSTER_RESOURCE_ENUM_DEPENDS );

	};

protected:
	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScAddDependency
	//
	//	Description:
	//		Abstracts AddClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The dependent resource
	//		hRes2	[IN]	- The depends on resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScAddDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::AddClusterResourceDependency( hRes1, hRes2 );

	}; //*** ScAddDependency

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScRemoveDependency
	//
	//	Description:
	//		Abstracts RemoveClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The dependent resource
	//		hRes2	[IN]	- The depends on resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScRemoveDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::RemoveClusterResourceDependency( hRes1, hRes2 );

	}; //*** ScRemoveDependency

}; //*** Class CClusResDependencies

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResDependents
//
//	Description:
//		Cluster Resource Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResDependents, &IID_ISClusResDependents, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResDependents, &CLSID_ClusResDependents >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResDependents :
	public CClusResDepends,
	public IDispatchImpl< ISClusResDependents, &IID_ISClusResDependents, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResDependents, &CLSID_ClusResDependents >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResDependents( void );

BEGIN_COM_MAP(CClusResDependents)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResDependents)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResDependents)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource )
	{
		return CClusResDepends::Create( pClusRefObject, hResource );

	};

	STDMETHODIMP get_Count( OUT long * plCount )
	{
		return CClusResDepends::get_Count( plCount );

	};

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource )
	{
		return CClusResDepends::get_Item( varIndex, ppClusterResource );

	};

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk )
	{
		return CClusResDepends::get__NewEnum( ppunk );

	};

	STDMETHODIMP DeleteItem( IN VARIANT varIndex )
	{
		return CClusResDepends::DeleteItem( varIndex );

	};

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					)
	{
		return CClusResDepends::CreateItem( bstrResourceName, bstrResourceType, dwFlags, ppClusterResource );

	};

	STDMETHODIMP AddItem( IN ISClusResource * pResource )
	{
		return CClusResDepends::AddItem( pResource );

	};

	STDMETHODIMP RemoveItem( IN VARIANT varIndex )
	{
		return CClusResDepends::RemoveItem( varIndex );

	};

	STDMETHODIMP Refresh( void )
	{
		return HrRefresh( CLUSTER_RESOURCE_ENUM_PROVIDES );

	};

protected:
	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScAddDependency
	//
	//	Description:
	//		Abstracts AddClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The depends on resource
	//		hRes2	[IN]	- The dependent resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScAddDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::AddClusterResourceDependency( hRes2, hRes1 );

	}; //*** ScAddDependency

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScRemoveDependency
	//
	//	Description:
	//		Abstracts RemoveClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The depends on resource
	//		hRes2	[IN]	- The dependent resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScRemoveDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::RemoveClusterResourceDependency( hRes2, hRes1 );

	}; //*** ScRemoveDependency

}; //*** Class CClusResDependents

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroupResources
//
//	Description:
//		Cluster Group Resources Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroupResources, &IID_ISClusResGroupResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CResources
//		CComCoClass< CClusResGroupResources, &CLSID_ClusResGroupResources >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroupResources :
	public IDispatchImpl< ISClusResGroupResources, &IID_ISClusResGroupResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CResources,
	public CComCoClass< CClusResGroupResources, &CLSID_ClusResGroupResources >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroupResources( void );
	~CClusResGroupResources( void );

BEGIN_COM_MAP(CClusResGroupResources)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroupResources)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroupResources)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject , IN CRefcountedHGROUP hGroup );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

private:
	CRefcountedHGROUP	m_hGroup;

}; //*** Class CClusResGroupResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypeResources
//
//	Description:
//		Cluster Resource Type Resources Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResTypeResources, &IID_ISClusResTypeResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CResources
//		CComCoClass< CClusResTypeResources, &CLSID_ClusResTypeResources >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResTypeResources :
	public IDispatchImpl< ISClusResTypeResources, &IID_ISClusResTypeResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CResources,
	public CComCoClass< CClusResTypeResources, &CLSID_ClusResTypeResources >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResTypeResources( void );
	~CClusResTypeResources( void );

BEGIN_COM_MAP(CClusResTypeResources)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResTypeResources)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResTypeResources)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResTypeName );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrGroupName,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

private:
	CComBSTR	m_bstrResourceTypeName;

}; //*** Class CClusResTypeResources

#endif // _CLUSRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusnode.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ClusNode.cpp
//
//  Description:
//      Implementation of the node classes for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusneti.h"
#include "clusnode.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusNode[] =
{
    &IID_ISClusNode
};

static const IID * iidCClusNodes[] =
{
    &IID_ISClusNodes
};

static const IID * iidCClusResGroupPreferredOwnerNodes[] =
{
    &IID_ISClusResGroupPreferredOwnerNodes
};

static const IID * iidCClusResPossibleOwnerNodes[] =
{
    &IID_ISClusResPossibleOwnerNodes
};

static const IID * iidCClusResTypePossibleOwnerNodes[] =
{
    &IID_ISClusResTypePossibleOwnerNodes
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNode class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::CClusNode
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNode::CClusNode( void )
{
    m_hNode                 = NULL;
    m_pClusRefObject        = NULL;
    m_pResourceGroups       = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;
    m_pNetInterfaces        = NULL;

    m_piids     = (const IID *) iidCClusNode;
    m_piidsSize = ARRAYSIZE( iidCClusNode );

} //*** CClusNode::CClusNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::~CClusNode
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNode::~CClusNode( void )
{
    if ( m_hNode != NULL )
    {
        ::CloseClusterNode( m_hNode );
        m_hNode = NULL;
    } // if:

    if ( m_pResourceGroups != NULL )
    {
        m_pResourceGroups->Release();
        m_pResourceGroups = NULL;
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pNetInterfaces != NULL )
    {
        m_pNetInterfaces->Release();
        m_pNetInterfaces = NULL;
    } // if:

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CClusNode::~CClusNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Open
//
//  Description:
//      Retrieve this object's (Node) data from the cluster.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrNodeName    [IN]    - The name of the node to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrNodeName
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrNodeName != NULL);

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrNodeName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        HCLUSTER hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            m_hNode = ::OpenClusterNode( hCluster, bstrNodeName );
            if ( m_hNode == 0 )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            } // if: the node failed to open
            else
            {
                m_bstrNodeName = bstrNodeName;
                _hr = S_OK;
            } // else: we opened the node
        } // if: we have a cluster handle
    } // if: non NULL args

    return _hr;

} //*** CClusNode::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Node).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject< CClusProperties > * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = ptrProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pCommonProperties = ptrProperties;
                            }
                        }
                    }
                }
            }
        }
    } // if: non NULL args

    return _hr;

} //*** CClusNode::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_Handle
//
//  Description:
//      Get the native handle for this object (Node).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );
    ASSERT( m_hNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        if ( m_hNode != NULL )
        {
            *phandle = (ULONG_PTR) m_hNode;
            _hr = S_OK;
        } // if: node handle not NULL
    } // if: argument no NULL

    return _hr;

} //*** CClusNode::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Close
//
//  Description:
//      Close this object (Node).
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::Close( void )
{
    HRESULT _hr = S_FALSE;

    if ( m_hNode != NULL )
    {
        if ( ::CloseClusterNode( m_hNode ) )
        {
            m_hNode = NULL;
            _hr = S_OK;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusNode::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_Name
//
//  Description:
//      Return the name of this object (Node).
//
//  Arguments:
//      pbstrNodeName   [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_Name( BSTR * pbstrNodeName )
{
    //ASSERT( pbstrNodeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNodeName != NULL )
    {
        *pbstrNodeName = m_bstrNodeName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNode::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_NodeID
//
//  Description:
//      Get the ID of this node.
//
//  Arguments:
//      pbstrNodeID [OUT]   - Catches the node id.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_NodeID( OUT BSTR * pbstrNodeID )
{
    //ASSERT( pbstrNodeID != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNodeID != NULL )
    {
        LPWSTR  pwszNodeID;
        DWORD   dwRet = ERROR_SUCCESS;

        dwRet = ::WrapGetClusterNodeId( m_hNode, &pwszNodeID );
        if ( dwRet == ERROR_SUCCESS )
        {
            *pbstrNodeID = ::SysAllocString( pwszNodeID );
            if ( *pbstrNodeID == NULL )
            {
                _hr = E_OUTOFMEMORY;
            }

            ::LocalFree( pwszNodeID );
        } // if: got node ID...

        _hr = HRESULT_FROM_WIN32( dwRet );
    }

    return _hr;

} //*** CClusNode::get_NodeID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_State
//
//  Description:
//      Get the current state of the cluster node.  Up/down/paused, etc.
//
//  Arguments:
//      pState  [OUT]   - Catches the node state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_State( OUT CLUSTER_NODE_STATE * pState )
{
    //ASSERT( pState != NULL );

    HRESULT _hr = E_POINTER;

    if ( pState !=  NULL )
    {
        CLUSTER_NODE_STATE  cns;

        cns = ::GetClusterNodeState( m_hNode );
        if ( cns == ClusterNodeStateUnknown )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pState = cns;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusNode::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Pause
//
//  Description:
//      Pause this cluster node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::Pause( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hNode != NULL )
    {
        DWORD   _sc = ::PauseClusterNode( m_hNode );

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusNode::Pause()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Resume
//
//  Description:
//      Resume this paused cluster node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::Resume( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hNode != NULL )
    {
        DWORD   _sc = ::ResumeClusterNode( m_hNode );

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusNode::Resume()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Evict
//
//  Description:
//      Evict this node from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::Evict( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hNode != NULL )
    {
        DWORD   _sc = ::EvictClusterNode( m_hNode );

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusNode::Evict()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_ResourceGroups
//
//  Description:
//      Get the collection of groups that are active on this node.
//
//  Arguments:
//      ppResourceGroups    [OUT]   - Catches the collection of groups.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_ResourceGroups(
    OUT ISClusResGroups ** ppResourceGroups
    )
{
    return ::HrCreateResourceCollection< CClusResGroups, ISClusResGroups, CComBSTR >(
                        &m_pResourceGroups,
                        m_bstrNodeName,
                        ppResourceGroups,
                        IID_ISClusResGroups,
                        m_pClusRefObject
                        );

} //*** CClusNode::get_ResourceGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_CommonProperties
//
//  Description:
//      Get this object's (Node) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusNode::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_PrivateProperties
//
//  Description:
//      Get this object's (Node) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusNode::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_CommonROProperties
//
//  Description:
//      Get this object's (Node) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties,  (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusNode::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_PrivateROProperties
//
//  Description:
//      Get this object's (Node) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties  );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusNode::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_NetInterfaces
//
//  Description:
//      Get this object's (Node) network interfaces collection.
//
//  Arguments:
//      ppNetInterfaces [OUT]   - Catches the network interfaces collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_NetInterfaces(
    OUT ISClusNodeNetInterfaces ** ppNetInterfaces
    )
{
    return ::HrCreateResourceCollection< CClusNodeNetInterfaces, ISClusNodeNetInterfaces, HNODE >(
                        &m_pNetInterfaces,
                        m_hNode,
                        ppNetInterfaces,
                        IID_ISClusNodeNetInterfaces,
                        m_pClusRefObject
                        );

} //*** CClusNode::get_NetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_Cluster
//
//  Description:
//      Returns the parent cluster of this node.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster parent.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_Cluster( OUT ISCluster ** ppCluster )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusNode::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;


    if ( bReadOnly )
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES
                        : CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_NODE_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetNodeProperties( m_hNode, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusNode::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusNode::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_NODE_SET_PRIVATE_PROPERTIES : CLUSCTL_NODE_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterNodeControl(
                        m_hNode,
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusNode::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::CNodes
//
//  Description:
//      Constructor.  This class implements functionality common to all node
//      collections.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodes::CNodes( void )
{
    m_pClusRefObject = NULL;

} //*** CNodes::CNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::~CNodes
//
//  Description:
//      Desctructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodes::~CNodes( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CNodes::~CNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::Clear
//
//  Description:
//      Release the objects in the vector and clean up the vector.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNodes::Clear( void )
{
    ::ReleaseAndEmptyCollection< NodeList, CComObject< CClusNode > >( m_Nodes );

} //*** CNodes::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::FindItem
//
//  Description:
//      Find the passed in node in the vector and return its index.
//
//  Arguments:
//      pwszNodeName    [IN]    - The node to find.
//      pnIndex         [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::FindItem(
    IN  LPWSTR  pwszNodeName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pwszNodeName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pwszNodeName != NULL ) && ( pnIndex != NULL ) )
    {
        _hr = E_INVALIDARG;

        if ( ! m_Nodes.empty() )
        {
            CComObject< CClusNode > *   pNode = NULL;
            NodeList::iterator          first = m_Nodes.begin();
            NodeList::iterator          last = m_Nodes.end();
            UINT                        _iIndex;

            for ( _iIndex = 0; first != last; first++, _iIndex++ )
            {
                pNode = *first;

                if ( pNode && ( lstrcmpi( pwszNodeName, pNode->Name() ) == 0 ) )
                {
                    *pnIndex = _iIndex;
                    _hr = S_OK;
                    break;
                }
            }
        } // if:
    }

    return _hr;

} //*** CNodes::FindItem( pwszNodeName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::FindItem
//
//  Description:
//      Find the passed in node in the vector and return its index.
//
//  Arguments:
//      pClusterNode    [IN]    - The node to find.
//      pnIndex         [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::FindItem(
    IN  ISClusNode *    pClusterNode,
    OUT UINT *          pnIndex
    )
{
    //ASSERT( pClusterNode != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusterNode != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR bstrName;

        _hr = pClusterNode->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CNodes::FindItem( pClusterNode )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        UINT        nIndex = 0;
        CComVariant v;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_Nodes.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CNodes::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetItem
//
//  Description:
//      Return the item (Node) by name.
//
//  Arguments:
//      pwszNodeName    [IN]    - The name of the item requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetItem(
    IN  LPWSTR          pwszNodeName,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( pwszNodeName != NULL );
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pwszNodeName != NULL ) && ( ppClusterNode != NULL ) )
    {
        CComObject< CClusNode > *   pNode = NULL;
        NodeList::iterator          first = m_Nodes.begin();
        NodeList::iterator          last = m_Nodes.end();

        _hr = E_INVALIDARG;

        for ( ; first != last; first++ )
        {
            pNode = *first;

            if ( pNode && ( lstrcmpi( pwszNodeName, pNode->Name() ) == 0 ) )
            {
                _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppClusterNode );
                break;
            }
        }
    }

    return _hr;

} //*** CNodes::GetItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetItem
//
//  Description:
//      Return the item (Node) by index.
//
//  Arguments:
//      nIndex          [IN]    - The name of the item requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetItem( IN UINT nIndex, OUT ISClusNode ** ppClusterNode )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        //
        // Automation collections are 1-relative for languages like VB.
        // We are 0-relative internally.
        //
        if ( ( --nIndex ) < m_Nodes.size() )
        {
            CComObject< CClusNode > * pNode = m_Nodes[ nIndex ];

            _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppClusterNode );
        }
        else
        {
            _hr = E_INVALIDARG;
        }
    }

    return _hr;

} //*** CNodes::GetItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetNodeItem
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetNodeItem(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        CComObject<CClusNode> * pNode = NULL;
        UINT                    nIndex = 0;

        *ppClusterNode = NULL;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pNode = m_Nodes[ nIndex ];
            _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppClusterNode );
        }
    }

    return _hr;

} //*** CNodes::GetNodeItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::InsertAt
//
//  Description:
//      Insert the passed in node into the node list.
//
//  Arguments:
//      pClusNode   [IN]    - The node to add.
//      pos         [IN]    - The position to insert the node at.
//
//  Return Value:
//      E_POINTER, E_INVALIDARG, or S_OK if successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::InsertAt(
    CComObject< CClusNode > *   pClusNode,
    size_t                      pos
    )
{
    //ASSERT( pClusNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusNode != NULL )
    {
        if ( pos < m_Nodes.size() )
        {
            NodeList::iterator          first = m_Nodes.begin();
            NodeList::iterator          last = m_Nodes.end();
            size_t                      _iIndex;

            for ( _iIndex = 0; ( _iIndex < pos ) && ( first != last ); _iIndex++, first++ )
            {
            } // for:

            m_Nodes.insert( first, pClusNode );
            pClusNode->AddRef();
            _hr = S_OK;
        }
        else
        {
            _hr = E_INVALIDARG;
        }
    }

    return _hr;

} //*** CNodes::InsertAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::RemoveAt
//
//  Description:
//      Remove the object from the vector at the passed in position.
//
//  Arguments:
//      pos [IN]    - the position of the object to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the position is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::RemoveAt( size_t pos )
{
    CComObject<CClusNode> *     pNode = NULL;
    NodeList::iterator          first = m_Nodes.begin();
    NodeList::const_iterator    last = m_Nodes.end();
    HRESULT                     _hr = E_INVALIDARG;
    size_t                      _iIndex;

    for ( _iIndex = 0; ( _iIndex < pos ) && ( first != last ); _iIndex++, first++ )
    {
    } // for:

    if ( first != last )
    {
        pNode = *first;
        if ( pNode )
        {
            pNode->Release();
        }

        m_Nodes.erase( first );
        _hr = S_OK;
    }

    return _hr;

} //*** CNodes::RemoveAt()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::CClusNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodes::CClusNodes( void )
{
    m_piids     = (const IID *) iidCClusNodes;
    m_piidsSize = ARRAYSIZE( iidCClusNodes );

} //*** CClusNodes::CClusNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::~CClusNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodes::~CClusNodes( void )
{
    Clear();

} //*** CClusNodes::~CClusNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem(varIndex, ppClusterNode);
    } // if: args are not NULL

    return _hr;

} //*** CClusNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::Refresh( void )
{
    HCLUSENUM   hEnum = NULL;
    HCLUSTER    hCluster = NULL;
    DWORD       _sc = ERROR_SUCCESS;
    HRESULT     _hr = S_OK;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_NODE );
        if ( hEnum != NULL )
        {
            int                         _nIndex = 0;
            DWORD                       dwType;
            LPWSTR                      pszName = NULL;
            CComObject< CClusNode > *   pNode = NULL;

            Clear();

            for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );
                        BSTR                                    bstr = NULL;

                        bstr = SysAllocString( pszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = ptrNode->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrNode->AddRef();
                                m_Nodes.insert( m_Nodes.end(), ptrNode );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NODE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the node to have been deleted from the cluster
                                //  in the time between creating the enum and opening the node.  When
                                //  that happens we need to simply skip that node and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster node was not found

                            SysFreeString( bstr );
                        }
                    }

                    ::LocalFree( pszName );
                    pszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }

            ::ClusterCloseEnum( hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusNodes::Refresh()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroupPreferredOwnerNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::CClusResGroupPreferredOwnerNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupPreferredOwnerNodes::CClusResGroupPreferredOwnerNodes( void )
{
    m_bModified = FALSE;
    m_piids     = (const IID *) iidCClusResGroupPreferredOwnerNodes;
    m_piidsSize = ARRAYSIZE( iidCClusResGroupPreferredOwnerNodes    );

} //*** CClusResGroupPreferredOwnerNodes::CClusResGroupPreferredOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::~CClusResGroupPreferredOwnerNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupPreferredOwnerNodes::~CClusResGroupPreferredOwnerNodes( void )
{
    Clear();

} //*** CClusResGroupPreferredOwnerNodes::~CClusResGroupPreferredOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hGroup          [IN]    - Group the collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroupPreferredOwnerNodes::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN CRefcountedHGROUP               hGroup
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNodes::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hGroup = hGroup;
    } // if:

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get_Count(
    OUT long * plCount
    )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem( varIndex, ppClusterNode );
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get__NewEnum(
    IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusResGroupPreferredOwnerNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::Refresh
//
//  Description:
//      Loads the resource group preferred owner node collection from the
//      cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::Refresh( void )
{
    HRESULT  _hr = S_OK;
    HGROUPENUM  hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    hEnum = ::ClusterGroupOpenEnum( m_hGroup->get_Handle(), CLUSTER_GROUP_ENUM_NODES );
    if ( hEnum != NULL )
    {
        int                         _nIndex = 0;
        DWORD                       dwType = 0;
        LPWSTR                      pszName = NULL;
        CComObject< CClusNode > *   pNode = NULL;

        Clear();
        m_bModified = FALSE;

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = WrapClusterGroupEnum( hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );
                    BSTR                                    bstr = NULL;

                    bstr = SysAllocString( pszName );
                    if ( bstr == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        _hr = ptrNode->Open( ptrRefObject, bstr );
                        if ( SUCCEEDED( _hr ) )
                        {
                            ptrNode->AddRef();
                            m_Nodes.insert( m_Nodes.end(), ptrNode );
                        }
                        else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NODE_NOT_FOUND )
                        {
                            //
                            //  It is possible for the node to have been deleted from the cluster
                            //  in the time between creating the enum and opening the node.  When
                            //  that happens we need to simply skip that node and continue
                            //  enumerating.
                            //

                            _hr = S_FALSE;      // success code to keep us in the loop
                        } // else if: the cluster node was not found

                        SysFreeString( bstr );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterGroupCloseEnum( hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;


} //*** CClusResGroupPreferredOwnerNodes::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::InsertItem
//
//  Description:
//      Insert the node into the groups preferred owners list.
//
//  Arguments:
//      pNode       [IN]    - Node to add to the preferred owners list.
//      nPosition   [IN]    - Where in the list to insert the node.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::InsertItem(
    IN ISClusNode * pNode,
    IN long         nPosition
    )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        UINT _nIndex = 0;

        _hr = FindItem( pNode, &_nIndex );
        if ( FAILED( _hr ) )
        {
            _hr = E_INVALIDARG;

            if ( nPosition > 0 )
            {
                SSIZE_T pos = (SSIZE_T) nPosition - 1;  // convert to zero base

                if ( pos >= 0 )
                {
                    CComObject< CClusNode > *   _pNode = NULL;

                    _hr = pNode->QueryInterface( IID_CClusNode, (void **) &_pNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( ( m_Nodes.empty() ) || ( pos == 0 ) )
                        {
                            _pNode->AddRef();
                            m_Nodes.insert( m_Nodes.begin(), _pNode );
                        } // if: list is empty or the insert index is zero then insert at the beginning
                        else if ( pos >= m_Nodes.size() )
                        {
                            _pNode->AddRef();
                            m_Nodes.insert( m_Nodes.end(), _pNode );
                        } // else if: pos equals the end, append
                        else
                        {
                            _hr = InsertAt( _pNode, pos );
                        } // else: try to insert it where is belongs

                        m_bModified = TRUE;
                        pNode->Release();
                    } // if:
                } // if: index is greater than zero
            } // if: nPosition must be greater than zero!
        } // if: node was not already in the collection
        else
        {
            _hr = E_INVALIDARG;
        } // else: node was already in the collectoin
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::InsertItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::AddItem
//
//  Description:
//      Add the node into the groups preferred owners list.
//
//  Arguments:
//      pNode       [IN]    - Node to add to the preferred owners list.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::AddItem(
    IN ISClusNode * pNode
    )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        UINT _nIndex = 0;

        _hr = FindItem( pNode, &_nIndex );
        if ( FAILED( _hr ) )
        {
            CComObject< CClusNode > *   _pNode = NULL;

            _hr = pNode->QueryInterface( IID_CClusNode, (void **) &_pNode );
            if ( SUCCEEDED( _hr ) )
            {
                m_Nodes.insert( m_Nodes.end(), _pNode );
                m_bModified = TRUE;
            } // if:
        } // if: node was not found in the collection already
        else
        {
            _hr = E_INVALIDARG;
        } // esle: node was found
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::RemoveItem
//
//  Description:
//      Remove the item at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - The index of the item to remove.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::RemoveItem(
    IN VARIANT varIndex
    )
{
    HRESULT _hr = S_OK;

    UINT _nIndex = 0;

    _hr = GetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        _hr = RemoveAt( _nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            m_bModified = TRUE;
        } // if:
    } // if:

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get_Modified
//
//  Description:
//      Has this collection been modified?
//
//  Arguments:
//      pvarModified    [OUT]   - Catches the modified state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get_Modified(
    OUT VARIANT * pvarModified
    )
{
    //ASSERT( pvarModified != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarModified != NULL )
    {
        pvarModified->vt = VT_BOOL;

        if ( m_bModified )
        {
            pvarModified->boolVal = VARIANT_TRUE;
        } // if: the collection has been modified.
        else
        {
            pvarModified->boolVal = VARIANT_FALSE;
        } // else: the collection has not been modified.

        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::get_Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::SaveChanges
//
//  Description:
//      Saves the changes to this collection of preferred owner nodes to
//      the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::SaveChanges( void )
{
    HRESULT _hr = S_OK;

    if ( m_bModified )
    {
        size_t  _cNodes;
        HNODE * _phNodes = NULL;

        _cNodes = m_Nodes.size();

        _phNodes = new HNODE [ _cNodes ];
        if ( _phNodes != NULL )
        {
            NodeList::const_iterator    _itCurrent = m_Nodes.begin();
            NodeList::const_iterator    _itLast = m_Nodes.end();
            size_t                      _iIndex;
            DWORD                       _sc = ERROR_SUCCESS;
            CComObject< CClusNode > *   _pOwnerNode = NULL;

            ZeroMemory( _phNodes, _cNodes * sizeof( HNODE ) );

            for ( _iIndex = 0; _itCurrent != _itLast; _itCurrent++, _iIndex++ )
            {
                _pOwnerNode = *_itCurrent;
                _phNodes[ _iIndex ] = _pOwnerNode->RhNode();
            } // for:

            _sc = ::SetClusterGroupNodeList( m_hGroup->get_Handle(), _cNodes, _phNodes );

            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                m_bModified = FALSE;
            } // if:

            delete [] _phNodes;
        }
        else
        {
            _hr = E_OUTOFMEMORY;
        }
    }

    return _hr;


} //*** CClusResGroupPreferredOwnerNodes::SaveChanges()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResPossibleOwnerNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::CClusResPossibleOwnerNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResPossibleOwnerNodes::CClusResPossibleOwnerNodes( void )
{
    m_piids     = (const IID *) iidCClusResPossibleOwnerNodes;
    m_piidsSize = ARRAYSIZE( iidCClusResPossibleOwnerNodes );

} //*** CClusResPossibleOwnerNodes::CClusResPossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::~CClusResPossibleOwnerNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResPossibleOwnerNodes::~CClusResPossibleOwnerNodes( void )
{
    Clear();

} //*** CClusResPossibleOwnerNodes::~CClusResPossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hResource       [IN]    - Resource the collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResPossibleOwnerNodes::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HRESOURCE            hResource
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNodes::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hResource = hResource;
    } // if:

    return _hr;

} //*** CClusResPossibleOwnerNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem( varIndex, ppClusterNode );
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusResPossibleOwnerNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::Refresh( void )
{
    HRESULT  _hr = S_OK;
    HRESENUM    hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    hEnum = ::ClusterResourceOpenEnum( m_hResource, CLUSTER_RESOURCE_ENUM_NODES );
    if ( hEnum != NULL )
    {
        int                         _nIndex = 0;
        DWORD                       dwType;
        LPWSTR                      pszName = NULL;
        CComObject< CClusNode > *   pNode = NULL;

        Clear();

        m_bModified = FALSE;

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = ::WrapClusterResourceEnum( hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );
                    BSTR                                    bstr = NULL;

                    bstr = SysAllocString( pszName );
                    if ( bstr == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        _hr = ptrNode->Open( ptrRefObject, bstr );
                        if ( SUCCEEDED( _hr ) )
                        {
                            ptrNode->AddRef();
                            m_Nodes.insert( m_Nodes.end(), ptrNode );
                        }
                        else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NODE_NOT_FOUND )
                        {
                            //
                            //  It is possible for the node to have been deleted from the cluster
                            //  in the time between creating the enum and opening the node.  When
                            //  that happens we need to simply skip that node and continue
                            //  enumerating.
                            //

                            _hr = S_FALSE;      // success code to keep us in the loop
                        } // else if: the cluster node was not found

                        SysFreeString( bstr );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterResourceCloseEnum( hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::AddItem
//
//  Description:
//      Add the passed in node to this resource's list of possible owners.
//
//  Arguments:
//      pNode   [IN]    - The node to add to the list.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::AddItem( ISClusNode * pNode )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        // Fail if duplicate
        UINT _nIndex = 0;

        _hr = FindItem( pNode, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = E_INVALIDARG;
        }
        else
        {
            CComObject< CClusNode > *   _pNode = NULL;

            _hr = pNode->QueryInterface( IID_CClusNode, (void **) &_pNode );
            if ( SUCCEEDED( _hr ) )
            {
                DWORD   _sc = ERROR_SUCCESS;

                _sc = ::AddClusterResourceNode( m_hResource, _pNode->RhNode() );
                if ( _sc == ERROR_SUCCESS )
                {
                    _pNode->AddRef();
                    m_Nodes.insert( m_Nodes.end(), _pNode );

                    m_bModified = TRUE;
                } // if:

                _hr = HRESULT_FROM_WIN32( _sc );

                pNode->Release();
            } // if:
        }
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::RemoveItem
//
//  Description:
//      Remove the node at the passed in index from this resource's list of
//      possible owners.
//
//  Arguments:
//      varIndex    [IN]    - holds the index of the node to remove.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::RemoveItem( VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    UINT    _nIndex = 0;

    _hr = GetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        CComObject< CClusNode> *    _pNode = m_Nodes[ _nIndex ];
        DWORD   _sc = ERROR_SUCCESS;

        _sc = ::RemoveClusterResourceNode( m_hResource, _pNode->RhNode() );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr )  )
        {
            RemoveAt( _nIndex );
            m_bModified = TRUE;
        } // if:
    } // if:

    return _hr;

} //*** CClusResPossibleOwnerNodes::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get_Modified
//
//  Description:
//      Has this collection been modified?
//
//  Arguments:
//      pvarModified    [OUT]   - Catches the modified state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get_Modified(
    OUT VARIANT * pvarModified
    )
{
    //ASSERT( pvarModified != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarModified != NULL )
    {
        pvarModified->vt = VT_BOOL;

        if ( m_bModified )
        {
            pvarModified->boolVal = VARIANT_TRUE;
        } // if: the collection has been modified.
        else
        {
            pvarModified->boolVal = VARIANT_FALSE;
        } // else: the collection has not been modified.

        _hr = S_OK;
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::get_Modified()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResTypePossibleOwnerNodes class
/////////////////////////////////////////////////////////////////////////////

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::CClusResTypePossibleOwnerNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypePossibleOwnerNodes::CClusResTypePossibleOwnerNodes( void )
{
    m_piids     = (const IID *) iidCClusResTypePossibleOwnerNodes;
    m_piidsSize = ARRAYSIZE( iidCClusResTypePossibleOwnerNodes );

} //*** CClusResTypePossibleOwnerNodes::CClusResTypePossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::~CClusResTypePossibleOwnerNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypePossibleOwnerNodes::~CClusResTypePossibleOwnerNodes( void )
{
    Clear();

} //*** CClusResTypePossibleOwnerNodes::~CClusResTypePossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrResTypeName [IN]    - Resource type name the collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypePossibleOwnerNodes::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResTypeName
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNodes::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_bstrResTypeName = bstrResTypeName;
    } // if:

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem( varIndex, ppClusterNode );
    }

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::get__NewEnum(
    OUT IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusResTypePossibleOwnerNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::Refresh
//
//  Description:
//      Load the resource type possible owner nodes collection from the
//      cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error ad HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::Refresh( void )
{
    HRESULT         _hr = S_OK;
    HRESTYPEENUM    hEnum = NULL;
    DWORD           _sc = ERROR_SUCCESS;
    HCLUSTER        hCluster = NULL;

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        hEnum = ::ClusterResourceTypeOpenEnum( hCluster, m_bstrResTypeName, CLUSTER_RESOURCE_TYPE_ENUM_NODES );
        if ( hEnum != NULL )
        {
            int                         _nIndex = 0;
            DWORD                       dwType;
            LPWSTR                      pszName = NULL;
            CComObject< CClusNode > *   pNode = NULL;

            Clear();

            for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterResourceTypeEnum( hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );
                        BSTR                                    bstr = NULL;

                        bstr = SysAllocString( pszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = ptrNode->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrNode->AddRef();
                                m_Nodes.insert( m_Nodes.end(), ptrNode );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_CLUSTER_NODE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the node to have been deleted from the cluster
                                //  in the time between creating the enum and opening the node.  When
                                //  that happens we need to simply skip that node and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster node was not found

                            SysFreeString( bstr );
                        }
                    }

                    ::LocalFree( pszName );
                    pszName = NULL;
                } // else if: no error
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: error from WrapClusterResourceTypeEnum
            } // for: repeat until error

            ::ClusterResourceTypeCloseEnum( hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    } // if: we have a cluster handle

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::Refresh()

#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ClusRes.cpp
//
//  Description:
//      Implementation of the resource classes for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <Winbase.h>
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusrest.h"
#include "clusneti.h"
#include "clusnode.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusResource[] =
{
    &IID_ISClusResource
};

static const IID *  iidCClusResources[] =
{
    &IID_ISClusResources
};

static const IID *  iidCClusResDependencies[] =
{
    &IID_ISClusResDependencies
};

static const IID *  iidCClusResDependents[] =
{
    &IID_ISClusResDependents
};

static const IID * iidCClusResGroupResources[] =
{
    &IID_ISClusResGroupResources
};

static const IID *  iidCClusResTypeResources[] =
{
    &IID_ISClusResTypeResources
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResource class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::CClusResource
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResource::CClusResource( void )
{
    m_hResource             = NULL;
    m_pClusRefObject        = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;
    m_piids                 = (const IID *) iidCClusResource;
    m_piidsSize             = ARRAYSIZE( iidCClusResource );

} //*** CClusResource::CClusResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::~CClusResource
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResource::~CClusResource( void )
{
    if ( m_hResource != NULL )
    {
        ::CloseClusterResource( m_hResource );
        m_hResource = NULL;
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if: release the property collection

} //*** CClusResource::~CClusResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Create
//
//  Description:
//      Finish creating the object.
//
//  Arguments:
//      pClusRefObject      [IN]    - Wraps the cluster handle.
//      hGroup              [IN]    - Group to create the resource in.
//      bstrResourceName    [IN]    - Name of the new resource.
//      bstrResourceType    [IN]    - The type of resource to create.
//      dwFlags             [IN]    - Creatation flags, separate resmon, etc.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HGROUP               hGroup,
    IN BSTR                 bstrResourceName,
    IN BSTR                 bstrResourceType,
    IN long                 dwFlags
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrResourceName != NULL );
    ASSERT( bstrResourceType != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( pClusRefObject != NULL )      &&
            ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        m_hResource = ::CreateClusterResource( hGroup, bstrResourceName, bstrResourceType, dwFlags );
        if ( m_hResource == NULL )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );

        }
        else
        {
            m_bstrResourceName = bstrResourceName;
            _hr= S_OK;
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CClusResource::Create() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResource::Create() failed. (hr = %#08x)\n", _hr );
        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResource::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Open
//
//  Description:
//      Open a handle to the resource object on the cluster.
//
//  Arguments:
//      pClusRefObject      [IN]    - Wraps the cluster handle.
//      bstrResourceName    [IN]    - Name of the resource to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResourceName
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrResourceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrResourceName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        HCLUSTER hCluster;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            m_hResource = OpenClusterResource( hCluster, bstrResourceName );
            if ( m_hResource == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            }
            else
            {
                m_bstrResourceName = bstrResourceName;
                _hr = S_OK;
            }
        }
    }

    return _hr;

} //*** CClusResource::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Resource).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject< CClusProperties > * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = ptrProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pCommonProperties = ptrProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Handle
//
//  Description:
//      Return the handle to this object (Resource).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Handle(
    OUT ULONG_PTR * phandle
    )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        *phandle = (ULONG_PTR) m_hResource;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResource::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Close
//
//  Description:
//      Close the handle to the cluster object (Resource).
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Close( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hResource != NULL )
    {
        if ( CloseClusterResource(  m_hResource ) )
        {
            m_hResource = NULL;
            _hr = S_OK;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::put_Name
//
//  Description:
//      Change the name of this object (Resource).
//
//  Arguments:
//      bstrResourceName    [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::put_Name( IN BSTR bstrResourceName )
{
    //ASSERT( bstrResourceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrResourceName != NULL )
    {
        DWORD _sc = ERROR_SUCCESS;
        _sc = ::SetClusterResourceName( m_hResource, bstrResourceName );
        if ( _sc == ERROR_SUCCESS )
        {
            m_bstrResourceName = bstrResourceName;
        }

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResource::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Name
//
//  Description:
//      Return the name of this object (Resource).
//
//  Arguments:
//      pbstrResourceName   [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Name( OUT BSTR * pbstrResourceName )
{
    //ASSERT( pbstrResourceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrResourceName != NULL )
    {
        *pbstrResourceName = m_bstrResourceName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResource::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_State
//
//  Description:
//      Returs the current state of this object (Resource).
//
//  Arguments:
//      pcrsState   [OUT]   - Catches the resource's state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_State(
    OUT CLUSTER_RESOURCE_STATE * pcrsState
    )
{
    //ASSERT( pcrsState != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcrsState != NULL )
    {
        CLUSTER_RESOURCE_STATE crsState = ::WrapGetClusterResourceState( m_hResource, NULL, NULL );

        if ( crsState == ClusterResourceStateUnknown )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pcrsState = crsState;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusResource::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CoreFlag
//
//  Description:
//      Returns this object's (Resource) core flags.
//
//  Arguments:
//      pFlags  [OUT]   - Catches the flags.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CoreFlag(
    OUT CLUS_FLAGS * pFlags
    )
{
    //ASSERT( pFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( pFlags != NULL )
    {
        DWORD _sc = ERROR_SUCCESS;
        DWORD dwData;
        DWORD cbData;

        _sc = ::ClusterResourceControl(
                m_hResource,
                NULL,
                CLUSCTL_RESOURCE_GET_FLAGS,
                NULL,
                0,
                &dwData,
                sizeof( dwData ),
                &cbData
                );
        if ( _sc != ERROR_SUCCESS )
        {
            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pFlags = (CLUS_FLAGS) dwData;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusResource::get_CoreFlag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::BecomeQuorumResource
//
//  Description:
//      Make this resource (Physical Disk) the quorum resource.
//
//  Arguments:
//      bstrDevicePath  [IN]    - Path to the quorum device.
//      lMaxLogSize     [IN]    - Maximun quorum log file size.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::BecomeQuorumResource(
    IN BSTR bstrDevicePath,
    IN long lMaxLogSize
    )
{
    //ASSERT( bstrDevicePath != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrDevicePath != NULL )
    {
        if ( m_hResource != NULL )
        {
            DWORD   _sc = ERROR_SUCCESS;

            _sc = ::SetClusterQuorumResource( m_hResource, bstrDevicePath, lMaxLogSize );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::BecomeQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Delete
//
//  Description:
//      Removes this object (Resource) from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Delete( void )
{
    DWORD   _sc = ERROR_INVALID_HANDLE;

    if ( m_hResource != NULL )
    {
        _sc = ::DeleteClusterResource( m_hResource );
        if ( _sc == ERROR_SUCCESS )
        {
            m_hResource = NULL;
        }
    }
/*
    if ( _sc == ERROR_SUCCESS )
    {
        OutputDebugStringW( L"CClusResource::Delete() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResource::Delete() failed. (m_hResource = %d) (sc = %#08x)\n", m_hResource, _sc );
        OutputDebugStringW( sz );
    } // else: failure...
*/
    return HRESULT_FROM_WIN32( _sc );

} //*** CClusResource::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Fail
//
//  Description:
//      Initiate a failure in this resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Fail( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hResource != NULL )
    {
        DWORD   _sc = ERROR_SUCCESS;

        _sc = ::FailClusterResource( m_hResource );

        _hr =  HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResource::Fail()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Online
//
//  Description:
//      Bring this resource online.
//
//  Arguments:
//      nTimeut [IN]        - How long in seconds to wait for the resource
//                          to come online.
//      pvarPending [OUT]   - Catches the pending state.  True if the
//                          resource was not online when the timeout
//                          expired.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Online(
    IN  long        nTimeout,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        pvarPending->vt         = VT_BOOL;
        pvarPending->boolVal    = VARIANT_FALSE;

        if ( m_hResource != NULL )
        {
            HCLUSTER    hCluster = NULL;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                BOOL    bPending = FALSE;

                _hr = ::HrWrapOnlineClusterResource( hCluster, m_hResource, nTimeout, (long *) &bPending );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( bPending )
                    {
                        pvarPending->boolVal = VARIANT_TRUE;
                    } // if: pending?
                } // if: online resource succeeded
            } // if: do we have a cluster handle?
        } // if: do we have an open resource?
    } // if: args not NULL

    return _hr;

} //*** CClusResource::Online()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Offline
//
//  Description:
//      Take this resource offline.
//
//  Arguments:
//      nTimeut [IN]        - How long in seconds to wait for the resource
//                          to go offline.
//      pvarPending [OUT]   - Catches the pending state.  True if the
//                          resource was not offline when the timeout
//                          expired.
//
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Offline(
    IN  long        nTimeout,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        pvarPending->vt         = VT_BOOL;
        pvarPending->boolVal    = VARIANT_FALSE;

        if ( m_hResource != NULL )
        {
            HCLUSTER    hCluster = NULL;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                BOOL    bPending = FALSE;

                _hr = ::HrWrapOfflineClusterResource( hCluster, m_hResource, nTimeout, (long *) &bPending );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( bPending )
                    {
                        pvarPending->boolVal = VARIANT_TRUE;
                    } // if: pending?
                } // if: offline resource succeeded
            } // if: do we have a cluster handle?
        } // if: do we have an open resource?
    } // if: args not NULL

    return _hr;

} //*** CClusResource::Offline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::ChangeResourceGroup
//
//  Description:
//      Move this resource into the passed in group.
//
//  Arguments:
//      pResourceGroup  [IN]    - the group to move to.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::ChangeResourceGroup(
    IN ISClusResGroup * pResourceGroup
    )
{
    //ASSERT( pResourceGroup != NULL );

    HRESULT _hr = E_POINTER;

    if ( pResourceGroup != NULL )
    {
        HGROUP hGroup = 0;

        _hr = pResourceGroup->get_Handle( (ULONG_PTR *) &hGroup );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ::ChangeClusterResourceGroup( m_hResource, hGroup );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::ChangeResourceGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::AddResourceNode
//
//  Description:
//      Add the passed in node to this resources list of possible owners.
//
//  Arguments:
//      pNode   [IN]    - the node to add to the possible owners.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::AddResourceNode( IN ISClusNode * pNode )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        HNODE hNode = 0;

        _hr = pNode->get_Handle( (ULONG_PTR *) &hNode );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ::AddClusterResourceNode( m_hResource, hNode );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::AddResourceNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::RemoveResourceNode
//
//  Description:
//      remove the passed in node from this resources list of possible owners.
//
//  Arguments:
//      pNode   [IN]    - the node to remove from the possible owners.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::RemoveResourceNode( IN ISClusNode * pNode )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        HNODE hNode = 0;

        _hr = pNode->get_Handle( (ULONG_PTR *) &hNode );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ::RemoveClusterResourceNode( m_hResource, hNode );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::RemoveResourceNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::CanResourceBeDependent
//
//  Description:
//      Determines if this resource can be dependent upon the passed in
//      resource.
//
//  Arguments:
//      pResource       [in]    - The resource upon which this resource may
//                              depend.
//      pvarDependent   [OUT]   - catches whether or not this resource can become
//                              dependent.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::CanResourceBeDependent(
    IN  ISClusResource *    pResource,
    OUT VARIANT *           pvarDependent
    )
{
    //ASSERT( pResource != NULL );
    //ASSERT( pvarDependent != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pvarDependent != NULL ) && ( pResource != NULL ) )
    {
        HRESOURCE hResourceDep = NULL;

        _hr = pResource->get_Handle( (ULONG_PTR *) &hResourceDep );
        if ( SUCCEEDED( _hr ) )
        {
            BOOL    bDependent = FALSE;

            bDependent = ::CanResourceBeDependent( m_hResource, hResourceDep );

            pvarDependent->vt = VT_BOOL;

            if ( bDependent )
            {
                pvarDependent->boolVal = VARIANT_TRUE;
            } // if: can the passed in resource be dependent?
            else
            {
                pvarDependent->boolVal = VARIANT_FALSE;
            } // else: no it cannot...
        }
    }

    return _hr;

} //*** CClusResource::CanResourceBeDependent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_PossibleOwnerNodes
//
//  Description:
//      Returns the possible owner nodes collection for this resource.
//
//  Arguments:
//      ppOwnerNodes    [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_PossibleOwnerNodes(
    OUT ISClusResPossibleOwnerNodes ** ppOwnerNodes
    )
{
    //ASSERT( ppOwnerNodes != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppOwnerNodes != NULL )
    {
        CComObject< CClusResPossibleOwnerNodes > * pClusterNodes = NULL;

        *ppOwnerNodes = NULL;

        _hr = CComObject< CClusResPossibleOwnerNodes >::CreateInstance( &pClusterNodes );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                            ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResPossibleOwnerNodes > >   ptrClusterNodes( pClusterNodes );

            _hr = ptrClusterNodes->Create( ptrRefObject, m_hResource );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrClusterNodes->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusterNodes->QueryInterface( IID_ISClusResPossibleOwnerNodes, (void **) ppOwnerNodes );
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::get_PossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Dependencies
//
//  Description:
//      Get the collection of this resources dependency resources.
//
//  Arguments:
//      ppResources [OUT]   - Catches the collection of dependencies.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Dependencies(
    OUT ISClusResDependencies ** ppResources
    )
{
    //ASSERT( ppResources != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResources != NULL )
    {
        CComObject< CClusResDependencies > * pResources = NULL;

        *ppResources = NULL;

        _hr = CComObject< CClusResDependencies >::CreateInstance( &pResources );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResDependencies > > ptrResources( pResources );

            _hr = ptrResources->Create( ptrRefObject, m_hResource );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrResources->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrResources->QueryInterface( IID_ISClusResDependencies, (void **) ppResources );
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::get_Dependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Dependents
//
//  Description:
//      Get the collection of this resources dependent resources.
//
//  Arguments:
//      ppResources [OUT]   - Catches the collection of dependents.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Dependents(
    OUT ISClusResDependents ** ppResources
    )
{
    //ASSERT( ppResources != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResources != NULL )
    {
        CComObject< CClusResDependents > * pResources = NULL;

        *ppResources = NULL;

        _hr = CComObject< CClusResDependents >::CreateInstance( &pResources );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResDependents > >   ptrResources( pResources );

            _hr = ptrResources->Create( ptrRefObject, m_hResource );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrResources->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrResources->QueryInterface( IID_ISClusResDependents, (void **) ppResources );
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::get_Dependents()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CommonProperties
//
//  Description:
//      Get this object's (Resource) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusResource::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_PrivateProperties
//
//  Description:
//      Get this object's (Resource) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties    );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusResource::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CommonROProperties
//
//  Description:
//      Get this object's (Resource) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusResource::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_PrivateROProperties
//
//  Description:
//      Get this object's (Resource) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusResource::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Group
//
//  Description:
//      Get this resource's owning group.
//
//  Arguments:
//      ppGroup [OUT]   - Catches the owning group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Group( OUT ISClusResGroup ** ppGroup )
{
    //ASSERT( ppGroup != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppGroup != NULL )
    {
        LPWSTR                  pwszGroupName = NULL;
        CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;

        cState = ::WrapGetClusterResourceState( m_hResource, NULL, &pwszGroupName );
        if ( cState != ClusterResourceStateUnknown )
        {
            CComObject< CClusResGroup > * pGroup = NULL;

            _hr = CComObject< CClusResGroup >::CreateInstance( &pGroup );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResGroup > >    ptrGroup( pGroup );
                BSTR                                        bstr = NULL;

                bstr = SysAllocString( pwszGroupName );
                if ( bstr == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                else
                {
                    _hr = ptrGroup->Open( ptrRefObject, bstr );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = ptrGroup->QueryInterface( IID_ISClusResGroup, (void **) ppGroup);
                    }
                    SysFreeString( bstr );
                }
            }

            ::LocalFree( pwszGroupName );
            pwszGroupName = NULL;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::get_Group()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_OwnerNode
//
//  Description:
//      Returns this resource's owning node.
//
//  Arguments:
//      ppNode  [OUT]   - Catches the owning node.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_OwnerNode( OUT ISClusNode ** ppNode )
{
    //ASSERT( ppNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppNode != NULL )
    {
        LPWSTR                  pwszNodeName = NULL;
        CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;

        cState = ::WrapGetClusterResourceState( m_hResource, &pwszNodeName, NULL );
        if ( cState != ClusterResourceStateUnknown )
        {
            CComObject< CClusNode > *   pNode = NULL;

            _hr = CComObject< CClusNode >::CreateInstance( &pNode );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );
                BSTR                                    bstr = NULL;

                bstr = SysAllocString( pwszNodeName );
                if ( bstr == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                else
                {
                    _hr = ptrNode->Open( ptrRefObject, bstr );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = ptrNode->QueryInterface( IID_ISClusNode, (void **) ppNode);
                    }
                    SysFreeString( bstr );
                }
            }

            ::LocalFree( pwszNodeName );
            pwszNodeName = NULL;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::get_OwnerNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Cluster
//
//  Description:
//      Returns the cluster where this resource resides.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Cluster( OUT ISCluster ** ppCluster )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusResource::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;

    if ( bReadOnly )
    {
        _dwControlCode = bPrivate ?
                        CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES :
                        CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetResourceProperties( m_hResource, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusResource::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResource::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES : CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterResourceControl(
                        m_hResource,
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusResource::ScWriteProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_ClassInfo
//
//  Description:
//      Returns the class info for this resource.
//
//  Arguments:
//      prcClassInfo    [OUT]   - Catches the class info.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_ClassInfo(
    OUT CLUSTER_RESOURCE_CLASS * prcClassInfo
    )
{
    ASSERT( prcClassInfo != NULL );

    HRESULT _hr = E_POINTER;

    if ( prcClassInfo != NULL )
    {
        if ( m_hResource != NULL )
        {
            CLUS_RESOURCE_CLASS_INFO    ClassInfo;
            DWORD                       _sc = ERROR_SUCCESS;
            DWORD                       cbData;

            _sc = ::ClusterResourceControl(
                    m_hResource,
                    NULL,
                    CLUSCTL_RESOURCE_GET_CLASS_INFO,
                    NULL,
                    0,
                    &ClassInfo,
                    sizeof( CLUS_RESOURCE_CLASS_INFO ),
                    &cbData
                    );
            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                *prcClassInfo = ClassInfo.rc;
            } // if:
        } // if:
    } // if:

    return _hr;

}   //*** CClusResource::get_ClassInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Disk
//
//  Description:
//      Request the disk information for this physical disk resource.
//
//  Arguments:
//      ppDisk  [OUT]   - catches the disk information.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Disk(
    OUT ISClusDisk **   ppDisk
    )
{
//  ASSERT( ppDisk != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppDisk != NULL )
    {
        if ( m_hResource != NULL )
        {
            CComObject< CClusDisk > *   pDisk = NULL;

            _hr = CComObject< CClusDisk >::CreateInstance( &pDisk );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< CComObject< CClusDisk > >    ptrDisk( pDisk );

                _hr = ptrDisk->Create( m_hResource );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrDisk->QueryInterface( IID_ISClusDisk, (void **) ppDisk);
                } // if:
            } // if:
        } // if:
    } // if:

    return _hr;

}   //*** CClusResource::get_Disk

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_RegistryKeys
//
//  Description:
//      Get the collection of registry keys.
//
//  Arguments:
//      ppRegistryKeys  [OUT]   - catches the registry keys collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_RegistryKeys(
    OUT ISClusRegistryKeys ** ppRegistryKeys
    )
{
    return ::HrCreateResourceCollection< CClusResourceRegistryKeys, ISClusRegistryKeys, HRESOURCE >(
                        m_hResource,
                        ppRegistryKeys,
                        IID_ISClusRegistryKeys
                        );

} //*** CClusResource::get_RegistryKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CryptoKeys
//
//  Description:
//      Get the collection of crypto keys.
//
//  Arguments:
//      ppCryptoKeys    [OUT]   - catches the crypto keys collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CryptoKeys(
    OUT ISClusCryptoKeys ** ppCryptoKeys
    )
{
#if CLUSAPI_VERSION >= 0x0500

    return ::HrCreateResourceCollection< CClusResourceCryptoKeys, ISClusCryptoKeys, HRESOURCE >(
                        m_hResource,
                        ppCryptoKeys,
                        IID_ISClusCryptoKeys
                        );

#else

    return E_NOTIMPL;

#endif // CLUSAPI_VERSION >= 0x0500

} //*** CClusResource::get_CryptoKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_TypeName
//
//  Description:
//      Get the resource type name of this resource.
//
//  Arguments:
//      pbstrTypeName   [OUT]   - Catches the resource type name.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_TypeName( OUT BSTR * pbstrTypeName )
{
    //ASSERT( pbstrTypeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrTypeName != NULL )
    {
        LPWSTR  _psz;
        DWORD   _sc;

        _sc = ScGetResourceTypeName( &_psz );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            *pbstrTypeName = ::SysAllocString( _psz );
            if ( *pbstrTypeName == NULL )
            {
                _hr = E_OUTOFMEMORY;
            }
            ::LocalFree( _psz );
        } // if:
    } // if: arg is not NULL

    return _hr;

} //*** CClusResource::get_TypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Type
//
//  Description:
//      Get the resource type object for this resource.
//
//  Arguments:
//      ppResourceType  [OUT]   - Catches the resource type object.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Type( OUT ISClusResType ** ppResourceType )
{
    //ASSERT( ppResourceType != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResourceType != NULL )
    {
        LPWSTR  _psz;
        DWORD   _sc;

        _sc = ScGetResourceTypeName( &_psz );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            CComObject< CClusResType > *    _pResourceType = NULL;

            _hr = CComObject< CClusResType >::CreateInstance( &_pResourceType );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >            _ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResType > > _ptrResourceType( _pResourceType );
                BSTR                                    _bstr = NULL;

                _bstr = SysAllocString( _psz );
                if ( _bstr == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                else
                {
                    _hr = _ptrResourceType->Open( _ptrRefObject, _bstr );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = _ptrResourceType->QueryInterface( IID_ISClusResType, (void **) ppResourceType );
                    } // if: the resource type could be opened
                    SysFreeString( _bstr );
                }
            } // if: CreateInstance OK

            ::LocalFree( _psz );
        } // if: we got the resource type name for this resource
    } // if: arg is not NULL

    return _hr;

} //*** CClusResource::get_Type()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::ScGetResourceTypeName
//
//  Description:
//      Get the resource type name for this resource.
//
//  Arguments:
//      ppwszResourceTypeName   [OUT]   - Catches the resource type name.
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResource::ScGetResourceTypeName(
    OUT LPWSTR * ppwszResourceTypeName
    )
{
    ASSERT( ppwszResourceTypeName != NULL );

    LPWSTR  _psz = NULL;
    DWORD   _cb = 512;
    DWORD   _sc = ERROR_SUCCESS;

    _psz = (LPWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cb );
    if ( _psz != NULL )
    {
        DWORD   _cbData = 0;

        _sc = ::ClusterResourceControl(
                                m_hResource,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                _psz,
                                _cb,
                                &_cbData
                                );

        if ( _sc == ERROR_MORE_DATA )
        {
            ::LocalFree( _psz );
            _psz = NULL;
            _cb = _cbData;

            _psz = (LPWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cb );
            if ( _psz != NULL )
            {
                _cbData = 0;

                _sc = ::ClusterResourceControl(
                                        m_hResource,
                                        NULL,
                                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                        NULL,
                                        0,
                                        _psz,
                                        _cb,
                                        &_cbData
                                        );
            } // if: alloc ok
            else
            {
                _sc = ::GetLastError();
            } // else: if alloc failed
        } // if: buffer not big enough...

        if ( _sc == ERROR_SUCCESS )
        {
            *ppwszResourceTypeName = _psz;
        } // if:
    } // if: alloc ok
    else
    {
        _sc = ::GetLastError();
    } // else: if alloc failed

    return _sc;

} //*** CClusResource::ScGetResourceTypeName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::CResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResources::CResources( void )
{
    m_pClusRefObject = NULL;

} //*** CResources::CResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::~CResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResources::~CResources( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CResources::~CResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::Create(
    IN ISClusRefObject * pClusRefObject
    )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CResources::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::Clear
//
//  Description:
//      Release the objects in the vector and clean up the vector.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResources::Clear( void )
{
    ::ReleaseAndEmptyCollection< ResourceList, CComObject< CClusResource > >( m_Resources );

} //*** CResources::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::FindItem
//
//  Description:
//      Find the passed in resource in the vector and return its index.
//
//  Arguments:
//      pszResourceName [IN]    - The item to find.
//      pnIndex         [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::FindItem(
    IN  LPWSTR  pszResourceName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComObject< CClusResource > *   _pResource = NULL;
        size_t                          _cMax = m_Resources.size();
        size_t                          _index;

        _hr = E_INVALIDARG;

        for( _index = 0; _index < _cMax; _index++ )
        {
            _pResource = m_Resources[ _index ];

            if ( ( _pResource != NULL ) &&
                 ( lstrcmpi( pszResourceName, _pResource->Name() ) == 0 ) )
            {
                *pnIndex = _index;
                _hr = S_OK;
                break;
            }
        }
    }

    return _hr;

} //*** CResources::FindItem( pszResourceName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::FindItem
//
//  Description:
//      Find the passed in resource in the vector and return its index.
//
//  Arguments:
//      pResource   [IN]    - The item to find.
//      pnIndex     [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::FindItem(
    IN  ISClusResource *    pResource,
    OUT UINT *              pnIndex
    )
{
    //ASSERT( pResource != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pResource != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR bstrName;

        _hr = pResource->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CResources::FindItem( pResource )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        //
        // Check to see if the index is a number.
        //
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--;           // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            //
            // Check to see if the index is a string.
            //
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_Resources.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CResources::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::GetResourceItem
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::GetResourceItem(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    //ASSERT( ppResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResource != NULL )
    {
        CComObject< CClusResource > *   pResource = NULL;
        UINT                            nIndex = 0;

        *ppResource = NULL ;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pResource = m_Resources[ nIndex ];
            _hr = pResource->QueryInterface( IID_ISClusResource, (void **) ppResource );
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CResources::GetResourceItem() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CResources::GetResourceItem() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CResources::GetResourceItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::RemoveAt
//
//  Description:
//      Remove the item at the passed in index from the collection.
//
//  Arguments:
//      pos [IN]    - Index to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::RemoveAt( IN size_t pos )
{
    CComObject<CClusResource> * pResource = NULL;
    ResourceList::iterator      first = m_Resources.begin();
    ResourceList::iterator      last    = m_Resources.end();
    HRESULT                     _hr = E_INVALIDARG;

    for ( size_t t = 0; ( t < pos ) && ( first != last ); t++, first++ );

    if ( first != last )
    {
        pResource = *first;
        if ( pResource )
        {
            pResource->Release();
        }

        m_Resources.erase( first );
        _hr = S_OK;
    }

    return _hr;

} //*** CResources::RemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::DeleteItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_FALSE;
    UINT    nIndex = 0;

    _hr = GetIndex( varIndex, &nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        ISClusResource * pClusterResource = (ISClusResource *) m_Resources[ nIndex ];

        _hr = pClusterResource->Delete();
        if ( SUCCEEDED( _hr ) )
        {
            _hr = RemoveAt( nIndex );
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CResources::RefreshNode() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR   sz[ 128 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CResources::DeleteItem() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CResources::DeleteItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::CClusResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResources::CClusResources( void )
{
    m_piids     = (const IID *) iidCClusResources;
    m_piidsSize = ARRAYSIZE( iidCClusResources );

} //*** CClusResources::CClusResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::~CClusResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResources::~CClusResources( void )
{
    CResources::Clear();

} //*** CClusResources::~CClusResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResources::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResources::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrResourceType    [IN]    - The type of the resource to create.
//      bstrGroupName       [IN]    - The group to create it in.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrResourceType,
    IN  BSTR                            bstrGroupName,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    IN  ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrResourceType != NULL );
    //ASSERT( bstrGroupName != NULL );
    //ASSERT( ppClusterResource != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( ppClusterResource != NULL )   &&
            ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL )    &&
            ( bstrGroupName != NULL ) )
    {
        *ppClusterResource = NULL;

        //
        // Fail if no valid cluster handle.
        //
        if ( m_pClusRefObject != NULL )
        {
            UINT nIndex;

            _hr = FindItem( bstrResourceName, &nIndex );
            if ( FAILED( _hr ) )                         // don't allow duplicates
            {
                HCLUSTER    hCluster = NULL;
                HGROUP      hGroup = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    hGroup = OpenClusterGroup( hCluster, bstrGroupName );
                    if ( hGroup != NULL )
                    {
                        CComObject< CClusResource > *   pClusterResource = NULL;

                        _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                            _hr = ptrResource->Create( ptrRefObject, hGroup, bstrResourceName, bstrResourceType, dwFlags );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    ptrResource->AddRef();
                                    m_Resources.insert( m_Resources.end(), ptrResource );
                                }
                            }
                        }

                        ::CloseClusterGroup( hGroup );
                    }
                    else
                    {
                        DWORD   _sc = 0;

                        _sc = GetLastError();
                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }
            }
            else
            {
                CComObject<CClusResource> * pClusterResource = NULL;

                pClusterResource = m_Resources[ nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            }
        }
    }
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"ClusResources::CreateItem() succeeded.\n" );
    } // if: success
    else
    {
        WCHAR   sz[ 256 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResources::CreateItem() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure
*/
    return _hr;

} //*** CClusResources::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::DeleteItem( IN VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResources::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::Refresh( void )
{
    HRESULT     _hr = E_POINTER;
    HCLUSENUM   _hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;
    HCLUSTER    hCluster = NULL;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        _hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
        if ( _hEnum != NULL )
        {
            int                             _nIndex = 0;
            DWORD                           dwType;
            LPWSTR                          pszName = NULL;
            CComObject< CClusResource > *   pClusterResource = NULL;

            CResources::Clear();

            for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( _hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                } // if: enum is empty.  Time to leave...
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );
                        BSTR                                        bstr = NULL;

                        bstr = SysAllocString( pszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        } // if: could not allocate a bstr
                        else
                        {
                            _hr = ptrResource->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrResource->AddRef();
                                m_Resources.insert( m_Resources.end(), ptrResource );
                            } // if: successfully opened the resource
                            else if ( HRESULT_CODE( _hr ) == ERROR_RESOURCE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the resource to have been deleted from the cluster
                                //  in the time between creating the enum and opening the resource.  When
                                //  that happens we need to simply skip that resource and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster resource was not found

                            SysFreeString( bstr );
                        } // else: successfully allocated a new bstr
                    } // if: successfully created a new resource instance

                    ::LocalFree( pszName );
                    pszName = NULL;
                } // else if: successfully got the resource from the enumerator
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: failed to get the resource from the enumerator
            } // for: each resource in the enumerator

            ::ClusterCloseEnum( _hEnum );
        } // if: opened cluster resource enumerator
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        } // else: could not open cluster resource enumerator
    } // if: got the cluster handle from the ref counted container
/*
    if ( _hr == S_OK )
    {
        OutputDebugStringW( L"CClusResources::Refresh() succeeded.\n" );
    } // if: success!
    else
    {
        WCHAR sz[ 128 ];

        _snwprintf( sz, RTL_NUMBER_OF( sz ), L"CClusResources::Refresh() failed. (hr = %#08x)\n", _hr );

        OutputDebugStringW( sz );
    } // else: failure...
*/
    return _hr;

} //*** CClusResources::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResources::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResources::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResDepends class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::CClusResDepends
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDepends::CClusResDepends( void )
{
    m_hResource = NULL;

} //*** CClusResDepends::CClusResDepends()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::~CClusResDepends
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDepends::~CClusResDepends( void )
{
    Clear();

} //*** CClusResDepends::~CClusResDepends()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResDepends::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hResource       [IN]    - The resource this collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResDepends::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HRESOURCE            hResource
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CResources::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hResource = hResource;
    } // if:

    return _hr;

} //*** CClusResDepends::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResDepends::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::DeleteItem( IN VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResDepends::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResDepends::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::HrRefresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      cre [IN]    - Type of enumeration to perform.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResDepends::HrRefresh( IN CLUSTER_RESOURCE_ENUM cre )
{
    HRESENUM    _hEnum = NULL;
    HRESULT     _hr = S_OK;
    DWORD       _sc = ERROR_SUCCESS;

    _hEnum = ::ClusterResourceOpenEnum( m_hResource, cre );
    if ( _hEnum != NULL )
    {
        int                             _nIndex = 0;
        DWORD                           dwType;
        LPWSTR                          pszName = NULL;
        CComObject< CClusResource > *   pClusterResource = NULL;

        Clear();

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = ::WrapClusterResourceEnum( _hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );
                    BSTR                                        bstr = NULL;

                    bstr = SysAllocString( pszName );
                    if ( bstr == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        _hr = ptrResource->Open( ptrRefObject, bstr );
                        if ( SUCCEEDED( _hr ) )
                        {
                            ptrResource->AddRef();
                            m_Resources.insert( m_Resources.end(), ptrResource );
                        }
                        else if ( HRESULT_CODE( _hr ) == ERROR_RESOURCE_NOT_FOUND )
                        {
                            //
                            //  It is possible for the resource to have been deleted from the cluster
                            //  in the time between creating the enum and opening the resource.  When
                            //  that happens we need to simply skip that resource and continue
                            //  enumerating.
                            //

                            _hr = S_FALSE;      // success code to keep us in the loop
                        } // else if: the cluster resource was not found

                        SysFreeString( bstr );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterResourceCloseEnum( _hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResDepends::HrRefresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrResourceType    [IN]    - The type of the resource to create.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrResourceType,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    OUT ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrResourceType != NULL );
    //ASSERT( ppClusterResource != NULL );
    ASSERT( m_pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( ppClusterResource != NULL )   &&
            ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL ) )
    {
        DWORD   _sc = ERROR_SUCCESS;

        *ppClusterResource = NULL;

        if ( m_pClusRefObject != NULL )
        {
            UINT _nIndex;

            _hr = FindItem( bstrResourceName, &_nIndex );
            if ( FAILED( _hr ) )
            {
                HCLUSTER    hCluster = NULL;
                HGROUP      hGroup = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    LPWSTR                  pwszGroupName = NULL;
                    CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;

                    cState = WrapGetClusterResourceState( m_hResource, NULL, &pwszGroupName );
                    if ( cState != ClusterResourceStateUnknown )
                    {
                        hGroup = ::OpenClusterGroup( hCluster, pwszGroupName );
                        if ( hGroup != NULL )
                        {
                            CComObject< CClusResource > *   pClusterResource = NULL;

                            _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                            if ( SUCCEEDED( _hr ) )
                            {
                                CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                                CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                                _hr = ptrResource->Create( ptrRefObject, hGroup, bstrResourceName, bstrResourceType, dwFlags );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    HRESOURCE   hDependsRes = NULL;

                                    _hr = ptrResource->get_Handle( (ULONG_PTR *) &hDependsRes );
                                    if ( SUCCEEDED( _hr ) )
                                    {
                                        _sc = ScAddDependency( m_hResource, hDependsRes );
                                        if ( _sc == ERROR_SUCCESS )
                                        {
                                            _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                                            if ( SUCCEEDED( _hr ) )
                                            {
                                                ptrResource->AddRef();
                                                m_Resources.insert( m_Resources.end(), ptrResource );
                                            }
                                        }
                                        else
                                        {
                                            _hr = HRESULT_FROM_WIN32( _sc );
                                        }
                                    }
                                }
                            }

                            ::CloseClusterGroup( hGroup );
                        }
                        else
                        {
                            _sc = GetLastError();
                            _hr = HRESULT_FROM_WIN32( _sc );
                        }

                        ::LocalFree( pwszGroupName );
                        pwszGroupName = NULL;
                    } // if: WrapGetClusterResourceState
                    else
                    {
                        _sc = GetLastError();
                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }
            }
            else
            {
                CComObject< CClusResource > *   pClusterResource = NULL;

                pClusterResource = m_Resources[ _nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            }
        }
    }

    return _hr;

} //*** CClusResDepends::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::AddItem
//
//  Description:
//      Make this resource dependent upon the passed in resource.
//
//  Arguments:
//      pResouce    [IN]    - Resource to add to the dependencies list.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::AddItem( IN ISClusResource * pResource )
{
    //ASSERT( pResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( pResource != NULL )
    {
        // Fail if duplicate
        UINT _nIndex = 0;

        _hr = FindItem( pResource, &_nIndex );
        if ( FAILED( _hr ) )
        {
            HRESOURCE                       hResourceDep = NULL;
            CComObject< CClusResource > *   pClusterResource = NULL;

            _hr = pResource->get_Handle( (ULONG_PTR *) &hResourceDep );
            if ( SUCCEEDED( _hr ) )
            {
                DWORD _sc = ScAddDependency( m_hResource, hResourceDep );

                _hr = HRESULT_FROM_WIN32( _sc );
                if ( SUCCEEDED( _hr ) )
                {
                    CComObject< CClusResource > *   _pResource = NULL;

                    _hr = pResource->QueryInterface( IID_CClusResource, (void **) &_pResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _pResource->AddRef();
                        m_Resources.insert( m_Resources.end(), _pResource );

                        pResource->Release();
                    } // if:
                }
            }
        }
        else
        {
            _hr = E_INVALIDARG;
        }
    }

    return _hr;

} //*** CClusResDepends::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::RemoveItem
//
//  Description:
//      Remove the dependency on the resource at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - The index of the item whose dependency should
//                              be removed.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::RemoveItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    UINT    _nIndex = 0;

    _hr = GetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        ISClusResource *    pClusterResource = (ISClusResource *) m_Resources[ _nIndex ];
        HRESOURCE       hResourceDep = NULL;

        _hr = pClusterResource->get_Handle( (ULONG_PTR *) &hResourceDep );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ScRemoveDependency( m_hResource, hResourceDep );

            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = RemoveAt( _nIndex );
            }
        }
    }

    return _hr;

} //*** CClusResDepends::RemoveItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResDependencies class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDependencies::CClusResDependencies
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDependencies::CClusResDependencies( void )
{
    m_piids     = (const IID *) iidCClusResDependencies;
    m_piidsSize = ARRAYSIZE( iidCClusResDependencies );

} //*** CClusResDependencies::CClusResDependencies()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResDependents class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDependents::CClusResDependents
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDependents::CClusResDependents( void )
{
    m_piids     = (const IID *) iidCClusResDependents;
    m_piidsSize = ARRAYSIZE( iidCClusResDependents );

} //*** CClusResDependents::CClusResDependents()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroupResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::CClusResGroupResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupResources::CClusResGroupResources( void )
{
    m_piids     = (const IID *) iidCClusResGroupResources;
    m_piidsSize = ARRAYSIZE( iidCClusResGroupResources );

} //*** CClusResGroupResources::CClusResGroupResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::~CClusResGroupResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupResources::~CClusResGroupResources( void )
{
    Clear();

} //*** CClusResGroupResources::~CClusResGroupResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroupResources::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hGroup          [IN]    - The group this collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroupResources::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN CRefcountedHGROUP               hGroup
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CResources::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hGroup = hGroup;
    } // if:

    return _hr;

} //*** CClusResGroupResources::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResGroupResources::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrResourceType    [IN]    - The type of the resource to create.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrResourceType,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    OUT ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrResourceType != NULL );
    //ASSERT( ppClusterResource != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL )    &&
            ( ppClusterResource != NULL ) )
    {
        *ppClusterResource = NULL;

        if ( m_pClusRefObject != NULL )
        {
            UINT _nIndex = 0;

            _hr = FindItem( bstrResourceName, &_nIndex );
            if ( FAILED( _hr ) )
            {
                HCLUSTER                            hCluster = NULL;
                CComObject< CClusResource > *   pClusterResource = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                        _hr = ptrResource->Create( ptrRefObject, m_hGroup->get_Handle(), bstrResourceName, bstrResourceType, dwFlags );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrResource->AddRef();
                                m_Resources.insert( m_Resources.end(), ptrResource );
                            }
                        }
                    }
                }
            }
            else
            {
                CComObject< CClusResource > *   pClusterResource = NULL;

                pClusterResource = m_Resources[ _nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            }
        }
    }

    return _hr;

} //*** CClusResGroupResources::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::DeleteItem( VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResGroupResources::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::Refresh( void )
{
    HGROUPENUM  hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;
    HRESULT     _hr = S_OK;

    hEnum = ::ClusterGroupOpenEnum( m_hGroup->get_Handle(), CLUSTER_GROUP_ENUM_CONTAINS );
    if ( hEnum != NULL )
    {
        int                             _nIndex = 0;
        DWORD                           dwType;
        LPWSTR                          pszName = NULL;
        CComObject< CClusResource > *   pClusterResource = NULL;

        Clear();

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = ::WrapClusterGroupEnum( hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );
                    BSTR                                        bstr = NULL;

                    bstr = SysAllocString( pszName );
                    if ( bstr == NULL )
                    {
                        _hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        _hr = ptrResource->Open( ptrRefObject, bstr );
                        if ( SUCCEEDED( _hr ) )
                        {
                            ptrResource->AddRef();
                            m_Resources.insert( m_Resources.end(), ptrResource );
                        }
                        else if ( HRESULT_CODE( _hr ) == ERROR_RESOURCE_NOT_FOUND )
                        {
                            //
                            //  It is possible for the resource to have been deleted from the cluster
                            //  in the time between creating the enum and opening the resource.  When
                            //  that happens we need to simply skip that resource and continue
                            //  enumerating.
                            //

                            _hr = S_FALSE;      // success code to keep us in the loop
                        } // else if: the cluster resource was not found

                        SysFreeString( bstr );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterGroupCloseEnum( hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResGroupResources::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResGroupResources::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResTypeResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::CClusResTypeResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypeResources::CClusResTypeResources( void )
{
    m_piids     = (const IID *) iidCClusResTypeResources;
    m_piidsSize = ARRAYSIZE( iidCClusResTypeResources );

} //*** CClusResTypeResources::CClusResTypeResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::~CClusResTypeResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypeResources::~CClusResTypeResources( void )
{
    Clear();

} //*** CClusResTypeResources::~CClusResTypeResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResTypeResources::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrResTypeName [IN]    - The name of the resource type this collection
//                              belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypeResources::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResTypeName
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CResources::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_bstrResourceTypeName = bstrResTypeName;
    } // if:

    return _hr;

} //*** CClusResTypeResources::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResTypeResources::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrGroupName       [IN]    - The group to create it in.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrGroupName,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    OUT ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrGroupName != NULL );
    //ASSERT( ppClusterResource != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( bstrResourceName != NULL )    &&
            ( bstrGroupName != NULL )       &&
            ( ppClusterResource != NULL ) )
    {
        *ppClusterResource = NULL;

        // Fail if no valid cluster handle.
        if ( m_pClusRefObject != NULL )
        {
            UINT _nIndex;

            _hr = FindItem( bstrResourceName, &_nIndex );
            if ( FAILED( _hr ) )                         // duplicates are not allowed
            {
                HCLUSTER                            hCluster = NULL;
                HGROUP                              hGroup = NULL;
                CComObject< CClusResource > *   pClusterResource = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    hGroup = OpenClusterGroup( hCluster, bstrGroupName );
                    if ( hGroup != NULL )
                    {
                        _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                            _hr = ptrResource->Create( ptrRefObject, hGroup, bstrResourceName, m_bstrResourceTypeName, dwFlags );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    ptrResource->AddRef();
                                    m_Resources.insert( m_Resources.end(), ptrResource );
                                } // if: QI ok
                            } // if: Create ok
                        } // if: CreateInstance ok

                        CloseClusterGroup( hGroup );
                    } // if: OpenClusterGroup ok
                    else
                    {
                        DWORD _sc = GetLastError();

                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                } // if: get_Handle ok
            } // if: FindIndex failed. No duplicate entries
            else
            {
                CComObject<CClusResource> * pClusterResource = NULL;

                pClusterResource = m_Resources[ _nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            } // else: found a duplicate
        } // if: m_pClusRefObject is not NULL
    } // if: any NULL argument pointers

    return _hr;

} //*** CClusResTypeResources::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::DeleteItem( IN VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResTypeResources::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::Refresh( void )
{
    DWORD       _sc = ERROR_SUCCESS;
    HRESULT     _hr = E_POINTER;
    HCLUSTER    hCluster = NULL;
    HCLUSENUM   hEnum = NULL;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
        if ( hEnum != NULL )
        {
            int                             _nIndex = 0;
            DWORD                           dwType = 0;
            LPWSTR                          pszName = NULL;
            HRESOURCE                       hResource = NULL;
            WCHAR                           strResType[1024];
            DWORD                           dwData = 0;
            CComObject< CClusResource > *   pClusterResource = NULL;

            Clear();

            for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                } // if: Enumerator is empty.  Time to leave.
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );
                        BSTR                                        bstr = NULL;

                        bstr = SysAllocString( pszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        } // if: failed to allocated a bstr
                        else
                        {
                            _hr = ptrResource->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = ptrResource->get_Handle( (ULONG_PTR *) &hResource );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    _sc = ClusterResourceControl(
                                                                    hResource,
                                                                    NULL,
                                                                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                                                    NULL,
                                                                    0,
                                                                    strResType,
                                                                    sizeof( strResType ),
                                                                    &dwData
                                                                    );
                                    if ( _sc == ERROR_SUCCESS )
                                    {
                                        if ( lstrcmpi( strResType, m_bstrResourceTypeName ) == 0 )
                                        {
                                            ptrResource->AddRef();
                                            m_Resources.insert( m_Resources.end(), ptrResource );
                                        } // if: the resource is of this resource type
                                    } // if: successfully got the resource's resource type
                                    else
                                    {
                                        _hr = HRESULT_FROM_WIN32( _sc );
                                    } // else: failed to get the resoruce's resource type
                                } // if: successfully got the resource's handle
                            } // if: successfully opened the resource
                            else if ( HRESULT_CODE( _hr ) == ERROR_RESOURCE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the resource to have been deleted from the cluster
                                //  in the time between creating the enum and opening the resource.  When
                                //  that happens we need to simply skip that resource and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster resource was not found

                            SysFreeString( bstr );
                        } // else: successfully created a bstr
                    } // if: successfully created a resource object instance

                    ::LocalFree( pszName );
                    pszName = NULL;
                } // if: successfully got a resource from the enumerator
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: failed to get a resource from the enumerator
            } // for: each resource in the enumerator

            ::ClusterCloseEnum( hEnum );
        } // if: successfully created a resource enumerator
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        } // else: failed to create a resource enumerator
    } // if: successfully got the cluster handle

    return _hr;

} //*** CClusResTypeResources::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResTypeResources::get_Item()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusresg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusResG.h
//
//	Description:
//		Definition of the resource group classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusResG.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSRESG_H_
#define _CLUSRESG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusResGroup;
class CClusResGroups;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNodes;
class CClusResGroupPreferredOwnerNodes;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroup
//
//	Description:
//		Cluster Resource Group Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroup, &IID_ISClusResGroup, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo,
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResGroup, &CLSID_ClusResGroup >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroup	:
	public IDispatchImpl< ISClusResGroup, &IID_ISClusResGroup, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResGroup, &CLSID_ClusResGroup >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroup( void );
	~CClusResGroup( void );

BEGIN_COM_MAP(CClusResGroup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroup)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroup)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *									m_pClusRefObject;
	CComObject< CClusResGroupResources > *				m_pClusterResources;
	CComObject< CClusResGroupPreferredOwnerNodes > *	m_pPreferredOwnerNodes;
	CComObject< CClusProperties > *						m_pCommonProperties;
	CComObject< CClusProperties > *						m_pPrivateProperties;
	CComObject< CClusProperties > *						m_pCommonROProperties;
	CComObject< CClusProperties > *						m_pPrivateROProperties;
	CRefcountedHGROUP												m_hGroup;
	CComBSTR											m_bstrGroupName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN BSTR bstrGroupName );

	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrGroupName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP Close( void );

	STDMETHODIMP put_Name( IN BSTR bstrGroupName );

	STDMETHODIMP get_Name( OUT BSTR * pbstrGroupName );

	STDMETHODIMP get_State( OUT CLUSTER_GROUP_STATE * dwState );

	STDMETHODIMP get_OwnerNode( OUT ISClusNode ** ppOwnerNode );

	STDMETHODIMP get_Resources( OUT ISClusResGroupResources ** ppClusterGroupResources );

	STDMETHODIMP get_PreferredOwnerNodes( OUT ISClusResGroupPreferredOwnerNodes ** ppOwnerNodes );

	STDMETHODIMP Delete( void );

	STDMETHODIMP Online( IN VARIANT varTimeout, VARIANT varNode, OUT VARIANT * pvarPending );

	STDMETHODIMP Move( IN VARIANT varTimeout, VARIANT varNode, OUT VARIANT * pvarPending );

	STDMETHODIMP Offline( IN VARIANT varTimeout, OUT VARIANT * pvarPending );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrGroupName; };

	const HGROUP Hgroup( void ) const { return m_hGroup->get_Handle(); };

}; //*** Class CClusResGroup

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroups
//
//	Description:
//		Cluster Resource Group Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroups, &IID_ISClusResGroups, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResGroups, &CLSID_ClusResGroups >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroups :
	public IDispatchImpl< ISClusResGroups, &IID_ISClusResGroups, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResGroups, &CLSID_ClusResGroups >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroups( void );
	~CClusResGroups( void );

BEGIN_COM_MAP(CClusResGroups)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroups)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroups)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN LPCWSTR pszNodeName = NULL );

protected:
	typedef std::vector< CComObject< CClusResGroup > * >	ResourceGroupList;

	ResourceGroupList	m_ResourceGroups;
	ISClusRefObject *	m_pClusRefObject;
	CComBSTR			m_bstrNodeName;

	void	Clear( void );

	HRESULT FindItem( IN LPWSTR lpszGroupName, OUT ULONG * pnIndex );

	HRESULT FindItem( IN ISClusResGroup * pResourceGroup, OUT ULONG * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT ULONG * pnIndex );

	HRESULT RemoveAt( IN size_t pos );

	HRESULT RefreshCluster( void );

	HRESULT RefreshNode( void );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResGroup ** ppResourceGroup );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem( IN BSTR bstrResourceGroupName, OUT ISClusResGroup ** ppResourceGroup );

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResGroups

#endif // _CLUSRESG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\interfacever.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		InterfaceVer.h
//
//	Module Description:
//		Interface version defines
//
//	Implementation File:
//
//	Author:
//		Galen Barbee	(GalenB)	18-Nov-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INTERFACEVER_H_
#define _INTERFACEVER_H_

#define	MAJORINTERFACEVER		1

#define	MINORINTERFACEVER		0

#endif // _INTERFACEVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusterobject.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  Module Name:
//      ClusterObject.h
//
//  Description:
//      Definition of the CClusterObject base class.
//
//  Implementation File:
//      ClusterObject.cpp
//
//  Author:
//      Galen Barbee    (GalenB)    10-Dec-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSTEROBJECT_H_
#define _CLUSTEROBJECT_H_

#ifndef __PROPERTY_H__
    #include "property.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterObject
//
//  Description:
//      Cluster object common implementation base Class.
//
//  Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusterObject
{
public:
    //CClusterObject( void );
    //~CClusterObject( void );

    virtual HRESULT HrLoadProperties( IN CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate ) = 0;

    virtual HRESULT HrSaveProperties(
                        IN OUT  CClusProperties::CClusPropertyVector &  cpvProps,
                        IN      BOOL                                    bPrivate,
                        OUT     VARIANT *                               pvarStatusCode
                        );

protected:
    virtual HRESULT HrBuildPropertyList(
                        IN OUT  CClusProperties::CClusPropertyVector &  cpvProps,
                        OUT     CClusPropList &                         rcplPropList
                        );

    virtual DWORD ScWriteProperties( IN const CClusPropList & /*rcplPropList*/, IN BOOL /*bPrivate*/ )
    {
        return E_NOTIMPL;
    }

private:
    HRESULT HrConvertVariantToDword( IN const CComVariant & rvarValue, OUT PDWORD pdwValue );

    HRESULT HrConvertVariantToLong( IN const CComVariant & rvarValue, OUT long * plValue );

    HRESULT HrConvertVariantToULONGLONG( IN const CComVariant & rvarValue, OUT PULONGLONG pullValue );

    HRESULT HrAddBinaryProp(
                    IN OUT  CClusPropList &     rcplPropList,
                    IN      LPCWSTR             pszPropName,
                    IN      const CComVariant & rvarPropValue
                     );

    HRESULT HrAddMultiSzProp(
                    IN OUT  CClusPropList &                             rcplPropList,
                    IN      LPCWSTR                                     pszPropName,
                    IN      const CComObject< CClusPropertyValues > &   rcpvValues
                    );

};  //*** Class CClusterObject

#endif // _CLUSTEROBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusterobject.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  Module Name:
//      ClusterObject.cpp
//
//  Description:
//      Implementation of ClusterObject
//
//  Author:
//      Galen Barbee    (GalenB)    14-Dec-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterObject class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrSaveProperties
//
//  Description:
//      Save the properties to the cluster database.
//
//  Arguments:
//      cpvProps        [IN OUT]    - The properties to save.
//      bPrivate        [IN]        - Are these private properties?
//      pvarStatusCode  [OUT]       - Catches additional status.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrSaveProperties(
    IN OUT  CClusProperties::CClusPropertyVector &  cpvProps,
    IN      BOOL                                    bPrivate,
    OUT     VARIANT *                               pvarStatusCode
    )
{
    HRESULT         _hr = S_FALSE;
    CClusPropList   _cplPropList( TRUE );       // always add the prop...
    DWORD           sc;

    sc = _cplPropList.ScAllocPropList( 8192 );
    _hr = HRESULT_FROM_WIN32( sc );
    if ( SUCCEEDED( _hr ) )
    {
        _hr = HrBuildPropertyList( cpvProps, _cplPropList );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD   _sc = ERROR_SUCCESS;

            _sc = ScWriteProperties( _cplPropList, bPrivate );

            pvarStatusCode->vt      = VT_ERROR;                             // fill in the error code info
            pvarStatusCode->scode   = _sc;

            if ( _sc == ERROR_RESOURCE_PROPERTIES_STORED )
            {
                _hr = S_OK;
            } // if: if ERROR_RESOURCE_PROPERTIES_STORED then convert to S_OK...
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            } // else: simply use the status code as is...
        } // if:
    } // if:

    return _hr;

} //*** CClusterObject::HrSaveProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrBuildPropertyList
//
//  Description:
//      Build a proper property list from the passed in properties collection.
//
//  Arguments:
//      cpvProps        [IN, OUT]   - The vector that is the properties.
//      rcplPropList    [OUT]       - The property list to add to.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrBuildPropertyList(
    IN OUT  CClusProperties::CClusPropertyVector &  cpvProps,
    OUT     CClusPropList &                         rcplPropList
    )
{
    HRESULT                                                 _hr = S_OK;
    CComObject< CClusProperty > *                           _pProperty = 0;
    CClusProperties::CClusPropertyVector::iterator          _itCurrent = cpvProps.begin();
    CClusProperties::CClusPropertyVector::const_iterator    _itLast  = cpvProps.end();
    DWORD                                                   _sc = ERROR_SUCCESS;
    CLUSTER_PROPERTY_FORMAT                                 _cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

    for ( ; ( _itCurrent != _itLast ) && ( SUCCEEDED( _hr ) ); _itCurrent++ )
    {
        _pProperty = *_itCurrent;

        _hr = _pProperty->get_Format( &_cpfFormat );
        if ( SUCCEEDED( _hr ) )
        {
            if ( _pProperty->Modified() )
            {
                if ( _pProperty->IsDefaultValued() )
                {
                    _sc = rcplPropList.ScSetPropToDefault( _pProperty->Name(), _cpfFormat );
                    _hr = HRESULT_FROM_WIN32( _sc );
                    continue;
                } // if: property was set to its default state
                else
                {
                    switch( _cpfFormat )
                    {
                        case CLUSPROP_FORMAT_DWORD :
                        {
                            DWORD   dwValue = 0;

                            _hr = HrConvertVariantToDword( _pProperty->Value(), &dwValue );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _sc = rcplPropList.ScAddProp( _pProperty->Name(), dwValue, (DWORD) 0 );
                                _hr = HRESULT_FROM_WIN32( _sc );
                            } // if:
                            break;
                        } // case:

#if CLUSAPI_VERSION >= 0x0500

                        case CLUSPROP_FORMAT_LONG :
                        {
                            long    lValue = 0L;

                            _hr = HrConvertVariantToLong( _pProperty->Value(), &lValue );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _sc = rcplPropList.ScAddProp( _pProperty->Name(), lValue, 0L );
                                _hr = HRESULT_FROM_WIN32( _sc );
                            } // if:
                            break;
                        } // case:

#endif // CLUSAPI_VERSION >= 0x0500

                            case CLUSPROP_FORMAT_ULARGE_INTEGER :
                            {
                                ULONGLONG   ullValue = 0;

                                _hr = HrConvertVariantToULONGLONG( _pProperty->Value(), &ullValue );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    _sc = rcplPropList.ScAddProp( _pProperty->Name(), ullValue, 0 );
                                    _hr = HRESULT_FROM_WIN32( _sc );
                                } // if:
                                break;
                            } // case:

                            case CLUSPROP_FORMAT_SZ :
                            case CLUSPROP_FORMAT_EXPAND_SZ :
                            {
                                _sc = rcplPropList.ScAddProp( _pProperty->Name(), _pProperty->Value().bstrVal );
                                _hr = HRESULT_FROM_WIN32( _sc );
                                break;
                            } // case:

                            case CLUSPROP_FORMAT_MULTI_SZ:
                            {
                                _hr = HrAddMultiSzProp( rcplPropList, _pProperty->Name(), _pProperty->Values() );
                                break;
                            } // case:

                            case CLUSPROP_FORMAT_BINARY:
                            {
                                _hr = HrAddBinaryProp(
                                                rcplPropList,
                                                _pProperty->Name(),
                                                _pProperty->Value()
                                                );
                                break;
                            } // case:
                        } // end switch

                        _pProperty->Modified( FALSE );
                } // else: common property was not deleted
            } // if: property was modified
        } // if: we got the property format

    } // for: property in the collection


    return _hr;

} //*** CClusterObject::HrBuildPropertyList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrConvertVariantToDword
//
//  Description:
//      Convert the passed in varint to a DWORD.
//
//  Arguments:
//      rvarValue   [IN]    - The variant value to convert.
//      pdwValue    [OUT]   - Catches the converted value.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the value cannot be converted.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrConvertVariantToDword(
    IN  const CComVariant & rvarValue,
    OUT PDWORD              pdwValue
    )
{
    HRESULT _hr = S_OK;

    switch ( rvarValue.vt )
    {
        case VT_I2:
        {
            *pdwValue = (DWORD) rvarValue.iVal;
            break;
        } // case:

        case VT_I4:
        {
            *pdwValue = (DWORD) rvarValue.lVal;
            break;
        } // case:

        case VT_BOOL:
        {
            *pdwValue = (DWORD) rvarValue.boolVal;
            break;
        } // case:

        default:
        {
            _hr = E_INVALIDARG;
            break;
        } // default:
    } // switch:

    return _hr;

} //*** CClusterObject::HrConvertVariantToDword()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrConvertVariantToLong
//
//  Description:
//      Convert the passed in varint to a long.
//
//  Arguments:
//      rvarValue   [IN]    - The variant value to convert.
//      plValue     [OUT]   - Catches the converted value.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the value cannot be converted.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrConvertVariantToLong(
    IN  const CComVariant & rvarValue,
    OUT long *              plValue
    )
{
    HRESULT _hr = S_OK;

    switch ( rvarValue.vt )
    {
        case VT_I2:
        {
            *plValue = (long) rvarValue.iVal;
            break;
        } // case:

        case VT_I4:
        {
            *plValue = rvarValue.lVal;
            break;
        } // case:

        case VT_BOOL:
        {
            *plValue = (long) rvarValue.boolVal;
            break;
        } // case:

        default:
        {
            _hr = E_INVALIDARG;
            break;
        } // default:
    } // switch:

    return _hr;

} //*** CClusterObject::HrConvertVariantToLong()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrConvertVariantToULONGLONG
//
//  Description:
//      Convert the passed in varint to a ULONGLONG.
//
//  Arguments:
//      rvarValue   [IN]    - The variant value to convert.
//      pullValue   [OUT]   - Catches the converted value.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the value cannot be converted.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrConvertVariantToULONGLONG(
    IN  const CComVariant & rvarValue,
    OUT PULONGLONG          pullValue
    )
{
    HRESULT _hr = S_OK;

    switch ( rvarValue.vt )
    {
        case VT_I8:
        {
            *pullValue = rvarValue.ulVal;
            break;
        } // case:

        case VT_R8:
        {
            *pullValue = (ULONGLONG) rvarValue.dblVal;
            break;
        } // case:

        default:
        {
            _hr = E_INVALIDARG;
            break;
        } // default:
    } // switch:

    return _hr;

} //*** CClusterObject::HrConvertVariantToULONGLONG()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrAddBinaryProp
//
//  Description:
//      Create a binary property from the passed in variant and add it to the
//      property list so it can be saved into the cluster DB.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to add the binary
//                                  property to.
//      pszPropName     [IN]        - The name of the multisz property.
//      rvarPropValue   [IN]        - The value that is the binary property.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrAddBinaryProp(
    IN OUT  CClusPropList &     rcplPropList,
    IN      LPCWSTR             pszPropName,
    IN      const CComVariant & rvarPropValue
    )
{
    ASSERT( rvarPropValue.vt & VT_ARRAY );

    HRESULT     _hr = E_INVALIDARG;
    SAFEARRAY * _psa = rvarPropValue.parray;
    long        _cb;
    PBYTE       _pb;

    if ( _psa != NULL )
    {
        _hr = HrSafeArraySizeof( _psa, 1, &_cb );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = ::SafeArrayAccessData( _psa, (PVOID *) &_pb );
            if ( SUCCEEDED( _hr ) )
            {
                DWORD   _sc = rcplPropList.ScAddProp( pszPropName, _pb, _cb, NULL, 0 );

                _hr = HRESULT_FROM_WIN32( _sc );

                //
                // release the pointer into the SafeArray
                //

                ::SafeArrayUnaccessData( _psa );
            } // if:
        } // if:
    } // if:

    return _hr;

} //*** CClusterObject::HrAddBinaryProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterObject::HrAddMultiSzProp
//
//  Description:
//      Create a multisz property from the passed in property values and add it
//      to the property list so it can be saved in the cluster DB.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to add the multisz to.
//      pszPropName     [IN]        - The name of the multisz property.
//      rPropertyValues [IN]        - The values that are the multisz property.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrAddMultiSzProp(
    IN OUT  CClusPropList &                             rcplPropList,
    IN      LPCWSTR                                     pszPropName,
    IN      const CComObject< CClusPropertyValues > &   rPropertyValues
    )
{
    HRESULT                                                 _hr = E_INVALIDARG;
    const CClusPropertyValues::CClusPropertyValueVector &   _rPropValuesList = rPropertyValues.ValuesList();

    //
    // KB: Only going to iterate one value and its data!!
    //
    if ( !_rPropValuesList.empty() )
    {
        CClusPropertyValues::CClusPropertyValueVector::const_iterator   _itPropValue = _rPropValuesList.begin();
        const CComObject< CClusPropertyValueData > *                    _pPropertyValueData = (*_itPropValue)->Data();

        if ( _pPropertyValueData != NULL )
        {
            LPWSTR  _psz    = NULL;
            DWORD   _sc     = ERROR_SUCCESS;

            _hr = _pPropertyValueData->HrFillMultiSzBuffer( &_psz );
            if ( SUCCEEDED( _hr ) )
            {
                _sc = rcplPropList.ScAddMultiSzProp( pszPropName, _psz, NULL );
                _hr = HRESULT_FROM_WIN32( _sc );

                ::LocalFree( _psz );
            } // if:
        } // if:
    } // if:

    return _hr;

} //*** CClusterObject::HrAddMultiSzProp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusrest.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusResT.h
//
//	Description:
//		Definition of the resource type classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusNetI.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSREST_H_
#define _CLUSREST_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusResType;
class CClusResTypes;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResType
//
//	Description:
//		Cluster Resource Type Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResType, &IID_ISClusResType, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResType, &CLSID_ClusResType >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResType :
	public IDispatchImpl< ISClusResType, &IID_ISClusResType, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResType, &CLSID_ClusResType >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResType( void );
	~CClusResType( void );

BEGIN_COM_MAP(CClusResType)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResType)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResType)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *					m_pClusRefObject;
	CComObject< CClusProperties > *		m_pCommonProperties;
	CComObject< CClusProperties > *		m_pPrivateProperties;
	CComObject< CClusProperties > *		m_pCommonROProperties;
	CComObject< CClusProperties > *		m_pPrivateROProperties;
	CComObject<CClusResTypeResources> *	m_pClusterResTypeResources;
	CComBSTR							m_bstrResourceTypeName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Create(
		ISClusRefObject *	pClusRefObject,
		BSTR				bstrResourceTypeName,
		BSTR				bstrDisplayName,
		BSTR				bstrResourceTypeDll,
		long				dwLooksAlivePollInterval,
		long				dwIsAlivePollInterval
		);

	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResourceTypeName );

	STDMETHODIMP get_Name( OUT BSTR * pbstrTypeName );

	STDMETHODIMP Delete( void );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_Resources( OUT ISClusResTypeResources ** ppClusterResTypeResources );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	STDMETHODIMP get_PossibleOwnerNodes( OUT ISClusResTypePossibleOwnerNodes ** ppOwnerNodes );

	STDMETHODIMP get_AvailableDisks( OUT ISClusDisks ** ppAvailableDisks );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrResourceTypeName ; };

}; //*** Class CClusResType

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypes
//
//	Description:
//		Cluster Resource Types Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResTypes, &IID_ISClusResTypes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResTypes, &CLSID_ClusResTypes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResTypes :
	public IDispatchImpl< ISClusResTypes, &IID_ISClusResTypes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResTypes, &CLSID_ClusResTypes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResTypes( void );
	~CClusResTypes( void );

BEGIN_COM_MAP(CClusResTypes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResTypes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResTypes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject* pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusResType > * > ResourceTypeList;

	ResourceTypeList	m_ResourceTypes;
	ISClusRefObject *	m_pClusRefObject;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR pszResourceTypeName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusResType * pResourceType, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT RemoveAt( OUT size_t pos );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResType ** ppResourceType );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
		IN	BSTR				bstrResourceTypeName,
		IN	BSTR				bstrDisplayName,
		IN	BSTR				bstrResourceTypeDll,
		IN	long				dwLooksAlivePollInterval,
		IN	long				dwIsAlivePollInterval,
		OUT	ISClusResType **	ppResourceType
		);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResTypes

#endif // _CLUSREST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\clusrest.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      ClusResT.cpp
//
//  Description:
//      Implementation of the resource type classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusneti.h"
#include "clusnode.h"
#include "clusrest.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID * iidCClusResourceType[] =
{
    &IID_ISClusResType
};

static const IID * iidCClusResourceTypes[] =
{
    &IID_ISClusResTypes
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResType class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::CClusResType
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResType::CClusResType( void )
{
    m_pClusRefObject        = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;
    m_pClusterResTypeResources      = NULL;

    m_piids     = (const IID *) iidCClusResourceType;
    m_piidsSize = ARRAYSIZE( iidCClusResourceType );

} //*** CClusResType::CClusResType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::~CClusResType
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResType::~CClusResType( void )
{
    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusterResTypeResources != NULL )
    {
        m_pClusterResTypeResources->Release();
        m_pClusterResTypeResources = NULL;
    }

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CClusResType::~CClusResType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Resource Type).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::GetProperties(
    OUT ISClusProperties ** ppProperties,
    IN  BOOL                bPrivate,
    IN  BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        *ppProperties = NULL;

        CComObject< CClusProperties > * pProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusResType::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::Create
//
//  Description:
//      Create a new Resource Type and add it to the cluster.
//
//  Arguments:
//      pClusRefObject              [IN]    - Cluster handle wrapper.
//      bstrResourceTypeName        [IN]    - Name of the new resource type.
//      bstrDisplayName             [IN]    - Resource type display name.
//      bstrResourceTypeDll         [IN]    - Resource type implementation dll.
//      dwLooksAlivePollInterval    [IN]    - Looks alive poll interval.
//      dwIsAlivePollInterval       [IN]    - Is alive poll interval.
//
//  Return Value:
//      S_OK if successful, or Win32 error wrapped in HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResourceTypeName,
    IN BSTR                 bstrDisplayName,
    IN BSTR                 bstrResourceTypeDll,
    IN long                 dwLooksAlivePollInterval,
    IN long                 dwIsAlivePollInterval
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrResourceTypeName != NULL );
    ASSERT( bstrDisplayName != NULL );
    ASSERT( bstrResourceTypeDll != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( pClusRefObject != NULL )          &&
            ( pClusRefObject != NULL )          &&
            ( bstrResourceTypeName != NULL )    &&
            ( bstrDisplayName != NULL ) )
    {
        DWORD       _sc = 0;
        HCLUSTER    hCluster = NULL;

        m_pClusRefObject= pClusRefObject;
        m_pClusRefObject->AddRef();

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster);
        if ( SUCCEEDED( _hr ) )
        {
            _sc = CreateClusterResourceType(
                                            hCluster,
                                            bstrResourceTypeName,
                                            bstrDisplayName,
                                            bstrResourceTypeDll,
                                            dwLooksAlivePollInterval,
                                            dwIsAlivePollInterval
                                            );
            if ( _sc == ERROR_SUCCESS )
            {
                m_bstrResourceTypeName = bstrResourceTypeName ;
            }

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResType::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::Open
//
//  Description:
//      Create a resource type object from an existing object in the cluster.
//
//  Arguments:
//      pClusRefObject              [IN]    - Cluster handle wrapper.
//      bstrResourceTypeName        [IN]    - Name of the resource type to open.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResourceTypeName
    )
{
    ASSERT( pClusRefObject != NULL );
    //ASSERT( bstrResourceTypeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrResourceTypeName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;

        m_pClusRefObject->AddRef();
        m_bstrResourceTypeName = bstrResourceTypeName;

        return S_OK;
    }

    return _hr;

} //*** CClusResType::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_Name
//
//  Description:
//      Return the name of this object (Resource Type).
//
//  Arguments:
//      pbstrTypeName   [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_Name( OUT BSTR * pbstrTypeName )
{
    //ASSERT( pbstrTypeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrTypeName != NULL )
    {
        *pbstrTypeName = m_bstrResourceTypeName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResType::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::Delete
//
//  Description:
//      Removes this object (Resource Type) from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::Delete( void )
{
    ASSERT( m_bstrResourceTypeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( m_bstrResourceTypeName != NULL )
    {
        HCLUSTER    hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD    _sc = DeleteClusterResourceType( hCluster, m_bstrResourceTypeName );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResType::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_CommonProperties
//
//  Description:
//      Get this object's (Resource Type) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties != NULL )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void   **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusResType::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_PrivateProperties
//
//  Description:
//      Get this object's (Resource Type) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties != NULL )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusResType::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_CommonROProperties
//
//  Description:
//      Get this object's (Resource Type) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties != NULL )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties,   (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusResType::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_PrivateROProperties
//
//  Description:
//      Get this object's (Resource Type) private readonly properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties != NULL )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusResType::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_Cluster
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_Cluster(
    ISCluster **    ppCluster
    )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusResType::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    ASSERT( m_pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( m_pClusRefObject != NULL )
    {
        HCLUSTER    hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD       _dwControlCode  = 0;
            DWORD       _sc             = ERROR_SUCCESS;

            if ( bReadOnly )
            {
                _dwControlCode = bPrivate
                                ? CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES
                                : CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES;
            }
            else
            {
                _dwControlCode = bPrivate
                                ? CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
                                : CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;
            }

            _sc = rcplPropList.ScGetResourceTypeProperties( hCluster, m_bstrResourceTypeName, _dwControlCode );

            _hr = HRESULT_FROM_WIN32( _sc );
        } // if:
    } // if:

    return _hr;

} //*** CClusResType::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResType::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    ASSERT( m_pClusRefObject != NULL );

    DWORD   _sc = ERROR_BAD_ARGUMENTS;

    if ( m_pClusRefObject != NULL )
    {
        HCLUSTER    hCluster = NULL;

        if ( S_OK == m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster ) )
        {
            DWORD   dwControlCode   = bPrivate
                                      ? CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES
                                      : CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;
            DWORD   nBytesReturned  = 0;

            _sc = ClusterResourceTypeControl(
                                    hCluster,
                                    m_bstrResourceTypeName,
                                    NULL,
                                    dwControlCode,
                                    rcplPropList,
                                    rcplPropList.CbBufferSize(),
                                    0,
                                    0,
                                    &nBytesReturned
                                    );
        } // if:
    } // if:

    return _sc;

} //*** CClusResType::ScWriteProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_Resources
//
//  Description:
//      Create a collection of the resources of this type.
//
//  Arguments:
//      ppClusterResTypeResources   [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_Resources(
    OUT ISClusResTypeResources ** ppClusterResTypeResources
    )
{
    return ::HrCreateResourceCollection< CClusResTypeResources, ISClusResTypeResources, CComBSTR >(
                        &m_pClusterResTypeResources,
                        m_bstrResourceTypeName,
                        ppClusterResTypeResources,
                        IID_ISClusResTypeResources,
                        m_pClusRefObject
                        );

} //*** CClusResType::get_Resources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_PossibleOwnerNodes
//
//  Description:
//      Create a collection of possible owner nodes for this resource type.
//
//  Arguments:
//      ppOwnerNodes    [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_PossibleOwnerNodes(
    ISClusResTypePossibleOwnerNodes **  ppOwnerNodes
    )
{
    //
    // KB:  Can't use one of the template functions here!  There is an internal compiler error(C1001).
    //      I am assuming that the type names are too long.  Very sad for 1999 ;-)
    //
    //ASSERT( ppOwnerNodes != NULL );

    HRESULT _hr = E_POINTER;

#if CLUSAPI_VERSION >= 0x0500

    if ( ppOwnerNodes != NULL )
    {
        CComObject< CClusResTypePossibleOwnerNodes > * pClusterNodes = NULL;

        *ppOwnerNodes = NULL;

        _hr = CComObject< CClusResTypePossibleOwnerNodes >::CreateInstance( &pClusterNodes );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                                ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResTypePossibleOwnerNodes > >   ptrClusterNodes( pClusterNodes );

            _hr = ptrClusterNodes->Create( ptrRefObject, m_bstrResourceTypeName );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrClusterNodes->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusterNodes->QueryInterface( IID_ISClusResTypePossibleOwnerNodes, (void **) ppOwnerNodes );
                }
            }
        }
    }

#else

    _hr = E_NOTIMPL;

#endif // CLUSAPI_VERSION >= 0x0500

    return _hr;

} //*** CClusResType::get_PossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResType::get_AvailableDisks
//
//  Description:
//      Get the collection of available disks.
//
//  Arguments:
//      ppAvailableDisk [OUT]   - catches the available disks collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_AvailableDisks(
    OUT ISClusDisks **  ppAvailableDisks
    )
{
    return ::HrCreateResourceCollection< CClusDisks, ISClusDisks, CComBSTR >(
                        ppAvailableDisks,
                        m_bstrResourceTypeName,
                        IID_ISClusDisks,
                        m_pClusRefObject
                        );

} //*** CClusResType::get_AvailableDisks()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResTypes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::CClusResTypes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypes::CClusResTypes( void )
{
    m_pClusRefObject    = NULL;
    m_piids             = (const IID *) iidCClusResourceTypes;
    m_piidsSize         = ARRAYSIZE( iidCClusResourceTypes );

} //*** CClusResTypes::CClusResTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::~CClusResTypes
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypes::~CClusResTypes( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

} //*** CClusResTypes::~CClusResTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    } // if: args are not NULL

    return _hr;

} //*** CClusResTypes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::get_Count
//
//  Description:
//      Returns the count of elements (ResTypes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_ResourceTypes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResTypes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::Clear
//
//  Description:
//      Clean out the vector of ClusResGroup objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusResTypes::Clear( void )
{
    ::ReleaseAndEmptyCollection< ResourceTypeList, CComObject< CClusResType > >( m_ResourceTypes );

} //*** CClusResTypes::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::FindItem
//
//  Description:
//      Find the passed in resource type in the collection.
//
//  Arguments:
//      pszResourceTypeName [IN]    - The name of the resource type to find.
//      pnIndex             [OUT]   - Catches the index of the group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the resource type
//      was not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::FindItem(
    IN  LPWSTR  pszResourceTypeName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pszResourceTypeName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pszResourceTypeName != NULL ) && ( pnIndex != NULL ) )
    {
        CComObject<CClusResType> *  pResourceType = NULL;
        int                              nMax = m_ResourceTypes.size();

        _hr = E_INVALIDARG;

        for( int i = 0; i < nMax; i++ )
        {
            pResourceType = m_ResourceTypes[i];

            if ( pResourceType && ( lstrcmpi( pszResourceTypeName, pResourceType->Name() ) == 0 ) )
            {
                *pnIndex = i;
                _hr = S_OK;
                break;
            }
        }
    }

    return _hr;

} //*** CClusResTypes::FindItem( pszResourceTypeName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::FindItem
//
//  Description:
//      Find the passed in resource type in the collection.
//
//  Arguments:
//      pszResourceTypeName [IN]    - The name of the resource type to find.
//      pnIndex             [OUT]   - Catches the index of the group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the resource type
//      was not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::FindItem(
    IN  ISClusResType * pResourceType,
    OUT UINT *          pnIndex
    )
{
    //ASSERT( pResourceType != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pResourceType != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR bstrName;

        _hr = pResourceType->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CClusResTypes::FindItem( pResourceType )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::RemoveAt
//
//  Description:
//      Remove the object (ResType) at the passed in index/position from the
//      collection.
//
//  Arguments:
//      nPos    [IN]    - Index of the object to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG is the index is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::RemoveAt( IN size_t pos )
{
    CComObject<CClusResType> *  pResourceType = NULL;
    ResourceTypeList::iterator          first = m_ResourceTypes.begin();
    ResourceTypeList::iterator          last    = m_ResourceTypes.end();
    HRESULT                          _hr = E_INVALIDARG;

    for ( size_t t = 0; ( t < pos ) && ( first != last ); t++, first++ );

    if ( first != last )
    {
        pResourceType = *first;
        if ( pResourceType )
        {
            pResourceType->Release();
        }

        m_ResourceTypes.erase( first );
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResTypes::RemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_ResourceTypes.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusResTypes::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::get_Item
//
//  Description:
//      Returns the object (Group) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Hold the index.  This is a one based number, or
//                              a string that is the name of the group to get.
//      ppResourceType  [OUT]   - Catches the resource type object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResType **    ppResourceType
    )
{
    //ASSERT( ppResourceType != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResourceType != NULL )
    {
        CComObject<CClusResType> *  pResourceType = NULL;
        UINT                                nIndex = 0;

        *ppResourceType = NULL;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pResourceType = m_ResourceTypes[ nIndex ];
            _hr = pResourceType->QueryInterface( IID_ISClusResType, (void **) ppResourceType );
        }
    }

    return _hr;

} //*** CClusResTypes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceTypeList, CComObject< CClusResType > >( ppunk, m_ResourceTypes );

} //*** CClusResTypes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::CreateItem
//
//  Description:
//      Create a new object (ResType) and add it to the collection.
//
//  Arguments:
//      bstrResourceGroupName   [IN]    - The name of the new group.
//      ppResourceGroup         [OUT]   - Catches the new object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::CreateItem(
    BSTR                bstrResTypeName,
    BSTR                bstrDisplayName,
    BSTR                bstrResTypeDll,
    long                nLooksAliveInterval,
    long                nIsAliveInterval,
    ISClusResType **    ppResourceType
    )
{
    //ASSERT( bstrResTypeName != NULL );
    //ASSERT( bstrDisplayName != NULL );
    //ASSERT( bstrResTypeDll != NULL );
    //ASSERT( ppResourceType != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrResTypeName  != NULL )    &&
         ( bstrDisplayName != NULL )        &&
         ( bstrResTypeDll != NULL ) &&
         ( ppResourceType != NULL ) )
    {
        UINT nIndex;

        *ppResourceType = NULL;

        _hr = FindItem( bstrResTypeName, &nIndex );
        if ( FAILED( _hr ) )
        {
            CComObject<CClusResType> * pClusterResourceType = NULL;

            _hr = CComObject< CClusResType >::CreateInstance( &pClusterResourceType );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >                        ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResType > > ptrResourceType( pClusterResourceType );

                _hr = ptrResourceType->Create( ptrRefObject, bstrResTypeName, bstrDisplayName, bstrResTypeDll, nLooksAliveInterval, nIsAliveInterval );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrResourceType->QueryInterface( IID_ISClusResType,   (void **) ppResourceType );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrResourceType->AddRef();
                        m_ResourceTypes.insert( m_ResourceTypes.end(), ptrResourceType  );
                    }
                }
            }
        }
        else
        {
            CComObject<CClusResType> * pClusterResourceType = NULL;

            pClusterResourceType = m_ResourceTypes[ nIndex ];
            _hr = pClusterResourceType->QueryInterface( IID_ISClusResType,   (void **) ppResourceType );
        }
    }

    return _hr;

} //*** CClusResTypes::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::DeleteItem
//
//  Description:
//      Deletes the object (ResType) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - The index of the object to delete.
//
//  Return Value:
//      S_OK if successful, E_INVALIDARG, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::DeleteItem( VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    UINT    nIndex = 0;

    _hr = GetIndex( varIndex, &nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        ISClusResType    * pResourceType = (ISClusResType *) m_ResourceTypes[ nIndex ];

        // delete the resource type
        _hr = pResourceType->Delete();
        if ( SUCCEEDED( _hr ) )
        {
            RemoveAt( nIndex );
        } // if: the restype was deleted from the cluster
    } // if: we have a valid index

    return _hr;

} //*** CClusResTypes::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypes::Refresh
//
//  Description:
//      Load the collection from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::Refresh( void )
{
    HCLUSTER    hCluster = NULL;
    HRESULT     _hr;

    ASSERT( m_pClusRefObject != NULL );

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        HCLUSENUM   hEnum = NULL;
        DWORD       _sc = ERROR_SUCCESS;

        hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESTYPE );
        if ( hEnum != NULL )
        {
            int                             _nIndex = 0;
            DWORD                           dwType = 0;
            LPWSTR                          pwszName = NULL;
            CComObject< CClusResType > *    pClusterResourceType = NULL;

            Clear();

            for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pwszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusResType >::CreateInstance( &pClusterResourceType );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResType > > ptrType( pClusterResourceType );
                        BSTR                                    bstr = NULL;

                        bstr = SysAllocString( pwszName );
                        if ( bstr == NULL )
                        {
                            _hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            _hr = ptrType->Open( ptrRefObject, bstr );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrType->AddRef();
                                m_ResourceTypes.insert( m_ResourceTypes.end(), ptrType  );
                            }
                            else if ( HRESULT_CODE( _hr ) == ERROR_RESOURCE_TYPE_NOT_FOUND )
                            {
                                //
                                //  It is possible for the resource type to have been deleted from the cluster
                                //  in the time between creating the enum and opening the resourcetype .  When
                                //  that happens we need to simply skip that resource type and continue
                                //  enumerating.
                                //

                                _hr = S_FALSE;      // success code to keep us in the loop
                            } // else if: the cluster resource type was not found

                            SysFreeString( bstr );
                        }
                    }

                    ::LocalFree( pwszName );
                    pwszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            } // for:

            ::ClusterCloseEnum( hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResTypes::Refresh()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\cluster.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		Cluster.h
//
//	Description:
//		Definition of the CCluster and CClusRefObject classes.
//
//	Implementation File:
//		Cluster.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSTER_H_
#define _CLUSTER_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CCluster;
class CClusRefObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluster
//
//	Description:
//		Cluster Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISCluster, &IID_ISCluster, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CCluster,&CLSID_Cluster >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CCluster :
	public IDispatchImpl< ISCluster, &IID_ISCluster, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CCluster,&CLSID_Cluster >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >						BaseComClass;
	typedef IDispatchImpl< ISCluster, &IID_ISCluster, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >	BaseDispatchClass;
	typedef CComCoClass< CCluster,&CLSID_Cluster >							BaseCoClass;

public:
	CCluster( void );
	~CCluster( void );

BEGIN_COM_MAP(CCluster)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISCluster)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCluster)
DECLARE_NO_REGISTRY()

private:
	CComBSTR			m_bstrQuorumPath;
	CComBSTR			m_bstrQuorumResourceName;
	long				m_nQuorumLogSize;
	ISClusApplication *	m_pParentApplication;
	ISClusRefObject *	m_pClusRefObject;
	HCLUSTER			m_hCluster;

	CComObject< CClusNodes > *			m_pClusterNodes;
	CComObject< CClusResGroups > *		m_pClusterResourceGroups;
	CComObject< CClusResources > *		m_pClusterResources;
	CComObject< CClusResTypes > *		m_pResourceTypes;
	CComObject< CClusNetworks > *		m_pNetworks;
	CComObject< CClusNetInterfaces > *	m_pNetInterfaces;

	CComObject< CClusProperties > *	 m_pCommonProperties;
	CComObject< CClusProperties > *	 m_pPrivateProperties;
	CComObject< CClusProperties > *	 m_pCommonROProperties;
	CComObject< CClusProperties > *	 m_pPrivateROProperties;

	STDMETHODIMP OpenResource( IN BSTR bstrResourceName, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP HrGetQuorumInfo( void );

	void Clear( void );

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	STDMETHODIMP Create( IN CClusApplication * pParentApplication );

	STDMETHODIMP Close( void );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP Open( IN BSTR bstrClusterName );

	STDMETHODIMP put_Name( IN BSTR bstrClusterName );

	STDMETHODIMP get_Name( IN BSTR * pbstrClusterName );

	STDMETHODIMP get_Version( OUT ISClusVersion ** ppClusVersion );

	STDMETHODIMP put_QuorumResource( IN ISClusResource * pResource );

	STDMETHODIMP get_QuorumResource( OUT ISClusResource ** ppResource );

	STDMETHODIMP get_Nodes( OUT ISClusNodes ** ppClusterNodes );

	STDMETHODIMP get_ResourceGroups( OUT ISClusResGroups ** ppClusterResourceGroups );

	STDMETHODIMP get_Resources( OUT ISClusResources ** ppClusterResources );

	STDMETHODIMP get_ResourceTypes( OUT ISClusResTypes ** ppResourceTypes );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_QuorumLogSize( OUT long * pnQuoromLogSize );

	STDMETHODIMP put_QuorumLogSize( IN long nQuoromLogSize );

	STDMETHODIMP get_QuorumPath( OUT BSTR * ppPath );

	STDMETHODIMP put_QuorumPath( IN BSTR pPath );

	STDMETHODIMP get_Networks( OUT ISClusNetworks ** ppNetworks );

	STDMETHODIMP get_NetInterfaces( OUT ISClusNetInterfaces ** ppNetInterfaces );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

//	STDMETHODIMP get_Parent( IDispatch ** ppParent );

//	STDMETHODIMP get_Application( ISClusApplication ** ppParentApplication );

	const ISClusRefObject * ClusRefObject( void ) const { return m_pClusRefObject; };

	void ClusRefObject( IN ISClusRefObject * pClusRefObject );

	void Hcluster( IN HCLUSTER hCluster );

	const HCLUSTER Hcluster( void ) const { return m_hCluster; };

}; //*** CCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusRefObject
//
//	Description:
//		Automation Class that wraps the Cluster handle.
//
//	Inheritance:
//		IDispatchImpl< ISClusRefObject, &IID_ISClusRefObject, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusRefObject, &CLSID_ClusRefObject >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusRefObject :
	public IDispatchImpl< ISClusRefObject, &IID_ISClusRefObject, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusRefObject, &CLSID_ClusRefObject >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusRefObject( void );
	~CClusRefObject( void );

BEGIN_COM_MAP(CClusRefObject)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusRefObject)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusRefObject)
DECLARE_NO_REGISTRY()

	HRESULT SetClusHandle( IN HCLUSTER hCluster ) { m_hCluster = hCluster; return S_OK;};

private:
	HCLUSTER m_hCluster;

public:
	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

}; //*** Class CClusRefObject

#endif // _CLUSTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\cluster.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      Cluster.cpp
//
//  Description:
//      Implementation of the cluster and application classes and other
//      support classes for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "ClusRes.h"
#include "ClusNeti.h"
#include "ClusResg.h"
#include "ClusRest.h"
#include "ClusNode.h"
#include "ClusNetw.h"
#include "ClusApp.h"
#include "version.h"
#include "cluster.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusRefObject[] =
{
    &IID_ISClusRefObject
};

static const IID *  iidCCluster[] =
{
    &IID_ISCluster
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusRefObject class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusRefObject::CClusRefObject
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusRefObject::CClusRefObject( void )
{
    m_hCluster  = NULL;
    m_piids     = (const IID *) iidCClusRefObject;
    m_piidsSize = ARRAYSIZE( iidCClusRefObject );

} //*** CClusRefObject::CClusRefObject( void )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusRefObject::~CClusRefObject
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusRefObject::~CClusRefObject( void )
{
    if ( m_hCluster != NULL )
    {
        ::CloseCluster( m_hCluster );
        m_hCluster = NULL;
    }

} //*** CClusRefObject::~CClusRefObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ClusRefObject
//
//  Description:
//      Copy constructor -- sort of.
//
//  Arguments:
//      pClusRefObject  [IN]    - Cluster handle wrapper to hold copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ClusRefObject( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    if ( pClusRefObject != NULL )
    {
        if ( m_pClusRefObject != NULL )
        {
            m_pClusRefObject->Release();
            m_pClusRefObject = NULL;
        } // if:

        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
    } // if: args are not NULL

} //*** CCluster::ClusRefObject( pClusRefObject )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Hcluster
//
//  Description:
//      Changes the raw cluster handle that this class holds onto.
//
//  Arguments:
//      hCluster    [IN]    - The new cluster handle.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Hcluster( IN HCLUSTER hCluster )
{
    ASSERT( hCluster != NULL );

    if ( hCluster != NULL )
    {
        if ( m_hCluster != NULL )
        {
            ::CloseCluster( m_hCluster );
            m_hCluster = NULL;
        } // if:

        m_hCluster = hCluster;
    } // if:

} //*** CCluster::Hcluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusRefObject::get_Handle
//
//  Description:
//      Returns the raw cluster handle.
//
//  Arguments:
//      phandle [OUT]   - Catches the cluster handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusRefObject::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            *phandle = (ULONG_PTR) m_hCluster;
            _hr = S_OK;
        } // if: cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CClusRefObject::get_Handle()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CCluster class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CCluster
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::CCluster( void )
{
    // Initializing all data members.
    m_hCluster                  = NULL;
    m_pClusterNodes             = NULL;
    m_pClusterResourceGroups    = NULL;
    m_pClusterResources         = NULL;
    m_pResourceTypes            = NULL;
    m_pNetworks                 = NULL;
    m_pNetInterfaces            = NULL;
    m_pClusRefObject            = NULL;
    m_nQuorumLogSize            = -1;

    m_pCommonProperties         = NULL;
    m_pPrivateProperties        = NULL;
    m_pCommonROProperties       = NULL;
    m_pPrivateROProperties      = NULL;
    m_pParentApplication        = NULL;
    m_piids                  = (const IID *) iidCCluster;
    m_piidsSize              = ARRAYSIZE( iidCCluster );

} //*** CCluster::CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::~CCluster
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::~CCluster( void )
{
    Clear();

} //*** CCluster::~CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Clear
//
//  Description:
//      Clean out all of the collections we are hanging onto.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Clear( void )
{
    if ( m_pParentApplication != NULL )
    {
        m_pParentApplication->Release();
        m_pParentApplication = NULL;
    }

    if ( m_pClusterNodes != NULL )
    {
        m_pClusterNodes->Release();
        m_pClusterNodes = NULL;
    }

    if ( m_pClusterResourceGroups != NULL )
    {
        m_pClusterResourceGroups->Release();
        m_pClusterResourceGroups = NULL;
    }

    if ( m_pClusterResources != NULL )
    {
        m_pClusterResources->Release();
        m_pClusterResources = NULL;
    }

    if ( m_pResourceTypes != NULL )
    {
        m_pResourceTypes->Release();
        m_pResourceTypes = NULL;
    }

    if ( m_pNetworks != NULL )
    {
        m_pNetworks->Release();
        m_pNetworks = NULL;
    }

    if ( m_pNetInterfaces != NULL )
    {
        m_pNetInterfaces->Release();
        m_pNetInterfaces = NULL;
    }

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

    m_hCluster = NULL;

} //*** CCluster::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Create
//
//  Description:
//      Complete heavy weight construction.
//
//  Arguments:
//      pParentApplication  [IN]    - The parent ClusApplication object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::Create( IN CClusApplication * pParentApplication )
{
    //ASSERT( pParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( pParentApplication != NULL )
    {
        _hr = pParentApplication->_InternalQueryInterface( IID_ISClusApplication, (void **) &m_pParentApplication );
    } // if: args are not NULL

    return _hr;

} //*** CCluster::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Open
//
//  Description:
//      Open the cluster whose name is in bstrClusterName.
//
//  Arguments:
//      bstrCluserName  [IN]    - Cluster name.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if the cluster is already open.
//      Win32 errors passed back as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::Open( IN BSTR bstrClusterName )
{
    //ASSERT( bstrClusterName != NULL );
    //ASSERT( m_hCluster == NULL );

    HRESULT  _hr = E_POINTER;

    if ( bstrClusterName != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster == NULL )
        {
            _hr = S_OK;

            m_hCluster = ::OpenCluster( bstrClusterName );
            if ( m_hCluster == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            } // if: was the cluster opened?
            else
            {
                CComObject< CClusRefObject > *  pCClusRefObject = NULL;

                _hr = CComObject< CClusRefObject >::CreateInstance( &pCClusRefObject );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< CComObject< CClusRefObject > >   ptrRefObject( pCClusRefObject );

                    ptrRefObject->SetClusHandle( m_hCluster );

                    _hr = pCClusRefObject->QueryInterface( IID_ISClusRefObject, (void **) &m_pClusRefObject );
                } // if: CreateInstance OK.
            } // else: the cluster was opened
        } // if: is there already a cluster open?
    } // if: bstrClusterName != NULL

    return _hr;

} //*** CCluster::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Handle
//
//  Description:
//      Return the cluster handle.
//
//  Arguments:
//      phandle [OUT]   - Catches the cluster handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            *phandle = (ULONG_PTR) m_hCluster;
            _hr = S_OK;
        } // if: cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CCluster::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Close
//
//  Description:
//      Close the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::Close( void )
{
    if ( m_hCluster != NULL )
    {
        //
        // If the Cluster Handle will be closed only when the
        // reference count on the RefObj becomes 0. But the
        // Cluster Object will be initialized and is reusable.
        //
        Clear();
    }

    return S_OK;

} //*** CCluster::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_Name
//
//  Description:
//      Change the name of this object (Cluster).
//
//  Arguments:
//      bstrClusterName [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_Name( IN BSTR bstrClusterName )
{
    //ASSERT( bstrClusterName != NULL );
    //ASSERT( pvarStatusCode != NULL );
    //ASSERT( bstrClusterName[ 0 ] != '\0' );
    ASSERT( m_hCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrClusterName != NULL ) && ( bstrClusterName[ 0 ] != '\0' ) )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            DWORD   _sc = ::SetClusterName( m_hCluster, bstrClusterName );

            //
            // Convert status, it's not an error, into error success since we
            // don't want an exception to be thrown when the client is a scripting
            // client.
            //
            if ( _sc == ERROR_RESOURCE_PROPERTIES_STORED )
            {
                _sc = ERROR_SUCCESS;
            }

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    } // if: args are not NULL and the new name is not empty

    return _hr;

} //*** CCluster::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Name
//
//  Description:
//      Return the name of this object (Cluster).
//
//  Arguments:
//      pbstrClusterName    [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Name( OUT BSTR * pbstrClusterName )
{
    //ASSERT( pbstrClusterName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrClusterName != NULL )
    {
        if ( m_hCluster != NULL )
        {
            CLUSTERVERSIONINFO  clusinfo;
            LPWSTR              pwszName = NULL;
            DWORD               _sc;

            clusinfo.dwVersionInfoSize = sizeof( clusinfo );

            _sc = WrapGetClusterInformation( m_hCluster, &pwszName, &clusinfo );
            if ( _sc == ERROR_SUCCESS )
            {
                *pbstrClusterName = SysAllocString( pwszName );
                if ( *pbstrClusterName == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                ::LocalFree( pwszName );
                pwszName = NULL;
            }

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CCluster::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Version
//
//  Description:
//      Return the version info for this cluster.
//
//  Arguments:
//      ppClusVersion   [OUT]   - Catches the ClusVersion object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Version( OUT ISClusVersion ** ppClusVersion )
{
    //ASSERT( ppClusVersion != NULL );
    ASSERT( m_hCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusVersion != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            CComObject< CClusVersion > *    pClusVersion = NULL;

            *ppClusVersion = NULL;

            _hr = CComObject< CClusVersion >::CreateInstance( &pClusVersion );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusVersion > > ptrClusVersion( pClusVersion );

                _hr = ptrClusVersion->Create( ptrRefObject );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusVersion->QueryInterface( IID_ISClusVersion, (void **) ppClusVersion );
                } // if: ClusVersion object created
            } // if: ClusVersion object allocated
        } // if: cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CCluster::GetVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_QuorumResource
//
//  Description:
//      Change the quorum resource.
//
//  Arguments:
//      pResource   [IN]    - The new quorum resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_QuorumResource( IN ISClusResource * pResource )
{
    //ASSERT( pResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( pResource != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = pResource->BecomeQuorumResource( m_bstrQuorumPath, m_nQuorumLogSize );
        } // if: the cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CCluster::put_QuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_QuorumResource
//
//  Description:
//      Returns the quorum resource.
//
//  Arguments:
//      ppResource  [IN]    - Catches the quorum resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_QuorumResource( ISClusResource ** ppResource )
{
    //ASSERT( ppResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResource != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            LPWSTR  lpszResourceName = NULL;
            LPWSTR  lpszDeviceName = NULL;
            DWORD   dwLogSize = 0;
            DWORD   _sc;

            _sc = ::WrapGetClusterQuorumResource( m_hCluster, &lpszResourceName, &lpszDeviceName, &dwLogSize );
            if ( _sc == ERROR_SUCCESS )
            {
                BSTR bstr = NULL;

                bstr = SysAllocString( lpszResourceName );
                if ( bstr == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                else
                {
                    _hr = OpenResource( bstr, ppResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( lpszResourceName != NULL )
                        {
                            ::LocalFree( lpszResourceName );
                        }

                        if ( lpszDeviceName != NULL )
                        {
                            m_bstrQuorumPath = lpszDeviceName;
                            ::LocalFree( lpszDeviceName );
                        }

                        m_nQuorumLogSize = dwLogSize;
                    }
                    SysFreeString( bstr );
                } // else:
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }
    }

    return _hr;

} //*** CCluster::get_QuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::HrGetQuorumInfo
//
//  Description:
//      Retrieves the current quorum info and stores it in member vars.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::HrGetQuorumInfo( void )
{
    LPWSTR  lpszResourceName = NULL;
    LPWSTR  lpszDeviceName = NULL;
    DWORD   dwLogSize = 0;
    DWORD   _sc = NO_ERROR;
    HRESULT _hr = E_HANDLE;

    if ( m_hCluster != NULL )
    {
        _sc = ::WrapGetClusterQuorumResource( m_hCluster, &lpszResourceName, &lpszDeviceName, &dwLogSize );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            if ( lpszResourceName != NULL )
            {
                m_bstrQuorumResourceName = lpszResourceName;
                ::LocalFree( lpszResourceName );
            }

            if ( lpszDeviceName != NULL )
            {
                m_bstrQuorumPath = lpszDeviceName;
                ::LocalFree( lpszDeviceName );
            }

            m_nQuorumLogSize = dwLogSize;
        } // if: WrapGetClusterQuorumResource() succeeded
    } // if: cluster handle is not NULL

    return _hr;

} //*** CCluster::HrGetQuorumInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_QuorumLogSize
//
//  Description:
//      Returns the current quorum log size.
//
//  Arguments:
//      pnQuorumLogSize [OUT]   - Catches the log file size.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_QuorumLogSize( OUT long * pnQuorumLogSize )
{
    //ASSERT( pnQuorumLogSize != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnQuorumLogSize != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                *pnQuorumLogSize = m_nQuorumLogSize;
            }
        }
    }

    return _hr;

} //*** CCluster::get_QuorumLogSize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_QuorumLogSize
//
//  Description:
//      Set the current quorum log size.
//
//  Arguments:
//      nQuorumLogSize  [IN]    - The new log file size.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_QuorumLogSize( IN long nQuoromLogSize )
{
    //ASSERT( nQuoromLogSize > 0 );

    HRESULT _hr = E_INVALIDARG;

    if ( nQuoromLogSize > 0 )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                DWORD       _sc = NO_ERROR;
                HRESOURCE   hResource = NULL;

                hResource = ::OpenClusterResource( m_hCluster,  m_bstrQuorumResourceName );
                if ( hResource != NULL )
                {
                    m_nQuorumLogSize = nQuoromLogSize;

                    _sc = ::SetClusterQuorumResource( hResource, m_bstrQuorumPath, m_nQuorumLogSize );

                    _hr = HRESULT_FROM_WIN32( _sc );
                    ::CloseClusterResource( hResource );
                }
                else
                {
                    _sc = GetLastError();
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }
        }
    }

    return _hr;

} //*** CCluster::put_QuorumLogSize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_QuorumPath
//
//  Description:
//      Returns the current quorum log path.
//
//  Arguments:
//      ppPath  [OUT]   - Catches the device path.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_QuorumPath( OUT BSTR * ppPath )
{
    //ASSERT( ppPath != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppPath != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                *ppPath = m_bstrQuorumPath.Copy();
            }
        }
    }

    return _hr;

} //*** CCluster::get_QuorumPath()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_QuorumPath
//
//  Description:
//      Change the current quorum log path.
//
//  Arguments:
//      pPath   [IN]    - The new device path.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_QuorumPath( IN BSTR pPath )
{
    //ASSERT( pPath != NULL );

    HRESULT _hr = E_POINTER;

    if ( pPath != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                DWORD       _sc = NO_ERROR;
                HRESOURCE   hResource = NULL;

                hResource = ::OpenClusterResource( m_hCluster,  m_bstrQuorumResourceName );
                if ( hResource != NULL )
                {
                    m_bstrQuorumPath = pPath;

                    _sc = ::SetClusterQuorumResource( hResource, m_bstrQuorumPath, m_nQuorumLogSize );

                    _hr = HRESULT_FROM_WIN32( _sc );
                    ::CloseClusterResource( hResource );
                }
                else
                {
                    _sc = GetLastError();
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }
        }
    }

    return _hr;

} //*** CCluster::put_QuorumPath()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Nodes
//
//  Description:
//      Returns the collection of nodes for this cluster.
//
//  Arguments:
//      ppClusterNodes  [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Nodes( OUT ISClusNodes ** ppClusterNodes )
{
    return ::HrCreateResourceCollection< CClusNodes, ISClusNodes, HNODE >(
                        ppClusterNodes,
                        IID_ISClusNodes,
                        m_pClusRefObject
                        );

} //*** CCluster::get_Nodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_ResourceGroups
//
//  Description:
//      Returns the collection of resource groups for this cluster.
//
//  Arguments:
//      ppClusterResourceGroups [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_ResourceGroups(
    OUT ISClusResGroups ** ppClusterResourceGroups
    )
{
    return ::HrCreateResourceCollection< CClusResGroups, ISClusResGroups,  HRESOURCE >(
                        ppClusterResourceGroups,
                        IID_ISClusResGroups,
                        m_pClusRefObject
                        );

} //*** CCluster::get_ResourceGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Resources
//
//  Description:
//      Returns the collection of resources for this cluster.
//
//  Arguments:
//      ppClusterResources  [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Resources(
    OUT ISClusResources ** ppClusterResources
    )
{
    return ::HrCreateResourceCollection< CClusResources, ISClusResources, HRESOURCE >(
                        &m_pClusterResources,
                        ppClusterResources,
                        IID_ISClusResources,
                        m_pClusRefObject
                        );

} //*** CCluster::get_Resources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::OpenResource
//
//  Description:
//      Create and open a new resource.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to open.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::OpenResource(
    IN  BSTR                bstrResourceName,
    OUT ISClusResource **   ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( ppClusterResource != NULL );
    ASSERT( m_hCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrResourceName != NULL ) && ( ppClusterResource != NULL ) )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            CComObject< CClusResource > * pClusterResource = NULL;

            *ppClusterResource  = NULL;

            _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResource > >    ptrClusterResource( pClusterResource );

                _hr = ptrClusterResource->Open( ptrRefObject, bstrResourceName );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                }
            }
        }
    }

    return _hr;

} //*** CCluster::OpenResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_ResourceTypes
//
//  Description:
//      Returns the collection of resource types for this cluster.
//
//  Arguments:
//      ppResourceTypes [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_ResourceTypes(
    OUT ISClusResTypes ** ppResourceTypes
    )
{
    return ::HrCreateResourceCollection< CClusResTypes, ISClusResTypes, CComBSTR >(
                        &m_pResourceTypes,
                        ppResourceTypes,
                        IID_ISClusResTypes,
                        m_pClusRefObject
                        );

} //*** CCluster::get_ResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Networks
//
//  Description:
//      Returns the collection of networks for this cluster.
//
//  Arguments:
//      ppNetworks  [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Networks( OUT ISClusNetworks ** ppNetworks )
{
    return ::HrCreateResourceCollection< CClusNetworks, ISClusNetworks, HNETWORK >(
                        &m_pNetworks,
                        ppNetworks,
                        IID_ISClusNetworks,
                        m_pClusRefObject
                        );

} //*** CCluster::get_Networks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_NetInterfaces
//
//  Description:
//      Returns the collection of netinterfaces for this cluster.
//
//  Arguments:
//      ppNetInterfaces [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_NetInterfaces(
    OUT ISClusNetInterfaces ** ppNetInterfaces
    )
{
    return ::HrCreateResourceCollection< CClusNetInterfaces, ISClusNetInterfaces, HNETINTERFACE >(
                        &m_pNetInterfaces,
                        ppNetInterfaces,
                        IID_ISClusNetInterfaces,
                        m_pClusRefObject
                        );

} //*** CCluster::get_NetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Cluster).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CCluster::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        *ppProperties = NULL;

        CComObject< CClusProperties > * pProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CCluster::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CCluster::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = E_INVALIDARG;

#if CLUSAPI_VERSION >= 0x0500

    DWORD   _dwControlCode  = 0;
    DWORD   _sc             = NO_ERROR;

    _hr = E_HANDLE;
    if ( m_hCluster != NULL )
    {
        if ( bReadOnly )
        {
            _dwControlCode = bPrivate
                            ? CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES
                            : CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES;
        }
        else
        {
            _dwControlCode = bPrivate
                            ? CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES
                            : CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;
        }

        _sc = rcplPropList.ScGetClusterProperties( m_hCluster, _dwControlCode );

        _hr = HRESULT_FROM_WIN32( _sc );
    } // if: cluster handle is not NULL

#else

    _hr = E_NOTIMPL;

#endif // CLUSAPI_VERSION >= 0x0500

    return _hr;

} //*** CCluster::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CCluster::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    //ASSERT( bPrivate == FALSE );

    DWORD   _sc = ERROR_INVALID_HANDLE;

#if CLUSAPI_VERSION >= 0x0500

    if ( m_hCluster != NULL )
    {
        DWORD   nBytesReturned  = 0;
        DWORD   _dwControlCode  = bPrivate
                                  ? CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES
                                  : CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES;

        _sc = ClusterControl(
                            m_hCluster,
                            NULL,
                            _dwControlCode,
                            rcplPropList,
                            rcplPropList.CbBufferSize(),
                            0,
                            0,
                            &nBytesReturned
                            );
    } // if: cluster handle is not NULL

#else

    _sc = ERROR_CALL_NOT_IMPLEMENTED;

#endif // CLUSAPI_VERSION >= 0x0500

    return _sc;

} //*** CCluster::ScWriteProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_CommonProperties
//
//  Description:
//      Get this object's (Cluster) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties != NULL )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CCluster::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_PrivateProperties
//
//  Description:
//      Get this object's (Cluster) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties != NULL )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CCluster::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_CommonROProperties
//
//  Description:
//      Get this object's (Cluster) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties != NULL )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CCluster::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_PrivateROProperties
//
//  Description:
//      Get this object's (Cluster) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties != NULL )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CCluster::get_PrivateROProperties()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Parent
//
//  Description:
//      Returns the parent of the cluster object.  This is an automation
//      thing and the parent could be NULL.
//
//  Arguments:
//      ppParent    [OUT]   - Catches the parent.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Parent( OUT IDispatch ** ppParent )
{
    //ASSERT( ppParent != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParent != NULL )
    {
        if ( m_pParentApplication != NULL )
        {
            _hr = m_pParentApplication->QueryInterface( IID_IDispatch, (void **) ppParent );
        }
        else
        {
            _hr = _InternalQueryInterface( IID_IDispatch, (void **) ppParent );
        }
    }

    return _hr;

} //*** CCluster::get_Parent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Application
//
//  Description:
//      Get the parent application for this cluster object.  This is an
//      automation thing and it could be NULL.
//
//  Arguments:
//      ppParentApplication [OUT]   - Catches the parent app object.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Application(
    OUT ISClusApplication ** ppParentApplication
    )
{
    //ASSERT( ppParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParentApplication != NULL )
    {
        if ( m_pParentApplication != NULL )
        {
            _hr = m_pParentApplication->QueryInterface( IID_IDispatch, (void **) ppParentApplication );
        }
    }

    return _hr;

} //*** CCluster::get_Application()
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\msclus.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  Module Name:
//      MSClus.cpp
//
//  Description:
//      Implementation of the DLL Exports for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <ShlWapi.h>
#include <atlimpl.cpp>
#include <initguid.h>
#include <ClusRtl.h>
#include "ClusterObject.h"
#include "property.h"
#include "ClusNeti.h"
#include "ClusNetw.h"
#include "ClusRes.h"
#include "ClusRest.h"
#include "ClusResg.h"
#include "ClusNode.h"
#include "Version.h"
#include "ClusApp.h"
#include "Cluster.h"

#define IID_DEFINED
#include "msclus_i.c"
#undef IID_DEFINED

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ClusApplication, CClusApplication)
    OBJECT_ENTRY(CLSID_Cluster, CCluster)
    OBJECT_ENTRY(CLSID_ClusVersion, CClusVersion)
    OBJECT_ENTRY(CLSID_DomainNames, CDomainNames)
    OBJECT_ENTRY(CLSID_ClusResGroupPreferredOwnerNodes, CClusResGroupPreferredOwnerNodes)
    OBJECT_ENTRY(CLSID_ClusterNames, CClusterNames)
    OBJECT_ENTRY(CLSID_ClusNetInterface, CClusNetInterface)
    OBJECT_ENTRY(CLSID_ClusNetInterfaces, CClusNetInterfaces)
    OBJECT_ENTRY(CLSID_ClusNetwork, CClusNetwork)
    OBJECT_ENTRY(CLSID_ClusNetworks, CClusNetworks)
    OBJECT_ENTRY(CLSID_ClusNetworkNetInterfaces, CClusNetworkNetInterfaces)
    OBJECT_ENTRY(CLSID_ClusNode, CClusNode)
    OBJECT_ENTRY(CLSID_ClusNodes, CClusNodes)
    OBJECT_ENTRY(CLSID_ClusNodeNetInterfaces, CClusNodeNetInterfaces)
    OBJECT_ENTRY(CLSID_ClusProperty, CClusProperty)
    OBJECT_ENTRY(CLSID_ClusProperties, CClusProperties)
    OBJECT_ENTRY(CLSID_ClusRefObject, CClusRefObject)
    OBJECT_ENTRY(CLSID_ClusResDependencies, CClusResDependencies)
//    OBJECT_ENTRY(CLSID_CClusResDependents , CClusResDependents )
    OBJECT_ENTRY(CLSID_ClusResGroup, CClusResGroup)
    OBJECT_ENTRY(CLSID_ClusResGroups, CClusResGroups)
    OBJECT_ENTRY(CLSID_ClusResource, CClusResource)
    OBJECT_ENTRY(CLSID_ClusResources, CClusResources)
    OBJECT_ENTRY(CLSID_ClusResPossibleOwnerNodes, CClusResPossibleOwnerNodes)
    OBJECT_ENTRY(CLSID_ClusResType, CClusResType)
    OBJECT_ENTRY(CLSID_ClusResTypes, CClusResTypes)
    OBJECT_ENTRY(CLSID_ClusResTypeResources, CClusResTypeResources)
    OBJECT_ENTRY(CLSID_ClusResGroupResources, CClusResGroupResources)
#if CLUSAPI_VERSION >= 0x0500
    OBJECT_ENTRY(CLSID_ClusResTypePossibleOwnerNodes, CClusResTypePossibleOwnerNodes)
#endif // CLUSAPI_VERSION >= 0x0500
    OBJECT_ENTRY(CLSID_ClusPropertyValue, CClusPropertyValue)
    OBJECT_ENTRY(CLSID_ClusPropertyValues, CClusPropertyValues)
    OBJECT_ENTRY(CLSID_ClusPropertyValueData, CClusPropertyValueData)
    OBJECT_ENTRY(CLSID_ClusPartition, CClusPartition)
    OBJECT_ENTRY(CLSID_ClusPartitions, CClusPartitions)
    OBJECT_ENTRY(CLSID_ClusDisk, CClusDisk)
    OBJECT_ENTRY(CLSID_ClusDisks, CClusDisks)
    OBJECT_ENTRY(CLSID_ClusScsiAddress, CClusScsiAddress)
    OBJECT_ENTRY(CLSID_ClusRegistryKeys, CClusResourceRegistryKeys)
#if CLUSAPI_VERSION >= 0x0500
    OBJECT_ENTRY(CLSID_ClusCryptoKeys, CClusResourceCryptoKeys)
#endif // CLUSAPI_VERSION >= 0x0500
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Forward function declarations
/////////////////////////////////////////////////////////////////////////////
static  void    RegisterRegistryCleanUp( void );
static  void    UnregisterRegistryCleanUp( void );

static  const   LPWSTR  g_ptszRegisterRegistryNodesToDelete[] =
{
    _T( "software\\classes\\MSCluster.Application" ),
    _T( "software\\classes\\MSCluster.Application.2" ),
    _T( "software\\classes\\MSCluster.Cluster.2" ),
    _T( "software\\classes\\MSCluster.ClusGroupResources" ),
    _T( "software\\classes\\MSCluster.ClusGroupResources.1" ),
    _T( "software\\classes\\MSCluster.ClusGroupOwners" ),
    _T( "software\\classes\\MSCluster.ClusGroupOwners.1" ),
    _T( "software\\classes\\MSCluster.ClusResOwners" ),
    _T( "software\\classes\\MSCluster.ClusResOwners.1" ),
    _T( "software\\classes\\CLSID\\{f2e60717-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60718-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\CLSID\\{f2e60719-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e6071a-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e0-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e1-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e3-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e5-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e7-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e9-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606eb-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606ed-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606ef-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f3-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f5-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f7-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f9-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606fb-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606fd-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606fe-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606ff-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60700-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60702-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60704-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\CLSID\\{f2e606f2-2631-11d1-89f1-00a0c90d061e}" ),
    NULL
};
/*
static  const   LPWSTR  g_ptszUnregisterRegistryNodesToDelete[] =
{
//  _T( "software\\classes\\typelib\\{f2e606e0-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e2-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e4-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e6-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606e8-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606ea-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606ec-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606ee-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f0-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f2-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f4-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f6-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606f8-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606fa-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606fc-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e606fe-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60700-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60702-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60704-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60706-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60708-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e6070a-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e6070c-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e6070e-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60710-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60712-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60714-2631-11d1-89f1-00a0c90d061e}" ),
    _T( "software\\classes\\interface\\{f2e60716-2631-11d1-89f1-00a0c90d061e}" ),
    NULL
};
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//      DLL Entry Point.
//
//  Arguments:
//      hInstance   [IN]    - Out instance handle.
//      dwReason    [IN]    - The reason we are being called.
//      lpReserved  [IN]    - Don't rightly know what this is...
//
//  Return Value:
//      TRUE if successful, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL WINAPI DllMain(
    IN  HINSTANCE   hInstance,
    IN  DWORD       dwReason,
    IN  LPVOID      //lpReserved
    )
{
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
#ifdef _DEBUG
        _CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
        _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
#endif
        _Module.Init( ObjectMap, hInstance );
        DisableThreadLibraryCalls( hInstance );
    }
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        _Module.Term();
    }

    return TRUE;    // ok

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllCanUnloadNow
//
//  Description:
//      Used to determine whether the DLL can be unloaded by OLE.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if we can unload, S_FALSE if we cannot.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
    return ( _Module.GetLockCount() == 0 ) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllGetClassObject
//
//  Description:
//      Retrieves the class object from a DLL object handler or object
//      application. DllGetClassObject is called from within the
//      CoGetClassObject function when the class context is a DLL.
//
//  Arguments:
//      rclsid  [IN]    - CLSID that will associate the correct data and code.
//      riid    [IN]    - Reference to the identifier of the interface that the
//                      caller is to use to communicate with the class object.
//                      Usually, this is IID_IClassFactory (defined in the OLE
//                      headers as the interface identifier for IClassFactory).
//      ppv     [OUT]   - Address of pointer variable that receives the interface
//                      pointer requested in riid. Upon successful return, *ppv
//                      contains the requested interface pointer. If an error
//                      occurs, the interface pointer is NULL.
//
//  Return Value:
//      S_OK if successful, or CLASS_E_CLASSNOTAVAILABLE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(
    IN  REFCLSID    rclsid,
    IN  REFIID      riid,
    OUT LPVOID *    ppv
    )
{
    return _Module.GetClassObject( rclsid, riid, ppv );

} //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterServer
//
//  Description:
//      Add entries to the system registry.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{
    RegisterRegistryCleanUp();

    //
    // Registers object, typelib and all interfaces in typelib
    //
    return _Module.RegisterServer( TRUE );

} //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterServer
//
//  Description:
//      Removes entries from the system registry.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
    HRESULT _hr = S_FALSE;

    UnregisterRegistryCleanUp();

    //
    // Unregisters object, typelib and all interfaces   in typelib
    //
    _hr = _Module.UnregisterServer();
    if ( SUCCEEDED( _hr ) )
    {

#if _WIN32_WINNT >= 0x0400
        _hr = UnRegisterTypeLib( LIBID_MSClusterLib, 1, 0, LOCALE_NEUTRAL, SYS_WIN32 );
#endif

    } //if: server was unregistered

    return _hr;

} //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetCluster
//
//  Description:
//      Common implementation of creating a new cluster object.
//
//  Arguments:
//      ppCluster       [OUT]   - Catches the newly created object.
//      pClusRefObject  [IN]    - Object that wraps the cluster handle.
//
//  Return Value:
//      S_OK for success
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrGetCluster(
    OUT ISCluster **        ppCluster,
    IN  ISClusRefObject *   pClusRefObject
    )
{
    //ASSERT( ppCluster != NULL );
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( ppCluster != NULL ) && ( pClusRefObject != NULL ) )
    {
        HCLUSTER hCluster = NULL;

        _hr = pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            CComObject< CCluster > *    pCluster = NULL;

            _hr = CComObject< CCluster >::CreateInstance( &pCluster );
            if ( SUCCEEDED( _hr ) )
            {
                pCluster->ClusRefObject( pClusRefObject );
                pCluster->Hcluster( hCluster );

                _hr = pCluster->QueryInterface( IID_ISCluster, (void **) ppCluster );
            }
        }
    }

    return _hr;

} //*** HrGetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterRegistryCleanUp
//
//  Description:
//      Clean up the registry during registration
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void RegisterRegistryCleanUp( void )
{
    int nIndex;;

    for ( nIndex = 0; ; nIndex++ )
    {
        if ( g_ptszRegisterRegistryNodesToDelete[ nIndex ] == NULL )
        {
            break;
        } // if:

        SHDeleteKey( HKEY_LOCAL_MACHINE, g_ptszRegisterRegistryNodesToDelete[ nIndex ] );
    } // for:

} //*** RegisterRegistryCleanUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterRegistryCleanUp
//
//  Description:
//      Clean up the registry during unregistration
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void UnregisterRegistryCleanUp( void )
{
    return;

} //*** UnregisterRegistryCleanUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClearIDispatchEnum
//
//  Description:
//      Cleans up an Enum of IDispatch pointers.
//
//  Arguments:
//      ppVarVect   [IN OUT]    - The enum to clean up.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ClearIDispatchEnum(
    IN OUT CComVariant ** ppvarVect
    )
{
    if ( ppvarVect != NULL )
    {
        size_t  cCount = ARRAYSIZE( *ppvarVect );
        size_t  iIndex;

        for ( iIndex = 0; iIndex < cCount; iIndex++ )
        {
            (*ppvarVect[iIndex]).pdispVal->Release();
        } // for:

        delete [] *ppvarVect;
        *ppvarVect = NULL;
    }

} //*** ClearIDispatchEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClearVariantEnum
//
//  Description:
//      Cleans up an Enum of variant values.
//
//  Arguments:
//      ppVarVect   [IN OUT]    - The enum to clean up.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ClearVariantEnum(
    IN OUT CComVariant ** ppvarVect
    )
{
    if ( ppvarVect != NULL )
    {
        delete [] *ppvarVect;
        *ppvarVect = NULL;
    }

} //*** ClearVariantEnum()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\partition.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Partition.h
//
//	Description:
//		Definition of the cluster disk partition class for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		Partition.cpp
//
//	Author:
//		Galen Barbee	(galenb)	10-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PARTITION_H_
#define __PARTITION_H__

#if CLUSAPI_VERSION >= 0x0500
	#include <PropList.h>
#else
	#include "PropList.h"
#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusPartition;
class CClusPartitions;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPartition
//
//	Description:
//		Cluster Partition Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPartition, &IID_ISClusPartition, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPartition, &CLSID_ClusPartition >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPartition :
	public IDispatchImpl< ISClusPartition, &IID_ISClusPartition, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPartition, &CLSID_ClusPartition >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusPartition( void );

BEGIN_COM_MAP(CClusPartition)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPartition)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPartition)
DECLARE_NO_REGISTRY()

private:

	CLUS_PARTITION_INFO	m_cpi;

public:
	HRESULT Create( IN CLUS_PARTITION_INFO * pcpi );

	STDMETHODIMP get_Flags( OUT long * plFlags );

	STDMETHODIMP get_DeviceName( OUT BSTR * pbstrDeviceName );

	STDMETHODIMP get_VolumeLabel( OUT BSTR * pbstrVolumeLabel );

	STDMETHODIMP get_SerialNumber( OUT long * plSerialNumber );

	STDMETHODIMP get_MaximumComponentLength( OUT long * plMaximumComponentLength );

	STDMETHODIMP get_FileSystemFlags( OUT long * plFileSystemFlags );

	STDMETHODIMP get_FileSystem( OUT BSTR * pbstrFileSystem );

}; //*** Class CClusPartition

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPartitions
//
//	Description:
//		Cluster Partition Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPartitions, &IID_ISClusPartitions, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPartitions, &CLSID_ClusPartitions >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPartitions :
	public IDispatchImpl< ISClusPartitions, &IID_ISClusPartitions, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPartitions, &CLSID_ClusPartitions >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusPartitions( void );
	~CClusPartitions( void );

BEGIN_COM_MAP(CClusPartitions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPartitions)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPartitions)
DECLARE_NO_REGISTRY()

	HRESULT HrCreateItem( IN CLUS_PARTITION_INFO * pcpi );

protected:
	typedef std::vector< CComObject< CClusPartition > * >	PartitionVector;

	PartitionVector	m_pvPartitions;

	void	Clear( void );

	HRESULT GetIndex( VARIANT varIndex, UINT *pnIndex );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusPartition ** ppPartition );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

}; //*** Class CClusPartitions

#endif // __PARTITION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\property.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      Property.cpp
//
//  Description:
//      Implementation of the cluster property classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusProperty[] =
{
    &IID_ISClusProperty
};

static const IID *  iidCClusProperties[] =
{
    &IID_ISClusProperties
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusProperty class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::CClusProperty
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperty::CClusProperty( void )
{
    m_dwFlags   = 0;
    m_pValues   = NULL;
    m_piids     = (const IID *) iidCClusProperty;
    m_piidsSize = ARRAYSIZE( iidCClusProperty );

} //*** CClusProperty::CClusProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::~CClusProperty
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperty::~CClusProperty( void )
{
    if ( m_pValues != NULL )
    {
        m_pValues->Release();
    } // if:

} //*** CClusProperty::~CClusProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::HrCoerceVariantType
//
//  Description:
//      Coerce the passed in variant to a type that matches the cluster
//      property type.
//
//  Arguments:
//      cpfFormat   [IN]    - CLUSPROP_FORMAT_xxxx of the property.
//      rvarValue   [IN]    - The variant to coerce.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrCoerceVariantType(
    IN CLUSTER_PROPERTY_FORMAT  cpfFormat,
    IN VARIANT &                rvarValue
    )
{
    HRESULT _hr = S_OK;
    VARIANT _var;

    ::VariantInit( &_var );

    switch ( cpfFormat )
    {
        case CLUSPROP_FORMAT_BINARY:
        {
            if ( ! ( rvarValue.vt & VT_ARRAY ) )
            {
                _hr = E_INVALIDARG;
            } // if:
            break;
        } // case:

#if CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_LONG:
#endif // CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_DWORD:
        {
            _hr = VariantChangeTypeEx( &_var, &rvarValue, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
            break;
        } // case:

        case CLUSPROP_FORMAT_SZ:
        case CLUSPROP_FORMAT_EXPAND_SZ:
        case CLUSPROP_FORMAT_MULTI_SZ:
        {
            _hr = VariantChangeTypeEx( &_var, &rvarValue, LOCALE_SYSTEM_DEFAULT, 0, VT_BSTR );
            break;
        } // case:

        case CLUSPROP_FORMAT_ULARGE_INTEGER:
        {
            _hr = VariantChangeTypeEx( &_var, &rvarValue, LOCALE_SYSTEM_DEFAULT, 0, VT_I8 );
            break;
        } // case:

#if CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_EXPANDED_SZ:
#endif // CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_UNKNOWN:
        default:
        {
            _hr = E_INVALIDARG;
            break;
        } // default:
    } // switch:

    return _hr;

} //*** CClusProperty::HrCoerceVariantType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::HrBinaryCompare
//
//  Description:
//      Compare two SafeArrays and return whether or not they are equal.
//
//  Arguments:
//      rvarOldValue    [IN]    - Old value
//      rvarValue       [IN]    - New value.
//      pbEqual         [OUT]   - Catches the equality state.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrBinaryCompare(
    IN  const CComVariant   rvarOldValue,
    IN  const VARIANT &     rvarValue,
    OUT BOOL *              pbEqual
    )
{
    ASSERT( pbEqual != NULL );

    HRESULT     _hr = S_OK;
    PBYTE       _pbOld = NULL;
    SAFEARRAY * _psaOld = NULL;
    BOOL        _bEqual = FALSE;
    long        _cbNew = 0;
    long        _cbOld = 0;
    SAFEARRAY * _psaNew = NULL;
    PBYTE       _pbNew = NULL;

    _psaOld = rvarOldValue.parray;

    _hr = HrSafeArraySizeof( _psaOld, 1, &_cbOld );
    if ( SUCCEEDED( _hr ) )
    {
        _psaNew = rvarValue.parray;

        _hr = HrSafeArraySizeof( _psaNew, 1, &_cbNew );
        if ( SUCCEEDED( _hr ) )
        {
            if ( _cbNew == _cbOld )
            {
                _hr = ::SafeArrayAccessData( _psaOld, (PVOID *) &_pbOld );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ::SafeArrayAccessData( _psaNew, (PVOID *) &_pbNew );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( _psaOld->cbElements == _psaNew->cbElements )
                        {
                            _bEqual = ( ::memcmp( _pbOld, _pbNew, _cbOld ) == 0 );
                        } // if:

                        _hr = ::SafeArrayUnaccessData( _psaNew );
                    } // if:

                    _hr = ::SafeArrayUnaccessData( _psaOld );
                } // if:
            } // if:
        } // if:
    } // if:

    if ( pbEqual != NULL )
    {
        *pbEqual = _bEqual;
    } // if:

    return _hr;

} //*** CClusProperty::HrBinaryCompare()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::HrConvertVariantTypeToClusterFormat
//
//  Description:
//      Given a variant, pick the best CLUSPROP_FORMAT_xxx.
//
//  Arguments:
//      rvar        [IN]    - variant to check.
//      varType     [IN]    - variant type.
//      pcpfFormat  [OUT]   - catches the cluster property format
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrConvertVariantTypeToClusterFormat(
    IN  const VARIANT &             rvar,
    IN  VARTYPE                     varType,
    OUT CLUSTER_PROPERTY_FORMAT *   pcpfFormat
    )
{
    HRESULT _hr = E_INVALIDARG;

    do
    {
        if ( ( varType & VT_ARRAY ) && ( varType & VT_UI1 ) )
        {
            *pcpfFormat = CLUSPROP_FORMAT_BINARY;
            _hr = S_OK;
            break;
        } // if:

        if ( varType & VT_VECTOR )
        {
            break;
        } // if: Don't know what to do with a vector...

        varType &= ~VT_BYREF;       // mask off the by ref bit if it was set...

        if ( ( varType == VT_I2 ) || ( varType == VT_I4 ) || ( varType == VT_BOOL ) || ( varType == VT_R4 ) )
        {
            *pcpfFormat = CLUSPROP_FORMAT_DWORD;
            _hr = S_OK;
            break;
        } // if:
        else if ( varType == VT_BSTR )
        {
            *pcpfFormat = CLUSPROP_FORMAT_SZ;
            _hr = S_OK;
            break;
        } // else if:
        else if ( ( varType == VT_I8 ) || ( varType == VT_R8 ) )
        {
            *pcpfFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
            _hr = S_OK;
            break;
        } // else if:
        else if ( varType == VT_VARIANT )
        {
            _hr = HrConvertVariantTypeToClusterFormat( *rvar.pvarVal, rvar.pvarVal->vt, pcpfFormat );
            break;
        } // else if:
        else
        {
            break;
        } // else:
    }
    while( TRUE );  // do-while: want to avoid using a goto ;-)

    return _hr;

} //*** CClusProperty::HrConvertVariantTypeToClusterFormat()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::Create
//
//  Description:
//      Finish creating a ClusProperty object.  This is where the real
//      work is done -- not the ctor.
//
//  Arguments:
//      bstrName    [IN]    - The name of the property.
//      varValue    [IN]    - The value of the property.
//      bPrivate    [IN]    - Is it a private property?
//      bReadOnly   [IN]    - Is it a read only property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::Create(
    IN BSTR     bstrName,
    IN VARIANT  varValue,
    IN BOOL     bPrivate,
    IN BOOL     bReadOnly
    )
{
    HRESULT                 _hr = S_OK;
    CLUSTER_PROPERTY_FORMAT _cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

    if ( bPrivate )
    {
        m_dwFlags |= PRIVATE;
    } // if: set the private flag
    else
    {
        m_dwFlags &= ~PRIVATE;
    } // else: clear the private flag

    if ( bReadOnly )
    {
        m_dwFlags |= READONLY;
    } // if: set the read only flag
    else
    {
        m_dwFlags &= ~READONLY;
    } // else: clear the read only flag

    m_bstrName  = bstrName;

    _hr = HrConvertVariantTypeToClusterFormat( varValue, varValue.vt, &_cpfFormat );
    if ( SUCCEEDED( _hr ) )
    {
        _hr = HrCreateValuesCollection( varValue, CLUSPROP_TYPE_LIST_VALUE, _cpfFormat );
    } // if:

    return _hr;

} //*** CClusProperty::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::Create
//
//  Description:
//      Finish creating a ClusProperty object.  This is where the real
//      work is done -- not the ctor.
//
//  Arguments:
//      bstrName    [IN]    - The name of the property.
//      rpvlValue   [IN]    - The value list of the property.
//      bPrivate    [IN]    - Is it a private property?
//      bReadOnly   [IN]    - Is it a read only property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::Create(
    IN BSTR                         bstrName,
    IN const CClusPropValueList &   rpvlValue,
    IN BOOL                         bPrivate,
    IN BOOL                         bReadOnly
    )
{
    if ( bPrivate )
    {
        m_dwFlags |= PRIVATE;
    } // if: set the private flag
    else
    {
        m_dwFlags &= ~PRIVATE;
    } // else: clear the private flag

    if ( bReadOnly )
    {
        m_dwFlags |= READONLY;
    } // if: set the read only flag
    else
    {
        m_dwFlags &= ~READONLY;
    } // else: clear the read only flag

    m_bstrName  = bstrName;

    return HrCreateValuesCollection( rpvlValue );

} //*** CClusProperty::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::HrCreateValuesCollection
//
//  Description:
//      Create the values collection from a value list.
//
//  Arguments:
//      rpvlValue   [IN]    - The value list.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrCreateValuesCollection(
    IN const CClusPropValueList &   rpvlValue
    )
{
    HRESULT _hr = S_FALSE;

    _hr = CComObject< CClusPropertyValues >::CreateInstance( &m_pValues );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject< CClusPropertyValues > >  _ptrValues( m_pValues );

        _hr = _ptrValues->Create( rpvlValue, ( m_dwFlags & READONLY ) );
        if ( SUCCEEDED( _hr ) )
        {
            _ptrValues->AddRef();
        } // if:
    }

    return _hr;

} //*** CClusProperty::HrCreateValuesCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::HrCreateValuesCollection
//
//  Description:
//      Create the values collection from a variant.
//
//  Arguments:
//      varValue    [IN]    - The value.
//      cptType     [IN]    - The cluster property type.
//      cpfFormat   [IN]    - The cluster property format.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrCreateValuesCollection(
    IN VARIANT                  varValue,
    IN CLUSTER_PROPERTY_TYPE    cptType,
    IN CLUSTER_PROPERTY_FORMAT  cpfFormat
    )
{
    HRESULT _hr = S_FALSE;

    _hr = CComObject< CClusPropertyValues >::CreateInstance( &m_pValues );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject< CClusPropertyValues > >  _ptrValues( m_pValues );

        _hr = _ptrValues->Create( varValue, cptType, cpfFormat, ( m_dwFlags & READONLY ) );
        if ( SUCCEEDED( _hr ) )
        {
            _ptrValues->AddRef();
        } // if:
    }

    return _hr;

} //*** CClusProperty::HrCreateValuesCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Name
//
//  Description:
//      Return the name of this property.
//
//  Arguments:
//      pbstrName   [OUT]   - Catches the name of this property.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Name( OUT BSTR * pbstrName )
{
    //ASSERT( pbstrName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrName != NULL )
    {
        *pbstrName = m_bstrName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusProperty::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::put_Name
//
//  Description:
//      Change the name of this property.
//
//  Arguments:
//      bstrName    [IN]    - The new property name.
//
//  Return Value:
//      S_OK if successful, or S_FALSE if the property is read only.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Name( IN BSTR bstrName )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        m_bstrName = bstrName;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusProperty::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Type
//
//  Description:
//      Return the cluster property type for the default value.
//
//  Arguments:
//      pcptType    [OUT]   - Catches the type.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Type( OUT CLUSTER_PROPERTY_TYPE * pcptType )
{
    //ASSERT( pcptType != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcptType != NULL )
    {
        _hr = (*m_pValues)[ 0 ]->get_Type( pcptType );
    } // if: property type return value specified

    return _hr;

} //*** CClusProperty::get_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::put_Type
//
//  Description:
//      Change the cluster property type of the default value.
//
//  Arguments:
//      cptType [IN]    - The new cluster property type.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Type( IN CLUSTER_PROPERTY_TYPE cptType )
{
    return (*m_pValues)[ 0 ]->put_Type( cptType );

} //*** CClusProperty::put_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Format
//
//  Description:
//      Returns the cluster property format for the default value.
//
//  Arguments:
//      pcpfFormat  [OUT]   - Catches the format.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Format(
    OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat
    )
{
    //ASSERT( pcpfFormat != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcpfFormat != NULL )
    {
        _hr = (*m_pValues)[ 0 ]->get_Format( pcpfFormat );
    } // if: property format return value specified

    return _hr;

} //*** CClusProperty::get_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::put_Format
//
//  Description:
//      Change the cluster property format of the default value.
//
//  Arguments:
//      cpfFormat   [IN]    - The new cluster property format.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Format(
    IN CLUSTER_PROPERTY_FORMAT cpfFormat
    )
{
    return (*m_pValues)[ 0 ]->put_Format( cpfFormat );

} //*** CClusProperty::put_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Length
//
//  Description:
//      Returns the length of the default value.
//
//  Arguments:
//      plLenght    [OUT]   - Catches the length.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Length( OUT long * plLength )
{
    return (*m_pValues)[ 0 ]->get_Length( plLength );

} //*** CClusProperty::get_Length()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_ValueCount
//
//  Description:
//      Return the count of ClusPropertyValue object in the ClusPropertyValues
//      collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_ValueCount( OUT long * plCount )
{
    return m_pValues->get_Count( plCount );

} //*** CClusProperty::get_ValueCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Values
//
//  Description:
//      Returns the property values collection.
//
//  Arguments:
//      ppClusterPropertyValues [OUT]   - Catches the values collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Values(
    ISClusPropertyValues ** ppClusterPropertyValues
    )
{
    //ASSERT( ppClusterPropertyValues );

    HRESULT _hr = E_POINTER;

    if ( ppClusterPropertyValues != NULL )
    {
        _hr = m_pValues->QueryInterface( IID_ISClusPropertyValues, (void **) ppClusterPropertyValues );
    }

    return _hr;

} //*** CClusProperty::get_Values()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::Modified
//
//  Description:
//      Sets the modified state of the property.
//
//  Arguments:
//      bModified   [IN]    - The new modfied state.
//
//  Return Value:
//      The old state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusProperty::Modified( IN BOOL bModified )
{
    BOOL _bTemp = ( m_dwFlags & MODIFIED );

    if ( bModified )
    {
        m_dwFlags |= MODIFIED;
    } // if: set the modified flag
    else
    {
        m_dwFlags &= ~MODIFIED;
    } // else: clear the modified flag

    return _bTemp;

} //*** CClusProperty::Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Value
//
//  Description:
//      Get the value of the default value from the values collection.
//
//  Arguments:
//      pvarValue   [OUT]   - Catches the value.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Value( OUT VARIANT * pvarValue )
{
    //ASSERT( pvarValue != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarValue != NULL )
    {
        CComObject< CClusPropertyValue > *  _pPropValue = (*m_pValues)[ 0 ];
        CComVariant                         _varPropValue = _pPropValue->Value();

        _hr = ::VariantCopyInd( pvarValue, &_varPropValue );
    }

    return _hr;

} //*** _CClusProperty::get_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::put_Value
//
//  Description:
//      Change the value of the default value in the values collection.
//
//  Arguments:
//      varValue    [IN]    - The new value.
//
//  Return Value:
//      S_OK if successful, S_FALSE is read only, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Value( IN VARIANT varValue )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        CComObject< CClusPropertyValue > *  _pPropValue = (*m_pValues)[ 0 ];
        CLUSTER_PROPERTY_FORMAT             _cpfFormat = CLUSPROP_FORMAT_UNKNOWN;
        VARIANT                             _var;

        ::VariantInit( &_var );

        //
        //  TODO:   17-JAN-2003 GalenB
        //
        //  I am wondering if I should have simply deref'd the variant
        //  and called this function recursivley?  My fix only works
        //  for one level of indirection...  I didn't think of this
        //  at first and since time is short I don't want to reset
        //  the testing effort.
        //

        //
        //  The variant that we are handed could be a "pointer" to the real
        //  variant.  If thats the case then we need to "deref" the pointer
        //  and use the real variant.
        //
        //  The code below will always make a copy of the variant and use
        //  that copy for all operations.  I chose to make a copy because
        //  I think that is more clear than using a flag and the ternary
        //  operator to control how we use varValue.  Do we simply use it,
        //  or do we "deref" down into the another variant?
        //

        if ( varValue.vt == ( VT_BYREF | VT_VARIANT ) )
        {
            _hr = ::VariantCopy( &_var, varValue.pvarVal );
        } // if: the variant contains a ref to another variant so copy that variant
        else
        {
            _hr = ::VariantCopy( &_var, &varValue );
        } // else: we can copy the variant directly

        if ( SUCCEEDED( _hr ) )
        {
            _hr = _pPropValue->get_Format( &_cpfFormat );
            if ( SUCCEEDED( _hr ) )
            {
                CComVariant _varOldValue = _pPropValue->Value();

                _hr = HrCoerceVariantType( _cpfFormat, _var );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( _cpfFormat == CLUSPROP_FORMAT_BINARY )
                    {
                        BOOL    bEqual = TRUE;

                        _hr = HrBinaryCompare( _varOldValue, _var, &bEqual );
                        if ( ( SUCCEEDED( _hr ) ) && ( ! bEqual ) )
                        {
                            _hr = HrSaveBinaryProperty( _pPropValue, _var );
                            if ( SUCCEEDED( _hr ) )
                            {
                                m_dwFlags |= MODIFIED;
                                m_dwFlags &= ~USEDEFAULT;
                            } // if: the binary value was saved
                        } // if: This is a new value
                    } // if: This is a binary property
                    else
                    {
                        if ( _varOldValue != _var )
                        {
                            _pPropValue->Value( _var );
                            m_dwFlags |= MODIFIED;
                            m_dwFlags &= ~USEDEFAULT;
                        } // if: This is a new value
                    } // else: This is not a binary property
                } // if: HrCoerceVariantType succeeded
            } // if: get_Format succeeded
        } // if: VariantCopy succeeded
    } // if: this property is not read only

    return _hr;

} //*** CClusProperty::put_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_ReadOnly
//
//  Description:
//      Is this property read only?
//
//  Arguments:
//      pvarReadOnly    [OUT]   - catches the property's read only  state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_ReadOnly( OUT VARIANT * pvarReadOnly )
{
    //ASSERT( pvarReadOnly != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarReadOnly != NULL )
    {
        pvarReadOnly->vt = VT_BOOL;

        if ( m_dwFlags & READONLY )
        {
            pvarReadOnly->boolVal = VARIANT_TRUE;
        } // if: if this is a read only property...
        else
        {
            pvarReadOnly->boolVal = VARIANT_FALSE;
        } // else: it is not a read only property...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperty::get_ReadOnly()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Private
//
//  Description:
//      Is this a private property?
//
//  Arguments:
//      pvarPrivate [OUT]   - catches the private property state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Private( OUT VARIANT * pvarPrivate )
{
    //ASSERT( pvarPrivate != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPrivate != NULL )
    {
        pvarPrivate->vt = VT_BOOL;

        if ( m_dwFlags & PRIVATE )
        {
            pvarPrivate->boolVal = VARIANT_TRUE;
        } // if: if this is private property...
        else
        {
            pvarPrivate->boolVal = VARIANT_FALSE;
        } // else: it is not a private property...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperty::get_Private()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Common
//
//  Description:
//      Is this a common property?
//
//  Arguments:
//      pvarCommon  [OUT]   - catches the common property state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Common( OUT VARIANT * pvarCommon )
{
    //ASSERT( pvarCommon != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarCommon != NULL )
    {
        pvarCommon->vt = VT_BOOL;

        if ( ( m_dwFlags & PRIVATE ) == 0 )
        {
            pvarCommon->boolVal = VARIANT_TRUE;
        } // if: if this is not a private property then it must be a common one...
        else
        {
            pvarCommon->boolVal = VARIANT_FALSE;
        } // else: it is a private property...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperty::get_Common()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::get_Modified
//
//  Description:
//      Has this property been modified?
//
//  Arguments:
//      pvarModified    [OUT]   - catches the modified state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Modified( OUT VARIANT * pvarModified )
{
    //ASSERT( pvarModified != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarModified != NULL )
    {
        pvarModified->vt = VT_BOOL;

        if ( m_dwFlags & MODIFIED )
        {
            pvarModified->boolVal = VARIANT_TRUE;
        } // if: if it's been modified set the varint to true...
        else
        {
            pvarModified->boolVal = VARIANT_FALSE;
        } // else: if not the set the variant to false...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperty::get_Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::HrSaveBinaryProperty
//
//  Description:
//      Save the passed in SafeArray into our own SafeArray that is stored in
//      in a variant.
//
//  Arguments:
//      pPropValue  [IN]    - PropertyValue that gets the copy.
//      rvarValue   [IN]    - The safe array to copy.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrSaveBinaryProperty(
    IN CComObject< CClusPropertyValue > *   pPropValue,
    IN const VARIANT &                      rvarValue
    )
{
    ASSERT( pPropValue != NULL );

    HRESULT _hr = E_POINTER;

    if ( pPropValue != NULL )
    {
        SAFEARRAY * _psa = NULL;

        _hr = ::SafeArrayCopy( rvarValue.parray, &_psa );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = pPropValue->HrBinaryValue( _psa );
        } // if:
    } // if:

    return _hr;

} //*** CClusProperty::HrSaveBinaryProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperty::UseDefaultValue
//
//  Description:
//      Mark this property to restore its default value.  This effectivly
//      deletes the property.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::UseDefaultValue( void )
{
    HRESULT _hr = S_OK;

    //
    // Mark this property as being modified and needing to be reset to
    // its default value.
    //
    m_dwFlags |= USEDEFAULT;
    m_dwFlags |= MODIFIED;

    //
    // Now we need to empty the value
    //
    CComObject< CClusPropertyValue > *  _pPropValue = (*m_pValues)[ 0 ];
    CLUSTER_PROPERTY_FORMAT             _cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

    _hr = _pPropValue->get_Format( &_cpfFormat );
    if ( SUCCEEDED( _hr ) )
    {
        VARIANT _var;

        ::VariantInit( &_var );

        switch ( _cpfFormat )
        {
            case CLUSPROP_FORMAT_BINARY:
            {
                SAFEARRAY *     _psa = NULL;
                SAFEARRAYBOUND  _sab[ 1 ];

                _sab[ 0 ].lLbound   = 0;
                _sab[ 0 ].cElements = 0;

                //
                // allocate a one dimensional SafeArray of BYTES
                //
                _psa = ::SafeArrayCreate( VT_UI1, 1, _sab );
                if ( _psa != NULL )
                {
                    _hr = _pPropValue->HrBinaryValue( _psa );
                } // if the safe array was allocated
                else
                {
                    _hr = E_OUTOFMEMORY;
                } // else: safe array was not allocated

                break;
            } // case:

#if CLUSAPI_VERSION >= 0x0500
            case CLUSPROP_FORMAT_LONG:
#endif // CLUSAPI_VERSION >= 0x0500
            case CLUSPROP_FORMAT_DWORD:
            case CLUSPROP_FORMAT_ULARGE_INTEGER:
            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            {
                _var.vt = VT_EMPTY;
                _pPropValue->Value( _var );
                break;
            } // case:

#if CLUSAPI_VERSION >= 0x0500
            case CLUSPROP_FORMAT_EXPANDED_SZ:
#endif // CLUSAPI_VERSION >= 0x0500
            case CLUSPROP_FORMAT_UNKNOWN:
            default:
            {
                _hr = E_INVALIDARG;
                break;
            } // default:
        } // switch: on property format
    } // if: we got the format

    return _hr;

} //*** CClusProperty::UseDefaultValue()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusProperties class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::CClusProperties
//
//  Description:
//      Constsructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperties::CClusProperties( void )
{
    m_dwFlags       = 0;
    m_pcoParent     = NULL;
    m_piids         = (const IID *) iidCClusProperties;
    m_piidsSize     = ARRAYSIZE( iidCClusProperties );

} //*** CClusProperties::CClusProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::~CClusProperties
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperties::~CClusProperties( void )
{
    Clear();

} //*** CClusProperties::~CClusProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::Clear
//
//  Description:
//      Clean out the vector or ClusProperty objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusProperties::Clear( void )
{
    ::ReleaseAndEmptyCollection< CClusPropertyVector, CComObject< CClusProperty > >( m_Properties );

} //*** CClusProperties::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get_Count
//
//  Description:
//      Returns the count of elements (properties) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Properties.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusProperties::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::FindItem
//
//  Description:
//      Find the property that has the passed in name.
//
//  Arguments:
//      pszPropName [IN]    - The name of the property to find.
//      pnIndex     [OUT]   - The index of the property.
//
//  Return Value:
//      S_OK if successful, E_INVALIDARG, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::FindItem(
    IN  LPWSTR  pszPropName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pszPropName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pszPropName != NULL ) && ( pnIndex != NULL ) )
    {
        CComObject< CClusProperty > *       _pProperty = NULL;
        CClusPropertyVector::const_iterator _first = m_Properties.begin();
        CClusPropertyVector::const_iterator _last  = m_Properties.end();
        UINT                                _nIndex = 0;

        _hr = E_INVALIDARG;

        for ( ; _first != _last; _first++, _nIndex++ )
        {
            _pProperty = *_first;

            if ( _pProperty && ( lstrcmpi( pszPropName, _pProperty->Name() ) == 0 ) )
            {
                *pnIndex = _nIndex;
                _hr = S_OK;
                break;
            }
        }
    }

    return _hr;

} //*** CClusProperties::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::FindItem
//
//  Description:
//      Find the passed in property in the collection.
//
//  Arguments:
//      pProperty   [IN]    - The property to find.
//      pnIndex     [OUT]   - The index of the property.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::FindItem(
    IN  ISClusProperty *    pProperty,
    OUT UINT *              pnIndex
    )
{
    //ASSERT( pProperty != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pProperty != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR _bstrName;

        _hr = pProperty->get_Name( &_bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( _bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CClusProperties::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::GetIndex
//
//  Description:
//      Get the index from the passed in variant.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number,
//                          or the name of the property as a string.
//      pnIndex     [OUT]   - Catches the zero based index in the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant _v;
        UINT        _nIndex = 0;

        *pnIndex = 0;

        _v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = _v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            _nIndex = _v.lVal;
            _nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = _v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( _v.bstrVal, &_nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( _nIndex < m_Properties.size() )
            {
                *pnIndex = _nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusProperties::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get_Item
//
//  Description:
//      Returns the object (property) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number.
//      ppProperty  [OUT]   - Catches the property.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusProperty **   ppProperty
    )
{
    //ASSERT( ppProperty != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperty != NULL )
    {
        CComObject< CClusProperty > *   _pProperty = NULL;
        UINT                            _nIndex = 0;

        //
        // Zero the out param
        //
        *ppProperty = 0;

        _hr = GetIndex( varIndex, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            _pProperty = m_Properties[ _nIndex ];
            _hr = _pProperty->QueryInterface( IID_ISClusProperty, (void **) ppProperty );
        }
    }

    return _hr;

} //*** CClusProperties::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< CClusPropertyVector, CComObject< CClusProperty > >( ppunk, m_Properties );

} //*** CClusProperties::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::CreateItem
//
//  Description:
//      Create a new property and add it to the collection.
//
//  Arguments:
//      bstrName    [IN]    - property name.
//      varValue    [IN]    - the value to add.
//      ppProperty  [OUT]   - catches the newly created object.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::CreateItem(
    IN  BSTR                bstrName,
    IN  VARIANT             varValue,
    OUT ISClusProperty **   ppProperty
    )
{
    //ASSERT( ppProperty != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperty != NULL )
    {
        //
        // You can only add to not read only and private property lists.  Meaning
        // only the PrivateProperties collection can have new, unknown properties
        // added to it.  This should be reflected in the idl, but since there is
        // only one properties collection...
        //
        if ( ( ( m_dwFlags & READONLY ) == 0 ) && ( m_dwFlags & PRIVATE ) )
        {
            UINT                            _nIndex = 0;
            CComObject< CClusProperty > *   _pProperty = NULL;

            _hr = FindItem( bstrName, &_nIndex );
            if ( SUCCEEDED( _hr ) )
            {
                _pProperty = m_Properties[ _nIndex ];
                _hr = _pProperty->put_Value( varValue );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = _pProperty->QueryInterface( IID_ISClusProperty, (void **) ppProperty );
                } // if: the value was changed
            } // if: the item is in the list, change it...
            else
            {
                //
                // Create a new property and add it to the list.
                //
                _hr = CComObject< CClusProperty >::CreateInstance( &_pProperty );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< CComObject< CClusProperty > >    _ptrProperty( _pProperty );

                    _hr = _ptrProperty->Create( bstrName, varValue, ( m_dwFlags & PRIVATE ), ( m_dwFlags & READONLY ) );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _hr = _ptrProperty->QueryInterface( IID_ISClusProperty, (void **) ppProperty );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _ptrProperty->AddRef();
                            m_Properties.insert( m_Properties.end(), _pProperty );
                            m_dwFlags |= MODIFIED;
                            _ptrProperty->Modified( TRUE );
                        }
                    }
                }
            } // else: new item
        }
        else
        {
            _hr = S_FALSE;
        } // else: this is not the PrivateProperties collection!
    }

    return _hr;

} //*** CClusProperties::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::UseDefaultValue
//
//  Description:
//      Remove the item from the collection at the passed in index.
//
//  Arguments:
//      varIdex [IN]    - contains the index to remove.
//
//  Return Value:
//      S_OK if successful, E_INVALIDARG, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::UseDefaultValue( IN VARIANT varIndex )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        UINT    _nIndex = 0;

        _hr = GetIndex( varIndex, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            CComObject< CClusProperty > *   _pProp = NULL;

            _hr = E_POINTER;

            _pProp = m_Properties [_nIndex];
            if ( _pProp != NULL )
            {
                _hr = _pProp->UseDefaultValue();
            } // if: we have a property
        } // if: we got the index from the variant
    } // if: the collection is not read only

    return _hr;

} //*** CClusProperties::UseDefaultValue()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::RemoveAt
//
//  Description:
//      Remove the object (property) at the passed in index/position from the
//      collection.
//
//  Arguments:
//      nPos    [IN]    - Index of the object to remove.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::RemoveAt( IN size_t nPos )
{
    CComObject< CClusProperty > *       _pProperty = NULL;
    CClusPropertyVector::iterator       _first = m_Properties.begin();
    CClusPropertyVector::const_iterator _last  = m_Properties.end();
    HRESULT                             _hr = E_INVALIDARG;
    size_t                              _nIndex;

    for ( _nIndex = 0; ( _nIndex < nPos ) && ( _first != _last ); _nIndex++, _first++ )
    {
    }

    if ( _first != _last )
    {
        _pProperty = *_first;
        if ( _pProperty )
        {
            _pProperty->Release();
        }

        m_Properties.erase( _first );
        _hr = S_OK;
    }

    return _hr;

} //*** CClusProperties::RemoveAt()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::SaveChanges
//
//  Description:
//      Save the changes to the properties to the cluster database.
//
//  Arguments:
//      pvarStatusCode  [OUT]   - Catches an additional status code.
//                              e.g. ERROR_RESOURCE_PROPERTIES_STORED.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::SaveChanges( OUT VARIANT * pvarStatusCode )
{
    ASSERT( m_pcoParent != NULL );

    HRESULT _hr = E_POINTER;

    if ( m_pcoParent != NULL )
    {
        if ( ( m_dwFlags & READONLY ) == 0 )
        {
            VARIANT _vsc;

            _hr = m_pcoParent->HrSaveProperties( m_Properties, ( m_dwFlags & PRIVATE ), &_vsc );
            if ( SUCCEEDED( _hr ) )
            {
                if ( pvarStatusCode != NULL )
                {
                    _hr = ::VariantCopy( pvarStatusCode, &_vsc );
                    if ( FAILED( _hr ) )
                    {
                        goto Cleanup;
                    }
                } // if: optional arg is not NULL

                _hr = Refresh();
            } // if: properties were saved
        } // if: this collection is not read only
        else
        {
            _hr = S_FALSE;
        } // else: this collection is read only
    } // if: args and members vars are not NULL

Cleanup:

    return _hr;

} //*** CClusProperties::SaveChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::Refresh
//
//  Description:
//      Load the properties collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::Refresh( void )
{
    ASSERT( m_pcoParent != NULL );

    HRESULT _hr = E_POINTER;

    if ( m_pcoParent != NULL )
    {
        CClusPropList   _cplPropList;

        _hr = m_pcoParent->HrLoadProperties( _cplPropList, ( m_dwFlags & READONLY ), ( m_dwFlags & PRIVATE ) );
        if ( SUCCEEDED( _hr ) )
        {
            Clear();
            m_dwFlags &= ~MODIFIED;

            if ( _cplPropList.Cprops() > 0 )
            {
                _hr = HrFillPropertyVector( _cplPropList );
            } // if: are there any properties in the list?
        } // if: loaded properties successfully
    } // if: no parent

    return _hr;

} //*** CClusProperties::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::Create
//
//  Description:
//      Do the heavy weight construction.
//
//  Arguments:
//      pcoParent   [IN]    - Back pointer to the parent cluster object.
//      bPrivate    [IN]    - Are these private properties?
//      bReadOnly   [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::Create(
    IN CClusterObject * pcoParent,
    IN BOOL             bPrivate,
    IN BOOL             bReadOnly
    )
{
    //ASSERT( pcoParent != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcoParent != NULL )
    {
        m_pcoParent = pcoParent;

        if ( bPrivate )
        {
            m_dwFlags |= PRIVATE;
        } // if: set the private flag
        else
        {
            m_dwFlags &= ~PRIVATE;
        } // else: clear the private flag

        if ( bReadOnly )
        {
            m_dwFlags |= READONLY;
        } // if: set the read only flag
        else
        {
            m_dwFlags &= ~READONLY;
        } // else: clear the read only flag

        _hr = S_OK;
    } // if: parent specified

    return _hr;

} //*** CClusProperties::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::HrFillPropertyVector
//
//  Description:
//      Parse the passed in property list into a collection of properties.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to parse.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::HrFillPropertyVector(
    IN CClusPropList & rcplPropList
    )
{
    HRESULT                         _hr = S_OK;
    DWORD                           _sc;
    CComObject< CClusProperty > *   _pProp = NULL;

    _sc = rcplPropList.ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            _hr = CComObject< CClusProperty >::CreateInstance( &_pProp );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< CComObject < CClusProperty > >   _ptrProp( _pProp );

                _hr = _ptrProp->Create(
                                const_cast< BSTR >( rcplPropList.PszCurrentPropertyName() ),
                                rcplPropList.RPvlPropertyValue(),
                                ( m_dwFlags & PRIVATE ),
                                ( m_dwFlags & READONLY )
                                );
                if ( SUCCEEDED( _hr ) )
                {
                    _ptrProp->AddRef();
                    m_Properties.insert( m_Properties.end(), _ptrProp );
                } // if: create property ok
                else
                {
                    break;
                } // else: error creating the property
            } // if: create property instance ok

            //
            // Move to the next property in the list.
            //
            _sc = rcplPropList.ScMoveToNextProperty();

        } while ( _sc == ERROR_SUCCESS );   // do-while: there are properties in the list

    } // if: moved to the first property successfully

    if ( _sc != ERROR_NO_MORE_ITEMS )
    {
        _hr = HRESULT_FROM_WIN32( _sc );
    } // if: error moving to property

    return _hr;

} //*** CClusProperties::HrFillPropertyVector()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get_ReadOnly
//
//  Description:
//      Is this property collection read only?
//
//  Arguments:
//      pvarReadOnly    [OUT]   - catches the property's read only  state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_ReadOnly( OUT VARIANT * pvarReadOnly )
{
    //ASSERT( pvarReadOnly != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarReadOnly != NULL )
    {
        pvarReadOnly->vt = VT_BOOL;

        if ( m_dwFlags & READONLY )
        {
            pvarReadOnly->boolVal = VARIANT_TRUE;
        } // if: if this is a read only property...
        else
        {
            pvarReadOnly->boolVal = VARIANT_FALSE;
        } // else: it is not a read only property...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperties::get_ReadOnly()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get_Private
//
//  Description:
//      Is this a private property collection?
//
//  Arguments:
//      pvarPrivate [OUT]   - catches the private property state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Private( OUT VARIANT * pvarPrivate )
{
    //ASSERT( pvarPrivate != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPrivate != NULL )
    {
        pvarPrivate->vt = VT_BOOL;

        if ( m_dwFlags & PRIVATE )
        {
            pvarPrivate->boolVal = VARIANT_TRUE;
        } // if: if this is private property...
        else
        {
            pvarPrivate->boolVal = VARIANT_FALSE;
        } // else: it is not a private property...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperties::get_Private()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get_Common
//
//  Description:
//      Is this a common property collection?
//
//  Arguments:
//      pvarCommon  [OUT]   - catches the common property state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Common( OUT VARIANT * pvarCommon )
{
    //ASSERT( pvarCommon != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarCommon != NULL )
    {
        pvarCommon->vt = VT_BOOL;

        if ( ( m_dwFlags & PRIVATE ) == 0 )
        {
            pvarCommon->boolVal = VARIANT_TRUE;
        } // if: if this is not a private property then it must be a common one...
        else
        {
            pvarCommon->boolVal = VARIANT_FALSE;
        } // else: it is a private property...

        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusProperties::get_Common()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusProperties::get_Modified
//
//  Description:
//      Has this property collection been modified?
//
//  Arguments:
//      pvarModified    [OUT]   - catches the modified state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Modified( OUT VARIANT * pvarModified )
{
    //ASSERT( pvarModified != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarModified != NULL )
    {
        pvarModified->vt = VT_BOOL;

        if ( m_dwFlags & MODIFIED )
        {
            pvarModified->boolVal = VARIANT_TRUE;
            _hr = S_OK;
        } // if: has an add or a remove been done?
        else
        {
            CComObject< CClusProperty > *       _pProperty = NULL;
            CClusPropertyVector::iterator       _itCurrent = m_Properties.begin();
            CClusPropertyVector::const_iterator _itLast  = m_Properties.end();

            pvarModified->boolVal = VARIANT_FALSE;      // init to false
            _hr = S_OK;

            for ( ; _itCurrent != _itLast ; _itCurrent++ )
            {
                _pProperty = *_itCurrent;
                if ( _pProperty )
                {
                    if ( _pProperty->Modified() )
                    {
                        pvarModified->boolVal = VARIANT_TRUE;
                        break;
                    } // if: has this property been modified?
                }
            } // for: each property in the collection
        } // else: not adds or remove, check each property's modified state.
    } // if: is the pointer arg any good?

    return _hr;

} //*** CClusProperties::get_Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSafeArraySizeof
//
//  Description:
//      Little helper function to get the sizeof() a safe array.
//
//  Arguments:
//      psa
//          The safe array to get the sizeof.
//
//      nDimension
//          The dimension of the safe array to get the sizeof.
//
//      pcElements
//          The count of elements in the safe array.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrSafeArraySizeof(
      SAFEARRAY *   psa
    , unsigned int  nDimension
    , long *        pcElements
    )
{
    ASSERT( psa != NULL );
    ASSERT( pcElements != NULL );

    HRESULT _hr = S_OK;
    long    _lUBound;
    long    _lLBound;

    _hr = SafeArrayGetUBound( psa, nDimension, &_lUBound );
    if ( SUCCEEDED( _hr ) )
    {
        _hr = SafeArrayGetLBound( psa, nDimension, &_lLBound );
        if ( SUCCEEDED( _hr ) )
        {
            *pcElements = ( _lUBound - _lLBound ) + 1;   // convert from upper and lower bounds to sizeof()
        } // if:
    } // if:

    return _hr;

} //*** HrSafeArraySizeof()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      PropLstS.cpp
//
//  Description:
//      Stub for implementation of property list classes.
//
//  Author:
//      Galen Barbee    (GalenB)    20-Dec-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\propertyvalue.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      PropertyValue.cpp
//
//  Description:
//      Implementation of the cluster property value classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Galen Barbee    (GalenB)    16-Dec-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <StrSafe.h>

#include "Property.h"
#include "PropertyValue.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusPropertyValue[] =
{
    &IID_ISClusPropertyValue
};

static const IID *  iidCClusPropertyValues[] =
{
    &IID_ISClusPropertyValues
};

static const IID *  iidCClusPropertyValueData[] =
{
    &IID_ISClusPropertyValueData
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropertyValue class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::CClusPropertyValue
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValue::CClusPropertyValue( void )
{
    m_dwFlags   = 0;
    m_pcpvdData = NULL;

#if CLUSAPI_VERSION >= 0x0500
    m_cptType   = CLUSPROP_TYPE_UNKNOWN;
#else
    m_cptType   = (CLUSTER_PROPERTY_TYPE) -1;
#endif // CLUSAPI_VERSION >= 0x0500

    m_cpfFormat = CLUSPROP_FORMAT_UNKNOWN;
    m_cbLength  = 0;

    m_piids  = (const IID *) iidCClusPropertyValue;
    m_piidsSize = ARRAYSIZE( iidCClusPropertyValue );

} //*** CClusPropertyValue::CClusPropertyValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::~CClusPropertyValue
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValue::~CClusPropertyValue( void )
{
    if ( m_pcpvdData != NULL )
    {
        m_pcpvdData->Release();
    } // if: data vector has been allocated

} //*** CClusPropertyValue::~CClusPropertyValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::Create
//
//  Description:
//      Finish the heavy weight construction for a single value.
//
//  Arguments:
//      varValue    [IN]    - The value.
//      cptType     [IN]    - The cluster property type of the value.
//      cpfFormat   [IN]    - The cluster property format of the value.
//      cbLength    [IN]    - The length of the value.
//      bReadOnly   [IN]    - Is this a read only property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValue::Create(
    IN VARIANT                  varValue,
    IN CLUSTER_PROPERTY_TYPE    cptType,
    IN CLUSTER_PROPERTY_FORMAT  cpfFormat,
    IN size_t                   cbLength,
    IN BOOL                     bReadOnly
    )
{
    HRESULT _hr = S_FALSE;

    m_cptType   = cptType;
    m_cpfFormat = cpfFormat;
    m_cbLength  = cbLength;

    if ( bReadOnly )
    {
        m_dwFlags |= READONLY;
    } // if: set the read only flag
    else
    {
        m_dwFlags &= ~READONLY;
    } // else: clear the read only flag

    _hr = CComObject< CClusPropertyValueData >::CreateInstance( &m_pcpvdData );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject < CClusPropertyValueData > >  _ptrData( m_pcpvdData );

        _hr = _ptrData->Create( varValue, cpfFormat, bReadOnly );
        if ( SUCCEEDED( _hr ) )
        {
            _ptrData->AddRef();
        } // if:
    } // if: Can create an instance of CClusPropertyValueData

    return _hr;

} //*** CClusPropertyValue::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::Create
//
//  Description:
//      Finish the heavy weight construction for a value list.
//
//  Arguments:
//      cbhValue    [IN]    - The value list buffer helper.
//      bReadOnly   [IN]    - Is this a read only property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValue::Create(
    IN CLUSPROP_BUFFER_HELPER   cbhValue,
    IN BOOL                     bReadOnly
    )
{
    HRESULT _hr = S_FALSE;

    m_cptType   = (CLUSTER_PROPERTY_TYPE) cbhValue.pValue->Syntax.wType;
    m_cpfFormat = (CLUSTER_PROPERTY_FORMAT) cbhValue.pValue->Syntax.wFormat;
    m_cbLength  = cbhValue.pValue->cbLength;

    if ( bReadOnly )
    {
        m_dwFlags |= READONLY;
    } // if: set the read only flag
    else
    {
        m_dwFlags &= ~READONLY;
    } // else: clear the read only flag

    _hr = CComObject< CClusPropertyValueData >::CreateInstance( &m_pcpvdData );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject < CClusPropertyValueData > >  _ptrData( m_pcpvdData );

        _hr = _ptrData->Create( cbhValue, bReadOnly );
        if ( SUCCEEDED( _hr ) )
        {
            _ptrData->AddRef();
        } // if:
    } // if: Can create an instance of CClusPropertyValueData

    return _hr;

} //*** CClusPropertyValue::Create

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::get_Value
//
//  Description:
//      Return the default value data for this value.
//
//  Arguments:
//      pvarValue   [IN]    - Catches the data value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Value( IN VARIANT * pvarValue )
{
    //ASSERT( pvarValue != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarValue != NULL )
    {
        _hr = VariantCopyInd( pvarValue, &(*m_pcpvdData)[ 0 ] );
    }

    return _hr;

} //*** CClusPropertyValue::get_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::put_Value
//
//  Description:
//      Change the default data value.
//
//  Arguments:
//      varValue    [IN]    - The new data value.
//
//  Return Value:
//      S_OK if successful, or S_FALSE if read only.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::put_Value( IN VARIANT varValue )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        CComVariant _varNew( varValue );
        CComVariant _varOld( (*m_pcpvdData)[ 0 ] );

        _hr = S_OK;

        if ( _varOld != _varNew )
        {
            (*m_pcpvdData)[ 0 ] = _varNew;
            m_dwFlags |= MODIFIED;
        } // if: value changed
    } // if:


    return _hr;

} //*** CClusPropertyValue::put_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::get_Type
//
//  Description:
//      Get this value's cluster property type.
//
//  Arguments:
//      pcptType    [OUT]   - Catches the value type.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Type(
    OUT CLUSTER_PROPERTY_TYPE * pcptType
    )
{
    //ASSERT( pcptType != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcptType != NULL )
    {
        *pcptType = m_cptType;
        _hr = S_OK;
    } // if: property type pointer specified

    return _hr;

} //*** CClusPropertyValue::get_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::put_Type
//
//  Description:
//      Set this value's cluster property type.
//
//  Arguments:
//      cptType [IN]    - The new type.
//
//  Return Value:
//      S_OK if successful, or S_FALSE if read only.
//
//  Note:
//      It is possible that this should be removed.  You cannot ever change
//      a value's type.
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::put_Type( IN CLUSTER_PROPERTY_TYPE cptType )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        m_cptType = cptType;
        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusPropertyValue::put_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::get_Format
//
//  Description:
//      Get the value's cluster property format.
//
//  Arguments:
//      pcpfFormat  [OUT]   - Catches the format.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Format(
    OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat
    )
{
    //ASSERT( pcpfFormat != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcpfFormat != NULL )
    {
        *pcpfFormat = m_cpfFormat;
        _hr = S_OK;
    } // if: property format pointer specified

    return _hr;

} //*** CClusPropertyValue::get_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::put_Format
//
//  Description:
//      Set the value's cluster property format.
//
//  Arguments:
//      cpfFormat   [IN]    - The new format for the value.
//
//  Return Value:
//      S_OK if successful, or S_FALSE if read only.
//
//  Note:
//      It is possible that this should be removed.  You cannot ever change
//      a value's format.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::put_Format(
    IN CLUSTER_PROPERTY_FORMAT cpfFormat
    )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        m_cpfFormat = cpfFormat;
        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusPropertyValue::put_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::get_Length
//
//  Description:
//      Returns the length of this value.
//
//  Arguments:
//      plLength    [OUT]   - Catches the length of this value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Length( OUT long * plLength )
{
    //ASSERT( plLength != NULL );

    HRESULT _hr = E_POINTER;

    if ( plLength != NULL )
    {
        *plLength = (long) m_cbLength;
        _hr = S_OK;
    } // if: length pointer specified

    return _hr;

} //*** CClusPropertyValue::get_Length()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::get_DataCount
//
//  Description:
//      Return the count of VARIANTS in the ClusProperyValueData object.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_DataCount( OUT long * plCount )
{
    return m_pcpvdData->get_Count( plCount );

} //*** CClusPropertyValue::get_DataCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::get_Data
//
//  Description:
//      Returns the data collection.
//
//  Arguments:
//      ppClusterPropertyValueData  [OUT]   - Catches the data collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Data(
    OUT ISClusPropertyValueData ** ppClusterPropertyValueData
    )
{
    //ASSERT( ppClusterPropertyValueData );

    HRESULT _hr = E_POINTER;

    if ( ppClusterPropertyValueData != NULL )
    {
        _hr = m_pcpvdData->QueryInterface( IID_ISClusPropertyValueData, (void **) ppClusterPropertyValueData );
    }

    return _hr;

} //*** CClusPropertyValue::get_Data()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::Modified
//
//  Description:
//      Sets this value to modified and returns the old modified state.
//
//  Arguments:
//      bModified   [IN]    - New modified state.
//
//  Return Value:
//      The old modified state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusPropertyValue::Modified( IN BOOL bModified )
{
    BOOL _bTemp = ( m_dwFlags & MODIFIED );

    if ( bModified )
    {
        m_dwFlags |= MODIFIED;
    } // if: set the modified flag
    else
    {
        m_dwFlags &= ~MODIFIED;
    } // else: clear the modified flag

    return _bTemp;

} //*** CClusPropertyValue::Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::Value
//
//  Description:
//      Set a new value into this property value.
//
//  Arguments:
//      rvarValue   [IN]    - the new value
//
//  Return Value:
//      The old value.
//
//--
/////////////////////////////////////////////////////////////////////////////
CComVariant CClusPropertyValue::Value( const CComVariant & rvarValue )
{
    CComVariant _varNew( rvarValue );
    CComVariant _varOld( (*m_pcpvdData)[ 0 ] );

    if ( _varOld != _varNew )
    {
        (*m_pcpvdData)[ 0 ] = _varNew;
        m_dwFlags |= MODIFIED;
    } // if: data changed

    return _varOld;

} //*** CClusPropertyValue::Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValue::HrBinaryValue
//
//  Description:
//      Set the binary value of property value.
//
//  Arguments:
//      psa [IN]    - The SAFEARRY to save.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValue::HrBinaryValue( IN SAFEARRAY * psa )
{
    return m_pcpvdData->HrBinaryValue( psa );

} //*** CClusPropertyValue::HrBinaryValue()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropertyValues class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::CClusPropertyValues
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValues::CClusPropertyValues( void )
{
    m_piids     = (const IID *) iidCClusPropertyValues;
    m_piidsSize = ARRAYSIZE( iidCClusPropertyValues );

} //*** CClusPropertyValues::CClusPropertyValues()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::~CClusPropertyValues
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValues::~CClusPropertyValues( void )
{
    Clear();

} //*** CClusPropertyValues::~CClusPropertyValues()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::Clear
//
//  Description:
//      Releases the values in the collection.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropertyValues::Clear( void )
{
    ::ReleaseAndEmptyCollection< CClusPropertyValueVector, CComObject< CClusPropertyValue > >( m_cpvvValues );

} //*** CClusPropertyValues::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::HrGetVariantLength
//
//  Description:
//      Compute the length of the data from its variant type.
//
//  Arguments:
//      rvarValue   [IN]    - The new value to compute the length of.
//      pcbLength   [OUT]   - Catches the length.
//      cpfFormat   [IN]    - The cluster property format.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the type is bogus.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::HrGetVariantLength(
    IN  const VARIANT           rvarValue,
    OUT PDWORD                  pcbLength,
    IN  CLUSTER_PROPERTY_FORMAT cpfFormat
    )
{
    HRESULT _hr = E_INVALIDARG;
    VARTYPE _varType = rvarValue.vt;

    do
    {
        if ( ( _varType & VT_ARRAY ) && ( _varType & VT_UI1 ) )
        {
            SAFEARRAY * _psa = rvarValue.parray;

            //
            // only accept single dimensional arrays!
            //
            if ( ( _psa != NULL ) && ( ::SafeArrayGetDim( _psa ) == 1 ) )
            {
                _hr = HrSafeArraySizeof( _psa, 1, (long *) pcbLength );
            } // if:

            break;
        } // if:

        if ( _varType & VT_VECTOR )
        {
            break;
        } // if: Don't know what to do with a vector...

        _varType &= ~VT_BYREF;      // mask off the by ref bit if it was set...

        if ( ( _varType == VT_I2 ) || ( _varType == VT_I4 ) || ( _varType == VT_BOOL ) || ( _varType == VT_R4 ) )
        {
            *pcbLength = sizeof( DWORD );
            _hr = S_OK;
            break;
        } // if:
        else if ( _varType == VT_BSTR )
        {
            CComBSTR    _bstr;

            _bstr.Attach( rvarValue.bstrVal );
            *pcbLength = _bstr.Length();
            _bstr.Detach();
            _hr = S_OK;
            break;
        } // else if:
        else if ( ( _varType == VT_I8 ) || ( _varType == VT_R8 ) )
        {
            *pcbLength = sizeof( ULONGLONG );
            _hr = S_OK;
            break;
        } // else if:
        else if ( _varType == VT_VARIANT )
        {
            _hr = HrGetVariantLength( *rvarValue.pvarVal, pcbLength, cpfFormat );
            break;
        } // else if:
    }
    while( TRUE );  // do-while: want to avoid using a goto ;-)

    return _hr;

} //*** CClusPropertyValues::HrGetVariantLength()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::get_Count
//
//  Description:
//      Returns the count of elements (values) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_cpvvValues.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPropertyValues::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::GetIndex
//
//  Description:
//      Get the index from the passed in variant.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number.
//      pnIndex     [OUT]   - Catches the zero based index in the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant _v;
        UINT        _nIndex = 0;

        *pnIndex = 0;

        _v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = _v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            _nIndex = _v.lVal;
            _nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( _nIndex < m_cpvvValues.size() )
            {
                *pnIndex = _nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusPropertyValues::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::get_Item
//
//  Description:
//      Returns the object (value) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Hold the index.  This is a one based number.
//      ppPropertyValue [OUT]   - Catches the property value.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::get_Item(
    IN  VARIANT                 varIndex,
    OUT ISClusPropertyValue **  ppPropertyValue
    )
{
    //ASSERT( ppPropertyValue != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppPropertyValue != NULL )
    {
        CComObject< CClusPropertyValue > *  _pPropertyValue = NULL;
        UINT                                _nIndex = 0;

        //
        // Zero the out param
        //
        *ppPropertyValue = 0;

        _hr = GetIndex( varIndex, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            _pPropertyValue = m_cpvvValues[ _nIndex ];
            _hr = _pPropertyValue->QueryInterface( IID_ISClusPropertyValue, (void **) ppPropertyValue );
        }
    }

    return _hr;

} //*** CClusPropertyValues::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< CClusPropertyValueVector, CComObject< CClusPropertyValue > >( ppunk, m_cpvvValues );

} //*** CClusPropertyValues::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      varValue    [IN]    - The value.
//      cptType     [IN]    - The cluster property type.
//      cpfFormat   [IN]    - The cluster format type.
//      bReadOnly   [IN]    - Is this a read only value/property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::Create(
    IN VARIANT                  varValue,
    IN CLUSTER_PROPERTY_TYPE    cptType,
    IN CLUSTER_PROPERTY_FORMAT  cpfFormat,
    IN BOOL                     bReadOnly
    )
{
    HRESULT                             _hr = S_FALSE;
    CComObject< CClusPropertyValue > *  _pValue = NULL;

    _hr = CComObject< CClusPropertyValue >::CreateInstance( &_pValue );
    if ( SUCCEEDED( _hr ) )
    {
        CSmartPtr< CComObject < CClusPropertyValue > >  _ptrValue( _pValue );
        DWORD                                           _cbLength = 0;

        _hr = HrGetVariantLength( varValue, &_cbLength, cpfFormat );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = _ptrValue->Create( varValue, cptType, cpfFormat, _cbLength, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                m_cpvvValues.insert( m_cpvvValues.end(), _ptrValue );
                _ptrValue->AddRef();
            } // if:
        } // if:
    } // if: Can create an instance of CClusPropertyValueData

    return _hr;

} //*** CClusPropertyValues::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      rpvlValue   [IN]    - The value list.
//      bReadOnly   [IN]    - Is this a read only value/property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::Create(
    IN const CClusPropValueList &   rpvlValue,
    IN BOOL                         bReadOnly
    )
{
    return HrFillPropertyValuesVector( const_cast< CClusPropValueList & >( rpvlValue ), bReadOnly );

} //*** CClusPropertyValues::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::CreateItem
//
//  Description:
//      Create a new property value object and add it to the collection.
//
//  Arguments:
//      bstrName        [IN]    - property name.
//      varValue        [IN]    - the value to add.
//      ppPropertyValue [OUT]   - catches the newly created object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::CreateItem(
    IN  BSTR                    bstrName,
    IN  VARIANT                 varValue,
    OUT ISClusPropertyValue **  ppPropertyValue
    )
{
    //ASSERT( ppPropertyValue != NULL );

    HRESULT _hr = E_POINTER;

    //
    //  TODO: GalenB    17 Jan 2000
    //
    //  If are going to allow Multi-valued property creation we need to implement this method?
    //
    if ( ppPropertyValue != NULL )
    {
        _hr = E_NOTIMPL;
    } // if: property value interface pointer not specified

    return _hr;

} //*** CClusPropertyValues::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::RemoveItem
//
//  Description:
//      Remove the property value at the passed in index from the collection.
//
//  Arguments:
//      varIndex    [IN]    - contains the index to remove.
//
//  Return Value:
//      S_OK if successful, S_FALSE if read only, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::RemoveItem( VARIANT varIndex )
{
    //
    //  TODO: GalenB    17 Jan 2000
    //
    //  If are going to allow Multi-valued property creation we need to implement this method?
    //
    return E_NOTIMPL;

} //*** CClusPropertyValues::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValues::HrFillPropertyValuesVector
//
//  Description:
//      Fill the collection from the passes in value list.
//
//  Arguments:
//      cplPropValueList    [IN]    - The value list to parse.
//      bReadOnly           [IN]    - Is this part of a read only property?
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::HrFillPropertyValuesVector(
    IN CClusPropValueList & cplPropValueList,
    IN BOOL                 bReadOnly
    )
{
    HRESULT                             _hr = S_OK;
    DWORD                               _sc;
    CComVariant                         _var;
    CComObject< CClusPropertyValue > *  _pPropVal = NULL;
    CLUSPROP_BUFFER_HELPER              _cbhValue = { NULL };

    _sc = cplPropValueList.ScMoveToFirstValue();
    if ( _sc != ERROR_SUCCESS )
    {
        _hr = HRESULT_FROM_WIN32( _sc );
    } // if: error moving to the first value
    else
    {
        do
        {
            _cbhValue = cplPropValueList;

            _hr = CComObject< CClusPropertyValue >::CreateInstance( &_pPropVal );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< CComObject < CClusPropertyValue > >  _ptrProp( _pPropVal );

                _hr = _ptrProp->Create( _cbhValue, bReadOnly );
                if ( SUCCEEDED( _hr ) )
                {
                    _ptrProp->AddRef();
                    m_cpvvValues.insert( m_cpvvValues.end(), _ptrProp );
                } // if: create property ok
            } // if: create property instance ok

            //
            // Move to the next value.
            //
            _sc = cplPropValueList.ScMoveToNextValue();

        } while ( _sc == ERROR_SUCCESS );   // do-while: there are value in the list

        if ( _sc != ERROR_NO_MORE_ITEMS )
        {
            _hr = HRESULT_FROM_WIN32( _sc );
        } // if:  error occurred moving to the next value
    } // else: moved to the first value successfully

    return _hr;

} //*** CClusPropertyValues::HrFillPropertyValuesVector()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropertyValueData class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::CClusPropertyValueData
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValueData::CClusPropertyValueData( void )
{
    m_cpfFormat = CLUSPROP_FORMAT_UNKNOWN;
    m_dwFlags   = 0;
    m_piids     = (const IID *) iidCClusPropertyValueData;
    m_piidsSize = ARRAYSIZE( iidCClusPropertyValueData );

} //*** CClusPropertyValueData::CClusPropertyValueData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::~CClusPropertyValueData
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValueData::~CClusPropertyValueData( void )
{
    Clear();

} //*** CClusPropertyValueData::~CClusPropertyValueData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::Clear
//
//  Description:
//      Erase the data collection.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropertyValueData::Clear( void )
{
    if ( ! m_cpvdvData.empty() )
    {
        m_cpvdvData.erase( m_cpvdvData.begin(), m_cpvdvData.end() );
    } // if:

} //*** CClusPropertyValueData::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::get_Count
//
//  Description:
//      Returns the count of elements (data) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_cpvdvData.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPropertyValueData::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::GetIndex
//
//  Description:
//      Get the index from the passed in variant.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number.
//      pnIndex     [OUT]   - Catches the zero based index in the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant _v;
        UINT        _nIndex = 0;

        *pnIndex = 0;

        _v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = _v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            _nIndex = _v.lVal;
            _nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( _nIndex < m_cpvdvData.size() )
            {
                *pnIndex = _nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusPropertyValueData::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::get_Item
//
//  Description:
//      Returns the object (data) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number.
//      pvarData    [OUT]   - Catches the property value.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::get_Item(
    IN  VARIANT     varIndex,
    OUT VARIANT *   pvarData
    )
{
    //ASSERT( pvarData != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarData != NULL )
    {
        UINT    _nIndex = 0;

        _hr = GetIndex( varIndex, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = VariantCopyInd( pvarData, &m_cpvdvData[ _nIndex ] );
        }
    }

    return _hr;

} //*** CClusPropertyValueData::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewVariantEnum< CClusPropertyValueDataVector >( ppunk, m_cpvdvData );

} //*** CClusPropertyValueData::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      varValue    [IN]    - The data value.
//      cpfFormat   [IN]    - The cluster property format.
//      bReadOnly   [IN]    - Is this data for a read only property?
//
//  Return Value:
//      S_OK -- Always!!!
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::Create(
    IN VARIANT                  varValue,
    IN CLUSTER_PROPERTY_FORMAT  cpfFormat,
    IN BOOL                     bReadOnly
    )
{
    if ( bReadOnly )
    {
        m_dwFlags |= READONLY;
    } // if: set the read only flag
    else
    {
        m_dwFlags &= ~READONLY;
    } // else: clear the read only flag

    m_cpfFormat = cpfFormat;

    if ( ( varValue.vt & VT_BYREF ) && ( varValue.vt & VT_VARIANT ) )
    {
        m_cpvdvData.insert( m_cpvdvData.end(), *varValue.pvarVal );
    } // if: the variant is a reference to another variant...
    else
    {
        m_cpvdvData.insert( m_cpvdvData.end(), varValue );
    } // else: the variant is the data...

    return S_OK;

} //*** CClusPropertyValueData::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::Create
//
//  Description:
//      Finish the heavy weight construction.
//
//  Arguments:
//      cbhValue    [IN]    - The value buffer helper.
//      bReadOnly   [IN]    - Is this data for a read only property?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::Create(
    IN CLUSPROP_BUFFER_HELPER   cbhValue,
    IN BOOL                     bReadOnly
    )
{
    HRESULT _hr = S_OK;

    if ( bReadOnly )
    {
        m_dwFlags |= READONLY;
    } // if: set the read only flag
    else
    {
        m_dwFlags &= ~READONLY;
    } // else: clear the read only flag

    m_cpfFormat = (CLUSTER_PROPERTY_FORMAT) cbhValue.pValue->Syntax.wFormat;

    switch( m_cpfFormat )
    {
#if CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_EXPANDED_SZ:
#endif // CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_SZ:
        case CLUSPROP_FORMAT_EXPAND_SZ:
        {
            m_cpvdvData.insert( m_cpvdvData.end(), cbhValue.pStringValue->sz );
            break;
        } // case:

#if CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_LONG:
#endif // CLUSAPI_VERSION >= 0x0500
        case CLUSPROP_FORMAT_DWORD:
        {
#if CLUSAPI_VERSION >= 0x0500
            m_cpvdvData.insert( m_cpvdvData.end(), cbhValue.pLongValue->l );
#else
            m_cpvdvData.insert( m_cpvdvData.end(), (long) cbhValue.pDwordValue->dw );
#endif // CLUSAPI_VERSION >= 0x0500
            break;
        } // case:

        case CLUSPROP_FORMAT_MULTI_SZ:
        {
            _hr = HrCreateMultiSz( cbhValue );
            break;
        } // case:

        case CLUSPROP_FORMAT_BINARY:
        {
            _hr = HrCreateBinary( cbhValue );
            break;
        } // case:

        default:
        {
            break;
        } // default:
    } // switch:

    return _hr;

} //*** CClusPropertyValueData::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::CreateItem
//
//  Description:
//      Create a new object and add it to the collection.
//
//  Arguments:
//      varValue    [IN]    - value to add.
//      pvarData    [OUT]   - catches the new created object.
//
//  Return Value:
//      S_OK if successful, S_FALSE if read only, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::CreateItem(
    IN  VARIANT     varValue,
    OUT VARIANT *   pvarData
    )
{
    //ASSERT( pvarData != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarData != NULL )
    {
        if ( ( m_dwFlags & READONLY ) == 0 )
        {
            if ( ( m_cpfFormat == CLUSPROP_FORMAT_MULTI_SZ ) && ( varValue.vt == VT_BSTR ) )
            {
                m_cpvdvData.insert( m_cpvdvData.end(), varValue );
                *pvarData = varValue;   // kinda acquard, but that's automation for ya'
                _hr = S_OK;
            } // if:
            else
            {
                _hr = E_INVALIDARG;
            } // else:
        } // if:
        else
        {
            _hr = S_FALSE;
        } // else:
    } // if:

    return _hr;

} //*** CClusPropertyValueData::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::RemoveItem
//
//  Description:
//      Remove the data at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - variant that contains the index to remove.
//
//  Return Value:
//      S_OK if successful, S_FALSE if read only, or other HRESULT error.
//
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::RemoveItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_FALSE;

    if ( ( m_dwFlags & READONLY ) == 0 )
    {
        UINT    _iDelete = 0;

        _hr = GetIndex( varIndex, &_iDelete );
        if ( SUCCEEDED( _hr ) )
        {
            CClusPropertyValueDataVector::iterator          _itDelete = m_cpvdvData.begin();
            CClusPropertyValueDataVector::const_iterator    _itLast = m_cpvdvData.end();
            UINT                                            _nCount;

            for ( _nCount = 0; ( ( _iDelete < _nCount ) && ( _itDelete != _itLast ) ); _itDelete++, _nCount++ )
            {
            } // for:

            m_cpvdvData.erase( _itDelete );

            _hr = S_OK;
        }
    } // if:

    return _hr;

} //*** CClusPropertyValueData::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::operator=
//
//  Description:
//      Saves the passed in data into the collection at the default
//      position.
//
//  Arguments:
//      varvalue    [IN]    - The data to save.
//
//  Return Value:
//      The old data.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CComVariant & CClusPropertyValueData::operator=(
    IN const CComVariant & varData
    )
{
    m_cpvdvData[ 0 ] = varData;

    return m_cpvdvData[ 0 ];

} //*** CClusPropertyValueData::operator=()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::HrCreateMultiSz
//
//  Description:
//      Parse the passed in multi string into a collection of strings.
//
//  Arguments:
//      cbhValue    [IN]    - The property value buffer helper.
//
//  Return Value:
//      S_OK -- Always!
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrCreateMultiSz(
    IN CLUSPROP_BUFFER_HELPER cbhValue
    )
{
    HRESULT _hr = S_OK;
    LPWSTR  _psz = cbhValue.pMultiSzValue->sz;

    do
    {
        m_cpvdvData.insert( m_cpvdvData.end(), _psz );
        _psz += wcslen( _psz ) + 1;
    }
    while( *_psz != L'\0' );    // do-while not at end of string...

    return _hr;

} //*** CClusPropertyValueData::HrCreateMultiSz()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::HrFillMultiSzBuffer
//
//  Description:
//      Create a multi string from the collection of strings.
//
//  Arguments:
//      ppsz    [OUT]   - Catches the mutli string.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrFillMultiSzBuffer( OUT LPWSTR * ppsz ) const
{
    //ASSERT( ppsz != NULL );

    HRESULT                                         _hr = E_POINTER;
    size_t                                          _cchpsz = 0;
    CClusPropertyValueDataVector::const_iterator    _itFirst = m_cpvdvData.begin();
    CClusPropertyValueDataVector::const_iterator    _itLast = m_cpvdvData.end();

    if ( ppsz != NULL )
    {
        _hr = S_OK;
        for ( ; _itFirst != _itLast; _itFirst++ )
        {
            if ( (*_itFirst).vt == VT_BSTR )
            {
                _cchpsz += ( wcslen( (*_itFirst).bstrVal ) + 1 ); // don't forget the NULL!
            } // if:
            else
            {
                _hr = E_INVALIDARG;
                break;
            } // else:
        } // for:

        if ( SUCCEEDED( _hr ) )
        {
            LPWSTR  _psz = NULL;
            size_t  _cch = 0;

            _cchpsz += 2;     // ends in NULL NULL

            *ppsz = (LPWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cchpsz * sizeof( WCHAR ) );
            if ( *ppsz != NULL )
            {
                _psz = *ppsz;

                for ( _itFirst = m_cpvdvData.begin(); _itFirst != _itLast; _itFirst++ )
                {
                    _cch = wcslen( (*_itFirst).bstrVal );
                    _hr = StringCchCopyW( _psz, _cchpsz, (*_itFirst).bstrVal );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _psz += ( _cch + 1 );
                    } // if:
                    else
                    {
                        break;
                    } // else:
                } // for:
            } // if:
            else
            {
                DWORD   _sc = ::GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            } // else:
        } // if:
    } // if:

    return _hr;

} //*** CClusPropertyValueData::HrFillMultiSzBuffer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::HrCreateBinary
//
//  Description:
//      Create a safeArray from the passed in binary property value.
//
//  Arguments:
//      cbhValue    [IN]    - The binary property value.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrCreateBinary(
    IN CLUSPROP_BUFFER_HELPER cbhValue
    )
{
    HRESULT         _hr = E_OUTOFMEMORY;
    SAFEARRAY *     _psa = NULL;
    SAFEARRAYBOUND  _sab[ 1 ];

    _sab[ 0 ].lLbound   = 0;
    _sab[ 0 ].cElements = cbhValue.pValue->cbLength;

    //
    // allocate a one dimensional SafeArray of BYTES
    //
    _psa = ::SafeArrayCreate( VT_UI1, 1, _sab );
    if ( _psa != NULL )
    {
        PBYTE   _pb = NULL;

        //
        // get a pointer to the SafeArray
        //
        _hr = ::SafeArrayAccessData( _psa, (PVOID *) &_pb );
        if ( SUCCEEDED( _hr ) )
        {
            CComVariant _var;

            ::CopyMemory( _pb, cbhValue.pBinaryValue->rgb, cbhValue.pValue->cbLength );

            //
            // tell the variant what it is holding onto
            //
            _var.parray = _psa;
            _var.vt     = VT_ARRAY | VT_UI1;

            m_cpvdvData.insert( m_cpvdvData.end(), _var );

            //
            // release the pointer into the SafeArray
            //
            _hr = ::SafeArrayUnaccessData( _psa );
        } // if:
    } // if:

    return _hr;

} //*** CClusPropertyValueData::HrCreateBinary()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropertyValueData::HrBinaryValue
//
//  Description:
//      Set the binary value of this property value data.
//
//  Arguments:
//      psa [IN]    - The SAFEARRY to save.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrBinaryValue( IN SAFEARRAY * psa )
{
    ASSERT( psa != NULL );

    HRESULT _hr = E_POINTER;

    if ( psa != NULL )
    {
        CComVariant _var;

        if ( ! m_cpvdvData.empty() )
        {
            m_cpvdvData.erase( m_cpvdvData.begin() );
        } // if:

        //
        // tell the variant what it is holding onto
        //
        _var.parray = psa;
        _var.vt     = VT_ARRAY | VT_UI1;

        m_cpvdvData.insert( m_cpvdvData.begin(), _var );
        _hr = S_OK;
    } // if:

    return _hr;

} //*** CClusPropertyValueData::HrBinaryValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\propertyvalue.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  Module Name:
//      PropertyValue.h
//
//  Description:
//      Definition of the cluster property value classes for the MSCLUS automation
//      classes.
//
//  Implementation File:
//      PropertyValue.cpp
//
//  Author:
//      Galen Barbee    (GalenB)    16-Dec-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROPERTYVALUE_H__
#define __PROPERTYVALUE_H__

#ifndef _PROPLIST_H_
    #if CLUSAPI_VERSION >= 0x0500
        #include <PropList.h>
    #else
        #include "PropList.h"
    #endif // CLUSAPI_VERSION >= 0x0500
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusPropertyValueData;
class CClusPropertyValue;
class CClusPropertyValues;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropertyValueData
//
//  Description:
//      Cluster Properties Collection Automation Class.
//
//  Inheritance:
//      IDispatchImpl< ISClusPropertyValueData, &IID_ISClusPropertyValueData, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >
//      CSupportErrorInfo
//      CComObjectRootEx< CComSingleThreadModel >
//      CComCoClass< CClusPropertyValueData, &CLSID_ClusPropertyValueData >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPropertyValueData :
    public IDispatchImpl< ISClusPropertyValueData, &IID_ISClusPropertyValueData, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
    public CSupportErrorInfo,
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CClusPropertyValueData, &CLSID_ClusPropertyValueData >
{
    typedef CComObjectRootEx< CComSingleThreadModel >   BaseComClass;

public:
    typedef std::vector< CComVariant >  CClusPropertyValueDataVector;

    CClusPropertyValueData( void );
    ~CClusPropertyValueData( void );

BEGIN_COM_MAP(CClusPropertyValueData)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISClusPropertyValueData)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPropertyValueData)
DECLARE_NO_REGISTRY()

    void Clear( void );

private:
    CClusPropertyValueDataVector    m_cpvdvData;
    DWORD                           m_dwFlags;
    CLUSTER_PROPERTY_FORMAT         m_cpfFormat;

    HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

    HRESULT HrCreateMultiSz( IN CLUSPROP_BUFFER_HELPER cbhValue );

    HRESULT HrCreateBinary( IN CLUSPROP_BUFFER_HELPER cbhValue );

public:
    HRESULT Create( IN VARIANT varValue, IN CLUSTER_PROPERTY_FORMAT cpfFormat, IN BOOL bReadOnly );

    HRESULT Create( IN CLUSPROP_BUFFER_HELPER cbhValue, IN BOOL bReadOnly );

    STDMETHODIMP get_Count( OUT long * plCount );

    STDMETHODIMP get_Item( IN VARIANT varIndex, OUT VARIANT * pvarValue );

    STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

    STDMETHODIMP CreateItem( IN VARIANT varValue, OUT VARIANT * pvarData );

    STDMETHODIMP RemoveItem( IN VARIANT varIndex );

    CComVariant & operator[]( IN int nIndex ) { return m_cpvdvData[ nIndex ]; };

    const CComVariant & operator=( IN const CComVariant & varValue );

    const CClusPropertyValueDataVector & DataList( void ) const { return m_cpvdvData; };

    HRESULT HrFillMultiSzBuffer( OUT LPWSTR * ppsz ) const;

    HRESULT HrBinaryValue( IN SAFEARRAY * psa );
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropertyValue
//
//  Description:
//      Cluster Property Automation Class.
//
//  Inheritance:
//      IDispatchImpl< ISClusPropertyValue, &IID_ISClusPropertyValue, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//      CSupportErrorInfo
//      CComObjectRootEx< CComSingleThreadModel >
//      CComCoClass< CClusPropertyValue, &CLSID_ClusProperty >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPropertyValue :
    public IDispatchImpl< ISClusPropertyValue, &IID_ISClusPropertyValue, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
    public CSupportErrorInfo,
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CClusPropertyValue, &CLSID_ClusPropertyValue >
{
    typedef CComObjectRootEx< CComSingleThreadModel >   BaseComClass;

public:
    CClusPropertyValue( void );
    ~CClusPropertyValue( void );

BEGIN_COM_MAP(CClusPropertyValue)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISClusPropertyValue)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPropertyValue)
DECLARE_NO_REGISTRY()

    HRESULT Create(
                IN VARIANT                  varValue,
                IN CLUSTER_PROPERTY_TYPE    cptType,
                IN CLUSTER_PROPERTY_FORMAT  cpfFormat,
                IN size_t                   cbLength,
                IN BOOL                     bReadOnly
                );

    HRESULT Create( IN CLUSPROP_BUFFER_HELPER cbhValue, IN BOOL bReadOnly );

    STDMETHODIMP get_Value( OUT VARIANT * pvarValue );

    STDMETHODIMP put_Value( IN VARIANT varValue );

    STDMETHODIMP get_Type( OUT CLUSTER_PROPERTY_TYPE * pcptType );

    STDMETHODIMP put_Type( IN CLUSTER_PROPERTY_TYPE cptType );

    STDMETHODIMP get_Format( OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat );

    STDMETHODIMP put_Format( IN CLUSTER_PROPERTY_FORMAT cpfFormat );

    STDMETHODIMP get_Length( OUT long * plLength );

    STDMETHODIMP get_DataCount( OUT long * plCount );

    STDMETHODIMP get_Data( OUT ISClusPropertyValueData ** ppClusterPropertyValueData );

    BOOL Modified( void ) const { return ( m_dwFlags & MODIFIED ); }

    BOOL Modified( IN BOOL bModified );

    const CComVariant & Value( void ) const { return (*m_pcpvdData)[ 0 ]; };

    DWORD CbLength( void ) const {return m_cbLength; };

    CComVariant Value( IN const CComVariant & rvarValue );

    HRESULT HrBinaryValue( IN SAFEARRAY * psa );

    CComObject< CClusPropertyValueData > * Data( void ) const { return m_pcpvdData; };

private:
    DWORD                                   m_dwFlags;
    CLUSTER_PROPERTY_TYPE                   m_cptType;
    CLUSTER_PROPERTY_FORMAT                 m_cpfFormat;
    CComObject< CClusPropertyValueData > *  m_pcpvdData;
    size_t                                  m_cbLength;

};

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropertyValues
//
//  Description:
//      Cluster Properties Collection Automation Class.
//
//  Inheritance:
//      IDispatchImpl< ISClusPropertyValues, &IID_ISClusPropertyValues, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >
//      CSupportErrorInfo
//      CComObjectRootEx< CComSingleThreadModel >
//      CComCoClass< CClusPropertyValues, &CLSID_ClusProperties >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPropertyValues :
    public IDispatchImpl< ISClusPropertyValues, &IID_ISClusPropertyValues, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
    public CSupportErrorInfo,
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CClusPropertyValues, &CLSID_ClusPropertyValues >
{
    typedef CComObjectRootEx< CComSingleThreadModel >   BaseComClass;

public:
    typedef std::vector< CComObject< CClusPropertyValue > * >   CClusPropertyValueVector;

    CClusPropertyValues( void );
    ~CClusPropertyValues( void );

BEGIN_COM_MAP(CClusPropertyValues)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISClusPropertyValues)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPropertyValues)
DECLARE_NO_REGISTRY()

    void Clear( void );

private:
    CClusPropertyValueVector    m_cpvvValues;

    HRESULT HrGetVariantLength( IN const VARIANT rvarValue, OUT PDWORD pcbLength, IN CLUSTER_PROPERTY_FORMAT cpfFormat );

    HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

    HRESULT HrFillPropertyValuesVector( IN OUT CClusPropValueList & cplPropValueList, IN BOOL bReadOnly );

public:
    HRESULT Create( IN const CClusPropValueList & pvlValue, IN BOOL bReadOnly );

    HRESULT Create(
            IN VARIANT                  varValue,
            IN CLUSTER_PROPERTY_TYPE    cptType,
            IN CLUSTER_PROPERTY_FORMAT  cpfFormat,
            IN BOOL                     bReadOnly
            );

    STDMETHODIMP get_Count( OUT long * plCount );

    STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusPropertyValue ** ppPropertyValue );

    STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

    STDMETHODIMP CreateItem( IN BSTR bstrName, IN VARIANT varValue, OUT ISClusPropertyValue ** ppPropertyValue );

    STDMETHODIMP RemoveItem( IN VARIANT varIndex );

    CComObject< CClusPropertyValue > * operator[]( IN int nIndex ) const { return m_cpvvValues[ nIndex ]; };

    DWORD CbLength( void ) const { return m_cpvvValues[ 0 ]->CbLength(); };

    const CClusPropertyValueVector & ValuesList (void ) const { return m_cpvvValues; };

}; //*** Class CClusPropertyValues

#endif // __PROPERTYVALUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msclus.rc
//
#define	IDS_CLUSTER_DESC					1
#define	IDS_CLUSTERAPP_DESC					2
#define	IDS_CLUSVERSION_DESC				3
#define	IDS_DOMAINNAMES_DESC				4
#define	IDS_CLUSGROUPPREFERREDOWNERS_DESC	5
#define	IDS_CLUSGROUPRESOURCES_DESC			6
#define	IDS_CLUSTERNAMES_DESC				7
#define	IDS_CLUSNETINTERFACE_DESC			8
#define	IDS_CLUSNETINTERFACES_DESC			9
#define	IDS_CLUSNETWORK_DESC				10
#define	IDS_CLUSNETWORKS_DESC				11
#define	IDS_CLUSNETWORKNETINTERFACES_DESC	12
#define	IDS_CLUSNODE_DESC					13
#define	IDS_CLUSNODES_DESC					14
#define	IDS_CLUSNODENETINTERFACES_DESC		15
#define	IDS_CLUSPROPERTY_DESC				16
#define	IDS_CLUSPROPERTIES_DESC				17
#define	IDS_CLUSREFOBJECT_DESC				18
#define	IDS_CLUSRESDEPENDENCIES_DESC		19
#define	IDS_CLUSRESGROUP_DESC				20
#define	IDS_CLUSRESGROUPS_DESC				21
#define	IDS_CLUSRESOURCE_DESC				22
#define	IDS_CLUSRESOURCES_DESC				23
#define	IDS_CLUSRESPOSSIBLEOWNERS_DESC		24
#define	IDS_CLUSRESTYPE_DESC				25
#define	IDS_CLUSRESTYPES_DESC				26
#define	IDS_CLUSRESTYPERESOURCES_DESC		27

//#define	IDR_CLUSTER							100
//#define	IDR_CLUSAPPLICATION					101
//#define	IDR_CLUSGROUPOWNERS					102
//#define	IDR_CLUSGROUPRESOURCES				103
//#define	IDR_CLUSTERNAMES					104
//#define	IDR_CLUSNETINTERFACE				105
//#define	IDR_CLUSNETINTERFACES				106
//#define	IDR_CLUSNETWORK						107
//#define	IDR_CLUSNETWORKS					108
//#define	IDR_CLUSNETWORKNETINTERFACES		109
//#define	IDR_CLUSNODE						110
//#define	IDR_CLUSNODES						111
//#define	IDR_CLUSNODENETINTERFACES			112
//#define	IDR_CLUSPROPERTY					113
//#define	IDR_CLUSPROPERTIES					114
//#define	IDR_CLUSREFOBJECT					115
//#define	IDR_CLUSRESDEPENDENCIES				116
//#define	IDR_CLUSRESGROUP					117
//#define	IDR_CLUSRESGROUPS					118
//#define	IDR_CLUSRESOURCE					119
//#define	IDR_CLUSRESOURCES					120
//#define	IDR_ClusResPossibleOwners					121
//#define	IDR_CLUSRESTYPE						122
//#define	IDR_CLUSRESTYPES					123
//#define	IDR_CLUSRESTYPERESOURCES			124
//#define	IDR_CLUSVERSION						125
//#define	IDR_DOMAINNAMES						126
#define	IDR_MSCLUS							127

// Next	default	values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef	APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE		201
#define _APS_NEXT_COMMAND_VALUE			32768
#define _APS_NEXT_CONTROL_VALUE			201
#define _APS_NEXT_SYMED_VALUE			128
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\partition.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Partition.cpp
//
//  Description:
//      Implementation of the cluster disk partition class for the MSCLUS
//      automation classes.
//
//  Author:
//      Galen Barbee    (galenb)    10-Feb-1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Partition.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusPartition[] =
{
    &IID_ISClusPartition
};

static const IID *  iidCClusPartitions[] =
{
    &IID_ISClusPartitions
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPartition class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::CClusPartition
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPartition::CClusPartition( void )
{
    m_piids     = (const IID *) iidCClusPartition;
    m_piidsSize = ARRAYSIZE( iidCClusPartition );

    ZeroMemory( &m_cpi, sizeof( m_cpi ) );

} //*** CClusPartition::CClusPartition()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::Create
//
//  Description:
//      Finish creating this object.
//
//  Arguments:
//      pcpi    [IN]    - points to the CLUS_PARTITION_INFO struct.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPartition::Create( IN CLUS_PARTITION_INFO * pcpi )
{
    ASSERT( pcpi != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcpi != NULL )
    {
        m_cpi = *pcpi;
        _hr = S_OK;
    } // if: pcpi != NULL

    return _hr;

} //*** CClusPartition::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_Flags
//
//  Description:
//      Get the dwFlags field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      plFlags [OUT]   - catches the dwFlags field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_Flags( OUT long * plFlags )
{
    //ASSERT( plFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( plFlags != NULL )
    {
        *plFlags = m_cpi.dwFlags;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_Flags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_DeviceName
//
//  Description:
//      Get the szDeviceName field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      pbstrDeviceName [OUT]   - catches the szDeviceName field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_DeviceName( OUT BSTR * pbstrDeviceName )
{
    //ASSERT( pbstrDeviceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrDeviceName != NULL )
    {
        *pbstrDeviceName = SysAllocString( m_cpi.szDeviceName );
        if ( *pbstrDeviceName == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusPartition::get_DeviceName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_VolumeLabel
//
//  Description:
//      Get the szVolumeLabel field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      pbstrVolumeLabel [OUT]  - catches the szVolumeLabel field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_VolumeLabel(
    OUT BSTR * pbstrVolumeLabel
    )
{
    //ASSERT( pbstrVolumeLabel != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrVolumeLabel != NULL )
    {
        *pbstrVolumeLabel = SysAllocString( m_cpi.szVolumeLabel );
        if ( *pbstrVolumeLabel == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusPartition::get_VolumeLabel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_SerialNumber
//
//  Description:
//      Get the dwSerialNumber field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      plSerialNumber [OUT]    - catches the dwSerialNumber field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_SerialNumber(
    OUT long * plSerialNumber
    )
{
    //ASSERT( plSerialNumber != NULL );

    HRESULT _hr = E_POINTER;

    if ( plSerialNumber != NULL )
    {
        *plSerialNumber = m_cpi.dwSerialNumber;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_SerialNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_MaximumComponentLength
//
//  Description:
//      Get the dwMaximumComponentLength field from the CLUS_PARTITION_INFO
//      struct.
//
//  Arguments:
//      plMaximumComponentLength [OUT]  - catches the dwMaximumComponentLength
//                                      field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_MaximumComponentLength(
    OUT long * plMaximumComponentLength
    )
{
    //ASSERT( plMaximumComponentLength != NULL );

    HRESULT _hr = E_POINTER;

    if ( plMaximumComponentLength != NULL )
    {
        *plMaximumComponentLength = m_cpi.rgdwMaximumComponentLength;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_MaximumComponentLength()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_FileSystemFlags
//
//  Description:
//      Get the dwFileSystemFlags field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      plFileSystemFlags [OUT] - catches the dwFileSystemFlags field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_FileSystemFlags(
    OUT long * plFileSystemFlags
    )
{
    //ASSERT( plFileSystemFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( plFileSystemFlags != NULL )
    {
        *plFileSystemFlags = m_cpi.dwFileSystemFlags;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_FileSystemFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_FileSystem
//
//  Description:
//      Get the szFileSystem field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      pbstrFileSystem [OUT]   - catches the szFileSystem field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_FileSystem( OUT BSTR * pbstrFileSystem )
{
    //ASSERT( pbstrFileSystem != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrFileSystem != NULL )
    {
        *pbstrFileSystem = SysAllocString( m_cpi.szFileSystem );
        if ( *pbstrFileSystem == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusPartition::get_FileSystem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPartitions class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::CClusPartitions
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPartitions::CClusPartitions( void )
{
    m_piids             = (const IID *) iidCClusPartitions;
    m_piidsSize         = ARRAYSIZE( iidCClusPartitions );

} //*** CClusPartitions::CClusPartitions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::~CClusPartitions
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPartitions::~CClusPartitions( void )
{
    Clear();

} //*** CClusPartitions::~CClusPartitions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::HrCreateItem
//
//  Description:
//      Create and add a partition to the collection.
//
//  Arguments:
//      rcpvl   [IN]    - value list of partition(s).
//
//  Return Value:
//      S_OK if successful, or HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPartitions::HrCreateItem( IN CLUS_PARTITION_INFO * pcpi )
{
    ASSERT( pcpi != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcpi != NULL )
    {
        CComObject< CClusPartition > *  _pPartition = NULL;

        _hr = CComObject< CClusPartition >::CreateInstance( &_pPartition );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusPartition > >   _ptrPartition( _pPartition );

            _hr = _ptrPartition->Create( pcpi );
            if ( SUCCEEDED( _hr ) )
            {
                m_pvPartitions.insert( m_pvPartitions.end(), _pPartition );
                _ptrPartition->AddRef();
            } // if:
        } // if:
    } // if:

    return _hr;

} //*** CClusPartitions::HrCreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::GetIndex
//
//  Description:
//      Convert the passed in 1 based index into a 0 based index.
//
//  Arguments:
//      varIndex    [IN]    - the 1 based index.
//      pnIndex     [OUT]   - the 0 based index
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the index is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPartitions::GetIndex( VARIANT varIndex, UINT * pnIndex )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--;                       // Adjust index to be 0 relative instead of 1 relative

            if ( nIndex < m_pvPartitions.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusPartitions::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::get_Count
//
//  Description:
//      Returns the count of elements (Partitions) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartitions::get_Count(
    long * plCount
    )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_pvPartitions.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartitions::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::Clear
//
//  Description:
//      Clean out the vector of ClusPartition objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPartitions::Clear( void )
{
    ::ReleaseAndEmptyCollection< PartitionVector, CComObject< CClusPartition > >( m_pvPartitions );

} //*** CClusPartitions::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::get_Item
//
//  Description:
//      Returns the object (Partition) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number, or
//                          a string that is the name of the group to get.
//      ppPartition [OUT]   - Catches the partition
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartitions::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusPartition **  ppPartition
    )
{
    //ASSERT( ppPartition != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppPartition != NULL )
    {
        CComObject< CClusPartition > * pPartition = NULL;

        // Zero the out param
        *ppPartition = NULL;

        UINT nIndex = 0;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pPartition = m_pvPartitions[ nIndex ];
            _hr = pPartition->QueryInterface( IID_ISClusPartition, (void **) ppPartition );
        }
    }

    return _hr;

} //*** CClusPartitions::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartitions::get__NewEnum(
    IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< PartitionVector, CComObject< CClusPartition > >( ppunk, m_pvPartitions );

} //*** CClusPartitions::get__NewEnum()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\property.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  Module Name:
//      Property.h
//
//  Description:
//      Definition of the cluster property classes for the MSCLUS automation
//      classes.
//
//  Implementation File:
//      Property.cpp
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROPERTY_H__
#define __PROPERTY_H__

#ifndef _PROPLIST_H_
    #if CLUSAPI_VERSION >= 0x0500
        #include <PropList.h>
    #else
        #include "PropList.h"
    #endif // CLUSAPI_VERSION >= 0x0500
#endif

/////////////////////////////////////////////////////////////////////////////
// Global defines
/////////////////////////////////////////////////////////////////////////////
#define READONLY    0x00000001      // is this property read only?
#define PRIVATE     0x00000002      // is this a private property?
#define MODIFIED    0x00000004      // has this property been modified?
#define USEDEFAULT  0x00000008      // this property has been deleted.

#ifndef __PROPERTYVALUE_H__
    #include "PropertyValue.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusProperty;
class CClusProperties;
class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusProperty
//
//  Description:
//      Cluster Property Automation Class.
//
//  Inheritance:
//      IDispatchImpl< ISClusProperty, &IID_ISClusProperty, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//      CSupportErrorInfo
//      CComObjectRootEx< CComSingleThreadModel >
//      CComCoClass< CClusProperty, &CLSID_ClusProperty >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusProperty :
    public IDispatchImpl< ISClusProperty, &IID_ISClusProperty, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
    public CSupportErrorInfo,
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CClusProperty, &CLSID_ClusProperty >
{
    typedef CComObjectRootEx< CComSingleThreadModel >   BaseComClass;

public:
    CClusProperty( void );
    ~CClusProperty( void );

BEGIN_COM_MAP(CClusProperty)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISClusProperty)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusProperty)
DECLARE_NO_REGISTRY()

private:
    DWORD                               m_dwFlags;
    CComBSTR                            m_bstrName;
    CComObject< CClusPropertyValues > * m_pValues;

    HRESULT HrBinaryCompare( IN const CComVariant rvarOldValue, IN const VARIANT & rvarValue, OUT BOOL * pbEqual );

    HRESULT HrCoerceVariantType( IN CLUSTER_PROPERTY_FORMAT cpfFormat, IN OUT VARIANT & rvarValue );

    HRESULT HrConvertVariantTypeToClusterFormat(
                            IN  const VARIANT &             rvar,
                            IN  VARTYPE                     varType,
                            OUT CLUSTER_PROPERTY_FORMAT *   pcpfFormat
                            );

    HRESULT HrCreateValuesCollection( IN const CClusPropValueList & pvlValue );

    HRESULT HrCreateValuesCollection(
                            IN VARIANT                  varValue,
                            IN CLUSTER_PROPERTY_TYPE    cptType,
                            IN CLUSTER_PROPERTY_FORMAT  cpfFormat
                            );

    HRESULT HrSaveBinaryProperty( IN CComObject< CClusPropertyValue > * pPropValue, IN const VARIANT & rvarValue );

public:
    HRESULT Create( IN BSTR bstrName, IN VARIANT varValue, IN BOOL bPrivate, IN BOOL bReadOnly );

    HRESULT Create(
            IN BSTR                         bstrName,
            IN const CClusPropValueList &   varValue,
            IN BOOL                         bPrivate,
            IN BOOL                         bReadOnly
            );

    STDMETHODIMP get_Name( OUT BSTR * pbstrName );

    STDMETHODIMP put_Name( IN BSTR bstrName );

    STDMETHODIMP get_Type( OUT CLUSTER_PROPERTY_TYPE * pcptType );

    STDMETHODIMP put_Type( IN CLUSTER_PROPERTY_TYPE cptType );

    STDMETHODIMP get_Value( OUT VARIANT * pvarValue );

    STDMETHODIMP put_Value( IN VARIANT varValue );

    STDMETHODIMP get_Format( OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat );

    STDMETHODIMP put_Format( IN CLUSTER_PROPERTY_FORMAT cpfFormat );

    STDMETHODIMP get_Length( OUT long * plLength );

    STDMETHODIMP get_ValueCount( OUT long * plCount );

    STDMETHODIMP get_Values( OUT ISClusPropertyValues ** ppClusterPropertyValues );

    STDMETHODIMP get_ReadOnly( OUT VARIANT * pvarReadOnly );

    STDMETHODIMP get_Private( OUT VARIANT * pvarPrivate );

    STDMETHODIMP get_Common( OUT VARIANT * pvarCommon );

    STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

    BOOL Modified( void ) const { return ( m_dwFlags & MODIFIED ); }

    BOOL Modified( BOOL bModified );

    const BSTR Name( void ) const { return m_bstrName; }

    DWORD CbLength( void ) const { return (*m_pValues)[ 0 ]->CbLength(); }

    const CComVariant & Value( void ) const { return (*m_pValues)[ 0 ]->Value(); }

    const CComObject< CClusPropertyValues > & Values( void ) const { return *m_pValues; }

    STDMETHODIMP UseDefaultValue( void );

    BOOL IsDefaultValued( void ) const { return ( m_dwFlags & USEDEFAULT ); };

}; //*** Class CClusProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusProperties
//
//  Description:
//      Cluster Properties Collection Automation Class.
//
//  Inheritance:
//      IDispatchImpl< ISClusProperties, &IID_ISClusProperties, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >
//      CSupportErrorInfo
//      CComObjectRootEx< CComSingleThreadModel >
//      CComCoClass< CClusProperties, &CLSID_ClusProperties >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusProperties :
    public IDispatchImpl< ISClusProperties, &IID_ISClusProperties, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
    public CSupportErrorInfo,
    public CComObjectRootEx< CComSingleThreadModel >,
    public CComCoClass< CClusProperties, &CLSID_ClusProperties >
{
    typedef CComObjectRootEx< CComSingleThreadModel >   BaseComClass;

public:
    typedef std::vector< CComObject< CClusProperty > * >    CClusPropertyVector;

    CClusProperties( void );
    ~CClusProperties( void );

BEGIN_COM_MAP(CClusProperties)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISClusProperties)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusProperties)
DECLARE_NO_REGISTRY()

    void Clear( void );

private:
    CClusPropertyVector m_Properties;
    CClusterObject *    m_pcoParent;
    DWORD               m_dwFlags;

    HRESULT FindItem( IN LPWSTR lpszPropName, OUT UINT * pnIndex );

    HRESULT FindItem( IN ISClusProperty * pProperty, OUT UINT * pnIndex );

    HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

    HRESULT HrFillPropertyVector( IN OUT CClusPropList & PropList );

//  HRESULT RemoveAt( IN size_t nPos );

public:
    HRESULT Create( IN CClusterObject * pcoParent, IN BOOL bPrivateProps, IN BOOL bReadOnly );

    STDMETHODIMP get_Count( OUT long * plCount );

    STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusProperty ** ppProperty );

    STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

    STDMETHODIMP CreateItem( IN BSTR bstrName, VARIANT varValue, OUT ISClusProperty ** ppProperty );

    STDMETHODIMP UseDefaultValue( IN VARIANT varIndex );

    STDMETHODIMP Refresh( void );

    STDMETHODIMP SaveChanges( OUT VARIANT * pvarStatusCode );

    STDMETHODIMP get_ReadOnly( OUT VARIANT * pvarReadOnly );

    STDMETHODIMP get_Private( OUT VARIANT * pvarPrivate );

    STDMETHODIMP get_Common( OUT VARIANT * pvarCommon );

    STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

}; //*** Class CClusProperties

HRESULT HrSafeArraySizeof( SAFEARRAY * psa, unsigned int nDimension, long * pcElements );

#endif // __PROPERTY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		StdAfx.cpp
//
//	Description:
//		Pre-compiled header source file.
//
//	Author:
//		Charles	Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\smarthandle.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2002 Microsoft Corporation
//
//	Module Name:
//		SmartHandle.h
//
//	Description:
//		Refcounted Handles
//
//	Author:
//		Gor Nishanov (gorn) 05-Apr-2002
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SMARTHANDLE_H__
#define __SMARTHANDLE_H__

template< class T > class CRefCountedHandle 
{
private:

	typename T::Type	m_handle;
	LONG			m_refcount;

	CRefCountedHandle(typename T::Type handle):
		m_handle(handle), m_refcount(0)
	{
	}

	~CRefCountedHandle()
	{
		T::Close(m_handle);
	}

public:

	static CRefCountedHandle* Create(typename T::Type handle) 
	{
		return new CRefCountedHandle(handle);
	}

	typename T::Type get_Handle() const 
	{
		return m_handle;
	}

	void AddRef()
	{
		InterlockedIncrement(&m_refcount);
	}

	void Release() 
	{
		if (InterlockedDecrement(&m_refcount) == 0) 
		{
			delete this;
		}
	}

};

struct GroupHandle 
{
    typedef HGROUP Type;
    static void Close(Type& handle) { ::CloseClusterGroup(handle); }
};

typedef CSmartPtr< CRefCountedHandle<GroupHandle> > CRefcountedHGROUP;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\version.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		Version.h
//
//	Description:
//		Definition of the cluster version classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		Version.cpp
//
//	Author:
//		Galen Barbee	(galenb)	26-Oct-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VERSION_H_
#define __VERSION_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusVerion;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluster
//
//	Description:
//		Cluster Version Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusVersion, &IID_ISClusVersion, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusVersion, &CLSID_ClusVersion >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusVersion :
	public IDispatchImpl< ISClusVersion, &IID_ISClusVersion, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusVersion, &CLSID_ClusVersion >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusVersion( void );

BEGIN_COM_MAP(CClusVersion)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusVersion)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusVersion)
DECLARE_NO_REGISTRY()

private:

	CComBSTR						m_bstrClusterName;
	CSmartPtr< ISClusRefObject >	m_ptrClusRefObject;
	CLUSTERVERSIONINFO				m_clusinfo;

public:
	HRESULT Create( IN ISClusRefObject * pClusRefObject );

	STDMETHODIMP get_Name( OUT BSTR * pbstrClusterName );

	STDMETHODIMP get_VendorId( OUT BSTR * pbstrVendorId );

	STDMETHODIMP get_CSDVersion( OUT BSTR * pbstrCSDVersion );

	STDMETHODIMP get_MajorVersion( OUT long * pnMajorVersion );

	STDMETHODIMP get_MinorVersion( OUT long * pnMinorVersion );

	STDMETHODIMP get_BuildNumber( OUT short * pnBuildNumber );

	STDMETHODIMP get_ClusterHighestVersion( OUT long * pnClusterHighestVersion );

	STDMETHODIMP get_ClusterLowestVersion( OUT long * pnClusterLowestVersion );

	STDMETHODIMP get_Flags( OUT long * pnFlags );

	STDMETHODIMP get_MixedVersion( OUT VARIANT * pvarMixedVersion );

}; //*** Class CClusVersion

#endif // __VERSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\supporterrorinfo.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      SupportErrorInfo.h
//
//  Description:
//      Definition of the CSupportErrorInfo class.
//
//  Implementation File:
//
//
//  Author:
//      Galen Barbee    (galenb)    4-Aug-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SUPPORTERRORINFO_H
#define _SUPPORTERRORINFO_H

#ifndef ARRAYSIZE
    #define ARRAYSIZE(_x)    RTL_NUMBER_OF(_x)
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CSupportErrorInfo;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSupportErrorInfo
//
//  Description:
//      Implementation of the InterfaceSupportsErrir Info
//
//  Inheritance:
//      ISupportErrorInfo
//
//--
/////////////////////////////////////////////////////////////////////////////
class CSupportErrorInfo :
    public ISupportErrorInfo
{
public:
    CSupportErrorInfo( void ) : m_piids( NULL ), m_piidsSize( 0 ) {};
//  ~CSupportErrorInfo( void ) {};

    STDMETHODIMP InterfaceSupportsErrorInfo( REFIID riid )
    {
        ASSERT( m_piids != NULL );
        ASSERT( m_piidsSize != 0 );

        HRESULT _hr = S_FALSE;

        if ( m_piids != NULL )
        {
            for ( size_t i = 0; i < m_piidsSize; i++ )
            {
                if ( InlineIsEqualGUID( m_piids[ i ], riid ) )
                {
                    _hr =  S_OK;
                    break;
                }
            }
        }

        return _hr;

    }

protected:
    const IID * m_piids;
    size_t      m_piidsSize;

};  //*** Class CSupportErrorInfo

#endif // _SUPPORTERRORINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		StdAfx.h
//
//	Description:
//		Pre-compiled header file.
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _STDAFX_H_
#define _STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// Enable cluster debug reporting
//
#if DBG
	#define CLRTL_INCLUDE_DEBUG_REPORTING
#endif // DBG

#if CLUSAPI_VERSION >= 0x0500
	#include "ClRtlDbg.h"
	#define ASSERT _CLRTL_ASSERTE
	#define ATLASSERT ASSERT
#else
	#undef ASSERT
	#define ASSERT _ASSERTE
#endif

#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _ATL_DEBUG_QI
#define	_ATL_DEBUG_REFCOUNT
#define	_CRTDBG_MAP_ALLOC
#endif

#ifdef _ATL_DEBUG_REFCOUNT
	#define	Release	_DebugRelease
	#define	AddRef	_DebugAddRef
#endif

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include <comdef.h>
#include <vector>
#include <clusapi.h>

extern "C"
{
	#include <lmaccess.h>
	#include <lmwksta.h>
	#include <lmapibuf.h>
	#include <lm.h>
	#include <ntsecapi.h>
}

#if CLUSAPI_VERSION >= 0x0500
	#include <DsGetDC.h>
	#include <cluswrap.h>
#else
	#include "cluswrap.h"
#endif // CLUSAPI_VERSION >= 0x0500

#include "InterfaceVer.h"
#include "SmartPointer.h"
#include "SmartHandle.h"
#include "SupportErrorInfo.h"
#include "msclus.h"

HRESULT HrGetCluster( OUT ISCluster ** ppCluster, IN ISClusRefObject * pClusRefObject );

void ClearIDispatchEnum( IN OUT CComVariant ** ppvarVect );

void ClearVariantEnum( IN OUT CComVariant ** ppvarVect );

#include "TemplateFuncs.h"

#endif	// _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\smartpointer.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmartPointer.h
//
//	Description:
//		Smart pointer template class
//
//	Author:
//		Galen Barbee (galenb) 19-Oct-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SMARTPOINTER_H__
#define __SMARTPOINTER_H__

/////////////////////////////////////////////////////////////////////////////
//+++
//
//	class:	CSmartPtr
//
//	Description:
//		This class template is used to encapsulate pointers to interfaces,
//		but in simpler way than com_ptr_t. We do not want exceptions
//		to be thrown on com errors (as com_ptr_t does) (except Release).
//		Instead, we want to process them on our own, yet still have an advantage
//		of proper cleaning upon destruction. Using it significantly simplifies
//		test code.
//
//	Inheritance:
//		None.
//---
/////////////////////////////////////////////////////////////////////////////
template< class T > class CSmartPtr
{
private:
	T * m_tPtr;

	void * operator new( size_t );
	void * operator new( size_t, void * );
	void   operator delete( void * );

public:
	__declspec(nothrow) CSmartPtr( T * ptr )
	{
		if ( ( m_tPtr = ptr) != NULL )
		{
			m_tPtr->AddRef();
		}
	}

	__declspec(nothrow) CSmartPtr( const CSmartPtr< T > & ptr )
	{
		if ( ( m_tPtr = ptr.m_tPtr ) != NULL )
		{
			m_tPtr->AddRef();
		}
	}

	__declspec(nothrow) CSmartPtr( void )
	{
		m_tPtr = NULL;
	}

	~CSmartPtr( void ) throw( _com_error )
	{
		if ( m_tPtr != NULL )
		{
			m_tPtr->Release();
			m_tPtr = NULL;
		}
	}

	__declspec(nothrow) T ** operator&() const
	{
		return &m_tPtr;
	}

	__declspec(nothrow) T * operator->() const
	{
		return m_tPtr;
	}

	__declspec(nothrow) operator T * () const
	{
		return m_tPtr;
	}

	__declspec(nothrow) T * operator=( T * ptr )
	{
		if ( m_tPtr != NULL )
		{
			m_tPtr->Release();
			m_tPtr = NULL;
		}

		if ( ( m_tPtr = ptr ) != NULL )
		{
			m_tPtr->AddRef();
		}

		return m_tPtr;
	}

	__declspec(nothrow) T * operator=( const CSmartPtr< T >& ptr )
	{
		if ( m_tPtr != ptr.m_tPtr ) 
		{
			operator=(ptr.m_tPtr);
		}

		return m_tPtr;
	}

	__declspec(nothrow) bool operator==( T * ptr ) const
	{
		return m_tPtr == ptr;
	}

	__declspec(nothrow) bool operator!=( T * ptr ) const
	{
		return m_tPtr != ptr;
	}

	//
	// This is the only non-conforming operator in this class.
	//
	__declspec(nothrow) T * operator*() const
	{
		return m_tPtr;
	}

}; //*** Class CSmartPtr

#endif // __SMARTPOINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\templatefuncs.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		TemplateFuncs.h
//
//	Description:
//		Template function implementations.
//
//	Author:
//		Galen Barbee	(galenb)	09-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TEMPLATEFUNCS_H_
#define _TEMPLATEFUNCS_H_

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrNewIDispatchEnum
//
//	Description:
//		Create a new Enumerator of IDispatch objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//		TObject		- Type of the objects in the container.
//
//	Arguments:
//		ppunk		[OUT]	- catches the enumerator.
//		rCollection	[IN]	- Implementatoin collection to make the
//							enumerator from.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TObject >
HRESULT HrNewIDispatchEnum(
	OUT	IUnknown **			ppunk,
	IN	const TCollection &	rCollection
	)
{
	ASSERT( ppunk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppunk != NULL )
	{
		TObject *					_pObject= NULL;
		size_t						_cObjects = rCollection.size();
		size_t						_iIndex;
		LPDISPATCH					_lpDisp;
		TCollection::const_iterator	_itFirst = rCollection.begin();
		TCollection::const_iterator	_itLast  = rCollection.end();
		CComVariant *				_pvarVect = NULL;

		*ppunk = NULL;

		_pvarVect = new CComVariant[ _cObjects ];
		if ( _pvarVect != NULL )
		{
			for ( _iIndex = 0; _itFirst != _itLast; _iIndex++, _itFirst++ )
			{
				_lpDisp	= NULL;
				_pObject	= NULL;

				_pObject = *_itFirst;
				_hr = _pObject->QueryInterface( IID_IDispatch, (void **) &_lpDisp );
				if ( SUCCEEDED( _hr ) )
				{
					//
					// create a variant and add it to the collection
					//
					CComVariant & var = _pvarVect[ _iIndex ];

					var.vt = VT_DISPATCH;
					var.pdispVal = _lpDisp;
				}
			} // for: each node in the list

			CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > > *	_pEnum;

			_pEnum = new CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > >;
			if ( _pEnum != NULL )
			{
				_hr = _pEnum->Init( &_pvarVect[ 0 ], &_pvarVect[ _cObjects ], NULL, AtlFlagCopy );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pEnum->QueryInterface( IID_IEnumVARIANT, (void **) ppunk );
				}
				else
				{
					delete _pEnum;
				}
			}
			else
			{
				_hr = E_OUTOFMEMORY;
			}

			ClearIDispatchEnum( &_pvarVect );
		}
		else
		{
			_hr = E_OUTOFMEMORY;
		}
	}

	return _hr;

} //*** HrNewIDispatchEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReleaseAndEmptyCollection
//
//	Description:
//		Clean out the passed in STL container by releasing it's references
//		on the contained objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//		TObject		- Type of the objects in the container.
//
//	Arguments:
//		rCollection	[IN OUT]	- STL container instance to clear.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TObject >
void ReleaseAndEmptyCollection(
	IN OUT	TCollection & rCollection
	)
{
	if ( !rCollection.empty() )
	{
		TObject *				_pObject = NULL;
		TCollection::iterator	_itFirst = rCollection.begin();
		TCollection::iterator	_itLast  = rCollection.end();

		for ( ; _itFirst != _itLast; _itFirst++ )
		{
			_pObject = *_itFirst;
			if ( _pObject != NULL )
			{
				_pObject->Release();
			} // if: we have an object
		} // for: each object in the collection

		rCollection.erase( rCollection.begin(), _itLast );
	} // if: the collection is not empty

} //*** ReleaseAndEmptyCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrNewVariantEnum
//
//	Description:
//		Create a new Enumerator of VARIANT objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//
//	Arguments:
//		ppunk		[OUT]	- catches the enumerator.
//		rCollection	[IN]	- Implementatoin collection to make the
//							enumerator from.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection >
STDMETHODIMP HrNewVariantEnum(
	OUT	IUnknown ** 		ppunk,
	IN	const TCollection &	rCollection
	)
{
	ASSERT( ppunk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppunk != NULL )
	{
		TCollection::const_iterator	_itFirst = rCollection.begin();
		TCollection::const_iterator	_itLast  = rCollection.end();
		size_t						_iIndex;
		size_t						_cVariants = rCollection.size();
		CComVariant *				_pvarVect = NULL;

		*ppunk = NULL;

		_pvarVect = new CComVariant[ _cVariants ];
		if ( _pvarVect != NULL )
		{
			for ( _iIndex = 0; _itFirst != _itLast; _iIndex++, _itFirst++ )
			{
				_pvarVect[ _iIndex ] = *_itFirst;
			}

			CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > > * _pEnum;

			_pEnum = new CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > >;
			if ( _pEnum != NULL )
			{
				_hr = _pEnum->Init( &_pvarVect[ 0 ], &_pvarVect[ _cVariants ], NULL, AtlFlagCopy );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pEnum->QueryInterface( IID_IEnumVARIANT, (void **) ppunk );
				}
				else
				{
					delete _pEnum;
				}
			}
			else
			{
				_hr = E_OUTOFMEMORY;
			}

			ClearVariantEnum( &_pvarVect );
		}
		else
		{
			_hr = E_OUTOFMEMORY;
		}
	}

	return _hr;

} //*** HrNewVariantEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrNewCComBSTREnum
//
//	Description:
//		Create a new Enumerator of CComBSTR objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//
//	Arguments:
//		ppunk		[OUT]	- catches the enumerator.
//		rCollection	[IN]	- Implementatoin collection to make the
//							enumerator from.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection >
STDMETHODIMP HrNewCComBSTREnum(
	OUT	IUnknown ** 		ppunk,
	IN	const TCollection &	rCollection
	)
{
	ASSERT( ppunk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppunk != NULL )
	{
		TCollection::const_iterator	_itFirst = rCollection.begin();
		TCollection::const_iterator	_itLast  = rCollection.end();
		size_t						_iIndex;
		size_t						_cVariants = rCollection.size();
		CComVariant *				_pvarVect = NULL;

		*ppunk = NULL;

		_pvarVect = new CComVariant[ _cVariants ];
		if ( _pvarVect != NULL )
		{
			for ( _iIndex = 0; _itFirst != _itLast; _iIndex++, _itFirst++ )
			{
				_pvarVect[ _iIndex ].bstrVal	= (*_itFirst)->Copy();;
				_pvarVect[ _iIndex ].vt			= VT_BSTR;
			} // for:

			CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > > * _pEnum;

			_pEnum = new CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > >;
			if ( _pEnum != NULL )
			{
				_hr = _pEnum->Init( &_pvarVect[ 0 ], &_pvarVect[ _cVariants ], NULL, AtlFlagCopy );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pEnum->QueryInterface( IID_IEnumVARIANT, (void **) ppunk );
				}
				else
				{
					delete _pEnum;
				}
			}
			else
			{
				_hr = E_OUTOFMEMORY;
			}

			ClearVariantEnum( &_pvarVect );
		}
		else
		{
			_hr = E_OUTOFMEMORY;
		}
	}

	return _hr;

} //*** HrNewCComBSTREnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation argument.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		ppCollection	[OUT]	- Catches the new collection implementation.
//		tHandle			[IN]	- Passed to the objects Create method.
//		ppInterface		[OUT]	- Catches the new collection interface.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	CComObject< TCollection > **	ppCollection,
	IN	THandle							tHandle,
	OUT	TInterface **					ppInterface,
	IN	IID								iid,
	IN	ISClusRefObject *				pClusRefObject
	)
{
	ASSERT( ppCollection != NULL );
	ASSERT( tHandle != NULL );
//	ASSERT( ppInterface != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppCollection != NULL ) && ( ppInterface != NULL ) && ( pClusRefObject != NULL ) && ( tHandle != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		if ( *ppCollection == NULL )
		{
			CComObject< TCollection > *	pCollection = NULL;

			_hr = CComObject< TCollection >::CreateInstance( &pCollection );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
				CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

				_hr = ptrCollection->Create( ptrRefObject, tHandle );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrCollection->Refresh();
					if ( SUCCEEDED( _hr ) )
					{
						*ppCollection = ptrCollection;
						ptrCollection->AddRef();
					} // if: Refresh OK
				} // if: Create OK
			} // if: CreateInstance OK
		} // if: do we need to create a new collection?

		if ( SUCCEEDED( _hr ) )
		{
			_hr = (*ppCollection)->QueryInterface( iid, (void **) ppInterface );
		} // if: we have, or successfully made a collection
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation argument.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		ppInterface		[OUT]	- Catches the new collection interface.
//		tHandle			[IN]	- Passed to the objects Create method.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	TInterface **		ppInterface,
	IN	THandle				tHandle,
	IN	IID					iid,
	IN	ISClusRefObject *	pClusRefObject
	)
{
	ASSERT( ppInterface != NULL );
	ASSERT( tHandle != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppInterface != NULL ) && ( pClusRefObject != NULL ) && ( tHandle != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		CComObject< TCollection > *	pCollection = NULL;

		_hr = CComObject< TCollection >::CreateInstance( &pCollection );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
			CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

			_hr = ptrCollection->Create( ptrRefObject, tHandle );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCollection->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pCollection->QueryInterface( iid, (void **) ppInterface );
				} // if: Refresh OK
			} // if: Create OK
		} // if: CreateInstance OK
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation to make.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		ppInterface		[OUT]	- Catches the new collection interface.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	TInterface **		ppInterface,
	IN	IID					iid,
	IN	ISClusRefObject *	pClusRefObject
	)
{
	//ASSERT( ppInterface != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppInterface != NULL ) && ( pClusRefObject != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		CComObject< TCollection > *	pCollection = NULL;

		_hr = CComObject< TCollection >::CreateInstance( &pCollection );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
			CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

			_hr = ptrCollection->Create( ptrRefObject );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCollection->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pCollection->QueryInterface( iid, (void **) ppInterface );
				} // if: Refresh OK
			} // if: Create OK
		} // if: CreateInstance OK
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation argument.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Not used.  Simply here because the Alpha compiler is broken.
//
//	Arguments:
//		ppCollection	[OUT]	- Catches the new collection implementation.
//		ppInterface		[OUT]	- Catches the new collection interface.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	CComObject< TCollection > **	ppCollection,
	OUT	TInterface **					ppInterface,
	IN	IID								iid,
	IN	ISClusRefObject *				pClusRefObject
	)
{
	ASSERT( ppCollection != NULL );
	//ASSERT( ppInterface != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppCollection != NULL ) && ( ppInterface != NULL ) && ( pClusRefObject != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		if ( *ppCollection == NULL )
		{
			CComObject< TCollection > *	pCollection = NULL;

			_hr = CComObject< TCollection >::CreateInstance( &pCollection );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
				CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

				_hr = ptrCollection->Create( ptrRefObject );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrCollection->Refresh();
					if ( SUCCEEDED( _hr ) )
					{
						*ppCollection = ptrCollection;
						ptrCollection->AddRef();
					} // if: Refresh OK
				} // if: Create OK
			} // if: CreateInstance OK
		} // if: do we need to create a new collection?

		if ( SUCCEEDED( _hr ) )
		{
			_hr = (*ppCollection)->QueryInterface( iid, (void **) ppInterface );
		} // if: we have, or successfully made a collection
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation to make.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		tHandle		[IN]	- Passed to the collection' create method.
//		ppInterface	[OUT]	- Catches the new collection interface.
//		iid			[IN]	- IID of the interface to QI for.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	IN	THandle				tHandle,
	OUT	TInterface **		ppInterface,
	IN	IID					iid
	)
{
	//ASSERT( ppInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppInterface != NULL )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		CComObject< TCollection > *	pCollection = NULL;

		_hr = CComObject< TCollection >::CreateInstance( &pCollection );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

			_hr = ptrCollection->Create( tHandle );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCollection->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pCollection->QueryInterface( iid, (void **) ppInterface );
				} // if: Refresh OK
			} // if: Create OK
		} // if: CreateInstance OK
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

#endif	// _TEMPLATEFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\version.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      Version.cpp
//
//  Description:
//      Implementation of the cluster version classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Galen Barbee    (galenb)    26-Oct-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "version.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusVersion[] =
{
    &IID_ISClusVersion
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusVersion class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::CClusVersion
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusVersion::CClusVersion( void )
{
    m_piids     = (const IID *) iidCClusVersion;
    m_piidsSize = ARRAYSIZE( iidCClusVersion );

    ZeroMemory( &m_clusinfo, sizeof( m_clusinfo ) );
    m_clusinfo.dwVersionInfoSize = sizeof( m_clusinfo );

}   //*** CClusVersion::CClusVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::Create
//
//  Description:
//      Finish creating this object from the data in the cluster.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful, other HRESULT error, or other Win32 error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusVersion::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        HCLUSTER    _hCluster = NULL;

        m_ptrClusRefObject = pClusRefObject;

        _hr = m_ptrClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            LPWSTR  _pwszName = NULL;
            DWORD   _sc;

            _sc = ::WrapGetClusterInformation( _hCluster, &_pwszName, &m_clusinfo );
            if ( _sc == ERROR_SUCCESS )
            {
                m_bstrClusterName = _pwszName;
                ::LocalFree( _pwszName );
                _pwszName = NULL;
            } // if: WrapGetClusterInformation OK

            _hr = HRESULT_FROM_WIN32( _sc );
        } //if: get cluster handle
    } // if: pClusRefObject != NULL

    return _hr;

} //*** CClusVersion::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_Name
//
//  Description:
//      Return the name of the cluster.
//
//  Arguments:
//      pbstrClusterName    [OUT]   - Catches the name of this cluster.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_Name( OUT BSTR * pbstrClusterName )
{
    //ASSERT( pbstrClusterName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrClusterName != NULL )
    {
        *pbstrClusterName = m_bstrClusterName.Copy();
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_VendorId
//
//  Description:
//      Return the vendor ID from the CLUSTERVERSIONINFO struct.
//
//  Arguments:
//      pbstrVendorId   [OUT]   - Catches the value of the vendo id.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_VendorId( OUT BSTR * pbstrVendorId )
{
    //ASSERT( pbstrVendorId != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrVendorId != NULL )
    {
        *pbstrVendorId = ::SysAllocString( m_clusinfo.szVendorId );
        if ( *pbstrVendorId == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

}   //*** CClusVersion::get_VendorId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_CSDVersion
//
//  Description:
//      Return the value the CSDVersion from the CLUSTERVERSIONINFO struct.
//
//  Arguments:
//      pbstrCSDVersion [OUT]   - Catches the value of CSDVersion.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_CSDVersion( OUT BSTR * pbstrCSDVersion )
{
    //ASSERT( pbstrCSDVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrCSDVersion != NULL )
    {
        *pbstrCSDVersion = ::SysAllocString( m_clusinfo.szCSDVersion );
        if ( *pbstrCSDVersion == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

}   //*** CClusVersion::get_CSDVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_MajorVersion
//
//  Description:
//      Returns the cluster major version.
//
//  Arguments:
//      pnMajorVersion  [OUT]   - Catches the cluster major version value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_MajorVersion( OUT long * pnMajorVersion )
{
    //ASSERT( pnMajorVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnMajorVersion != NULL )
    {
        *pnMajorVersion = m_clusinfo.MajorVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_MajorVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_MinorVersion
//
//  Description:
//      Returns the cluster minor version.
//
//  Arguments:
//      pnMinorVersion  [OUT]   - Catches the cluster minor version value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_MinorVersion( OUT long * pnMinorVersion )
{
    //ASSERT( pnMinorVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnMinorVersion != NULL )
    {
        *pnMinorVersion = m_clusinfo.MinorVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_MinorVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_BuildNumber
//
//  Description:
//      Returns the value of the cluster build number.
//
//  Arguments:
//      pnBuildNumber   [OUT]   - Catches the build number.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_BuildNumber( OUT short * pnBuildNumber )
{
    //ASSERT( pnBuildNumber != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnBuildNumber != NULL )
    {
        *pnBuildNumber = m_clusinfo.BuildNumber;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_BuildNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_ClusterHighestVersion
//
//  Description:
//      Returns the value of the highest cluster version.
//
//  Arguments:
//      pnClusterHighestVersion [OUT]   - Catches the value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_ClusterHighestVersion(
    OUT long * pnClusterHighestVersion
    )
{
    //ASSERT( pnClusterHighestVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnClusterHighestVersion != NULL )
    {
        *pnClusterHighestVersion = m_clusinfo.dwClusterHighestVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_ClusterHighestVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_ClusterLowestVersion
//
//  Description:
//      Returns the value of the lowest cluster version.
//
//  Arguments:
//      pnClusterLowestVersion  [OUT]   - Catches the value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_ClusterLowestVersion(
    OUT long * pnClusterLowestVersion
    )
{
    //ASSERT( pnClusterLowestVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnClusterLowestVersion != NULL )
    {
        *pnClusterLowestVersion = m_clusinfo.dwClusterLowestVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_ClusterLowestVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_Flags
//
//  Description:
//      Get the CLUSTERINFO.dwFlags value.
//
//  Arguments:
//      pnFlags [OUT]   - Catches the flags value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_Flags( OUT long * pnFlags )
{
    //ASSERT( pnFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnFlags != NULL )
    {
        *pnFlags = m_clusinfo.dwFlags;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_Flags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_MixedVersion
//
//  Description:
//      Is this cluster composed of mixed version nodes?
//
//  Arguments:
//      pvarMixedVersion    [OUT]   - Catches the mixed version state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_MixedVersion( OUT VARIANT * pvarMixedVersion )
{
    //ASSERT( pvarMixedVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarMixedVersion != NULL )
    {
        pvarMixedVersion->vt = VT_BOOL;

        if ( m_clusinfo.dwFlags & CLUSTER_VERSION_FLAG_MIXED_MODE )
        {
            pvarMixedVersion->boolVal = VARIANT_TRUE;
        } // if: the mixed version bit is set...
        else
        {
            pvarMixedVersion->boolVal = VARIANT_FALSE;
        } // else: the mixed version bit is not set...

        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_MixedVersion()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vbscript\msclusdisp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright 	1998 Microsoft Corporation
//
//	Module Name:
//		MSClusDisp.h
//
//	Abstract:
//		Definition of the MSClus DISPIDs
//
//	Implementation File:
//		None.
//
//	Author:
//		Galen Barbee (galenb) 02-Oct-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef	_MSCLUSDISP_H_

#define DISPID_CLUSOBJ_NAME			( ( 0x40 << 24 ) | ( 1 << 16 ) | 1 )
#define DISPID_CLUSTER_NAME			( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )
#define DISPID_CLUSNETWORK_NAME		( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )
#define DISPID_CLUSRESGROUP_NAME	( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )
#define DISPID_CLUSRESOURCE_NAME	( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )

#define	_MSCLUSDISP_H_

#endif // _MSCLUSDISP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\clustest.h ===
// clustest.h : main header file for the CLUSTEST application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CClustestApp:
// See clustest.cpp for the implementation of this class
//

class CClustestApp : public CWinApp
{
public:
	CClustestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClustestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CClustestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\clusdlg.cpp ===
// clustestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "clustest.h"
#include "clusDlg.h"
#include "msclus.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClustestDlg dialog

CClustestDlg::CClustestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CClustestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CClustestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CClustestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClustestDlg)
	DDX_Control(pDX, IDC_TREE1, m_ClusTree);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CClustestDlg, CDialog)
	//{{AFX_MSG_MAP(CClustestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClustestDlg message handlers

BOOL CClustestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
    EnumerateCluster();
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CClustestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CClustestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CClustestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

BOOL CClustestDlg::EnumerateCluster()
{
	COleException e;
	CLSID clsid;
    long nDomainCnt, nClusterCnt, nGroupCnt, nResCnt;
	IClusterApplication ClusterApp;
	DomainNames DomainList;
	ClusterNames	ClusterList;
	VARIANT v;
    CString strDomainName, strClusterName, strGroupName,strResourceName;
    ICluster m_Cluster;
    HTREEITEM hItem,hDomainItem, hClustersItem,hClusterItem, hGroupsItem, hGroupItem;
    HTREEITEM hResourcesItem, hResourceItem;
	try
	{
	    if (CLSIDFromProgID(OLESTR("MSCluster.Application"), &clsid) == NOERROR)
	    {
		    if (ClusterApp.CreateDispatch(clsid, &e))
		    {
			    DomainList.AttachDispatch(ClusterApp.GetDomainNames());
			    nDomainCnt = DomainList.GetCount();
                hItem = AddItem(_T("Domains"), NULL,TRUE);
			    while(nDomainCnt >0)
			    {
				    strDomainName = DomainList.GetItem(nDomainCnt--);
                    ClusterList.AttachDispatch(ClusterApp.GetClusterNames(strDomainName));
			        nClusterCnt = ClusterList.GetCount();
                    hDomainItem = AddItem(strDomainName.GetBuffer(strDomainName.GetLength()), hItem,TRUE);
                    strDomainName.ReleaseBuffer(-1);
                    if(nClusterCnt == 0)
                        return FALSE;
                    hClustersItem = AddItem(_T("Clusters"), hDomainItem, TRUE);
			        while(nClusterCnt > 1)
			        {
				        strClusterName = ClusterList.GetItem(nClusterCnt--);
                        hClusterItem = AddItem(strClusterName.GetBuffer(strClusterName.GetLength()), hClustersItem,TRUE);
                        strClusterName.ReleaseBuffer(-1);
		                m_Cluster.AttachDispatch(ClusterApp.OpenCluster(strClusterName));
            		    ClusResGroups ClusGroups(m_Cluster.GetResourceGroups());
                        nGroupCnt = ClusGroups.GetCount();
                        if(nGroupCnt == 0)
                            return FALSE;
                        hGroupsItem = AddItem(_T("Groups"), hClusterItem,TRUE);
                        while(nGroupCnt >0)
                        {
			                v.lVal = nGroupCnt--;
			                v.vt = VT_I4 ;
             		        ClusResGroup ClusGroup(ClusGroups.GetItem(v));
                            strGroupName = ClusGroup.GetName();
                            hGroupItem = AddItem(strGroupName.GetBuffer(strGroupName.GetLength()), hGroupsItem,TRUE);
                            strGroupName.ReleaseBuffer(-1);
                            ClusGroupResources Resources(ClusGroup.GetResources());
                            nResCnt = Resources.GetCount();
                            if(nResCnt ==0)
                                return FALSE;
                            hResourcesItem = AddItem(_T("Resources"), hGroupItem,TRUE);
                            while(nResCnt >0)
                            {
			                    v.lVal = nResCnt--;
			                    v.vt = VT_I4 ;
                                ClusResource Resource(Resources.GetItem(v));
                                strResourceName = Resource.GetName();
                                hResourceItem = AddItem(strResourceName.GetBuffer(strResourceName.GetLength()), hResourcesItem,FALSE);
                                strResourceName.ReleaseBuffer(-1);
                            }
                        }
                    }
                }

	        }
		    
	    }
    }
	catch(CException *e)
	{
		e->ReportError();
		e->Delete();
	}
    return TRUE;
}

HTREEITEM CClustestDlg::AddItem(LPTSTR pStrName, HTREEITEM pParent,BOOL bHasChildren)
{
    HTREEITEM hItem;
    TV_ITEM         tvi;                          // TreeView Item.
    TV_INSERTSTRUCT tvins;                        // TreeView Insert Struct.
    tvins.hParent = pParent;
    tvins.hInsertAfter = TVI_LAST;
    tvi.cChildren=1;
    tvi.mask = TVIF_TEXT;
    tvi.pszText    = pStrName;
    tvi.cchTextMax = _tcslen(pStrName) * sizeof(TCHAR);
    if(bHasChildren)
        tvi.mask |= TVIF_CHILDREN;
    tvins.item = tvi;
    hItem = m_ClusTree.InsertItem(&tvins);
    return hItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by clustest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDS_ABOUTBOX                    101
#define IDD_CLUSTEST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_TREE1                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	clustest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\msclus.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "msclus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// IClusterApplication properties

/////////////////////////////////////////////////////////////////////////////
// IClusterApplication operations

unsigned long IClusterApplication::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long IClusterApplication::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH IClusterApplication::GetDomainNames()
{
	LPDISPATCH result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH IClusterApplication::GetClusterNames(LPCTSTR bstrDomainName)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		bstrDomainName);
	return result;
}

LPDISPATCH IClusterApplication::OpenCluster(LPCTSTR bstrClusterName)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrClusterName);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// DomainNames properties

/////////////////////////////////////////////////////////////////////////////
// DomainNames operations

unsigned long DomainNames::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long DomainNames::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long DomainNames::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN DomainNames::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void DomainNames::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

CString DomainNames::GetItem(long nIndex)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		nIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusObjCollection properties

/////////////////////////////////////////////////////////////////////////////
// ClusObjCollection operations

unsigned long ClusObjCollection::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusObjCollection::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusObjCollection::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusObjCollection::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusObjCollection::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// ClusterNames properties

/////////////////////////////////////////////////////////////////////////////
// ClusterNames operations

unsigned long ClusterNames::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusterNames::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusterNames::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusterNames::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusterNames::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

CString ClusterNames::GetItem(long nIndex)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		nIndex);
	return result;
}

CString ClusterNames::GetDomainName()
{
	CString result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ICluster properties

/////////////////////////////////////////////////////////////////////////////
// ICluster operations

unsigned long ICluster::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ICluster::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ICluster::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ICluster::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ICluster::Open(LPCTSTR bstrClusterName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrClusterName);
}

void ICluster::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

void ICluster::GetVersion(BSTR* pbstrClusterName, short* MajorVersion, short* MinorVersion, short* BuildNumber, BSTR* pbstrVendorId, BSTR* pbstrCSDVersion)
{
	static BYTE parms[] =
		VTS_PBSTR VTS_PI2 VTS_PI2 VTS_PI2 VTS_PBSTR VTS_PBSTR;
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pbstrClusterName, MajorVersion, MinorVersion, BuildNumber, pbstrVendorId, pbstrCSDVersion);
}

void ICluster::SetQuorumResource(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

LPDISPATCH ICluster::GetQuorumResource()
{
	LPDISPATCH result;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

void ICluster::SetQuorumInfo(LPCTSTR DevicePath, long nLogSize)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x60030006, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 DevicePath, nLogSize);
}

void ICluster::GetQuorumInfo(BSTR* DevicePath, long* pLogSize)
{
	static BYTE parms[] =
		VTS_PBSTR VTS_PI4;
	InvokeHelper(0x60030007, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 DevicePath, pLogSize);
}

LPDISPATCH ICluster::GetNodes()
{
	LPDISPATCH result;
	InvokeHelper(0x60030008, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetResourceGroups()
{
	LPDISPATCH result;
	InvokeHelper(0x60030009, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetResources()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000a, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetResourceTypes()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000b, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetNetworks()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000c, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetNetInterfaces()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000d, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusObj properties

/////////////////////////////////////////////////////////////////////////////
// ClusObj operations

unsigned long ClusObj::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusObj::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusObj::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusProperties properties

/////////////////////////////////////////////////////////////////////////////
// ClusProperties operations

unsigned long ClusProperties::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusProperties::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusProperties::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusProperties::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusProperties::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusProperties::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusProperties::Add(LPCTSTR bstrName, const VARIANT& varValue)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrName, &varValue);
	return result;
}

void ClusProperties::Remove(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}

void ClusProperties::SaveChanges()
{
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// ClusProperty properties

/////////////////////////////////////////////////////////////////////////////
// ClusProperty operations

unsigned long ClusProperty::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusProperty::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusProperty::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

VARIANT ClusProperty::GetValue()
{
	VARIANT result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_VARIANT, (void*)&result, NULL);
	return result;
}

void ClusProperty::SetValue(const VARIANT& newValue)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 &newValue);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResource properties

/////////////////////////////////////////////////////////////////////////////
// ClusResource operations

unsigned long ClusResource::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResource::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusResource::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusResource::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusResource::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long ClusResource::GetState()
{
	long result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusResource::BecomeQuorumResource(LPCTSTR bstrDevicePath, long lMaxLogSize)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrDevicePath, lMaxLogSize);
}

void ClusResource::Delete()
{
	InvokeHelper(0x60030004, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusResource::Fail()
{
	InvokeHelper(0x60030005, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusResource::Online(long nTimeout, long* bPending)
{
	static BYTE parms[] =
		VTS_I4 VTS_PI4;
	InvokeHelper(0x60030006, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nTimeout, bPending);
}

void ClusResource::Offline(long nTimeout, long* bPending)
{
	static BYTE parms[] =
		VTS_I4 VTS_PI4;
	InvokeHelper(0x60030007, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nTimeout, bPending);
}

void ClusResource::ChangeResourceGroup(LPDISPATCH pResourceGroup)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030008, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pResourceGroup);
}

void ClusResource::AddResourceNode(LPDISPATCH pNode)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030009, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pNode);
}

void ClusResource::RemoveResourceNode(LPDISPATCH pNode)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x6003000a, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pNode);
}

long ClusResource::CanResourceBeDependent(LPDISPATCH pResource)
{
	long result;
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x6003000b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pResource);
	return result;
}

LPDISPATCH ClusResource::GetPossibleOwnerNodes()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000c, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetDependencies()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000d, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetGroup()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000e, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetOwnerNode()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000f, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030010, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResGroup properties

/////////////////////////////////////////////////////////////////////////////
// ClusResGroup operations

unsigned long ClusResGroup::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResGroup::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusResGroup::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusResGroup::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusResGroup::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long ClusResGroup::GetState()
{
	long result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetOwnerNode()
{
	LPDISPATCH result;
	InvokeHelper(0x60030003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetResources()
{
	LPDISPATCH result;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetPreferredOwnerNodes()
{
	LPDISPATCH result;
	InvokeHelper(0x60030005, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

void ClusResGroup::SetPreferredOwnerNodes()
{
	InvokeHelper(0x60030006, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusResGroup::Delete()
{
	InvokeHelper(0x60030007, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long ClusResGroup::Online(long nTimeout, LPDISPATCH pDestinationNode)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_DISPATCH;
	InvokeHelper(0x60030008, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		nTimeout, pDestinationNode);
	return result;
}

long ClusResGroup::Move(long nTimeout, LPDISPATCH pDestinationNode)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_DISPATCH;
	InvokeHelper(0x60030009, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		nTimeout, pDestinationNode);
	return result;
}

long ClusResGroup::Offline(long nTimeout)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6003000a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		nTimeout);
	return result;
}

LPDISPATCH ClusResGroup::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000b, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNode properties

/////////////////////////////////////////////////////////////////////////////
// ClusNode operations

unsigned long ClusNode::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNode::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNode::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusNode::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNode::GetNodeID()
{
	CString result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long ClusNode::GetState()
{
	long result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusNode::Pause()
{
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusNode::Resume()
{
	InvokeHelper(0x60030004, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusNode::Evict()
{
	InvokeHelper(0x60030005, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNode::GetResourceGroups()
{
	LPDISPATCH result;
	InvokeHelper(0x60030006, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030007, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetNetInterfaces()
{
	LPDISPATCH result;
	InvokeHelper(0x60030008, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResGroups properties

/////////////////////////////////////////////////////////////////////////////
// ClusResGroups operations

unsigned long ClusResGroups::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResGroups::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResGroups::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResGroups::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResGroups::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResGroups::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResGroups::CreateItem(LPCTSTR bstrResourceGroupName)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceGroupName);
	return result;
}

void ClusResGroups::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusNodeNetInterfaces properties

/////////////////////////////////////////////////////////////////////////////
// ClusNodeNetInterfaces operations

unsigned long ClusNodeNetInterfaces::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNodeNetInterfaces::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNodeNetInterfaces::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNodeNetInterfaces::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNodeNetInterfaces::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNodeNetInterfaces::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetInterface properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetInterface operations

unsigned long ClusNetInterface::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetInterface::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNetInterface::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusNetInterface::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetInterface::GetState()
{
	long result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusGroupResources properties

/////////////////////////////////////////////////////////////////////////////
// ClusGroupResources operations

unsigned long ClusGroupResources::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusGroupResources::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusGroupResources::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusGroupResources::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusGroupResources::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusGroupResources::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusGroupResources::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrResourceType, dwFlags);
	return result;
}

void ClusGroupResources::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusGroupOwners properties

/////////////////////////////////////////////////////////////////////////////
// ClusGroupOwners operations

unsigned long ClusGroupOwners::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusGroupOwners::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusGroupOwners::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusGroupOwners::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusGroupOwners::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusGroupOwners::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

void ClusGroupOwners::InsertItem(LPDISPATCH pClusNode, long nPosition)
{
	static BYTE parms[] =
		VTS_DISPATCH VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pClusNode, nPosition);
}

void ClusGroupOwners::RemoveItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResOwners properties

/////////////////////////////////////////////////////////////////////////////
// ClusResOwners operations

unsigned long ClusResOwners::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResOwners::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResOwners::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResOwners::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResOwners::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResOwners::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

void ClusResOwners::AddItem(LPDISPATCH pNode)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pNode);
}

void ClusResOwners::RemoveItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResDependencies properties

/////////////////////////////////////////////////////////////////////////////
// ClusResDependencies operations

unsigned long ClusResDependencies::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResDependencies::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResDependencies::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResDependencies::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResDependencies::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResDependencies::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResDependencies::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrResourceType, bstrGroupName, dwFlags);
	return result;
}

void ClusResDependencies::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}

void ClusResDependencies::AddItem(LPDISPATCH pResource)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pResource);
}

void ClusResDependencies::RemoveItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030004, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusNodes properties

/////////////////////////////////////////////////////////////////////////////
// ClusNodes operations

unsigned long ClusNodes::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNodes::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNodes::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNodes::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNodes::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNodes::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResources properties

/////////////////////////////////////////////////////////////////////////////
// ClusResources operations

unsigned long ClusResources::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResources::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResources::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResources::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResources::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResources::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResources::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrResourceType, bstrGroupName, dwFlags);
	return result;
}

void ClusResources::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResTypes properties

/////////////////////////////////////////////////////////////////////////////
// ClusResTypes operations

unsigned long ClusResTypes::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResTypes::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResTypes::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResTypes::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResTypes::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResTypes::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResTypes::CreateItem(LPCTSTR bstrResourceTypeName, LPCTSTR bstrDisplayName, LPCTSTR bstrResourceTypeDll, long dwLooksAlivePollInterval, long dwIsAlivePollInterval)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4 VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceTypeName, bstrDisplayName, bstrResourceTypeDll, dwLooksAlivePollInterval, dwIsAlivePollInterval);
	return result;
}

void ClusResTypes::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResType properties

/////////////////////////////////////////////////////////////////////////////
// ClusResType operations

unsigned long ClusResType::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResType::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusResType::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

void ClusResType::Delete()
{
	InvokeHelper(0x60030000, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResType::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetResources()
{
	LPDISPATCH result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResTypeResources properties

/////////////////////////////////////////////////////////////////////////////
// ClusResTypeResources operations

unsigned long ClusResTypeResources::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResTypeResources::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResTypeResources::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResTypeResources::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResTypeResources::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResTypeResources::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResTypeResources::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrGroupName, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrGroupName, dwFlags);
	return result;
}

void ClusResTypeResources::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetworks properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetworks operations

unsigned long ClusNetworks::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetworks::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetworks::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNetworks::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNetworks::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNetworks::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetwork properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetwork operations

unsigned long ClusNetwork::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetwork::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNetwork::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusNetwork::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusNetwork::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

CString ClusNetwork::GetNetworkID()
{
	CString result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long ClusNetwork::GetState()
{
	long result;
	InvokeHelper(0x60030003, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetNetInterfaces()
{
	LPDISPATCH result;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030005, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetworkNetInterfaces properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetworkNetInterfaces operations

unsigned long ClusNetworkNetInterfaces::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetworkNetInterfaces::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetworkNetInterfaces::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNetworkNetInterfaces::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNetworkNetInterfaces::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNetworkNetInterfaces::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetInterfaces properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetInterfaces operations

unsigned long ClusNetInterfaces::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetInterfaces::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetInterfaces::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNetInterfaces::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNetInterfaces::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNetInterfaces::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\clustest.cpp ===
// clustest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "clustest.h"
#include "clusDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClustestApp

BEGIN_MESSAGE_MAP(CClustestApp, CWinApp)
	//{{AFX_MSG_MAP(CClustestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClustestApp construction

CClustestApp::CClustestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CClustestApp object

CClustestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CClustestApp initialization

BOOL CClustestApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Parse the command line to see if launched as OLE server
	if (RunEmbedded() || RunAutomated())
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	COleObjectFactory::UpdateRegistryAll();

	CClustestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\clusdlg.h ===
// clustestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClustestDlg dialog

class CClustestDlg : public CDialog
{
// Construction
public:
	CClustestDlg(CWnd* pParent = NULL);	// standard constructor
	BOOL EnumerateCluster();
    HTREEITEM AddItem(LPTSTR pStrName, HTREEITEM pParent,BOOL bHasChildren);

// Dialog Data
	//{{AFX_DATA(CClustestDlg)
	enum { IDD = IDD_CLUSTEST_DIALOG };
	CTreeCtrl	m_ClusTree;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClustestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CClustestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\msclus\vctest\msclus.h ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// IClusterApplication wrapper class

class IClusterApplication : public COleDispatchDriver
{
public:
	IClusterApplication() {}		// Calls COleDispatchDriver default constructor
	IClusterApplication(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	IClusterApplication(const IClusterApplication& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	LPDISPATCH GetDomainNames();
	LPDISPATCH GetClusterNames(LPCTSTR bstrDomainName);
	LPDISPATCH OpenCluster(LPCTSTR bstrClusterName);
};
/////////////////////////////////////////////////////////////////////////////
// DomainNames wrapper class

class DomainNames : public COleDispatchDriver
{
public:
	DomainNames() {}		// Calls COleDispatchDriver default constructor
	DomainNames(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	DomainNames(const DomainNames& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	CString GetItem(long nIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusObjCollection wrapper class

class ClusObjCollection : public COleDispatchDriver
{
public:
	ClusObjCollection() {}		// Calls COleDispatchDriver default constructor
	ClusObjCollection(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusObjCollection(const ClusObjCollection& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
};
/////////////////////////////////////////////////////////////////////////////
// ClusterNames wrapper class

class ClusterNames : public COleDispatchDriver
{
public:
	ClusterNames() {}		// Calls COleDispatchDriver default constructor
	ClusterNames(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusterNames(const ClusterNames& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	CString GetItem(long nIndex);
	CString GetDomainName();
};
/////////////////////////////////////////////////////////////////////////////
// ICluster wrapper class

class ICluster : public COleDispatchDriver
{
public:
	ICluster() {}		// Calls COleDispatchDriver default constructor
	ICluster(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ICluster(const ICluster& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void Open(LPCTSTR bstrClusterName);
	void SetName(LPCTSTR lpszNewValue);
	void GetVersion(BSTR* pbstrClusterName, short* MajorVersion, short* MinorVersion, short* BuildNumber, BSTR* pbstrVendorId, BSTR* pbstrCSDVersion);
	void SetQuorumResource(LPDISPATCH newValue);
	LPDISPATCH GetQuorumResource();
	void SetQuorumInfo(LPCTSTR DevicePath, long nLogSize);
	void GetQuorumInfo(BSTR* DevicePath, long* pLogSize);
	LPDISPATCH GetNodes();
	LPDISPATCH GetResourceGroups();
	LPDISPATCH GetResources();
	LPDISPATCH GetResourceTypes();
	LPDISPATCH GetNetworks();
	LPDISPATCH GetNetInterfaces();
};
/////////////////////////////////////////////////////////////////////////////
// ClusObj wrapper class

class ClusObj : public COleDispatchDriver
{
public:
	ClusObj() {}		// Calls COleDispatchDriver default constructor
	ClusObj(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusObj(const ClusObj& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
};
/////////////////////////////////////////////////////////////////////////////
// ClusProperties wrapper class

class ClusProperties : public COleDispatchDriver
{
public:
	ClusProperties() {}		// Calls COleDispatchDriver default constructor
	ClusProperties(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusProperties(const ClusProperties& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH Add(LPCTSTR bstrName, const VARIANT& varValue);
	void Remove(const VARIANT& varIndex);
	void SaveChanges();
};
/////////////////////////////////////////////////////////////////////////////
// ClusProperty wrapper class

class ClusProperty : public COleDispatchDriver
{
public:
	ClusProperty() {}		// Calls COleDispatchDriver default constructor
	ClusProperty(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusProperty(const ClusProperty& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	VARIANT GetValue();
	void SetValue(const VARIANT& newValue);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResource wrapper class

class ClusResource : public COleDispatchDriver
{
public:
	ClusResource() {}		// Calls COleDispatchDriver default constructor
	ClusResource(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResource(const ClusResource& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void SetName(LPCTSTR lpszNewValue);
	long GetState();
	void BecomeQuorumResource(LPCTSTR bstrDevicePath, long lMaxLogSize);
	void Delete();
	void Fail();
	void Online(long nTimeout, long* bPending);
	void Offline(long nTimeout, long* bPending);
	void ChangeResourceGroup(LPDISPATCH pResourceGroup);
	void AddResourceNode(LPDISPATCH pNode);
	void RemoveResourceNode(LPDISPATCH pNode);
	long CanResourceBeDependent(LPDISPATCH pResource);
	LPDISPATCH GetPossibleOwnerNodes();
	LPDISPATCH GetDependencies();
	LPDISPATCH GetGroup();
	LPDISPATCH GetOwnerNode();
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusResGroup wrapper class

class ClusResGroup : public COleDispatchDriver
{
public:
	ClusResGroup() {}		// Calls COleDispatchDriver default constructor
	ClusResGroup(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResGroup(const ClusResGroup& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void SetName(LPCTSTR lpszNewValue);
	long GetState();
	LPDISPATCH GetOwnerNode();
	LPDISPATCH GetResources();
	LPDISPATCH GetPreferredOwnerNodes();
	void SetPreferredOwnerNodes();
	void Delete();
	long Online(long nTimeout, LPDISPATCH pDestinationNode);
	long Move(long nTimeout, LPDISPATCH pDestinationNode);
	long Offline(long nTimeout);
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusNode wrapper class

class ClusNode : public COleDispatchDriver
{
public:
	ClusNode() {}		// Calls COleDispatchDriver default constructor
	ClusNode(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNode(const ClusNode& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	CString GetNodeID();
	long GetState();
	void Pause();
	void Resume();
	void Evict();
	LPDISPATCH GetResourceGroups();
	LPDISPATCH GetCluster();
	LPDISPATCH GetNetInterfaces();
};
/////////////////////////////////////////////////////////////////////////////
// ClusResGroups wrapper class

class ClusResGroups : public COleDispatchDriver
{
public:
	ClusResGroups() {}		// Calls COleDispatchDriver default constructor
	ClusResGroups(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResGroups(const ClusResGroups& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceGroupName);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNodeNetInterfaces wrapper class

class ClusNodeNetInterfaces : public COleDispatchDriver
{
public:
	ClusNodeNetInterfaces() {}		// Calls COleDispatchDriver default constructor
	ClusNodeNetInterfaces(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNodeNetInterfaces(const ClusNodeNetInterfaces& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetInterface wrapper class

class ClusNetInterface : public COleDispatchDriver
{
public:
	ClusNetInterface() {}		// Calls COleDispatchDriver default constructor
	ClusNetInterface(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetInterface(const ClusNetInterface& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	long GetState();
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusGroupResources wrapper class

class ClusGroupResources : public COleDispatchDriver
{
public:
	ClusGroupResources() {}		// Calls COleDispatchDriver default constructor
	ClusGroupResources(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusGroupResources(const ClusGroupResources& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not e